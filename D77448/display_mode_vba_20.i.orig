# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 349 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/include/linux/kconfig.h" 1






# 1 "./include/generated/autoconf.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/kconfig.h" 2
# 2 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 1
# 59 "/home/nathan/src/linux-next/include/linux/compiler_types.h"
# 1 "/home/nathan/src/linux-next/include/linux/compiler_attributes.h" 1
# 60 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/compiler-clang.h" 1
# 64 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 2
# 85 "/home/nathan/src/linux-next/include/linux/compiler_types.h"
struct ftrace_branch_data {
 const char *func;
 const char *file;
 unsigned line;
 union {
  struct {
   unsigned long correct;
   unsigned long incorrect;
  };
  struct {
   unsigned long miss;
   unsigned long hit;
  };
  unsigned long miss_hit[2];
 };
};

struct ftrace_likely_data {
 struct ftrace_branch_data data;
 unsigned long constant;
};
# 3 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c" 2
# 26 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 1
# 28 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h" 1
# 34 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h" 1
# 32 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"
# 1 "/home/nathan/src/linux-next/include/linux/tracepoint.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/tracepoint.h"
# 1 "/home/nathan/src/linux-next/include/linux/smp.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/smp.h"
# 1 "/home/nathan/src/linux-next/include/linux/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/errno.h" 1
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno-base.h" 1
# 6 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno.h" 2
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/errno.h" 2
# 2 "/home/nathan/src/linux-next/include/uapi/linux/errno.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/errno.h" 2
# 11 "/home/nathan/src/linux-next/include/linux/smp.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/types.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h" 1
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h" 1
# 12 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitsperlong.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/bitsperlong.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/bitsperlong.h" 2
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h" 2
# 13 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h" 2







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 12 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h" 2




typedef __s8 s8;
typedef __u8 u8;
typedef __s16 s16;
typedef __u16 u16;
typedef __s32 s32;
typedef __u32 u32;
typedef __s64 s64;
typedef __u64 u64;
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h" 2





typedef struct {
 __u32 u[4];
} __attribute__((aligned(16))) __vector128;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h" 2
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h"
typedef __vector128 vector128;

typedef struct {
 unsigned long entry;
 unsigned long toc;
 unsigned long env;
} func_descr_t;
# 6 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 2








# 1 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/stddef.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/stddef.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/stddef.h" 2




enum {
 false = 0,
 true = 1
};
# 6 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 2
# 25 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h"
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h"
typedef unsigned long __kernel_old_dev_t;
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h" 1
# 15 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;



typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;
# 72 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;



typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 25 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h" 2
# 37 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 2
# 15 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 2
# 29 "/home/nathan/src/linux-next/include/uapi/linux/types.h"
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 52 "/home/nathan/src/linux-next/include/uapi/linux/types.h"
typedef unsigned __poll_t;
# 7 "/home/nathan/src/linux-next/include/linux/types.h" 2






typedef u32 __kernel_dev_t;

typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef unsigned short umode_t;
typedef u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;

typedef unsigned long uintptr_t;
# 46 "/home/nathan/src/linux-next/include/linux/types.h"
typedef __kernel_loff_t loff_t;
# 55 "/home/nathan/src/linux-next/include/linux/types.h"
typedef __kernel_size_t size_t;




typedef __kernel_ssize_t ssize_t;




typedef __kernel_ptrdiff_t ptrdiff_t;




typedef __kernel_clock_t clock_t;




typedef __kernel_caddr_t caddr_t;



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;




typedef u8 u_int8_t;
typedef s8 int8_t;
typedef u16 u_int16_t;
typedef s16 int16_t;
typedef u32 u_int32_t;
typedef s32 int32_t;



typedef u8 uint8_t;
typedef u16 uint16_t;
typedef u32 uint32_t;


typedef u64 uint64_t;
typedef u64 u_int64_t;
typedef s64 int64_t;
# 125 "/home/nathan/src/linux-next/include/linux/types.h"
typedef u64 sector_t;
typedef u64 blkcnt_t;
# 143 "/home/nathan/src/linux-next/include/linux/types.h"
typedef u64 dma_addr_t;




typedef unsigned int gfp_t;
typedef unsigned int slab_flags_t;
typedef unsigned int fmode_t;


typedef u64 phys_addr_t;




typedef phys_addr_t resource_size_t;





typedef unsigned long irq_hw_number_t;

typedef struct {
 int counter;
} atomic_t;


typedef struct {
 s64 counter;
} atomic64_t;


struct list_head {
 struct list_head *next, *prev;
};

struct hlist_head {
 struct hlist_node *first;
};

struct hlist_node {
 struct hlist_node *next, **pprev;
};

struct ustat {
 __kernel_daddr_t f_tfree;
 __kernel_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];
};
# 214 "/home/nathan/src/linux-next/include/linux/types.h"
struct callback_head {
 struct callback_head *next;
 void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));


typedef void (*rcu_callback_t)(struct callback_head *head);
typedef void (*call_rcu_func_t)(struct callback_head *head, rcu_callback_t func);

typedef void (*swap_func_t)(void *a, void *b, int size);

typedef int (*cmp_r_func_t)(const void *a, const void *b, const void *priv);
typedef int (*cmp_func_t)(const void *a, const void *b);
# 12 "/home/nathan/src/linux-next/include/linux/smp.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/list.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/poison.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/const.h" 1



# 1 "/home/nathan/src/linux-next/include/vdso/const.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/const.h" 1
# 6 "/home/nathan/src/linux-next/include/vdso/const.h" 2
# 5 "/home/nathan/src/linux-next/include/linux/const.h" 2
# 9 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kernel.h" 1





# 1 "/home/nathan/cbl/github/tc-build/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 1 3
# 14 "/home/nathan/cbl/github/tc-build/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 3
typedef __builtin_va_list va_list;
# 32 "/home/nathan/cbl/github/tc-build/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 7 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/limits.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/limits.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/limits.h" 2

# 1 "/home/nathan/src/linux-next/include/vdso/limits.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/limits.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/linkage.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/stringify.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/export.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/export.h"
extern struct module __this_module;
# 72 "/home/nathan/src/linux-next/include/linux/export.h"
struct kernel_symbol {
 unsigned long value;
 const char *name;
 const char *namespace;
};
# 8 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/linkage.h" 1
# 9 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 9 "/home/nathan/src/linux-next/include/linux/kernel.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/compiler.h" 1
# 198 "/home/nathan/src/linux-next/include/linux/compiler.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-const.h" 1
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 2
# 100 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/barrier.h" 1
# 16 "/home/nathan/src/linux-next/include/asm-generic/barrier.h"
# 1 "/home/nathan/src/linux-next/include/linux/compiler.h" 1
# 17 "/home/nathan/src/linux-next/include/asm-generic/barrier.h" 2
# 101 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 2
# 199 "/home/nathan/src/linux-next/include/linux/compiler.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kasan-checks.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/kasan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __kasan_check_read(const volatile void *p, unsigned int size)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __kasan_check_write(const volatile void *p, unsigned int size)
{
 return true;
}
# 34 "/home/nathan/src/linux-next/include/linux/kasan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_check_read(const volatile void *p, unsigned int size)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_check_write(const volatile void *p, unsigned int size)
{
 return true;
}
# 200 "/home/nathan/src/linux-next/include/linux/compiler.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kcsan-checks.h" 1
# 148 "/home/nathan/src/linux-next/include/linux/kcsan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __kcsan_check_access(const volatile void *ptr, size_t size,
     int type) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_disable_current(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_enable_current(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_enable_current_nowarn(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_nestable_atomic_begin(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_nestable_atomic_end(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_flat_atomic_begin(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_flat_atomic_end(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_atomic_next(int n) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_set_access_mask(unsigned long mask) { }

struct kcsan_scoped_access { };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kcsan_scoped_access *
kcsan_begin_scoped_access(const volatile void *ptr, size_t size, int type,
     struct kcsan_scoped_access *sa) { return sa; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_end_scoped_access(struct kcsan_scoped_access *sa) { }
# 184 "/home/nathan/src/linux-next/include/linux/kcsan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_check_access(const volatile void *ptr, size_t size,
          int type) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __kcsan_enable_current(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __kcsan_disable_current(void) { }
# 201 "/home/nathan/src/linux-next/include/linux/compiler.h" 2
# 253 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__))
unsigned long __read_once_word_nocheck(const void *addr)
{
 return (*(const volatile typeof( _Generic((*(unsigned long *)addr), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*(unsigned long *)addr))) *)&(*(unsigned long *)addr));
}
# 274 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__))
unsigned long read_word_at_a_time(const void *addr)
{
 kasan_check_read(addr, 1);
 return *(unsigned long *)addr;
}
# 297 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *offset_to_ptr(const int *off)
{
 return (void *)((unsigned long)off + *off);
}
# 12 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/bitops.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/bits.h" 1





# 1 "/home/nathan/src/linux-next/include/vdso/bits.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/bits.h" 2
# 23 "/home/nathan/src/linux-next/include/linux/bits.h"
# 1 "/home/nathan/src/linux-next/include/linux/build_bug.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/bits.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/bitops.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/bitops.h"
extern unsigned int __sw_hweight8(unsigned int w);
extern unsigned int __sw_hweight16(unsigned int w);
extern unsigned int __sw_hweight32(unsigned int w);
extern unsigned long __sw_hweight64(__u64 w);






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 1
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-compat.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ppc-opcode.h" 1
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-compat.h" 2
# 43 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/synch.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/feature-fixups.h" 1
# 239 "/home/nathan/src/linux-next/arch/powerpc/include/asm/feature-fixups.h"
extern long stf_barrier_fallback;
extern long __start___stf_entry_barrier_fixup, __stop___stf_entry_barrier_fixup;
extern long __start___stf_exit_barrier_fixup, __stop___stf_exit_barrier_fixup;
extern long __start___rfi_flush_fixup, __stop___rfi_flush_fixup;
extern long __start___barrier_nospec_fixup, __stop___barrier_nospec_fixup;
extern long __start__btb_flush_fixup, __stop__btb_flush_fixup;

void apply_feature_fixups(void);
void setup_feature_keys(void);
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/synch.h" 2



extern unsigned int __start___lwsync_fixup, __stop___lwsync_fixup;
extern void do_lwsync_fixups(unsigned long value, void *fixup_start,
        void *fixup_end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eieio(void)
{
 __asm__ __volatile__ ("eieio" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void isync(void)
{
 __asm__ __volatile__ ("isync" : : : "memory");
}
# 44 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 82 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "or" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bits_unlock(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "lwsync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void change_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "xor" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_set_bit(int nr, volatile unsigned long *addr)
{
 set_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_clear_bit(int nr, volatile unsigned long *addr)
{
 clear_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_clear_bit_unlock(int nr, volatile unsigned long *addr)
{
 clear_bits_unlock(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_change_bit(int nr, volatile unsigned long *addr)
{
 change_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}
# 129 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_set_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "or" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_set_bits_lock( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n" "or" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_clear_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_change_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "xor" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_set_bit(unsigned long nr,
     volatile unsigned long *addr)
{
 return test_and_set_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_set_bit_lock(unsigned long nr,
          volatile unsigned long *addr)
{
 return test_and_set_bits_lock(((((1UL))) << ((nr) % 64)),
    addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_clear_bit(unsigned long nr,
       volatile unsigned long *addr)
{
 return test_and_clear_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_change_bit(unsigned long nr,
        volatile unsigned long *addr)
{
 return test_and_change_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
clear_bit_unlock_return_word(int nr, volatile unsigned long *addr)
{
 unsigned long old, t;
 unsigned long *p = (unsigned long *)addr + ((nr) / 64);
 unsigned long mask = ((((1UL))) << ((nr) % 64));

 __asm__ __volatile__ (
 "lwsync" " " "\n"
"1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n"
 "andc %1,%0,%2\n"
 "stdcx." " " "%1,0,%3\n"
 "bne- 1b\n"
 : "=&r" (old), "=&r" (t)
 : "r" (mask), "r" (p)
 : "cc", "memory");

 return old;
}
# 193 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h" 1
# 16 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p |= mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p &= ~mask;
}
# 41 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __change_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p ^= mask;
}
# 58 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_set_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old | mask;
 return (old & mask) != 0;
}
# 77 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_clear_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old & ~mask;
 return (old & mask) != 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_change_bit(int nr,
         volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old ^ mask;
 return (old & mask) != 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_bit(int nr, const volatile unsigned long *addr)
{
 return 1UL & (addr[((nr) / 64)] >> (nr & (64 -1)));
}
# 194 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch___clear_bit_unlock(int nr, volatile unsigned long *addr)
{
 __asm__ __volatile__("lwsync" " " "\n" "" ::: "memory");
 __clear_bit(nr, addr);
}








# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/ffz.h" 1
# 208 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__ffs.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__ffs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __ffs(unsigned long word)
{
 return __builtin_ctzl(word);
}
# 210 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-ffs.h" 1
# 13 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-ffs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int ffs(int x)
{
 return __builtin_ffs(x);
}
# 212 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fls(unsigned int x)
{
 return 32 - __builtin_clz(x);
}


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__fls.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__fls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __fls(unsigned long word)
{
 return (sizeof(word) * 8) - 1 - __builtin_clzl(word);
}
# 223 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fls64(__u64 x)
{
 return 64 - __builtin_clzll(x);
}


unsigned int __arch_hweight8(unsigned int w);
unsigned int __arch_hweight16(unsigned int w);
unsigned int __arch_hweight32(unsigned int w);
unsigned long __arch_hweight64(__u64 w);

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/const_hweight.h" 1
# 235 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2




# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h" 1
# 15 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(const unsigned long *addr, unsigned long
  size, unsigned long offset);
# 30 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_and_bit(const unsigned long *addr1,
  const unsigned long *addr2, unsigned long size,
  unsigned long offset);
# 45 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_zero_bit(const unsigned long *addr, unsigned
  long size, unsigned long offset);
# 93 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_clump8(unsigned long *clump,
          const unsigned long *addr,
          unsigned long size, unsigned long offset);
# 240 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h" 1
# 14 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
# 1 "/home/nathan/src/linux-next/include/linux/instrumented.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void instrument_read(const volatile void *v, size_t size)
{
 kasan_check_read(v, size);
 kcsan_check_access(v, size, 0);
}
# 39 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void instrument_write(const volatile void *v, size_t size)
{
 kasan_check_write(v, size);
 kcsan_check_access(v, size, 0x1);
}
# 54 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void instrument_atomic_read(const volatile void *v, size_t size)
{
 kasan_check_read(v, size);
 kcsan_check_access(v, size, 0x2);
}
# 69 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void instrument_atomic_write(const volatile void *v, size_t size)
{
 kasan_check_write(v, size);
 kcsan_check_access(v, size, 0x2 | 0x1);
}
# 85 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
instrument_copy_to_user(void *to, const void *from, unsigned long n)
{
 kasan_check_read(from, n);
 kcsan_check_access(from, n, 0);
}
# 102 "/home/nathan/src/linux-next/include/linux/instrumented.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
instrument_copy_from_user(const void *to, const void *from, unsigned long n)
{
 kasan_check_write(to, n);
 kcsan_check_access(to, n, 0x1);
}
# 15 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h" 2
# 26 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 arch_set_bit(nr, addr);
}
# 39 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 arch_clear_bit(nr, addr);
}
# 55 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void change_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 arch_change_bit(nr, addr);
}
# 68 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_set_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_set_bit(nr, addr);
}
# 81 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_clear_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_clear_bit(nr, addr);
}
# 94 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_change_bit(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_change_bit(nr, addr);
}
# 243 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h" 1
# 23 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit_unlock(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 arch_clear_bit_unlock(nr, addr);
}
# 38 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit_unlock(long nr, volatile unsigned long *addr)
{
 instrument_write(addr + ((nr) / 64), sizeof(long));
 arch___clear_bit_unlock(nr, addr);
}
# 53 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_set_bit_lock(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_set_bit_lock(nr, addr);
}
# 71 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
clear_bit_unlock_is_negative_byte(long nr, volatile unsigned long *addr)
{
 instrument_atomic_write(addr + ((nr) / 64), sizeof(long));
 return (clear_bit_unlock_return_word(nr, addr) & ((((1UL))) << ((7) % 64)));
}
# 244 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h"
# 1 "/home/nathan/src/linux-next/include/linux/byteorder/little_endian.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/little_endian.h" 1
# 13 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/little_endian.h"
# 1 "/home/nathan/src/linux-next/include/linux/swab.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/swab.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/swab.h" 1






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/swab.h" 1
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/swab.h" 2
# 9 "/home/nathan/src/linux-next/include/uapi/linux/swab.h" 2
# 48 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u16 __fswab16(__u16 val)
{



 return ((__u16)( (((__u16)(val) & (__u16)0x00ffU) << 8) | (((__u16)(val) & (__u16)0xff00U) >> 8)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswab32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x000000ffUL) << 24) | (((__u32)(val) & (__u32)0x0000ff00UL) << 8) | (((__u32)(val) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(val) & (__u32)0xff000000UL) >> 24)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u64 __fswab64(__u64 val)
{







 return ((__u64)( (((__u64)(val) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(val) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(val) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(val) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(val) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(val) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(val) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(val) & (__u64)0xff00000000000000ULL) >> 56)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswahw32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x0000ffffUL) << 16) | (((__u32)(val) & (__u32)0xffff0000UL) >> 16)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswahb32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(val) & (__u32)0xff00ff00UL) >> 8)));

}
# 136 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __swab(const unsigned long y)
{

 return (__builtin_constant_p((__u64)(y)) ? ((__u64)( (((__u64)(y) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(y) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(y) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(y) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(y) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(y) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(y) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(y) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(y));



}
# 171 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __swab16p(const __u16 *p)
{



 return (__builtin_constant_p((__u16)(*p)) ? ((__u16)( (((__u16)(*p) & (__u16)0x00ffU) << 8) | (((__u16)(*p) & (__u16)0xff00U) >> 8))) : __fswab16(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __swab32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x000000ffUL) << 24) | (((__u32)(*p) & (__u32)0x0000ff00UL) << 8) | (((__u32)(*p) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(*p) & (__u32)0xff000000UL) >> 24))) : __fswab32(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __swab64p(const __u64 *p)
{



 return (__builtin_constant_p((__u64)(*p)) ? ((__u64)( (((__u64)(*p) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(*p) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(*p) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(*p) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(*p) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(*p) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(*p) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(*p) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(*p));

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 __swahw32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x0000ffffUL) << 16) | (((__u32)(*p) & (__u32)0xffff0000UL) >> 16))) : __fswahw32(*p));

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 __swahb32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(*p) & (__u32)0xff00ff00UL) >> 8))) : __fswahb32(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swab16s(__u16 *p)
{



 *p = __swab16p(p);

}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __swab32s(__u32 *p)
{



 *p = __swab32p(p);

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __swab64s(__u64 *p)
{



 *p = __swab64p(p);

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swahw32s(__u32 *p)
{



 *p = __swahw32p(p);

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swahb32s(__u32 *p)
{



 *p = __swahb32p(p);

}
# 6 "/home/nathan/src/linux-next/include/linux/swab.h" 2
# 14 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/little_endian.h" 2
# 44 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/little_endian.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le64 __cpu_to_le64p(const __u64 *p)
{
 return ( __le64)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __le64_to_cpup(const __le64 *p)
{
 return ( __u64)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le32 __cpu_to_le32p(const __u32 *p)
{
 return ( __le32)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __le32_to_cpup(const __le32 *p)
{
 return ( __u32)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le16 __cpu_to_le16p(const __u16 *p)
{
 return ( __le16)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __le16_to_cpup(const __le16 *p)
{
 return ( __u16)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be64 __cpu_to_be64p(const __u64 *p)
{
 return ( __be64)__swab64p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __be64_to_cpup(const __be64 *p)
{
 return __swab64p((__u64 *)p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be32 __cpu_to_be32p(const __u32 *p)
{
 return ( __be32)__swab32p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __be32_to_cpup(const __be32 *p)
{
 return __swab32p((__u32 *)p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be16 __cpu_to_be16p(const __u16 *p)
{
 return ( __be16)__swab16p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __be16_to_cpup(const __be16 *p)
{
 return __swab16p((__u16 *)p);
}
# 6 "/home/nathan/src/linux-next/include/linux/byteorder/little_endian.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/byteorder/generic.h" 1
# 144 "/home/nathan/src/linux-next/include/linux/byteorder/generic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le16_add_cpu(__le16 *var, u16 val)
{
 *var = (( __le16)(__u16)((( __u16)(__le16)(*var)) + val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le32_add_cpu(__le32 *var, u32 val)
{
 *var = (( __le32)(__u32)((( __u32)(__le32)(*var)) + val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le64_add_cpu(__le64 *var, u64 val)
{
 *var = (( __le64)(__u64)((( __u64)(__le64)(*var)) + val));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le32_to_cpu_array(u32 *buf, unsigned int words)
{
 while (words--) {
  do { (void)(buf); } while (0);
  buf++;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_to_le32_array(u32 *buf, unsigned int words)
{
 while (words--) {
  do { (void)(buf); } while (0);
  buf++;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be16_add_cpu(__be16 *var, u16 val)
{
 *var = (( __be16)(__builtin_constant_p((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))) ? ((__u16)( (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0x00ffU) << 8) | (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0xff00U) >> 8))) : __fswab16(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be32_add_cpu(__be32 *var, u32 val)
{
 *var = (( __be32)(__builtin_constant_p((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))) ? ((__u32)( (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0xff000000UL) >> 24))) : __fswab32(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be64_add_cpu(__be64 *var, u64 val)
{
 *var = (( __be64)(__builtin_constant_p((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))) ? ((__u64)( (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)
{
 int i;

 for (i = 0; i < len; i++)
  dst[i] = (( __be32)(__builtin_constant_p((__u32)((src[i]))) ? ((__u32)( (((__u32)((src[i])) & (__u32)0x000000ffUL) << 24) | (((__u32)((src[i])) & (__u32)0x0000ff00UL) << 8) | (((__u32)((src[i])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((src[i])) & (__u32)0xff000000UL) >> 24))) : __fswab32((src[i]))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)
{
 int i;

 for (i = 0; i < len; i++)
  dst[i] = (__builtin_constant_p((__u32)(( __u32)(__be32)(src[i]))) ? ((__u32)( (((__u32)(( __u32)(__be32)(src[i])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(src[i])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(src[i])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(src[i])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(src[i])));
}
# 12 "/home/nathan/src/linux-next/include/linux/byteorder/little_endian.h" 2
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h" 2
# 7 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h" 2





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long find_next_zero_bit_le(const void *addr,
  unsigned long size, unsigned long offset)
{
 return find_next_zero_bit(addr, size, offset);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long find_next_bit_le(const void *addr,
  unsigned long size, unsigned long offset)
{
 return find_next_bit(addr, size, offset);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long find_first_zero_bit_le(const void *addr,
  unsigned long size)
{
 return find_next_zero_bit((addr), (size), 0);
}
# 53 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_bit_le(int nr, const void *addr)
{
 return test_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bit_le(int nr, void *addr)
{
 set_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit_le(int nr, void *addr)
{
 clear_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_bit_le(int nr, void *addr)
{
 __set_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit_le(int nr, void *addr)
{
 __clear_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_bit_le(int nr, void *addr)
{
 return test_and_set_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_bit_le(int nr, void *addr)
{
 return test_and_clear_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_set_bit_le(int nr, void *addr)
{
 return __test_and_set_bit(nr ^ 0, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_clear_bit_le(int nr, void *addr)
{
 return __test_and_clear_bit(nr ^ 0, addr);
}
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2



# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/ext2-atomic-setbit.h" 1
# 251 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h" 1
# 13 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sched_find_first_bit(const unsigned long *b)
{

 if (b[0])
  return __ffs(b[0]);
 return __ffs(b[1]) + 64;
# 30 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h"
}
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 30 "/home/nathan/src/linux-next/include/linux/bitops.h" 2
# 65 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_bitmask_order(unsigned int count)
{
 int order;

 order = fls(count);
 return order;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long hweight_long(unsigned long w)
{
 return sizeof(w) == 4 ? (__builtin_constant_p(w) ? ((((unsigned int) ((!!((w) & (1ULL << 0))) + (!!((w) & (1ULL << 1))) + (!!((w) & (1ULL << 2))) + (!!((w) & (1ULL << 3))) + (!!((w) & (1ULL << 4))) + (!!((w) & (1ULL << 5))) + (!!((w) & (1ULL << 6))) + (!!((w) & (1ULL << 7))))) + ((unsigned int) ((!!(((w) >> 8) & (1ULL << 0))) + (!!(((w) >> 8) & (1ULL << 1))) + (!!(((w) >> 8) & (1ULL << 2))) + (!!(((w) >> 8) & (1ULL << 3))) + (!!(((w) >> 8) & (1ULL << 4))) + (!!(((w) >> 8) & (1ULL << 5))) + (!!(((w) >> 8) & (1ULL << 6))) + (!!(((w) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!(((w) >> 16) & (1ULL << 0))) + (!!(((w) >> 16) & (1ULL << 1))) + (!!(((w) >> 16) & (1ULL << 2))) + (!!(((w) >> 16) & (1ULL << 3))) + (!!(((w) >> 16) & (1ULL << 4))) + (!!(((w) >> 16) & (1ULL << 5))) + (!!(((w) >> 16) & (1ULL << 6))) + (!!(((w) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!((((w) >> 16) >> 8) & (1ULL << 0))) + (!!((((w) >> 16) >> 8) & (1ULL << 1))) + (!!((((w) >> 16) >> 8) & (1ULL << 2))) + (!!((((w) >> 16) >> 8) & (1ULL << 3))) + (!!((((w) >> 16) >> 8) & (1ULL << 4))) + (!!((((w) >> 16) >> 8) & (1ULL << 5))) + (!!((((w) >> 16) >> 8) & (1ULL << 6))) + (!!((((w) >> 16) >> 8) & (1ULL << 7))))))) : __arch_hweight32(w)) : (__builtin_constant_p((__u64)w) ? (((((unsigned int) ((!!(((__u64)w) & (1ULL << 0))) + (!!(((__u64)w) & (1ULL << 1))) + (!!(((__u64)w) & (1ULL << 2))) + (!!(((__u64)w) & (1ULL << 3))) + (!!(((__u64)w) & (1ULL << 4))) + (!!(((__u64)w) & (1ULL << 5))) + (!!(((__u64)w) & (1ULL << 6))) + (!!(((__u64)w) & (1ULL << 7))))) + ((unsigned int) ((!!((((__u64)w) >> 8) & (1ULL << 0))) + (!!((((__u64)w) >> 8) & (1ULL << 1))) + (!!((((__u64)w) >> 8) & (1ULL << 2))) + (!!((((__u64)w) >> 8) & (1ULL << 3))) + (!!((((__u64)w) >> 8) & (1ULL << 4))) + (!!((((__u64)w) >> 8) & (1ULL << 5))) + (!!((((__u64)w) >> 8) & (1ULL << 6))) + (!!((((__u64)w) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!((((__u64)w) >> 16) & (1ULL << 0))) + (!!((((__u64)w) >> 16) & (1ULL << 1))) + (!!((((__u64)w) >> 16) & (1ULL << 2))) + (!!((((__u64)w) >> 16) & (1ULL << 3))) + (!!((((__u64)w) >> 16) & (1ULL << 4))) + (!!((((__u64)w) >> 16) & (1ULL << 5))) + (!!((((__u64)w) >> 16) & (1ULL << 6))) + (!!((((__u64)w) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!(((((__u64)w) >> 16) >> 8) & (1ULL << 0))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 1))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 2))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 3))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 4))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 5))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 6))) + (!!(((((__u64)w) >> 16) >> 8) & (1ULL << 7))))))) + ((((unsigned int) ((!!((((__u64)w) >> 32) & (1ULL << 0))) + (!!((((__u64)w) >> 32) & (1ULL << 1))) + (!!((((__u64)w) >> 32) & (1ULL << 2))) + (!!((((__u64)w) >> 32) & (1ULL << 3))) + (!!((((__u64)w) >> 32) & (1ULL << 4))) + (!!((((__u64)w) >> 32) & (1ULL << 5))) + (!!((((__u64)w) >> 32) & (1ULL << 6))) + (!!((((__u64)w) >> 32) & (1ULL << 7))))) + ((unsigned int) ((!!(((((__u64)w) >> 32) >> 8) & (1ULL << 0))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 1))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 2))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 3))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 4))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 5))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 6))) + (!!(((((__u64)w) >> 32) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!(((((__u64)w) >> 32) >> 16) & (1ULL << 0))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 1))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 2))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 3))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 4))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 5))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 6))) + (!!(((((__u64)w) >> 32) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 0))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 1))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 2))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 3))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 4))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 5))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 6))) + (!!((((((__u64)w) >> 32) >> 16) >> 8) & (1ULL << 7)))))))) : __arch_hweight64((__u64)w));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 rol64(__u64 word, unsigned int shift)
{
 return (word << (shift & 63)) | (word >> ((-shift) & 63));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 ror64(__u64 word, unsigned int shift)
{
 return (word >> (shift & 63)) | (word << ((-shift) & 63));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 rol32(__u32 word, unsigned int shift)
{
 return (word << (shift & 31)) | (word >> ((-shift) & 31));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 ror32(__u32 word, unsigned int shift)
{
 return (word >> (shift & 31)) | (word << ((-shift) & 31));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u16 rol16(__u16 word, unsigned int shift)
{
 return (word << (shift & 15)) | (word >> ((-shift) & 15));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u16 ror16(__u16 word, unsigned int shift)
{
 return (word >> (shift & 15)) | (word << ((-shift) & 15));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 rol8(__u8 word, unsigned int shift)
{
 return (word << (shift & 7)) | (word >> ((-shift) & 7));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 ror8(__u8 word, unsigned int shift)
{
 return (word >> (shift & 7)) | (word << ((-shift) & 7));
}
# 165 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __s32 sign_extend32(__u32 value, int index)
{
 __u8 shift = 31 - index;
 return (__s32)(value << shift) >> shift;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __s64 sign_extend64(__u64 value, int index)
{
 __u8 shift = 63 - index;
 return (__s64)(value << shift) >> shift;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned fls_long(unsigned long l)
{
 if (sizeof(l) == 4)
  return fls(l);
 return fls64(l);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_count_order(unsigned int count)
{
 int order;

 order = fls(count) - 1;
 if (count & (count - 1))
  order++;
 return order;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_count_order_long(unsigned long l)
{
 if (l == 0UL)
  return -1;
 else if (l & (l - 1UL))
  return (int)fls_long(l);
 else
  return (int)fls_long(l) - 1;
}
# 223 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __ffs64(u64 word)
{






 return __ffs((unsigned long)word);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void assign_bit(long nr, volatile unsigned long *addr,
           bool value)
{
 if (value)
  set_bit(nr, addr);
 else
  clear_bit(nr, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __assign_bit(long nr, volatile unsigned long *addr,
      bool value)
{
 if (value)
  __set_bit(nr, addr);
 else
  __clear_bit(nr, addr);
}
# 299 "/home/nathan/src/linux-next/include/linux/bitops.h"
extern unsigned long find_last_bit(const unsigned long *addr,
       unsigned long size);
# 13 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/log2.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __ilog2_u32(u32 n)
{
 return fls(n) - 1;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __ilog2_u64(u64 n)
{
 return fls64(n) - 1;
}
# 44 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
bool is_power_of_2(unsigned long n)
{
 return (n != 0 && ((n & (n - 1)) == 0));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
unsigned long __roundup_pow_of_two(unsigned long n)
{
 return 1UL << fls_long(n - 1);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
unsigned long __rounddown_pow_of_two(unsigned long n)
{
 return 1UL << (fls_long(n) - 1);
}
# 197 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__))
int __order_base_2(unsigned long n)
{
 return n > 1 ? ( __builtin_constant_p(n - 1) ? ( __builtin_constant_p(n - 1) ? ( (n - 1) < 2 ? 0 : (n - 1) & (1ULL << 63) ? 63 : (n - 1) & (1ULL << 62) ? 62 : (n - 1) & (1ULL << 61) ? 61 : (n - 1) & (1ULL << 60) ? 60 : (n - 1) & (1ULL << 59) ? 59 : (n - 1) & (1ULL << 58) ? 58 : (n - 1) & (1ULL << 57) ? 57 : (n - 1) & (1ULL << 56) ? 56 : (n - 1) & (1ULL << 55) ? 55 : (n - 1) & (1ULL << 54) ? 54 : (n - 1) & (1ULL << 53) ? 53 : (n - 1) & (1ULL << 52) ? 52 : (n - 1) & (1ULL << 51) ? 51 : (n - 1) & (1ULL << 50) ? 50 : (n - 1) & (1ULL << 49) ? 49 : (n - 1) & (1ULL << 48) ? 48 : (n - 1) & (1ULL << 47) ? 47 : (n - 1) & (1ULL << 46) ? 46 : (n - 1) & (1ULL << 45) ? 45 : (n - 1) & (1ULL << 44) ? 44 : (n - 1) & (1ULL << 43) ? 43 : (n - 1) & (1ULL << 42) ? 42 : (n - 1) & (1ULL << 41) ? 41 : (n - 1) & (1ULL << 40) ? 40 : (n - 1) & (1ULL << 39) ? 39 : (n - 1) & (1ULL << 38) ? 38 : (n - 1) & (1ULL << 37) ? 37 : (n - 1) & (1ULL << 36) ? 36 : (n - 1) & (1ULL << 35) ? 35 : (n - 1) & (1ULL << 34) ? 34 : (n - 1) & (1ULL << 33) ? 33 : (n - 1) & (1ULL << 32) ? 32 : (n - 1) & (1ULL << 31) ? 31 : (n - 1) & (1ULL << 30) ? 30 : (n - 1) & (1ULL << 29) ? 29 : (n - 1) & (1ULL << 28) ? 28 : (n - 1) & (1ULL << 27) ? 27 : (n - 1) & (1ULL << 26) ? 26 : (n - 1) & (1ULL << 25) ? 25 : (n - 1) & (1ULL << 24) ? 24 : (n - 1) & (1ULL << 23) ? 23 : (n - 1) & (1ULL << 22) ? 22 : (n - 1) & (1ULL << 21) ? 21 : (n - 1) & (1ULL << 20) ? 20 : (n - 1) & (1ULL << 19) ? 19 : (n - 1) & (1ULL << 18) ? 18 : (n - 1) & (1ULL << 17) ? 17 : (n - 1) & (1ULL << 16) ? 16 : (n - 1) & (1ULL << 15) ? 15 : (n - 1) & (1ULL << 14) ? 14 : (n - 1) & (1ULL << 13) ? 13 : (n - 1) & (1ULL << 12) ? 12 : (n - 1) & (1ULL << 11) ? 11 : (n - 1) & (1ULL << 10) ? 10 : (n - 1) & (1ULL << 9) ? 9 : (n - 1) & (1ULL << 8) ? 8 : (n - 1) & (1ULL << 7) ? 7 : (n - 1) & (1ULL << 6) ? 6 : (n - 1) & (1ULL << 5) ? 5 : (n - 1) & (1ULL << 4) ? 4 : (n - 1) & (1ULL << 3) ? 3 : (n - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof(n - 1) <= 4) ? __ilog2_u32(n - 1) : __ilog2_u64(n - 1) ) + 1 : 0;
}
# 224 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __bits_per(unsigned long n)
{
 if (n < 2)
  return 1;
 if (is_power_of_2(n))
  return ( __builtin_constant_p(n) ? ( ((n) == 0 || (n) == 1) ? 0 : ( __builtin_constant_p((n) - 1) ? ( __builtin_constant_p((n) - 1) ? ( ((n) - 1) < 2 ? 0 : ((n) - 1) & (1ULL << 63) ? 63 : ((n) - 1) & (1ULL << 62) ? 62 : ((n) - 1) & (1ULL << 61) ? 61 : ((n) - 1) & (1ULL << 60) ? 60 : ((n) - 1) & (1ULL << 59) ? 59 : ((n) - 1) & (1ULL << 58) ? 58 : ((n) - 1) & (1ULL << 57) ? 57 : ((n) - 1) & (1ULL << 56) ? 56 : ((n) - 1) & (1ULL << 55) ? 55 : ((n) - 1) & (1ULL << 54) ? 54 : ((n) - 1) & (1ULL << 53) ? 53 : ((n) - 1) & (1ULL << 52) ? 52 : ((n) - 1) & (1ULL << 51) ? 51 : ((n) - 1) & (1ULL << 50) ? 50 : ((n) - 1) & (1ULL << 49) ? 49 : ((n) - 1) & (1ULL << 48) ? 48 : ((n) - 1) & (1ULL << 47) ? 47 : ((n) - 1) & (1ULL << 46) ? 46 : ((n) - 1) & (1ULL << 45) ? 45 : ((n) - 1) & (1ULL << 44) ? 44 : ((n) - 1) & (1ULL << 43) ? 43 : ((n) - 1) & (1ULL << 42) ? 42 : ((n) - 1) & (1ULL << 41) ? 41 : ((n) - 1) & (1ULL << 40) ? 40 : ((n) - 1) & (1ULL << 39) ? 39 : ((n) - 1) & (1ULL << 38) ? 38 : ((n) - 1) & (1ULL << 37) ? 37 : ((n) - 1) & (1ULL << 36) ? 36 : ((n) - 1) & (1ULL << 35) ? 35 : ((n) - 1) & (1ULL << 34) ? 34 : ((n) - 1) & (1ULL << 33) ? 33 : ((n) - 1) & (1ULL << 32) ? 32 : ((n) - 1) & (1ULL << 31) ? 31 : ((n) - 1) & (1ULL << 30) ? 30 : ((n) - 1) & (1ULL << 29) ? 29 : ((n) - 1) & (1ULL << 28) ? 28 : ((n) - 1) & (1ULL << 27) ? 27 : ((n) - 1) & (1ULL << 26) ? 26 : ((n) - 1) & (1ULL << 25) ? 25 : ((n) - 1) & (1ULL << 24) ? 24 : ((n) - 1) & (1ULL << 23) ? 23 : ((n) - 1) & (1ULL << 22) ? 22 : ((n) - 1) & (1ULL << 21) ? 21 : ((n) - 1) & (1ULL << 20) ? 20 : ((n) - 1) & (1ULL << 19) ? 19 : ((n) - 1) & (1ULL << 18) ? 18 : ((n) - 1) & (1ULL << 17) ? 17 : ((n) - 1) & (1ULL << 16) ? 16 : ((n) - 1) & (1ULL << 15) ? 15 : ((n) - 1) & (1ULL << 14) ? 14 : ((n) - 1) & (1ULL << 13) ? 13 : ((n) - 1) & (1ULL << 12) ? 12 : ((n) - 1) & (1ULL << 11) ? 11 : ((n) - 1) & (1ULL << 10) ? 10 : ((n) - 1) & (1ULL << 9) ? 9 : ((n) - 1) & (1ULL << 8) ? 8 : ((n) - 1) & (1ULL << 7) ? 7 : ((n) - 1) & (1ULL << 6) ? 6 : ((n) - 1) & (1ULL << 5) ? 5 : ((n) - 1) & (1ULL << 4) ? 4 : ((n) - 1) & (1ULL << 3) ? 3 : ((n) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((n) - 1) <= 4) ? __ilog2_u32((n) - 1) : __ilog2_u64((n) - 1) ) + 1) : __order_base_2(n) ) + 1;
 return ( __builtin_constant_p(n) ? ( ((n) == 0 || (n) == 1) ? 0 : ( __builtin_constant_p((n) - 1) ? ( __builtin_constant_p((n) - 1) ? ( ((n) - 1) < 2 ? 0 : ((n) - 1) & (1ULL << 63) ? 63 : ((n) - 1) & (1ULL << 62) ? 62 : ((n) - 1) & (1ULL << 61) ? 61 : ((n) - 1) & (1ULL << 60) ? 60 : ((n) - 1) & (1ULL << 59) ? 59 : ((n) - 1) & (1ULL << 58) ? 58 : ((n) - 1) & (1ULL << 57) ? 57 : ((n) - 1) & (1ULL << 56) ? 56 : ((n) - 1) & (1ULL << 55) ? 55 : ((n) - 1) & (1ULL << 54) ? 54 : ((n) - 1) & (1ULL << 53) ? 53 : ((n) - 1) & (1ULL << 52) ? 52 : ((n) - 1) & (1ULL << 51) ? 51 : ((n) - 1) & (1ULL << 50) ? 50 : ((n) - 1) & (1ULL << 49) ? 49 : ((n) - 1) & (1ULL << 48) ? 48 : ((n) - 1) & (1ULL << 47) ? 47 : ((n) - 1) & (1ULL << 46) ? 46 : ((n) - 1) & (1ULL << 45) ? 45 : ((n) - 1) & (1ULL << 44) ? 44 : ((n) - 1) & (1ULL << 43) ? 43 : ((n) - 1) & (1ULL << 42) ? 42 : ((n) - 1) & (1ULL << 41) ? 41 : ((n) - 1) & (1ULL << 40) ? 40 : ((n) - 1) & (1ULL << 39) ? 39 : ((n) - 1) & (1ULL << 38) ? 38 : ((n) - 1) & (1ULL << 37) ? 37 : ((n) - 1) & (1ULL << 36) ? 36 : ((n) - 1) & (1ULL << 35) ? 35 : ((n) - 1) & (1ULL << 34) ? 34 : ((n) - 1) & (1ULL << 33) ? 33 : ((n) - 1) & (1ULL << 32) ? 32 : ((n) - 1) & (1ULL << 31) ? 31 : ((n) - 1) & (1ULL << 30) ? 30 : ((n) - 1) & (1ULL << 29) ? 29 : ((n) - 1) & (1ULL << 28) ? 28 : ((n) - 1) & (1ULL << 27) ? 27 : ((n) - 1) & (1ULL << 26) ? 26 : ((n) - 1) & (1ULL << 25) ? 25 : ((n) - 1) & (1ULL << 24) ? 24 : ((n) - 1) & (1ULL << 23) ? 23 : ((n) - 1) & (1ULL << 22) ? 22 : ((n) - 1) & (1ULL << 21) ? 21 : ((n) - 1) & (1ULL << 20) ? 20 : ((n) - 1) & (1ULL << 19) ? 19 : ((n) - 1) & (1ULL << 18) ? 18 : ((n) - 1) & (1ULL << 17) ? 17 : ((n) - 1) & (1ULL << 16) ? 16 : ((n) - 1) & (1ULL << 15) ? 15 : ((n) - 1) & (1ULL << 14) ? 14 : ((n) - 1) & (1ULL << 13) ? 13 : ((n) - 1) & (1ULL << 12) ? 12 : ((n) - 1) & (1ULL << 11) ? 11 : ((n) - 1) & (1ULL << 10) ? 10 : ((n) - 1) & (1ULL << 9) ? 9 : ((n) - 1) & (1ULL << 8) ? 8 : ((n) - 1) & (1ULL << 7) ? 7 : ((n) - 1) & (1ULL << 6) ? 6 : ((n) - 1) & (1ULL << 5) ? 5 : ((n) - 1) & (1ULL << 4) ? 4 : ((n) - 1) & (1ULL << 3) ? 3 : ((n) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((n) - 1) <= 4) ? __ilog2_u32((n) - 1) : __ilog2_u64((n) - 1) ) + 1) : __order_base_2(n) );
}
# 14 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/typecheck.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/printk.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/init.h" 1
# 116 "/home/nathan/src/linux-next/include/linux/init.h"
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
# 127 "/home/nathan/src/linux-next/include/linux/init.h"
typedef initcall_t initcall_entry_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) initcall_t initcall_from_entry(initcall_entry_t *entry)
{
 return *entry;
}


extern initcall_entry_t __con_initcall_start[], __con_initcall_end[];


typedef void (*ctor_fn_t)(void);

struct file_system_type;


extern int do_one_initcall(initcall_t fn);
extern char __attribute__((__section__(".init.data"))) boot_command_line[];
extern char *saved_command_line;
extern unsigned int reset_devices;


void setup_arch(char **);
void prepare_namespace(void);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) init_rootfs(void);
extern struct file_system_type rootfs_fs_type;
# 161 "/home/nathan/src/linux-next/include/linux/init.h"
extern void (*late_time_init)(void);

extern bool initcall_debug;
# 7 "/home/nathan/src/linux-next/include/linux/printk.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kern_levels.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/printk.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/cache.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kernel.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/sysinfo.h" 1







struct sysinfo {
 __kernel_long_t uptime;
 __kernel_ulong_t loads[3];
 __kernel_ulong_t totalram;
 __kernel_ulong_t freeram;
 __kernel_ulong_t sharedram;
 __kernel_ulong_t bufferram;
 __kernel_ulong_t totalswap;
 __kernel_ulong_t freeswap;
 __u16 procs;
 __u16 pad;
 __kernel_ulong_t totalhigh;
 __kernel_ulong_t freehigh;
 __u32 mem_unit;
 char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];
};
# 6 "/home/nathan/src/linux-next/include/uapi/linux/kernel.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/cache.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h" 1
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h"
struct ppc_cache_info {
 u32 size;
 u32 line_size;
 u32 block_size;
 u32 log_block_size;
 u32 blocks_per_page;
 u32 sets;
 u32 assoc;
};

struct ppc64_caches {
 struct ppc_cache_info l1d;
 struct ppc_cache_info l1i;
 struct ppc_cache_info l2;
 struct ppc_cache_info l3;
};

extern struct ppc64_caches ppc64_caches;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_dcache_shift(void)
{
 return ppc64_caches.l1d.log_block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_dcache_bytes(void)
{
 return ppc64_caches.l1d.block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_icache_shift(void)
{
 return ppc64_caches.l1i.log_block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_icache_bytes(void)
{
 return ppc64_caches.l1i.block_size;
}
# 114 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbz(void *addr)
{
 __asm__ __volatile__ ("dcbz 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbi(void *addr)
{
 __asm__ __volatile__ ("dcbi 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbf(void *addr)
{
 __asm__ __volatile__ ("dcbf 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbst(void *addr)
{
 __asm__ __volatile__ ("dcbst 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void icbi(void *addr)
{
 asm volatile ("icbi 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iccci(void *addr)
{
 asm volatile ("iccci 0, %0" : : "r"(addr) : "memory");
}
# 7 "/home/nathan/src/linux-next/include/linux/cache.h" 2
# 10 "/home/nathan/src/linux-next/include/linux/printk.h" 2

extern const char linux_banner[];
extern const char linux_proc_banner[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int printk_get_level(const char *buffer)
{
 if (buffer[0] == '\001' && buffer[1]) {
  switch (buffer[1]) {
  case '0' ... '7':
  case 'c':
   return buffer[1];
  }
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *printk_skip_level(const char *buffer)
{
 if (printk_get_level(buffer))
  return buffer + 2;

 return buffer;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *printk_skip_headers(const char *buffer)
{
 while (printk_get_level(buffer))
  buffer = printk_skip_level(buffer);

 return buffer;
}
# 62 "/home/nathan/src/linux-next/include/linux/printk.h"
extern int console_printk[];






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void console_silent(void)
{
 (console_printk[0]) = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void console_verbose(void)
{
 if ((console_printk[0]))
  (console_printk[0]) = 15;
}



extern char devkmsg_log_str[];
struct ctl_table;

extern int suppress_printk;

struct va_format {
 const char *fmt;
 va_list *va;
};
# 142 "/home/nathan/src/linux-next/include/linux/printk.h"
extern __attribute__((__format__(printf, 1, 2)))
void early_printk(const char *fmt, ...);






extern void printk_nmi_enter(void);
extern void printk_nmi_exit(void);
extern void printk_nmi_direct_enter(void);
extern void printk_nmi_direct_exit(void);
# 162 "/home/nathan/src/linux-next/include/linux/printk.h"
           __attribute__((__format__(printf, 5, 0)))
int vprintk_emit(int facility, int level,
   const char *dict, size_t dictlen,
   const char *fmt, va_list args);

           __attribute__((__format__(printf, 1, 0)))
int vprintk(const char *fmt, va_list args);

           __attribute__((__format__(printf, 1, 2))) __attribute__((__cold__))
int printk(const char *fmt, ...);




__attribute__((__format__(printf, 1, 2))) __attribute__((__cold__)) int printk_deferred(const char *fmt, ...);






extern int __printk_ratelimit(const char *func);

extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
       unsigned int interval_msec);

extern int printk_delay_msec;
extern int dmesg_restrict;

extern int
devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void *buf,
     size_t *lenp, loff_t *ppos);

extern void wake_up_klogd(void);

char *log_buf_addr_get(void);
u32 log_buf_len_get(void);
void log_buf_vmcoreinfo_setup(void);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) setup_log_buf(int early);
__attribute__((__format__(printf, 1, 2))) void dump_stack_set_arch_desc(const char *fmt, ...);
void dump_stack_print_info(const char *log_lvl);
void show_regs_print_info(const char *log_lvl);
extern void dump_stack(void) __attribute__((__cold__));
extern void printk_safe_flush(void);
extern void printk_safe_flush_on_panic(void);
# 280 "/home/nathan/src/linux-next/include/linux/printk.h"
extern int kptr_restrict;
# 404 "/home/nathan/src/linux-next/include/linux/printk.h"
# 1 "/home/nathan/src/linux-next/include/linux/dynamic_debug.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/jump_label.h" 1
# 79 "/home/nathan/src/linux-next/include/linux/jump_label.h"
extern bool static_key_initialized;







struct static_key {
 atomic_t enabled;
# 102 "/home/nathan/src/linux-next/include/linux/jump_label.h"
 union {
  unsigned long type;
  struct jump_entry *entries;
  struct static_key_mod *next;
 };
};
# 117 "/home/nathan/src/linux-next/include/linux/jump_label.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/jump_label.h" 1
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool arch_static_branch(struct static_key *key, bool branch)
{
 asm goto("1:\n\t" "nop # arch_static_branch\n\t" ".pushsection __jump_table,  \"aw\"\n\t" ".8byte" " " "1b, %l[l_yes], %c0\n\t" ".popsection \n\t" : : "i" (&((char *)key)[branch]) : : l_yes);






 return false;
l_yes:
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool arch_static_branch_jump(struct static_key *key, bool branch)
{
 asm goto("1:\n\t" "b %l[l_yes] # arch_static_branch_jump\n\t" ".pushsection __jump_table,  \"aw\"\n\t" ".8byte" " " "1b, %l[l_yes], %c0\n\t" ".popsection \n\t" : : "i" (&((char *)key)[branch]) : : l_yes);






 return false;
l_yes:
 return true;
}


typedef u64 jump_label_t;




struct jump_entry {
 jump_label_t code;
 jump_label_t target;
 jump_label_t key;
};
# 118 "/home/nathan/src/linux-next/include/linux/jump_label.h" 2
# 147 "/home/nathan/src/linux-next/include/linux/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long jump_entry_code(const struct jump_entry *entry)
{
 return entry->code;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long jump_entry_target(const struct jump_entry *entry)
{
 return entry->target;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct static_key *jump_entry_key(const struct jump_entry *entry)
{
 return (struct static_key *)((unsigned long)entry->key & ~3UL);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool jump_entry_is_branch(const struct jump_entry *entry)
{
 return (unsigned long)entry->key & 1UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool jump_entry_is_init(const struct jump_entry *entry)
{
 return (unsigned long)entry->key & 2UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void jump_entry_set_init(struct jump_entry *entry)
{
 entry->key |= 2;
}






enum jump_label_type {
 JUMP_LABEL_NOP = 0,
 JUMP_LABEL_JMP,
};

struct module;
# 198 "/home/nathan/src/linux-next/include/linux/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool static_key_false(struct static_key *key)
{
 return arch_static_branch(key, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool static_key_true(struct static_key *key)
{
 return !arch_static_branch(key, true);
}

extern struct jump_entry __start___jump_table[];
extern struct jump_entry __stop___jump_table[];

extern void jump_label_init(void);
extern void jump_label_lock(void);
extern void jump_label_unlock(void);
extern void arch_jump_label_transform(struct jump_entry *entry,
          enum jump_label_type type);
extern void arch_jump_label_transform_static(struct jump_entry *entry,
          enum jump_label_type type);
extern bool arch_jump_label_transform_queue(struct jump_entry *entry,
         enum jump_label_type type);
extern void arch_jump_label_transform_apply(void);
extern int jump_label_text_reserved(void *start, void *end);
extern void static_key_slow_inc(struct static_key *key);
extern void static_key_slow_dec(struct static_key *key);
extern void static_key_slow_inc_cpuslocked(struct static_key *key);
extern void static_key_slow_dec_cpuslocked(struct static_key *key);
extern void jump_label_apply_nops(struct module *mod);
extern int static_key_count(struct static_key *key);
extern void static_key_enable(struct static_key *key);
extern void static_key_disable(struct static_key *key);
extern void static_key_enable_cpuslocked(struct static_key *key);
extern void static_key_disable_cpuslocked(struct static_key *key);
# 346 "/home/nathan/src/linux-next/include/linux/jump_label.h"
struct static_key_true {
 struct static_key key;
};

struct static_key_false {
 struct static_key key;
};
# 385 "/home/nathan/src/linux-next/include/linux/jump_label.h"
extern bool ____wrong_branch_error(void);
# 7 "/home/nathan/src/linux-next/include/linux/dynamic_debug.h" 2







struct _ddebug {




 const char *modname;
 const char *function;
 const char *filename;
 const char *format;
 unsigned int lineno:18;
# 40 "/home/nathan/src/linux-next/include/linux/dynamic_debug.h"
 unsigned int flags:8;

 union {
  struct static_key_true dd_key_true;
  struct static_key_false dd_key_false;
 } key;

} __attribute__((aligned(8)));




int ddebug_add_module(struct _ddebug *tab, unsigned int n,
    const char *modname);
extern int ddebug_remove_module(const char *mod_name);
extern __attribute__((__format__(printf, 2, 3)))
void __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...);

extern int ddebug_dyndbg_module_param_cb(char *param, char *val,
     const char *modname);

struct device;

extern __attribute__((__format__(printf, 3, 4)))
void __dynamic_dev_dbg(struct _ddebug *descriptor, const struct device *dev,
         const char *fmt, ...);

struct net_device;

extern __attribute__((__format__(printf, 3, 4)))
void __dynamic_netdev_dbg(struct _ddebug *descriptor,
     const struct net_device *dev,
     const char *fmt, ...);

struct ib_device;

extern __attribute__((__format__(printf, 3, 4)))
void __dynamic_ibdev_dbg(struct _ddebug *descriptor,
    const struct ib_device *ibdev,
    const char *fmt, ...);
# 405 "/home/nathan/src/linux-next/include/linux/printk.h" 2
# 560 "/home/nathan/src/linux-next/include/linux/printk.h"
extern const struct file_operations kmsg_fops;

enum {
 DUMP_PREFIX_NONE,
 DUMP_PREFIX_ADDRESS,
 DUMP_PREFIX_OFFSET
};
extern int hex_dump_to_buffer(const void *buf, size_t len, int rowsize,
         int groupsize, char *linebuf, size_t linebuflen,
         bool ascii);

extern void print_hex_dump(const char *level, const char *prefix_str,
      int prefix_type, int rowsize, int groupsize,
      const void *buf, size_t len, bool ascii);
# 16 "/home/nathan/src/linux-next/include/linux/kernel.h" 2


# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/div64.h" 1
# 2 "./arch/powerpc/include/generated/asm/div64.h" 2
# 19 "/home/nathan/src/linux-next/include/linux/kernel.h" 2

# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 191 "/home/nathan/src/linux-next/include/linux/kernel.h"
struct completion;
struct pt_regs;
struct user;


extern int _cond_resched(void);
# 247 "/home/nathan/src/linux-next/include/linux/kernel.h"
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ___might_sleep(const char *file, int line,
       int preempt_offset) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __might_sleep(const char *file, int line,
       int preempt_offset) { }
# 304 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 reciprocal_scale(u32 val, u32 ep_ro)
{
 return (u32)(((u64) val * ep_ro) >> 32);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void might_fault(void) { }


extern struct atomic_notifier_head panic_notifier_list;
extern long (*panic_blink)(int state);
__attribute__((__format__(printf, 1, 2)))
void panic(const char *fmt, ...) __attribute__((__noreturn__)) __attribute__((__cold__));
void nmi_panic(struct pt_regs *regs, const char *msg);
extern void oops_enter(void);
extern void oops_exit(void);
void print_oops_end_marker(void);
extern int oops_may_print(void);
void do_exit(long error_code) __attribute__((__noreturn__));
void complete_and_exit(struct completion *, long) __attribute__((__noreturn__));


int __attribute__((__warn_unused_result__)) _kstrtoul(const char *s, unsigned int base, unsigned long *res);
int __attribute__((__warn_unused_result__)) _kstrtol(const char *s, unsigned int base, long *res);

int __attribute__((__warn_unused_result__)) kstrtoull(const char *s, unsigned int base, unsigned long long *res);
int __attribute__((__warn_unused_result__)) kstrtoll(const char *s, unsigned int base, long long *res);
# 351 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtoul(const char *s, unsigned int base, unsigned long *res)
{




 if (sizeof(unsigned long) == sizeof(unsigned long long) &&
     __alignof__(unsigned long) == __alignof__(unsigned long long))
  return kstrtoull(s, base, (unsigned long long *)res);
 else
  return _kstrtoul(s, base, res);
}
# 379 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtol(const char *s, unsigned int base, long *res)
{




 if (sizeof(long) == sizeof(long long) &&
     __alignof__(long) == __alignof__(long long))
  return kstrtoll(s, base, (long long *)res);
 else
  return _kstrtol(s, base, res);
}

int __attribute__((__warn_unused_result__)) kstrtouint(const char *s, unsigned int base, unsigned int *res);
int __attribute__((__warn_unused_result__)) kstrtoint(const char *s, unsigned int base, int *res);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou64(const char *s, unsigned int base, u64 *res)
{
 return kstrtoull(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos64(const char *s, unsigned int base, s64 *res)
{
 return kstrtoll(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou32(const char *s, unsigned int base, u32 *res)
{
 return kstrtouint(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos32(const char *s, unsigned int base, s32 *res)
{
 return kstrtoint(s, base, res);
}

int __attribute__((__warn_unused_result__)) kstrtou16(const char *s, unsigned int base, u16 *res);
int __attribute__((__warn_unused_result__)) kstrtos16(const char *s, unsigned int base, s16 *res);
int __attribute__((__warn_unused_result__)) kstrtou8(const char *s, unsigned int base, u8 *res);
int __attribute__((__warn_unused_result__)) kstrtos8(const char *s, unsigned int base, s8 *res);
int __attribute__((__warn_unused_result__)) kstrtobool(const char *s, bool *res);

int __attribute__((__warn_unused_result__)) kstrtoull_from_user(const char *s, size_t count, unsigned int base, unsigned long long *res);
int __attribute__((__warn_unused_result__)) kstrtoll_from_user(const char *s, size_t count, unsigned int base, long long *res);
int __attribute__((__warn_unused_result__)) kstrtoul_from_user(const char *s, size_t count, unsigned int base, unsigned long *res);
int __attribute__((__warn_unused_result__)) kstrtol_from_user(const char *s, size_t count, unsigned int base, long *res);
int __attribute__((__warn_unused_result__)) kstrtouint_from_user(const char *s, size_t count, unsigned int base, unsigned int *res);
int __attribute__((__warn_unused_result__)) kstrtoint_from_user(const char *s, size_t count, unsigned int base, int *res);
int __attribute__((__warn_unused_result__)) kstrtou16_from_user(const char *s, size_t count, unsigned int base, u16 *res);
int __attribute__((__warn_unused_result__)) kstrtos16_from_user(const char *s, size_t count, unsigned int base, s16 *res);
int __attribute__((__warn_unused_result__)) kstrtou8_from_user(const char *s, size_t count, unsigned int base, u8 *res);
int __attribute__((__warn_unused_result__)) kstrtos8_from_user(const char *s, size_t count, unsigned int base, s8 *res);
int __attribute__((__warn_unused_result__)) kstrtobool_from_user(const char *s, size_t count, bool *res);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou64_from_user(const char *s, size_t count, unsigned int base, u64 *res)
{
 return kstrtoull_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos64_from_user(const char *s, size_t count, unsigned int base, s64 *res)
{
 return kstrtoll_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou32_from_user(const char *s, size_t count, unsigned int base, u32 *res)
{
 return kstrtouint_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos32_from_user(const char *s, size_t count, unsigned int base, s32 *res)
{
 return kstrtoint_from_user(s, count, base, res);
}
# 466 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern unsigned long simple_strtoul(const char *,char **,unsigned int);
extern long simple_strtol(const char *,char **,unsigned int);
extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
extern long long simple_strtoll(const char *,char **,unsigned int);

extern int num_to_str(char *buf, int size,
        unsigned long long num, unsigned int width);



extern __attribute__((__format__(printf, 2, 3))) int sprintf(char *buf, const char * fmt, ...);
extern __attribute__((__format__(printf, 2, 0))) int vsprintf(char *buf, const char *, va_list);
extern __attribute__((__format__(printf, 3, 4)))
int snprintf(char *buf, size_t size, const char *fmt, ...);
extern __attribute__((__format__(printf, 3, 0)))
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 3, 4)))
int scnprintf(char *buf, size_t size, const char *fmt, ...);
extern __attribute__((__format__(printf, 3, 0)))
int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 2, 3))) __attribute__((__malloc__))
char *kasprintf(gfp_t gfp, const char *fmt, ...);
extern __attribute__((__format__(printf, 2, 0))) __attribute__((__malloc__))
char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 2, 0)))
const char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);

extern __attribute__((__format__(scanf, 2, 3)))
int sscanf(const char *, const char *, ...);
extern __attribute__((__format__(scanf, 2, 0)))
int vsscanf(const char *, const char *, va_list);

extern int get_option(char **str, int *pint);
extern char *get_options(const char *str, int nints, int *ints);
extern unsigned long long memparse(const char *ptr, char **retptr);
extern bool parse_option_str(const char *str, const char *option);
extern char *next_arg(char *args, char **param, char **val);

extern int core_kernel_text(unsigned long addr);
extern int init_kernel_text(unsigned long addr);
extern int core_kernel_data(unsigned long addr);
extern int __kernel_text_address(unsigned long addr);
extern int kernel_text_address(unsigned long addr);
extern int func_ptr_is_kernel_text(void *ptr);

u64 int_pow(u64 base, unsigned int exp);
unsigned long int_sqrt(unsigned long);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 int_sqrt64(u64 x)
{
 return (u32)int_sqrt(x);
}



extern unsigned int sysctl_oops_all_cpu_backtrace;




extern void bust_spinlocks(int yes);
extern int oops_in_progress;
extern int panic_timeout;
extern unsigned long panic_print;
extern int panic_on_oops;
extern int panic_on_unrecovered_nmi;
extern int panic_on_io_nmi;
extern int panic_on_warn;
extern unsigned long panic_on_taint;
extern bool panic_on_taint_nousertaint;
extern int sysctl_panic_on_rcu_stall;
extern int sysctl_panic_on_stackoverflow;

extern bool crash_kexec_post_notifiers;






extern atomic_t panic_cpu;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_arch_panic_timeout(int timeout, int arch_default_timeout)
{
 if (panic_timeout == arch_default_timeout)
  panic_timeout = timeout;
}
extern const char *print_tainted(void);
enum lockdep_ok {
 LOCKDEP_STILL_OK,
 LOCKDEP_NOW_UNRELIABLE
};
extern void add_taint(unsigned flag, enum lockdep_ok);
extern int test_taint(unsigned flag);
extern unsigned long get_taint(void);
extern int root_mountflags;

extern bool early_boot_irqs_disabled;





extern enum system_states {
 SYSTEM_BOOTING,
 SYSTEM_SCHEDULING,
 SYSTEM_RUNNING,
 SYSTEM_HALT,
 SYSTEM_POWER_OFF,
 SYSTEM_RESTART,
 SYSTEM_SUSPEND,
} system_state;
# 609 "/home/nathan/src/linux-next/include/linux/kernel.h"
struct taint_flag {
 char c_true;
 char c_false;
 bool module;
};

extern const struct taint_flag taint_flags[18];

extern const char hex_asc[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *hex_byte_pack(char *buf, u8 byte)
{
 *buf++ = hex_asc[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc[((byte) & 0x0f)];
 return buf;
}

extern const char hex_asc_upper[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *hex_byte_pack_upper(char *buf, u8 byte)
{
 *buf++ = hex_asc_upper[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc_upper[((byte) & 0x0f)];
 return buf;
}

extern int hex_to_bin(char ch);
extern int __attribute__((__warn_unused_result__)) hex2bin(u8 *dst, const char *src, size_t count);
extern char *bin2hex(char *dst, const void *src, size_t count);

bool mac_pton(const char *s, u8 *mac);
# 665 "/home/nathan/src/linux-next/include/linux/kernel.h"
enum ftrace_dump_mode {
 DUMP_NONE,
 DUMP_ALL,
 DUMP_ORIG,
};


void tracing_on(void);
void tracing_off(void);
int tracing_is_on(void);
void tracing_snapshot(void);
void tracing_snapshot_alloc(void);

extern void tracing_start(void);
extern void tracing_stop(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__format__(printf, 1, 2)))
void ____trace_printk_check_format(const char *fmt, ...)
{
}
# 744 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern __attribute__((__format__(printf, 2, 3)))
int __trace_bprintk(unsigned long ip, const char *fmt, ...);

extern __attribute__((__format__(printf, 2, 3)))
int __trace_printk(unsigned long ip, const char *fmt, ...);
# 785 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern int __trace_bputs(unsigned long ip, const char *str);
extern int __trace_puts(unsigned long ip, const char *str, int size);

extern void trace_dump_stack(int skip);
# 807 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern __attribute__((__format__(printf, 2, 0))) int
__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);

extern __attribute__((__format__(printf, 2, 0))) int
__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);

extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);
# 10 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 33 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_LIST_HEAD(struct list_head *list)
{
 do { do { extern void __compiletime_assert_0(void) ; if (!((sizeof(list->next) == sizeof(char) || sizeof(list->next) == sizeof(short) || sizeof(list->next) == sizeof(int) || sizeof(list->next) == sizeof(long)) || sizeof(list->next) == sizeof(long long))) __compiletime_assert_0(); } while (0); do { *(volatile typeof(list->next) *)&(list->next) = (list); } while (0); } while (0);
 list->prev = list;
}


extern bool __list_add_valid(struct list_head *new,
         struct list_head *prev,
         struct list_head *next);
extern bool __list_del_entry_valid(struct list_head *entry);
# 63 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_add(struct list_head *new,
         struct list_head *prev,
         struct list_head *next)
{
 if (!__list_add_valid(new, prev, next))
  return;

 next->prev = new;
 new->next = next;
 new->prev = prev;
 do { do { extern void __compiletime_assert_1(void) ; if (!((sizeof(prev->next) == sizeof(char) || sizeof(prev->next) == sizeof(short) || sizeof(prev->next) == sizeof(int) || sizeof(prev->next) == sizeof(long)) || sizeof(prev->next) == sizeof(long long))) __compiletime_assert_1(); } while (0); do { *(volatile typeof(prev->next) *)&(prev->next) = (new); } while (0); } while (0);
}
# 84 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add(struct list_head *new, struct list_head *head)
{
 __list_add(new, head, head->next);
}
# 98 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_tail(struct list_head *new, struct list_head *head)
{
 __list_add(new, head->prev, head);
}
# 110 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del(struct list_head * prev, struct list_head * next)
{
 next->prev = prev;
 do { do { extern void __compiletime_assert_2(void) ; if (!((sizeof(prev->next) == sizeof(char) || sizeof(prev->next) == sizeof(short) || sizeof(prev->next) == sizeof(int) || sizeof(prev->next) == sizeof(long)) || sizeof(prev->next) == sizeof(long long))) __compiletime_assert_2(); } while (0); do { *(volatile typeof(prev->next) *)&(prev->next) = (next); } while (0); } while (0);
}
# 124 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del_clearprev(struct list_head *entry)
{
 __list_del(entry->prev, entry->next);
 entry->prev = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del_entry(struct list_head *entry)
{
 if (!__list_del_entry_valid(entry))
  return;

 __list_del(entry->prev, entry->next);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del(struct list_head *entry)
{
 __list_del_entry(entry);
 entry->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 entry->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 158 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace(struct list_head *old,
    struct list_head *new)
{
 new->next = old->next;
 new->next->prev = new;
 new->prev = old->prev;
 new->prev->next = new;
}
# 174 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace_init(struct list_head *old,
         struct list_head *new)
{
 list_replace(old, new);
 INIT_LIST_HEAD(old);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_swap(struct list_head *entry1,
        struct list_head *entry2)
{
 struct list_head *pos = entry2->prev;

 list_del(entry2);
 list_replace(entry1, entry2);
 if (pos == entry1)
  pos = entry2;
 list_add(entry1, pos);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del_init(struct list_head *entry)
{
 __list_del_entry(entry);
 INIT_LIST_HEAD(entry);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_move(struct list_head *list, struct list_head *head)
{
 __list_del_entry(list);
 list_add(list, head);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_move_tail(struct list_head *list,
      struct list_head *head)
{
 __list_del_entry(list);
 list_add_tail(list, head);
}
# 240 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_bulk_move_tail(struct list_head *head,
           struct list_head *first,
           struct list_head *last)
{
 first->prev->next = last->next;
 last->next->prev = first->prev;

 head->prev->next = first;
 first->prev = head->prev;

 last->next = head;
 head->prev = last;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_first(const struct list_head *list,
     const struct list_head *head)
{
 return list->prev == head;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_last(const struct list_head *list,
    const struct list_head *head)
{
 return list->next == head;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_empty(const struct list_head *head)
{
 return ({ do { extern void __compiletime_assert_3(void) ; if (!((sizeof(head->next) == sizeof(char) || sizeof(head->next) == sizeof(short) || sizeof(head->next) == sizeof(int) || sizeof(head->next) == sizeof(long)) || sizeof(head->next) == sizeof(long long))) __compiletime_assert_3(); } while (0); ({ typeof( _Generic((head->next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head->next))) __x = (*(const volatile typeof( _Generic((head->next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head->next))) *)&(head->next)); do { } while (0); (typeof(head->next))__x; }); }) == head;
}
# 298 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_empty_careful(const struct list_head *head)
{
 struct list_head *next = head->next;
 return (next == head) && (next == head->prev);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_rotate_left(struct list_head *head)
{
 struct list_head *first;

 if (!list_empty(head)) {
  first = head->next;
  list_move_tail(first, head);
 }
}
# 325 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_rotate_to_front(struct list_head *list,
     struct list_head *head)
{





 list_move_tail(head, list);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_singular(const struct list_head *head)
{
 return !list_empty(head) && (head->next == head->prev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 struct list_head *new_first = entry->next;
 list->next = head->next;
 list->next->prev = list;
 list->prev = entry;
 entry->next = list;
 head->next = new_first;
 new_first->prev = head;
}
# 371 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 if (list_empty(head))
  return;
 if (list_is_singular(head) &&
  (head->next != entry && head != entry))
  return;
 if (entry == head)
  INIT_LIST_HEAD(list);
 else
  __list_cut_position(list, head, entry);
}
# 399 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_cut_before(struct list_head *list,
       struct list_head *head,
       struct list_head *entry)
{
 if (head->next == entry) {
  INIT_LIST_HEAD(list);
  return;
 }
 list->next = head->next;
 list->next->prev = list;
 list->prev = entry->prev;
 list->prev->next = list;
 head->next = entry;
 entry->prev = head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_splice(const struct list_head *list,
     struct list_head *prev,
     struct list_head *next)
{
 struct list_head *first = list->next;
 struct list_head *last = list->prev;

 first->prev = prev;
 prev->next = first;

 last->next = next;
 next->prev = last;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice(const struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, head, head->next);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail(struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, head->prev, head);
}
# 460 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_init(struct list_head *list,
        struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, head, head->next);
  INIT_LIST_HEAD(list);
 }
}
# 477 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail_init(struct list_head *list,
      struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, head->prev, head);
  INIT_LIST_HEAD(list);
 }
}
# 765 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_HLIST_NODE(struct hlist_node *h)
{
 h->next = ((void *)0);
 h->pprev = ((void *)0);
}
# 779 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_unhashed(const struct hlist_node *h)
{
 return !h->pprev;
}
# 792 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_unhashed_lockless(const struct hlist_node *h)
{
 return !({ do { extern void __compiletime_assert_4(void) ; if (!((sizeof(h->pprev) == sizeof(char) || sizeof(h->pprev) == sizeof(short) || sizeof(h->pprev) == sizeof(int) || sizeof(h->pprev) == sizeof(long)) || sizeof(h->pprev) == sizeof(long long))) __compiletime_assert_4(); } while (0); ({ typeof( _Generic((h->pprev), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->pprev))) __x = (*(const volatile typeof( _Generic((h->pprev), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->pprev))) *)&(h->pprev)); do { } while (0); (typeof(h->pprev))__x; }); });
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_empty(const struct hlist_head *h)
{
 return !({ do { extern void __compiletime_assert_5(void) ; if (!((sizeof(h->first) == sizeof(char) || sizeof(h->first) == sizeof(short) || sizeof(h->first) == sizeof(int) || sizeof(h->first) == sizeof(long)) || sizeof(h->first) == sizeof(long long))) __compiletime_assert_5(); } while (0); ({ typeof( _Generic((h->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->first))) __x = (*(const volatile typeof( _Generic((h->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->first))) *)&(h->first)); do { } while (0); (typeof(h->first))__x; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hlist_del(struct hlist_node *n)
{
 struct hlist_node *next = n->next;
 struct hlist_node **pprev = n->pprev;

 do { do { extern void __compiletime_assert_6(void) ; if (!((sizeof(*pprev) == sizeof(char) || sizeof(*pprev) == sizeof(short) || sizeof(*pprev) == sizeof(int) || sizeof(*pprev) == sizeof(long)) || sizeof(*pprev) == sizeof(long long))) __compiletime_assert_6(); } while (0); do { *(volatile typeof(*pprev) *)&(*pprev) = (next); } while (0); } while (0);
 if (next)
  do { do { extern void __compiletime_assert_7(void) ; if (!((sizeof(next->pprev) == sizeof(char) || sizeof(next->pprev) == sizeof(short) || sizeof(next->pprev) == sizeof(int) || sizeof(next->pprev) == sizeof(long)) || sizeof(next->pprev) == sizeof(long long))) __compiletime_assert_7(); } while (0); do { *(volatile typeof(next->pprev) *)&(next->pprev) = (pprev); } while (0); } while (0);
}
# 823 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del(struct hlist_node *n)
{
 __hlist_del(n);
 n->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_init(struct hlist_node *n)
{
 if (!hlist_unhashed(n)) {
  __hlist_del(n);
  INIT_HLIST_NODE(n);
 }
}
# 852 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
 struct hlist_node *first = h->first;
 do { do { extern void __compiletime_assert_8(void) ; if (!((sizeof(n->next) == sizeof(char) || sizeof(n->next) == sizeof(short) || sizeof(n->next) == sizeof(int) || sizeof(n->next) == sizeof(long)) || sizeof(n->next) == sizeof(long long))) __compiletime_assert_8(); } while (0); do { *(volatile typeof(n->next) *)&(n->next) = (first); } while (0); } while (0);
 if (first)
  do { do { extern void __compiletime_assert_9(void) ; if (!((sizeof(first->pprev) == sizeof(char) || sizeof(first->pprev) == sizeof(short) || sizeof(first->pprev) == sizeof(int) || sizeof(first->pprev) == sizeof(long)) || sizeof(first->pprev) == sizeof(long long))) __compiletime_assert_9(); } while (0); do { *(volatile typeof(first->pprev) *)&(first->pprev) = (&n->next); } while (0); } while (0);
 do { do { extern void __compiletime_assert_10(void) ; if (!((sizeof(h->first) == sizeof(char) || sizeof(h->first) == sizeof(short) || sizeof(h->first) == sizeof(int) || sizeof(h->first) == sizeof(long)) || sizeof(h->first) == sizeof(long long))) __compiletime_assert_10(); } while (0); do { *(volatile typeof(h->first) *)&(h->first) = (n); } while (0); } while (0);
 do { do { extern void __compiletime_assert_11(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_11(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (&h->first); } while (0); } while (0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_before(struct hlist_node *n,
        struct hlist_node *next)
{
 do { do { extern void __compiletime_assert_12(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_12(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (next->pprev); } while (0); } while (0);
 do { do { extern void __compiletime_assert_13(void) ; if (!((sizeof(n->next) == sizeof(char) || sizeof(n->next) == sizeof(short) || sizeof(n->next) == sizeof(int) || sizeof(n->next) == sizeof(long)) || sizeof(n->next) == sizeof(long long))) __compiletime_assert_13(); } while (0); do { *(volatile typeof(n->next) *)&(n->next) = (next); } while (0); } while (0);
 do { do { extern void __compiletime_assert_14(void) ; if (!((sizeof(next->pprev) == sizeof(char) || sizeof(next->pprev) == sizeof(short) || sizeof(next->pprev) == sizeof(int) || sizeof(next->pprev) == sizeof(long)) || sizeof(next->pprev) == sizeof(long long))) __compiletime_assert_14(); } while (0); do { *(volatile typeof(next->pprev) *)&(next->pprev) = (&n->next); } while (0); } while (0);
 do { do { extern void __compiletime_assert_15(void) ; if (!((sizeof(*(n->pprev)) == sizeof(char) || sizeof(*(n->pprev)) == sizeof(short) || sizeof(*(n->pprev)) == sizeof(int) || sizeof(*(n->pprev)) == sizeof(long)) || sizeof(*(n->pprev)) == sizeof(long long))) __compiletime_assert_15(); } while (0); do { *(volatile typeof(*(n->pprev)) *)&(*(n->pprev)) = (n); } while (0); } while (0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_behind(struct hlist_node *n,
        struct hlist_node *prev)
{
 do { do { extern void __compiletime_assert_16(void) ; if (!((sizeof(n->next) == sizeof(char) || sizeof(n->next) == sizeof(short) || sizeof(n->next) == sizeof(int) || sizeof(n->next) == sizeof(long)) || sizeof(n->next) == sizeof(long long))) __compiletime_assert_16(); } while (0); do { *(volatile typeof(n->next) *)&(n->next) = (prev->next); } while (0); } while (0);
 do { do { extern void __compiletime_assert_17(void) ; if (!((sizeof(prev->next) == sizeof(char) || sizeof(prev->next) == sizeof(short) || sizeof(prev->next) == sizeof(int) || sizeof(prev->next) == sizeof(long)) || sizeof(prev->next) == sizeof(long long))) __compiletime_assert_17(); } while (0); do { *(volatile typeof(prev->next) *)&(prev->next) = (n); } while (0); } while (0);
 do { do { extern void __compiletime_assert_18(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_18(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (&prev->next); } while (0); } while (0);

 if (n->next)
  do { do { extern void __compiletime_assert_19(void) ; if (!((sizeof(n->next->pprev) == sizeof(char) || sizeof(n->next->pprev) == sizeof(short) || sizeof(n->next->pprev) == sizeof(int) || sizeof(n->next->pprev) == sizeof(long)) || sizeof(n->next->pprev) == sizeof(long long))) __compiletime_assert_19(); } while (0); do { *(volatile typeof(n->next->pprev) *)&(n->next->pprev) = (&n->next); } while (0); } while (0);
}
# 900 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_fake(struct hlist_node *n)
{
 n->pprev = &n->next;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_fake(struct hlist_node *h)
{
 return h->pprev == &h->next;
}
# 922 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
hlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)
{
 return !n->next && n->pprev == &h->first;
}
# 936 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_move_list(struct hlist_head *old,
       struct hlist_head *new)
{
 new->first = old->first;
 if (new->first)
  new->first->pprev = &new->first;
 old->first = ((void *)0);
}
# 13 "/home/nathan/src/linux-next/include/linux/smp.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/cpumask.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/cpumask.h"
# 1 "/home/nathan/src/linux-next/include/linux/threads.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/cpumask.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/bitmap.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/string.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/string.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/string.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/string.h" 2

extern char *strndup_user(const char *, long);
extern void *memdup_user(const void *, size_t);
extern void *vmemdup_user(const void *, size_t);
extern void *memdup_user_nul(const void *, size_t);





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h"
extern char * strcpy(char *,const char *);
extern char * strncpy(char *,const char *, __kernel_size_t);
extern __kernel_size_t strlen(const char *);
extern int strcmp(const char *,const char *);
extern int strncmp(const char *, const char *, __kernel_size_t);
extern char * strcat(char *, const char *);
extern void * memset(void *,int,__kernel_size_t);
extern void * memcpy(void *,const void *,__kernel_size_t);
extern void * memmove(void *,const void *,__kernel_size_t);
extern int memcmp(const void *,const void *,__kernel_size_t);
extern void * memchr(const void *,int,__kernel_size_t);
extern void * memcpy_flushcache(void *,const void *,__kernel_size_t);

void *__memset(void *s, int c, __kernel_size_t count);
void *__memcpy(void *to, const void *from, __kernel_size_t n);
void *__memmove(void *to, const void *from, __kernel_size_t n);
# 58 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h"
extern int memcpy_mcsafe(void *dst, const void *src, __kernel_size_t sz);
extern void *__memset16(uint16_t *, uint16_t v, __kernel_size_t);
extern void *__memset32(uint32_t *, uint32_t v, __kernel_size_t);
extern void *__memset64(uint64_t *, uint64_t v, __kernel_size_t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset16(uint16_t *p, uint16_t v, __kernel_size_t n)
{
 return __memset16(p, v, n * 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset32(uint32_t *p, uint32_t v, __kernel_size_t n)
{
 return __memset32(p, v, n * 4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset64(uint64_t *p, uint64_t v, __kernel_size_t n)
{
 return __memset64(p, v, n * 8);
}
# 21 "/home/nathan/src/linux-next/include/linux/string.h" 2


extern char * strcpy(char *,const char *);





size_t strlcpy(char *, const char *, size_t);


ssize_t strscpy(char *, const char *, size_t);



ssize_t strscpy_pad(char *dest, const char *src, size_t count);


extern char * strcat(char *, const char *);


extern char * strncat(char *, const char *, __kernel_size_t);


extern size_t strlcat(char *, const char *, __kernel_size_t);


extern int strcmp(const char *,const char *);





extern int strcasecmp(const char *s1, const char *s2);


extern int strncasecmp(const char *s1, const char *s2, size_t n);


extern char * strchr(const char *,int);


extern char * strchrnul(const char *,int);

extern char * strnchrnul(const char *, size_t, int);

extern char * strnchr(const char *, size_t, int);


extern char * strrchr(const char *,int);

extern char * __attribute__((__warn_unused_result__)) skip_spaces(const char *);

extern char *strim(char *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) char *strstrip(char *str)
{
 return strim(str);
}


extern char * strstr(const char *, const char *);


extern char * strnstr(const char *, const char *, size_t);


extern __kernel_size_t strlen(const char *);


extern __kernel_size_t strnlen(const char *,__kernel_size_t);


extern char * strpbrk(const char *,const char *);


extern char * strsep(char **,const char *);


extern __kernel_size_t strspn(const char *,const char *);


extern __kernel_size_t strcspn(const char *,const char *);
# 122 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset_l(unsigned long *p, unsigned long v,
  __kernel_size_t n)
{
 if (64 == 32)
  return memset32((uint32_t *)p, v, n);
 else
  return memset64((uint64_t *)p, v, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset_p(void **p, void *v, __kernel_size_t n)
{
 if (64 == 32)
  return memset32((uint32_t *)p, (uintptr_t)v, n);
 else
  return memset64((uint64_t *)p, (uintptr_t)v, n);
}

extern void **__memcat_p(void **a, void **b);
# 153 "/home/nathan/src/linux-next/include/linux/string.h"
extern void * memscan(void *,int,__kernel_size_t);





extern int bcmp(const void *,const void *,__kernel_size_t);
# 178 "/home/nathan/src/linux-next/include/linux/string.h"
void *memchr_inv(const void *s, int c, size_t n);
char *strreplace(char *s, char old, char new);

extern void kfree_const(const void *x);

extern char *kstrdup(const char *s, gfp_t gfp) __attribute__((__malloc__));
extern const char *kstrdup_const(const char *s, gfp_t gfp);
extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
extern char *kmemdup_nul(const char *s, size_t len, gfp_t gfp);

extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
extern void argv_free(char **argv);

extern bool sysfs_streq(const char *s1, const char *s2);
extern int kstrtobool(const char *s, bool *res);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int strtobool(const char *s, bool *res)
{
 return kstrtobool(s, res);
}

int match_string(const char * const *array, size_t n, const char *string);
int __sysfs_match_string(const char * const *array, size_t n, const char *s);
# 212 "/home/nathan/src/linux-next/include/linux/string.h"
int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);
int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __attribute__((__format__(printf, 3, 4)));


extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
           const void *from, size_t available);

int ptr_to_hashval(const void *ptr, unsigned long *hashval_out);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool strstarts(const char *str, const char *prefix)
{
 return strncmp(str, prefix, strlen(prefix)) == 0;
}

size_t memweight(const void *ptr, size_t bytes);
# 248 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memzero_explicit(void *s, size_t count)
{
 memset(s, 0, count);
 __asm__ __volatile__("" : : : "memory");
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kbasename(const char *path)
{
 const char *tail = strrchr(path, '/');
 return tail ? tail + 1 : path;
}




void fortify_panic(const char *name) __attribute__((__noreturn__)) __attribute__((__cold__));
void __read_overflow(void) ;
void __read_overflow2(void) ;
void __read_overflow3(void) ;
void __write_overflow(void) ;
# 300 "/home/nathan/src/linux-next/include/linux/string.h"
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) char *strncpy(char *p, const char *q, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __write_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __builtin_strncpy(p, q, size);
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) char *strcat(char *p, const char *q)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (p_size == (size_t)-1)
  return __builtin_strcat(p, q);
 if (strlcat(p, q, p_size) >= p_size)
  fortify_panic(__func__);
 return p;
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) __kernel_size_t strlen(const char *p)
{
 __kernel_size_t ret;
 size_t p_size = __builtin_object_size(p, 0);


 if (p_size == (size_t)-1 ||
     (__builtin_constant_p(p[p_size - 1]) && p[p_size - 1] == '\0'))
  return __builtin_strlen(p);
 ret = strnlen(p, p_size);
 if (p_size <= ret)
  fortify_panic(__func__);
 return ret;
}

extern __kernel_size_t __real_strnlen(const char *, __kernel_size_t) __asm__("strnlen");
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) __kernel_size_t strnlen(const char *p, __kernel_size_t maxlen)
{
 size_t p_size = __builtin_object_size(p, 0);
 __kernel_size_t ret = __real_strnlen(p, maxlen < p_size ? maxlen : p_size);
 if (p_size <= ret && maxlen != ret)
  fortify_panic(__func__);
 return ret;
}


extern size_t __real_strlcpy(char *, const char *, size_t) __asm__("strlcpy");
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) size_t strlcpy(char *p, const char *q, size_t size)
{
 size_t ret;
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (p_size == (size_t)-1 && q_size == (size_t)-1)
  return __real_strlcpy(p, q, size);
 ret = strlen(q);
 if (size) {
  size_t len = (ret >= size) ? size - 1 : ret;
  if (__builtin_constant_p(len) && len >= p_size)
   __write_overflow();
  if (len >= p_size)
   fortify_panic(__func__);
  __builtin_memcpy(p, q, len);
  p[len] = '\0';
 }
 return ret;
}


extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) char *strncat(char *p, const char *q, __kernel_size_t count)
{
 size_t p_len, copy_len;
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (p_size == (size_t)-1 && q_size == (size_t)-1)
  return __builtin_strncat(p, q, count);
 p_len = strlen(p);
 copy_len = strnlen(q, count);
 if (p_size < p_len + copy_len + 1)
  fortify_panic(__func__);
 __builtin_memcpy(p + p_len, q, copy_len);
 p[p_len + copy_len] = '\0';
 return p;
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memset(void *p, int c, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __write_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __builtin_memset(p, c, size);
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memcpy(void *p, const void *q, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (__builtin_constant_p(size)) {
  if (p_size < size)
   __write_overflow();
  if (q_size < size)
   __read_overflow2();
 }
 if (p_size < size || q_size < size)
  fortify_panic(__func__);
 return __builtin_memcpy(p, q, size);
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memmove(void *p, const void *q, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (__builtin_constant_p(size)) {
  if (p_size < size)
   __write_overflow();
  if (q_size < size)
   __read_overflow2();
 }
 if (p_size < size || q_size < size)
  fortify_panic(__func__);
 return __builtin_memmove(p, q, size);
}

extern void *__real_memscan(void *, int, __kernel_size_t) __asm__("memscan");
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memscan(void *p, int c, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __read_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __real_memscan(p, c, size);
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) int memcmp(const void *p, const void *q, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (__builtin_constant_p(size)) {
  if (p_size < size)
   __read_overflow();
  if (q_size < size)
   __read_overflow2();
 }
 if (p_size < size || q_size < size)
  fortify_panic(__func__);
 return __builtin_memcmp(p, q, size);
}

extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memchr(const void *p, int c, __kernel_size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __read_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __builtin_memchr(p, c, size);
}

void *__real_memchr_inv(const void *s, int c, size_t n) __asm__("memchr_inv");
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *memchr_inv(const void *p, int c, size_t size)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __read_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __real_memchr_inv(p, c, size);
}

extern void *__real_kmemdup(const void *src, size_t len, gfp_t gfp) __asm__("kmemdup");
extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) void *kmemdup(const void *p, size_t size, gfp_t gfp)
{
 size_t p_size = __builtin_object_size(p, 0);
 if (__builtin_constant_p(size) && p_size < size)
  __read_overflow();
 if (p_size < size)
  fortify_panic(__func__);
 return __real_kmemdup(p, size, gfp);
}


extern inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((gnu_inline)) char *strcpy(char *p, const char *q)
{
 size_t p_size = __builtin_object_size(p, 0);
 size_t q_size = __builtin_object_size(q, 0);
 if (p_size == (size_t)-1 && q_size == (size_t)-1)
  return __builtin_strcpy(p, q);
 memcpy(p, q, strlen(q) + 1);
 return p;
}
# 514 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcpy_and_pad(void *dest, size_t dest_len,
      const void *src, size_t count, int pad)
{
 if (dest_len > count) {
  memcpy(dest, src, count);
  memset(dest + count, pad, dest_len - count);
 } else
  memcpy(dest, src, dest_len);
}
# 539 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) size_t str_has_prefix(const char *str, const char *prefix)
{
 size_t len = strlen(prefix);
 return strncmp(str, prefix, len) == 0 ? len : 0;
}
# 10 "/home/nathan/src/linux-next/include/linux/bitmap.h" 2
# 121 "/home/nathan/src/linux-next/include/linux/bitmap.h"
extern unsigned long *bitmap_alloc(unsigned int nbits, gfp_t flags);
extern unsigned long *bitmap_zalloc(unsigned int nbits, gfp_t flags);
extern void bitmap_free(const unsigned long *bitmap);





extern int __bitmap_empty(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_full(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_equal(const unsigned long *bitmap1,
     const unsigned long *bitmap2, unsigned int nbits);
extern bool __attribute__((__pure__)) __bitmap_or_equal(const unsigned long *src1,
         const unsigned long *src2,
         const unsigned long *src3,
         unsigned int nbits);
extern void __bitmap_complement(unsigned long *dst, const unsigned long *src,
   unsigned int nbits);
extern void __bitmap_shift_right(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits);
extern void __bitmap_shift_left(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits);
extern void bitmap_cut(unsigned long *dst, const unsigned long *src,
         unsigned int first, unsigned int cut,
         unsigned int nbits);
extern int __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_replace(unsigned long *dst,
   const unsigned long *old, const unsigned long *new,
   const unsigned long *mask, unsigned int nbits);
extern int __bitmap_intersects(const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_subset(const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);
extern void __bitmap_set(unsigned long *map, unsigned int start, int len);
extern void __bitmap_clear(unsigned long *map, unsigned int start, int len);

extern unsigned long bitmap_find_next_zero_area_off(unsigned long *map,
          unsigned long size,
          unsigned long start,
          unsigned int nr,
          unsigned long align_mask,
          unsigned long align_offset);
# 184 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
bitmap_find_next_zero_area(unsigned long *map,
      unsigned long size,
      unsigned long start,
      unsigned int nr,
      unsigned long align_mask)
{
 return bitmap_find_next_zero_area_off(map, size, start, nr,
           align_mask, 0);
}

extern int bitmap_parse(const char *buf, unsigned int buflen,
   unsigned long *dst, int nbits);
extern int bitmap_parse_user(const char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern int bitmap_parselist(const char *buf, unsigned long *maskp,
   int nmaskbits);
extern int bitmap_parselist_user(const char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern void bitmap_remap(unsigned long *dst, const unsigned long *src,
  const unsigned long *old, const unsigned long *new, unsigned int nbits);
extern int bitmap_bitremap(int oldbit,
  const unsigned long *old, const unsigned long *new, int bits);
extern void bitmap_onto(unsigned long *dst, const unsigned long *orig,
  const unsigned long *relmap, unsigned int bits);
extern void bitmap_fold(unsigned long *dst, const unsigned long *orig,
  unsigned int sz, unsigned int nbits);
extern int bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order);
extern void bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order);
extern int bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order);






extern unsigned int bitmap_ord_to_pos(const unsigned long *bitmap, unsigned int ord, unsigned int nbits);
extern int bitmap_print_to_pagebuf(bool list, char *buf,
       const unsigned long *maskp, int nmaskbits);
# 235 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memset(dst, 0, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_fill(unsigned long *dst, unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memset(dst, 0xff, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_copy(unsigned long *dst, const unsigned long *src,
   unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memcpy(dst, src, len);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_copy_clear_tail(unsigned long *dst,
  const unsigned long *src, unsigned int nbits)
{
 bitmap_copy(dst, src, nbits);
 if (nbits % 64)
  dst[nbits / 64] &= (~0UL >> (-(nbits) & (64 - 1)));
}






extern void bitmap_from_arr32(unsigned long *bitmap, const u32 *buf,
       unsigned int nbits);
extern void bitmap_to_arr32(u32 *buf, const unsigned long *bitmap,
       unsigned int nbits);
# 283 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_and(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return (*dst = *src1 & *src2 & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 return __bitmap_and(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_or(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = *src1 | *src2;
 else
  __bitmap_or(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_xor(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = *src1 ^ *src2;
 else
  __bitmap_xor(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_andnot(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return (*dst = *src1 & ~(*src2) & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 return __bitmap_andnot(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_complement(unsigned long *dst, const unsigned long *src,
   unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = ~(*src);
 else
  __bitmap_complement(dst, src, nbits);
}
# 333 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_equal(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return !((*src1 ^ *src2) & (~0UL >> (-(nbits) & (64 - 1))));
 if (__builtin_constant_p(nbits & (8 - 1)) &&
     (((nbits) & ((typeof(nbits))(8) - 1)) == 0))
  return !memcmp(src1, src2, nbits / 8);
 return __bitmap_equal(src1, src2, nbits);
}
# 353 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bitmap_or_equal(const unsigned long *src1,
       const unsigned long *src2,
       const unsigned long *src3,
       unsigned int nbits)
{
 if (!(__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return __bitmap_or_equal(src1, src2, src3, nbits);

 return !(((*src1 | *src2) ^ *src3) & (~0UL >> (-(nbits) & (64 - 1))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_intersects(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ((*src1 & *src2) & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 else
  return __bitmap_intersects(src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_subset(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! ((*src1 & ~(*src2)) & (~0UL >> (-(nbits) & (64 - 1))));
 else
  return __bitmap_subset(src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_empty(const unsigned long *src, unsigned nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! (*src & (~0UL >> (-(nbits) & (64 - 1))));

 return find_next_bit((src), (nbits), 0) == nbits;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_full(const unsigned long *src, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! (~(*src) & (~0UL >> (-(nbits) & (64 - 1))));

 return find_next_zero_bit((src), (nbits), 0) == nbits;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int bitmap_weight(const unsigned long *src, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return hweight_long(*src & (~0UL >> (-(nbits) & (64 - 1))));
 return __bitmap_weight(src, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void bitmap_set(unsigned long *map, unsigned int start,
  unsigned int nbits)
{
 if (__builtin_constant_p(nbits) && nbits == 1)
  __set_bit(start, map);
 else if (__builtin_constant_p(start & (8 - 1)) &&
   (((start) & ((typeof(start))(8) - 1)) == 0) &&
   __builtin_constant_p(nbits & (8 - 1)) &&
   (((nbits) & ((typeof(nbits))(8) - 1)) == 0))
  memset((char *)map + start / 8, 0xff, nbits / 8);
 else
  __bitmap_set(map, start, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void bitmap_clear(unsigned long *map, unsigned int start,
  unsigned int nbits)
{
 if (__builtin_constant_p(nbits) && nbits == 1)
  __clear_bit(start, map);
 else if (__builtin_constant_p(start & (8 - 1)) &&
   (((start) & ((typeof(start))(8) - 1)) == 0) &&
   __builtin_constant_p(nbits & (8 - 1)) &&
   (((nbits) & ((typeof(nbits))(8) - 1)) == 0))
  memset((char *)map + start / 8, 0, nbits / 8);
 else
  __bitmap_clear(map, start, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_shift_right(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*src & (~0UL >> (-(nbits) & (64 - 1)))) >> shift;
 else
  __bitmap_shift_right(dst, src, shift, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_shift_left(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*src << shift) & (~0UL >> (-(nbits) & (64 - 1)));
 else
  __bitmap_shift_left(dst, src, shift, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_replace(unsigned long *dst,
      const unsigned long *old,
      const unsigned long *new,
      const unsigned long *mask,
      unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*old & ~(*mask)) | (*new & *mask);
 else
  __bitmap_replace(dst, old, new, mask, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_next_clear_region(unsigned long *bitmap,
         unsigned int *rs, unsigned int *re,
         unsigned int end)
{
 *rs = find_next_zero_bit(bitmap, end, *rs);
 *re = find_next_bit(bitmap, end, *rs + 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_next_set_region(unsigned long *bitmap,
       unsigned int *rs, unsigned int *re,
       unsigned int end)
{
 *rs = find_next_bit(bitmap, end, *rs);
 *re = find_next_zero_bit(bitmap, end, *rs + 1);
}
# 541 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_from_u64(unsigned long *dst, u64 mask)
{
 dst[0] = mask & (~0UL);

 if (sizeof(mask) > sizeof(unsigned long))
  dst[1] = mask >> 32;
}
# 557 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long bitmap_get_value8(const unsigned long *map,
           unsigned long start)
{
 const size_t index = ((start) / 64);
 const unsigned long offset = start % 64;

 return (map[index] >> offset) & 0xFF;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_set_value8(unsigned long *map, unsigned long value,
         unsigned long start)
{
 const size_t index = ((start) / 64);
 const unsigned long offset = start % 64;

 map[index] &= ~(0xFFUL << offset);
 map[index] |= value << offset;
}
# 13 "/home/nathan/src/linux-next/include/linux/cpumask.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/atomic.h" 1






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/bug.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h" 1
# 109 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bug.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/instrumentation.h" 1
# 7 "/home/nathan/src/linux-next/include/asm-generic/bug.h" 2
# 25 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
struct bug_entry {

 unsigned long bug_addr;





 const char *file;



 unsigned short line;

 unsigned short flags;
};
# 93 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
extern __attribute__((__format__(printf, 1, 2))) void __warn_printk(const char *fmt, ...);
# 111 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
struct warn_args;
struct pt_regs;

void __warn(const char *file, int line, void *caller, unsigned taint,
     struct pt_regs *regs, struct warn_args *args);
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h" 2



struct pt_regs;
extern int do_page_fault(struct pt_regs *, unsigned long, unsigned long);
extern void bad_page_fault(struct pt_regs *, unsigned long, int);
extern void _exception(int, struct pt_regs *, int, unsigned long);
extern void _exception_pkey(struct pt_regs *, unsigned long, int);
extern void die(const char *, struct pt_regs *, long);
extern bool die_will_crash(void);
extern void panic_flush_kmsg_start(void);
extern void panic_flush_kmsg_end(void);
# 6 "/home/nathan/src/linux-next/include/linux/bug.h" 2



enum bug_trap_type {
 BUG_TRAP_TYPE_NONE = 0,
 BUG_TRAP_TYPE_WARN = 1,
 BUG_TRAP_TYPE_BUG = 2,
};

struct pt_regs;
# 34 "/home/nathan/src/linux-next/include/linux/bug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_warning_bug(const struct bug_entry *bug)
{
 return bug->flags & (1 << 0);
}

struct bug_entry *find_bug(unsigned long bugaddr);

enum bug_trap_type report_bug(unsigned long bug_addr, struct pt_regs *regs);


int is_valid_bugaddr(unsigned long addr);

void generic_bug_clear_once(void);
# 70 "/home/nathan/src/linux-next/include/linux/bug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool check_data_corruption(bool v) { return v; }
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h" 2
# 80 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u8_local(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u8_relaxed(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u16_local(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u16_relaxed(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u32_local(volatile void *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2 \n"
"	stwcx.	%3,0,%2 \n	bne-	1b"

 : "=&r" (prev), "+m" (*(volatile unsigned int *)p)
 : "r" (p), "r" (val)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u32_relaxed(u32 *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2\n"
"	stwcx.	%3,0,%2\n"
"	bne-	1b"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (val)
 : "cc");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u64_local(volatile void *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2 \n"
"	stdcx.	%3,0,%2 \n	bne-	1b"

 : "=&r" (prev), "+m" (*(volatile unsigned long *)p)
 : "r" (p), "r" (val)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u64_relaxed(u64 *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2\n"
"	stdcx.	%3,0,%2\n"
"	bne-	1b"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (val)
 : "cc");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_local(void *ptr, unsigned long x, unsigned int size)
{
 switch (size) {
 case 1:
  return __xchg_u8_local(ptr, x);
 case 2:
  return __xchg_u16_local(ptr, x);
 case 4:
  return __xchg_u32_local(ptr, x);

 case 8:
  return __xchg_u64_local(ptr, x);

 }
 do { extern void __compiletime_assert_20(void) ; if (!(!(1))) __compiletime_assert_20(); } while (0);
 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_relaxed(void *ptr, unsigned long x, unsigned int size)
{
 switch (size) {
 case 1:
  return __xchg_u8_relaxed(ptr, x);
 case 2:
  return __xchg_u16_relaxed(ptr, x);
 case 4:
  return __xchg_u32_relaxed(ptr, x);

 case 8:
  return __xchg_u64_relaxed(ptr, x);

 }
 do { extern void __compiletime_assert_21(void) ; if (!(!(1))) __compiletime_assert_21(); } while (0);
 return x;
}
# 206 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "\n" "sync" " " "\n" "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "sync" " " "\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_local(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_acquire(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_relaxed(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "\n" "sync" " " "\n" "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "sync" " " "\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_local(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_acquire(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_relaxed(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = (off * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)
{
 unsigned int prev;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%2		# __cmpxchg_u32\n	cmpw	0,%0,%3\n	bne-	2f\n"


"	stwcx.	%4,0,%2\n	bne-	1b"

 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_local(volatile unsigned int *p, unsigned long old,
   unsigned long new)
{
 unsigned int prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32\n	cmpw	0,%0,%3\n	bne-	2f\n"


"	stwcx.	%4,0,%2\n	bne-	1b"

 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_relaxed(u32 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32_relaxed\n"
"	cmpw	0,%0,%3\n"
"	bne-	2f\n"
"	stwcx.	%4,0,%2\n"
"	bne-	1b\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc");

 return prev;
}
# 285 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_acquire(u32 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32_acquire\n"
"	cmpw	0,%0,%3\n"
"	bne-	2f\n"
"	stwcx.	%4,0,%2\n"
"	bne-	1b\n"
 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
 "\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%2		# __cmpxchg_u64\n	cmpd	0,%0,%3\n	bne-	2f\n	stdcx.	%4,0,%2\n	bne-	1b"




 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_local(volatile unsigned long *p, unsigned long old,
   unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64\n	cmpd	0,%0,%3\n	bne-	2f\n	stdcx.	%4,0,%2\n	bne-	1b"




 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_relaxed(u64 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64_relaxed\n"
"	cmpd	0,%0,%3\n"
"	bne-	2f\n"
"	stdcx.	%4,0,%2\n"
"	bne-	1b\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_acquire(u64 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64_acquire\n"
"	cmpd	0,%0,%3\n"
"	bne-	2f\n"
"	stdcx.	%4,0,%2\n"
"	bne-	1b\n"
 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
 "\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg(volatile void *ptr, unsigned long old, unsigned long new,
   unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8(ptr, old, new);
 case 2:
  return __cmpxchg_u16(ptr, old, new);
 case 4:
  return __cmpxchg_u32(ptr, old, new);

 case 8:
  return __cmpxchg_u64(ptr, old, new);

 }
 do { extern void __compiletime_assert_22(void) ; if (!(!(1))) __compiletime_assert_22(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_local(void *ptr, unsigned long old, unsigned long new,
   unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_local(ptr, old, new);
 case 2:
  return __cmpxchg_u16_local(ptr, old, new);
 case 4:
  return __cmpxchg_u32_local(ptr, old, new);

 case 8:
  return __cmpxchg_u64_local(ptr, old, new);

 }
 do { extern void __compiletime_assert_23(void) ; if (!(!(1))) __compiletime_assert_23(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_relaxed(void *ptr, unsigned long old, unsigned long new,
    unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_relaxed(ptr, old, new);
 case 2:
  return __cmpxchg_u16_relaxed(ptr, old, new);
 case 4:
  return __cmpxchg_u32_relaxed(ptr, old, new);

 case 8:
  return __cmpxchg_u64_relaxed(ptr, old, new);

 }
 do { extern void __compiletime_assert_24(void) ; if (!(!(1))) __compiletime_assert_24(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_acquire(void *ptr, unsigned long old, unsigned long new,
    unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_acquire(ptr, old, new);
 case 2:
  return __cmpxchg_u16_acquire(ptr, old, new);
 case 4:
  return __cmpxchg_u32_acquire(ptr, old, new);

 case 8:
  return __cmpxchg_u64_acquire(ptr, old, new);

 }
 do { extern void __compiletime_assert_25(void) ; if (!(!(1))) __compiletime_assert_25(); } while (0);
 return old;
}
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h" 2
# 27 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_read(const atomic_t *v)
{
 int t;

 __asm__ __volatile__("lwz%U1%X1 %0,%1" : "=r"(t) : "m"(v->counter));

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_set(atomic_t *v, int i)
{
 __asm__ __volatile__("stw%U0%X0 %1,%0" : "=m"(v->counter) : "r"(i));
}
# 95 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_add(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "add" "\n" "add" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_add_return_relaxed(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "add" "_return_relaxed\n" "add" " %0,%2,%0\n" "	stwcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_add_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "add" "_relaxed\n" "add" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_sub(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "sub" "\n" "subf" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_sub_return_relaxed(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "sub" "_return_relaxed\n" "subf" " %0,%2,%0\n" "	stwcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_sub_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "sub" "_relaxed\n" "subf" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 109 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_and(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "and" "\n" "and" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_and_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "and" "_relaxed\n" "and" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_or(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "or" "\n" "or" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_or_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "or" "_relaxed\n" "or" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_xor(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "xor" "\n" "xor" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_xor_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "xor" "_relaxed\n" "xor" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 122 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_inc(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_inc\n	addic	%0,%0,1\n"

"	stwcx.	%0,0,%2 \n	bne-	1b"

 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_inc_return_relaxed(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_inc_return_relaxed\n"
"	addic	%0,%0,1\n"
"	stwcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_dec(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_dec\n	addic	%0,%0,-1\n"

"	stwcx.	%0,0,%2\n	bne-	1b"

 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_dec_return_relaxed(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_dec_return_relaxed\n"
"	addic	%0,%0,-1\n"
"	stwcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}
# 205 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_add_unless(atomic_t *v, int a, int u)
{
 int t;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%1		# atomic_fetch_add_unless\n	cmpw	0,%0,%3 \n	beq	2f \n	add	%0,%2,%0 \n"



"	stwcx.	%0,0,%1 \n	bne-	1b \n"

 "\n" "sync" " " "\n"
"	subf	%0,%2,%0 \n2:"

 : "=&r" (t)
 : "r" (&v->counter), "r" (a), "r" (u)
 : "cc", "memory");

 return t;
}
# 235 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_inc_not_zero(atomic_t *v)
{
 int t1, t2;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%2		# atomic_inc_not_zero\n	cmpwi	0,%0,0\n	beq-	2f\n	addic	%1,%0,1\n"



"	stwcx.	%1,0,%2\n	bne-	1b\n"

 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (t1), "=&r" (t2)
 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t1;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_dec_if_positive(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%1		# atomic_dec_if_positive\n	cmpwi	%0,1\n	addi	%0,%0,-1\n	blt-	2f\n"



"	stwcx.	%0,0,%1\n	bne-	1b"

 "\n" "sync" " " "\n"
 "\n2:" : "=&b" (t)

 : "r" (&v->counter)
 : "cc", "memory");

 return t;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_read(const atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__("ld%U1%X1 %0,%1" : "=r"(t) : "m"(v->counter));

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_set(atomic64_t *v, s64 i)
{
 __asm__ __volatile__("std%U0%X0 %1,%0" : "=m"(v->counter) : "r"(i));
}
# 359 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_add(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "add" "\n" "add" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_add_return_relaxed(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "add" "_return_relaxed\n" "add" " %0,%2,%0\n" "	stdcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_add_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "add" "_relaxed\n" "add" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_sub(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "sub" "\n" "subf" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_sub_return_relaxed(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "sub" "_return_relaxed\n" "subf" " %0,%2,%0\n" "	stdcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_sub_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "sub" "_relaxed\n" "subf" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 373 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_and(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "and" "\n" "and" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_and_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "and" "_relaxed\n" "and" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_or(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "or" "\n" "or" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_or_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "or" "_relaxed\n" "or" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_xor(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "xor" "\n" "xor" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_xor_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "xor" "_relaxed\n" "xor" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 386 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_inc(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_inc\n	addic	%0,%0,1\n	stdcx.	%0,0,%2 \n	bne-	1b"



 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_inc_return_relaxed(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_inc_return_relaxed\n"
"	addic	%0,%0,1\n"
"	stdcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_dec(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_dec\n	addic	%0,%0,-1\n	stdcx.	%0,0,%2\n	bne-	1b"



 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_dec_return_relaxed(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_dec_return_relaxed\n"
"	addic	%0,%0,-1\n"
"	stdcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}
# 455 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_dec_if_positive(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%1		# atomic64_dec_if_positive\n	addic.	%0,%0,-1\n	blt-	2f\n	stdcx.	%0,0,%1\n	bne-	1b"




 "\n" "sync" " " "\n"
 "\n2:" : "=&r" (t)

 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t;
}
# 494 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)
{
 s64 t;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%1		# atomic64_fetch_add_unless\n	cmpd	0,%0,%3 \n	beq	2f \n	add	%0,%2,%0 \n"



"	stdcx.	%0,0,%1 \n	bne-	1b \n"

 "\n" "sync" " " "\n"
"	subf	%0,%2,%0 \n2:"

 : "=&r" (t)
 : "r" (&v->counter), "r" (a), "r" (u)
 : "cc", "memory");

 return t;
}
# 524 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic64_inc_not_zero(atomic64_t *v)
{
 s64 t1, t2;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%2		# atomic64_inc_not_zero\n	cmpdi	0,%0,0\n	beq-	2f\n	addic	%1,%0,1\n	stdcx.	%1,0,%2\n	bne-	1b\n"





 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (t1), "=&r" (t2)
 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t1 != 0;
}
# 8 "/home/nathan/src/linux-next/include/linux/atomic.h" 2
# 84 "/home/nathan/src/linux-next/include/linux/atomic.h"
# 1 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h" 1
# 81 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_read_acquire(const atomic_t *v)
{
 return ({ typeof(*&(v)->counter) ___p1 = ({ do { extern void __compiletime_assert_26(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)) || sizeof(*&(v)->counter) == sizeof(long long))) __compiletime_assert_26(); } while (0); ({ typeof( _Generic((*&(v)->counter), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&(v)->counter))) __x = (*(const volatile typeof( _Generic((*&(v)->counter), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&(v)->counter))) *)&(*&(v)->counter)); do { } while (0); (typeof(*&(v)->counter))__x; }); }); do { extern void __compiletime_assert_27(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_27(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_set_release(atomic_t *v, int i)
{
 do { do { extern void __compiletime_assert_28(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_28(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_29(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)) || sizeof(*&(v)->counter) == sizeof(long long))) __compiletime_assert_29(); } while (0); do { *(volatile typeof(*&(v)->counter) *)&(*&(v)->counter) = (i); } while (0); } while (0); } while (0);
}
# 105 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_add_return_acquire(int i, atomic_t *v)
{
 int ret = atomic_add_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_add_return_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_add_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_add_return(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_add_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 147 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_add_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_add_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_add_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_add_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_add(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_add_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 189 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_sub_return_acquire(int i, atomic_t *v)
{
 int ret = atomic_sub_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_sub_return_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_sub_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_sub_return(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_sub_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 231 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_sub_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_sub_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_sub_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_sub_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_sub(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_sub_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 321 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_inc_return_acquire(atomic_t *v)
{
 int ret = atomic_inc_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_inc_return_release(atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_inc_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_inc_return(atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_inc_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 364 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_inc(atomic_t *v)
{
 return atomic_fetch_add(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_inc_acquire(atomic_t *v)
{
 return atomic_fetch_add_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_inc_release(atomic_t *v)
{
 return atomic_fetch_add_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_inc_relaxed(atomic_t *v)
{
 return atomic_fetch_add_relaxed(1, v);
}
# 492 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_dec_return_acquire(atomic_t *v)
{
 int ret = atomic_dec_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_dec_return_release(atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_dec_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_dec_return(atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_dec_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 535 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_dec(atomic_t *v)
{
 return atomic_fetch_sub(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_dec_acquire(atomic_t *v)
{
 return atomic_fetch_sub_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_dec_release(atomic_t *v)
{
 return atomic_fetch_sub_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_dec_relaxed(atomic_t *v)
{
 return atomic_fetch_sub_relaxed(1, v);
}
# 615 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_and_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_and_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_and_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_and_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_and(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_and_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_andnot(int i, atomic_t *v)
{
 atomic_and(~i, v);
}
# 667 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_andnot(int i, atomic_t *v)
{
 return atomic_fetch_and(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_andnot_acquire(int i, atomic_t *v)
{
 return atomic_fetch_and_acquire(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_andnot_release(int i, atomic_t *v)
{
 return atomic_fetch_and_release(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_andnot_relaxed(int i, atomic_t *v)
{
 return atomic_fetch_and_relaxed(~i, v);
}
# 747 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_or_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_or_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_or_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_or_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_or(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_or_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 789 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_xor_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_xor_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_xor_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_xor_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_fetch_xor(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_xor_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 831 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_xchg_acquire(atomic_t *v, int i)
{
 int ret = ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_xchg_release(atomic_t *v, int i)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}
# 884 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int
atomic_cmpxchg_release(atomic_t *v, int old, int new)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}
# 916 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_try_cmpxchg(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = (({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_try_cmpxchg_acquire(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_try_cmpxchg_release(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = atomic_cmpxchg_release(v, o, new);
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_try_cmpxchg_relaxed(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}
# 1015 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_sub_and_test(int i, atomic_t *v)
{
 return atomic_sub_return(i, v) == 0;
}
# 1032 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_dec_and_test(atomic_t *v)
{
 return atomic_dec_return(v) == 0;
}
# 1049 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_inc_and_test(atomic_t *v)
{
 return atomic_inc_return(v) == 0;
}
# 1067 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_add_negative(int i, atomic_t *v)
{
 return atomic_add_return(i, v) < 0;
}
# 1110 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_add_unless(atomic_t *v, int a, int u)
{
 return atomic_fetch_add_unless(v, a, u) != u;
}
# 1135 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_inc_unless_negative(atomic_t *v)
{
 int c = atomic_read(v);

 do {
  if (__builtin_expect(!!(c < 0), 0))
   return false;
 } while (!atomic_try_cmpxchg(v, &c, c + 1));

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_dec_unless_positive(atomic_t *v)
{
 int c = atomic_read(v);

 do {
  if (__builtin_expect(!!(c > 0), 0))
   return false;
 } while (!atomic_try_cmpxchg(v, &c, c - 1));

 return true;
}
# 1188 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_read_acquire(const atomic64_t *v)
{
 return ({ typeof(*&(v)->counter) ___p1 = ({ do { extern void __compiletime_assert_30(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)) || sizeof(*&(v)->counter) == sizeof(long long))) __compiletime_assert_30(); } while (0); ({ typeof( _Generic((*&(v)->counter), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&(v)->counter))) __x = (*(const volatile typeof( _Generic((*&(v)->counter), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&(v)->counter))) *)&(*&(v)->counter)); do { } while (0); (typeof(*&(v)->counter))__x; }); }); do { extern void __compiletime_assert_31(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_31(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic64_set_release(atomic64_t *v, s64 i)
{
 do { do { extern void __compiletime_assert_32(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_32(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_33(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)) || sizeof(*&(v)->counter) == sizeof(long long))) __compiletime_assert_33(); } while (0); do { *(volatile typeof(*&(v)->counter) *)&(*&(v)->counter) = (i); } while (0); } while (0); } while (0);
}
# 1212 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_add_return_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_add_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_add_return_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_add_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_add_return(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_add_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1254 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_add_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_add_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_add_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_add_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_add(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_add_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1296 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_sub_return_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_sub_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_sub_return_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_sub_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_sub_return(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_sub_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1338 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_sub_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_sub_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_sub_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_sub_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_sub(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_sub_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1428 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_inc_return_acquire(atomic64_t *v)
{
 s64 ret = atomic64_inc_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_inc_return_release(atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_inc_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_inc_return(atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_inc_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1471 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_inc(atomic64_t *v)
{
 return atomic64_fetch_add(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_inc_acquire(atomic64_t *v)
{
 return atomic64_fetch_add_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_inc_release(atomic64_t *v)
{
 return atomic64_fetch_add_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_inc_relaxed(atomic64_t *v)
{
 return atomic64_fetch_add_relaxed(1, v);
}
# 1599 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_dec_return_acquire(atomic64_t *v)
{
 s64 ret = atomic64_dec_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_dec_return_release(atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_dec_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_dec_return(atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_dec_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1642 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_dec(atomic64_t *v)
{
 return atomic64_fetch_sub(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_dec_acquire(atomic64_t *v)
{
 return atomic64_fetch_sub_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_dec_release(atomic64_t *v)
{
 return atomic64_fetch_sub_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_dec_relaxed(atomic64_t *v)
{
 return atomic64_fetch_sub_relaxed(1, v);
}
# 1722 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_and_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_and_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_and_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_and_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_and(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_and_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic64_andnot(s64 i, atomic64_t *v)
{
 atomic64_and(~i, v);
}
# 1774 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_andnot(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_andnot_acquire(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_acquire(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_andnot_release(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_release(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_andnot_relaxed(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_relaxed(~i, v);
}
# 1854 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_or_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_or_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_or_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_or_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_or(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_or_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1896 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_xor_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_xor_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_xor_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_xor_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_fetch_xor(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_xor_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1938 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_xchg_acquire(atomic64_t *v, s64 i)
{
 s64 ret = ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_xchg_release(atomic64_t *v, s64 i)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}
# 1991 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) s64
atomic64_cmpxchg_release(atomic64_t *v, s64 old, s64 new)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}
# 2023 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_try_cmpxchg(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = (({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_try_cmpxchg_acquire(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_try_cmpxchg_release(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = atomic64_cmpxchg_release(v, o, new);
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_try_cmpxchg_relaxed(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}
# 2122 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_sub_and_test(s64 i, atomic64_t *v)
{
 return atomic64_sub_return(i, v) == 0;
}
# 2139 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_dec_and_test(atomic64_t *v)
{
 return atomic64_dec_return(v) == 0;
}
# 2156 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_inc_and_test(atomic64_t *v)
{
 return atomic64_inc_return(v) == 0;
}
# 2174 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_add_negative(s64 i, atomic64_t *v)
{
 return atomic64_add_return(i, v) < 0;
}
# 2217 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_add_unless(atomic64_t *v, s64 a, s64 u)
{
 return atomic64_fetch_add_unless(v, a, u) != u;
}
# 2242 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_inc_unless_negative(atomic64_t *v)
{
 s64 c = atomic64_read(v);

 do {
  if (__builtin_expect(!!(c < 0), 0))
   return false;
 } while (!atomic64_try_cmpxchg(v, &c, c + 1));

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic64_dec_unless_positive(atomic64_t *v)
{
 s64 c = atomic64_read(v);

 do {
  if (__builtin_expect(!!(c > 0), 0))
   return false;
 } while (!atomic64_try_cmpxchg(v, &c, c - 1));

 return true;
}
# 85 "/home/nathan/src/linux-next/include/linux/atomic.h" 2


# 1 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h" 1
# 13 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
# 26 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_read(const atomic_long_t *v)
{
 return atomic64_read(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_read_acquire(const atomic_long_t *v)
{
 return atomic64_read_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_set(atomic_long_t *v, long i)
{
 atomic64_set(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_set_release(atomic_long_t *v, long i)
{
 atomic64_set_release(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_add(long i, atomic_long_t *v)
{
 atomic64_add(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_add_return(long i, atomic_long_t *v)
{
 return atomic64_add_return(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_add_return_acquire(long i, atomic_long_t *v)
{
 return atomic64_add_return_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_add_return_release(long i, atomic_long_t *v)
{
 return atomic64_add_return_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_add_return_relaxed(long i, atomic_long_t *v)
{
 return atomic64_add_return_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_add(long i, atomic_long_t *v)
{
 return atomic64_fetch_add(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_add_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_sub(long i, atomic_long_t *v)
{
 atomic64_sub(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_sub_return(long i, atomic_long_t *v)
{
 return atomic64_sub_return(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_sub_return_acquire(long i, atomic_long_t *v)
{
 return atomic64_sub_return_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_sub_return_release(long i, atomic_long_t *v)
{
 return atomic64_sub_return_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
{
 return atomic64_sub_return_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_sub(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_sub_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_inc(atomic_long_t *v)
{
 atomic64_inc(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_inc_return(atomic_long_t *v)
{
 return atomic64_inc_return(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_inc_return_acquire(atomic_long_t *v)
{
 return atomic64_inc_return_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_inc_return_release(atomic_long_t *v)
{
 return atomic64_inc_return_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_inc_return_relaxed(atomic_long_t *v)
{
 return atomic64_inc_return_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_inc(atomic_long_t *v)
{
 return atomic64_fetch_inc(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_inc_acquire(atomic_long_t *v)
{
 return atomic64_fetch_inc_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_inc_release(atomic_long_t *v)
{
 return atomic64_fetch_inc_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_inc_relaxed(atomic_long_t *v)
{
 return atomic64_fetch_inc_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_dec(atomic_long_t *v)
{
 atomic64_dec(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_dec_return(atomic_long_t *v)
{
 return atomic64_dec_return(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_dec_return_acquire(atomic_long_t *v)
{
 return atomic64_dec_return_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_dec_return_release(atomic_long_t *v)
{
 return atomic64_dec_return_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_dec_return_relaxed(atomic_long_t *v)
{
 return atomic64_dec_return_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_dec(atomic_long_t *v)
{
 return atomic64_fetch_dec(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_dec_acquire(atomic_long_t *v)
{
 return atomic64_fetch_dec_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_dec_release(atomic_long_t *v)
{
 return atomic64_fetch_dec_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_dec_relaxed(atomic_long_t *v)
{
 return atomic64_fetch_dec_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_and(long i, atomic_long_t *v)
{
 atomic64_and(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_and(long i, atomic_long_t *v)
{
 return atomic64_fetch_and(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_and_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_and_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_and_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_andnot(long i, atomic_long_t *v)
{
 atomic64_andnot(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_andnot(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_andnot_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_andnot_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_or(long i, atomic_long_t *v)
{
 atomic64_or(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_or(long i, atomic_long_t *v)
{
 return atomic64_fetch_or(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_or_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_or_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_or_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
atomic_long_xor(long i, atomic_long_t *v)
{
 atomic64_xor(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_xor(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_xor_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_xor_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_xor_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_xchg(atomic_long_t *v, long i)
{
 return (({ typeof(({ __typeof__(*(&((v)->counter))) _x_ = (i); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&((v)->counter))) _x_ = (i); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_xchg_acquire(atomic_long_t *v, long i)
{
 return atomic64_xchg_acquire(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_xchg_release(atomic_long_t *v, long i)
{
 return atomic64_xchg_release(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_xchg_relaxed(atomic_long_t *v, long i)
{
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_cmpxchg(atomic_long_t *v, long old, long new)
{
 return (({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_cmpxchg_acquire(atomic_long_t *v, long old, long new)
{
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_cmpxchg_release(atomic_long_t *v, long old, long new)
{
 return atomic64_cmpxchg_release(v, old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_cmpxchg_relaxed(atomic_long_t *v, long old, long new)
{
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_try_cmpxchg_acquire(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_acquire(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_try_cmpxchg_release(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_release(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_try_cmpxchg_relaxed(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_relaxed(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_sub_and_test(long i, atomic_long_t *v)
{
 return atomic64_sub_and_test(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_dec_and_test(atomic_long_t *v)
{
 return atomic64_dec_and_test(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_inc_and_test(atomic_long_t *v)
{
 return atomic64_inc_and_test(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_add_negative(long i, atomic_long_t *v)
{
 return atomic64_add_negative(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u)
{
 return atomic64_fetch_add_unless(v, a, u);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_add_unless(atomic_long_t *v, long a, long u)
{
 return atomic64_add_unless(v, a, u);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_inc_not_zero(atomic_long_t *v)
{
 return atomic64_inc_not_zero((v));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_inc_unless_negative(atomic_long_t *v)
{
 return atomic64_inc_unless_negative(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
atomic_long_dec_unless_positive(atomic_long_t *v)
{
 return atomic64_dec_unless_positive(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
atomic_long_dec_if_positive(atomic_long_t *v)
{
 return atomic64_dec_if_positive(v);
}
# 88 "/home/nathan/src/linux-next/include/linux/atomic.h" 2
# 14 "/home/nathan/src/linux-next/include/linux/cpumask.h" 2



typedef struct cpumask { unsigned long bits[(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))]; } cpumask_t;
# 39 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern unsigned int nr_cpu_ids;
# 90 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern struct cpumask __cpu_possible_mask;
extern struct cpumask __cpu_online_mask;
extern struct cpumask __cpu_present_mask;
extern struct cpumask __cpu_active_mask;





extern atomic_t __num_online_cpus;
# 110 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int num_online_cpus(void)
{
 return atomic_read(&__num_online_cpus);
}
# 132 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern cpumask_t cpus_booted_once_mask;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)
{



}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_check(unsigned int cpu)
{
 cpu_max_bits_warn(cpu, ((unsigned int)2048));
 return cpu;
}
# 217 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_first(const struct cpumask *srcp)
{
 return find_next_bit((((srcp)->bits)), (((unsigned int)2048)), 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_last(const struct cpumask *srcp)
{
 return find_last_bit(((srcp)->bits), ((unsigned int)2048));
}

unsigned int cpumask_next(int n, const struct cpumask *srcp);
# 242 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
{

 if (n != -1)
  cpumask_check(n);
 return find_next_zero_bit(((srcp)->bits), ((unsigned int)2048), n+1);
}

int cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);
int cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
unsigned int cpumask_local_spread(unsigned int i, int node);
int cpumask_any_and_distribute(const struct cpumask *src1p,
          const struct cpumask *src2p);
# 280 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);
# 332 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
 set_bit(cpumask_check(cpu), ((dstp)->bits));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
 __set_bit(cpumask_check(cpu), ((dstp)->bits));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
 clear_bit(cpumask_check(cpu), ((dstp)->bits));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
 __clear_bit(cpumask_check(cpu), ((dstp)->bits));
}
# 365 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)
{
 return test_bit(cpumask_check(cpu), (((cpumask))->bits));
}
# 379 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_set_bit(cpumask_check(cpu), ((cpumask)->bits));
}
# 393 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_clear_bit(cpumask_check(cpu), ((cpumask)->bits));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_setall(struct cpumask *dstp)
{
 bitmap_fill(((dstp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_clear(struct cpumask *dstp)
{
 bitmap_zero(((dstp)->bits), ((unsigned int)2048));
}
# 424 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_and(struct cpumask *dstp,
          const struct cpumask *src1p,
          const struct cpumask *src2p)
{
 return bitmap_and(((dstp)->bits), ((src1p)->bits),
           ((src2p)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,
         const struct cpumask *src2p)
{
 bitmap_or(((dstp)->bits), ((src1p)->bits),
          ((src2p)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_xor(struct cpumask *dstp,
          const struct cpumask *src1p,
          const struct cpumask *src2p)
{
 bitmap_xor(((dstp)->bits), ((src1p)->bits),
           ((src2p)->bits), ((unsigned int)2048));
}
# 467 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_andnot(struct cpumask *dstp,
      const struct cpumask *src1p,
      const struct cpumask *src2p)
{
 return bitmap_andnot(((dstp)->bits), ((src1p)->bits),
       ((src2p)->bits), ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_complement(struct cpumask *dstp,
          const struct cpumask *srcp)
{
 bitmap_complement(((dstp)->bits), ((srcp)->bits),
           ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_equal(const struct cpumask *src1p,
    const struct cpumask *src2p)
{
 return bitmap_equal(((src1p)->bits), ((src2p)->bits),
       ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_or_equal(const struct cpumask *src1p,
        const struct cpumask *src2p,
        const struct cpumask *src3p)
{
 return bitmap_or_equal(((src1p)->bits), ((src2p)->bits),
          ((src3p)->bits), ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_intersects(const struct cpumask *src1p,
         const struct cpumask *src2p)
{
 return bitmap_intersects(((src1p)->bits), ((src2p)->bits),
            ((unsigned int)2048));
}
# 532 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_subset(const struct cpumask *src1p,
     const struct cpumask *src2p)
{
 return bitmap_subset(((src1p)->bits), ((src2p)->bits),
        ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_empty(const struct cpumask *srcp)
{
 return bitmap_empty(((srcp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_full(const struct cpumask *srcp)
{
 return bitmap_full(((srcp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_weight(const struct cpumask *srcp)
{
 return bitmap_weight(((srcp)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_shift_right(struct cpumask *dstp,
           const struct cpumask *srcp, int n)
{
 bitmap_shift_right(((dstp)->bits), ((srcp)->bits), n,
            ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_shift_left(struct cpumask *dstp,
          const struct cpumask *srcp, int n)
{
 bitmap_shift_left(((dstp)->bits), ((srcp)->bits), n,
           ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_copy(struct cpumask *dstp,
    const struct cpumask *srcp)
{
 bitmap_copy(((dstp)->bits), ((srcp)->bits), ((unsigned int)2048));
}
# 643 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parse_user(const char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parse_user(buf, len, ((dstp)->bits), ((unsigned int)2048));
}
# 657 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parselist_user(const char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parselist_user(buf, len, ((dstp)->bits),
         ((unsigned int)2048));
}
# 671 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parse(const char *buf, struct cpumask *dstp)
{
 return bitmap_parse(buf, (~0U), ((dstp)->bits), ((unsigned int)2048));
}
# 683 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpulist_parse(const char *buf, struct cpumask *dstp)
{
 return bitmap_parselist(buf, ((dstp)->bits), ((unsigned int)2048));
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_size(void)
{
 return (((((unsigned int)2048)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(long);
}
# 756 "/home/nathan/src/linux-next/include/linux/cpumask.h"
typedef struct cpumask cpumask_var_t[1];




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 cpumask_clear(*mask);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 cpumask_clear(*mask);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_cpumask_var(cpumask_var_t mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_bootmem_cpumask_var(cpumask_var_t mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_available(cpumask_var_t mask)
{
 return true;
}




extern const unsigned long cpu_all_bits[(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
# 816 "/home/nathan/src/linux-next/include/linux/cpumask.h"
void init_cpu_present(const struct cpumask *src);
void init_cpu_possible(const struct cpumask *src);
void init_cpu_online(const struct cpumask *src);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reset_cpu_possible_mask(void)
{
 bitmap_zero(((&__cpu_possible_mask)->bits), 2048);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_possible(unsigned int cpu, bool possible)
{
 if (possible)
  cpumask_set_cpu(cpu, &__cpu_possible_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_possible_mask);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_present(unsigned int cpu, bool present)
{
 if (present)
  cpumask_set_cpu(cpu, &__cpu_present_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_present_mask);
}

void set_cpu_online(unsigned int cpu, bool online);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_active(unsigned int cpu, bool active)
{
 if (active)
  cpumask_set_cpu(cpu, &__cpu_active_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_active_mask);
}
# 869 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __check_is_bitmap(const unsigned long *bitmap)
{
 return 1;
}
# 881 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern const unsigned long
 cpu_bit_bitmap[64 +1][(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *get_cpu_mask(unsigned int cpu)
{
 const unsigned long *p = cpu_bit_bitmap[1 + cpu % 64];
 p -= cpu / 64;
 return ((struct cpumask *)(1 ? (p) : (void *)sizeof(__check_is_bitmap(p))));
}
# 918 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t
cpumap_print_to_pagebuf(bool list, char *buf, const struct cpumask *mask)
{
 return bitmap_print_to_pagebuf(list, buf, ((mask)->bits),
          nr_cpu_ids);
}
# 14 "/home/nathan/src/linux-next/include/linux/smp.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/llist.h" 1
# 54 "/home/nathan/src/linux-next/include/linux/llist.h"
struct llist_head {
 struct llist_node *first;
};

struct llist_node {
 struct llist_node *next;
};
# 69 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_llist_head(struct llist_head *list)
{
 list->first = ((void *)0);
}
# 187 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool llist_empty(const struct llist_head *head)
{
 return ({ do { extern void __compiletime_assert_34(void) ; if (!((sizeof(head->first) == sizeof(char) || sizeof(head->first) == sizeof(short) || sizeof(head->first) == sizeof(int) || sizeof(head->first) == sizeof(long)) || sizeof(head->first) == sizeof(long long))) __compiletime_assert_34(); } while (0); ({ typeof( _Generic((head->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head->first))) __x = (*(const volatile typeof( _Generic((head->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head->first))) *)&(head->first)); do { } while (0); (typeof(head->first))__x; }); }) == ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct llist_node *llist_next(struct llist_node *node)
{
 return node->next;
}

extern bool llist_add_batch(struct llist_node *new_first,
       struct llist_node *new_last,
       struct llist_head *head);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool llist_add(struct llist_node *new, struct llist_head *head)
{
 return llist_add_batch(new, new, head);
}
# 220 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct llist_node *llist_del_all(struct llist_head *head)
{
 return ({ typeof(({ __typeof__(*(&head->first)) _x_ = (((void *)0)); (__typeof__(*(&head->first))) __xchg_relaxed((&head->first), (unsigned long)_x_, sizeof(*(&head->first))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&head->first)) _x_ = (((void *)0)); (__typeof__(*(&head->first))) __xchg_relaxed((&head->first), (unsigned long)_x_, sizeof(*(&head->first))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
}

extern struct llist_node *llist_del_first(struct llist_head *head);

struct llist_node *llist_reverse_order(struct llist_node *head);
# 16 "/home/nathan/src/linux-next/include/linux/smp.h" 2

typedef void (*smp_call_func_t)(void *info);
typedef bool (*smp_cond_func_t)(int cpu, void *info);

enum {
 CSD_FLAG_LOCK = 0x01,



 CSD_TYPE_ASYNC = 0x00,
 CSD_TYPE_SYNC = 0x10,
 CSD_TYPE_IRQ_WORK = 0x20,
 CSD_TYPE_TTWU = 0x30,
 CSD_FLAG_TYPE_MASK = 0xF0,
};




struct __call_single_data {
 struct llist_node llist;
 unsigned int flags;
 smp_call_func_t func;
 void *info;
};


typedef struct __call_single_data call_single_data_t
 __attribute__((__aligned__(sizeof(struct __call_single_data))));





extern void __smp_call_single_queue(int cpu, struct llist_node *node);


extern unsigned int total_cpus;

int smp_call_function_single(int cpuid, smp_call_func_t func, void *info,
        int wait);




void on_each_cpu(smp_call_func_t func, void *info, int wait);





void on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,
  void *info, bool wait);






void on_each_cpu_cond(smp_cond_func_t cond_func, smp_call_func_t func,
        void *info, bool wait);

void on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,
      void *info, bool wait, const struct cpumask *mask);

int smp_call_function_single_async(int cpu, call_single_data_t *csd);




# 1 "/home/nathan/src/linux-next/include/linux/preempt.h" 1
# 78 "/home/nathan/src/linux-next/include/linux/preempt.h"
# 1 "./arch/powerpc/include/generated/asm/preempt.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/preempt.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/thread_info.h"
# 1 "/home/nathan/src/linux-next/include/linux/restart_block.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/restart_block.h"
# 1 "/home/nathan/src/linux-next/include/linux/time64.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/math64.h" 1





# 1 "/home/nathan/src/linux-next/include/vdso/math64.h" 1




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32
__iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
 u32 ret = 0;

 while (dividend >= divisor) {


  asm("" : "+rm"(dividend));

  dividend -= divisor;
  ret++;
 }

 *remainder = dividend;

 return ret;
}
# 7 "/home/nathan/src/linux-next/include/linux/math64.h" 2
# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/math64.h" 2
# 25 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 39 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 53 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 66 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div64_u64(u64 dividend, u64 divisor)
{
 return dividend / divisor;
}
# 78 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div64_s64(s64 dividend, s64 divisor)
{
 return dividend / divisor;
}
# 124 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div_u64(u64 dividend, u32 divisor)
{
 u32 remainder;
 return div_u64_rem(dividend, divisor, &remainder);
}
# 137 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div_s64(s64 dividend, s32 divisor)
{
 s32 remainder;
 return div_s64_rem(dividend, divisor, &remainder);
}


u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u32_u32(u32 a, u32 b)
{
 return (u64)a * b;
}
# 175 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
 u32 ah, al;
 u64 ret;

 al = a;
 ah = a >> 32;

 ret = mul_u32_u32(al, mul) >> shift;
 if (ah)
  ret += mul_u32_u32(ah, mul) << (32 - shift);

 return ret;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u64_shr(u64 a, u64 b, unsigned int shift)
{
 union {
  u64 ll;
  struct {



   u32 low, high;

  } l;
 } rl, rm, rn, rh, a0, b0;
 u64 c;

 a0.ll = a;
 b0.ll = b;

 rl.ll = mul_u32_u32(a0.l.low, b0.l.low);
 rm.ll = mul_u32_u32(a0.l.low, b0.l.high);
 rn.ll = mul_u32_u32(a0.l.high, b0.l.low);
 rh.ll = mul_u32_u32(a0.l.high, b0.l.high);






 rl.l.high = c = (u64)rl.l.high + rm.l.low + rn.l.low;
 rh.l.low = c = (c >> 32) + rm.l.high + rn.l.high + rh.l.low;
 rh.l.high = (c >> 32) + rh.l.high;





 if (shift == 0)
  return rl.ll;
 if (shift < 64)
  return (rl.ll >> shift) | (rh.ll << (64 - shift));
 return rh.ll >> (shift & 63);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u32_div(u64 a, u32 mul, u32 divisor)
{
 union {
  u64 ll;
  struct {



   u32 low, high;

  } l;
 } u, rl, rh;

 u.ll = a;
 rl.ll = mul_u32_u32(u.l.low, mul);
 rh.ll = mul_u32_u32(u.l.high, mul) + rl.l.high;


 rl.l.high = ({ uint32_t __base = (divisor); uint32_t __rem; __rem = ((uint64_t)(rh.ll)) % __base; (rh.ll) = ((uint64_t)(rh.ll)) / __base; __rem; });


 ({ uint32_t __base = (divisor); uint32_t __rem; __rem = ((uint64_t)(rl.ll)) % __base; (rl.ll) = ((uint64_t)(rl.ll)) / __base; __rem; });

 rl.l.high = rh.l.low;
 return rl.ll;
}
# 6 "/home/nathan/src/linux-next/include/linux/time64.h" 2
# 1 "/home/nathan/src/linux-next/include/vdso/time64.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/time64.h" 2

typedef __s64 time64_t;
typedef __u64 timeu64_t;


# 1 "/home/nathan/src/linux-next/include/uapi/linux/time.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/time_types.h" 1






struct __kernel_timespec {
 __kernel_time64_t tv_sec;
 long long tv_nsec;
};

struct __kernel_itimerspec {
 struct __kernel_timespec it_interval;
 struct __kernel_timespec it_value;
};
# 25 "/home/nathan/src/linux-next/include/uapi/linux/time_types.h"
struct __kernel_old_timeval {
 __kernel_long_t tv_sec;
 __kernel_long_t tv_usec;
};


struct __kernel_old_timespec {
 __kernel_old_time_t tv_sec;
 long tv_nsec;
};

struct __kernel_old_itimerval {
 struct __kernel_old_timeval it_interval;
 struct __kernel_old_timeval it_value;
};

struct __kernel_sock_timeval {
 __s64 tv_sec;
 __s64 tv_usec;
};
# 7 "/home/nathan/src/linux-next/include/uapi/linux/time.h" 2
# 33 "/home/nathan/src/linux-next/include/uapi/linux/time.h"
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 12 "/home/nathan/src/linux-next/include/linux/time64.h" 2

struct timespec64 {
 time64_t tv_sec;
 long tv_nsec;
};

struct itimerspec64 {
 struct timespec64 it_interval;
 struct timespec64 it_value;
};
# 41 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec64_equal(const struct timespec64 *a,
       const struct timespec64 *b)
{
 return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec64_compare(const struct timespec64 *lhs, const struct timespec64 *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_nsec - rhs->tv_nsec;
}

extern void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec64 timespec64_add(struct timespec64 lhs,
      struct timespec64 rhs)
{
 struct timespec64 ts_delta;
 set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
    lhs.tv_nsec + rhs.tv_nsec);
 return ts_delta;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec64 timespec64_sub(struct timespec64 lhs,
      struct timespec64 rhs)
{
 struct timespec64 ts_delta;
 set_normalized_timespec64(&ts_delta, lhs.tv_sec - rhs.tv_sec,
    lhs.tv_nsec - rhs.tv_nsec);
 return ts_delta;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid(const struct timespec64 *ts)
{

 if (ts->tv_sec < 0)
  return false;

 if ((unsigned long)ts->tv_nsec >= 1000000000L)
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid_strict(const struct timespec64 *ts)
{
 if (!timespec64_valid(ts))
  return false;

 if ((unsigned long long)ts->tv_sec >= (((s64)~((u64)1 << 63)) / 1000000000L))
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid_settod(const struct timespec64 *ts)
{
 if (!timespec64_valid(ts))
  return false;

 if ((unsigned long long)ts->tv_sec >= ((((s64)~((u64)1 << 63)) / 1000000000L) - (30LL * 365 * 24 *3600)))
  return false;
 return true;
}
# 125 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 timespec64_to_ns(const struct timespec64 *ts)
{
 return ((s64) ts->tv_sec * 1000000000L) + ts->tv_nsec;
}







extern struct timespec64 ns_to_timespec64(const s64 nsec);
# 146 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void timespec64_add_ns(struct timespec64 *a, u64 ns)
{
 a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, 1000000000L, &ns);
 a->tv_nsec = ns;
}





extern struct timespec64 timespec64_add_safe(const struct timespec64 lhs,
      const struct timespec64 rhs);
# 11 "/home/nathan/src/linux-next/include/linux/restart_block.h" 2

struct timespec;
struct old_timespec32;
struct pollfd;

enum timespec_type {
 TT_NONE = 0,
 TT_NATIVE = 1,
 TT_COMPAT = 2,
};




struct restart_block {
 long (*fn)(struct restart_block *);
 union {

  struct {
   u32 *uaddr;
   u32 val;
   u32 flags;
   u32 bitset;
   u64 time;
   u32 *uaddr2;
  } futex;

  struct {
   clockid_t clockid;
   enum timespec_type type;
   union {
    struct __kernel_timespec *rmtp;
    struct old_timespec32 *compat_rmtp;
   };
   u64 expires;
  } nanosleep;

  struct {
   struct pollfd *ufds;
   int nfds;
   int has_timeout;
   unsigned long tv_sec;
   unsigned long tv_nsec;
  } poll;
 };
};

extern long do_no_restart_syscall(struct restart_block *parm);
# 14 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/current.h" 1








struct task_struct;




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 1
# 45 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
# 1 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock_types.h" 1








typedef struct {
 volatile unsigned int slock;
} arch_spinlock_t;



typedef struct {
 volatile signed int lock;
} arch_rwlock_t;
# 14 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/lockdep.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct task_struct;
struct lockdep_map;


extern int prove_locking;
extern int lock_stat;





enum lockdep_wait_type {
 LD_WAIT_INV = 0,

 LD_WAIT_FREE,
 LD_WAIT_SPIN,




 LD_WAIT_CONFIG = LD_WAIT_SPIN,

 LD_WAIT_SLEEP,

 LD_WAIT_MAX,
};
# 477 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_init_task(struct task_struct *task)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_off(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_on(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_set_selftest_task(struct task_struct *task)
{
}
# 526 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct lock_class_key { };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_register_key(struct lock_class_key *key)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_unregister_key(struct lock_class_key *key)
{
}




struct lockdep_map { };
# 552 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct pin_cookie { };
# 562 "/home/nathan/src/linux-next/include/linux/lockdep.h"
enum xhlock_context_t {
 XHLOCK_HARD,
 XHLOCK_SOFT,
 XHLOCK_CTX_NR,
};
# 576 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_invariant_state(bool force) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_free_task(struct task_struct *task) {}
# 638 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void print_irqtrace_events(struct task_struct *curr)
{
}
# 751 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
lockdep_rcu_suspicious(const char *file, const int line, const char *s)
{
}
# 19 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2

typedef struct raw_spinlock {
 arch_spinlock_t raw_lock;







} raw_spinlock_t;
# 71 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
typedef struct spinlock {
 union {
  struct raw_spinlock rlock;
# 82 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
 };
} spinlock_t;
# 99 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
# 1 "/home/nathan/src/linux-next/include/linux/rwlock_types.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/rwlock_types.h"
typedef struct {
 arch_rwlock_t raw_lock;







} rwlock_t;
# 100 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2
# 46 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 1
# 132 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cputable.h" 1






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/cputable.h" 1
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cputable.h" 2







struct cpu_spec;

typedef void (*cpu_setup_t)(unsigned long offset, struct cpu_spec* spec);
typedef void (*cpu_restore_t)(void);

enum powerpc_oprofile_type {
 PPC_OPROFILE_INVALID = 0,
 PPC_OPROFILE_RS64 = 1,
 PPC_OPROFILE_POWER4 = 2,
 PPC_OPROFILE_G4 = 3,
 PPC_OPROFILE_FSL_EMB = 4,
 PPC_OPROFILE_CELL = 5,
 PPC_OPROFILE_PA6T = 6,
};

enum powerpc_pmc_type {
 PPC_PMC_DEFAULT = 0,
 PPC_PMC_IBM = 1,
 PPC_PMC_PA6T = 2,
 PPC_PMC_G4 = 3,
};

struct pt_regs;

extern int machine_check_generic(struct pt_regs *regs);
extern int machine_check_4xx(struct pt_regs *regs);
extern int machine_check_440A(struct pt_regs *regs);
extern int machine_check_e500mc(struct pt_regs *regs);
extern int machine_check_e500(struct pt_regs *regs);
extern int machine_check_e200(struct pt_regs *regs);
extern int machine_check_47x(struct pt_regs *regs);
int machine_check_8xx(struct pt_regs *regs);
int machine_check_83xx(struct pt_regs *regs);

extern void cpu_down_flush_e500v2(void);
extern void cpu_down_flush_e500mc(void);
extern void cpu_down_flush_e5500(void);
extern void cpu_down_flush_e6500(void);


struct cpu_spec {

 unsigned int pvr_mask;
 unsigned int pvr_value;

 char *cpu_name;
 unsigned long cpu_features;
 unsigned int cpu_user_features;
 unsigned int cpu_user_features2;
 unsigned int mmu_features;


 unsigned int icache_bsize;
 unsigned int dcache_bsize;


 void (*cpu_down_flush)(void);


 unsigned int num_pmcs;
 enum powerpc_pmc_type pmc_type;




 cpu_setup_t cpu_setup;

 cpu_restore_t cpu_restore;


 char *oprofile_cpu_type;


 enum powerpc_oprofile_type oprofile_type;


 unsigned long oprofile_mmcra_sihv;
 unsigned long oprofile_mmcra_sipr;


 unsigned long oprofile_mmcra_clear;


 char *platform;




 int (*machine_check)(struct pt_regs *regs);





 long (*machine_check_early)(struct pt_regs *regs);
};

extern struct cpu_spec *cur_cpu_spec;

extern unsigned int __start___ftr_fixup, __stop___ftr_fixup;

extern void set_cur_cpu_spec(struct cpu_spec *s);
extern struct cpu_spec *identify_cpu(unsigned long offset, unsigned int pvr);
extern void identify_cpu_name(unsigned int pvr);
extern void do_feature_fixups(unsigned long value, void *fixup_start,
         void *fixup_end);

extern const char *powerpc_base_platform;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_feature_keys_init(void) { }
# 133 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 1
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
extern unsigned int hpage_shift;
# 87 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
extern phys_addr_t memstart_addr;
extern phys_addr_t kernstart_addr;
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h" 1
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
typedef unsigned long pte_basic_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_page(void *addr)
{
 unsigned long iterations;
 unsigned long onex, twox, fourx, eightx;

 iterations = ppc64_caches.l1d.blocks_per_page / 8;






 onex = ppc64_caches.l1d.block_size;
 twox = onex << 1;
 fourx = onex << 2;
 eightx = onex << 3;

 asm volatile(
 "mtctr	%1	# clear_page\n	.balign	16\n1:	dcbz	0,%0\n	dcbz	%3,%0\n	dcbz	%4,%0\n	dcbz	%5,%0\n	dcbz	%6,%0\n	dcbz	%7,%0\n	dcbz	%8,%0\n	dcbz	%9,%0\n	add	%0,%0,%10\n	bdnz+	1b"
# 73 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
 : "=&r" (addr)
 : "r" (iterations), "0" (addr), "b" (onex), "b" (twox),
  "b" (twox+onex), "b" (fourx), "b" (fourx+onex),
  "b" (twox+fourx), "b" (eightx-onex), "r" (eightx)
 : "ctr", "memory");
}

extern void copy_page(void *to, void *from);


extern u64 ppc64_pft_size;
# 104 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/getorder.h" 1
# 29 "/home/nathan/src/linux-next/include/asm-generic/getorder.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) int get_order(unsigned long size)
{
 if (__builtin_constant_p(size)) {
  if (!size)
   return 64 - 16;

  if (size < (1UL << 16))
   return 0;

  return ( __builtin_constant_p((size) - 1) ? ( __builtin_constant_p((size) - 1) ? ( ((size) - 1) < 2 ? 0 : ((size) - 1) & (1ULL << 63) ? 63 : ((size) - 1) & (1ULL << 62) ? 62 : ((size) - 1) & (1ULL << 61) ? 61 : ((size) - 1) & (1ULL << 60) ? 60 : ((size) - 1) & (1ULL << 59) ? 59 : ((size) - 1) & (1ULL << 58) ? 58 : ((size) - 1) & (1ULL << 57) ? 57 : ((size) - 1) & (1ULL << 56) ? 56 : ((size) - 1) & (1ULL << 55) ? 55 : ((size) - 1) & (1ULL << 54) ? 54 : ((size) - 1) & (1ULL << 53) ? 53 : ((size) - 1) & (1ULL << 52) ? 52 : ((size) - 1) & (1ULL << 51) ? 51 : ((size) - 1) & (1ULL << 50) ? 50 : ((size) - 1) & (1ULL << 49) ? 49 : ((size) - 1) & (1ULL << 48) ? 48 : ((size) - 1) & (1ULL << 47) ? 47 : ((size) - 1) & (1ULL << 46) ? 46 : ((size) - 1) & (1ULL << 45) ? 45 : ((size) - 1) & (1ULL << 44) ? 44 : ((size) - 1) & (1ULL << 43) ? 43 : ((size) - 1) & (1ULL << 42) ? 42 : ((size) - 1) & (1ULL << 41) ? 41 : ((size) - 1) & (1ULL << 40) ? 40 : ((size) - 1) & (1ULL << 39) ? 39 : ((size) - 1) & (1ULL << 38) ? 38 : ((size) - 1) & (1ULL << 37) ? 37 : ((size) - 1) & (1ULL << 36) ? 36 : ((size) - 1) & (1ULL << 35) ? 35 : ((size) - 1) & (1ULL << 34) ? 34 : ((size) - 1) & (1ULL << 33) ? 33 : ((size) - 1) & (1ULL << 32) ? 32 : ((size) - 1) & (1ULL << 31) ? 31 : ((size) - 1) & (1ULL << 30) ? 30 : ((size) - 1) & (1ULL << 29) ? 29 : ((size) - 1) & (1ULL << 28) ? 28 : ((size) - 1) & (1ULL << 27) ? 27 : ((size) - 1) & (1ULL << 26) ? 26 : ((size) - 1) & (1ULL << 25) ? 25 : ((size) - 1) & (1ULL << 24) ? 24 : ((size) - 1) & (1ULL << 23) ? 23 : ((size) - 1) & (1ULL << 22) ? 22 : ((size) - 1) & (1ULL << 21) ? 21 : ((size) - 1) & (1ULL << 20) ? 20 : ((size) - 1) & (1ULL << 19) ? 19 : ((size) - 1) & (1ULL << 18) ? 18 : ((size) - 1) & (1ULL << 17) ? 17 : ((size) - 1) & (1ULL << 16) ? 16 : ((size) - 1) & (1ULL << 15) ? 15 : ((size) - 1) & (1ULL << 14) ? 14 : ((size) - 1) & (1ULL << 13) ? 13 : ((size) - 1) & (1ULL << 12) ? 12 : ((size) - 1) & (1ULL << 11) ? 11 : ((size) - 1) & (1ULL << 10) ? 10 : ((size) - 1) & (1ULL << 9) ? 9 : ((size) - 1) & (1ULL << 8) ? 8 : ((size) - 1) & (1ULL << 7) ? 7 : ((size) - 1) & (1ULL << 6) ? 6 : ((size) - 1) & (1ULL << 5) ? 5 : ((size) - 1) & (1ULL << 4) ? 4 : ((size) - 1) & (1ULL << 3) ? 3 : ((size) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((size) - 1) <= 4) ? __ilog2_u32((size) - 1) : __ilog2_u64((size) - 1) ) - 16 + 1;
 }

 size--;
 size >>= 16;



 return fls64(size);

}
# 105 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h" 2
# 248 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 297 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable-be-types.h" 1







typedef struct { __be64 pte; } pte_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_val(pte_t x)
{
 return (__builtin_constant_p((__u64)(( __u64)(__be64)(x.pte))) ? ((__u64)( (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(x.pte)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(x.pte)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pte_raw(pte_t x)
{
 return x.pte;
}



typedef struct { __be64 pmd; } pmd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pmd_val(pmd_t x)
{
 return (__builtin_constant_p((__u64)(( __u64)(__be64)(x.pmd))) ? ((__u64)( (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(x.pmd)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(x.pmd)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pmd_raw(pmd_t x)
{
 return x.pmd;
}


typedef struct { __be64 pud; } pud_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pud_val(pud_t x)
{
 return (__builtin_constant_p((__u64)(( __u64)(__be64)(x.pud))) ? ((__u64)( (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(x.pud)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(x.pud)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pud_raw(pud_t x)
{
 return x.pud;
}




typedef struct { __be64 pgd; } pgd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pgd_val(pgd_t x)
{
 return (__builtin_constant_p((__u64)(( __u64)(__be64)(x.pgd))) ? ((__u64)( (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(x.pgd)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(x.pgd)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pgd_raw(pgd_t x)
{
 return x.pgd;
}


typedef struct { unsigned long pgprot; } pgprot_t;
# 76 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable-be-types.h"
typedef struct { pte_t pte; unsigned long hidx; } real_pte_t;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_xchg(pte_t *ptep, pte_t old, pte_t new)
{
 unsigned long *p = (unsigned long *)ptep;
 __be64 prev;


 prev = ( __be64)__cmpxchg_u64(p, ( unsigned long)pte_raw(old),
          ( unsigned long)pte_raw(new));

 return pte_raw(old) == prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_xchg(pmd_t *pmdp, pmd_t old, pmd_t new)
{
 unsigned long *p = (unsigned long *)pmdp;
 __be64 prev;

 prev = ( __be64)__cmpxchg_u64(p, ( unsigned long)pmd_raw(old),
          ( unsigned long)pmd_raw(new));

 return pmd_raw(old) == prev;
}

typedef struct { __be64 pdbe; } hugepd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpd_val(hugepd_t x)
{
 return (__builtin_constant_p((__u64)(( __u64)(__be64)(x.pdbe))) ? ((__u64)( (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(x.pdbe)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(x.pdbe)));
}
# 298 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 308 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
struct page;
extern void clear_user_page(void *page, unsigned long vaddr, struct page *pg);
extern void copy_user_page(void *to, void *from, unsigned long vaddr,
  struct page *p);
extern int devmem_is_allowed(unsigned long pfn);


void arch_free_page(struct page *page, int order);



struct vm_area_struct;

extern unsigned long kernstart_virt_addr;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long kaslr_offset(void)
{
 return kernstart_virt_addr - 0xc000000000000000UL;
}


# 1 "/home/nathan/src/linux-next/include/asm-generic/memory_model.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/pfn.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/pfn.h"
typedef struct {
 u64 val;
} pfn_t;
# 6 "/home/nathan/src/linux-next/include/asm-generic/memory_model.h" 2
# 329 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/slice.h" 1
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h" 2




struct mm_struct;
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h"
unsigned long slice_get_unmapped_area(unsigned long addr, unsigned long len,
          unsigned long flags, unsigned int psize,
          int topdown);

unsigned int get_slice_psize(struct mm_struct *mm, unsigned long addr);

void slice_set_range_psize(struct mm_struct *mm, unsigned long start,
      unsigned long len, unsigned int psize);

void slice_init_new_context_exec(struct mm_struct *mm);
void slice_setup_new_exec(void);
# 331 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 134 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2

typedef pte_t *pgtable_t;






enum {
 MMU_FTRS_POSSIBLE =

  0x00000001UL |
# 169 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
  0x02000000UL | 0x04000000UL | 0x08000000UL |
  0x10000000UL | 0x20000000UL |
  0x40000000UL | 0x00008000UL |
  0x00004000UL | 0x00002000UL |


  0x00000040UL |

  0x80000000UL |


  0,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_mmu_has_feature(unsigned long feature)
{
 return !!(MMU_FTRS_POSSIBLE & cur_cpu_spec->mmu_features & feature);
}
# 230 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmu_feature_keys_init(void)
{

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mmu_has_feature(unsigned long feature)
{
 return early_mmu_has_feature(feature);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmu_clear_feature(unsigned long feature)
{
 cur_cpu_spec->mmu_features &= ~feature;
}


extern unsigned int __start___mmu_ftr_fixup, __stop___mmu_ftr_fixup;





extern u64 ppc64_rma_size;


extern void mmu_cleanup_all(void);
extern void radix__mmu_cleanup_all(void);


extern void mmu_partition_table_init(void);
extern void mmu_partition_table_set_entry(unsigned int lpid, unsigned long dw0,
       unsigned long dw1, bool flush);


struct mm_struct;

extern void assert_pte_locked(struct mm_struct *mm, unsigned long addr);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_enabled(void)
{
 return mmu_has_feature(0x00000040UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_radix_enabled(void)
{
 return early_mmu_has_feature(0x00000040UL);
}
# 301 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool strict_kernel_rwx_enabled(void)
{
 return false;
}
# 348 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
struct mmu_psize_def {
 unsigned int shift;
 int penc[16];
 unsigned int tlbiel;
 unsigned long avpnm;
 union {
  unsigned long sllp;
  unsigned long ap;
 };
};
extern struct mmu_psize_def mmu_psize_defs[16];
# 46 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 1




# 1 "/home/nathan/src/linux-next/include/asm-generic/pgtable-nop4d.h" 1








typedef struct { pgd_t pgd; } p4d_t;
# 22 "/home/nathan/src/linux-next/include/asm-generic/pgtable-nop4d.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_none(pgd_t pgd) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_bad(pgd_t pgd) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_present(pgd_t pgd) { return 1; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgd_clear(pgd_t *pgd) { }
# 36 "/home/nathan/src/linux-next/include/asm-generic/pgtable-nop4d.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) p4d_t *p4d_offset(pgd_t *pgd, unsigned long address)
{
 return (p4d_t *)pgd;
}
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/mmdebug.h" 1







struct page;
struct vm_area_struct;
struct mm_struct;

extern void dump_page(struct page *page, const char *reason);
extern void __dump_page(struct page *page, const char *reason);
void dump_vma(const struct vm_area_struct *vma);
void dump_mm(const struct mm_struct *mm);
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 185 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
extern unsigned long __pte_index_size;
extern unsigned long __pmd_index_size;
extern unsigned long __pud_index_size;
extern unsigned long __pgd_index_size;
extern unsigned long __pud_cache_index;
# 201 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
extern unsigned long __pte_table_size;
extern unsigned long __pmd_table_size;
extern unsigned long __pud_table_size;
extern unsigned long __pgd_table_size;





extern unsigned long __pmd_val_bits;
extern unsigned long __pud_val_bits;
extern unsigned long __pgd_val_bits;




extern unsigned long __pte_frag_nr;

extern unsigned long __pte_frag_size_shift;



extern unsigned long __pmd_frag_nr;

extern unsigned long __pmd_frag_size_shift;
# 259 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
enum pgtable_index {
 PTE_INDEX = 0,
 PMD_INDEX,
 PUD_INDEX,
 PGD_INDEX,



 HTLB_16M_INDEX,
 HTLB_16G_INDEX,
};

extern unsigned long __vmalloc_start;
extern unsigned long __vmalloc_end;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ioremap_max_order(void)
{
 if (radix_enabled())
  return ((16 + __pte_index_size) + __pmd_index_size);
 return 7 + 16;
}


extern unsigned long __kernel_virt_start;
extern unsigned long __kernel_io_start;
extern unsigned long __kernel_io_end;




extern struct page *vmemmap;
extern unsigned long pci_io_base;



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h" 1
# 79 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) real_pte_t __real_pte(pte_t pte, pte_t *ptep, int offset)
{
 real_pte_t rpte;
 unsigned long *hidxp;

 rpte.pte = pte;






 __asm__ __volatile__ ("lwsync" " " : : :"memory");

 hidxp = (unsigned long *)(ptep + offset);
 rpte.hidx = *hidxp;
 return rpte;
}
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __rpte_to_hidx(real_pte_t rpte, unsigned long index)
{
 return ((((rpte.hidx >> (index << 2)) & 0xfUL) + 0xfUL) & 0xfUL);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_set_hidx(pte_t *ptep, real_pte_t rpte,
      unsigned int subpg_index,
      unsigned long hidx, int offset)
{
 unsigned long *hidxp = (unsigned long *)(ptep + offset);

 rpte.hidx &= ~(0xfUL << (subpg_index << 2));
 *hidxp = rpte.hidx | (((hidx + 0x1UL) & 0xfUL) << (subpg_index << 2));






 __asm__ __volatile__ ("lwsync" " " : : :"memory");


 return 0x0UL;
}


extern bool __rpte_sub_valid(real_pte_t rpte, unsigned long index);
# 160 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
extern int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
      unsigned long pfn, unsigned long size, pgprot_t);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__remap_4k_pfn(struct vm_area_struct *vma, unsigned long addr,
     unsigned long pfn, pgprot_t prot)
{
 if (pfn > ((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) >> 16)) {
  ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { do { } while(0); __warn_printk("remap_4k_pfn called with wrong pfn value\n"); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/hash-64k.h"), "i" (166), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); do { } while(0); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });
  return -22;
 }
 return remap_pfn_range(vma, addr, pfn, (1UL << 16),
          ((pgprot_t) { (((prot).pgprot) | 0x02000) }));
}
# 189 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *get_hpte_slot_array(pmd_t *pmdp)
{






 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return *(char **)(pmdp + (1 << __pmd_index_size));


}
# 214 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int hpte_valid(unsigned char *hpte_slot_array, int index)
{
 return hpte_slot_array[index] & 0x1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int hpte_hash_index(unsigned char *hpte_slot_array,
        int index)
{
 return hpte_slot_array[index] >> 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_hpte_slot_valid(unsigned char *hpte_slot_array,
     unsigned int index, unsigned int hidx)
{
 hpte_slot_array[index] = (hidx << 1) | 0x1;
}
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pmd_trans_huge(pmd_t pmd)
{
 return !!((pmd_val(pmd) & (0x4000000000000000UL | 0x02000 | 0x00800)) ==
    (0x4000000000000000UL | 0x02000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 return (((pmd_raw(pmd_a) ^ pmd_raw(pmd_b)) & ~(( __be64)(__builtin_constant_p((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))) ? ((__u64)( (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))))) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t hash__pmd_mkhuge(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__builtin_constant_p((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000)))) ? ((__u64)( (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pmd_val(pmd) | (0x4000000000000000UL | 0x02000))))) });
}

extern unsigned long hash__pmd_hugepage_update(struct mm_struct *mm,
        unsigned long addr, pmd_t *pmdp,
        unsigned long clr, unsigned long set);
extern pmd_t hash__pmdp_collapse_flush(struct vm_area_struct *vma,
       unsigned long address, pmd_t *pmdp);
extern void hash__pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
      pgtable_t pgtable);
extern pgtable_t hash__pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
extern pmd_t hash__pmdp_huge_get_and_clear(struct mm_struct *mm,
           unsigned long addr, pmd_t *pmdp);
extern int hash__has_transparent_hugepage(void);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t hash__pmd_mkdevmap(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__builtin_constant_p((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800)))) ? ((__u64)( (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pmd_val(pmd) | (0x4000000000000000UL | 0x02000 | 0x00800))))) });
}
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h" 2
# 115 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_region_id(unsigned long ea)
{
 int region_id;
 int id = (ea >> 60UL);

 if (id == 0)
  return 0;

 if (id != (0xc000000000000000UL >> 60))
  return (((((unsigned long)((0xc008000000000000UL + (1UL << 49)) + (1UL << 49)) - 0xc008000000000000UL) >> 49) + 2) + 1);

 if (ea < 0xc008000000000000UL)
  return 1;

 do { extern void __compiletime_assert_35(void) ; if (!(!(((((unsigned long)0xc008000000000000UL - 0xc008000000000000UL) >> 49) + 2) != 2))) __compiletime_assert_35(); } while (0);

 region_id = ((((unsigned long)ea - 0xc008000000000000UL) >> 49) + 2);
 return region_id;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__p4d_bad(p4d_t p4d)
{
 return ((pgd_val((p4d).pgd)) == 0);
}





extern void hpte_need_flush(struct mm_struct *mm, unsigned long addr,
       pte_t *ptep, unsigned long pte, int huge);
extern unsigned long htab_convert_pte_flags(unsigned long pteflags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hash__pte_update(struct mm_struct *mm,
      unsigned long addr,
      pte_t *ptep, unsigned long clr,
      unsigned long set,
      int huge)
{
 __be64 old_be, tmp_be;
 unsigned long old;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%3		# pte_update\n	and.	%1,%0,%6\n	bne-	1b \n	andc	%1,%0,%4 \n	or	%1,%1,%7\n	stdcx.	%1,0,%3 \n	bne-	1b"






 : "=&r" (old_be), "=&r" (tmp_be), "=m" (*ptep)
 : "r" (ptep), "r" ((( __be64)(__builtin_constant_p((__u64)((clr))) ? ((__u64)( (((__u64)((clr)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((clr)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((clr)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((clr)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((clr)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((clr)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((clr)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((clr)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((clr))))), "m" (*ptep),
   "r" ((( __be64)(__builtin_constant_p((__u64)((0x0100000000000000UL))) ? ((__u64)( (((__u64)((0x0100000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x0100000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x0100000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x0100000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x0100000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x0100000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x0100000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x0100000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x0100000000000000UL))))), "r" ((( __be64)(__builtin_constant_p((__u64)((set))) ? ((__u64)( (((__u64)((set)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((set)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((set)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((set)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((set)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((set)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((set)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((set)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((set)))))
 : "cc" );

 if (!huge)
  assert_pte_locked(mm, addr);

 old = (__builtin_constant_p((__u64)(( __u64)(__be64)(old_be))) ? ((__u64)( (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(old_be)));
 if (old & 0x0080000000000000UL)
  hpte_need_flush(mm, addr, ptep, old, huge);

 return old;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__ptep_set_access_flags(pte_t *ptep, pte_t entry)
{
 __be64 old, tmp, val, mask;

 mask = (( __be64)(__builtin_constant_p((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200))) ? ((__u64)( (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200))));


 val = pte_raw(entry) & mask;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%4\n		and.	%1,%0,%6\n		bne-	1b \n		or	%0,%3,%0\n		stdcx.	%0,0,%4\n		bne-	1b"





 :"=&r" (old), "=&r" (tmp), "=m" (*ptep)
 :"r" (val), "r" (ptep), "m" (*ptep), "r" ((( __be64)(__builtin_constant_p((__u64)((0x0100000000000000UL))) ? ((__u64)( (((__u64)((0x0100000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x0100000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x0100000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x0100000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x0100000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x0100000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x0100000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x0100000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x0100000000000000UL)))))
 :"cc");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pte_same(pte_t pte_a, pte_t pte_b)
{
 return (((pte_raw(pte_a) ^ pte_raw(pte_b)) & ~(( __be64)(__builtin_constant_p((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))) ? ((__u64)( (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))))) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pte_none(pte_t pte)
{
 return (pte_val(pte) & ~(0x0100000000000000UL | 0x0080000000000000UL | 0x01000)) == 0;
}

unsigned long pte_get_hash_gslot(unsigned long vpn, unsigned long shift,
  int ssize, real_pte_t rpte, unsigned int subpg_index);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__set_pte_at(struct mm_struct *mm, unsigned long addr,
      pte_t *ptep, pte_t pte, int percpu)
{




 *ptep = pte;
}


extern void hpte_do_hugepage_flush(struct mm_struct *mm, unsigned long addr,
       pmd_t *pmdp, unsigned long old_pmd);
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
int hash__map_kernel_page(unsigned long ea, unsigned long pa, pgprot_t prot);
extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) hash__vmemmap_create_mapping(unsigned long start,
           unsigned long page_size,
           unsigned long phys);
extern void hash__vmemmap_remove_mapping(unsigned long start,
         unsigned long page_size);

int hash__create_section_mapping(unsigned long start, unsigned long end,
     int nid, pgprot_t prot);
int hash__remove_section_mapping(unsigned long start, unsigned long end);
# 296 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix-64k.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h" 1




struct vm_area_struct;
struct mm_struct;
struct mmu_gather;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mmu_get_ap(int psize)
{
 return mmu_psize_defs[psize].ap;
}


extern void radix__tlbiel_all(unsigned int action);
extern void radix__flush_tlb_lpid_page(unsigned int lpid,
     unsigned long addr,
     unsigned long page_size);
extern void radix__flush_pwc_lpid(unsigned int lpid);
extern void radix__flush_all_lpid(unsigned int lpid);
extern void radix__flush_all_lpid_guest(unsigned int lpid);
# 44 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h"
extern void radix__flush_hugetlb_tlb_range(struct vm_area_struct *vma,
        unsigned long start, unsigned long end);
extern void radix__flush_tlb_range_psize(struct mm_struct *mm, unsigned long start,
      unsigned long end, int psize);
extern void radix__flush_pmd_tlb_range(struct vm_area_struct *vma,
           unsigned long start, unsigned long end);
extern void radix__flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
       unsigned long end);
extern void radix__flush_tlb_kernel_range(unsigned long start, unsigned long end);

extern void radix__local_flush_tlb_mm(struct mm_struct *mm);
extern void radix__local_flush_all_mm(struct mm_struct *mm);
extern void radix__local_flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr);
extern void radix__local_flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,
           int psize);
extern void radix__tlb_flush(struct mmu_gather *tlb);

extern void radix__flush_tlb_mm(struct mm_struct *mm);
extern void radix__flush_all_mm(struct mm_struct *mm);
extern void radix__flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr);
extern void radix__flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,
     int psize);






extern void radix__flush_tlb_pwc(struct mmu_gather *tlb, unsigned long addr);
extern void radix__flush_tlb_collapsed_pmd(struct mm_struct *mm, unsigned long addr);
extern void radix__flush_tlb_all(void);
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_cpu_has_feature(unsigned long feature)
{
 return !!(((((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x00000002UL | 0x0000000004000000UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0004000000000000UL)) & ~0x0000000000002000UL & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) & (0x00000080UL | 0x00000040UL | 0x00000020UL | 0x00000100UL | 0x00000001UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000008000000000UL | 0x0000000000008000UL | 0x0000000000010000UL)) & feature) ||
    (((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x00000002UL | 0x0000000004000000UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0004000000000000UL)) & cur_cpu_spec->cpu_features & feature));
}
# 49 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpu_has_feature(unsigned long feature)
{
 return early_cpu_has_feature(feature);
}
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2
# 124 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
extern void radix__ptep_set_access_flags(struct vm_area_struct *vma, pte_t *ptep,
      pte_t entry, unsigned long address,
      int psize);

extern void radix__ptep_modify_prot_commit(struct vm_area_struct *vma,
        unsigned long addr, pte_t *ptep,
        pte_t old_pte, pte_t pte);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __radix_pte_update(pte_t *ptep, unsigned long clr,
            unsigned long set)
{
 __be64 old_be, tmp_be;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%3		# pte_update\n"
 "	andc	%1,%0,%5	\n"
 "	or	%1,%1,%4	\n"
 "	stdcx.	%1,0,%3		\n"
 "	bne-	1b"
 : "=&r" (old_be), "=&r" (tmp_be), "=m" (*ptep)
 : "r" (ptep), "r" ((( __be64)(__builtin_constant_p((__u64)((set))) ? ((__u64)( (((__u64)((set)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((set)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((set)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((set)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((set)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((set)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((set)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((set)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((set))))), "r" ((( __be64)(__builtin_constant_p((__u64)((clr))) ? ((__u64)( (((__u64)((clr)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((clr)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((clr)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((clr)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((clr)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((clr)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((clr)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((clr)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((clr)))))
 : "cc" );

 return (__builtin_constant_p((__u64)(( __u64)(__be64)(old_be))) ? ((__u64)( (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(old_be)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(old_be)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long radix__pte_update(struct mm_struct *mm,
     unsigned long addr,
     pte_t *ptep, unsigned long clr,
     unsigned long set,
     int huge)
{
 unsigned long old_pte;

 old_pte = __radix_pte_update(ptep, clr, set);
 if (!huge)
  assert_pte_locked(mm, addr);

 return old_pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t radix__ptep_get_and_clear_full(struct mm_struct *mm,
         unsigned long addr,
         pte_t *ptep, int full)
{
 unsigned long old_pte;

 if (full) {
  old_pte = pte_val(*ptep);
  *ptep = ((pte_t) { (( __be64)(__builtin_constant_p((__u64)((0))) ? ((__u64)( (((__u64)((0)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0)))) });
 } else
  old_pte = radix__pte_update(mm, addr, ptep, ~0ul, 0, 0);

 return ((pte_t) { (( __be64)(__builtin_constant_p((__u64)((old_pte))) ? ((__u64)( (((__u64)((old_pte)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((old_pte)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((old_pte)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((old_pte)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((old_pte)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((old_pte)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((old_pte)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((old_pte)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((old_pte)))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pte_same(pte_t pte_a, pte_t pte_b)
{
 return ((pte_raw(pte_a) ^ pte_raw(pte_b)) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pte_none(pte_t pte)
{
 return (pte_val(pte) & ~(0x00080 | 0x00100)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void radix__set_pte_at(struct mm_struct *mm, unsigned long addr,
     pte_t *ptep, pte_t pte, int percpu)
{
 *ptep = pte;
# 212 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_bad(pmd_t pmd)
{
 return !!(pmd_val(pmd) & 0x60000000000000e0UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 return ((pmd_raw(pmd_a) ^ pmd_raw(pmd_b)) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pud_bad(pud_t pud)
{
 return !!(pud_val(pud) & 0x60000000000000e0UL);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__p4d_bad(p4d_t p4d)
{
 return !!((pgd_val((p4d).pgd)) & 0x60000000000000e0UL);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_trans_huge(pmd_t pmd)
{
 return (pmd_val(pmd) & (0x4000000000000000UL | 0x00800)) == 0x4000000000000000UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t radix__pmd_mkhuge(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__builtin_constant_p((__u64)((pmd_val(pmd) | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pmd_val(pmd) | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pmd_val(pmd) | 0x4000000000000000UL)))) });
}

extern unsigned long radix__pmd_hugepage_update(struct mm_struct *mm, unsigned long addr,
       pmd_t *pmdp, unsigned long clr,
       unsigned long set);
extern pmd_t radix__pmdp_collapse_flush(struct vm_area_struct *vma,
      unsigned long address, pmd_t *pmdp);
extern void radix__pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
     pgtable_t pgtable);
extern pgtable_t radix__pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
extern pmd_t radix__pmdp_huge_get_and_clear(struct mm_struct *mm,
          unsigned long addr, pmd_t *pmdp);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__has_transparent_hugepage(void)
{

 if (mmu_psize_defs[7].shift == (16 + __pte_index_size))
  return 1;
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t radix__pmd_mkdevmap(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__builtin_constant_p((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800)))) ? ((__u64)( (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pmd_val(pmd) | (0x4000000000000000UL | 0x00800))))) });
}

extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) radix__vmemmap_create_mapping(unsigned long start,
          unsigned long page_size,
          unsigned long phys);
extern void radix__vmemmap_remove_mapping(unsigned long start,
        unsigned long page_size);

extern int radix__map_kernel_page(unsigned long ea, unsigned long pa,
     pgprot_t flags, unsigned int psz);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long radix__get_tree_size(void)
{
 unsigned long rts_field;







 rts_field = (0x5UL << 5);
 rts_field |= (0x2UL << 61);

 return rts_field;
}


int radix__create_section_mapping(unsigned long start, unsigned long end,
      int nid, pgprot_t prot);
int radix__remove_section_mapping(unsigned long start, unsigned long end);
# 297 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable-64k.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_huge(pmd_t pmd)
{



 return !!(pmd_raw(pmd) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_huge(pud_t pud)
{



 return !!(pud_raw(pud) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_huge(pgd_t pgd)
{



 return !!(pgd_raw(pgd) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hugepd_ok(hugepd_t hpd)
{
 return 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_hugepd_cache_index(int index)
{
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable-64k.h"), "i" (59), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int remap_4k_pfn(struct vm_area_struct *vma, unsigned long addr,
          unsigned long pfn, pgprot_t prot)
{
 if (radix_enabled())
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable-64k.h"), "i" (68), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 return hash__remap_4k_pfn(vma, addr, pfn, prot);
}
# 300 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 353 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_update(struct mm_struct *mm, unsigned long addr,
           pte_t *ptep, unsigned long clr,
           unsigned long set, int huge)
{
 if (radix_enabled())
  return radix__pte_update(mm, addr, ptep, clr, set, huge);
 return hash__pte_update(mm, addr, ptep, clr, set, huge);
}
# 371 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ptep_test_and_clear_young(struct mm_struct *mm,
           unsigned long addr, pte_t *ptep)
{
 unsigned long old;

 if ((pte_raw(*ptep) & (( __be64)(__builtin_constant_p((__u64)((0x00100 | 0x0080000000000000UL))) ? ((__u64)( (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00100 | 0x0080000000000000UL))))) == 0)
  return 0;
 old = pte_update(mm, addr, ptep, 0x00100, 0, 0);
 return (old & 0x00100) != 0;
}
# 390 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __pte_write(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00002))) ? ((__u64)( (((__u64)((0x00002)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00002)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00002)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00002)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00002)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00002)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00002)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00002)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00002)))));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_savedwrite(pte_t pte)
{







 return !(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008))) ? ((__u64)( (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x00004 | 0x00002 | 0x00001) | 0x00008)))));
}
# 416 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_write(pte_t pte)
{
 return __pte_write(pte) || pte_savedwrite(pte);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_read(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00004))) ? ((__u64)( (((__u64)((0x00004)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00004)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00004)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00004)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00004)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00004)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00004)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00004)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00004)))));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr,
          pte_t *ptep)
{
 if (__pte_write(*ptep))
  pte_update(mm, addr, ptep, 0x00002, 0, 0);
 else if (__builtin_expect(!!(pte_savedwrite(*ptep)), 0))
  pte_update(mm, addr, ptep, 0, 0x00008, 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void huge_ptep_set_wrprotect(struct mm_struct *mm,
        unsigned long addr, pte_t *ptep)
{




 if (__pte_write(*ptep))
  pte_update(mm, addr, ptep, 0x00002, 0, 1);
 else if (__builtin_expect(!!(pte_savedwrite(*ptep)), 0))
  pte_update(mm, addr, ptep, 0, 0x00008, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t ptep_get_and_clear(struct mm_struct *mm,
           unsigned long addr, pte_t *ptep)
{
 unsigned long old = pte_update(mm, addr, ptep, ~0UL, 0, 0);
 return ((pte_t) { (( __be64)(__builtin_constant_p((__u64)((old))) ? ((__u64)( (((__u64)((old)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((old)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((old)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((old)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((old)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((old)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((old)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((old)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((old)))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t ptep_get_and_clear_full(struct mm_struct *mm,
         unsigned long addr,
         pte_t *ptep, int full)
{
 if (full && radix_enabled()) {




  return radix__ptep_get_and_clear_full(mm, addr, ptep, full);
 }
 return ptep_get_and_clear(mm, addr, ptep);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_clear(struct mm_struct *mm, unsigned long addr,
        pte_t * ptep)
{
 pte_update(mm, addr, ptep, ~0UL, 0, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00080))) ? ((__u64)( (((__u64)((0x00080)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00080)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00080)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00080)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00080)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00080)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00080)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00080)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00080)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_young(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00100))) ? ((__u64)( (((__u64)((0x00100)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00100)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00100)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00100)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00100)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00100)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00100)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00100)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00100)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_special(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00400))) ? ((__u64)( (((__u64)((0x00400)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00400)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00400)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00400)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00400)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00400)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00400)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00400)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00400)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_exec(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00001))) ? ((__u64)( (((__u64)((0x00001)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00001)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00001)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00001)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00001)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00001)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00001)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00001)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00001)))));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_soft_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00200))) ? ((__u64)( (((__u64)((0x00200)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00200)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00200)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00200)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00200)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00200)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00200)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00200)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00200)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mksoft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00200))) ? ((__u64)( (((__u64)((0x00200)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00200)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00200)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00200)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00200)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00200)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00200)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00200)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00200))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_clear_soft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00200))) ? ((__u64)( (((__u64)((~0x00200)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00200)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00200)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00200)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00200)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00200)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00200)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00200)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00200))))) });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_protnone(pte_t pte)
{
 return (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001)))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001)))))) ==
  (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x4000000000000000UL))));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mk_savedwrite(pte_t pte)
{





 do { if (__builtin_constant_p((pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))))) != (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x00008)))))) { if ((pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))))) != (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x00008))))) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (534), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (534), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))))) != (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x00008))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x00008))))))); } } while (0);

 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00008))) ? ((__u64)( (((__u64)((~0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00008))))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_clear_savedwrite(pte_t pte)
{



 do { if (__builtin_constant_p(!pte_protnone(pte))) { if (!pte_protnone(pte)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (544), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (544), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!pte_protnone(pte)))); } } while (0);
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00008))) ? ((__u64)( (((__u64)((0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00008))))) });
}
# 556 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_hw_valid(pte_t pte)
{
 return (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x4000000000000000UL))))) ==
  (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x4000000000000000UL))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_present(pte_t pte)
{







 if (pte_hw_valid(pte))
  return true;
 return (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x2000000000000000UL | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x2000000000000000UL | 0x4000000000000000UL))))) ==
  (( __be64)(__builtin_constant_p((__u64)((0x2000000000000000UL | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x2000000000000000UL | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x2000000000000000UL | 0x4000000000000000UL))));
}


extern bool arch_pte_access_permitted(u64 pte, bool write, bool execute);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_user(pte_t pte)
{
 return !(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((0x00008))) ? ((__u64)( (((__u64)((0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00008)))));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_access_permitted(pte_t pte, bool write)
{




 if (!pte_present(pte) || !pte_user(pte) || !pte_read(pte))
  return false;

 if (write && !pte_write(pte))
  return false;

 return arch_pte_access_permitted(pte_val(pte), write, 0);
}
# 614 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pfn_pte(unsigned long pfn, pgprot_t pgprot)
{
 do { if (__builtin_constant_p(pfn >> (64 - 16))) { if (pfn >> (64 - 16)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (616), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (616), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(pfn >> (64 - 16)))); } } while (0);
 do { if (__builtin_constant_p((pfn << 16) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1)))))) { if ((pfn << 16) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1))))) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (617), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable.h"), "i" (617), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((pfn << 16) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1))))))); } } while (0);

 return ((pte_t) { (( __be64)(__builtin_constant_p((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot)))) ? ((__u64)( (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((((pte_basic_t)pfn << 16) | ((pgprot).pgprot))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_pfn(pte_t pte)
{
 return (pte_val(pte) & (((1UL << 53) - 1) & ((~((1 << 16) - 1))))) >> 16;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_wrprotect(pte_t pte)
{
 if (__builtin_expect(!!(pte_savedwrite(pte)), 0))
  return pte_clear_savedwrite(pte);
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00002))) ? ((__u64)( (((__u64)((~0x00002)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00002)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00002)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00002)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00002)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00002)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00002)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00002)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00002))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_exprotect(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00001))) ? ((__u64)( (((__u64)((~0x00001)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00001)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00001)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00001)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00001)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00001)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00001)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00001)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00001))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkclean(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00080))) ? ((__u64)( (((__u64)((~0x00080)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00080)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00080)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00080)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00080)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00080)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00080)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00080)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00080))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkold(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00100))) ? ((__u64)( (((__u64)((~0x00100)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00100)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00100)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00100)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00100)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00100)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00100)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00100)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00100))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkexec(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00001))) ? ((__u64)( (((__u64)((0x00001)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00001)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00001)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00001)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00001)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00001)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00001)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00001)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00001))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkpte(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkwrite(pte_t pte)
{



 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)(((0x00004 | 0x00002)))) ? ((__u64)( (((__u64)(((0x00004 | 0x00002))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x00004 | 0x00002))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x00004 | 0x00002)))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkdirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00080 | 0x00200))) ? ((__u64)( (((__u64)((0x00080 | 0x00200)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00080 | 0x00200)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00080 | 0x00200)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00080 | 0x00200))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkyoung(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00100))) ? ((__u64)( (((__u64)((0x00100)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00100)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00100)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00100)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00100)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00100)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00100)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00100)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00100))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkspecial(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00400))) ? ((__u64)( (((__u64)((0x00400)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00400)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00400)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00400)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00400)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00400)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00400)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00400)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00400))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkhuge(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkdevmap(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00400 | 0x00800))) ? ((__u64)( (((__u64)((0x00400 | 0x00800)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00400 | 0x00800)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00400 | 0x00800)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00400 | 0x00800))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkprivileged(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)((0x00008))) ? ((__u64)( (((__u64)((0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00008))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkuser(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~0x00008))) ? ((__u64)( (((__u64)((~0x00008)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~0x00008)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~0x00008)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~0x00008)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~0x00008)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~0x00008)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~0x00008)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~0x00008)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~0x00008))))) });
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_devmap(pte_t pte)
{
 u64 mask = (( __be64)(__builtin_constant_p((__u64)((0x00800 | 0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00800 | 0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00800 | 0x4000000000000000UL))));

 return (pte_raw(pte) & mask) == mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_modify(pte_t pte, pgprot_t newprot)
{

 return ((pte_t) { ((pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800)))) ? ((__u64)( (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800)))))) | (( __be64)(__builtin_constant_p((__u64)((((newprot).pgprot)))) ? ((__u64)( (((__u64)((((newprot).pgprot))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((((newprot).pgprot))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((((newprot).pgprot))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((((newprot).pgprot))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((((newprot).pgprot))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((((newprot).pgprot))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((((newprot).pgprot))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((((newprot).pgprot))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((((newprot).pgprot)))))) });

}
# 759 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_swp_mksoft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__builtin_constant_p((__u64)(((1UL << (5 + 0))))) ? ((__u64)( (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((1UL << (5 + 0))))))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_swp_soft_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)(((1UL << (5 + 0))))) ? ((__u64)( (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((1UL << (5 + 0)))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((1UL << (5 + 0)))))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_swp_clear_soft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__builtin_constant_p((__u64)((~(1UL << (5 + 0))))) ? ((__u64)( (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((~(1UL << (5 + 0)))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((~(1UL << (5 + 0))))))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool check_pte_access(unsigned long access, unsigned long ptev)
{



 if (access & ~ptev)
  return false;



 if ((access & 0x00008) != (ptev & 0x00008))
  return false;

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ptep_set_access_flags(struct vm_area_struct *vma,
        pte_t *ptep, pte_t entry,
        unsigned long address,
        int psize)
{
 if (radix_enabled())
  return radix__ptep_set_access_flags(vma, ptep, entry,
          address, psize);
 return hash__ptep_set_access_flags(ptep, entry);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_same(pte_t pte_a, pte_t pte_b)
{
 if (radix_enabled())
  return radix__pte_same(pte_a, pte_b);
 return hash__pte_same(pte_a, pte_b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_none(pte_t pte)
{
 if (radix_enabled())
  return radix__pte_none(pte);
 return hash__pte_none(pte);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_pte_at(struct mm_struct *mm, unsigned long addr,
    pte_t *ptep, pte_t pte, int percpu)
{
 if (radix_enabled())
  return radix__set_pte_at(mm, addr, ptep, pte, percpu);
 return hash__set_pte_at(mm, addr, ptep, pte, percpu);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_noncached(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030)) | 0x00020) });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_noncached_wc(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030)) | 0x00030) });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_cached(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_writecombine(pgprot_t prot)
{
 return pgprot_noncached_wc(prot);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_ci(pte_t pte)
{
 __be64 pte_v = pte_raw(pte);

 if (((pte_v & (( __be64)(__builtin_constant_p((__u64)(((0x00010 | 0x00020 | 0x00030)))) ? ((__u64)( (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x00010 | 0x00020 | 0x00030)))))) == (( __be64)(__builtin_constant_p((__u64)((0x00030))) ? ((__u64)( (((__u64)((0x00030)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00030)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00030)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00030)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00030)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00030)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00030)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00030)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00030))))) ||
     ((pte_v & (( __be64)(__builtin_constant_p((__u64)(((0x00010 | 0x00020 | 0x00030)))) ? ((__u64)( (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((0x00010 | 0x00020 | 0x00030))) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((0x00010 | 0x00020 | 0x00030)))))) == (( __be64)(__builtin_constant_p((__u64)((0x00020))) ? ((__u64)( (((__u64)((0x00020)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00020)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00020)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00020)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00020)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00020)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00020)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00020)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00020))))))
  return true;
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pmd_clear(pmd_t *pmdp)
{
 *pmdp = ((pmd_t) { (( __be64)(__builtin_constant_p((__u64)((0))) ? ((__u64)( (((__u64)((0)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0)))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none(pmd_t pmd)
{
 return !pmd_raw(pmd);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_present(pmd_t pmd)
{






 if (pmd_raw(pmd) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x2000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x2000000000000000UL)))))
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_is_serializing(pmd_t pmd)
{
# 902 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
 if ((pmd_raw(pmd) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL | 0x2000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL | 0x2000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL | 0x2000000000000000UL))))) ==
      (( __be64)(__builtin_constant_p((__u64)((0x2000000000000000UL))) ? ((__u64)( (((__u64)((0x2000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x2000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x2000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x2000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x2000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x2000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x2000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x2000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x2000000000000000UL)))))
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_bad(pmd_t pmd)
{
 if (radix_enabled())
  return radix__pmd_bad(pmd);
 return (pmd_val(pmd) & (__pte_table_size-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pud_clear(pud_t *pudp)
{
 *pudp = ((pud_t) { (( __be64)(__builtin_constant_p((__u64)((0))) ? ((__u64)( (((__u64)((0)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0)))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none(pud_t pud)
{
 return !pud_raw(pud);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_present(pud_t pud)
{
 return !!(pud_raw(pud) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL)))));
}

extern struct page *pud_page(pud_t pud);
extern struct page *pmd_page(pmd_t pmd);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pud_pte(pud_t pud)
{
 return ((pte_t) { (pud_raw(pud)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pte_pud(pte_t pte)
{
 return ((pud_t) { (pte_raw(pte)) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_bad(pud_t pud)
{
 if (radix_enabled())
  return radix__pud_bad(pud);
 return (pud_val(pud) & (__pmd_table_size-1));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pud_access_permitted(pud_t pud, bool write)
{
 return pte_access_permitted(pud_pte(pud), write);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 p4d_raw(p4d_t x)
{
 return pgd_raw(x.pgd);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void p4d_clear(p4d_t *p4dp)
{
 *p4dp = ((p4d_t) { ((pgd_t) { (( __be64)(__builtin_constant_p((__u64)((0))) ? ((__u64)( (((__u64)((0)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0)))) }) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_none(p4d_t p4d)
{
 return !p4d_raw(p4d);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_present(p4d_t p4d)
{
 return !!(p4d_raw(p4d) & (( __be64)(__builtin_constant_p((__u64)((0x8000000000000000UL))) ? ((__u64)( (((__u64)((0x8000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x8000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x8000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x8000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x8000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x8000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x8000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x8000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x8000000000000000UL)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t p4d_pte(p4d_t p4d)
{
 return ((pte_t) { (p4d_raw(p4d)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) p4d_t pte_p4d(pte_t pte)
{
 return ((p4d_t) { ((pgd_t) { (pte_raw(pte)) }) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_bad(p4d_t p4d)
{
 if (radix_enabled())
  return radix__p4d_bad(p4d);
 return hash__p4d_bad(p4d);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool p4d_access_permitted(p4d_t p4d, bool write)
{
 return pte_access_permitted(p4d_pte(p4d), write);
}

extern struct page *p4d_page(p4d_t p4d);
# 1020 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int map_kernel_page(unsigned long ea, unsigned long pa, pgprot_t prot)
{
 if (radix_enabled()) {




  return radix__map_kernel_page(ea, pa, prot, (1UL << 16));
 }
 return hash__map_kernel_page(ea, pa, prot);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) vmemmap_create_mapping(unsigned long start,
         unsigned long page_size,
         unsigned long phys)
{
 if (radix_enabled())
  return radix__vmemmap_create_mapping(start, page_size, phys);
 return hash__vmemmap_create_mapping(start, page_size, phys);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vmemmap_remove_mapping(unsigned long start,
       unsigned long page_size)
{
 if (radix_enabled())
  return radix__vmemmap_remove_mapping(start, page_size);
 return hash__vmemmap_remove_mapping(start, page_size);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pmd_pte(pmd_t pmd)
{
 return ((pte_t) { (pmd_raw(pmd)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pte_pmd(pte_t pte)
{
 return ((pmd_t) { (pte_raw(pte)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t *pmdp_ptep(pmd_t *pmd)
{
 return (pte_t *)pmd;
}
# 1090 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_protnone(pmd_t pmd)
{
 return pte_protnone(pmd_pte(pmd));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_access_permitted(pmd_t pmd, bool write)
{
# 1113 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
 if (pmd_is_serializing(pmd))
  return false;

 return pte_access_permitted(pmd_pte(pmd), write);
}


extern pmd_t pfn_pmd(unsigned long pfn, pgprot_t pgprot);
extern pmd_t mk_pmd(struct page *page, pgprot_t pgprot);
extern pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot);
extern void set_pmd_at(struct mm_struct *mm, unsigned long addr,
         pmd_t *pmdp, pmd_t pmd);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_mmu_cache_pmd(struct vm_area_struct *vma,
     unsigned long addr, pmd_t *pmd)
{
}

extern int hash__has_transparent_hugepage(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int has_transparent_hugepage(void)
{
 if (radix_enabled())
  return radix__has_transparent_hugepage();
 return hash__has_transparent_hugepage();
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
pmd_hugepage_update(struct mm_struct *mm, unsigned long addr, pmd_t *pmdp,
      unsigned long clr, unsigned long set)
{
 if (radix_enabled())
  return radix__pmd_hugepage_update(mm, addr, pmdp, clr, set);
 return hash__pmd_hugepage_update(mm, addr, pmdp, clr, set);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_large(pmd_t pmd)
{
 return !!(pmd_raw(pmd) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __pmdp_test_and_clear_young(struct mm_struct *mm,
           unsigned long addr, pmd_t *pmdp)
{
 unsigned long old;

 if ((pmd_raw(*pmdp) & (( __be64)(__builtin_constant_p((__u64)((0x00100 | 0x0080000000000000UL))) ? ((__u64)( (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x00100 | 0x0080000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x00100 | 0x0080000000000000UL))))) == 0)
  return 0;
 old = pmd_hugepage_update(mm, addr, pmdp, 0x00100, 0);
 return ((old & 0x00100) != 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pmdp_set_wrprotect(struct mm_struct *mm, unsigned long addr,
          pmd_t *pmdp)
{
 if (__pte_write(pmd_pte((*pmdp))))
  pmd_hugepage_update(mm, addr, pmdp, 0x00002, 0);
 else if (__builtin_expect(!!(pte_savedwrite(pmd_pte(*pmdp))), 0))
  pmd_hugepage_update(mm, addr, pmdp, 0, 0x00008);
}
# 1193 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_trans_huge(pmd_t pmd)
{
 if (!pmd_present(pmd))
  return false;

 if (radix_enabled())
  return radix__pmd_trans_huge(pmd);
 return hash__pmd_trans_huge(pmd);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 if (radix_enabled())
  return radix__pmd_same(pmd_a, pmd_b);
 return hash__pmd_same(pmd_a, pmd_b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_mkhuge(pmd_t pmd)
{
 if (radix_enabled())
  return radix__pmd_mkhuge(pmd);
 return hash__pmd_mkhuge(pmd);
}


extern int pmdp_set_access_flags(struct vm_area_struct *vma,
     unsigned long address, pmd_t *pmdp,
     pmd_t entry, int dirty);


extern int pmdp_test_and_clear_young(struct vm_area_struct *vma,
         unsigned long address, pmd_t *pmdp);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmdp_huge_get_and_clear(struct mm_struct *mm,
         unsigned long addr, pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pmdp_huge_get_and_clear(mm, addr, pmdp);
 return hash__pmdp_huge_get_and_clear(mm, addr, pmdp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmdp_collapse_flush(struct vm_area_struct *vma,
     unsigned long address, pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pmdp_collapse_flush(vma, address, pmdp);
 return hash__pmdp_collapse_flush(vma, address, pmdp);
}



pmd_t pmdp_huge_get_and_clear_full(struct vm_area_struct *vma,
       unsigned long addr,
       pmd_t *pmdp, int full);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgtable_trans_huge_deposit(struct mm_struct *mm,
           pmd_t *pmdp, pgtable_t pgtable)
{
 if (radix_enabled())
  return radix__pgtable_trans_huge_deposit(mm, pmdp, pgtable);
 return hash__pgtable_trans_huge_deposit(mm, pmdp, pgtable);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm,
          pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pgtable_trans_huge_withdraw(mm, pmdp);
 return hash__pgtable_trans_huge_withdraw(mm, pmdp);
}


extern pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,
        pmd_t *pmdp);


struct spinlock;
extern int pmd_move_must_withdraw(struct spinlock *new_pmd_ptl,
      struct spinlock *old_pmd_ptl,
      struct vm_area_struct *vma);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_needs_pgtable_deposit(void)
{
 if (radix_enabled())
  return false;
 return true;
}
extern void serialize_against_pte_lookup(struct mm_struct *mm);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_mkdevmap(pmd_t pmd)
{
 if (radix_enabled())
  return radix__pmd_mkdevmap(pmd);
 return hash__pmd_mkdevmap(pmd);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_devmap(pmd_t pmd)
{
 return pte_devmap(pmd_pte(pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_devmap(pud_t pud)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_devmap(pgd_t pgd)
{
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_pfn(pud_t pud)
{





 do { extern void __compiletime_assert_36(void) ; if (!(!(1))) __compiletime_assert_36(); } while (0);
 return 0;
}

pte_t ptep_modify_prot_start(struct vm_area_struct *, unsigned long, pte_t *);
void ptep_modify_prot_commit(struct vm_area_struct *, unsigned long,
        pte_t *, pte_t, pte_t);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_pte_rw_upgrade(unsigned long old_val, unsigned long new_val)
{
 if (!(old_val & 0x00004))
  return false;

 if ((!(old_val & 0x00002)) && (new_val & 0x00002))
  return true;

 return false;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_is_leaf(pmd_t pmd)
{
 return !!(pmd_raw(pmd) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pud_is_leaf(pud_t pud)
{
 return !!(pud_raw(pud) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool p4d_is_leaf(p4d_t p4d)
{
 return !!(p4d_raw(p4d) & (( __be64)(__builtin_constant_p((__u64)((0x4000000000000000UL))) ? ((__u64)( (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((0x4000000000000000UL)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((0x4000000000000000UL)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((0x4000000000000000UL)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((0x4000000000000000UL)))));
}
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/task_size_64.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 2
# 135 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
struct mmu_hash_ops {
 void (*hpte_invalidate)(unsigned long slot,
        unsigned long vpn,
        int bpsize, int apsize,
        int ssize, int local);
 long (*hpte_updatepp)(unsigned long slot,
      unsigned long newpp,
      unsigned long vpn,
      int bpsize, int apsize,
      int ssize, unsigned long flags);
 void (*hpte_updateboltedpp)(unsigned long newpp,
            unsigned long ea,
            int psize, int ssize);
 long (*hpte_insert)(unsigned long hpte_group,
           unsigned long vpn,
           unsigned long prpn,
           unsigned long rflags,
           unsigned long vflags,
           int psize, int apsize,
           int ssize);
 long (*hpte_remove)(unsigned long hpte_group);
 int (*hpte_removebolted)(unsigned long ea,
          int psize, int ssize);
 void (*flush_hash_range)(unsigned long number, int local);
 void (*hugepage_invalidate)(unsigned long vsid,
            unsigned long addr,
            unsigned char *hpte_slot_array,
            int psize, int ssize, int local);
 int (*resize_hpt)(unsigned long shift);







 void (*hpte_clear_all)(void);
};
extern struct mmu_hash_ops mmu_hash_ops;

struct hash_pte {
 __be64 v;
 __be64 r;
};

extern struct hash_pte *htab_address;
extern unsigned long htab_size_bytes;
extern unsigned long htab_hash_mask;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int shift_to_mmu_psize(unsigned int shift)
{
 int psize;

 for (psize = 0; psize < 16; ++psize)
  if (mmu_psize_defs[psize].shift == shift)
   return psize;
 return -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int mmu_psize_to_shift(unsigned int mmu_psize)
{
 if (mmu_psize_defs[mmu_psize].shift)
  return mmu_psize_defs[mmu_psize].shift;
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu-hash.h"), "i" (199), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ap_to_shift(unsigned long ap)
{
 int psize;

 for (psize = 0; psize < 16; psize++) {
  if (mmu_psize_defs[psize].ap == ap)
   return mmu_psize_defs[psize].shift;
 }

 return -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_sllp_encoding(int psize)
{
 unsigned long sllp;

 sllp = ((mmu_psize_defs[psize].sllp & 0x0000000000000100UL) >> 6) |
  ((mmu_psize_defs[psize].sllp & 0x0000000000000030UL) >> 4);
 return sllp;
}
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int slb_vsid_shift(int ssize)
{
 if (ssize == 0)
  return 12;
 return 24;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int segment_shift(int ssize)
{
 if (ssize == 0)
  return 28;
 return 40;
}
# 274 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
extern u8 hpte_page_sizes[1 << 8];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __hpte_page_size(unsigned long h, unsigned long l,
          bool is_base_size)
{
 unsigned int i, lp;

 if (!(h & 0x0000000000000004UL))
  return 1ul << 12;


 lp = (l >> 12) & ((1 << 8) - 1);
 i = hpte_page_sizes[lp];
 if (!i)
  return 0;
 if (!is_base_size)
  i >>= 4;
 return 1ul << mmu_psize_defs[i & 0xf].shift;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_page_size(unsigned long h, unsigned long l)
{
 return __hpte_page_size(h, l, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_base_page_size(unsigned long h, unsigned long l)
{
 return __hpte_page_size(h, l, 1);
}




extern int mmu_kernel_ssize;
extern int mmu_highuser_ssize;
extern u16 mmu_slb_size;
extern unsigned long tce_alloc_start, tce_alloc_end;







extern int mmu_ci_restrictions;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_avpn(unsigned long vpn, int psize,
          int ssize)
{
 unsigned long v;
# 337 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
 v = (vpn >> (23 - 12)) & ~(mmu_psize_defs[psize].avpnm);
 v <<= 7;
 v |= ((unsigned long) ssize) << 62;
 return v;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_old_to_new_v(unsigned long v)
{

 return v & 0x000fffffffffffffUL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_old_to_new_r(unsigned long v, unsigned long r)
{

 return (r & ~(3ull << 58)) |
  (((v) >> 62) << 58);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_new_to_old_v(unsigned long v, unsigned long r)
{

 return (v & 0x000fffffffffffffUL) |
  ((r & (3ull << 58)) <<
   (62 - 58));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_new_to_old_r(unsigned long r)
{

 return r & ~(3ull << 58);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_get_old_v(struct hash_pte *hptep)
{
 unsigned long hpte_v;

 hpte_v = (__builtin_constant_p((__u64)(( __u64)(__be64)(hptep->v))) ? ((__u64)( (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(hptep->v)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(hptep->v)));
 if (cpu_has_feature(0x0000000000020000UL))
  hpte_v = hpte_new_to_old_v(hpte_v, (__builtin_constant_p((__u64)(( __u64)(__be64)(hptep->r))) ? ((__u64)( (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(hptep->r)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(hptep->r))));
 return hpte_v;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_v(unsigned long vpn, int base_psize,
       int actual_psize, int ssize)
{
 unsigned long v;
 v = hpte_encode_avpn(vpn, base_psize, ssize);
 if (actual_psize != 0)
  v |= 0x0000000000000004UL;
 return v;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_r(unsigned long pa, int base_psize,
       int actual_psize)
{

 if (actual_psize == 0)
  return pa & 0x0ffffffffffff000UL;
 else {
  unsigned int penc = mmu_psize_defs[base_psize].penc[actual_psize];
  unsigned int shift = mmu_psize_defs[actual_psize].shift;
  return (pa & ~((1ul << shift) - 1)) | (penc << 12);
 }
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpt_vpn(unsigned long ea,
        unsigned long vsid, int ssize)
{
 unsigned long mask;
 int s_shift = segment_shift(ssize);

 mask = (1ul << (s_shift - 12)) - 1;
 return (vsid << (s_shift - 12)) | ((ea >> 12) & mask);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpt_hash(unsigned long vpn,
         unsigned int shift, int ssize)
{
 unsigned long mask;
 unsigned long hash, vsid;


 if (ssize == 0) {
  mask = (1ul << (28 - 12)) - 1;
  hash = (vpn >> (28 - 12)) ^
   ((vpn & mask) >> (shift - 12));
 } else {
  mask = (1ul << (40 - 12)) - 1;
  vsid = vpn >> (40 - 12);
  hash = vsid ^ (vsid << 25) ^
   ((vpn & mask) >> (shift - 12)) ;
 }
 return hash & 0x7fffffffffUL;
}




extern int __hash_page_4K(unsigned long ea, unsigned long access,
     unsigned long vsid, pte_t *ptep, unsigned long trap,
     unsigned long flags, int ssize, int subpage_prot);
extern int __hash_page_64K(unsigned long ea, unsigned long access,
      unsigned long vsid, pte_t *ptep, unsigned long trap,
      unsigned long flags, int ssize);
struct mm_struct;
unsigned int hash_page_do_lazy_icache(unsigned int pp, pte_t pte, int trap);
extern int hash_page_mm(struct mm_struct *mm, unsigned long ea,
   unsigned long access, unsigned long trap,
   unsigned long flags);
extern int hash_page(unsigned long ea, unsigned long access, unsigned long trap,
       unsigned long dsisr);
int __hash_page_huge(unsigned long ea, unsigned long access, unsigned long vsid,
       pte_t *ptep, unsigned long trap, unsigned long flags,
       int ssize, unsigned int shift, unsigned int mmu_psize);

extern int __hash_page_thp(unsigned long ea, unsigned long access,
      unsigned long vsid, pmd_t *pmdp, unsigned long trap,
      unsigned long flags, int ssize, unsigned int psize);
# 486 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
extern void hash_failure_debug(unsigned long ea, unsigned long access,
          unsigned long vsid, unsigned long trap,
          int ssize, int psize, int lpsize,
          unsigned long pte);
extern int htab_bolt_mapping(unsigned long vstart, unsigned long vend,
        unsigned long pstart, unsigned long prot,
        int psize, int ssize);
int htab_remove_mapping(unsigned long vstart, unsigned long vend,
   int psize, int ssize);
extern void pseries_add_gpage(u64 addr, u64 page_size, unsigned long number_of_pages);
extern void demote_segment_4k(struct mm_struct *mm, unsigned long addr);

extern void hash__setup_new_exec(void);


void hpte_init_pseries(void);




extern void hpte_init_native(void);

struct slb_entry {
 u64 esid;
 u64 vsid;
};

extern void slb_initialize(void);
void slb_flush_and_restore_bolted(void);
void slb_flush_all_realmode(void);
void __slb_restore_bolted_realmode(void);
void slb_restore_bolted_realmode(void);
void slb_save_contents(struct slb_entry *slb_ptr);
void slb_dump_contents(struct slb_entry *slb_ptr);

extern void slb_vmalloc_update(void);
extern void slb_set_size(u16 size);
# 673 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
struct subpage_prot_table {
 unsigned long maxaddr;
 unsigned int **protptrs[((0x0010000000000000UL) >> 43)];
 unsigned int *low_prot[4];
};
# 686 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
extern void subpage_prot_free(struct mm_struct *mm);
# 696 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
struct slice_mask {
 u64 low_slices;
 unsigned long high_slices[(((((1UL << (8 + 10 + 10 + 8 + 16)) >> 40)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
};

struct hash_mm_context {
 u16 user_psize;


 unsigned char low_slices_psize[(64 / 8)];
 unsigned char high_slices_psize[((1UL << (8 + 10 + 10 + 8 + 16)) >> 41)];
 unsigned long slb_addr_limit;

 struct slice_mask mask_64k;

 struct slice_mask mask_4k;

 struct slice_mask mask_16m;
 struct slice_mask mask_16g;



 struct subpage_prot_table *spt;

};
# 742 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vsid_scramble(unsigned long protovsid,
      unsigned long vsid_multiplier, int vsid_bits)
{
 unsigned long vsid;
 unsigned long vsid_modulus = ((1UL << vsid_bits) - 1);



 vsid = protovsid * vsid_multiplier;
 vsid = (vsid >> vsid_bits) + (vsid & vsid_modulus);
 return (vsid + ((vsid + 1) >> vsid_bits)) & vsid_modulus;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int user_segment_size(unsigned long addr)
{

 if (addr >= (1UL << 40))
  return mmu_highuser_ssize;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_vsid(unsigned long context, unsigned long ea,
         int ssize)
{
 unsigned long va_bits = 68;
 unsigned long vsid_bits;
 unsigned long protovsid;




 if ((ea & (~(0xcUL << 60))) >= (1UL << (8 + 10 + 10 + 8 + 16)))
  return 0;

 if (!mmu_has_feature(0x00002000UL))
  va_bits = 65;

 if (ssize == 0) {
  vsid_bits = va_bits - 28;
  protovsid = (context << (68 - (28 + 19))) |
   ((ea >> 28) & ((1 << (68 - (28 + 19))) - 1));
  return vsid_scramble(protovsid, 12538073UL, vsid_bits);
 }

 vsid_bits = va_bits - 40;
 protovsid = (context << (68 - (40 + 19))) |
  ((ea >> 40) & ((1 << (68 - (40 + 19))) - 1));
 return vsid_scramble(protovsid, 12538073UL, vsid_bits);
}
# 811 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kernel_context(unsigned long ea)
{
 unsigned long region_id = get_region_id(ea);
 unsigned long ctx;




 if (region_id == 1) {



  ctx = 1 + ((ea & (~(0xcUL << 60))) >> 49);
 } else
  ctx = region_id + (1UL << (51 - 49)) - 1;
 return ctx;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kernel_vsid(unsigned long ea, int ssize)
{
 unsigned long context;

 if (!((ea) >= 0xc000000000000000UL))
  return 0;

 context = get_kernel_context(ea);
 return get_vsid(context, ea, ssize);
}

unsigned htab_shift_for_mem_size(unsigned long mem_size);
# 47 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h" 2





struct prtb_entry {
 __be64 prtb0;
 __be64 prtb1;
};
extern struct prtb_entry *process_tb;

struct patb_entry {
 __be64 patb0;
 __be64 patb1;
};
extern struct patb_entry *partition_tb;
# 80 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
extern unsigned int mmu_pid_bits;


extern unsigned int mmu_base_pid;
# 93 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
typedef unsigned long mm_context_id_t;
struct spinlock;




typedef struct {
 union {
# 109 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
  mm_context_id_t id;
  mm_context_id_t extended_id[(0x0010000000000000UL)/(0x0002000000000000UL)];
 };


 atomic_t active_cpus;


 atomic_t copros;


 atomic_t vas_windows;

 struct hash_mm_context *hash_context;

 unsigned long vdso_base;



 void *pte_frag;
 void *pmd_frag;

 struct list_head iommu_group_mem_list;
# 140 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
 u32 pkey_allocation_map;
 s16 execute_only_pkey;

} mm_context_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 mm_ctx_user_psize(mm_context_t *ctx)
{
 return ctx->hash_context->user_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_ctx_set_user_psize(mm_context_t *ctx, u16 user_psize)
{
 ctx->hash_context->user_psize = user_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *mm_ctx_low_slices(mm_context_t *ctx)
{
 return ctx->hash_context->low_slices_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *mm_ctx_high_slices(mm_context_t *ctx)
{
 return ctx->hash_context->high_slices_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long mm_ctx_slb_addr_limit(mm_context_t *ctx)
{
 return ctx->hash_context->slb_addr_limit;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_ctx_set_slb_addr_limit(mm_context_t *ctx, unsigned long limit)
{
 ctx->hash_context->slb_addr_limit = limit;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct slice_mask *slice_mask_for_size(mm_context_t *ctx, int psize)
{

 if (psize == 2)
  return &ctx->hash_context->mask_64k;


 if (psize == 10)
  return &ctx->hash_context->mask_16m;
 if (psize == 14)
  return &ctx->hash_context->mask_16g;

 do { if (__builtin_constant_p(psize != 0)) { if (psize != 0) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (187), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (187), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(psize != 0))); } } while (0);

 return &ctx->hash_context->mask_4k;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct subpage_prot_table *mm_ctx_subpage_prot(mm_context_t *ctx)
{
 return ctx->hash_context->spt;
}





extern int mmu_linear_psize;
extern int mmu_virtual_psize;
extern int mmu_vmalloc_psize;
extern int mmu_vmemmap_psize;
extern int mmu_io_psize;


void mmu_early_init_devtree(void);
void hash__early_init_devtree(void);
void radix__early_init_devtree(void);
extern void hash__early_init_mmu(void);
extern void radix__early_init_mmu(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) early_init_mmu(void)
{
 if (radix_enabled())
  return radix__early_init_mmu();
 return hash__early_init_mmu();
}
extern void hash__early_init_mmu_secondary(void);
extern void radix__early_init_mmu_secondary(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void early_init_mmu_secondary(void)
{
 if (radix_enabled())
  return radix__early_init_mmu_secondary();
 return hash__early_init_mmu_secondary();
}

extern void hash__setup_initial_memory_limit(phys_addr_t first_memblock_base,
      phys_addr_t first_memblock_size);
extern void radix__setup_initial_memory_limit(phys_addr_t first_memblock_base,
      phys_addr_t first_memblock_size);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void setup_initial_memory_limit(phys_addr_t first_memblock_base,
           phys_addr_t first_memblock_size)
{
 if (early_radix_enabled())
  return radix__setup_initial_memory_limit(first_memblock_base,
         first_memblock_size);
 return hash__setup_initial_memory_limit(first_memblock_base,
        first_memblock_size);
}


extern void radix_init_pseries(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_user_context(mm_context_t *ctx, unsigned long ea)
{
 int index = ea >> 49;

 if (__builtin_expect(!!(index < (sizeof(ctx->extended_id) / sizeof((ctx->extended_id)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((ctx->extended_id)), typeof(&(ctx->extended_id)[0])))); }))))), 1))
  return ctx->extended_id[index];


 ({ int __ret_warn_on = !!(1); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (257), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (257), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_user_vsid(mm_context_t *ctx,
       unsigned long ea, int ssize)
{
 unsigned long context = get_user_context(ctx, ea);

 return get_vsid(context, ea, ssize);
}
# 349 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/firmware.h" 1
# 58 "/home/nathan/src/linux-next/arch/powerpc/include/asm/firmware.h"
enum {

 FW_FEATURE_PSERIES_POSSIBLE = 0x0000000000000001UL | 0x0000000000000002UL |
  0x0000000000000004UL | 0x0000000000000008UL | 0x0000000000000010UL |
  0x0000000000000020UL | 0x0000000000000040UL | 0x0000000000000080UL |
  0x0000000000000100UL | 0x0000000000000200UL | 0x0000000000000400UL |
  0x0000000000000800UL | 0x0000000000001000UL | 0x0000000000002000UL |
  0x0000000000004000UL | 0x0000000000008000UL | 0x0000000000010000UL |
  0x0000000000020000UL | 0x0000000000040000UL |
  0x0000000000080000UL | 0x0000008000000000UL |
  0x0000000000100000UL | 0x0000000000400000UL |
  0x0000000002000000UL | 0x0000000004000000UL | 0x0000000008000000UL |
  0x0000000040000000UL | 0x0000000080000000UL |
  0x0000000100000000UL | 0x0000000200000000UL |
  0x0000000001000000UL | 0x0000000400000000UL |
  0x0000000800000000UL | 0x0000001000000000UL |
  0x0000002000000000UL | 0x0000004000000000UL,
 FW_FEATURE_PSERIES_ALWAYS = 0,
 FW_FEATURE_POWERNV_POSSIBLE = 0x0000000010000000UL | 0x0000004000000000UL,
 FW_FEATURE_POWERNV_ALWAYS = 0,
 FW_FEATURE_PS3_POSSIBLE = 0x0000000000400000UL | 0x0000000000800000UL,
 FW_FEATURE_PS3_ALWAYS = 0x0000000000400000UL | 0x0000000000800000UL,
 FW_FEATURE_NATIVE_POSSIBLE = 0,
 FW_FEATURE_NATIVE_ALWAYS = 0,
 FW_FEATURE_POSSIBLE =

  FW_FEATURE_PSERIES_POSSIBLE |


  FW_FEATURE_POWERNV_POSSIBLE |





  FW_FEATURE_NATIVE_ALWAYS |

  0,
 FW_FEATURE_ALWAYS =

  FW_FEATURE_PSERIES_ALWAYS &


  FW_FEATURE_POWERNV_ALWAYS &





  FW_FEATURE_NATIVE_ALWAYS &

  FW_FEATURE_POSSIBLE,





};




extern unsigned long powerpc_firmware_features;





extern void system_reset_fwnmi(void);
extern void machine_check_fwnmi(void);


extern int fwnmi_active;
extern int ibm_nmi_interlock_token;

extern unsigned int __start___fw_ftr_fixup, __stop___fw_ftr_fixup;


void pseries_probe_fw_features(void);
# 49 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2
# 62 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
struct lppaca {


 __be32 desc;
 __be16 size;
 u8 reserved1[3];
 u8 __old_status;
 u8 reserved3[14];
 volatile __be32 dyn_hw_node_id;
 volatile __be32 dyn_hw_proc_id;
 u8 reserved4[56];
 volatile u8 vphn_assoc_counts[8];

 u8 reserved5[32];



 u8 reserved6[48];
 u8 cede_latency_hint;
 u8 ebb_regs_in_use;
 u8 reserved7[6];
 u8 dtl_enable_mask;
 u8 donate_dedicated_cpu;
 u8 fpregs_in_use;
 u8 pmcregs_in_use;
 u8 reserved8[28];
 __be64 wait_state_cycles;
 u8 reserved9[28];
 __be16 slb_count;
 u8 idle;
 u8 vmxregs_in_use;
# 104 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
 volatile __be32 yield_count;
 volatile __be32 dispersion_count;
 volatile __be64 cmo_faults;
 volatile __be64 cmo_fault_time;
 u8 reserved10[104];



 __be32 page_ins;
 u8 reserved11[148];
 volatile __be64 dtl_idx;
 u8 reserved12[96];
} __attribute__((__aligned__((1 << 7))));
# 127 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lppaca_shared_proc(struct lppaca *l)
{
 if (!((FW_FEATURE_ALWAYS & (0x0000000000100000UL)) || (FW_FEATURE_POSSIBLE & powerpc_firmware_features & (0x0000000000100000UL))))
  return false;
 return !!(l->__old_status & 2);
}






struct slb_shadow {
 __be32 persistent;
 __be32 buffer_length;
 __be64 reserved;
 struct {
  __be64 esid;
  __be64 vsid;
 } save_area[2];
} __attribute__((__aligned__((1 << 7))));




struct dtl_entry {
 u8 dispatch_reason;
 u8 preempt_reason;
 __be16 processor_id;
 __be32 enqueue_to_dispatch_time;
 __be32 ready_to_enqueue_time;
 __be32 waiting_to_ready_time;
 __be64 timebase;
 __be64 fault_addr;
 __be64 srr0;
 __be64 srr1;
};
# 179 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
extern struct kmem_cache *dtl_cache;
extern rwlock_t dtl_access_lock;







extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);

extern void register_dtl_buffer(int cpu);
extern void alloc_dtl_buffers(unsigned long *time_limit);
extern long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/exception-64s.h" 1
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h" 1
# 66 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
struct kvmppc_vcore;


struct kvm_split_mode {
 unsigned long rpr;
 unsigned long pmmar;
 unsigned long ldbar;
 u8 subcore_size;
 u8 do_nap;
 u8 napped[8];
 struct kvmppc_vcore *vc[4];

 unsigned long lpcr_req;
 unsigned long lpidr_req;
 unsigned long host_lpcr;
 u32 do_set;
 u32 do_restore;
 union {
  u32 allphases;
  u8 phase[4];
 } lpcr_sync;
};
# 96 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
struct kvmppc_host_state {
 ulong host_r1;
 ulong host_r2;
 ulong host_msr;
 ulong vmhandler;
 ulong scratch0;
 ulong scratch1;
 ulong scratch2;
 u8 in_guest;
 u8 restore_hid5;
 u8 napping;


 u8 hwthread_req;
 u8 hwthread_state;
 u8 host_ipi;
 u8 ptid;
 u8 tid;
 u8 fake_suspend;
 struct kvm_vcpu *kvm_vcpu;
 struct kvmppc_vcore *kvm_vcore;
 void *xics_phys;
 void *xive_tima_phys;
 void *xive_tima_virt;
 u32 saved_xirr;
 u64 dabr;
 u64 host_mmcr[7];
 u32 host_pmc[8];
 u64 host_purr;
 u64 host_spurr;
 u64 host_dscr;
 u64 dec_expires;
 struct kvm_split_mode *kvm_split_mode;


 u64 cfar;
 u64 ppr;
 u64 host_fscr;

};

struct kvmppc_book3s_shadow_vcpu {
 bool in_use;
 ulong gpr[14];
 u32 cr;
 ulong xer;
 ulong ctr;
 ulong lr;
 ulong pc;

 ulong shadow_srr1;
 ulong fault_dar;
 u32 fault_dsisr;
 u32 last_inst;
# 158 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
 u8 slb_max;
 struct {
  u64 esid;
  u64 vsid;
 } slb[64];
 u64 shadow_fscr;

};
# 27 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/accounting.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/accounting.h"
struct cpu_accounting_data {

 unsigned long utime;
 unsigned long stime;




 unsigned long gtime;
 unsigned long hardirq_time;
 unsigned long softirq_time;
 unsigned long steal_time;
 unsigned long idle_time;

 unsigned long starttime;
 unsigned long starttime_user;




};
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hmi.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hmi.h"
struct sibling_subcore_state {
 unsigned long flags;
 u8 in_guest[4];
};

extern void wait_for_subcore_guest_exit(void);
extern void wait_for_tb_resync(void);





struct pt_regs;
extern long hmi_handle_debugtrig(struct pt_regs *regs);
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpuidle.h" 1
# 74 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpuidle.h"
struct pnv_idle_states_t {
 char name[16];
 u32 latency_ns;
 u32 residency_ns;
 u64 psscr_val;
 u64 psscr_mask;
 u32 flags;
 bool valid;
};

extern struct pnv_idle_states_t *pnv_idle_states;
extern int nr_pnv_idle_states;

unsigned long pnv_cpu_offline(unsigned int cpu);
int validate_psscr_val_mask(u64 *psscr_val, u64 *psscr_mask, u32 flags);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void report_invalid_psscr_val(u64 psscr_val, int err)
{
 switch (err) {
 case -1:
  printk("\001" "4" "Invalid psscr 0x%016llx : ESL,EC bits unequal", psscr_val);

  break;
 case -2:
  printk("\001" "4" "Invalid psscr 0x%016llx : ESL cleared for deep stop-state", psscr_val);

 }
}
# 31 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/rtas-types.h" 1






typedef __be32 rtas_arg_t;

struct rtas_args {
 __be32 token;
 __be32 nargs;
 __be32 nret;
 rtas_arg_t args[16];
 rtas_arg_t *rets;
};

struct rtas_t {
 unsigned long entry;
 unsigned long base;
 unsigned long size;
 arch_spinlock_t lock;
 struct rtas_args args;
 struct device_node *dev;
};

struct rtas_suspend_me_data {
 atomic_t working;
 atomic_t done;
 int token;
 atomic_t error;
 struct completion *complete;
};

struct rtas_error_log {

 u8 byte0;


 u8 byte1;
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/rtas-types.h"
 u8 byte2;




 u8 byte3;
 __be32 extended_log_length;
 unsigned char buffer[1];

};




struct rtas_ext_event_log_v6 {

 u8 byte0;
# 77 "/home/nathan/src/linux-next/arch/powerpc/include/asm/rtas-types.h"
 u8 byte1;


 u8 byte2;







 u8 byte3;

 u8 reserved[8];

 __be32 company_id;



 u8 vendor_log[1];

};


struct pseries_errorlog {
 __be16 id;
 __be16 length;
 u8 version;
 u8 subtype;
 __be16 creator_component;
 u8 data[];
};


struct pseries_hp_errorlog {
 u8 resource;
 u8 action;
 u8 id_type;
 u8 reserved;
 union {
  __be32 drc_index;
  __be32 drc_count;
  struct { __be32 count, index; } ic;
  char drc_name[1];
 } _drc_u;
};
# 33 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/mmiowb_types.h" 1






struct mmiowb_state {
 u16 nesting_count;
 u16 mmiowb_pending;
};
# 35 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

register struct paca_struct *local_paca asm("r13");
# 55 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
struct task_struct;







struct paca_struct {
# 72 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 struct lppaca *lppaca_ptr;
# 85 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 u16 paca_index;
 u16 lock_token;


 u64 kernel_toc;
 u64 kernelbase;
 u64 kernel_msr;
 void *emergency_sp;
 u64 data_offset;
 s16 hw_cpu_id;
 u8 cpu_start;

 u8 kexec_state;

 struct slb_shadow *slb_shadow_ptr;
 struct dtl_entry *dispatch_log;
 struct dtl_entry *dispatch_log_end;

 u64 dscr_default;






 u64 exgen[10] __attribute__((aligned(0x80)));
 u64 exslb[10];


 u16 vmalloc_sllp;
 u8 slb_cache_ptr;
 u8 stab_rr;

 u8 in_kernel_slb_handler;

 u32 slb_used_bitmap;
 u32 slb_kern_bitmap;
 u32 slb_cache[8];
# 152 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 mm_context_id_t mm_ctx_id;

 unsigned char mm_ctx_low_slices_psize[64 / 8];
 unsigned char mm_ctx_high_slices_psize[((1UL << (8 + 10 + 10 + 8 + 16)) >> 41)];
 unsigned long mm_ctx_slb_addr_limit;
# 166 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 struct task_struct *__current;
 u64 kstack;
 u64 saved_r1;
 u64 saved_msr;



 u8 irq_soft_mask;
 u8 irq_happened;
 u8 irq_work_pending;

 u8 pmcregs_in_use;

 u64 sprg_vdso;

 u64 tm_scratch;





 unsigned long idle_state;
 union {

  struct {

   u8 thread_idle_state;

   u8 subcore_sibling_mask;
  };


  struct {


   u64 requested_psscr;

   atomic_t dont_stop;

  };
 };




 u64 exnmi[10];
 u64 exmc[10];



 void *nmi_emergency_sp;
 void *mc_emergency_sp;

 u16 in_nmi;





 u16 in_mce;
 u8 hmi_event_available;
 u8 hmi_p9_special_emu;

 u8 ftrace_enabled;


 struct cpu_accounting_data accounting;
 u64 dtl_ridx;
 struct dtl_entry *dtl_curr;




 struct kvmppc_book3s_shadow_vcpu shadow_vcpu;

 struct kvmppc_host_state kvm_hstate;





 struct sibling_subcore_state *sibling_subcore_state;







 u64 exrfi[10] __attribute__((__aligned__(0x80)));
 void *rfi_flush_fallback_area;
 u64 l1d_flush_size;


 struct rtas_args *rtas_args_reentrant;
 u8 *mce_data_buf;




 struct slb_entry *mce_faulty_slbs;
 u16 slb_save_cache_ptr;





 struct mmiowb_state mmiowb_state;

} __attribute__((__aligned__((1 << 7))));

extern void copy_mm_to_paca(struct mm_struct *mm);
extern struct paca_struct **paca_ptrs;
extern void initialise_paca(struct paca_struct *new_paca, int cpu);
extern void setup_paca(struct paca_struct *new_paca);
extern void allocate_paca_ptrs(void);
extern void allocate_paca(int cpu);
extern void free_unused_pacas(void);
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/current.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *get_current(void)
{
 struct task_struct *task;


 asm ("ld %0,%1(13)"
 : "=r" (task)
 : "i" (__builtin_offsetof(struct paca_struct, __current)));

 return task;
}
# 22 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2
# 31 "/home/nathan/src/linux-next/include/linux/thread_info.h"
enum {
 BAD_STACK = -1,
 NOT_STACK = 0,
 GOOD_FRAME,
 GOOD_STACK,
};


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h" 1
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 1








# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h" 1
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg_8xx.h" 1
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h" 2
# 1375 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mtmsr_isync(unsigned long val)
{
 asm volatile("mtmsrd" " %0; " "971:" " " "isync" "; " "972: .pushsection __ftr_alt_97,\"a\"; .align 2; 973:" " " "nop" "; " "974: .popsection; .pushsection __ftr_fixup,\"a\"; .align 3; 975: .8byte ((%1)); .8byte (0); .8byte 971b-975b; .8byte 972b-975b; .8byte 973b-975b; .8byte 974b-975b; .ifgt (974b- 973b)-(972b- 971b); .error \"Feature section else case larger than body\"; .endif; .popsection;" " " : :
   "r" (val), "i" (0x0000000000008000UL) : "memory");
}
# 1392 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wrtee(unsigned long val)
{
 if (__builtin_constant_p(val))
  asm volatile("wrteei %0" : : "i" ((val & (1UL<<(15))) ? 1 : 0) : "memory");
 else
  asm volatile("wrtee %0" : : "r" (val) : "memory");
}

extern unsigned long msr_check_and_set(unsigned long bits);
extern bool strict_msr_control;
extern void __msr_check_and_clear(unsigned long bits);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void msr_check_and_clear(unsigned long bits)
{
 if (strict_msr_control)
  __msr_check_and_clear(bits);
}
# 1460 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
extern unsigned long current_stack_frame(void);

register unsigned long current_stack_pointer asm("r1");

extern unsigned long scom970_read(unsigned int address);
extern void scom970_write(unsigned int address, unsigned long value);

struct pt_regs;

extern void ppc_save_regs(struct pt_regs *regs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_power8_hid0(unsigned long hid0)
{





 asm volatile("sync; mtspr %0,%1; isync":: "i"(0x3F0), "r"(hid0));
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h" 1
# 33 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct user_pt_regs



{
 unsigned long gpr[32];
 unsigned long nip;
 unsigned long msr;
 unsigned long orig_gpr3;
 unsigned long ctr;
 unsigned long link;
 unsigned long xer;
 unsigned long ccr;

 unsigned long softe;




 unsigned long trap;


 unsigned long dar;
 unsigned long dsisr;
 unsigned long result;
};
# 205 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct ppc_debug_info {
 __u32 version;
 __u32 num_instruction_bps;
 __u32 num_data_bps;
 __u32 num_condition_regs;
 __u32 data_bp_alignment;
 __u32 sizeof_condition;
 __u64 features;
};
# 228 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct ppc_hw_breakpoint {
 __u32 version;
 __u32 trigger_type;
 __u32 addr_mode;
 __u32 condition_mode;
 __u64 addr;
 __u64 addr2;
 __u64 condition_value;
};
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 2



struct pt_regs
{
 union {
  struct user_pt_regs user_regs;
  struct {
   unsigned long gpr[32];
   unsigned long nip;
   unsigned long msr;
   unsigned long orig_gpr3;
   unsigned long ctr;
   unsigned long link;
   unsigned long xer;
   unsigned long ccr;

   unsigned long softe;



   unsigned long trap;
   unsigned long dar;
   unsigned long dsisr;
   unsigned long result;
  };
 };

 union {
  struct {

   unsigned long ppr;


   unsigned long kuap;

  };
  unsigned long __pad[2];
 };
};
# 114 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long instruction_pointer(struct pt_regs *regs)
{
 return regs->nip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void instruction_pointer_set(struct pt_regs *regs,
  unsigned long val)
{
 regs->nip = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long user_stack_pointer(struct pt_regs *regs)
{
 return regs->gpr[1];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long frame_pointer(struct pt_regs *regs)
{
 return 0;
}


extern unsigned long profile_pc(struct pt_regs *regs);




long do_syscall_trace_enter(struct pt_regs *regs);
void do_syscall_trace_leave(struct pt_regs *regs);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_syscall_success(struct pt_regs *regs)
{
 return !(regs->ccr & 0x10000000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long regs_return_value(struct pt_regs *regs)
{
 if (is_syscall_success(regs))
  return regs->gpr[3];
 else
  return -regs->gpr[3];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void regs_set_return_value(struct pt_regs *regs, unsigned long rc)
{
 regs->gpr[3] = rc;
}
# 174 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
struct task_struct;
extern int ptrace_get_reg(struct task_struct *task, int regno,
     unsigned long *data);
extern int ptrace_put_reg(struct task_struct *task, int regno,
     unsigned long data);
# 220 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_trap(struct pt_regs *regs, unsigned long val)
{
 regs->trap = (regs->trap & 0x10) | (val & ~0x10);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool trap_is_syscall(struct pt_regs *regs)
{
 return ((regs)->trap & ~0x10) == 0xc00;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool trap_norestart(struct pt_regs *regs)
{
 return regs->trap & 0x10;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_trap_norestart(struct pt_regs *regs)
{
 regs->trap |= 0x10;
}
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 254 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 2
extern int regs_query_register_offset(const char *name);
extern const char *regs_query_register_name(unsigned int offset);
# 267 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long regs_get_register(struct pt_regs *regs,
      unsigned int offset)
{
 if (__builtin_expect(!!(offset > (__builtin_offsetof(struct pt_regs, dsisr))), 0))
  return 0;
 return *(unsigned long *)((unsigned long)regs + offset);
}
# 284 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool regs_within_kernel_stack(struct pt_regs *regs,
      unsigned long addr)
{
 return ((addr & ~((1 << 14) - 1)) ==
  (((regs)->gpr[1]) & ~((1 << 14) - 1)));
}
# 300 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
            unsigned int n)
{
 unsigned long *addr = (unsigned long *)((regs)->gpr[1]);
 addr += n;
 if (regs_within_kernel_stack(regs, (unsigned long)addr))
  return *addr;
 else
  return 0;
}
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
struct arch_hw_breakpoint {
 unsigned long address;
 u16 type;
 u16 len;
 u16 hw_len;
};
# 47 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nr_wp_slots(void)
{
 return 1;
}



# 1 "/home/nathan/src/linux-next/include/linux/kdebug.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kdebug.h" 1






enum die_val {
 DIE_OOPS = 1,
 DIE_IABR_MATCH,
 DIE_DABR_MATCH,
 DIE_BPT,
 DIE_SSTEP,
};
# 6 "/home/nathan/src/linux-next/include/linux/kdebug.h" 2

struct notifier_block;

struct die_args {
 struct pt_regs *regs;
 const char *str;
 long err;
 int trapnr;
 int signr;
};

int register_die_notifier(struct notifier_block *nb);
int unregister_die_notifier(struct notifier_block *nb);

int notify_die(enum die_val val, const char *str,
        struct pt_regs *regs, long err, int trap, int sig);
# 54 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 1
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h" 2

struct pt_regs;



extern int (*__debugger)(struct pt_regs *regs);
extern int (*__debugger_ipi)(struct pt_regs *regs);
extern int (*__debugger_bpt)(struct pt_regs *regs);
extern int (*__debugger_sstep)(struct pt_regs *regs);
extern int (*__debugger_iabr_match)(struct pt_regs *regs);
extern int (*__debugger_break_match)(struct pt_regs *regs);
extern int (*__debugger_fault_handler)(struct pt_regs *regs);
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger), 0)) return __debugger(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_ipi(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_ipi), 0)) return __debugger_ipi(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_bpt(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_bpt), 0)) return __debugger_bpt(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_sstep(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_sstep), 0)) return __debugger_sstep(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_iabr_match(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_iabr_match), 0)) return __debugger_iabr_match(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_break_match(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_break_match), 0)) return __debugger_break_match(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_fault_handler(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_fault_handler), 0)) return __debugger_fault_handler(regs); return 0; }
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h"
void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk);
bool ppc_breakpoint_available(void);





extern void do_break(struct pt_regs *regs, unsigned long address,
       unsigned long error_code);
# 56 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 2

struct perf_event_attr;
struct perf_event;
struct pmu;
struct perf_sample_data;
struct task_struct;

extern int hw_breakpoint_slots(int type);
extern int arch_bp_generic_fields(int type, int *gen_bp_type);
extern int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw);
extern int hw_breakpoint_arch_parse(struct perf_event *bp,
        const struct perf_event_attr *attr,
        struct arch_hw_breakpoint *hw);
extern int hw_breakpoint_exceptions_notify(struct notifier_block *unused,
      unsigned long val, void *data);
int arch_install_hw_breakpoint(struct perf_event *bp);
void arch_uninstall_hw_breakpoint(struct perf_event *bp);
void hw_breakpoint_pmu_read(struct perf_event *bp);
extern void flush_ptrace_hw_breakpoint(struct task_struct *tsk);

extern struct pmu perf_ops_bp;
extern void ptrace_triggered(struct perf_event *bp,
   struct perf_sample_data *data, struct pt_regs *regs);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hw_breakpoint_disable(void)
{
 int i;
 struct arch_hw_breakpoint null_brk = {0};

 if (!ppc_breakpoint_available())
  return;

 for (i = 0; i < nr_wp_slots(); i++)
  __set_breakpoint(i, &null_brk);
}
extern void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs);
int hw_breakpoint_handler(struct die_args *args);
# 102 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
extern bool dawr_force_enable;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dawr_enabled(void)
{
 return dawr_force_enable;
}
int set_dawr(int nr, struct arch_hw_breakpoint *brk);
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 82 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
struct task_struct;
void start_thread(struct pt_regs *regs, unsigned long fdptr, unsigned long sp);
void release_thread(struct task_struct *);

typedef struct {
 unsigned long seg;
} mm_segment_t;





struct thread_fp_state {
 u64 fpr[32][2] __attribute__((aligned(16)));
 u64 fpscr;
};


struct thread_vr_state {
 vector128 vr[32] __attribute__((aligned(16)));
 vector128 vscr __attribute__((aligned(16)));
};

struct debug_reg {
# 142 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
};

struct thread_struct {
 unsigned long ksp;


 unsigned long ksp_vsid;

 struct pt_regs *regs;
 mm_segment_t addr_limit;
# 177 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 struct debug_reg debug;
 struct thread_fp_state fp_state;
 struct thread_fp_state *fp_save_area;
 int fpexc_mode;
 unsigned int align_ctl;

 struct perf_event *ptrace_bps[1];




 struct perf_event *last_hit_ubp[1];

 struct arch_hw_breakpoint hw_brk[1];
 unsigned long trap_nr;
 u8 load_slb;
 u8 load_fp;

 u8 load_vec;
 struct thread_vr_state vr_state;
 struct thread_vr_state *vr_save_area;
 unsigned long vrsave;
 int used_vr;



 int used_vsr;
# 214 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 u8 load_tm;
 u64 tm_tfhar;
 u64 tm_texasr;
 u64 tm_tfiar;
 struct pt_regs ckpt_regs;

 unsigned long tm_tar;
 unsigned long tm_ppr;
 unsigned long tm_dscr;
# 233 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 struct thread_fp_state ckfp_state;
 struct thread_vr_state ckvr_state;
 unsigned long ckvrsave;


 unsigned long amr;
 unsigned long iamr;
 unsigned long uamor;
# 249 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 unsigned long dscr;
 unsigned long fscr;
# 260 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 int dscr_inherit;
 unsigned long tidr;


 unsigned long tar;
 unsigned long ebbrr;
 unsigned long ebbhr;
 unsigned long bescr;
 unsigned long siar;
 unsigned long sdar;
 unsigned long sier;
 unsigned long mmcr2;
 unsigned mmcr0;

 unsigned used_ebb;

};
# 310 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
unsigned long get_wchan(struct task_struct *p);
# 319 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
extern int get_fpexc_mode(struct task_struct *tsk, unsigned long adr);
extern int set_fpexc_mode(struct task_struct *tsk, unsigned int val);




extern int get_endian(struct task_struct *tsk, unsigned long adr);
extern int set_endian(struct task_struct *tsk, unsigned int val);




extern int get_unalign_ctl(struct task_struct *tsk, unsigned long adr);
extern int set_unalign_ctl(struct task_struct *tsk, unsigned int val);

extern void load_fp_state(struct thread_fp_state *fp);
extern void store_fp_state(struct thread_fp_state *fp);
extern void load_vr_state(struct thread_vr_state *vr);
extern void store_vr_state(struct thread_vr_state *vr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __unpack_fe01(unsigned long msr_bits)
{
 return ((msr_bits & (1UL<<(11))) >> 10) | ((msr_bits & (1UL<<(8))) >> 8);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __pack_fe01(unsigned int fpmode)
{
 return ((fpmode << 10) & (1UL<<(11))) | ((fpmode << 8) & (1UL<<(8)));
}
# 374 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
int validate_sp(unsigned long sp, struct task_struct *p,
                       unsigned long nbytes);
# 384 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prefetch(const void *x)
{
 if (__builtin_expect(!!(!x), 0))
  return;

 __asm__ __volatile__ ("dcbt 0,%0" : : "r" (x));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prefetchw(const void *x)
{
 if (__builtin_expect(!!(!x), 0))
  return;

 __asm__ __volatile__ ("dcbtst 0,%0" : : "r" (x));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_clean_sp(unsigned long sp, int is_32)
{
 if (is_32)
  return sp & 0x0ffffffffUL;
 return sp;
}
# 419 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
extern unsigned long isa300_idle_stop_noloss(unsigned long psscr_val);
extern unsigned long isa300_idle_stop_mayloss(unsigned long psscr_val);
extern unsigned long isa206_idle_insn_mayloss(unsigned long type);




extern unsigned long cpuidle_disable;
enum idle_boot_override {IDLE_NO_OVERRIDE = 0, IDLE_POWERSAVE_OFF};

extern int powersave_nap;

extern void power7_idle_type(unsigned long type);
extern void power9_idle_type(unsigned long stop_psscr_val,
         unsigned long stop_psscr_mask);

extern void flush_instruction_cache(void);
extern void hard_reset_now(void);
extern void poweroff_now(void);
extern int fix_alignment(struct pt_regs *);
extern void cvt_fd(float *from, double *to);
extern void cvt_df(double *from, float *to);
extern void _nmask_and_or_msr(unsigned long nmask, unsigned long or_val);
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h" 2







struct thread_info {
 int preempt_count;

 unsigned long local_flags;






 unsigned char slb_preload_nr;
 unsigned char slb_preload_tail;
 u32 slb_preload_esid[16U];


 unsigned long flags __attribute__((__aligned__((1 << 7))));
};
# 78 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);


void arch_setup_new_exec(void);
# 159 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_thread_local_flags(unsigned int flags)
{
 struct thread_info *ti = ((struct thread_info *)get_current());
 return (ti->local_flags & flags) != 0;
}
# 39 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2
# 53 "/home/nathan/src/linux-next/include/linux/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_ti_thread_flag(struct thread_info *ti, int flag)
{
 set_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_ti_thread_flag(struct thread_info *ti, int flag,
      bool value)
{
 if (value)
  set_ti_thread_flag(ti, flag);
 else
  clear_ti_thread_flag(ti, flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_set_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_bit(flag, (unsigned long *)&ti->flags);
}
# 103 "/home/nathan/src/linux-next/include/linux/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_within_stack_frames(const void * const stack,
        const void * const stackend,
        const void *obj, unsigned long len)
{
 return 0;
}



extern void __check_object_size(const void *ptr, unsigned long n,
     bool to_user);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void check_object_size(const void *ptr, unsigned long n,
           bool to_user)
{
 if (!__builtin_constant_p(n))
  __check_object_size(ptr, n, to_user);
}






extern void
__bad_copy_from(void);
extern void
__bad_copy_to(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_overflow(int size, unsigned long count)
{
 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { do { } while(0); __warn_printk("Buffer overflow detected (%d < %lu)!\n", size, count); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/thread_info.h"), "i" (134), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); do { } while(0); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) bool
check_copy_size(const void *addr, size_t bytes, bool is_source)
{
 int sz = -1;
 if (__builtin_expect(!!(sz >= 0 && sz < bytes), 0)) {
  if (!__builtin_constant_p(bytes))
   copy_overflow(sz, bytes);
  else if (is_source)
   __bad_copy_from();
  else
   __bad_copy_to();
  return false;
 }
 if (({ int __ret_warn_on = !!(bytes > ((int)(~0U >> 1))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/thread_info.h"), "i" (150), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return false;
 check_object_size(addr, bytes, is_source);
 return true;
}
# 6 "/home/nathan/src/linux-next/include/asm-generic/preempt.h" 2



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int preempt_count(void)
{
 return ({ do { extern void __compiletime_assert_37(void) ; if (!((sizeof(((struct thread_info *)get_current())->preempt_count) == sizeof(char) || sizeof(((struct thread_info *)get_current())->preempt_count) == sizeof(short) || sizeof(((struct thread_info *)get_current())->preempt_count) == sizeof(int) || sizeof(((struct thread_info *)get_current())->preempt_count) == sizeof(long)) || sizeof(((struct thread_info *)get_current())->preempt_count) == sizeof(long long))) __compiletime_assert_37(); } while (0); ({ typeof( _Generic((((struct thread_info *)get_current())->preempt_count), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (((struct thread_info *)get_current())->preempt_count))) __x = (*(const volatile typeof( _Generic((((struct thread_info *)get_current())->preempt_count), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (((struct thread_info *)get_current())->preempt_count))) *)&(((struct thread_info *)get_current())->preempt_count)); do { } while (0); (typeof(((struct thread_info *)get_current())->preempt_count))__x; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) volatile int *preempt_count_ptr(void)
{
 return &((struct thread_info *)get_current())->preempt_count;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void preempt_count_set(int pc)
{
 *preempt_count_ptr() = pc;
}
# 35 "/home/nathan/src/linux-next/include/asm-generic/preempt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void set_preempt_need_resched(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void clear_preempt_need_resched(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool test_preempt_need_resched(void)
{
 return false;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __preempt_count_add(int val)
{
 *preempt_count_ptr() += val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __preempt_count_sub(int val)
{
 *preempt_count_ptr() -= val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool __preempt_count_dec_and_test(void)
{





 return !--*preempt_count_ptr() && test_ti_thread_flag(((struct thread_info *)get_current()), 2);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool should_resched(int preempt_offset)
{
 return __builtin_expect(!!(preempt_count() == preempt_offset && test_ti_thread_flag(((struct thread_info *)get_current()), 2)), 0);

}
# 2 "./arch/powerpc/include/generated/asm/preempt.h" 2
# 79 "/home/nathan/src/linux-next/include/linux/preempt.h" 2
# 277 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_notifier;
# 293 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_ops {
 void (*sched_in)(struct preempt_notifier *notifier, int cpu);
 void (*sched_out)(struct preempt_notifier *notifier,
     struct task_struct *next);
};
# 306 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_notifier {
 struct hlist_node link;
 struct preempt_ops *ops;
};

void preempt_notifier_inc(void);
void preempt_notifier_dec(void);
void preempt_notifier_register(struct preempt_notifier *notifier);
void preempt_notifier_unregister(struct preempt_notifier *notifier);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void preempt_notifier_init(struct preempt_notifier *notifier,
         struct preempt_ops *ops)
{
 INIT_HLIST_NODE(&notifier->link);
 notifier->ops = ops;
}
# 335 "/home/nathan/src/linux-next/include/linux/preempt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void migrate_disable(void)
{
 __asm__ __volatile__("" : : : "memory");
}
# 350 "/home/nathan/src/linux-next/include/linux/preempt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void migrate_enable(void)
{
 __asm__ __volatile__("" : : : "memory");
}
# 86 "/home/nathan/src/linux-next/include/linux/smp.h" 2



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 1
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
# 1 "/home/nathan/src/linux-next/include/linux/irqreturn.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/irqreturn.h"
enum irqreturn {
 IRQ_NONE = (0 << 0),
 IRQ_HANDLED = (1 << 0),
 IRQ_WAKE_THREAD = (1 << 1),
};

typedef enum irqreturn irqreturn_t;
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 2






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/percpu.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/percpu-defs.h" 1
# 308 "/home/nathan/src/linux-next/include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __this_cpu_preempt_check(const char *op) { }
# 8 "/home/nathan/src/linux-next/include/asm-generic/percpu.h" 2
# 19 "/home/nathan/src/linux-next/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[2048];
# 48 "/home/nathan/src/linux-next/include/asm-generic/percpu.h"
extern void setup_per_cpu_areas(void);
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h" 2
# 27 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 2

extern int boot_cpuid;
extern int spinning_secondaries;
extern u32 *cpu_to_phys_id;

extern void cpu_die(void);
extern int cpu_to_chip_id(int cpu);



struct smp_ops_t {
 void (*message_pass)(int cpu, int msg);

 void (*cause_ipi)(int cpu);

 int (*cause_nmi_ipi)(int cpu);
 void (*probe)(void);
 int (*kick_cpu)(int nr);
 int (*prepare_cpu)(int nr);
 void (*setup_cpu)(int nr);
 void (*bringup_done)(void);
 void (*take_timebase)(void);
 void (*give_timebase)(void);
 int (*cpu_disable)(void);
 void (*cpu_die)(unsigned int nr);
 int (*cpu_bootable)(unsigned int nr);
};

extern int smp_send_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us);
extern int smp_send_safe_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us);
extern void smp_send_debugger_break(void);
extern void start_secondary_resume(void);
extern void smp_generic_give_timebase(void);
extern void smp_generic_take_timebase(void);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned int) cpu_pvr;


int generic_cpu_disable(void);
void generic_cpu_die(unsigned int cpu);
void generic_set_cpu_dead(unsigned int cpu);
void generic_set_cpu_up(unsigned int cpu);
int generic_check_cpu_restart(unsigned int cpu);
int is_cpu_dead(unsigned int cpu);
# 111 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_sibling_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_l2_cache_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_core_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_smallcore_map;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_sibling_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_sibling_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map)))); (typeof((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_core_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_core_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_core_map)))) *)((&(cpu_core_map)))); (typeof((typeof(*((&(cpu_core_map)))) *)((&(cpu_core_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_l2_cache_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_l2_cache_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_l2_cache_map)))) *)((&(cpu_l2_cache_map)))); (typeof((typeof(*((&(cpu_l2_cache_map)))) *)((&(cpu_l2_cache_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_smallcore_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_smallcore_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_smallcore_map)))) *)((&(cpu_smallcore_map)))); (typeof((typeof(*((&(cpu_smallcore_map)))) *)((&(cpu_smallcore_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

extern int cpu_to_core_id(int cpu);
# 153 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern int smp_handle_nmi_ipi(struct pt_regs *regs);





extern int smp_request_message_ipi(int virq, int message);
extern const char *smp_ipi_name[];


extern void smp_muxed_ipi_message_pass(int cpu, int msg);
extern void smp_muxed_ipi_set_message(int cpu, int msg);
extern irqreturn_t smp_ipi_demux(void);
extern irqreturn_t smp_ipi_demux_relaxed(void);

void smp_init_pSeries(void);
void smp_init_cell(void);
void smp_setup_cpu_maps(void);

extern int __cpu_disable(void);
extern void __cpu_die(unsigned int cpu);
# 194 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_hard_smp_processor_id(int cpu)
{
 return paca_ptrs[cpu]->hw_cpu_id;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_hard_smp_processor_id(int cpu, int phys)
{
 paca_ptrs[cpu]->hw_cpu_id = phys;
}
# 220 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern void smp_release_cpus(void);




extern int smt_enabled_at_boot;

extern void smp_mpic_probe(void);
extern void smp_mpic_setup_cpu(int cpu);
extern int smp_generic_kick_cpu(int nr);
extern int smp_generic_cpu_bootable(unsigned int nr);


extern void smp_generic_give_timebase(void);
extern void smp_generic_take_timebase(void);

extern struct smp_ops_t *smp_ops;

extern void arch_send_call_function_single_ipi(int cpu);
extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);





extern void generic_secondary_smp_init(void);
extern void generic_secondary_thread_init(void);
extern unsigned long __secondary_hold_spinloop;
extern unsigned long __secondary_hold_acknowledge;
extern char __secondary_hold;
extern unsigned int booting_thread_hwid;

extern void __early_start(void);
# 90 "/home/nathan/src/linux-next/include/linux/smp.h" 2
# 99 "/home/nathan/src/linux-next/include/linux/smp.h"
extern void smp_send_stop(void);




extern void smp_send_reschedule(int cpu);





extern void smp_prepare_cpus(unsigned int max_cpus);




extern int __cpu_up(unsigned int cpunum, struct task_struct *tidle);




extern void smp_cpus_done(unsigned int max_cpus);




void smp_call_function(smp_call_func_t func, void *info, int wait);
void smp_call_function_many(const struct cpumask *mask,
       smp_call_func_t func, void *info, bool wait);

int smp_call_function_any(const struct cpumask *mask,
     smp_call_func_t func, void *info, int wait);

void kick_all_cpus_sync(void);
void wake_up_all_idle_cpus(void);




void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) call_function_init(void);
void generic_smp_call_function_single_interrupt(void);







void smp_prepare_boot_cpu(void);

extern unsigned int setup_max_cpus;
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) setup_nr_cpu_ids(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) smp_init(void);

extern int __boot_cpu_id;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_boot_cpu_id(void)
{
 return __boot_cpu_id;
}
# 250 "/home/nathan/src/linux-next/include/linux/smp.h"
extern void arch_disable_smp_support(void);

extern void arch_thaw_secondary_cpus_begin(void);
extern void arch_thaw_secondary_cpus_end(void);

void smp_setup_processor_id(void);

int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par,
      bool phys);


int smpcfd_prepare_cpu(unsigned int cpu);
int smpcfd_dead_cpu(unsigned int cpu);
int smpcfd_dying_cpu(unsigned int cpu);
# 16 "/home/nathan/src/linux-next/include/linux/tracepoint.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/srcu.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/srcu.h"
# 1 "/home/nathan/src/linux-next/include/linux/mutex.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/mutex.h"
# 1 "/home/nathan/src/linux-next/include/linux/osq_lock.h" 1








struct optimistic_spin_node {
 struct optimistic_spin_node *next, *prev;
 int locked;
 int cpu;
};

struct optimistic_spin_queue {




 atomic_t tail;
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void osq_lock_init(struct optimistic_spin_queue *lock)
{
 atomic_set(&lock->tail, (0));
}

extern bool osq_lock(struct optimistic_spin_queue *lock);
extern void osq_unlock(struct optimistic_spin_queue *lock);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool osq_is_locked(struct optimistic_spin_queue *lock)
{
 return atomic_read(&lock->tail) != (0);
}
# 21 "/home/nathan/src/linux-next/include/linux/mutex.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/debug_locks.h" 1








struct task_struct;

extern int debug_locks __attribute__((__section__(".data..read_mostly")));
extern int debug_locks_silent __attribute__((__section__(".data..read_mostly")));


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int __debug_locks_off(void)
{
 return ({ typeof(({ __typeof__(*(&debug_locks)) _x_ = (0); (__typeof__(*(&debug_locks))) __xchg_relaxed((&debug_locks), (unsigned long)_x_, sizeof(*(&debug_locks))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&debug_locks)) _x_ = (0); (__typeof__(*(&debug_locks))) __xchg_relaxed((&debug_locks), (unsigned long)_x_, sizeof(*(&debug_locks))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
}




extern int debug_locks_off(void);
# 49 "/home/nathan/src/linux-next/include/linux/debug_locks.h"
struct task_struct;







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_show_all_locks(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_show_held_locks(struct task_struct *task)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_locks_freed(const void *from, unsigned long len)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_locks_held(void)
{
}
# 22 "/home/nathan/src/linux-next/include/linux/mutex.h" 2

struct ww_acquire_ctx;
# 53 "/home/nathan/src/linux-next/include/linux/mutex.h"
struct mutex {
 atomic_long_t owner;
 spinlock_t wait_lock;

 struct optimistic_spin_queue osq;

 struct list_head wait_list;






};





struct mutex_waiter {
 struct list_head list;
 struct task_struct *task;
 struct ww_acquire_ctx *ww_ctx;



};
# 92 "/home/nathan/src/linux-next/include/linux/mutex.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mutex_destroy(struct mutex *lock) {}
# 131 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock, const char *name,
    struct lock_class_key *key);







extern bool mutex_is_locked(struct mutex *lock);
# 168 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern void mutex_lock(struct mutex *lock);
extern int __attribute__((__warn_unused_result__)) mutex_lock_interruptible(struct mutex *lock);
extern int __attribute__((__warn_unused_result__)) mutex_lock_killable(struct mutex *lock);
extern void mutex_lock_io(struct mutex *lock);
# 186 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern int mutex_trylock(struct mutex *lock);
extern void mutex_unlock(struct mutex *lock);

extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);





enum mutex_trylock_recursive_enum {
 MUTEX_TRYLOCK_FAILED = 0,
 MUTEX_TRYLOCK_SUCCESS = 1,
 MUTEX_TRYLOCK_RECURSIVE,
};
# 213 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern __attribute__((__warn_unused_result__)) enum mutex_trylock_recursive_enum
mutex_trylock_recursive(struct mutex *lock);
# 20 "/home/nathan/src/linux-next/include/linux/srcu.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 1
# 26 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
# 1 "/home/nathan/src/linux-next/include/linux/irqflags.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/irqflags.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h" 1
# 54 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
extern void replay_system_reset(void);
extern void replay_soft_interrupts(void);

extern void timer_interrupt(struct pt_regs *);
extern void timer_broadcast_interrupt(void);
extern void performance_monitor_exception(struct pt_regs *regs);
extern void WatchdogException(struct pt_regs *regs);
extern void unknown_exception(struct pt_regs *regs);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_return(void)
{
 unsigned long flags;

 asm volatile(
  "lbz %0,%1(13)"
  : "=r" (flags)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)));

 return flags;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void irq_soft_mask_set(unsigned long mask)
{
# 103 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
 asm volatile(
  "stb %0,%1(13)"
  :
  : "r" (mask),
    "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask))
  : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_set_return(unsigned long mask)
{
 unsigned long flags;





 asm volatile(
  "lbz %0,%1(13); stb %2,%1(13)"
  : "=&r" (flags)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)),
    "r" (mask)
  : "memory");

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_or_return(unsigned long mask)
{
 unsigned long flags, tmp;

 asm volatile(
  "lbz %0,%2(13); or %1,%0,%3; stb %1,%2(13)"
  : "=&r" (flags), "=r" (tmp)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)),
    "r" (mask)
  : "memory");





 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long arch_local_save_flags(void)
{
 return irq_soft_mask_return();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_local_irq_disable(void)
{
 irq_soft_mask_set(1);
}

extern void arch_local_irq_restore(unsigned long);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_local_irq_enable(void)
{
 arch_local_irq_restore(0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long arch_local_irq_save(void)
{
 return irq_soft_mask_set_return(1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irqs_disabled_flags(unsigned long flags)
{
 return flags & 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irqs_disabled(void)
{
 return arch_irqs_disabled_flags(arch_local_save_flags());
}
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __lazy_irq_pending(u8 irq_happened)
{
 return !!(irq_happened & ~0x01);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lazy_irq_pending(void)
{
 return __lazy_irq_pending(local_paca->irq_happened);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lazy_irq_pending_nocheck(void)
{
 return __lazy_irq_pending(local_paca->irq_happened);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void may_hard_irq_enable(void)
{
 if (!(local_paca->irq_happened & (0x04|0x40))) {
  local_paca->irq_happened &= ~0x01;
  asm volatile("mtmsrd %0," "1" : : "r" ((1UL<<(15))|(1UL<<(1))) : "memory");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irq_disabled_regs(struct pt_regs *regs)
{
 return (regs->softe & 1);
}

extern bool prep_irq_for_idle(void);
extern bool prep_irq_for_idle_irqsoff(void);
extern void irq_set_pending_from_srr1(unsigned long srr1);



extern void force_external_irq_replay(void);
# 379 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
struct irq_chip;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h" 2
# 17 "/home/nathan/src/linux-next/include/linux/irqflags.h" 2
# 26 "/home/nathan/src/linux-next/include/linux/irqflags.h"
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_softirqs_on(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_softirqs_off(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_hardirqs_on_prepare(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_hardirqs_on(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_hardirqs_off(unsigned long ip) { }
# 27 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/bottom_half.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/bottom_half.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
{
 __preempt_count_add(cnt);
 __asm__ __volatile__("" : : : "memory");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_disable(void)
{
 __local_bh_disable_ip(({ __label__ __here; __here: (unsigned long)&&__here; }), (2 * (1UL << (0 + 8))));
}

extern void _local_bh_enable(void);
extern void __local_bh_enable_ip(unsigned long ip, unsigned int cnt);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_enable_ip(unsigned long ip)
{
 __local_bh_enable_ip(ip, (2 * (1UL << (0 + 8))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_enable(void)
{
 __local_bh_enable_ip(({ __label__ __here; __here: (unsigned long)&&__here; }), (2 * (1UL << (0 + 8))));
}
# 29 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 2
# 38 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
void call_rcu(struct callback_head *head, rcu_callback_t func);
void rcu_barrier_tasks(void);
void rcu_barrier_tasks_rude(void);
void synchronize_rcu(void);
# 58 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __rcu_read_lock(void)
{
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __rcu_read_unlock(void)
{
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_preempt_depth(void)
{
 return 0;
}




void rcu_init(void);
extern int rcu_scheduler_active __attribute__((__section__(".data..read_mostly")));
void rcu_sched_clock_irq(int user);
void rcu_report_dead(unsigned int cpu);
void rcutree_migrate_callbacks(int cpu);


void rcu_sysrq_start(void);
void rcu_sysrq_end(void);






void rcu_user_enter(void);
void rcu_user_exit(void);






void rcu_init_nohz(void);
# 141 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
void call_rcu_tasks(struct callback_head *head, rcu_callback_t func);
void synchronize_rcu_tasks(void);
# 169 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
void call_rcu_tasks_rude(struct callback_head *head, rcu_callback_t func);
void synchronize_rcu_tasks_rude(void);



void exit_tasks_rcu_start(void);
void exit_tasks_rcu_finish(void);
# 204 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
# 1 "/home/nathan/src/linux-next/include/linux/rcutree.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/rcutree.h"
void rcu_softirq_qs(void);
void rcu_note_context_switch(bool preempt);
int rcu_needs_cpu(u64 basem, u64 *nextevt);
void rcu_cpu_stall_reset(void);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_virt_note_context_switch(int cpu)
{
 rcu_note_context_switch(false);
}

void synchronize_rcu_expedited(void);
void kfree_call_rcu(struct callback_head *head, rcu_callback_t func);

void rcu_barrier(void);
bool rcu_eqs_special_set(int cpu);
void rcu_momentary_dyntick_idle(void);
void kfree_rcu_scheduler_running(void);
bool rcu_gp_might_be_stalled(void);
unsigned long get_state_synchronize_rcu(void);
void cond_synchronize_rcu(unsigned long oldstate);

void rcu_idle_enter(void);
void rcu_idle_exit(void);
void rcu_irq_enter(void);
void rcu_irq_exit(void);
void rcu_irq_exit_preempt(void);
void rcu_irq_enter_irqson(void);
void rcu_irq_exit_irqson(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_irq_exit_check_preempt(void) { }


void exit_rcu(void);

void rcu_scheduler_starting(void);
extern int rcu_scheduler_active __attribute__((__section__(".data..read_mostly")));
void rcu_end_inkernel_boot(void);
bool rcu_inkernel_boot_has_ended(void);
bool rcu_is_watching(void);
bool __rcu_is_watching(void);

void rcu_all_qs(void);



int rcutree_prepare_cpu(unsigned int cpu);
int rcutree_online_cpu(unsigned int cpu);
int rcutree_offline_cpu(unsigned int cpu);
int rcutree_dead_cpu(unsigned int cpu);
int rcutree_dying_cpu(unsigned int cpu);
void rcu_cpu_starting(unsigned int cpu);
# 205 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 2
# 225 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_rcu_head(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_rcu_head(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_rcu_head_on_stack(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_rcu_head_on_stack(struct callback_head *head) { }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rcu_lockdep_current_cpu_online(void) { return true; }
# 264 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_held(void)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_bh_held(void)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_sched_held(void)
{
 return !0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_any_held(void)
{
 return !0;
}
# 630 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void rcu_read_lock(void)
{
 __rcu_read_lock();
 (void)0;
 do { } while (0);
 do { } while (0);

}
# 682 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock(void)
{
 do { } while (0);

 (void)0;
 __rcu_read_unlock();
 do { } while (0);
}
# 703 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_bh(void)
{
 local_bh_disable();
 (void)0;
 do { } while (0);
 do { } while (0);

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_bh(void)
{
 do { } while (0);

 do { } while (0);
 (void)0;
 local_bh_enable();
}
# 738 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_sched(void)
{
 __asm__ __volatile__("" : : : "memory");
 (void)0;
 do { } while (0);
 do { } while (0);

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_sched_notrace(void)
{
 __asm__ __volatile__("" : : : "memory");
 (void)0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_sched(void)
{
 do { } while (0);

 do { } while (0);
 (void)0;
 __asm__ __volatile__("" : : : "memory");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_sched_notrace(void)
{
 (void)0;
 __asm__ __volatile__("" : : : "memory");
}
# 903 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_head_init(struct callback_head *rhp)
{
 rhp->func = (rcu_callback_t)~0L;
}
# 921 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
rcu_head_after_call_rcu(struct callback_head *rhp, rcu_callback_t f)
{
 rcu_callback_t func = ({ do { extern void __compiletime_assert_38(void) ; if (!((sizeof(rhp->func) == sizeof(char) || sizeof(rhp->func) == sizeof(short) || sizeof(rhp->func) == sizeof(int) || sizeof(rhp->func) == sizeof(long)) || sizeof(rhp->func) == sizeof(long long))) __compiletime_assert_38(); } while (0); ({ typeof( _Generic((rhp->func), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (rhp->func))) __x = (*(const volatile typeof( _Generic((rhp->func), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (rhp->func))) *)&(rhp->func)); do { } while (0); (typeof(rhp->func))__x; }); });

 if (func == f)
  return true;
 ({ int __ret_warn_on = !!(func != (rcu_callback_t)~0L); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rcupdate.h"), "i" (928), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return false;
}


extern int rcu_expedited;
extern int rcu_normal;
# 21 "/home/nathan/src/linux-next/include/linux/srcu.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/workqueue.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/timer.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/ktime.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/ktime.h"
# 1 "/home/nathan/src/linux-next/include/linux/time.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/seqlock.h" 1
# 36 "/home/nathan/src/linux-next/include/linux/seqlock.h"
# 1 "/home/nathan/src/linux-next/include/linux/spinlock.h" 1
# 60 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/mmiowb.h" 1
# 35 "/home/nathan/src/linux-next/include/asm-generic/mmiowb.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_set_pending(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);
 ms->mmiowb_pending = ms->nesting_count;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_spin_lock(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);
 ms->nesting_count++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_spin_unlock(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);

 if (__builtin_expect(!!(ms->mmiowb_pending), 0)) {
  ms->mmiowb_pending = 0;
  __asm__ __volatile__ ("sync" : : : "memory");
 }

 ms->nesting_count--;
}
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h" 2
# 61 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2
# 89 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h" 1
# 403 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall_norets(unsigned long opcode, ...);
# 416 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall(unsigned long opcode, unsigned long *retbuf, ...);
# 430 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall_raw(unsigned long opcode, unsigned long *retbuf, ...);
# 441 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall9(unsigned long opcode, unsigned long *retbuf, ...);
long plpar_hcall9_raw(unsigned long opcode, unsigned long *retbuf, ...);

struct hvcall_mpp_data {
 unsigned long entitled_mem;
 unsigned long mapped_mem;
 unsigned short group_num;
 unsigned short pool_num;
 unsigned char mem_weight;
 unsigned char unallocated_mem_weight;
 unsigned long unallocated_entitlement;
 unsigned long pool_size;
 signed long loan_request;
 unsigned long backing_mem;
};

int h_get_mpp(struct hvcall_mpp_data *);

struct hvcall_mpp_x_data {
 unsigned long coalesced_bytes;
 unsigned long pool_coalesced_bytes;
 unsigned long pool_purr_cycles;
 unsigned long pool_spurr_cycles;
 unsigned long reserved[3];
};

int h_get_mpp_x(struct hvcall_mpp_x_data *mpp_x_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int get_longbusy_msecs(int longbusy_rc)
{
 switch (longbusy_rc) {
 case 9900:
  return 1;
 case 9901:
  return 10;
 case 9902:
  return 100;
 case 9903:
  return 1000;
 case 9904:
  return 10000;
 case 9905:
  return 100000;
 default:
  return 1;
 }
}

struct h_cpu_char_result {
 u64 character;
 u64 behaviour;
};


struct hv_guest_state {
 u64 version;
 u32 lpid;
 u32 vcpu_token;

 u64 lpcr;
 u64 pcr;
 u64 amor;
 u64 dpdes;
 u64 hfscr;
 s64 tb_offset;
 u64 dawr0;
 u64 dawrx0;
 u64 ciabr;
 u64 hdec_expiry;
 u64 purr;
 u64 spurr;
 u64 ic;
 u64 vtb;
 u64 hdar;
 u64 hdsisr;
 u64 heir;
 u64 asdr;

 u64 srr0;
 u64 srr1;
 u64 sprg[4];
 u64 pidr;
 u64 cfar;
 u64 ppr;
};
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h" 2
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
extern struct static_key_false shared_processor;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vcpu_is_preempted(int cpu)
{
 if (!({ bool branch; if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_true)) branch = arch_static_branch_jump(&(&shared_processor)->key, false); else if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_false)) branch = arch_static_branch(&(&shared_processor)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }))
  return false;
 return !!((__builtin_constant_p((__u32)(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count))) ? ((__u32)( (((__u32)(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count))) & 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int arch_spin_value_unlocked(arch_spinlock_t lock)
{
 return lock.slock == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_spin_is_locked(arch_spinlock_t *lock)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 return !arch_spin_value_unlocked(*lock);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __arch_spin_trylock(arch_spinlock_t *lock)
{
 unsigned long tmp, token;

 token = (*(u32 *)(&local_paca->paca_index));
 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%2) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n	cmpwi		0,%0,0\n	bne-		2f\n	stwcx.		%1,0,%2\n	bne-		1b\n"




 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:"
 : "=&r" (tmp)
 : "r" (token), "r" (&lock->slock)
 : "cr0", "memory");

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_spin_trylock(arch_spinlock_t *lock)
{
 return __arch_spin_trylock(lock) == 0;
}
# 106 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
void splpar_spin_yield(arch_spinlock_t *lock);
void splpar_rw_yield(arch_rwlock_t *lock);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_shared_processor(void)
{

 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_true)) branch = arch_static_branch_jump(&(&shared_processor)->key, false); else if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_false)) branch = arch_static_branch(&(&shared_processor)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); });



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void spin_yield(arch_spinlock_t *lock)
{
 if (is_shared_processor())
  splpar_spin_yield(lock);
 else
  __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rw_yield(arch_rwlock_t *lock)
{
 if (is_shared_processor())
  splpar_rw_yield(lock);
 else
  __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_spin_lock(arch_spinlock_t *lock)
{
 while (1) {
  if (__builtin_expect(!!(__arch_spin_trylock(lock) == 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_spin_yield(lock);
  } while (__builtin_expect(!!(lock->slock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void arch_spin_lock_flags(arch_spinlock_t *lock, unsigned long flags)
{
 unsigned long flags_dis;

 while (1) {
  if (__builtin_expect(!!(__arch_spin_trylock(lock) == 0), 1))
   break;
  do { ({ unsigned long __dummy; typeof(flags_dis) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags_dis = arch_local_save_flags(); } while (0);
  do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_spin_yield(lock);
  } while (__builtin_expect(!!(lock->slock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
  do { do { ({ unsigned long __dummy; typeof(flags_dis) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags_dis); } while (0); } while (0);
 }
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_spin_unlock(arch_spinlock_t *lock)
{
 __asm__ __volatile__("# arch_spin_unlock\n\t"
    "lwsync" " " "\n": : :"memory");
 lock->slock = 0;
}
# 203 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __arch_read_trylock(arch_rwlock_t *rw)
{
 long tmp;

 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%1) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n"
 "extsw	%0,%0\n"
"	addic.		%0,%0,1\n	ble-		2f\n"

"	stwcx.		%0,0,%1\n	bne-		1b\n"

 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:" : "=&r" (tmp)
 : "r" (&rw->lock)
 : "cr0", "xer", "memory");

 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __arch_write_trylock(arch_rwlock_t *rw)
{
 long tmp, token;

 token = (*(u32 *)(&local_paca->paca_index));
 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%2) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n	cmpwi		0,%0,0\n	bne-		2f\n"


"	stwcx.		%1,0,%2\n	bne-		1b\n"

 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:" : "=&r" (tmp)
 : "r" (token), "r" (&rw->lock)
 : "cr0", "memory");

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_read_lock(arch_rwlock_t *rw)
{
 while (1) {
  if (__builtin_expect(!!(__arch_read_trylock(rw) > 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_rw_yield(rw);
  } while (__builtin_expect(!!(rw->lock < 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_write_lock(arch_rwlock_t *rw)
{
 while (1) {
  if (__builtin_expect(!!(__arch_write_trylock(rw) == 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_rw_yield(rw);
  } while (__builtin_expect(!!(rw->lock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_read_trylock(arch_rwlock_t *rw)
{
 return __arch_read_trylock(rw) > 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_write_trylock(arch_rwlock_t *rw)
{
 return __arch_write_trylock(rw) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_read_unlock(arch_rwlock_t *rw)
{
 long tmp;

 __asm__ __volatile__(
 "# read_unlock\n\t"
 "lwsync" " " "\n"
"1:	lwarx		%0,0,%1\n	addic		%0,%0,-1\n"

"	stwcx.		%0,0,%1\n	bne-		1b"

 : "=&r"(tmp)
 : "r"(&rw->lock)
 : "cr0", "xer", "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_write_unlock(arch_rwlock_t *rw)
{
 __asm__ __volatile__("# write_unlock\n\t"
    "lwsync" " " "\n": : :"memory");
 rw->lock = 0;
}
# 90 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2
# 179 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_raw_spin_lock(raw_spinlock_t *lock)
{
 (void)0;
 arch_spin_lock(&lock->raw_lock);
 mmiowb_spin_lock();
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
do_raw_spin_lock_flags(raw_spinlock_t *lock, unsigned long *flags)
{
 (void)0;
 arch_spin_lock_flags(&lock->raw_lock, *flags);
 mmiowb_spin_lock();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int do_raw_spin_trylock(raw_spinlock_t *lock)
{
 int ret = arch_spin_trylock(&(lock)->raw_lock);

 if (ret)
  mmiowb_spin_lock();

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_raw_spin_unlock(raw_spinlock_t *lock)
{
 mmiowb_spin_unlock();
 arch_spin_unlock(&lock->raw_lock);
 (void)0;
}
# 311 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/include/linux/rwlock.h" 1
# 312 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
int in_lock_functions(unsigned long addr);



void __attribute__((section(".spinlock.text"))) _raw_spin_lock(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)
                        ;
void __attribute__((section(".spinlock.text")))
_raw_spin_lock_nest_lock(raw_spinlock_t *lock, struct lockdep_map *map)
                        ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_bh(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_irq(raw_spinlock_t *lock)
                        ;

unsigned long __attribute__((section(".spinlock.text"))) _raw_spin_lock_irqsave(raw_spinlock_t *lock)
                        ;
unsigned long __attribute__((section(".spinlock.text")))
_raw_spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass)
                        ;
int __attribute__((section(".spinlock.text"))) _raw_spin_trylock(raw_spinlock_t *lock);
int __attribute__((section(".spinlock.text"))) _raw_spin_trylock_bh(raw_spinlock_t *lock);
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock_bh(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock_irq(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text")))
_raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)
                        ;
# 86 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_spin_trylock(raw_spinlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (do_raw_spin_trylock(lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}
# 104 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
# 119 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
 do_raw_spin_lock_flags(lock, &flags);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock_irq(raw_spinlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do_raw_spin_lock(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock_bh(raw_spinlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do_raw_spin_lock(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock(raw_spinlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do_raw_spin_lock(lock);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,
         unsigned long flags)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_irq(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_bh(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_spin_trylock_bh(raw_spinlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 if (do_raw_spin_trylock(lock)) {
  do { } while (0);
  return 1;
 }
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 return 0;
}


# 1 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
void __attribute__((section(".spinlock.text"))) _raw_read_lock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_lock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_lock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock_irq(rwlock_t *lock) ;
unsigned long __attribute__((section(".spinlock.text"))) _raw_read_lock_irqsave(rwlock_t *lock)
                       ;
unsigned long __attribute__((section(".spinlock.text"))) _raw_write_lock_irqsave(rwlock_t *lock)
                       ;
int __attribute__((section(".spinlock.text"))) _raw_read_trylock(rwlock_t *lock);
int __attribute__((section(".spinlock.text"))) _raw_write_trylock(rwlock_t *lock);
void __attribute__((section(".spinlock.text"))) _raw_read_unlock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_unlock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_unlock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text")))
_raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
                       ;
void __attribute__((section(".spinlock.text")))
_raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
                       ;
# 117 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_read_trylock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (arch_read_trylock(&(lock)->raw_lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_write_trylock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (arch_write_trylock(&(lock)->raw_lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}
# 146 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_read_lock_irqsave(rwlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&((lock))->raw_lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock_irq(rwlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock_bh(rwlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_write_lock_irqsave(rwlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&((lock))->raw_lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock_irq(rwlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock_bh(rwlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock_irq(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock_bh(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_irqrestore(rwlock_t *lock,
          unsigned long flags)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_irq(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_bh(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}
# 191 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h" 2
# 318 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
 return &lock->rlock;
}
# 351 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock(spinlock_t *lock)
{
 _raw_spin_lock(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock_bh(spinlock_t *lock)
{
 _raw_spin_lock_bh(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock(spinlock_t *lock)
{
 return (_raw_spin_trylock(&lock->rlock));
}
# 376 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock_irq(spinlock_t *lock)
{
 _raw_spin_lock_irq(&lock->rlock);
}
# 391 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock(spinlock_t *lock)
{
 __raw_spin_unlock(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_bh(spinlock_t *lock)
{
 _raw_spin_unlock_bh(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_irq(spinlock_t *lock)
{
 __raw_spin_unlock_irq(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
 do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); _raw_spin_unlock_irqrestore(&lock->rlock, flags); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock_bh(spinlock_t *lock)
{
 return (_raw_spin_trylock_bh(&lock->rlock));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock_irq(spinlock_t *lock)
{
 return ({ do { arch_local_irq_disable(); } while (0); (_raw_spin_trylock(&lock->rlock)) ? 1 : ({ do { arch_local_irq_enable(); } while (0); 0; }); });
}
# 444 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_is_locked(spinlock_t *lock)
{
 return arch_spin_is_locked(&(&lock->rlock)->raw_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_is_contended(spinlock_t *lock)
{
 return (((void)(&lock->rlock), 0));
}
# 469 "/home/nathan/src/linux-next/include/linux/spinlock.h"
extern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);



extern int _atomic_dec_and_lock_irqsave(atomic_t *atomic, spinlock_t *lock,
     unsigned long *flags);



int __alloc_bucket_spinlocks(spinlock_t **locks, unsigned int *lock_mask,
        size_t max_size, unsigned int cpu_mult,
        gfp_t gfp, const char *name,
        struct lock_class_key *key);
# 493 "/home/nathan/src/linux-next/include/linux/spinlock.h"
void free_bucket_spinlocks(spinlock_t *locks);
# 37 "/home/nathan/src/linux-next/include/linux/seqlock.h" 2
# 64 "/home/nathan/src/linux-next/include/linux/seqlock.h"
typedef struct seqcount {
 unsigned sequence;



} seqcount_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __seqcount_init(seqcount_t *s, const char *name,
       struct lock_class_key *key)
{



 do { (void)(name); (void)(key); } while (0);
 s->sequence = 0;
}
# 124 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned __read_seqcount_begin(const seqcount_t *s)
{
 unsigned ret;

repeat:
 ret = ({ do { extern void __compiletime_assert_39(void) ; if (!((sizeof(s->sequence) == sizeof(char) || sizeof(s->sequence) == sizeof(short) || sizeof(s->sequence) == sizeof(int) || sizeof(s->sequence) == sizeof(long)) || sizeof(s->sequence) == sizeof(long long))) __compiletime_assert_39(); } while (0); ({ typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) __x = (*(const volatile typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) *)&(s->sequence)); do { } while (0); (typeof(s->sequence))__x; }); });
 if (__builtin_expect(!!(ret & 1), 0)) {
  do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
  goto repeat;
 }
 kcsan_atomic_next(1000);
 return ret;
}
# 147 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_read_seqcount(const seqcount_t *s)
{
 unsigned ret = ({ do { extern void __compiletime_assert_40(void) ; if (!((sizeof(s->sequence) == sizeof(char) || sizeof(s->sequence) == sizeof(short) || sizeof(s->sequence) == sizeof(int) || sizeof(s->sequence) == sizeof(long)) || sizeof(s->sequence) == sizeof(long long))) __compiletime_assert_40(); } while (0); ({ typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) __x = (*(const volatile typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) *)&(s->sequence)); do { } while (0); (typeof(s->sequence))__x; }); });
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 kcsan_atomic_next(1000);
 return ret;
}
# 164 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_read_seqcount_begin(const seqcount_t *s)
{
 unsigned ret = __read_seqcount_begin(s);
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return ret;
}
# 180 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqcount_begin(const seqcount_t *s)
{
                                  ;
 return raw_read_seqcount_begin(s);
}
# 200 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_seqcount_begin(const seqcount_t *s)
{
 unsigned ret = ({ do { extern void __compiletime_assert_41(void) ; if (!((sizeof(s->sequence) == sizeof(char) || sizeof(s->sequence) == sizeof(short) || sizeof(s->sequence) == sizeof(int) || sizeof(s->sequence) == sizeof(long)) || sizeof(s->sequence) == sizeof(long long))) __compiletime_assert_41(); } while (0); ({ typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) __x = (*(const volatile typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) *)&(s->sequence)); do { } while (0); (typeof(s->sequence))__x; }); });
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 kcsan_atomic_next(1000);
 return ret & ~1;
}
# 222 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __read_seqcount_retry(const seqcount_t *s, unsigned start)
{
 kcsan_atomic_next(0);
 return __builtin_expect(!!(({ do { extern void __compiletime_assert_42(void) ; if (!((sizeof(s->sequence) == sizeof(char) || sizeof(s->sequence) == sizeof(short) || sizeof(s->sequence) == sizeof(int) || sizeof(s->sequence) == sizeof(long)) || sizeof(s->sequence) == sizeof(long long))) __compiletime_assert_42(); } while (0); ({ typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) __x = (*(const volatile typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) *)&(s->sequence)); do { } while (0); (typeof(s->sequence))__x; }); }) != start), 0);
}
# 238 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int read_seqcount_retry(const seqcount_t *s, unsigned start)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return __read_seqcount_retry(s, start);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_begin(seqcount_t *s)
{
 kcsan_nestable_atomic_begin();
 s->sequence++;
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_end(seqcount_t *s)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 s->sequence++;
 kcsan_nestable_atomic_end();
}
# 301 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_barrier(seqcount_t *s)
{
 kcsan_nestable_atomic_begin();
 s->sequence++;
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 s->sequence++;
 kcsan_nestable_atomic_end();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int raw_read_seqcount_latch(seqcount_t *s)
{

 int seq = ({ do { extern void __compiletime_assert_43(void) ; if (!((sizeof(s->sequence) == sizeof(char) || sizeof(s->sequence) == sizeof(short) || sizeof(s->sequence) == sizeof(int) || sizeof(s->sequence) == sizeof(long)) || sizeof(s->sequence) == sizeof(long long))) __compiletime_assert_43(); } while (0); ({ typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) __x = (*(const volatile typeof( _Generic((s->sequence), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (s->sequence))) *)&(s->sequence)); do { } while (0); (typeof(s->sequence))__x; }); });
 return seq;
}
# 394 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_latch(seqcount_t *s)
{
       __asm__ __volatile__ ("lwsync" " " : : :"memory");
       s->sequence++;
       __asm__ __volatile__ ("lwsync" " " : : :"memory");
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_begin_nested(seqcount_t *s, int subclass)
{
 raw_write_seqcount_begin(s);
 do { } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_begin(seqcount_t *s)
{
 write_seqcount_begin_nested(s, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_end(seqcount_t *s)
{
 do { } while (0);
 raw_write_seqcount_end(s);
}
# 429 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_invalidate(seqcount_t *s)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 kcsan_nestable_atomic_begin();
 s->sequence+=2;
 kcsan_nestable_atomic_end();
}

typedef struct {
 struct seqcount seqcount;
 spinlock_t lock;
} seqlock_t;
# 464 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqbegin(const seqlock_t *sl)
{
 unsigned ret = read_seqcount_begin(&sl->seqcount);

 kcsan_atomic_next(0);
 kcsan_flat_atomic_begin();
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqretry(const seqlock_t *sl, unsigned start)
{




 kcsan_flat_atomic_end();

 return read_seqcount_retry(&sl->seqcount, start);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock(seqlock_t *sl)
{
 spin_lock(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock_bh(seqlock_t *sl)
{
 spin_lock_bh(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock_bh(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock_irq(seqlock_t *sl)
{
 spin_lock_irq(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock_irq(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __write_seqlock_irqsave(seqlock_t *sl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(spinlock_check(&sl->lock)); } while (0); } while (0);
 write_seqcount_begin(&sl->seqcount);
 return flags;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
write_sequnlock_irqrestore(seqlock_t *sl, unsigned long flags)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_irqrestore(&sl->lock, flags);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl(seqlock_t *sl)
{
 spin_lock(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl(seqlock_t *sl)
{
 spin_unlock(&sl->lock);
}
# 569 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqbegin_or_lock(seqlock_t *lock, int *seq)
{
 if (!(*seq & 1))
  *seq = read_seqbegin(lock);
 else
  read_seqlock_excl(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int need_seqretry(seqlock_t *lock, int seq)
{
 return !(seq & 1) && read_seqretry(lock, seq);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void done_seqretry(seqlock_t *lock, int seq)
{
 if (seq & 1)
  read_sequnlock_excl(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl_bh(seqlock_t *sl)
{
 spin_lock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl_bh(seqlock_t *sl)
{
 spin_unlock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl_irq(seqlock_t *sl)
{
 spin_lock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl_irq(seqlock_t *sl)
{
 spin_unlock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __read_seqlock_excl_irqsave(seqlock_t *sl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(spinlock_check(&sl->lock)); } while (0); } while (0);
 return flags;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
read_sequnlock_excl_irqrestore(seqlock_t *sl, unsigned long flags)
{
 spin_unlock_irqrestore(&sl->lock, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
read_seqbegin_or_lock_irqsave(seqlock_t *lock, int *seq)
{
 unsigned long flags = 0;

 if (!(*seq & 1))
  *seq = read_seqbegin(lock);
 else
  do { flags = __read_seqlock_excl_irqsave(lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
done_seqretry_irqrestore(seqlock_t *lock, int seq, unsigned long flags)
{
 if (seq & 1)
  read_sequnlock_excl_irqrestore(lock, flags);
}
# 7 "/home/nathan/src/linux-next/include/linux/time.h" 2



extern struct timezone sys_tz;

int get_timespec64(struct timespec64 *ts,
  const struct __kernel_timespec *uts);
int put_timespec64(const struct timespec64 *ts,
  struct __kernel_timespec *uts);
int get_itimerspec64(struct itimerspec64 *it,
   const struct __kernel_itimerspec *uit);
int put_itimerspec64(const struct itimerspec64 *it,
   struct __kernel_itimerspec *uit);

extern time64_t mktime64(const unsigned int year, const unsigned int mon,
   const unsigned int day, const unsigned int hour,
   const unsigned int min, const unsigned int sec);
# 39 "/home/nathan/src/linux-next/include/linux/time.h"
extern void clear_itimer(void);




extern long do_utimes(int dfd, const char *filename, struct timespec64 *times, int flags);





struct tm {




 int tm_sec;

 int tm_min;

 int tm_hour;

 int tm_mday;

 int tm_mon;

 long tm_year;

 int tm_wday;

 int tm_yday;
};

void time64_to_tm(time64_t totalsecs, int offset, struct tm *result);


# 1 "/home/nathan/src/linux-next/include/linux/time32.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/time32.h"
# 1 "/home/nathan/src/linux-next/include/linux/timex.h" 1
# 56 "/home/nathan/src/linux-next/include/linux/timex.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/timex.h" 1
# 56 "/home/nathan/src/linux-next/include/uapi/linux/timex.h"
# 1 "/home/nathan/src/linux-next/include/linux/time.h" 1
# 57 "/home/nathan/src/linux-next/include/uapi/linux/timex.h" 2
# 97 "/home/nathan/src/linux-next/include/uapi/linux/timex.h"
struct __kernel_timex_timeval {
 __kernel_time64_t tv_sec;
 long long tv_usec;
};

struct __kernel_timex {
 unsigned int modes;
 int :32;
 long long offset;
 long long freq;
 long long maxerror;
 long long esterror;
 int status;
 int :32;
 long long constant;
 long long precision;
 long long tolerance;


 struct __kernel_timex_timeval time;
 long long tick;

 long long ppsfreq;
 long long jitter;
 int shift;
 int :32;
 long long stabil;
 long long jitcnt;
 long long calcnt;
 long long errcnt;
 long long stbcnt;

 int tai;

 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32;
};
# 57 "/home/nathan/src/linux-next/include/linux/timex.h" 2






# 1 "/home/nathan/src/linux-next/include/uapi/linux/param.h" 1




# 1 "./arch/powerpc/include/generated/uapi/asm/param.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/param.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/param.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/param.h" 2
# 2 "./arch/powerpc/include/generated/uapi/asm/param.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/param.h" 2
# 64 "/home/nathan/src/linux-next/include/linux/timex.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/timex.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/timex.h"
typedef unsigned long cycles_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) cycles_t get_cycles(void)
{
 if (0)
  return 0;

 return ({unsigned long rval; asm volatile("mfspr %0, %1" : "=r" (rval) : "i" (0x10C)); rval;});
}
# 66 "/home/nathan/src/linux-next/include/linux/timex.h" 2
# 139 "/home/nathan/src/linux-next/include/linux/timex.h"
extern unsigned long tick_usec;
extern unsigned long tick_nsec;
# 154 "/home/nathan/src/linux-next/include/linux/timex.h"
extern int do_adjtimex(struct __kernel_timex *);
extern int do_clock_adjtime(const clockid_t which_clock, struct __kernel_timex * ktx);

extern void hardpps(const struct timespec64 *, const struct timespec64 *);

int read_current_timer(unsigned long *timer_val);
void ntp_notify_cmos_timer(void);
# 14 "/home/nathan/src/linux-next/include/linux/time32.h" 2

# 1 "/home/nathan/src/linux-next/include/vdso/time32.h" 1




typedef s32 old_time32_t;

struct old_timespec32 {
 old_time32_t tv_sec;
 s32 tv_nsec;
};

struct old_timeval32 {
 old_time32_t tv_sec;
 s32 tv_usec;
};
# 16 "/home/nathan/src/linux-next/include/linux/time32.h" 2

struct old_itimerspec32 {
 struct old_timespec32 it_interval;
 struct old_timespec32 it_value;
};

struct old_utimbuf32 {
 old_time32_t actime;
 old_time32_t modtime;
};

struct old_timex32 {
 u32 modes;
 s32 offset;
 s32 freq;
 s32 maxerror;
 s32 esterror;
 s32 status;
 s32 constant;
 s32 precision;
 s32 tolerance;
 struct old_timeval32 time;
 s32 tick;
 s32 ppsfreq;
 s32 jitter;
 s32 shift;
 s32 stabil;
 s32 jitcnt;
 s32 calcnt;
 s32 errcnt;
 s32 stbcnt;
 s32 tai;

 s32:32; s32:32; s32:32; s32:32;
 s32:32; s32:32; s32:32; s32:32;
 s32:32; s32:32; s32:32;
};

extern int get_old_timespec32(struct timespec64 *, const void *);
extern int put_old_timespec32(const struct timespec64 *, void *);
extern int get_old_itimerspec32(struct itimerspec64 *its,
   const struct old_itimerspec32 *uits);
extern int put_old_itimerspec32(const struct itimerspec64 *its,
   struct old_itimerspec32 *uits);
struct __kernel_timex;
int get_old_timex32(struct __kernel_timex *, const struct old_timex32 *);
int put_old_timex32(struct old_timex32 *, const struct __kernel_timex *);







extern struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec);
# 75 "/home/nathan/src/linux-next/include/linux/time.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool itimerspec64_valid(const struct itimerspec64 *its)
{
 if (!timespec64_valid(&(its->it_interval)) ||
  !timespec64_valid(&(its->it_value)))
  return false;

 return true;
}
# 114 "/home/nathan/src/linux-next/include/linux/time.h"
# 1 "/home/nathan/src/linux-next/include/vdso/time.h" 1






struct timens_offset {
 s64 sec;
 u64 nsec;
};
# 115 "/home/nathan/src/linux-next/include/linux/time.h" 2
# 25 "/home/nathan/src/linux-next/include/linux/ktime.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/jiffies.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/jiffies.h"
# 1 "/home/nathan/src/linux-next/include/vdso/jiffies.h" 1




# 1 "./arch/powerpc/include/generated/uapi/asm/param.h" 1
# 6 "/home/nathan/src/linux-next/include/vdso/jiffies.h" 2
# 12 "/home/nathan/src/linux-next/include/linux/jiffies.h" 2
# 1 "./arch/powerpc/include/generated/uapi/asm/param.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/jiffies.h" 2
# 1 "./include/generated/timeconst.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/jiffies.h" 2
# 61 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern int register_refined_jiffies(long clock_tick_rate);
# 78 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern u64 __attribute__((__aligned__((1 << 7)), __section__(".data..cacheline_aligned"))) jiffies_64;
extern unsigned long volatile __attribute__((__aligned__((1 << 7)), __section__(".data..cacheline_aligned"))) jiffies;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_jiffies_64(void)
{
 return (u64)jiffies;
}
# 188 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern unsigned long preset_lpj;
# 289 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(const unsigned long j);
extern unsigned int jiffies_to_usecs(const unsigned long j);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 jiffies_to_nsecs(const unsigned long j)
{
 return (u64)jiffies_to_usecs(j) * 1000L;
}

extern u64 jiffies64_to_nsecs(u64 j);
extern u64 jiffies64_to_msecs(u64 j);

extern unsigned long __msecs_to_jiffies(const unsigned int m);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long _msecs_to_jiffies(const unsigned int m)
{
 return (m + (1000L / 100) - 1) / (1000L / 100);
}
# 362 "/home/nathan/src/linux-next/include/linux/jiffies.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long msecs_to_jiffies(const unsigned int m)
{
 if (__builtin_constant_p(m)) {
  if ((int)m < 0)
   return ((((long)(~0UL >> 1)) >> 1)-1);
  return _msecs_to_jiffies(m);
 } else {
  return __msecs_to_jiffies(m);
 }
}

extern unsigned long __usecs_to_jiffies(const unsigned int u);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long _usecs_to_jiffies(const unsigned int u)
{
 return (u + (1000000L / 100) - 1) / (1000000L / 100);
}
# 409 "/home/nathan/src/linux-next/include/linux/jiffies.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long usecs_to_jiffies(const unsigned int u)
{
 if (__builtin_constant_p(u)) {
  if (u > jiffies_to_usecs(((((long)(~0UL >> 1)) >> 1)-1)))
   return ((((long)(~0UL >> 1)) >> 1)-1);
  return _usecs_to_jiffies(u);
 } else {
  return __usecs_to_jiffies(u);
 }
}

extern unsigned long timespec64_to_jiffies(const struct timespec64 *value);
extern void jiffies_to_timespec64(const unsigned long jiffies,
      struct timespec64 *value);
extern clock_t jiffies_to_clock_t(unsigned long x);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clock_t jiffies_delta_to_clock_t(long delta)
{
 return jiffies_to_clock_t(__builtin_choose_expr(((!!(sizeof((typeof(0L) *)1 == (typeof(delta) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(0L) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(delta) * 0l)) : (int *)8))))), ((0L) > (delta) ? (0L) : (delta)), ({ typeof(0L) __UNIQUE_ID___x44 = (0L); typeof(delta) __UNIQUE_ID___y45 = (delta); ((__UNIQUE_ID___x44) > (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int jiffies_delta_to_msecs(long delta)
{
 return jiffies_to_msecs(__builtin_choose_expr(((!!(sizeof((typeof(0L) *)1 == (typeof(delta) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(0L) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(delta) * 0l)) : (int *)8))))), ((0L) > (delta) ? (0L) : (delta)), ({ typeof(0L) __UNIQUE_ID___x46 = (0L); typeof(delta) __UNIQUE_ID___y47 = (delta); ((__UNIQUE_ID___x46) > (__UNIQUE_ID___y47) ? (__UNIQUE_ID___x46) : (__UNIQUE_ID___y47)); })));
}

extern unsigned long clock_t_to_jiffies(unsigned long x);
extern u64 jiffies_64_to_clock_t(u64 x);
extern u64 nsec_to_clock_t(u64 x);
extern u64 nsecs_to_jiffies64(u64 n);
extern unsigned long nsecs_to_jiffies(u64 n);
# 26 "/home/nathan/src/linux-next/include/linux/ktime.h" 2


typedef s64 ktime_t;
# 37 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_set(const s64 secs, const unsigned long nsecs)
{
 if (__builtin_expect(!!(secs >= (((s64)~((u64)1 << 63)) / 1000000000L)), 0))
  return ((s64)~((u64)1 << 63));

 return secs * 1000000000L + (s64)nsecs;
}
# 70 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t timespec64_to_ktime(struct timespec64 ts)
{
 return ktime_set(ts.tv_sec, ts.tv_nsec);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_ns(const ktime_t kt)
{
 return kt;
}
# 94 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ktime_compare(const ktime_t cmp1, const ktime_t cmp2)
{
 if (cmp1 < cmp2)
  return -1;
 if (cmp1 > cmp2)
  return 1;
 return 0;
}
# 110 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ktime_after(const ktime_t cmp1, const ktime_t cmp2)
{
 return ktime_compare(cmp1, cmp2) > 0;
}
# 122 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ktime_before(const ktime_t cmp1, const ktime_t cmp2)
{
 return ktime_compare(cmp1, cmp2) < 0;
}
# 147 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_divns(const ktime_t kt, s64 div)
{




 ({ int __ret_warn_on = !!(div < 0); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/ktime.h"), "i" (153), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/ktime.h"), "i" (153), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return kt / div;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_us(const ktime_t kt)
{
 return ktime_divns(kt, 1000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_ms(const ktime_t kt)
{
 return ktime_divns(kt, 1000000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_us_delta(const ktime_t later, const ktime_t earlier)
{
       return ktime_to_us(((later) - (earlier)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_ms_delta(const ktime_t later, const ktime_t earlier)
{
 return ktime_to_ms(((later) - (earlier)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
 return ((kt) + (usec * 1000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_add_ms(const ktime_t kt, const u64 msec)
{
 return ((kt) + (msec * 1000000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_sub_us(const ktime_t kt, const u64 usec)
{
 return ((kt) - (usec * 1000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_sub_ms(const ktime_t kt, const u64 msec)
{
 return ((kt) - (msec * 1000000L));
}

extern ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs);
# 208 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool ktime_to_timespec64_cond(const ktime_t kt,
             struct timespec64 *ts)
{
 if (kt) {
  *ts = ns_to_timespec64((kt));
  return true;
 } else {
  return false;
 }
}


# 1 "/home/nathan/src/linux-next/include/vdso/ktime.h" 1
# 220 "/home/nathan/src/linux-next/include/linux/ktime.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ns_to_ktime(u64 ns)
{
 return ns;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ms_to_ktime(u64 ms)
{
 return ms * 1000000L;
}


# 1 "/home/nathan/src/linux-next/include/linux/timekeeping.h" 1








void timekeeping_init(void);
extern int timekeeping_suspended;


extern void update_process_times(int user);
extern void xtime_update(unsigned long ticks);




extern int do_settimeofday64(const struct timespec64 *ts);
extern int do_sys_settimeofday64(const struct timespec64 *tv,
     const struct timezone *tz);
# 41 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
extern void ktime_get_raw_ts64(struct timespec64 *ts);
extern void ktime_get_ts64(struct timespec64 *ts);
extern void ktime_get_real_ts64(struct timespec64 *tv);
extern void ktime_get_coarse_ts64(struct timespec64 *ts);
extern void ktime_get_coarse_real_ts64(struct timespec64 *ts);

void getboottime64(struct timespec64 *ts);




extern time64_t ktime_get_seconds(void);
extern time64_t __ktime_get_real_seconds(void);
extern time64_t ktime_get_real_seconds(void);





enum tk_offsets {
 TK_OFFS_REAL,
 TK_OFFS_BOOT,
 TK_OFFS_TAI,
 TK_OFFS_MAX,
};

extern ktime_t ktime_get(void);
extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
extern ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs);
extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
extern ktime_t ktime_get_raw(void);
extern u32 ktime_get_resolution_ns(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_real(void)
{
 return ktime_get_with_offset(TK_OFFS_REAL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_real(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_REAL);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_boottime(void)
{
 return ktime_get_with_offset(TK_OFFS_BOOT);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_boottime(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_BOOT);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_clocktai(void)
{
 return ktime_get_with_offset(TK_OFFS_TAI);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_clocktai(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_TAI);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse(void)
{
 struct timespec64 ts;

 ktime_get_coarse_ts64(&ts);
 return timespec64_to_ktime(ts);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_ns(void)
{
 return ktime_to_ns(ktime_get_coarse());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_real_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_real());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_boottime_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_boottime());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_clocktai_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_clocktai());
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_mono_to_real(ktime_t mono)
{
 return ktime_mono_to_any(mono, TK_OFFS_REAL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_ns(void)
{
 return ktime_to_ns(ktime_get());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_real_ns(void)
{
 return ktime_to_ns(ktime_get_real());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_boottime_ns(void)
{
 return ktime_to_ns(ktime_get_boottime());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_clocktai_ns(void)
{
 return ktime_to_ns(ktime_get_clocktai());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_raw_ns(void)
{
 return ktime_to_ns(ktime_get_raw());
}

extern u64 ktime_get_mono_fast_ns(void);
extern u64 ktime_get_raw_fast_ns(void);
extern u64 ktime_get_boot_fast_ns(void);
extern u64 ktime_get_real_fast_ns(void);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_boottime_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_boottime()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_coarse_boottime_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_coarse_boottime()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) time64_t ktime_get_boottime_seconds(void)
{
 return ktime_divns(ktime_get_coarse_boottime(), 1000000000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_clocktai_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_clocktai()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_coarse_clocktai_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_coarse_clocktai()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) time64_t ktime_get_clocktai_seconds(void)
{
 return ktime_divns(ktime_get_coarse_clocktai(), 1000000000L);
}




extern bool timekeeping_rtc_skipsuspend(void);
extern bool timekeeping_rtc_skipresume(void);

extern void timekeeping_inject_sleeptime64(const struct timespec64 *delta);
# 234 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_time_snapshot {
 u64 cycles;
 ktime_t real;
 ktime_t raw;
 unsigned int clock_was_set_seq;
 u8 cs_was_changed_seq;
};
# 249 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_device_crosststamp {
 ktime_t device;
 ktime_t sys_realtime;
 ktime_t sys_monoraw;
};
# 262 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_counterval_t {
 u64 cycles;
 struct clocksource *cs;
};




extern int get_device_system_crosststamp(
   int (*get_time_fn)(ktime_t *device_time,
    struct system_counterval_t *system_counterval,
    void *ctx),
   void *ctx,
   struct system_time_snapshot *history,
   struct system_device_crosststamp *xtstamp);




extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);




extern int persistent_clock_is_local;

extern void read_persistent_clock64(struct timespec64 *ts);
void read_persistent_wall_and_boot_offset(struct timespec64 *wall_clock,
       struct timespec64 *boot_offset);
extern int update_persistent_clock64(struct timespec64 now);
# 232 "/home/nathan/src/linux-next/include/linux/ktime.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/timekeeping32.h" 1








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_seconds(void)
{
 return ktime_get_real_seconds();
}
# 233 "/home/nathan/src/linux-next/include/linux/ktime.h" 2
# 7 "/home/nathan/src/linux-next/include/linux/timer.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/debugobjects.h" 1







enum debug_obj_state {
 ODEBUG_STATE_NONE,
 ODEBUG_STATE_INIT,
 ODEBUG_STATE_INACTIVE,
 ODEBUG_STATE_ACTIVE,
 ODEBUG_STATE_DESTROYED,
 ODEBUG_STATE_NOTAVAILABLE,
 ODEBUG_STATE_MAX,
};

struct debug_obj_descr;
# 28 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
struct debug_obj {
 struct hlist_node node;
 enum debug_obj_state state;
 unsigned int astate;
 void *object;
 struct debug_obj_descr *descr;
};
# 55 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
struct debug_obj_descr {
 const char *name;
 void *(*debug_hint)(void *addr);
 bool (*is_static_object)(void *addr);
 bool (*fixup_init)(void *addr, enum debug_obj_state state);
 bool (*fixup_activate)(void *addr, enum debug_obj_state state);
 bool (*fixup_destroy)(void *addr, enum debug_obj_state state);
 bool (*fixup_free)(void *addr, enum debug_obj_state state);
 bool (*fixup_assert_init)(void *addr, enum debug_obj_state state);
};
# 88 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_init (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
debug_object_activate (void *addr, struct debug_obj_descr *descr) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_deactivate(void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_destroy (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_free (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_assert_init(void *addr, struct debug_obj_descr *descr) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_objects_early_init(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_objects_mem_init(void) { }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_obj_freed(const void *address, unsigned long size) { }
# 9 "/home/nathan/src/linux-next/include/linux/timer.h" 2


struct timer_list {




 struct hlist_node entry;
 unsigned long expires;
 void (*function)(struct timer_list *);
 u32 flags;




};
# 90 "/home/nathan/src/linux-next/include/linux/timer.h"
void init_timer_key(struct timer_list *timer,
      void (*func)(struct timer_list *), unsigned int flags,
      const char *name, struct lock_class_key *key);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_timer_on_stack_key(struct timer_list *timer,
        void (*func)(struct timer_list *),
        unsigned int flags,
        const char *name,
        struct lock_class_key *key)
{
 init_timer_key(timer, func, flags, name, key);
}
# 149 "/home/nathan/src/linux-next/include/linux/timer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_timer_on_stack(struct timer_list *timer) { }
# 165 "/home/nathan/src/linux-next/include/linux/timer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timer_pending(const struct timer_list * timer)
{
 return !hlist_unhashed_lockless(&timer->entry);
}

extern void add_timer_on(struct timer_list *timer, int cpu);
extern int del_timer(struct timer_list * timer);
extern int mod_timer(struct timer_list *timer, unsigned long expires);
extern int mod_timer_pending(struct timer_list *timer, unsigned long expires);
extern int timer_reduce(struct timer_list *timer, unsigned long expires);







extern void add_timer(struct timer_list *timer);

extern int try_to_del_timer_sync(struct timer_list *timer);


  extern int del_timer_sync(struct timer_list *timer);






extern void init_timers(void);
extern void run_local_timers(void);
struct hrtimer;
extern enum hrtimer_restart it_real_fn(struct hrtimer *);


struct ctl_table;

extern unsigned int sysctl_timer_migration;
int timer_migration_handler(struct ctl_table *table, int write,
       void *buffer, size_t *lenp, loff_t *ppos);


unsigned long __round_jiffies(unsigned long j, int cpu);
unsigned long __round_jiffies_relative(unsigned long j, int cpu);
unsigned long round_jiffies(unsigned long j);
unsigned long round_jiffies_relative(unsigned long j);

unsigned long __round_jiffies_up(unsigned long j, int cpu);
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu);
unsigned long round_jiffies_up(unsigned long j);
unsigned long round_jiffies_up_relative(unsigned long j);


int timers_prepare_cpu(unsigned int cpu);
int timers_dead_cpu(unsigned int cpu);
# 10 "/home/nathan/src/linux-next/include/linux/workqueue.h" 2








struct workqueue_struct;

struct work_struct;
typedef void (*work_func_t)(struct work_struct *work);
void delayed_work_timer_fn(struct timer_list *t);







enum {
 WORK_STRUCT_PENDING_BIT = 0,
 WORK_STRUCT_DELAYED_BIT = 1,
 WORK_STRUCT_PWQ_BIT = 2,
 WORK_STRUCT_LINKED_BIT = 3,




 WORK_STRUCT_COLOR_SHIFT = 4,


 WORK_STRUCT_COLOR_BITS = 4,

 WORK_STRUCT_PENDING = 1 << WORK_STRUCT_PENDING_BIT,
 WORK_STRUCT_DELAYED = 1 << WORK_STRUCT_DELAYED_BIT,
 WORK_STRUCT_PWQ = 1 << WORK_STRUCT_PWQ_BIT,
 WORK_STRUCT_LINKED = 1 << WORK_STRUCT_LINKED_BIT,



 WORK_STRUCT_STATIC = 0,






 WORK_NR_COLORS = (1 << WORK_STRUCT_COLOR_BITS) - 1,
 WORK_NO_COLOR = WORK_NR_COLORS,


 WORK_CPU_UNBOUND = 2048,






 WORK_STRUCT_FLAG_BITS = WORK_STRUCT_COLOR_SHIFT +
      WORK_STRUCT_COLOR_BITS,


 WORK_OFFQ_FLAG_BASE = WORK_STRUCT_COLOR_SHIFT,

 __WORK_OFFQ_CANCELING = WORK_OFFQ_FLAG_BASE,
 WORK_OFFQ_CANCELING = (1 << __WORK_OFFQ_CANCELING),






 WORK_OFFQ_FLAG_BITS = 1,
 WORK_OFFQ_POOL_SHIFT = WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS,
 WORK_OFFQ_LEFT = 64 - WORK_OFFQ_POOL_SHIFT,
 WORK_OFFQ_POOL_BITS = WORK_OFFQ_LEFT <= 31 ? WORK_OFFQ_LEFT : 31,
 WORK_OFFQ_POOL_NONE = (1LU << WORK_OFFQ_POOL_BITS) - 1,


 WORK_STRUCT_FLAG_MASK = (1UL << WORK_STRUCT_FLAG_BITS) - 1,
 WORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,
 WORK_STRUCT_NO_POOL = (unsigned long)WORK_OFFQ_POOL_NONE << WORK_OFFQ_POOL_SHIFT,


 WORK_BUSY_PENDING = 1 << 0,
 WORK_BUSY_RUNNING = 1 << 1,


 WORKER_DESC_LEN = 24,
};

struct work_struct {
 atomic_long_t data;
 struct list_head entry;
 work_func_t func;



};





struct delayed_work {
 struct work_struct work;
 struct timer_list timer;


 struct workqueue_struct *wq;
 int cpu;
};

struct rcu_work {
 struct work_struct work;
 struct callback_head rcu;


 struct workqueue_struct *wq;
};






struct workqueue_attrs {



 int nice;




 cpumask_var_t cpumask;
# 155 "/home/nathan/src/linux-next/include/linux/workqueue.h"
 bool no_numa;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct delayed_work *to_delayed_work(struct work_struct *work)
{
 return ({ void *__mptr = (void *)(work); do { extern void __compiletime_assert_48(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(work)), typeof(((struct delayed_work *)0)->work)) && !__builtin_types_compatible_p(typeof(*(work)), typeof(void))))) __compiletime_assert_48(); } while (0); ((struct delayed_work *)(__mptr - __builtin_offsetof(struct delayed_work, work))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rcu_work *to_rcu_work(struct work_struct *work)
{
 return ({ void *__mptr = (void *)(work); do { extern void __compiletime_assert_49(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(work)), typeof(((struct rcu_work *)0)->work)) && !__builtin_types_compatible_p(typeof(*(work)), typeof(void))))) __compiletime_assert_49(); } while (0); ((struct rcu_work *)(__mptr - __builtin_offsetof(struct rcu_work, work))); });
}

struct execute_work {
 struct work_struct work;
};
# 215 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __init_work(struct work_struct *work, int onstack) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_work_on_stack(struct work_struct *work) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_delayed_work_on_stack(struct delayed_work *work) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int work_static(struct work_struct *work) { return 0; }
# 308 "/home/nathan/src/linux-next/include/linux/workqueue.h"
enum {
 WQ_UNBOUND = 1 << 1,
 WQ_FREEZABLE = 1 << 2,
 WQ_MEM_RECLAIM = 1 << 3,
 WQ_HIGHPRI = 1 << 4,
 WQ_CPU_INTENSIVE = 1 << 5,
 WQ_SYSFS = 1 << 6,
# 341 "/home/nathan/src/linux-next/include/linux/workqueue.h"
 WQ_POWER_EFFICIENT = 1 << 7,

 __WQ_DRAINING = 1 << 16,
 __WQ_ORDERED = 1 << 17,
 __WQ_LEGACY = 1 << 18,
 __WQ_ORDERED_EXPLICIT = 1 << 19,

 WQ_MAX_ACTIVE = 512,
 WQ_MAX_UNBOUND_PER_CPU = 4,
 WQ_DFL_ACTIVE = WQ_MAX_ACTIVE / 2,
};
# 385 "/home/nathan/src/linux-next/include/linux/workqueue.h"
extern struct workqueue_struct *system_wq;
extern struct workqueue_struct *system_highpri_wq;
extern struct workqueue_struct *system_long_wq;
extern struct workqueue_struct *system_unbound_wq;
extern struct workqueue_struct *system_freezable_wq;
extern struct workqueue_struct *system_power_efficient_wq;
extern struct workqueue_struct *system_freezable_power_efficient_wq;
# 407 "/home/nathan/src/linux-next/include/linux/workqueue.h"
struct workqueue_struct *alloc_workqueue(const char *fmt,
      unsigned int flags,
      int max_active, ...);
# 436 "/home/nathan/src/linux-next/include/linux/workqueue.h"
extern void destroy_workqueue(struct workqueue_struct *wq);

struct workqueue_attrs *alloc_workqueue_attrs(void);
void free_workqueue_attrs(struct workqueue_attrs *attrs);
int apply_workqueue_attrs(struct workqueue_struct *wq,
     const struct workqueue_attrs *attrs);
int workqueue_set_unbound_cpumask(cpumask_var_t cpumask);

extern bool queue_work_on(int cpu, struct workqueue_struct *wq,
   struct work_struct *work);
extern bool queue_work_node(int node, struct workqueue_struct *wq,
       struct work_struct *work);
extern bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *work, unsigned long delay);
extern bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *dwork, unsigned long delay);
extern bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork);

extern void flush_workqueue(struct workqueue_struct *wq);
extern void drain_workqueue(struct workqueue_struct *wq);

extern int schedule_on_each_cpu(work_func_t func);

int execute_in_process_context(work_func_t fn, struct execute_work *);

extern bool flush_work(struct work_struct *work);
extern bool cancel_work_sync(struct work_struct *work);

extern bool flush_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work_sync(struct delayed_work *dwork);

extern bool flush_rcu_work(struct rcu_work *rwork);

extern void workqueue_set_max_active(struct workqueue_struct *wq,
         int max_active);
extern struct work_struct *current_work(void);
extern bool current_is_workqueue_rescuer(void);
extern bool workqueue_congested(int cpu, struct workqueue_struct *wq);
extern unsigned int work_busy(struct work_struct *work);
extern __attribute__((__format__(printf, 1, 2))) void set_worker_desc(const char *fmt, ...);
extern void print_worker_info(const char *log_lvl, struct task_struct *task);
extern void show_workqueue_state(void);
extern void wq_worker_comm(char *buf, size_t size, struct task_struct *task);
# 504 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool queue_work(struct workqueue_struct *wq,
         struct work_struct *work)
{
 return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
# 518 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool queue_delayed_work(struct workqueue_struct *wq,
          struct delayed_work *dwork,
          unsigned long delay)
{
 return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
# 533 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mod_delayed_work(struct workqueue_struct *wq,
        struct delayed_work *dwork,
        unsigned long delay)
{
 return mod_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
# 547 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_work_on(int cpu, struct work_struct *work)
{
 return queue_work_on(cpu, system_wq, work);
}
# 566 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_work(struct work_struct *work)
{
 return queue_work(system_wq, work);
}
# 595 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_scheduled_work(void)
{
 flush_workqueue(system_wq);
}
# 609 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork,
         unsigned long delay)
{
 return queue_delayed_work_on(cpu, system_wq, dwork, delay);
}
# 623 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_delayed_work(struct delayed_work *dwork,
      unsigned long delay)
{
 return queue_delayed_work(system_wq, dwork, delay);
}
# 639 "/home/nathan/src/linux-next/include/linux/workqueue.h"
long work_on_cpu(int cpu, long (*fn)(void *), void *arg);
long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg);



extern void freeze_workqueues_begin(void);
extern bool freeze_workqueues_busy(void);
extern void thaw_workqueues(void);



int workqueue_sysfs_register(struct workqueue_struct *wq);
# 659 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wq_watchdog_touch(int cpu) { }



int workqueue_prepare_cpu(unsigned int cpu);
int workqueue_online_cpu(unsigned int cpu);
int workqueue_offline_cpu(unsigned int cpu);


void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) workqueue_init_early(void);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) workqueue_init(void);
# 22 "/home/nathan/src/linux-next/include/linux/srcu.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h"
struct rcu_cblist {
 struct callback_head *head;
 struct callback_head **tail;
 long len;
};
# 66 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h"
struct rcu_segcblist {
 struct callback_head *head;
 struct callback_head **tails[4];
 unsigned long gp_seq[4];

 atomic_long_t len;



 u8 enabled;
 u8 offloaded;
};
# 23 "/home/nathan/src/linux-next/include/linux/srcu.h" 2

struct srcu_struct;
# 41 "/home/nathan/src/linux-next/include/linux/srcu.h"
int init_srcu_struct(struct srcu_struct *ssp);








# 1 "/home/nathan/src/linux-next/include/linux/srcutree.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/srcutree.h"
# 1 "/home/nathan/src/linux-next/include/linux/rcu_node_tree.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/srcutree.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/completion.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/completion.h"
# 1 "/home/nathan/src/linux-next/include/linux/swait.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/wait.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/wait.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/wait.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/wait.h" 2

typedef struct wait_queue_entry wait_queue_entry_t;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);
int default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);
# 28 "/home/nathan/src/linux-next/include/linux/wait.h"
struct wait_queue_entry {
 unsigned int flags;
 void *private;
 wait_queue_func_t func;
 struct list_head entry;
};

struct wait_queue_head {
 spinlock_t lock;
 struct list_head head;
};
typedef struct wait_queue_head wait_queue_head_t;

struct task_struct;
# 62 "/home/nathan/src/linux-next/include/linux/wait.h"
extern void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *);
# 80 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struct task_struct *p)
{
 wq_entry->flags = 0;
 wq_entry->private = p;
 wq_entry->func = default_wake_function;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
init_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t func)
{
 wq_entry->flags = 0;
 wq_entry->private = ((void *)0);
 wq_entry->func = func;
}
# 125 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int waitqueue_active(struct wait_queue_head *wq_head)
{
 return !list_empty(&wq_head->head);
}
# 138 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wq_has_single_sleeper(struct wait_queue_head *wq_head)
{
 return list_is_singular(&wq_head->head);
}
# 151 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wq_has_sleeper(struct wait_queue_head *wq_head)
{







 __asm__ __volatile__ ("sync" : : : "memory");
 return waitqueue_active(wq_head);
}

extern void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
extern void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
extern void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_add(&wq_entry->entry, &wq_head->head);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 wq_entry->flags |= 0x01;
 __add_wait_queue(wq_head, wq_entry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_add_tail(&wq_entry->entry, &wq_head->head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__add_wait_queue_entry_tail_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 wq_entry->flags |= 0x01;
 __add_wait_queue_entry_tail(wq_head, wq_entry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_del(&wq_entry->entry);
}

void __wake_up(struct wait_queue_head *wq_head, unsigned int mode, int nr, void *key);
void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,
  unsigned int mode, void *key, wait_queue_entry_t *bookmark);
void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr);
void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode);
# 249 "/home/nathan/src/linux-next/include/linux/wait.h"
extern void init_wait_entry(struct wait_queue_entry *wq_entry, int flags);
# 733 "/home/nathan/src/linux-next/include/linux/wait.h"
extern int do_wait_intr(wait_queue_head_t *, wait_queue_entry_t *);
extern int do_wait_intr_irq(wait_queue_head_t *, wait_queue_entry_t *);
# 1127 "/home/nathan/src/linux-next/include/linux/wait.h"
void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout);
int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
# 1152 "/home/nathan/src/linux-next/include/linux/wait.h"
bool try_invoke_on_locked_down_task(struct task_struct *p, bool (*func)(struct task_struct *t, void *arg), void *arg);
# 9 "/home/nathan/src/linux-next/include/linux/swait.h" 2
# 41 "/home/nathan/src/linux-next/include/linux/swait.h"
struct task_struct;

struct swait_queue_head {
 raw_spinlock_t lock;
 struct list_head task_list;
};

struct swait_queue {
 struct task_struct *task;
 struct list_head task_list;
};
# 69 "/home/nathan/src/linux-next/include/linux/swait.h"
extern void __init_swait_queue_head(struct swait_queue_head *q, const char *name,
        struct lock_class_key *key);
# 121 "/home/nathan/src/linux-next/include/linux/swait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int swait_active(struct swait_queue_head *wq)
{
 return !list_empty(&wq->task_list);
}
# 134 "/home/nathan/src/linux-next/include/linux/swait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool swq_has_sleeper(struct swait_queue_head *wq)
{







 __asm__ __volatile__ ("sync" : : : "memory");
 return swait_active(wq);
}

extern void swake_up_one(struct swait_queue_head *q);
extern void swake_up_all(struct swait_queue_head *q);
extern void swake_up_locked(struct swait_queue_head *q);

extern void prepare_to_swait_exclusive(struct swait_queue_head *q, struct swait_queue *wait, int state);
extern long prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait, int state);

extern void __finish_swait(struct swait_queue_head *q, struct swait_queue *wait);
extern void finish_swait(struct swait_queue_head *q, struct swait_queue *wait);
# 13 "/home/nathan/src/linux-next/include/linux/completion.h" 2
# 26 "/home/nathan/src/linux-next/include/linux/completion.h"
struct completion {
 unsigned int done;
 struct swait_queue_head wait;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void complete_acquire(struct completion *x) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void complete_release(struct completion *x) {}
# 85 "/home/nathan/src/linux-next/include/linux/completion.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __init_completion(struct completion *x)
{
 x->done = 0;
 do { static struct lock_class_key __key; __init_swait_queue_head((&x->wait), "&x->wait", &__key); } while (0);
}
# 98 "/home/nathan/src/linux-next/include/linux/completion.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reinit_completion(struct completion *x)
{
 x->done = 0;
}

extern void wait_for_completion(struct completion *);
extern void wait_for_completion_io(struct completion *);
extern int wait_for_completion_interruptible(struct completion *x);
extern int wait_for_completion_killable(struct completion *x);
extern unsigned long wait_for_completion_timeout(struct completion *x,
         unsigned long timeout);
extern unsigned long wait_for_completion_io_timeout(struct completion *x,
          unsigned long timeout);
extern long wait_for_completion_interruptible_timeout(
 struct completion *x, unsigned long timeout);
extern long wait_for_completion_killable_timeout(
 struct completion *x, unsigned long timeout);
extern bool try_wait_for_completion(struct completion *x);
extern bool completion_done(struct completion *x);

extern void complete(struct completion *);
extern void complete_all(struct completion *);
# 16 "/home/nathan/src/linux-next/include/linux/srcutree.h" 2

struct srcu_node;
struct srcu_struct;





struct srcu_data {

 unsigned long srcu_lock_count[2];
 unsigned long srcu_unlock_count[2];


 spinlock_t lock __attribute__((__aligned__(1 << (7))));
 struct rcu_segcblist srcu_cblist;
 unsigned long srcu_gp_seq_needed;
 unsigned long srcu_gp_seq_needed_exp;
 bool srcu_cblist_invoking;
 struct timer_list delay_work;
 struct work_struct work;
 struct callback_head srcu_barrier_head;
 struct srcu_node *mynode;
 unsigned long grpmask;

 int cpu;
 struct srcu_struct *ssp;
};




struct srcu_node {
 spinlock_t lock;
 unsigned long srcu_have_cbs[4];


 unsigned long srcu_data_have_cbs[4];

 unsigned long srcu_gp_seq_needed_exp;
 struct srcu_node *srcu_parent;
 int grplo;
 int grphi;
};




struct srcu_struct {
 struct srcu_node node[(1 + (((2048) + (((16) * 64)) - 1) / (((16) * 64))) + (((2048) + ((16)) - 1) / ((16))))];
 struct srcu_node *level[3 + 1];

 struct mutex srcu_cb_mutex;
 spinlock_t lock;
 struct mutex srcu_gp_mutex;
 unsigned int srcu_idx;
 unsigned long srcu_gp_seq;
 unsigned long srcu_gp_seq_needed;
 unsigned long srcu_gp_seq_needed_exp;
 unsigned long srcu_last_gp_end;
 struct srcu_data *sda;
 unsigned long srcu_barrier_seq;
 struct mutex srcu_barrier_mutex;
 struct completion srcu_barrier_completion;

 atomic_t srcu_barrier_cpu_cnt;


 struct delayed_work work;



};
# 137 "/home/nathan/src/linux-next/include/linux/srcutree.h"
void synchronize_srcu_expedited(struct srcu_struct *ssp);
void srcu_barrier(struct srcu_struct *ssp);
void srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf);
# 50 "/home/nathan/src/linux-next/include/linux/srcu.h" 2







void call_srcu(struct srcu_struct *ssp, struct callback_head *head,
  void (*func)(struct callback_head *head));
void cleanup_srcu_struct(struct srcu_struct *ssp);
int __srcu_read_lock(struct srcu_struct *ssp) ;
void __srcu_read_unlock(struct srcu_struct *ssp, int idx) ;
void synchronize_srcu(struct srcu_struct *ssp);
# 91 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int srcu_read_lock_held(const struct srcu_struct *ssp)
{
 return 1;
}
# 150 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int srcu_read_lock(struct srcu_struct *ssp)
{
 int retval;

 retval = __srcu_read_lock(ssp);
 do { } while (0);
 return retval;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) int
srcu_read_lock_notrace(struct srcu_struct *ssp)
{
 int retval;

 retval = __srcu_read_lock(ssp);
 return retval;
}
# 176 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void srcu_read_unlock(struct srcu_struct *ssp, int idx)

{
 ({ int __ret_warn_on = !!(idx & ~0x1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/srcu.h"), "i" (179), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 do { } while (0);
 __srcu_read_unlock(ssp, idx);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void
srcu_read_unlock_notrace(struct srcu_struct *ssp, int idx)
{
 __srcu_read_unlock(ssp, idx);
}
# 200 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void smp_mb__after_srcu_read_unlock(void)
{

}
# 17 "/home/nathan/src/linux-next/include/linux/tracepoint.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h"
# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h" 2

struct trace_print_flags {
 unsigned long mask;
 const char *name;
};

struct trace_print_flags_u64 {
 unsigned long long mask;
 const char *name;
};

struct tracepoint_func {
 void *func;
 void *data;
 int prio;
};

struct tracepoint {
 const char *name;
 struct static_key key;
 int (*regfunc)(void);
 void (*unregfunc)(void);
 struct tracepoint_func *funcs;
};




typedef struct tracepoint * const tracepoint_ptr_t;


struct bpf_raw_event_map {
 struct tracepoint *tp;
 void *bpf_func;
 u32 num_args;
 u32 writable_size;
} __attribute__((__aligned__(32)));
# 22 "/home/nathan/src/linux-next/include/linux/tracepoint.h" 2

struct module;
struct tracepoint;
struct notifier_block;

struct trace_eval_map {
 const char *system;
 const char *eval_string;
 unsigned long eval_value;
};



extern struct srcu_struct tracepoint_srcu;

extern int
tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);
extern int
tracepoint_probe_register_prio(struct tracepoint *tp, void *probe, void *data,
          int prio);
extern int
tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data);
extern void
for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),
  void *priv);


struct tp_module {
 struct list_head list;
 struct module *mod;
};

bool trace_module_has_bad_taint(struct module *mod);
extern int register_tracepoint_module_notifier(struct notifier_block *nb);
extern int unregister_tracepoint_module_notifier(struct notifier_block *nb);
# 80 "/home/nathan/src/linux-next/include/linux/tracepoint.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tracepoint_synchronize_unregister(void)
{
 synchronize_srcu(&tracepoint_srcu);
 synchronize_rcu();
}






extern int syscall_regfunc(void);
extern void syscall_unregfunc(void);
# 112 "/home/nathan/src/linux-next/include/linux/tracepoint.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
{
 return *p;
}
# 33 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h" 2

extern struct tracepoint __tracepoint_amdgpu_dc_rreg; static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void trace_amdgpu_dc_rreg(unsigned long *read_count, uint32_t reg, uint32_t value) { if (static_key_false(&__tracepoint_amdgpu_dc_rreg.key)) do { struct tracepoint_func *it_func_ptr; void *it_func; void *__data; int __attribute__((__unused__)) __idx = 0; if (!(cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) return; ({ int __ret_warn_on = !!(0 && (preempt_count() & (((1UL << (4))-1) << (((0 + 8) + 8) + 4)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"), "i" (49), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }); __asm__ __volatile__("" : : : "memory"); if (0) { __idx = srcu_read_lock_notrace(&tracepoint_srcu); rcu_irq_enter_irqson(); } it_func_ptr = ({ typeof((&__tracepoint_amdgpu_dc_rreg)->funcs) ________p1 = ({ do { extern void __compiletime_assert_50(void) ; if (!((sizeof((&__tracepoint_amdgpu_dc_rreg)->funcs) == sizeof(char) || sizeof((&__tracepoint_amdgpu_dc_rreg)->funcs) == sizeof(short) || sizeof((&__tracepoint_amdgpu_dc_rreg)->funcs) == sizeof(int) || sizeof((&__tracepoint_amdgpu_dc_rreg)->funcs) == sizeof(long)) || sizeof((&__tracepoint_amdgpu_dc_rreg)->funcs) == sizeof(long long))) __compiletime_assert_50(); } while (0); ({ typeof( _Generic(((&__tracepoint_amdgpu_dc_rreg)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_rreg)->funcs))) __x = (*(const volatile typeof( _Generic(((&__tracepoint_amdgpu_dc_rreg)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_rreg)->funcs))) *)&((&__tracepoint_amdgpu_dc_rreg)->funcs)); do { } while (0); (typeof((&__tracepoint_amdgpu_dc_rreg)->funcs))__x; }); }); ((typeof(*(&__tracepoint_amdgpu_dc_rreg)->funcs) *)(________p1)); }); if (it_func_ptr) { do { it_func = (it_func_ptr)->func; __data = (it_func_ptr)->data; ((void(*)(void *__data, unsigned long *read_count, uint32_t reg, uint32_t value))(it_func))(__data, read_count, reg, value); } while ((++it_func_ptr)->func); } if (0) { rcu_irq_exit_irqson(); srcu_read_unlock_notrace(&tracepoint_srcu, __idx); } __asm__ __volatile__("" : : : "memory"); } while (0); if (0 && (cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) { rcu_read_lock_sched_notrace(); ({ typeof(*(__tracepoint_amdgpu_dc_rreg.funcs)) *________p1 = (typeof(*(__tracepoint_amdgpu_dc_rreg.funcs)) *)({ do { extern void __compiletime_assert_51(void) ; if (!((sizeof((__tracepoint_amdgpu_dc_rreg.funcs)) == sizeof(char) || sizeof((__tracepoint_amdgpu_dc_rreg.funcs)) == sizeof(short) || sizeof((__tracepoint_amdgpu_dc_rreg.funcs)) == sizeof(int) || sizeof((__tracepoint_amdgpu_dc_rreg.funcs)) == sizeof(long)) || sizeof((__tracepoint_amdgpu_dc_rreg.funcs)) == sizeof(long long))) __compiletime_assert_51(); } while (0); ({ typeof( _Generic(((__tracepoint_amdgpu_dc_rreg.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_rreg.funcs)))) __x = (*(const volatile typeof( _Generic(((__tracepoint_amdgpu_dc_rreg.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_rreg.funcs)))) *)&((__tracepoint_amdgpu_dc_rreg.funcs))); do { } while (0); (typeof((__tracepoint_amdgpu_dc_rreg.funcs)))__x; }); }); do { } while (0); ; ((typeof(*(__tracepoint_amdgpu_dc_rreg.funcs)) *)(________p1)); }); rcu_read_unlock_sched_notrace(); } } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_amdgpu_dc_rreg(void (*probe)(void *__data, unsigned long *read_count, uint32_t reg, uint32_t value), void *data) { return tracepoint_probe_register(&__tracepoint_amdgpu_dc_rreg, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_prio_amdgpu_dc_rreg(void (*probe)(void *__data, unsigned long *read_count, uint32_t reg, uint32_t value), void *data, int prio) { return tracepoint_probe_register_prio(&__tracepoint_amdgpu_dc_rreg, (void *)probe, data, prio); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unregister_trace_amdgpu_dc_rreg(void (*probe)(void *__data, unsigned long *read_count, uint32_t reg, uint32_t value), void *data) { return tracepoint_probe_unregister(&__tracepoint_amdgpu_dc_rreg, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void check_trace_callback_type_amdgpu_dc_rreg(void (*cb)(void *__data, unsigned long *read_count, uint32_t reg, uint32_t value)) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool trace_amdgpu_dc_rreg_enabled(void) { return static_key_false(&__tracepoint_amdgpu_dc_rreg.key); };
# 51 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"
extern struct tracepoint __tracepoint_amdgpu_dc_wreg; static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void trace_amdgpu_dc_wreg(unsigned long *write_count, uint32_t reg, uint32_t value) { if (static_key_false(&__tracepoint_amdgpu_dc_wreg.key)) do { struct tracepoint_func *it_func_ptr; void *it_func; void *__data; int __attribute__((__unused__)) __idx = 0; if (!(cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) return; ({ int __ret_warn_on = !!(0 && (preempt_count() & (((1UL << (4))-1) << (((0 + 8) + 8) + 4)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"), "i" (66), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }); __asm__ __volatile__("" : : : "memory"); if (0) { __idx = srcu_read_lock_notrace(&tracepoint_srcu); rcu_irq_enter_irqson(); } it_func_ptr = ({ typeof((&__tracepoint_amdgpu_dc_wreg)->funcs) ________p1 = ({ do { extern void __compiletime_assert_52(void) ; if (!((sizeof((&__tracepoint_amdgpu_dc_wreg)->funcs) == sizeof(char) || sizeof((&__tracepoint_amdgpu_dc_wreg)->funcs) == sizeof(short) || sizeof((&__tracepoint_amdgpu_dc_wreg)->funcs) == sizeof(int) || sizeof((&__tracepoint_amdgpu_dc_wreg)->funcs) == sizeof(long)) || sizeof((&__tracepoint_amdgpu_dc_wreg)->funcs) == sizeof(long long))) __compiletime_assert_52(); } while (0); ({ typeof( _Generic(((&__tracepoint_amdgpu_dc_wreg)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_wreg)->funcs))) __x = (*(const volatile typeof( _Generic(((&__tracepoint_amdgpu_dc_wreg)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_wreg)->funcs))) *)&((&__tracepoint_amdgpu_dc_wreg)->funcs)); do { } while (0); (typeof((&__tracepoint_amdgpu_dc_wreg)->funcs))__x; }); }); ((typeof(*(&__tracepoint_amdgpu_dc_wreg)->funcs) *)(________p1)); }); if (it_func_ptr) { do { it_func = (it_func_ptr)->func; __data = (it_func_ptr)->data; ((void(*)(void *__data, unsigned long *write_count, uint32_t reg, uint32_t value))(it_func))(__data, write_count, reg, value); } while ((++it_func_ptr)->func); } if (0) { rcu_irq_exit_irqson(); srcu_read_unlock_notrace(&tracepoint_srcu, __idx); } __asm__ __volatile__("" : : : "memory"); } while (0); if (0 && (cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) { rcu_read_lock_sched_notrace(); ({ typeof(*(__tracepoint_amdgpu_dc_wreg.funcs)) *________p1 = (typeof(*(__tracepoint_amdgpu_dc_wreg.funcs)) *)({ do { extern void __compiletime_assert_53(void) ; if (!((sizeof((__tracepoint_amdgpu_dc_wreg.funcs)) == sizeof(char) || sizeof((__tracepoint_amdgpu_dc_wreg.funcs)) == sizeof(short) || sizeof((__tracepoint_amdgpu_dc_wreg.funcs)) == sizeof(int) || sizeof((__tracepoint_amdgpu_dc_wreg.funcs)) == sizeof(long)) || sizeof((__tracepoint_amdgpu_dc_wreg.funcs)) == sizeof(long long))) __compiletime_assert_53(); } while (0); ({ typeof( _Generic(((__tracepoint_amdgpu_dc_wreg.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_wreg.funcs)))) __x = (*(const volatile typeof( _Generic(((__tracepoint_amdgpu_dc_wreg.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_wreg.funcs)))) *)&((__tracepoint_amdgpu_dc_wreg.funcs))); do { } while (0); (typeof((__tracepoint_amdgpu_dc_wreg.funcs)))__x; }); }); do { } while (0); ; ((typeof(*(__tracepoint_amdgpu_dc_wreg.funcs)) *)(________p1)); }); rcu_read_unlock_sched_notrace(); } } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_amdgpu_dc_wreg(void (*probe)(void *__data, unsigned long *write_count, uint32_t reg, uint32_t value), void *data) { return tracepoint_probe_register(&__tracepoint_amdgpu_dc_wreg, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_prio_amdgpu_dc_wreg(void (*probe)(void *__data, unsigned long *write_count, uint32_t reg, uint32_t value), void *data, int prio) { return tracepoint_probe_register_prio(&__tracepoint_amdgpu_dc_wreg, (void *)probe, data, prio); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unregister_trace_amdgpu_dc_wreg(void (*probe)(void *__data, unsigned long *write_count, uint32_t reg, uint32_t value), void *data) { return tracepoint_probe_unregister(&__tracepoint_amdgpu_dc_wreg, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void check_trace_callback_type_amdgpu_dc_wreg(void (*cb)(void *__data, unsigned long *write_count, uint32_t reg, uint32_t value)) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool trace_amdgpu_dc_wreg_enabled(void) { return static_key_false(&__tracepoint_amdgpu_dc_wreg.key); };
# 69 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"
extern struct tracepoint __tracepoint_amdgpu_dc_performance; static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void trace_amdgpu_dc_performance(unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line) { if (static_key_false(&__tracepoint_amdgpu_dc_performance.key)) do { struct tracepoint_func *it_func_ptr; void *it_func; void *__data; int __attribute__((__unused__)) __idx = 0; if (!(cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) return; ({ int __ret_warn_on = !!(0 && (preempt_count() & (((1UL << (4))-1) << (((0 + 8) + 8) + 4)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"), "i" (98), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }); __asm__ __volatile__("" : : : "memory"); if (0) { __idx = srcu_read_lock_notrace(&tracepoint_srcu); rcu_irq_enter_irqson(); } it_func_ptr = ({ typeof((&__tracepoint_amdgpu_dc_performance)->funcs) ________p1 = ({ do { extern void __compiletime_assert_54(void) ; if (!((sizeof((&__tracepoint_amdgpu_dc_performance)->funcs) == sizeof(char) || sizeof((&__tracepoint_amdgpu_dc_performance)->funcs) == sizeof(short) || sizeof((&__tracepoint_amdgpu_dc_performance)->funcs) == sizeof(int) || sizeof((&__tracepoint_amdgpu_dc_performance)->funcs) == sizeof(long)) || sizeof((&__tracepoint_amdgpu_dc_performance)->funcs) == sizeof(long long))) __compiletime_assert_54(); } while (0); ({ typeof( _Generic(((&__tracepoint_amdgpu_dc_performance)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_performance)->funcs))) __x = (*(const volatile typeof( _Generic(((&__tracepoint_amdgpu_dc_performance)->funcs), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&__tracepoint_amdgpu_dc_performance)->funcs))) *)&((&__tracepoint_amdgpu_dc_performance)->funcs)); do { } while (0); (typeof((&__tracepoint_amdgpu_dc_performance)->funcs))__x; }); }); ((typeof(*(&__tracepoint_amdgpu_dc_performance)->funcs) *)(________p1)); }); if (it_func_ptr) { do { it_func = (it_func_ptr)->func; __data = (it_func_ptr)->data; ((void(*)(void *__data, unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line))(it_func))(__data, read_count, write_count, last_read, last_write, func, line); } while ((++it_func_ptr)->func); } if (0) { rcu_irq_exit_irqson(); srcu_read_unlock_notrace(&tracepoint_srcu, __idx); } __asm__ __volatile__("" : : : "memory"); } while (0); if (0 && (cpumask_test_cpu(((local_paca->paca_index)), ((const struct cpumask *)&__cpu_online_mask)))) { rcu_read_lock_sched_notrace(); ({ typeof(*(__tracepoint_amdgpu_dc_performance.funcs)) *________p1 = (typeof(*(__tracepoint_amdgpu_dc_performance.funcs)) *)({ do { extern void __compiletime_assert_55(void) ; if (!((sizeof((__tracepoint_amdgpu_dc_performance.funcs)) == sizeof(char) || sizeof((__tracepoint_amdgpu_dc_performance.funcs)) == sizeof(short) || sizeof((__tracepoint_amdgpu_dc_performance.funcs)) == sizeof(int) || sizeof((__tracepoint_amdgpu_dc_performance.funcs)) == sizeof(long)) || sizeof((__tracepoint_amdgpu_dc_performance.funcs)) == sizeof(long long))) __compiletime_assert_55(); } while (0); ({ typeof( _Generic(((__tracepoint_amdgpu_dc_performance.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_performance.funcs)))) __x = (*(const volatile typeof( _Generic(((__tracepoint_amdgpu_dc_performance.funcs)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((__tracepoint_amdgpu_dc_performance.funcs)))) *)&((__tracepoint_amdgpu_dc_performance.funcs))); do { } while (0); (typeof((__tracepoint_amdgpu_dc_performance.funcs)))__x; }); }); do { } while (0); ; ((typeof(*(__tracepoint_amdgpu_dc_performance.funcs)) *)(________p1)); }); rcu_read_unlock_sched_notrace(); } } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_amdgpu_dc_performance(void (*probe)(void *__data, unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line), void *data) { return tracepoint_probe_register(&__tracepoint_amdgpu_dc_performance, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_trace_prio_amdgpu_dc_performance(void (*probe)(void *__data, unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line), void *data, int prio) { return tracepoint_probe_register_prio(&__tracepoint_amdgpu_dc_performance, (void *)probe, data, prio); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unregister_trace_amdgpu_dc_performance(void (*probe)(void *__data, unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line), void *data) { return tracepoint_probe_unregister(&__tracepoint_amdgpu_dc_performance, (void *)probe, data); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void check_trace_callback_type_amdgpu_dc_performance(void (*cb)(void *__data, unsigned long read_count, unsigned long write_count, unsigned long *last_read, unsigned long *last_write, const char *func, unsigned int line)) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool trace_amdgpu_dc_performance_enabled(void) { return static_key_false(&__tracepoint_amdgpu_dc_performance.key); };
# 104 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h"
# 1 "/home/nathan/src/linux-next/include/trace/define_trace.h" 1
# 105 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_trace.h" 2
# 35 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h" 2


# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services_types.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services_types.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 1
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h"
# 1 "/home/nathan/src/linux-next/include/linux/kgdb.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/kgdb.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kgdb.h" 1
# 32 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kgdb.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_kgdb_breakpoint(void)
{
 asm(".long 0x7d821008" " ");
}
# 21 "/home/nathan/src/linux-next/include/linux/kgdb.h" 2



struct pt_regs;
# 35 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern int kgdb_skipexception(int exception, struct pt_regs *regs);

struct tasklet_struct;
struct task_struct;
struct uart_port;
# 49 "/home/nathan/src/linux-next/include/linux/kgdb.h"
void kgdb_breakpoint(void);

extern int kgdb_connected;
extern int kgdb_io_module_registered;

extern atomic_t kgdb_setting_breakpoint;
extern atomic_t kgdb_cpu_doing_single_step;

extern struct task_struct *kgdb_usethread;
extern struct task_struct *kgdb_contthread;

enum kgdb_bptype {
 BP_BREAKPOINT = 0,
 BP_HARDWARE_BREAKPOINT,
 BP_WRITE_WATCHPOINT,
 BP_READ_WATCHPOINT,
 BP_ACCESS_WATCHPOINT,
 BP_POKE_BREAKPOINT,
};

enum kgdb_bpstate {
 BP_UNDEFINED = 0,
 BP_REMOVED,
 BP_SET,
 BP_ACTIVE
};

struct kgdb_bkpt {
 unsigned long bpt_addr;
 unsigned char saved_instr[4];
 enum kgdb_bptype type;
 enum kgdb_bpstate state;
};

struct dbg_reg_def_t {
 char *name;
 int size;
 int offset;
};




extern struct dbg_reg_def_t dbg_reg_def[];
extern char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs);
extern int dbg_set_reg(int regno, void *mem, struct pt_regs *regs);
# 112 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern int kgdb_arch_init(void);







extern void kgdb_arch_exit(void);
# 130 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
# 144 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void
sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p);
# 155 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs);
# 173 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern int
kgdb_arch_handle_exception(int vector, int signo, int err_code,
      char *remcom_in_buffer,
      char *remcom_out_buffer,
      struct pt_regs *regs);
# 188 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void kgdb_call_nmi_hook(void *ignored);
# 201 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void kgdb_roundup_cpus(void);
# 211 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);



extern int kgdb_validate_break_address(unsigned long addr);
extern int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt);
extern int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt);
# 227 "/home/nathan/src/linux-next/include/linux/kgdb.h"
extern void kgdb_arch_late(void);
# 250 "/home/nathan/src/linux-next/include/linux/kgdb.h"
struct kgdb_arch {
 unsigned char gdb_bpt_instr[4];
 unsigned long flags;

 int (*set_breakpoint)(unsigned long, char *);
 int (*remove_breakpoint)(unsigned long, char *);
 int (*set_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
 int (*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
 void (*disable_hw_break)(struct pt_regs *regs);
 void (*remove_all_hw_break)(void);
 void (*correct_hw_break)(void);

 void (*enable_nmi)(bool on);
};
# 282 "/home/nathan/src/linux-next/include/linux/kgdb.h"
struct kgdb_io {
 const char *name;
 int (*read_char) (void);
 void (*write_char) (u8);
 void (*flush) (void);
 int (*init) (void);
 void (*deinit) (void);
 void (*pre_exception) (void);
 void (*post_exception) (void);
 int is_console;
};

extern const struct kgdb_arch arch_kgdb_ops;

extern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kgdb_register_nmi_console(void) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kgdb_unregister_nmi_console(void) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kgdb_nmi_poll_knock(void) { return true; }


extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
extern struct kgdb_io *dbg_io_ops;

extern int kgdb_hex2long(char **ptr, unsigned long *long_val);
extern char *kgdb_mem2hex(char *mem, char *buf, int count);
extern int kgdb_hex2mem(char *buf, char *mem, int count);

extern int kgdb_isremovedbreak(unsigned long addr);
extern void kgdb_schedule_breakpoint(void);

extern int
kgdb_handle_exception(int ex_vector, int signo, int err_code,
        struct pt_regs *regs);
extern int kgdb_nmicallback(int cpu, void *regs);
extern int kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,
     atomic_t *snd_rdy);
extern void gdbstub_exit(int status);

extern int kgdb_single_step;
extern atomic_t kgdb_active;


extern bool dbg_is_early;
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) dbg_late_init(void);
extern void kgdb_panic(const char *msg);
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kref.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/kref.h"
# 1 "/home/nathan/src/linux-next/include/linux/refcount.h" 1
# 101 "/home/nathan/src/linux-next/include/linux/refcount.h"
struct mutex;
# 111 "/home/nathan/src/linux-next/include/linux/refcount.h"
typedef struct refcount_struct {
 atomic_t refs;
} refcount_t;





enum refcount_saturation_type {
 REFCOUNT_ADD_NOT_ZERO_OVF,
 REFCOUNT_ADD_OVF,
 REFCOUNT_ADD_UAF,
 REFCOUNT_SUB_UAF,
 REFCOUNT_DEC_LEAK,
};

void refcount_warn_saturate(refcount_t *r, enum refcount_saturation_type t);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_set(refcount_t *r, int n)
{
 atomic_set(&r->refs, n);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int refcount_read(const refcount_t *r)
{
 return atomic_read(&r->refs);
}
# 168 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_add_not_zero(int i, refcount_t *r)
{
 int old = refcount_read(r);

 do {
  if (!old)
   break;
 } while (!atomic_try_cmpxchg_relaxed(&r->refs, &old, old + i));

 if (__builtin_expect(!!(old < 0 || old + i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_NOT_ZERO_OVF);

 return old;
}
# 199 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_add(int i, refcount_t *r)
{
 int old = atomic_fetch_add_relaxed(i, &r->refs);

 if (__builtin_expect(!!(!old), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_UAF);
 else if (__builtin_expect(!!(old < 0 || old + i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_OVF);
}
# 222 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_inc_not_zero(refcount_t *r)
{
 return refcount_add_not_zero(1, r);
}
# 239 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_inc(refcount_t *r)
{
 refcount_add(1, r);
}
# 264 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_sub_and_test(int i, refcount_t *r)
{
 int old = atomic_fetch_sub_release(i, &r->refs);

 if (old == i) {
  __asm__ __volatile__ ("lwsync" " " : : :"memory");
  return true;
 }

 if (__builtin_expect(!!(old < 0 || old - i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_SUB_UAF);

 return false;
}
# 292 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_dec_and_test(refcount_t *r)
{
 return refcount_sub_and_test(1, r);
}
# 307 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_dec(refcount_t *r)
{
 if (__builtin_expect(!!(atomic_fetch_sub_release(1, &r->refs) <= 1), 0))
  refcount_warn_saturate(r, REFCOUNT_DEC_LEAK);
}

extern __attribute__((__warn_unused_result__)) bool refcount_dec_if_one(refcount_t *r);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_not_one(refcount_t *r);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_lock_irqsave(refcount_t *r,
             spinlock_t *lock,
             unsigned long *flags);
# 18 "/home/nathan/src/linux-next/include/linux/kref.h" 2

struct kref {
 refcount_t refcount;
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kref_init(struct kref *kref)
{
 refcount_set(&kref->refcount, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int kref_read(const struct kref *kref)
{
 return refcount_read(&kref->refcount);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kref_get(struct kref *kref)
{
 refcount_inc(&kref->refcount);
}
# 62 "/home/nathan/src/linux-next/include/linux/kref.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put(struct kref *kref, void (*release)(struct kref *kref))
{
 if (refcount_dec_and_test(&kref->refcount)) {
  release(kref);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put_mutex(struct kref *kref,
     void (*release)(struct kref *kref),
     struct mutex *lock)
{
 if (refcount_dec_and_mutex_lock(&kref->refcount, lock)) {
  release(kref);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put_lock(struct kref *kref,
    void (*release)(struct kref *kref),
    spinlock_t *lock)
{
 if (refcount_dec_and_lock(&kref->refcount, lock)) {
  release(kref);
  return 1;
 }
 return 0;
}
# 109 "/home/nathan/src/linux-next/include/linux/kref.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kref_get_unless_zero(struct kref *kref)
{
 return refcount_inc_not_zero(&kref->refcount);
}
# 32 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/slab.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/slab.h"
# 1 "/home/nathan/src/linux-next/include/linux/gfp.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/mmzone.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/mmzone.h"
# 1 "/home/nathan/src/linux-next/include/linux/numa.h" 1
# 25 "/home/nathan/src/linux-next/include/linux/numa.h"
int numa_map_to_online_node(int node);





int phys_to_target_node(phys_addr_t addr);
# 15 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/nodemask.h" 1
# 98 "/home/nathan/src/linux-next/include/linux/nodemask.h"
typedef struct { unsigned long bits[((((1 << 8)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))]; } nodemask_t;
extern nodemask_t _unused_nodemask_arg_;
# 109 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __nodemask_pr_numnodes(const nodemask_t *m)
{
 return m ? (1 << 8) : 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const unsigned long *__nodemask_pr_bits(const nodemask_t *m)
{
 return m ? m->bits : ((void *)0);
}
# 128 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __node_set(int node, volatile nodemask_t *dstp)
{
 set_bit(node, dstp->bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __node_clear(int node, volatile nodemask_t *dstp)
{
 clear_bit(node, dstp->bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_setall(nodemask_t *dstp, unsigned int nbits)
{
 bitmap_fill(dstp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_clear(nodemask_t *dstp, unsigned int nbits)
{
 bitmap_zero(dstp->bits, nbits);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __node_test_and_set(int node, nodemask_t *addr)
{
 return test_and_set_bit(node, addr->bits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_and(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_or(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_xor(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_andnot(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_complement(nodemask_t *dstp,
     const nodemask_t *srcp, unsigned int nbits)
{
 bitmap_complement(dstp->bits, srcp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_equal(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_equal(src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_intersects(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_intersects(src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_subset(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_subset(src1p->bits, src2p->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_empty(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_empty(srcp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_full(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_full(srcp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_weight(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_weight(srcp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_shift_right(nodemask_t *dstp,
     const nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_right(dstp->bits, srcp->bits, n, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_shift_left(nodemask_t *dstp,
     const nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __first_node(const nodemask_t *srcp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) ? ((int)((1 << 8))) : ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x56 = ((int)((1 << 8))); typeof((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) __UNIQUE_ID___y57 = ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))); ((__UNIQUE_ID___x56) < (__UNIQUE_ID___y57) ? (__UNIQUE_ID___x56) : (__UNIQUE_ID___y57)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __next_node(int n, const nodemask_t *srcp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) ? ((int)((1 << 8))) : ((int)(find_next_bit(srcp->bits, (1 << 8), n+1)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x58 = ((int)((1 << 8))); typeof((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) __UNIQUE_ID___y59 = ((int)(find_next_bit(srcp->bits, (1 << 8), n+1))); ((__UNIQUE_ID___x58) < (__UNIQUE_ID___y59) ? (__UNIQUE_ID___x58) : (__UNIQUE_ID___y59)); }));
}






int __next_node_in(int node, const nodemask_t *srcp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_nodemask_of_node(nodemask_t *mask, int node)
{
 __nodes_clear(&(*mask), (1 << 8));
 __node_set((node), &(*mask));
}
# 299 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __first_unset_node(const nodemask_t *maskp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) ? ((int)((1 << 8))) : ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x60 = ((int)((1 << 8))); typeof((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) __UNIQUE_ID___y61 = ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))); ((__UNIQUE_ID___x60) < (__UNIQUE_ID___y61) ? (__UNIQUE_ID___x60) : (__UNIQUE_ID___y61)); }));

}
# 333 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodemask_parse_user(const char *buf, int len,
     nodemask_t *dstp, int nbits)
{
 return bitmap_parse_user(buf, len, dstp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodelist_parse(const char *buf, nodemask_t *dstp, int nbits)
{
 return bitmap_parselist(buf, dstp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __node_remap(int oldbit,
  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
{
 return bitmap_bitremap(oldbit, oldp->bits, newp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_remap(nodemask_t *dstp, const nodemask_t *srcp,
  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
{
 bitmap_remap(dstp->bits, srcp->bits, oldp->bits, newp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_onto(nodemask_t *dstp, const nodemask_t *origp,
  const nodemask_t *relmapp, int nbits)
{
 bitmap_onto(dstp->bits, origp->bits, relmapp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_fold(nodemask_t *dstp, const nodemask_t *origp,
  int sz, int nbits)
{
 bitmap_fold(dstp->bits, origp->bits, sz, nbits);
}
# 391 "/home/nathan/src/linux-next/include/linux/nodemask.h"
enum node_states {
 N_POSSIBLE,
 N_ONLINE,
 N_NORMAL_MEMORY,



 N_HIGH_MEMORY = N_NORMAL_MEMORY,

 N_MEMORY,
 N_CPU,
 NR_NODE_STATES
};






extern nodemask_t node_states[NR_NODE_STATES];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int node_state(int node, enum node_states state)
{
 return test_bit((node), (node_states[state]).bits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_state(int node, enum node_states state)
{
 __node_set(node, &node_states[state]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_clear_state(int node, enum node_states state)
{
 __node_clear(node, &node_states[state]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int num_node_state(enum node_states state)
{
 return __nodes_weight(&(node_states[state]), (1 << 8));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int next_online_node(int nid)
{
 return __next_node((nid), &(node_states[N_ONLINE]));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int next_memory_node(int nid)
{
 return __next_node((nid), &(node_states[N_MEMORY]));
}

extern unsigned int nr_node_ids;
extern unsigned int nr_online_nodes;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_online(int nid)
{
 node_set_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_offline(int nid)
{
 node_clear_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}
# 497 "/home/nathan/src/linux-next/include/linux/nodemask.h"
extern int node_random(const nodemask_t *maskp);
# 531 "/home/nathan/src/linux-next/include/linux/nodemask.h"
struct nodemask_scratch {
 nodemask_t mask1;
 nodemask_t mask2;
};
# 18 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h"
enum pageblock_bits {
 PB_migrate,
 PB_migrate_end = PB_migrate + 3 - 1,

 PB_migrate_skip,





 NR_PAGEBLOCK_BITS
};






extern unsigned int pageblock_order;
# 55 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h"
struct page;

unsigned long get_pfnblock_flags_mask(struct page *page,
    unsigned long pfn,
    unsigned long end_bitidx,
    unsigned long mask);

void set_pfnblock_flags_mask(struct page *page,
    unsigned long flags,
    unsigned long pfn,
    unsigned long end_bitidx,
    unsigned long mask);
# 19 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 1





# 1 "./include/generated/bounds.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 2
# 28 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sparsemem.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sparsemem.h"
extern int create_section_mapping(unsigned long start, unsigned long end,
      int nid, pgprot_t prot);
extern int remove_section_mapping(unsigned long start, unsigned long end);


extern int resize_hpt_for_hotplug(unsigned long new_mem_size);





extern int hot_add_scn_to_nid(unsigned long scn_addr);
# 29 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/mm_types.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/mm_types_task.h" 1
# 34 "/home/nathan/src/linux-next/include/linux/mm_types_task.h"
struct vmacache {
 u64 seqnum;
 struct vm_area_struct *vmas[(1U << 2)];
};





enum {
 MM_FILEPAGES,
 MM_ANONPAGES,
 MM_SWAPENTS,
 MM_SHMEMPAGES,
 NR_MM_COUNTERS
};




struct task_rss_stat {
 int events;
 int count[NR_MM_COUNTERS];
};


struct mm_rss_stat {
 atomic_long_t count[NR_MM_COUNTERS];
};

struct page_frag {
 struct page *page;

 __u32 offset;
 __u32 size;




};


struct tlbflush_unmap_batch {
# 97 "/home/nathan/src/linux-next/include/linux/mm_types_task.h"
};
# 6 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/auxvec.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/auxvec.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/auxvec.h" 1
# 6 "/home/nathan/src/linux-next/include/uapi/linux/auxvec.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/auxvec.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/rbtree.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/rbtree.h"
struct rb_node {
 unsigned long __rb_parent_color;
 struct rb_node *rb_right;
 struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));


struct rb_root {
 struct rb_node *rb_node;
};
# 49 "/home/nathan/src/linux-next/include/linux/rbtree.h"
extern void rb_insert_color(struct rb_node *, struct rb_root *);
extern void rb_erase(struct rb_node *, struct rb_root *);



extern struct rb_node *rb_next(const struct rb_node *);
extern struct rb_node *rb_prev(const struct rb_node *);
extern struct rb_node *rb_first(const struct rb_root *);
extern struct rb_node *rb_last(const struct rb_root *);


extern struct rb_node *rb_first_postorder(const struct rb_root *);
extern struct rb_node *rb_next_postorder(const struct rb_node *);


extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,
       struct rb_root *root);
extern void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new,
    struct rb_root *root);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_link_node(struct rb_node *node, struct rb_node *parent,
    struct rb_node **rb_link)
{
 node->__rb_parent_color = (unsigned long)parent;
 node->rb_left = node->rb_right = ((void *)0);

 *rb_link = node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_link_node_rcu(struct rb_node *node, struct rb_node *parent,
        struct rb_node **rb_link)
{
 node->__rb_parent_color = (unsigned long)parent;
 node->rb_left = node->rb_right = ((void *)0);

 do { uintptr_t _r_a_p__v = (uintptr_t)(node); ; if (__builtin_constant_p(node) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_62(void) ; if (!((sizeof((*rb_link)) == sizeof(char) || sizeof((*rb_link)) == sizeof(short) || sizeof((*rb_link)) == sizeof(int) || sizeof((*rb_link)) == sizeof(long)) || sizeof((*rb_link)) == sizeof(long long))) __compiletime_assert_62(); } while (0); do { *(volatile typeof((*rb_link)) *)&((*rb_link)) = ((typeof(*rb_link))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_63(void) ; if (!((sizeof(*&*rb_link) == sizeof(char) || sizeof(*&*rb_link) == sizeof(short) || sizeof(*&*rb_link) == sizeof(int) || sizeof(*&*rb_link) == sizeof(long)))) __compiletime_assert_63(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_64(void) ; if (!((sizeof(*&*rb_link) == sizeof(char) || sizeof(*&*rb_link) == sizeof(short) || sizeof(*&*rb_link) == sizeof(int) || sizeof(*&*rb_link) == sizeof(long)) || sizeof(*&*rb_link) == sizeof(long long))) __compiletime_assert_64(); } while (0); do { *(volatile typeof(*&*rb_link) *)&(*&*rb_link) = ((typeof(*((typeof(*rb_link))_r_a_p__v)) *)((typeof(*rb_link))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
}
# 125 "/home/nathan/src/linux-next/include/linux/rbtree.h"
struct rb_root_cached {
 struct rb_root rb_root;
 struct rb_node *rb_leftmost;
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_insert_color_cached(struct rb_node *node,
       struct rb_root_cached *root,
       bool leftmost)
{
 if (leftmost)
  root->rb_leftmost = node;
 rb_insert_color(node, &root->rb_root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_erase_cached(struct rb_node *node,
       struct rb_root_cached *root)
{
 if (root->rb_leftmost == node)
  root->rb_leftmost = rb_next(node);
 rb_erase(node, &root->rb_root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_replace_node_cached(struct rb_node *victim,
       struct rb_node *new,
       struct rb_root_cached *root)
{
 if (root->rb_leftmost == victim)
  root->rb_leftmost = new;
 rb_replace_node(victim, new, &root->rb_root);
}
# 11 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rwsem.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/rwsem.h"
# 1 "/home/nathan/src/linux-next/include/linux/err.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/err.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__)) ERR_PTR(long error)
{
 return (void *) error;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __attribute__((__warn_unused_result__)) PTR_ERR( const void *ptr)
{
 return (long) ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) IS_ERR( const void *ptr)
{
 return __builtin_expect(!!((unsigned long)(void *)((unsigned long)ptr) >= (unsigned long)-4095), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) IS_ERR_OR_NULL( const void *ptr)
{
 return __builtin_expect(!!(!ptr), 0) || __builtin_expect(!!((unsigned long)(void *)((unsigned long)ptr) >= (unsigned long)-4095), 0);
}
# 51 "/home/nathan/src/linux-next/include/linux/err.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__)) ERR_CAST( const void *ptr)
{

 return (void *) ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) PTR_ERR_OR_ZERO( const void *ptr)
{
 if (IS_ERR(ptr))
  return PTR_ERR(ptr);
 else
  return 0;
}
# 19 "/home/nathan/src/linux-next/include/linux/rwsem.h" 2
# 35 "/home/nathan/src/linux-next/include/linux/rwsem.h"
struct rw_semaphore {
 atomic_long_t count;





 atomic_long_t owner;

 struct optimistic_spin_queue osq;

 raw_spinlock_t wait_lock;
 struct list_head wait_list;






};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rwsem_is_locked(struct rw_semaphore *sem)
{
 return atomic_long_read(&sem->count) != 0;
}
# 101 "/home/nathan/src/linux-next/include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore *sem, const char *name,
    struct lock_class_key *key);
# 117 "/home/nathan/src/linux-next/include/linux/rwsem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rwsem_is_contended(struct rw_semaphore *sem)
{
 return !list_empty(&sem->wait_list);
}




extern void down_read(struct rw_semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_read_killable(struct rw_semaphore *sem);




extern int down_read_trylock(struct rw_semaphore *sem);




extern void down_write(struct rw_semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_write_killable(struct rw_semaphore *sem);




extern int down_write_trylock(struct rw_semaphore *sem);




extern void up_read(struct rw_semaphore *sem);




extern void up_write(struct rw_semaphore *sem);




extern void downgrade_write(struct rw_semaphore *sem);
# 12 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/uprobes.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/uprobes.h"
struct vm_area_struct;
struct mm_struct;
struct inode;
struct notifier_block;
struct page;






enum uprobe_filter_ctx {
 UPROBE_FILTER_REGISTER,
 UPROBE_FILTER_UNREGISTER,
 UPROBE_FILTER_MMAP,
};

struct uprobe_consumer {
 int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
 int (*ret_handler)(struct uprobe_consumer *self,
    unsigned long func,
    struct pt_regs *regs);
 bool (*filter)(struct uprobe_consumer *self,
    enum uprobe_filter_ctx ctx,
    struct mm_struct *mm);

 struct uprobe_consumer *next;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h"
# 1 "/home/nathan/src/linux-next/include/linux/notifier.h" 1
# 49 "/home/nathan/src/linux-next/include/linux/notifier.h"
struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *nb,
   unsigned long action, void *data);

struct notifier_block {
 notifier_fn_t notifier_call;
 struct notifier_block *next;
 int priority;
};

struct atomic_notifier_head {
 spinlock_t lock;
 struct notifier_block *head;
};

struct blocking_notifier_head {
 struct rw_semaphore rwsem;
 struct notifier_block *head;
};

struct raw_notifier_head {
 struct notifier_block *head;
};

struct srcu_notifier_head {
 struct mutex mutex;
 struct srcu_struct srcu;
 struct notifier_block *head;
};
# 93 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
# 144 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_register(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,
  unsigned long val, void *v);
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
  unsigned long val, void *v);
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int raw_notifier_call_chain(struct raw_notifier_head *nh,
  unsigned long val, void *v);
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
  unsigned long val, void *v);
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
# 190 "/home/nathan/src/linux-next/include/linux/notifier.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notifier_from_errno(int err)
{
 if (err)
  return 0x8000 | (0x0001 - err);

 return 0x0001;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notifier_to_errno(int ret)
{
 ret &= ~0x8000;
 return ret > 0x0001 ? 0x0001 - ret : 0;
}
# 234 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern struct blocking_notifier_head reboot_notifier_list;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
typedef u32 ppc_opcode_t;
# 35 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void enable_single_step(struct pt_regs *regs)
{
 regs->msr |= ((1UL<<(10)));
# 50 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
}
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/inst.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/inst.h"
struct ppc_inst {
 u32 val;

 u32 suffix;

} __attribute__((__packed__));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ppc_inst_val(struct ppc_inst x)
{
 return x.val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ppc_inst_primary_opcode(struct ppc_inst x)
{
 return ppc_inst_val(x) >> 26;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ppc_inst_suffix(struct ppc_inst x)
{
 return x.suffix;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ppc_inst_prefixed(struct ppc_inst x)
{
 return (ppc_inst_primary_opcode(x) == 1) && ppc_inst_suffix(x) != 0xff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ppc_inst ppc_inst_swab(struct ppc_inst x)
{
 return ((struct ppc_inst){ .val = ((__builtin_constant_p((__u32)(ppc_inst_val(x))) ? ((__u32)( (((__u32)(ppc_inst_val(x)) & (__u32)0x000000ffUL) << 24) | (((__u32)(ppc_inst_val(x)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(ppc_inst_val(x)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(ppc_inst_val(x)) & (__u32)0xff000000UL) >> 24))) : __fswab32(ppc_inst_val(x)))), .suffix = ((__builtin_constant_p((__u32)(ppc_inst_suffix(x))) ? ((__u32)( (((__u32)(ppc_inst_suffix(x)) & (__u32)0x000000ffUL) << 24) | (((__u32)(ppc_inst_suffix(x)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(ppc_inst_suffix(x)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(ppc_inst_suffix(x)) & (__u32)0xff000000UL) >> 24))) : __fswab32(ppc_inst_suffix(x)))) });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ppc_inst ppc_inst_read(const struct ppc_inst *ptr)
{
 u32 val, suffix;

 val = *(u32 *)ptr;
 if ((val >> 26) == 1) {
  suffix = *((u32 *)ptr + 1);
  return ((struct ppc_inst){ .val = (val), .suffix = (suffix) });
 } else {
  return ((struct ppc_inst){ .val = (val), .suffix = 0xff });
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ppc_inst_equal(struct ppc_inst x, struct ppc_inst y)
{
 return *(u64 *)&x == *(u64 *)&y;
}
# 98 "/home/nathan/src/linux-next/arch/powerpc/include/asm/inst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ppc_inst_len(struct ppc_inst x)
{
 return ppc_inst_prefixed(x) ? 8 : 4;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ppc_inst *ppc_inst_next(void *location, struct ppc_inst *value)
{
 struct ppc_inst tmp;

 tmp = ppc_inst_read(value);

 return location + ppc_inst_len(tmp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ppc_inst_as_u64(struct ppc_inst x)
{

 return (u64)ppc_inst_suffix(x) << 32 | ppc_inst_val(x);



}

int probe_user_read_inst(struct ppc_inst *inst,
    struct ppc_inst *nip);

int probe_kernel_read_inst(struct ppc_inst *inst,
      struct ppc_inst *src);
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 2

typedef ppc_opcode_t uprobe_opcode_t;
# 25 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h"
struct arch_uprobe {
 union {
  struct ppc_inst insn;
  struct ppc_inst ixol;
 };
};

struct arch_uprobe_task {
 unsigned long saved_trap_nr;
};
# 50 "/home/nathan/src/linux-next/include/linux/uprobes.h" 2

enum uprobe_task_state {
 UTASK_RUNNING,
 UTASK_SSTEP,
 UTASK_SSTEP_ACK,
 UTASK_SSTEP_TRAPPED,
};




struct uprobe_task {
 enum uprobe_task_state state;

 union {
  struct {
   struct arch_uprobe_task autask;
   unsigned long vaddr;
  };

  struct {
   struct callback_head dup_xol_work;
   unsigned long dup_xol_addr;
  };
 };

 struct uprobe *active_uprobe;
 unsigned long xol_vaddr;

 struct return_instance *return_instances;
 unsigned int depth;
};

struct return_instance {
 struct uprobe *uprobe;
 unsigned long func;
 unsigned long stack;
 unsigned long orig_ret_vaddr;
 bool chained;

 struct return_instance *next;
};

enum rp_check {
 RP_CHECK_CALL,
 RP_CHECK_CHAIN_CALL,
 RP_CHECK_RET,
};

struct xol_area;

struct uprobes_state {
 struct xol_area *xol_area;
};

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) uprobes_init(void);
extern int set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
extern int set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
extern bool is_swbp_insn(uprobe_opcode_t *insn);
extern bool is_trap_insn(uprobe_opcode_t *insn);
extern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);
extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
extern int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
extern int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc);
extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
extern int uprobe_mmap(struct vm_area_struct *vma);
extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
extern void uprobe_start_dup_mmap(void);
extern void uprobe_end_dup_mmap(void);
extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
extern void uprobe_free_utask(struct task_struct *t);
extern void uprobe_copy_process(struct task_struct *t, unsigned long flags);
extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
extern void uprobe_notify_resume(struct pt_regs *regs);
extern bool uprobe_deny_signal(void);
extern bool arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
extern void uprobe_clear_state(struct mm_struct *mm);
extern int arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);
extern int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern int arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
extern int arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
extern bool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx, struct pt_regs *regs);
extern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
      void *src, unsigned long len);
# 15 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2
# 26 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct address_space;
struct mem_cgroup;
# 68 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct page {
 unsigned long flags;







 union {
  struct {





   struct list_head lru;

   struct address_space *mapping;
   unsigned long index;






   unsigned long private;
  };
  struct {




   dma_addr_t dma_addr;
  };
  struct {
   union {
    struct list_head slab_list;
    struct {
     struct page *next;

     int pages;
     int pobjects;




    };
   };
   struct kmem_cache *slab_cache;

   void *freelist;
   union {
    void *s_mem;
    unsigned long counters;
    struct {
     unsigned inuse:16;
     unsigned objects:15;
     unsigned frozen:1;
    };
   };
  };
  struct {
   unsigned long compound_head;


   unsigned char compound_dtor;
   unsigned char compound_order;
   atomic_t compound_mapcount;
  };
  struct {
   unsigned long _compound_pad_1;
   atomic_t hpage_pinned_refcount;

   struct list_head deferred_list;
  };
  struct {
   unsigned long _pt_pad_1;
   pgtable_t pmd_huge_pte;
   unsigned long _pt_pad_2;
   union {
    struct mm_struct *pt_mm;
    atomic_t pt_frag_refcount;
   };



   spinlock_t ptl;

  };
  struct {

   struct dev_pagemap *pgmap;
   void *zone_device_data;
# 172 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  };


  struct callback_head callback_head;
 };

 union {




  atomic_t _mapcount;







  unsigned int page_type;

  unsigned int active;
  int units;
 };


 atomic_t _refcount;


 struct mem_cgroup *mem_cgroup;
# 222 "/home/nathan/src/linux-next/include/linux/mm_types.h"
} ;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) atomic_t *compound_mapcount_ptr(struct page *page)
{
 return &page[1].compound_mapcount;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) atomic_t *compound_pincount_ptr(struct page *page)
{
 return &page[2].hpage_pinned_refcount;
}
# 244 "/home/nathan/src/linux-next/include/linux/mm_types.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_private(struct page *page, unsigned long private)
{
 page->private = private;
}

struct page_frag_cache {
 void * va;




 __u32 offset;




 unsigned int pagecnt_bias;
 bool pfmemalloc;
};

typedef unsigned long vm_flags_t;






struct vm_region {
 struct rb_node vm_rb;
 vm_flags_t vm_flags;
 unsigned long vm_start;
 unsigned long vm_end;
 unsigned long vm_top;
 unsigned long vm_pgoff;
 struct file *vm_file;

 int vm_usage;
 bool vm_icache_flushed : 1;

};



struct vm_userfaultfd_ctx {
 struct userfaultfd_ctx *ctx;
};
# 301 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct vm_area_struct {


 unsigned long vm_start;
 unsigned long vm_end;



 struct vm_area_struct *vm_next, *vm_prev;

 struct rb_node vm_rb;







 unsigned long rb_subtree_gap;



 struct mm_struct *vm_mm;





 pgprot_t vm_page_prot;
 unsigned long vm_flags;





 struct {
  struct rb_node rb;
  unsigned long rb_subtree_last;
 } shared;







 struct list_head anon_vma_chain;

 struct anon_vma *anon_vma;


 const struct vm_operations_struct *vm_ops;


 unsigned long vm_pgoff;

 struct file * vm_file;
 void * vm_private_data;


 atomic_long_t swap_readahead_info;





 struct mempolicy *vm_policy;

 struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
} ;

struct core_thread {
 struct task_struct *task;
 struct core_thread *next;
};

struct core_state {
 atomic_t nr_threads;
 struct core_thread dumper;
 struct completion startup;
};

struct kioctx_table;
struct mm_struct {
 struct {
  struct vm_area_struct *mmap;
  struct rb_root mm_rb;
  u64 vmacache_seqnum;

  unsigned long (*get_unmapped_area) (struct file *filp,
    unsigned long addr, unsigned long len,
    unsigned long pgoff, unsigned long flags);

  unsigned long mmap_base;
  unsigned long mmap_legacy_base;





  unsigned long task_size;
  unsigned long highest_vm_end;
  pgd_t * pgd;
# 412 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t membarrier_state;
# 424 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t mm_users;
# 433 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t mm_count;


  atomic_long_t pgtables_bytes;

  int map_count;

  spinlock_t page_table_lock;


  struct rw_semaphore mmap_lock;

  struct list_head mmlist;






  unsigned long hiwater_rss;
  unsigned long hiwater_vm;

  unsigned long total_vm;
  unsigned long locked_vm;
  atomic64_t pinned_vm;
  unsigned long data_vm;
  unsigned long exec_vm;
  unsigned long stack_vm;
  unsigned long def_flags;

  spinlock_t arg_lock;
  unsigned long start_code, end_code, start_data, end_data;
  unsigned long start_brk, brk, start_stack;
  unsigned long arg_start, arg_end, env_start, env_end;

  unsigned long saved_auxv[(2*(14 + 20 + 1))];





  struct mm_rss_stat rss_stat;

  struct linux_binfmt *binfmt;


  mm_context_t context;

  unsigned long flags;

  struct core_state *core_state;


  spinlock_t ioctx_lock;
  struct kioctx_table *ioctx_table;
# 500 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  struct task_struct *owner;

  struct user_namespace *user_ns;


  struct file *exe_file;

  struct mmu_notifier_subscriptions *notifier_subscriptions;
# 518 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  unsigned long numa_next_scan;


  unsigned long numa_scan_offset;


  int numa_scan_seq;






  atomic_t tlb_flush_pending;




  struct uprobes_state uprobes_state;

  atomic_long_t hugetlb_usage;

  struct work_struct async_put_work;
 } ;





 unsigned long cpu_bitmap[];
};

extern struct mm_struct init_mm;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_init_cpumask(struct mm_struct *mm)
{
 unsigned long cpu_bitmap = (unsigned long)mm;

 cpu_bitmap += __builtin_offsetof(struct mm_struct, cpu_bitmap);
 cpumask_clear((struct cpumask *)cpu_bitmap);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) cpumask_t *mm_cpumask(struct mm_struct *mm)
{
 return (struct cpumask *)&mm->cpu_bitmap;
}

struct mmu_gather;
extern void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,
    unsigned long start, unsigned long end);
extern void tlb_finish_mmu(struct mmu_gather *tlb,
    unsigned long start, unsigned long end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_tlb_flush_pending(struct mm_struct *mm)
{
 atomic_set(&mm->tlb_flush_pending, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_tlb_flush_pending(struct mm_struct *mm)
{
 atomic_inc(&mm->tlb_flush_pending);
# 617 "/home/nathan/src/linux-next/include/linux/mm_types.h"
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_tlb_flush_pending(struct mm_struct *mm)
{
# 629 "/home/nathan/src/linux-next/include/linux/mm_types.h"
 atomic_dec(&mm->tlb_flush_pending);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mm_tlb_flush_pending(struct mm_struct *mm)
{
# 642 "/home/nathan/src/linux-next/include/linux/mm_types.h"
 return atomic_read(&mm->tlb_flush_pending);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mm_tlb_flush_nested(struct mm_struct *mm)
{







 return atomic_read(&mm->tlb_flush_pending) > 1;
}

struct vm_fault;






typedef unsigned int vm_fault_t;
# 691 "/home/nathan/src/linux-next/include/linux/mm_types.h"
enum vm_fault_reason {
 VM_FAULT_OOM = ( vm_fault_t)0x000001,
 VM_FAULT_SIGBUS = ( vm_fault_t)0x000002,
 VM_FAULT_MAJOR = ( vm_fault_t)0x000004,
 VM_FAULT_WRITE = ( vm_fault_t)0x000008,
 VM_FAULT_HWPOISON = ( vm_fault_t)0x000010,
 VM_FAULT_HWPOISON_LARGE = ( vm_fault_t)0x000020,
 VM_FAULT_SIGSEGV = ( vm_fault_t)0x000040,
 VM_FAULT_NOPAGE = ( vm_fault_t)0x000100,
 VM_FAULT_LOCKED = ( vm_fault_t)0x000200,
 VM_FAULT_RETRY = ( vm_fault_t)0x000400,
 VM_FAULT_FALLBACK = ( vm_fault_t)0x000800,
 VM_FAULT_DONE_COW = ( vm_fault_t)0x001000,
 VM_FAULT_NEEDDSYNC = ( vm_fault_t)0x002000,
 VM_FAULT_HINDEX_MASK = ( vm_fault_t)0x0f0000,
};
# 731 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct vm_special_mapping {
 const char *name;







 struct page **pages;





 vm_fault_t (*fault)(const struct vm_special_mapping *sm,
    struct vm_area_struct *vma,
    struct vm_fault *vmf);

 int (*mremap)(const struct vm_special_mapping *sm,
       struct vm_area_struct *new_vma);
};

enum tlb_flush_reason {
 TLB_FLUSH_ON_TASK_SWITCH,
 TLB_REMOTE_SHOOTDOWN,
 TLB_LOCAL_SHOOTDOWN,
 TLB_LOCAL_MM_SHOOTDOWN,
 TLB_REMOTE_SEND_IPI,
 NR_TLB_FLUSH_REASONS,
};





typedef struct {
 unsigned long val;
} swp_entry_t;
# 22 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/page-flags.h" 1
# 104 "/home/nathan/src/linux-next/include/linux/page-flags.h"
enum pageflags {
 PG_locked,
 PG_referenced,
 PG_uptodate,
 PG_dirty,
 PG_lru,
 PG_active,
 PG_workingset,
 PG_waiters,
 PG_error,
 PG_slab,
 PG_owner_priv_1,
 PG_arch_1,
 PG_reserved,
 PG_private,
 PG_private_2,
 PG_writeback,
 PG_head,
 PG_mappedtodisk,
 PG_reclaim,
 PG_swapbacked,
 PG_unevictable,

 PG_mlocked,





 PG_hwpoison,





 __NR_PAGEFLAGS,


 PG_checked = PG_owner_priv_1,


 PG_swapcache = PG_owner_priv_1,





 PG_fscache = PG_private_2,



 PG_pinned = PG_owner_priv_1,

 PG_savepinned = PG_dirty,

 PG_foreign = PG_owner_priv_1,

 PG_xen_remapped = PG_owner_priv_1,


 PG_slob_free = PG_private,


 PG_double_map = PG_private_2,


 PG_isolated = PG_reclaim,


 PG_reported = PG_uptodate,
};



struct page;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *compound_head(struct page *page)
{
 unsigned long head = ({ do { extern void __compiletime_assert_65(void) ; if (!((sizeof(page->compound_head) == sizeof(char) || sizeof(page->compound_head) == sizeof(short) || sizeof(page->compound_head) == sizeof(int) || sizeof(page->compound_head) == sizeof(long)) || sizeof(page->compound_head) == sizeof(long long))) __compiletime_assert_65(); } while (0); ({ typeof( _Generic((page->compound_head), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (page->compound_head))) __x = (*(const volatile typeof( _Generic((page->compound_head), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (page->compound_head))) *)&(page->compound_head)); do { } while (0); (typeof(page->compound_head))__x; }); });

 if (__builtin_expect(!!(head & 1), 0))
  return (struct page *) (head - 1);
 return page;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageTail(struct page *page)
{
 return ({ do { extern void __compiletime_assert_66(void) ; if (!((sizeof(page->compound_head) == sizeof(char) || sizeof(page->compound_head) == sizeof(short) || sizeof(page->compound_head) == sizeof(int) || sizeof(page->compound_head) == sizeof(long)) || sizeof(page->compound_head) == sizeof(long long))) __compiletime_assert_66(); } while (0); ({ typeof( _Generic((page->compound_head), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (page->compound_head))) __x = (*(const volatile typeof( _Generic((page->compound_head), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (page->compound_head))) *)&(page->compound_head)); do { } while (0); (typeof(page->compound_head))__x; }); }) & 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageCompound(struct page *page)
{
 return test_bit(PG_head, &page->flags) || PageTail(page);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PagePoisoned(const struct page *page)
{
 return page->flags == -1l;
}


void page_init_poison(struct page *page, size_t size);
# 320 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageLocked(struct page *page) { return test_bit(PG_locked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageLocked(struct page *page) { __set_bit(PG_locked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageLocked(struct page *page) { __clear_bit(PG_locked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWaiters(struct page *page) { return test_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageWaiters(struct page *page) { set_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageWaiters(struct page *page) { clear_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageWaiters(struct page *page) { __clear_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageError(struct page *page) { return test_bit(PG_error, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageError(struct page *page) { set_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageError(struct page *page) { clear_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageError(struct page *page) { return test_and_clear_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReferenced(struct page *page) { return test_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReferenced(struct page *page) { set_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReferenced(struct page *page) { clear_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReferenced(struct page *page) { return test_and_clear_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageReferenced(struct page *page) { __set_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageDirty(struct page *page) { return test_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageDirty(struct page *page) { set_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageDirty(struct page *page) { clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageDirty(struct page *page) { return test_and_set_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageDirty(struct page *page) { return test_and_clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageDirty(struct page *page) { __clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageLRU(struct page *page) { return test_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageLRU(struct page *page) { set_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageLRU(struct page *page) { clear_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageLRU(struct page *page) { __clear_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageActive(struct page *page) { return test_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageActive(struct page *page) { set_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageActive(struct page *page) { clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageActive(struct page *page) { __clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageActive(struct page *page) { return test_and_clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWorkingset(struct page *page) { return test_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageWorkingset(struct page *page) { set_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageWorkingset(struct page *page) { clear_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageWorkingset(struct page *page) { return test_and_clear_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSlab(struct page *page) { return test_bit(PG_slab, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSlab(struct page *page) { __set_bit(PG_slab, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSlab(struct page *page) { __clear_bit(PG_slab, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSlobFree(struct page *page) { return test_bit(PG_slob_free, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSlobFree(struct page *page) { __set_bit(PG_slob_free, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSlobFree(struct page *page) { __clear_bit(PG_slob_free, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageChecked(struct page *page) { return test_bit(PG_checked, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageChecked(struct page *page) { set_bit(PG_checked, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageChecked(struct page *page) { clear_bit(PG_checked, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePinned(struct page *page) { return test_bit(PG_pinned, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePinned(struct page *page) { set_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePinned(struct page *page) { clear_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPagePinned(struct page *page) { return test_and_set_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPagePinned(struct page *page) { return test_and_clear_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSavePinned(struct page *page) { return test_bit(PG_savepinned, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSavePinned(struct page *page) { set_bit(PG_savepinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSavePinned(struct page *page) { clear_bit(PG_savepinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageForeign(struct page *page) { return test_bit(PG_foreign, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageForeign(struct page *page) { set_bit(PG_foreign, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageForeign(struct page *page) { clear_bit(PG_foreign, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageXenRemapped(struct page *page) { return test_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageXenRemapped(struct page *page) { set_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageXenRemapped(struct page *page) { clear_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageXenRemapped(struct page *page) { return test_and_clear_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReserved(struct page *page) { return test_bit(PG_reserved, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReserved(struct page *page) { set_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReserved(struct page *page) { clear_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageReserved(struct page *page) { __clear_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageReserved(struct page *page) { __set_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSwapBacked(struct page *page) { return test_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSwapBacked(struct page *page) { set_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSwapBacked(struct page *page) { clear_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSwapBacked(struct page *page) { __clear_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSwapBacked(struct page *page) { __set_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePrivate(struct page *page) { return test_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePrivate(struct page *page) { set_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePrivate(struct page *page) { clear_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPagePrivate(struct page *page) { __set_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPagePrivate(struct page *page) { __clear_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePrivate2(struct page *page) { return test_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePrivate2(struct page *page) { set_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePrivate2(struct page *page) { clear_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPagePrivate2(struct page *page) { return test_and_set_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPagePrivate2(struct page *page) { return test_and_clear_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageOwnerPriv1(struct page *page) { return test_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageOwnerPriv1(struct page *page) { set_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageOwnerPriv1(struct page *page) { clear_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageOwnerPriv1(struct page *page) { return test_and_clear_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWriteback(struct page *page) { return test_bit(PG_writeback, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageWriteback(struct page *page) { return test_and_set_bit(PG_writeback, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageWriteback(struct page *page) { return test_and_clear_bit(PG_writeback, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMappedToDisk(struct page *page) { return test_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageMappedToDisk(struct page *page) { set_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageMappedToDisk(struct page *page) { clear_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReclaim(struct page *page) { return test_bit(PG_reclaim, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReclaim(struct page *page) { set_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReclaim(struct page *page) { clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReclaim(struct page *page) { return test_and_clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReadahead(struct page *page) { return test_bit(PG_reclaim, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReadahead(struct page *page) { set_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReadahead(struct page *page) { clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReadahead(struct page *page) { return test_and_clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
# 384 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageHighMem(const struct page *page) { return 0; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageHighMem(struct page *page) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageHighMem(struct page *page) { }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSwapCache(struct page *page)
{



 return PageSwapBacked(page) && test_bit(PG_swapcache, &page->flags);

}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSwapCache(struct page *page) { set_bit(PG_swapcache, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSwapCache(struct page *page) { clear_bit(PG_swapcache, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageUnevictable(struct page *page) { return test_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageUnevictable(struct page *page) { set_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageUnevictable(struct page *page) { clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageUnevictable(struct page *page) { __clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageUnevictable(struct page *page) { return test_and_clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMlocked(struct page *page) { return test_bit(PG_mlocked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageMlocked(struct page *page) { set_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageMlocked(struct page *page) { clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageMlocked(struct page *page) { __clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageMlocked(struct page *page) { return test_and_set_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageMlocked(struct page *page) { return test_and_clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
# 418 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageUncached(const struct page *page) { return 0; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageUncached(struct page *page) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageUncached(struct page *page) { }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageHWPoison(struct page *page) { return test_bit(PG_hwpoison, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageHWPoison(struct page *page) { set_bit(PG_hwpoison, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageHWPoison(struct page *page) { clear_bit(PG_hwpoison, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageHWPoison(struct page *page) { return test_and_set_bit(PG_hwpoison, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageHWPoison(struct page *page) { return test_and_clear_bit(PG_hwpoison, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }

extern bool set_hwpoison_free_buddy_page(struct page *page);
# 448 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReported(struct page *page) { return test_bit(PG_reported, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageReported(struct page *page) { __set_bit(PG_reported, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageReported(struct page *page) { __clear_bit(PG_reported, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
# 472 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMappingFlags(struct page *page)
{
 return ((unsigned long)page->mapping & (0x1 | 0x2)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageAnon(struct page *page)
{
 page = compound_head(page);
 return ((unsigned long)page->mapping & 0x1) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int __PageMovable(struct page *page)
{
 return ((unsigned long)page->mapping & (0x1 | 0x2)) ==
    0x2;
}
# 496 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageKsm(struct page *page)
{
 page = compound_head(page);
 return ((unsigned long)page->mapping & (0x1 | 0x2)) ==
    (0x1 | 0x2);
}




u64 stable_page_flags(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageUptodate(struct page *page)
{
 int ret;
 page = compound_head(page);
 ret = test_bit(PG_uptodate, &(page)->flags);
# 521 "/home/nathan/src/linux-next/include/linux/page-flags.h"
 if (ret)
  __asm__ __volatile__ ("lwsync" " " : : :"memory");

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageUptodate(struct page *page)
{
 do { if (__builtin_expect(!!(PageTail(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "PageTail(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (529), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 __set_bit(PG_uptodate, &page->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageUptodate(struct page *page)
{
 do { if (__builtin_expect(!!(PageTail(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "PageTail(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (536), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);





 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 set_bit(PG_uptodate, &page->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageUptodate(struct page *page) { clear_bit(PG_uptodate, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }

int test_clear_page_writeback(struct page *page);
int __test_set_page_writeback(struct page *page, bool keep_write);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_writeback(struct page *page)
{
 __test_set_page_writeback(page, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_writeback_keepwrite(struct page *page)
{
 __test_set_page_writeback(page, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageHead(struct page *page) { return test_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageHead(struct page *page) { __set_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageHead(struct page *page) { __clear_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageHead(struct page *page) { clear_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void set_compound_head(struct page *page, struct page *head)
{
 do { do { extern void __compiletime_assert_67(void) ; if (!((sizeof(page->compound_head) == sizeof(char) || sizeof(page->compound_head) == sizeof(short) || sizeof(page->compound_head) == sizeof(int) || sizeof(page->compound_head) == sizeof(long)) || sizeof(page->compound_head) == sizeof(long long))) __compiletime_assert_67(); } while (0); do { *(volatile typeof(page->compound_head) *)&(page->compound_head) = ((unsigned long)head + 1); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void clear_compound_head(struct page *page)
{
 do { do { extern void __compiletime_assert_68(void) ; if (!((sizeof(page->compound_head) == sizeof(char) || sizeof(page->compound_head) == sizeof(short) || sizeof(page->compound_head) == sizeof(int) || sizeof(page->compound_head) == sizeof(long)) || sizeof(page->compound_head) == sizeof(long long))) __compiletime_assert_68(); } while (0); do { *(volatile typeof(page->compound_head) *)&(page->compound_head) = (0); } while (0); } while (0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageCompound(struct page *page)
{
 do { if (__builtin_constant_p(!PageHead(page))) { if (!PageHead(page)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (581), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (581), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!PageHead(page)))); } } while (0);
 ClearPageHead(page);
}





int PageHuge(struct page *page);
int PageHeadHuge(struct page *page);
bool page_huge_active(struct page *page);
# 612 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransHuge(struct page *page)
{
 do { if (__builtin_expect(!!(PageTail(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "PageTail(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (614), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 return PageHead(page);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransCompound(struct page *page)
{
 return PageCompound(page);
}
# 649 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransCompoundMap(struct page *page)
{
 struct page *head;

 if (!PageTransCompound(page))
  return 0;

 if (PageAnon(page))
  return atomic_read(&page->_mapcount) < 0;

 head = compound_head(page);

 return atomic_read(&page->_mapcount) ==
        atomic_read(compound_mapcount_ptr(head));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransTail(struct page *page)
{
 return PageTail(page);
}
# 688 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageDoubleMap(struct page *page)
{
 return PageHead(page) && test_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageDoubleMap(struct page *page)
{
 do { if (__builtin_expect(!!(!PageHead(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageHead(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (695), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 set_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageDoubleMap(struct page *page)
{
 do { if (__builtin_expect(!!(!PageHead(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageHead(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (701), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 clear_bit(PG_double_map, &page[1].flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int TestSetPageDoubleMap(struct page *page)
{
 do { if (__builtin_expect(!!(!PageHead(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageHead(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (706), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 return test_and_set_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int TestClearPageDoubleMap(struct page *page)
{
 do { if (__builtin_expect(!!(!PageHead(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageHead(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (712), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 return test_and_clear_bit(PG_double_map, &page[1].flags);
}
# 747 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_has_type(struct page *page)
{
 return (int)page->page_type < -128;
}
# 772 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageBuddy(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000080)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageBuddy(struct page *page) { do { if (__builtin_expect(!!(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (772), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type &= ~0x00000080; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageBuddy(struct page *page) { do { if (__builtin_expect(!!(!PageBuddy(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageBuddy(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (772), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type |= 0x00000080; }
# 791 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageOffline(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000100)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageOffline(struct page *page) { do { if (__builtin_expect(!!(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (791), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type &= ~0x00000100; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageOffline(struct page *page) { do { if (__builtin_expect(!!(!PageOffline(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageOffline(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (791), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type |= 0x00000100; }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageKmemcg(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000200)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageKmemcg(struct page *page) { do { if (__builtin_expect(!!(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (797), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type &= ~0x00000200; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageKmemcg(struct page *page) { do { if (__builtin_expect(!!(!PageKmemcg(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageKmemcg(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (797), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type |= 0x00000200; }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageTable(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000400)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageTable(struct page *page) { do { if (__builtin_expect(!!(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (802), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type &= ~0x00000400; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageTable(struct page *page) { do { if (__builtin_expect(!!(!PageTable(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageTable(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (802), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type |= 0x00000400; }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageGuard(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000800)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageGuard(struct page *page) { do { if (__builtin_expect(!!(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!((page->page_type & (0xf0000000 | 0)) == 0xf0000000)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (807), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type &= ~0x00000800; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageGuard(struct page *page) { do { if (__builtin_expect(!!(!PageGuard(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageGuard(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (807), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0); page->page_type |= 0x00000800; }

extern bool is_free_buddy_page(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageIsolated(struct page *page) { return test_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageIsolated(struct page *page) { __set_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageIsolated(struct page *page) { __clear_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); };





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageSlabPfmemalloc(struct page *page)
{
 do { if (__builtin_expect(!!(!PageSlab(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageSlab(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (819), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 return PageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageSlabPfmemalloc(struct page *page)
{
 do { if (__builtin_expect(!!(!PageSlab(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageSlab(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (825), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 SetPageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ClearPageSlabPfmemalloc(struct page *page)
{
 do { if (__builtin_expect(!!(!PageSlab(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageSlab(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (831), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 __ClearPageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageSlabPfmemalloc(struct page *page)
{
 do { if (__builtin_expect(!!(!PageSlab(page)), 0)) { dump_page(page, "VM_BUG_ON_PAGE(" "!PageSlab(page)"")"); do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (837), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } } while (0);
 ClearPageActive(page);
}
# 878 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_has_private(struct page *page)
{
 return !!(page->flags & (1UL << PG_private | 1UL << PG_private_2));
}
# 23 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 41 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum migratetype {
 MIGRATE_UNMOVABLE,
 MIGRATE_MOVABLE,
 MIGRATE_RECLAIMABLE,
 MIGRATE_PCPTYPES,
 MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
# 61 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 MIGRATE_CMA,


 MIGRATE_ISOLATE,

 MIGRATE_TYPES
};


extern const char * const migratetype_names[MIGRATE_TYPES];
# 80 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_migrate_movable(int mt)
{
 return __builtin_expect(!!((mt) == MIGRATE_CMA), 0) || mt == MIGRATE_MOVABLE;
}





extern int page_group_by_mobility_disabled;
# 98 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct free_area {
 struct list_head free_list[MIGRATE_TYPES];
 unsigned long nr_free;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *get_page_from_free_area(struct free_area *area,
         int migratetype)
{
 return ({ struct list_head *head__ = (&area->free_list[migratetype]); struct list_head *pos__ = ({ do { extern void __compiletime_assert_69(void) ; if (!((sizeof(head__->next) == sizeof(char) || sizeof(head__->next) == sizeof(short) || sizeof(head__->next) == sizeof(int) || sizeof(head__->next) == sizeof(long)) || sizeof(head__->next) == sizeof(long long))) __compiletime_assert_69(); } while (0); ({ typeof( _Generic((head__->next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head__->next))) __x = (*(const volatile typeof( _Generic((head__->next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (head__->next))) *)&(head__->next)); do { } while (0); (typeof(head__->next))__x; }); }); pos__ != head__ ? ({ void *__mptr = (void *)(pos__); do { extern void __compiletime_assert_70(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(pos__)), typeof(((struct page *)0)->lru)) && !__builtin_types_compatible_p(typeof(*(pos__)), typeof(void))))) __compiletime_assert_70(); } while (0); ((struct page *)(__mptr - __builtin_offsetof(struct page, lru))); }) : ((void *)0); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool free_area_empty(struct free_area *area, int migratetype)
{
 return list_empty(&area->free_list[migratetype]);
}

struct pglist_data;
# 124 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct zone_padding {
 char x[0];
} __attribute__((__aligned__(1 << (7))));






enum numa_stat_item {
 NUMA_HIT,
 NUMA_MISS,
 NUMA_FOREIGN,
 NUMA_INTERLEAVE_HIT,
 NUMA_LOCAL,
 NUMA_OTHER,
 NR_VM_NUMA_STAT_ITEMS
};




enum zone_stat_item {

 NR_FREE_PAGES,
 NR_ZONE_LRU_BASE,
 NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,
 NR_ZONE_ACTIVE_ANON,
 NR_ZONE_INACTIVE_FILE,
 NR_ZONE_ACTIVE_FILE,
 NR_ZONE_UNEVICTABLE,
 NR_ZONE_WRITE_PENDING,
 NR_MLOCK,
 NR_PAGETABLE,
 NR_KERNEL_STACK_KB,




 NR_BOUNCE,

 NR_ZSPAGES,

 NR_FREE_CMA_PAGES,
 NR_VM_ZONE_STAT_ITEMS };

enum node_stat_item {
 NR_LRU_BASE,
 NR_INACTIVE_ANON = NR_LRU_BASE,
 NR_ACTIVE_ANON,
 NR_INACTIVE_FILE,
 NR_ACTIVE_FILE,
 NR_UNEVICTABLE,
 NR_SLAB_RECLAIMABLE,
 NR_SLAB_UNRECLAIMABLE,
 NR_ISOLATED_ANON,
 NR_ISOLATED_FILE,
 WORKINGSET_NODES,
 WORKINGSET_REFAULT,
 WORKINGSET_ACTIVATE,
 WORKINGSET_RESTORE,
 WORKINGSET_NODERECLAIM,
 NR_ANON_MAPPED,
 NR_FILE_MAPPED,

 NR_FILE_PAGES,
 NR_FILE_DIRTY,
 NR_WRITEBACK,
 NR_WRITEBACK_TEMP,
 NR_SHMEM,
 NR_SHMEM_THPS,
 NR_SHMEM_PMDMAPPED,
 NR_FILE_THPS,
 NR_FILE_PMDMAPPED,
 NR_ANON_THPS,
 NR_VMSCAN_WRITE,
 NR_VMSCAN_IMMEDIATE,
 NR_DIRTIED,
 NR_WRITTEN,
 NR_KERNEL_MISC_RECLAIMABLE,
 NR_FOLL_PIN_ACQUIRED,
 NR_FOLL_PIN_RELEASED,
 NR_VM_NODE_STAT_ITEMS
};
# 222 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum lru_list {
 LRU_INACTIVE_ANON = 0,
 LRU_ACTIVE_ANON = 0 + 1,
 LRU_INACTIVE_FILE = 0 + 2,
 LRU_ACTIVE_FILE = 0 + 2 + 1,
 LRU_UNEVICTABLE,
 NR_LRU_LISTS
};





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_file_lru(enum lru_list lru)
{
 return (lru == LRU_INACTIVE_FILE || lru == LRU_ACTIVE_FILE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_active_lru(enum lru_list lru)
{
 return (lru == LRU_ACTIVE_ANON || lru == LRU_ACTIVE_FILE);
}

enum lruvec_flags {
 LRUVEC_CONGESTED,


};

struct lruvec {
 struct list_head lists[NR_LRU_LISTS];





 unsigned long anon_cost;
 unsigned long file_cost;

 atomic_long_t inactive_age;

 unsigned long refaults;

 unsigned long flags;

 struct pglist_data *pgdat;

};
# 279 "/home/nathan/src/linux-next/include/linux/mmzone.h"
typedef unsigned isolate_mode_t;

enum zone_watermarks {
 WMARK_MIN,
 WMARK_LOW,
 WMARK_HIGH,
 NR_WMARK
};






struct per_cpu_pages {
 int count;
 int high;
 int batch;


 struct list_head lists[MIGRATE_PCPTYPES];
};

struct per_cpu_pageset {
 struct per_cpu_pages pcp;

 s8 expire;
 u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];


 s8 stat_threshold;
 s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];

};

struct per_cpu_nodestat {
 s8 stat_threshold;
 s8 vm_node_stat_diff[NR_VM_NODE_STAT_ITEMS];
};



enum zone_type {
# 363 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 ZONE_NORMAL,
# 375 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 ZONE_MOVABLE,

 ZONE_DEVICE,

 __MAX_NR_ZONES

};



struct zone {



 unsigned long _watermark[NR_WMARK];
 unsigned long watermark_boost;

 unsigned long nr_reserved_highatomic;
# 403 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 long lowmem_reserve[3];


 int node;

 struct pglist_data *zone_pgdat;
 struct per_cpu_pageset *pageset;
# 420 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned long zone_start_pfn;
# 457 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 atomic_long_t managed_pages;
 unsigned long spanned_pages;
 unsigned long present_pages;

 const char *name;







 unsigned long nr_isolate_pageblock;




 seqlock_t span_seqlock;


 int initialized;


 struct zone_padding _pad1_;


 struct free_area free_area[9];


 unsigned long flags;


 spinlock_t lock;


 struct zone_padding _pad2_;






 unsigned long percpu_drift_mark;



 unsigned long compact_cached_free_pfn;

 unsigned long compact_cached_migrate_pfn[2];
 unsigned long compact_init_migrate_pfn;
 unsigned long compact_init_free_pfn;
# 516 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned int compact_considered;
 unsigned int compact_defer_shift;
 int compact_order_failed;




 bool compact_blockskip_flush;


 bool contiguous;

 struct zone_padding _pad3_;

 atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
 atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];
} __attribute__((__aligned__(1 << (7))));

enum pgdat_flags {
 PGDAT_DIRTY,



 PGDAT_WRITEBACK,


 PGDAT_RECLAIM_LOCKED,
};

enum zone_flags {
 ZONE_BOOSTED_WATERMARK,


};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_managed_pages(struct zone *zone)
{
 return (unsigned long)atomic_long_read(&zone->managed_pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_end_pfn(const struct zone *zone)
{
 return zone->zone_start_pfn + zone->spanned_pages;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_spans_pfn(const struct zone *zone, unsigned long pfn)
{
 return zone->zone_start_pfn <= pfn && pfn < zone_end_pfn(zone);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_is_initialized(struct zone *zone)
{
 return zone->initialized;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_is_empty(struct zone *zone)
{
 return zone->spanned_pages == 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_intersects(struct zone *zone,
  unsigned long start_pfn, unsigned long nr_pages)
{
 if (zone_is_empty(zone))
  return false;
 if (start_pfn >= zone_end_pfn(zone) ||
     start_pfn + nr_pages <= zone->zone_start_pfn)
  return false;

 return true;
}
# 602 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum {
 ZONELIST_FALLBACK,





 ZONELIST_NOFALLBACK,

 MAX_ZONELISTS
};





struct zoneref {
 struct zone *zone;
 int zone_idx;
};
# 637 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct zonelist {
 struct zoneref _zonerefs[((1 << 8) * 3) + 1];
};



extern struct page *mem_map;



struct deferred_split {
 spinlock_t split_queue_lock;
 struct list_head split_queue;
 unsigned long split_queue_len;
};
# 662 "/home/nathan/src/linux-next/include/linux/mmzone.h"
typedef struct pglist_data {





 struct zone node_zones[3];






 struct zonelist node_zonelists[MAX_ZONELISTS];

 int nr_zones;
# 697 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 spinlock_t node_size_lock;

 unsigned long node_start_pfn;
 unsigned long node_present_pages;
 unsigned long node_spanned_pages;

 int node_id;
 wait_queue_head_t kswapd_wait;
 wait_queue_head_t pfmemalloc_wait;
 struct task_struct *kswapd;

 int kswapd_order;
 enum zone_type kswapd_highest_zoneidx;

 int kswapd_failures;


 int kcompactd_max_order;
 enum zone_type kcompactd_highest_zoneidx;
 wait_queue_head_t kcompactd_wait;
 struct task_struct *kcompactd;





 unsigned long totalreserve_pages;





 unsigned long min_unmapped_pages;
 unsigned long min_slab_pages;



 struct zone_padding _pad1_;
 spinlock_t lru_lock;
# 746 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 struct deferred_split deferred_split_queue;
# 756 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 struct lruvec __lruvec;

 unsigned long flags;

 struct zone_padding _pad2_;


 struct per_cpu_nodestat *per_cpu_nodestats;
 atomic_long_t vm_stat[NR_VM_NODE_STAT_ITEMS];
} pg_data_t;
# 779 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pgdat_end_pfn(pg_data_t *pgdat)
{
 return pgdat->node_start_pfn + pgdat->node_spanned_pages;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgdat_is_empty(pg_data_t *pgdat)
{
 return !pgdat->node_start_pfn && !pgdat->node_spanned_pages;
}


# 1 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/mmzone.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h" 2




struct page;
struct zone;
struct pglist_data;
struct mem_section;
struct memory_block;
struct resource;
struct vmem_altmap;
# 40 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
enum {
 MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
 SECTION_INFO = MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE,
 MIX_SECTION_INFO,
 NODE_INFO,
 MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = NODE_INFO,
};


enum {

 MMOP_OFFLINE = 0,

 MMOP_ONLINE,

 MMOP_ONLINE_KERNEL,

 MMOP_ONLINE_MOVABLE,
};







struct mhp_params {
 struct vmem_altmap *altmap;
 pgprot_t pgprot;
};
# 78 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned zone_span_seqbegin(struct zone *zone)
{
 return read_seqbegin(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zone_span_seqretry(struct zone *zone, unsigned iv)
{
 return read_seqretry(&zone->span_seqlock, iv);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_span_writelock(struct zone *zone)
{
 write_seqlock(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_span_writeunlock(struct zone *zone)
{
 write_sequnlock(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_seqlock_init(struct zone *zone)
{
 do { __seqcount_init(&(&zone->span_seqlock)->seqcount, ((void *)0), ((void *)0)); do { spinlock_check(&(&zone->span_seqlock)->lock); *(&(&zone->span_seqlock)->lock) = (spinlock_t) { { .rlock = { .raw_lock = { 0 }, } } }; } while (0); } while (0);
}
extern int zone_grow_free_lists(struct zone *zone, unsigned long new_nr_pages);
extern int zone_grow_waitqueues(struct zone *zone, unsigned long nr_pages);
extern int add_one_highpage(struct page *page, int pfn, int bad_ppro);

extern int online_pages(unsigned long pfn, unsigned long nr_pages,
   int online_type, int nid);
extern struct zone *test_pages_in_a_zone(unsigned long start_pfn,
      unsigned long end_pfn);
extern unsigned long __offline_isolated_pages(unsigned long start_pfn,
      unsigned long end_pfn);

typedef void (*online_page_callback_t)(struct page *page, unsigned int order);

extern void generic_online_page(struct page *page, unsigned int order);
extern int set_online_page_callback(online_page_callback_t callback);
extern int restore_online_page_callback(online_page_callback_t callback);

extern int try_online_node(int nid);

extern int arch_add_memory(int nid, u64 start, u64 size,
      struct mhp_params *params);
extern u64 max_mem_size;

extern int memhp_online_type_from_str(const char *str);


extern int memhp_default_online_type;

extern bool movable_node_enabled;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool movable_node_is_enabled(void)
{
 return movable_node_enabled;
}

extern void arch_remove_memory(int nid, u64 start, u64 size,
          struct vmem_altmap *altmap);
extern void __remove_pages(unsigned long start_pfn, unsigned long nr_pages,
      struct vmem_altmap *altmap);


extern int __add_pages(int nid, unsigned long start_pfn, unsigned long nr_pages,
         struct mhp_params *params);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int add_pages(int nid, unsigned long start_pfn,
  unsigned long nr_pages, struct mhp_params *params)
{
 return __add_pages(nid, start_pfn, nr_pages, params);
}






extern int memory_add_physaddr_to_nid(u64 start);
# 198 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern pg_data_t *node_data[];
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_refresh_nodedata(int nid, pg_data_t *pgdat)
{
 node_data[nid] = pgdat;
}
# 222 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) register_page_bootmem_info_node(struct pglist_data *pgdat);





extern void put_page_bootmem(struct page *page);
extern void get_page_bootmem(unsigned long ingo, struct page *page,
        unsigned long type);

void get_online_mems(void);
void put_online_mems(void);

void mem_hotplug_begin(void);
void mem_hotplug_done(void);
# 291 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_lock(struct pglist_data *pgdat, unsigned long *flags)
{
 do { do { ({ unsigned long __dummy; typeof(*flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); *flags = _raw_spin_lock_irqsave(spinlock_check(&pgdat->node_size_lock)); } while (0); } while (0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_unlock(struct pglist_data *pgdat, unsigned long *flags)
{
 spin_unlock_irqrestore(&pgdat->node_size_lock, *flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_init(struct pglist_data *pgdat)
{
 do { spinlock_check(&pgdat->node_size_lock); *(&pgdat->node_size_lock) = (spinlock_t) { { .rlock = { .raw_lock = { 0 }, } } }; } while (0);
}
# 317 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern void try_offline_node(int nid);
extern int offline_pages(unsigned long start_pfn, unsigned long nr_pages);
extern int remove_memory(int nid, u64 start, u64 size);
extern void __remove_memory(int nid, u64 start, u64 size);
extern int offline_and_remove_memory(int nid, u64 start, u64 size);
# 339 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern void set_zone_contiguous(struct zone *zone);
extern void clear_zone_contiguous(struct zone *zone);

extern void __attribute__((__section__(".ref.text"))) __attribute__((__noinline__)) free_area_init_core_hotplug(int nid);
extern int __add_memory(int nid, u64 start, u64 size);
extern int add_memory(int nid, u64 start, u64 size);
extern int add_memory_resource(int nid, struct resource *resource);
extern int add_memory_driver_managed(int nid, u64 start, u64 size,
         const char *resource_name);
extern void move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,
  unsigned long nr_pages, struct vmem_altmap *altmap);
extern void remove_pfn_range_from_zone(struct zone *zone,
           unsigned long start_pfn,
           unsigned long nr_pages);
extern bool is_memblock_offlined(struct memory_block *mem);
extern int sparse_add_section(int nid, unsigned long pfn,
  unsigned long nr_pages, struct vmem_altmap *altmap);
extern void sparse_remove_section(struct mem_section *ms,
  unsigned long pfn, unsigned long nr_pages,
  unsigned long map_offset, struct vmem_altmap *altmap);
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map,
       unsigned long pnum);
extern bool allow_online_pfn_range(int nid, unsigned long pfn, unsigned long nr_pages,
  int online_type);
extern struct zone *zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,
  unsigned long nr_pages);
# 790 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2

void build_all_zonelists(pg_data_t *pgdat);
void wakeup_kswapd(struct zone *zone, gfp_t gfp_mask, int order,
     enum zone_type highest_zoneidx);
bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,
    int highest_zoneidx, unsigned int alloc_flags,
    long free_pages);
bool zone_watermark_ok(struct zone *z, unsigned int order,
  unsigned long mark, int highest_zoneidx,
  unsigned int alloc_flags);
bool zone_watermark_ok_safe(struct zone *z, unsigned int order,
  unsigned long mark, int highest_zoneidx);
enum memmap_context {
 MEMMAP_EARLY,
 MEMMAP_HOTPLUG,
};
extern void init_currently_empty_zone(struct zone *zone, unsigned long start_pfn,
         unsigned long size);

extern void lruvec_init(struct lruvec *lruvec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pglist_data *lruvec_pgdat(struct lruvec *lruvec)
{

 return lruvec->pgdat;



}

extern unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx);


void memory_present(int nid, unsigned long start, unsigned long end);





void memblocks_present(void);





int local_memory_node(int node_id);
# 851 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool managed_zone(struct zone *zone)
{
 return zone_managed_pages(zone);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool populated_zone(struct zone *zone)
{
 return zone->present_pages;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zone_to_nid(struct zone *zone)
{
 return zone->node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_set_nid(struct zone *zone, int nid)
{
 zone->node = nid;
}
# 881 "/home/nathan/src/linux-next/include/linux/mmzone.h"
extern int movable_zone;
# 894 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_highmem_idx(enum zone_type idx)
{




 return 0;

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_highmem(struct zone *zone)
{



 return 0;

}


struct ctl_table;

int min_free_kbytes_sysctl_handler(struct ctl_table *, int, void *, size_t *,
  loff_t *);
int watermark_scale_factor_sysctl_handler(struct ctl_table *, int, void *,
  size_t *, loff_t *);
extern int sysctl_lowmem_reserve_ratio[3];
int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int, void *,
  size_t *, loff_t *);
int percpu_pagelist_fraction_sysctl_handler(struct ctl_table *, int,
  void *, size_t *, loff_t *);
int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *, int,
  void *, size_t *, loff_t *);
int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *, int,
  void *, size_t *, loff_t *);
int numa_zonelist_order_handler(struct ctl_table *, int,
  void *, size_t *, loff_t *);
extern int percpu_pagelist_fraction;
extern char numa_zonelist_order[];
# 949 "/home/nathan/src/linux-next/include/linux/mmzone.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h"
extern struct pglist_data *node_data[];
# 33 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h"
extern int numa_cpu_lookup_table[];
extern cpumask_var_t node_to_cpumask_map[];

extern unsigned long max_pfn;
u64 memory_hotplug_max(void);
# 950 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2



extern struct pglist_data *first_online_pgdat(void);
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat);
extern struct zone *next_zone(struct zone *zone);
# 985 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zone *zonelist_zone(struct zoneref *zoneref)
{
 return zoneref->zone;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zonelist_zone_idx(struct zoneref *zoneref)
{
 return zoneref->zone_idx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zonelist_node_idx(struct zoneref *zoneref)
{
 return zone_to_nid(zoneref->zone);
}

struct zoneref *__next_zones_zonelist(struct zoneref *z,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes);
# 1016 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) struct zoneref *next_zones_zonelist(struct zoneref *z,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes)
{
 if (__builtin_expect(!!(!nodes && zonelist_zone_idx(z) <= highest_zoneidx), 1))
  return z;
 return __next_zones_zonelist(z, highest_zoneidx, nodes);
}
# 1041 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zoneref *first_zones_zonelist(struct zonelist *zonelist,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes)
{
 return next_zones_zonelist(zonelist->_zonerefs,
       highest_zoneidx, nodes);
}
# 1116 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pfn_to_section_nr(unsigned long pfn)
{
 return pfn >> (24 - 16);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long section_nr_to_pfn(unsigned long sec)
{
 return sec << (24 - 16);
}
# 1144 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct mem_section_usage {

 unsigned long subsection_map[((((1UL << (24 - 21))) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];


 unsigned long pageblock_flags[0];
};

void subsection_map_init(unsigned long pfn, unsigned long nr_pages);

struct page;
struct page_ext;
struct mem_section {
# 1169 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned long section_mem_map;

 struct mem_section_usage *usage;
# 1184 "/home/nathan/src/linux-next/include/linux/mmzone.h"
};
# 1197 "/home/nathan/src/linux-next/include/linux/mmzone.h"
extern struct mem_section **mem_section;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long *section_to_usemap(struct mem_section *ms)
{
 return ms->usage->pageblock_flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_section *__nr_to_section(unsigned long nr)
{

 if (!mem_section)
  return ((void *)0);

 if (!mem_section[((nr) / ((1UL << 16) / sizeof (struct mem_section)))])
  return ((void *)0);
 return &mem_section[((nr) / ((1UL << 16) / sizeof (struct mem_section)))][nr & (((1UL << 16) / sizeof (struct mem_section)) - 1)];
}
extern unsigned long __section_nr(struct mem_section *ms);
extern size_t mem_section_usage_size(void);
# 1241 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *__section_mem_map_addr(struct mem_section *section)
{
 unsigned long map = section->section_mem_map;
 map &= (~((1UL<<4)-1));
 return (struct page *)map;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int present_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<0)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int present_section_nr(unsigned long nr)
{
 return present_section(__nr_to_section(nr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int early_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<3)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_section_nr(unsigned long nr)
{
 return valid_section(__nr_to_section(nr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int online_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<2)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int online_section_nr(unsigned long nr)
{
 return online_section(__nr_to_section(nr));
}


void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn);

void offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_section *__pfn_to_section(unsigned long pfn)
{
 return __nr_to_section(pfn_to_section_nr(pfn));
}

extern unsigned long __highest_present_section_nr;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int subsection_map_index(unsigned long pfn)
{
 return (pfn & ~((~((1UL << (24 - 16))-1)))) / (1UL << (21 - 16));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_section_valid(struct mem_section *ms, unsigned long pfn)
{
 int idx = subsection_map_index(pfn);

 return test_bit(idx, ms->usage->subsection_map);
}
# 1317 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_valid(unsigned long pfn)
{
 struct mem_section *ms;

 if (pfn_to_section_nr(pfn) >= (1UL << (51 - 24)))
  return 0;
 ms = __nr_to_section(pfn_to_section_nr(pfn));
 if (!valid_section(ms))
  return 0;




 return early_section(ms) || pfn_section_valid(ms, pfn);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_in_present_section(unsigned long pfn)
{
 if (pfn_to_section_nr(pfn) >= (1UL << (51 - 24)))
  return 0;
 return present_section(__nr_to_section(pfn_to_section_nr(pfn)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long next_present_section_nr(unsigned long section_nr)
{
 while (++section_nr <= __highest_present_section_nr) {
  if (present_section_nr(section_nr))
   return section_nr;
 }

 return -1;
}
# 1367 "/home/nathan/src/linux-next/include/linux/mmzone.h"
void sparse_init(void);
# 1380 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct mminit_pfnnid_cache {
 unsigned long last_start;
 unsigned long last_end;
 int last_nid;
};





void memory_present(int nid, unsigned long start, unsigned long end);
# 1428 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool memmap_valid_within(unsigned long pfn,
     struct page *page, struct zone *zone)
{
 return true;
}
# 7 "/home/nathan/src/linux-next/include/linux/gfp.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/topology.h" 1
# 30 "/home/nathan/src/linux-next/include/linux/topology.h"
# 1 "/home/nathan/src/linux-next/include/linux/arch_topology.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/percpu.h" 1
# 65 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern void *pcpu_base_addr;
extern const unsigned long *pcpu_unit_offsets;

struct pcpu_group_info {
 int nr_units;
 unsigned long base_offset;
 unsigned int *cpu_map;

};

struct pcpu_alloc_info {
 size_t static_size;
 size_t reserved_size;
 size_t dyn_size;
 size_t unit_size;
 size_t atom_size;
 size_t alloc_size;
 size_t __ai_size;
 int nr_groups;
 struct pcpu_group_info groups[];
};

enum pcpu_fc {
 PCPU_FC_AUTO,
 PCPU_FC_EMBED,
 PCPU_FC_PAGE,

 PCPU_FC_NR,
};
extern const char * const pcpu_fc_names[PCPU_FC_NR];

extern enum pcpu_fc pcpu_chosen_fc;

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int cpu, size_t size,
         size_t align);
typedef void (*pcpu_fc_free_fn_t)(void *ptr, size_t size);
typedef void (*pcpu_fc_populate_pte_fn_t)(unsigned long addr);
typedef int (pcpu_fc_cpu_distance_fn_t)(unsigned int from, unsigned int to);

extern struct pcpu_alloc_info * __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_alloc_alloc_info(int nr_groups,
            int nr_units);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_free_alloc_info(struct pcpu_alloc_info *ai);

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,
      void *base_addr);


extern int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,
    size_t atom_size,
    pcpu_fc_cpu_distance_fn_t cpu_distance_fn,
    pcpu_fc_alloc_fn_t alloc_fn,
    pcpu_fc_free_fn_t free_fn);
# 126 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern void *__alloc_reserved_percpu(size_t size, size_t align);
extern bool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr);
extern bool is_kernel_percpu_address(unsigned long addr);





extern void *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp);
extern void *__alloc_percpu(size_t size, size_t align);
extern void free_percpu(void *__pdata);
extern phys_addr_t per_cpu_ptr_to_phys(void *addr);
# 146 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern unsigned long pcpu_nr_pages(void);
# 10 "/home/nathan/src/linux-next/include/linux/arch_topology.h" 2

void topology_normalize_cpu_scale(void);
int topology_update_cpu_topology(void);

struct device_node;
bool topology_parse_cpu_capacity(struct device_node *cpu_node, int cpu);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) cpu_scale;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long topology_get_cpu_scale(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_scale)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_scale)))) *)((&(cpu_scale)))); (typeof((typeof(*((&(cpu_scale)))) *)((&(cpu_scale))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

void topology_set_cpu_scale(unsigned int cpu, unsigned long capacity);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) freq_scale;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long topology_get_freq_scale(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(freq_scale)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(freq_scale)))) *)((&(freq_scale)))); (typeof((typeof(*((&(freq_scale)))) *)((&(freq_scale))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

bool arch_freq_counters_available(struct cpumask *cpus);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) thermal_pressure;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long topology_get_thermal_pressure(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(thermal_pressure)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(thermal_pressure)))) *)((&(thermal_pressure)))); (typeof((typeof(*((&(thermal_pressure)))) *)((&(thermal_pressure))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

void arch_set_thermal_pressure(struct cpumask *cpus,
          unsigned long th_pressure);

struct cpu_topology {
 int thread_id;
 int core_id;
 int package_id;
 int llc_id;
 cpumask_t thread_sibling;
 cpumask_t core_sibling;
 cpumask_t llc_sibling;
};
# 31 "/home/nathan/src/linux-next/include/linux/topology.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h" 1






struct device;
struct device_node;
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
struct pci_bus;

extern int pcibus_to_node(struct pci_bus *bus);
# 38 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
extern int cpu_distance(__be32 *cpu1_assoc, __be32 *cpu2_assoc);
extern int __node_distance(int, int);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) dump_numa_cpu_topology(void);

extern int sysfs_add_device_to_node(struct device *dev, int nid);
extern void sysfs_remove_device_from_node(struct device *dev, int nid);
extern int numa_update_cpu_topology(bool cpus_locked);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_numa_cpu_lookup_table(unsigned int cpu, int node)
{
 numa_cpu_lookup_table[cpu] = node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int early_cpu_to_node(int cpu)
{
 int nid;

 nid = numa_cpu_lookup_table[cpu];





 return (nid < 0) ? 0 : nid;
}
# 96 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
extern int start_topology_update(void);
extern int stop_topology_update(void);
extern int prrn_is_enabled(void);
extern int find_and_online_cpu_nid(int cpu);
extern int timed_topology_update(int nsecs);
# 125 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/topology.h" 1
# 126 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h" 2








int get_physical_package_id(int cpu);
# 144 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
int dlpar_cpu_readd(int cpu);
# 37 "/home/nathan/src/linux-next/include/linux/topology.h" 2
# 46 "/home/nathan/src/linux-next/include/linux/topology.h"
int arch_update_cpu_topology(void);
# 75 "/home/nathan/src/linux-next/include/linux/topology.h"
extern int __attribute__((__section__(".data..read_mostly"))) node_reclaim_distance;






extern __attribute__((section(".data..percpu" ""))) __typeof__(int) numa_node;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int numa_node_id(void)
{
 return ({ typeof(numa_node) pscr_ret__; do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(numa_node)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpu_to_node(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(numa_node)))) *)((&(numa_node)))); (typeof((typeof(*((&(numa_node)))) *)((&(numa_node))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_numa_node(int node)
{
 do { do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(numa_node)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_cpu_numa_node(int cpu, int node)
{
 (*({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(numa_node)))) *)((&(numa_node)))); (typeof((typeof(*((&(numa_node)))) *)((&(numa_node))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })) = node;
}
# 132 "/home/nathan/src/linux-next/include/linux/topology.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(int) _numa_mem_;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_numa_mem(int node)
{
 do { do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(_numa_mem_)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int numa_mem_id(void)
{
 return ({ typeof(_numa_mem_) pscr_ret__; do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(_numa_mem_)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpu_to_mem(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_)))); (typeof((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_cpu_numa_mem(int cpu, int node)
{
 (*({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_)))); (typeof((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })) = node;
}
# 202 "/home/nathan/src/linux-next/include/linux/topology.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *cpu_smt_mask(int cpu)
{
 return ((*({ do { const void *__vpp_verify = (typeof((&(cpu_sibling_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map)))); (typeof((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *cpu_cpu_mask(int cpu)
{
 return ((cpu_to_node(cpu)) == -1 ? ((struct cpumask *)(1 ? (cpu_all_bits) : (void *)sizeof(__check_is_bitmap(cpu_all_bits)))) : node_to_cpumask_map[cpu_to_node(cpu)]);
}
# 10 "/home/nathan/src/linux-next/include/linux/gfp.h" 2

struct vm_area_struct;
# 315 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gfp_migratetype(const gfp_t gfp_flags)
{
 (void)({ int __ret_warn_on = !!((gfp_flags & ((( gfp_t)0x10u)|(( gfp_t)0x08u))) == ((( gfp_t)0x10u)|(( gfp_t)0x08u))); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (317), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (317), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 do { extern void __compiletime_assert_71(void) ; if (!(!((1UL << 3) != 0x08u))) __compiletime_assert_71(); } while (0);
 do { extern void __compiletime_assert_72(void) ; if (!(!((0x08u >> 3) != MIGRATE_MOVABLE))) __compiletime_assert_72(); } while (0);

 if (__builtin_expect(!!(page_group_by_mobility_disabled), 0))
  return MIGRATE_UNMOVABLE;


 return (gfp_flags & ((( gfp_t)0x10u)|(( gfp_t)0x08u))) >> 3;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gfpflags_allow_blocking(const gfp_t gfp_flags)
{
 return !!(gfp_flags & (( gfp_t)0x400u));
}
# 352 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gfpflags_normal_context(const gfp_t gfp_flags)
{
 return (gfp_flags & ((( gfp_t)0x400u) | (( gfp_t)0x20000u))) ==
  (( gfp_t)0x400u);
}
# 448 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum zone_type gfp_zone(gfp_t flags)
{
 enum zone_type z;
 int bit = ( int) (flags & ((( gfp_t)0x01u)|(( gfp_t)0x02u)|(( gfp_t)0x04u)|(( gfp_t)0x08u)));

 z = (( (ZONE_NORMAL << 0 * 2) | (ZONE_NORMAL << 0x01u * 2) | (ZONE_NORMAL << 0x02u * 2) | (ZONE_NORMAL << 0x04u * 2) | (ZONE_NORMAL << 0x08u * 2) | (ZONE_NORMAL << (0x08u | 0x01u) * 2) | (ZONE_MOVABLE << (0x08u | 0x02u) * 2) | (ZONE_NORMAL << (0x08u | 0x04u) * 2)) >> (bit * 2)) &
      ((1 << 2) - 1);
 do { if (__builtin_constant_p((( 1 << (0x01u | 0x02u) | 1 << (0x01u | 0x04u) | 1 << (0x04u | 0x02u) | 1 << (0x01u | 0x04u | 0x02u) | 1 << (0x08u | 0x02u | 0x01u) | 1 << (0x08u | 0x04u | 0x01u) | 1 << (0x08u | 0x04u | 0x02u) | 1 << (0x08u | 0x04u | 0x01u | 0x02u) ) >> bit) & 1)) { if ((( 1 << (0x01u | 0x02u) | 1 << (0x01u | 0x04u) | 1 << (0x04u | 0x02u) | 1 << (0x01u | 0x04u | 0x02u) | 1 << (0x08u | 0x02u | 0x01u) | 1 << (0x08u | 0x04u | 0x01u) | 1 << (0x08u | 0x04u | 0x02u) | 1 << (0x08u | 0x04u | 0x01u | 0x02u) ) >> bit) & 1) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (455), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (455), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((( 1 << (0x01u | 0x02u) | 1 << (0x01u | 0x04u) | 1 << (0x04u | 0x02u) | 1 << (0x01u | 0x04u | 0x02u) | 1 << (0x08u | 0x02u | 0x01u) | 1 << (0x08u | 0x04u | 0x01u) | 1 << (0x08u | 0x04u | 0x02u) | 1 << (0x08u | 0x04u | 0x01u | 0x02u) ) >> bit) & 1))); } } while (0);
 return z;
}
# 466 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gfp_zonelist(gfp_t flags)
{

 if (__builtin_expect(!!(flags & (( gfp_t)0x200000u)), 0))
  return ZONELIST_NOFALLBACK;

 return ZONELIST_FALLBACK;
}
# 484 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zonelist *node_zonelist(int nid, gfp_t flags)
{
 return (node_data[nid])->node_zonelists + gfp_zonelist(flags);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_alloc_page(struct page *page, int order) { }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_make_page_accessible(struct page *page)
{
 return 0;
}


struct page *
__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,
       nodemask_t *nodemask);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)
{
 return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, ((void *)0));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
 do { if (__builtin_constant_p(nid < 0 || nid >= (1 << 8))) { if (nid < 0 || nid >= (1 << 8)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (519), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (519), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(nid < 0 || nid >= (1 << 8)))); } } while (0);
 (void)({ int __ret_warn_on = !!((gfp_mask & (( gfp_t)0x200000u)) && !node_state((nid), N_ONLINE)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (520), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/gfp.h"), "i" (520), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });

 return __alloc_pages(gfp_mask, order, nid);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
      unsigned int order)
{
 if (nid == (-1))
  nid = numa_mem_id();

 return __alloc_pages_node(nid, gfp_mask, order);
}


extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
 return alloc_pages_current(gfp_mask, order);
}
extern struct page *alloc_pages_vma(gfp_t gfp_mask, int order,
   struct vm_area_struct *vma, unsigned long addr,
   int node, bool hugepage);
# 566 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
extern unsigned long get_zeroed_page(gfp_t gfp_mask);

void *alloc_pages_exact(size_t size, gfp_t gfp_mask);
void free_pages_exact(void *virt, size_t size);
void * __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);







extern void __free_pages(struct page *page, unsigned int order);
extern void free_pages(unsigned long addr, unsigned int order);
extern void free_unref_page(struct page *page);
extern void free_unref_page_list(struct list_head *list);

struct page_frag_cache;
extern void __page_frag_cache_drain(struct page *page, unsigned int count);
extern void *page_frag_alloc(struct page_frag_cache *nc,
        unsigned int fragsz, gfp_t gfp_mask);
extern void page_frag_free(void *addr);




void page_alloc_init(void);
void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
void drain_all_pages(struct zone *zone);
void drain_local_pages(struct zone *zone);

void page_alloc_init_late(void);
# 607 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern gfp_t gfp_allowed_mask;


bool gfp_pfmemalloc_allowed(gfp_t gfp_mask);

extern void pm_restrict_gfp_mask(void);
extern void pm_restore_gfp_mask(void);


extern bool pm_suspended_storage(void);
# 626 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern int alloc_contig_range(unsigned long start, unsigned long end,
         unsigned migratetype, gfp_t gfp_mask);
extern struct page *alloc_contig_pages(unsigned long nr_pages, gfp_t gfp_mask,
           int nid, nodemask_t *nodemask);

void free_contig_range(unsigned long pfn, unsigned int nr_pages);



extern void init_cma_reserved_pageblock(struct page *page);
# 16 "/home/nathan/src/linux-next/include/linux/slab.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/overflow.h" 1
# 253 "/home/nathan/src/linux-next/include/linux/overflow.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t array_size(size_t a, size_t b)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}
# 275 "/home/nathan/src/linux-next/include/linux/overflow.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t array3_size(size_t a, size_t b, size_t c)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);
 if (({ typeof(bytes) __a = (bytes); typeof(c) __b = (c); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t __ab_c_size(size_t a, size_t b, size_t c)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);
 if (({ typeof(bytes) __a = (bytes); typeof(c) __b = (c); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_add_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}
# 17 "/home/nathan/src/linux-next/include/linux/slab.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h" 1
# 59 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
struct percpu_ref;
typedef void (percpu_ref_func_t)(struct percpu_ref *);


enum {
 __PERCPU_REF_ATOMIC = 1LU << 0,
 __PERCPU_REF_DEAD = 1LU << 1,
 __PERCPU_REF_ATOMIC_DEAD = __PERCPU_REF_ATOMIC | __PERCPU_REF_DEAD,

 __PERCPU_REF_FLAG_BITS = 2,
};


enum {







 PERCPU_REF_INIT_ATOMIC = 1 << 0,






 PERCPU_REF_INIT_DEAD = 1 << 1,




 PERCPU_REF_ALLOW_REINIT = 1 << 2,
};

struct percpu_ref {
 atomic_long_t count;




 unsigned long percpu_count_ptr;
 percpu_ref_func_t *release;
 percpu_ref_func_t *confirm_switch;
 bool force_atomic:1;
 bool allow_reinit:1;
 struct callback_head rcu;
};

int __attribute__((__warn_unused_result__)) percpu_ref_init(struct percpu_ref *ref,
     percpu_ref_func_t *release, unsigned int flags,
     gfp_t gfp);
void percpu_ref_exit(struct percpu_ref *ref);
void percpu_ref_switch_to_atomic(struct percpu_ref *ref,
     percpu_ref_func_t *confirm_switch);
void percpu_ref_switch_to_atomic_sync(struct percpu_ref *ref);
void percpu_ref_switch_to_percpu(struct percpu_ref *ref);
void percpu_ref_kill_and_confirm(struct percpu_ref *ref,
     percpu_ref_func_t *confirm_kill);
void percpu_ref_resurrect(struct percpu_ref *ref);
void percpu_ref_reinit(struct percpu_ref *ref);
# 134 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_kill(struct percpu_ref *ref)
{
 percpu_ref_kill_and_confirm(ref, ((void *)0));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __ref_is_percpu(struct percpu_ref *ref,
       unsigned long **percpu_countp)
{
 unsigned long percpu_ptr;
# 161 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
 percpu_ptr = ({ do { extern void __compiletime_assert_73(void) ; if (!((sizeof(ref->percpu_count_ptr) == sizeof(char) || sizeof(ref->percpu_count_ptr) == sizeof(short) || sizeof(ref->percpu_count_ptr) == sizeof(int) || sizeof(ref->percpu_count_ptr) == sizeof(long)) || sizeof(ref->percpu_count_ptr) == sizeof(long long))) __compiletime_assert_73(); } while (0); ({ typeof( _Generic((ref->percpu_count_ptr), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (ref->percpu_count_ptr))) __x = (*(const volatile typeof( _Generic((ref->percpu_count_ptr), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (ref->percpu_count_ptr))) *)&(ref->percpu_count_ptr)); do { } while (0); (typeof(ref->percpu_count_ptr))__x; }); });







 if (__builtin_expect(!!(percpu_ptr & __PERCPU_REF_ATOMIC_DEAD), 0))
  return false;

 *percpu_countp = (unsigned long *)percpu_ptr;
 return true;
}
# 185 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_get_many(struct percpu_ref *ref, unsigned long nr)
{
 unsigned long *percpu_count;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count))
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 else
  atomic_long_add(nr, &ref->count);

 rcu_read_unlock();
}
# 207 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_get(struct percpu_ref *ref)
{
 percpu_ref_get_many(ref, 1);
}
# 222 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget_many(struct percpu_ref *ref,
       unsigned long nr)
{
 unsigned long *percpu_count;
 bool ret;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count)) {
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
  ret = true;
 } else {
  ret = atomic_long_add_unless(&ref->count, nr, 0);
 }

 rcu_read_unlock();

 return ret;
}
# 251 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget(struct percpu_ref *ref)
{
 return percpu_ref_tryget_many(ref, 1);
}
# 271 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget_live(struct percpu_ref *ref)
{
 unsigned long *percpu_count;
 bool ret = false;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count)) {
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
  ret = true;
 } else if (!(ref->percpu_count_ptr & __PERCPU_REF_DEAD)) {
  ret = atomic_long_inc_not_zero(&ref->count);
 }

 rcu_read_unlock();

 return ret;
}
# 300 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_put_many(struct percpu_ref *ref, unsigned long nr)
{
 unsigned long *percpu_count;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count))
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 else if (__builtin_expect(!!(atomic_long_sub_and_test(nr, &ref->count)), 0))
  ref->release(ref);

 rcu_read_unlock();
}
# 323 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_put(struct percpu_ref *ref)
{
 percpu_ref_put_many(ref, 1);
}
# 337 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_is_dying(struct percpu_ref *ref)
{
 return ref->percpu_count_ptr & __PERCPU_REF_DEAD;
}
# 350 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_is_zero(struct percpu_ref *ref)
{
 unsigned long *percpu_count;

 if (__ref_is_percpu(ref, &percpu_count))
  return false;
 return !atomic_long_read(&ref->count);
}
# 20 "/home/nathan/src/linux-next/include/linux/slab.h" 2
# 136 "/home/nathan/src/linux-next/include/linux/slab.h"
# 1 "/home/nathan/src/linux-next/include/linux/kasan.h" 1






struct kmem_cache;
struct page;
struct vm_struct;
struct task_struct;
# 101 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_shadow(const void *address, size_t size) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_task_stack(struct task_struct *task) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_stack_above_sp_to(const void *watermark) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_enable_current(void) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_disable_current(void) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_alloc_pages(struct page *page, unsigned int order) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_free_pages(struct page *page, unsigned int order) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_create(struct kmem_cache *cache,
          unsigned int *size,
          slab_flags_t *flags) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_slab(struct page *page) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_object_data(struct kmem_cache *cache,
     void *object) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_object_data(struct kmem_cache *cache,
     void *object) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_init_slab_obj(struct kmem_cache *cache,
    const void *object)
{
 return (void *)object;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_kmalloc_large(void *ptr, size_t size, gfp_t flags)
{
 return ptr;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_kfree_large(void *ptr, unsigned long ip) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_kfree(void *ptr, unsigned long ip) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_kmalloc(struct kmem_cache *s, const void *object,
    size_t size, gfp_t flags)
{
 return (void *)object;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_krealloc(const void *object, size_t new_size,
     gfp_t flags)
{
 return (void *)object;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_slab_alloc(struct kmem_cache *s, void *object,
       gfp_t flags)
{
 return object;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_slab_free(struct kmem_cache *s, void *object,
       unsigned long ip)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_module_alloc(void *addr, size_t size) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_free_shadow(const struct vm_struct *vm) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_add_zero_shadow(void *start, unsigned long size)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_remove_zero_shadow(void *start,
     unsigned long size)
{}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_slab(const void *ptr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t kasan_metadata_size(struct kmem_cache *cache) { return 0; }
# 180 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_shrink(struct kmem_cache *cache) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_shutdown(struct kmem_cache *cache) {}
# 198 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_init_tags(void) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_reset_tag(const void *addr)
{
 return (void *)addr;
}
# 215 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_populate_vmalloc(unsigned long start,
     unsigned long size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_vmalloc(const void *start, unsigned long size)
{ }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_vmalloc(const void *start, unsigned long size)
{ }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_release_vmalloc(unsigned long start,
      unsigned long end,
      unsigned long free_region_start,
      unsigned long free_region_end) {}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_non_canonical_hook(unsigned long addr) { }
# 137 "/home/nathan/src/linux-next/include/linux/slab.h" 2

struct mem_cgroup;



void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init(void);
bool slab_is_available(void);

extern bool usercopy_fallback;

struct kmem_cache *kmem_cache_create(const char *name, unsigned int size,
   unsigned int align, slab_flags_t flags,
   void (*ctor)(void *));
struct kmem_cache *kmem_cache_create_usercopy(const char *name,
   unsigned int size, unsigned int align,
   slab_flags_t flags,
   unsigned int useroffset, unsigned int usersize,
   void (*ctor)(void *));
void kmem_cache_destroy(struct kmem_cache *);
int kmem_cache_shrink(struct kmem_cache *);

void memcg_create_kmem_cache(struct mem_cgroup *, struct kmem_cache *);
void memcg_deactivate_kmem_caches(struct mem_cgroup *, struct mem_cgroup *);
# 187 "/home/nathan/src/linux-next/include/linux/slab.h"
void * __attribute__((__warn_unused_result__)) krealloc(const void *, size_t, gfp_t);
void kfree(const void *);
void kzfree(const void *);
size_t __ksize(const void *);
size_t ksize(const void *);


void __check_heap_object(const void *ptr, unsigned long n, struct page *page,
   bool to_user);
# 308 "/home/nathan/src/linux-next/include/linux/slab.h"
enum kmalloc_cache_type {
 KMALLOC_NORMAL = 0,
 KMALLOC_RECLAIM,



 NR_KMALLOC_TYPES
};


extern struct kmem_cache *
kmalloc_caches[NR_KMALLOC_TYPES][(16 + 1) + 1];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) enum kmalloc_cache_type kmalloc_type(gfp_t flags)
{
# 337 "/home/nathan/src/linux-next/include/linux/slab.h"
 return flags & (( gfp_t)0x10u) ? KMALLOC_RECLAIM : KMALLOC_NORMAL;

}
# 349 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned int kmalloc_index(size_t size)
{
 if (!size)
  return 0;

 if (size <= (1 << 3))
  return 3;

 if ((1 << 3) <= 32 && size > 64 && size <= 96)
  return 1;
 if ((1 << 3) <= 64 && size > 128 && size <= 192)
  return 2;
 if (size <= 8) return 3;
 if (size <= 16) return 4;
 if (size <= 32) return 5;
 if (size <= 64) return 6;
 if (size <= 128) return 7;
 if (size <= 256) return 8;
 if (size <= 512) return 9;
 if (size <= 1024) return 10;
 if (size <= 2 * 1024) return 11;
 if (size <= 4 * 1024) return 12;
 if (size <= 8 * 1024) return 13;
 if (size <= 16 * 1024) return 14;
 if (size <= 32 * 1024) return 15;
 if (size <= 64 * 1024) return 16;
 if (size <= 128 * 1024) return 17;
 if (size <= 256 * 1024) return 18;
 if (size <= 512 * 1024) return 19;
 if (size <= 1024 * 1024) return 20;
 if (size <= 2 * 1024 * 1024) return 21;
 if (size <= 4 * 1024 * 1024) return 22;
 if (size <= 8 * 1024 * 1024) return 23;
 if (size <= 16 * 1024 * 1024) return 24;
 if (size <= 32 * 1024 * 1024) return 25;
 if (size <= 64 * 1024 * 1024) return 26;
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/slab.h"), "i" (385), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);


 return -1;
}


void *__kmalloc(size_t size, gfp_t flags) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void kmem_cache_free(struct kmem_cache *, void *);
# 403 "/home/nathan/src/linux-next/include/linux/slab.h"
void kmem_cache_free_bulk(struct kmem_cache *, size_t, void **);
int kmem_cache_alloc_bulk(struct kmem_cache *, gfp_t, size_t, void **);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void kfree_bulk(size_t size, void **p)
{
 kmem_cache_free_bulk(((void *)0), size, p);
}


void *__kmalloc_node(size_t size, gfp_t flags, int node) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
# 431 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));


extern void *kmem_cache_alloc_node_trace(struct kmem_cache *s,
        gfp_t gfpflags,
        int node, size_t size) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
# 469 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *kmalloc_order(size_t size, gfp_t flags, unsigned int order) __attribute__((__assume_aligned__((1UL << 16)))) __attribute__((__malloc__));


extern void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order) __attribute__((__assume_aligned__((1UL << 16)))) __attribute__((__malloc__));
# 481 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc_large(size_t size, gfp_t flags)
{
 unsigned int order = get_order(size);
 return kmalloc_order_trace(size, flags, order);
}
# 541 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc(size_t size, gfp_t flags)
{
 if (__builtin_constant_p(size)) {

  unsigned int index;

  if (size > (1UL << (16 + 1)))
   return kmalloc_large(size, flags);

  index = kmalloc_index(size);

  if (!index)
   return ((void *)16);

  return kmem_cache_alloc_trace(
    kmalloc_caches[kmalloc_type(flags)][index],
    flags, size);

 }
 return __kmalloc(size, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc_node(size_t size, gfp_t flags, int node)
{

 if (__builtin_constant_p(size) &&
  size <= (1UL << (16 + 1))) {
  unsigned int i = kmalloc_index(size);

  if (!i)
   return ((void *)16);

  return kmem_cache_alloc_node_trace(
    kmalloc_caches[kmalloc_type(flags)][i],
      flags, node, size);
 }

 return __kmalloc_node(size, flags, node);
}

int memcg_update_all_caches(int num_memcgs);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);
 if (__builtin_constant_p(n) && __builtin_constant_p(size))
  return kmalloc(bytes, flags);
 return __kmalloc(bytes, flags);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kcalloc(size_t n, size_t size, gfp_t flags)
{
 return kmalloc_array(n, size, flags | (( gfp_t)0x100u));
}
# 619 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmalloc_array_node(size_t n, size_t size, gfp_t flags,
           int node)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);
 if (__builtin_constant_p(n) && __builtin_constant_p(size))
  return kmalloc_node(bytes, flags, node);
 return __kmalloc_node(bytes, flags, node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kcalloc_node(size_t n, size_t size, gfp_t flags, int node)
{
 return kmalloc_array_node(n, size, flags | (( gfp_t)0x100u), node);
}



extern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);
# 657 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
{
 return kmem_cache_alloc(k, flags | (( gfp_t)0x100u));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kzalloc(size_t size, gfp_t flags)
{
 return kmalloc(size, flags | (( gfp_t)0x100u));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kzalloc_node(size_t size, gfp_t flags, int node)
{
 return kmalloc_node(size, flags | (( gfp_t)0x100u), node);
}

unsigned int kmem_cache_size(struct kmem_cache *s);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init_late(void);
# 34 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2



# 1 "/home/nathan/src/linux-next/include/drm/drm_print.h" 1
# 31 "/home/nathan/src/linux-next/include/drm/drm_print.h"
# 1 "/home/nathan/src/linux-next/include/linux/seq_file.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/seq_file.h"
# 1 "/home/nathan/src/linux-next/include/linux/fs.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/wait_bit.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
struct wait_bit_key {
 void *flags;
 int bit_nr;
 unsigned long timeout;
};

struct wait_bit_queue_entry {
 struct wait_bit_key key;
 struct wait_queue_entry wq_entry;
};




typedef int wait_bit_action_f(struct wait_bit_key *key, int mode);

void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit);
int __wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
int __wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
void wake_up_bit(void *word, int bit);
int out_of_line_wait_on_bit(void *word, int, wait_bit_action_f *action, unsigned int mode);
int out_of_line_wait_on_bit_timeout(void *word, int, wait_bit_action_f *action, unsigned int mode, unsigned long timeout);
int out_of_line_wait_on_bit_lock(void *word, int, wait_bit_action_f *action, unsigned int mode);
struct wait_queue_head *bit_waitqueue(void *word, int bit);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) wait_bit_init(void);

int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
# 49 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
extern int bit_wait(struct wait_bit_key *key, int mode);
extern int bit_wait_io(struct wait_bit_key *key, int mode);
extern int bit_wait_timeout(struct wait_bit_key *key, int mode);
extern int bit_wait_io_timeout(struct wait_bit_key *key, int mode);
# 70 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit(unsigned long *word, int bit, unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit,
           bit_wait,
           mode);
}
# 95 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_io(unsigned long *word, int bit, unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit,
           bit_wait_io,
           mode);
}
# 121 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_timeout(unsigned long *word, int bit, unsigned mode,
      unsigned long timeout)
{
 do { _cond_resched(); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_timeout(word, bit,
            bit_wait_timeout,
            mode, timeout);
}
# 149 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_action(unsigned long *word, int bit, wait_bit_action_f *action,
     unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit, action, mode);
}
# 178 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock(unsigned long *word, int bit, unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, bit_wait, mode);
}
# 202 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock_io(unsigned long *word, int bit, unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, bit_wait_io, mode);
}
# 228 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock_action(unsigned long *word, int bit, wait_bit_action_f *action,
   unsigned mode)
{
 do { _cond_resched(); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, action, mode);
}

extern void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags);
extern void wake_up_var(void *var);
extern wait_queue_head_t *__var_waitqueue(void *p);
# 330 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_and_wake_up_bit(int bit, void *word)
{
 clear_bit_unlock(bit, word);

 __asm__ __volatile__ ("sync" : : : "memory");
 wake_up_bit(word, bit);
}
# 7 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kdev_t.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kdev_t.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/kdev_t.h" 2
# 24 "/home/nathan/src/linux-next/include/linux/kdev_t.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool old_valid_dev(dev_t dev)
{
 return ((unsigned int) ((dev) >> 20)) < 256 && ((unsigned int) ((dev) & ((1U << 20) - 1))) < 256;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 old_encode_dev(dev_t dev)
{
 return (((unsigned int) ((dev) >> 20)) << 8) | ((unsigned int) ((dev) & ((1U << 20) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t old_decode_dev(u16 val)
{
 return ((((val >> 8) & 255) << 20) | (val & 255));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 new_encode_dev(dev_t dev)
{
 unsigned major = ((unsigned int) ((dev) >> 20));
 unsigned minor = ((unsigned int) ((dev) & ((1U << 20) - 1)));
 return (minor & 0xff) | (major << 8) | ((minor & ~0xff) << 12);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t new_decode_dev(u32 dev)
{
 unsigned major = (dev & 0xfff00) >> 8;
 unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
 return (((major) << 20) | (minor));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 huge_encode_dev(dev_t dev)
{
 return new_encode_dev(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t huge_decode_dev(u64 dev)
{
 return new_decode_dev(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sysv_valid_dev(dev_t dev)
{
 return ((unsigned int) ((dev) >> 20)) < (1<<14) && ((unsigned int) ((dev) & ((1U << 20) - 1))) < (1<<18);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 sysv_encode_dev(dev_t dev)
{
 return ((unsigned int) ((dev) & ((1U << 20) - 1))) | (((unsigned int) ((dev) >> 20)) << 18);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned sysv_major(u32 dev)
{
 return (dev >> 18) & 0x3fff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned sysv_minor(u32 dev)
{
 return dev & 0x3ffff;
}
# 8 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dcache.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/rculist.h" 1
# 31 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_LIST_HEAD_RCU(struct list_head *list)
{
 do { do { extern void __compiletime_assert_74(void) ; if (!((sizeof(list->next) == sizeof(char) || sizeof(list->next) == sizeof(short) || sizeof(list->next) == sizeof(int) || sizeof(list->next) == sizeof(long)) || sizeof(list->next) == sizeof(long long))) __compiletime_assert_74(); } while (0); do { *(volatile typeof(list->next) *)&(list->next) = (list); } while (0); } while (0);
 do { do { extern void __compiletime_assert_75(void) ; if (!((sizeof(list->prev) == sizeof(char) || sizeof(list->prev) == sizeof(short) || sizeof(list->prev) == sizeof(int) || sizeof(list->prev) == sizeof(long)) || sizeof(list->prev) == sizeof(long long))) __compiletime_assert_75(); } while (0); do { *(volatile typeof(list->prev) *)&(list->prev) = (list); } while (0); } while (0);
}
# 77 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_add_rcu(struct list_head *new,
  struct list_head *prev, struct list_head *next)
{
 if (!__list_add_valid(new, prev, next))
  return;

 new->next = next;
 new->prev = prev;
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_76(void) ; if (!((sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(char) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(short) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(int) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(long)) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(long long))) __compiletime_assert_76(); } while (0); do { *(volatile typeof(((*((struct list_head **)(&(prev)->next))))) *)&(((*((struct list_head **)(&(prev)->next))))) = ((typeof((*((struct list_head **)(&(prev)->next)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_77(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_77(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_78(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long long))) __compiletime_assert_78(); } while (0); do { *(volatile typeof(*&(*((struct list_head **)(&(prev)->next)))) *)&(*&(*((struct list_head **)(&(prev)->next)))) = ((typeof(*((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 next->prev = new;
}
# 105 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_rcu(struct list_head *new, struct list_head *head)
{
 __list_add_rcu(new, head, head->next);
}
# 126 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_tail_rcu(struct list_head *new,
     struct list_head *head)
{
 __list_add_rcu(new, head->prev, head);
}
# 156 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del_rcu(struct list_head *entry)
{
 __list_del_entry(entry);
 entry->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 182 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_init_rcu(struct hlist_node *n)
{
 if (!hlist_unhashed(n)) {
  __hlist_del(n);
  do { do { extern void __compiletime_assert_79(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_79(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (((void *)0)); } while (0); } while (0);
 }
}
# 198 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace_rcu(struct list_head *old,
    struct list_head *new)
{
 new->next = old->next;
 new->prev = old->prev;
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_80(void) ; if (!((sizeof(((*((struct list_head **)(&(new->prev)->next))))) == sizeof(char) || sizeof(((*((struct list_head **)(&(new->prev)->next))))) == sizeof(short) || sizeof(((*((struct list_head **)(&(new->prev)->next))))) == sizeof(int) || sizeof(((*((struct list_head **)(&(new->prev)->next))))) == sizeof(long)) || sizeof(((*((struct list_head **)(&(new->prev)->next))))) == sizeof(long long))) __compiletime_assert_80(); } while (0); do { *(volatile typeof(((*((struct list_head **)(&(new->prev)->next))))) *)&(((*((struct list_head **)(&(new->prev)->next))))) = ((typeof((*((struct list_head **)(&(new->prev)->next)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_81(void) ; if (!((sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(long)))) __compiletime_assert_81(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_82(void) ; if (!((sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(long)) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(long long))) __compiletime_assert_82(); } while (0); do { *(volatile typeof(*&(*((struct list_head **)(&(new->prev)->next)))) *)&(*&(*((struct list_head **)(&(new->prev)->next)))) = ((typeof(*((typeof((*((struct list_head **)(&(new->prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(new->prev)->next)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 new->next->prev = new;
 old->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 227 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_splice_init_rcu(struct list_head *list,
       struct list_head *prev,
       struct list_head *next,
       void (*sync)(void))
{
 struct list_head *first = list->next;
 struct list_head *last = list->prev;







 INIT_LIST_HEAD_RCU(list);
# 250 "/home/nathan/src/linux-next/include/linux/rculist.h"
 sync();
# 260 "/home/nathan/src/linux-next/include/linux/rculist.h"
 last->next = next;
 do { uintptr_t _r_a_p__v = (uintptr_t)(first); ; if (__builtin_constant_p(first) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_83(void) ; if (!((sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(char) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(short) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(int) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(long)) || sizeof(((*((struct list_head **)(&(prev)->next))))) == sizeof(long long))) __compiletime_assert_83(); } while (0); do { *(volatile typeof(((*((struct list_head **)(&(prev)->next))))) *)&(((*((struct list_head **)(&(prev)->next))))) = ((typeof((*((struct list_head **)(&(prev)->next)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_84(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_84(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_85(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long long))) __compiletime_assert_85(); } while (0); do { *(volatile typeof(*&(*((struct list_head **)(&(prev)->next)))) *)&(*&(*((struct list_head **)(&(prev)->next)))) = ((typeof(*((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 first->prev = prev;
 next->prev = last;
}
# 273 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_init_rcu(struct list_head *list,
     struct list_head *head,
     void (*sync)(void))
{
 if (!list_empty(list))
  __list_splice_init_rcu(list, head, head->next, sync);
}
# 288 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail_init_rcu(struct list_head *list,
          struct list_head *head,
          void (*sync)(void))
{
 if (!list_empty(list))
  __list_splice_init_rcu(list, head->prev, head, sync);
}
# 483 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_rcu(struct hlist_node *n)
{
 __hlist_del(n);
 do { do { extern void __compiletime_assert_86(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_86(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (((void *) 0x122 + (0x5deadbeef0000000UL))); } while (0); } while (0);
}
# 496 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_replace_rcu(struct hlist_node *old,
     struct hlist_node *new)
{
 struct hlist_node *next = old->next;

 new->next = next;
 do { do { extern void __compiletime_assert_87(void) ; if (!((sizeof(new->pprev) == sizeof(char) || sizeof(new->pprev) == sizeof(short) || sizeof(new->pprev) == sizeof(int) || sizeof(new->pprev) == sizeof(long)) || sizeof(new->pprev) == sizeof(long long))) __compiletime_assert_87(); } while (0); do { *(volatile typeof(new->pprev) *)&(new->pprev) = (old->pprev); } while (0); } while (0);
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_88(void) ; if (!((sizeof((*(struct hlist_node **)new->pprev)) == sizeof(char) || sizeof((*(struct hlist_node **)new->pprev)) == sizeof(short) || sizeof((*(struct hlist_node **)new->pprev)) == sizeof(int) || sizeof((*(struct hlist_node **)new->pprev)) == sizeof(long)) || sizeof((*(struct hlist_node **)new->pprev)) == sizeof(long long))) __compiletime_assert_88(); } while (0); do { *(volatile typeof((*(struct hlist_node **)new->pprev)) *)&((*(struct hlist_node **)new->pprev)) = ((typeof(*(struct hlist_node **)new->pprev))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_89(void) ; if (!((sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(char) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(short) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(int) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(long)))) __compiletime_assert_89(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_90(void) ; if (!((sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(char) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(short) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(int) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(long)) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(long long))) __compiletime_assert_90(); } while (0); do { *(volatile typeof(*&*(struct hlist_node **)new->pprev) *)&(*&*(struct hlist_node **)new->pprev) = ((typeof(*((typeof(*(struct hlist_node **)new->pprev))_r_a_p__v)) *)((typeof(*(struct hlist_node **)new->pprev))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 if (next)
  do { do { extern void __compiletime_assert_91(void) ; if (!((sizeof(new->next->pprev) == sizeof(char) || sizeof(new->next->pprev) == sizeof(short) || sizeof(new->next->pprev) == sizeof(int) || sizeof(new->next->pprev) == sizeof(long)) || sizeof(new->next->pprev) == sizeof(long long))) __compiletime_assert_91(); } while (0); do { *(volatile typeof(new->next->pprev) *)&(new->next->pprev) = (&new->next); } while (0); } while (0);
 do { do { extern void __compiletime_assert_92(void) ; if (!((sizeof(old->pprev) == sizeof(char) || sizeof(old->pprev) == sizeof(short) || sizeof(old->pprev) == sizeof(int) || sizeof(old->pprev) == sizeof(long)) || sizeof(old->pprev) == sizeof(long long))) __compiletime_assert_92(); } while (0); do { *(volatile typeof(old->pprev) *)&(old->pprev) = (((void *) 0x122 + (0x5deadbeef0000000UL))); } while (0); } while (0);
}
# 519 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlists_swap_heads_rcu(struct hlist_head *left, struct hlist_head *right)
{
 struct hlist_node *node1 = left->first;
 struct hlist_node *node2 = right->first;

 do { uintptr_t _r_a_p__v = (uintptr_t)(node2); ; if (__builtin_constant_p(node2) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_93(void) ; if (!((sizeof((left->first)) == sizeof(char) || sizeof((left->first)) == sizeof(short) || sizeof((left->first)) == sizeof(int) || sizeof((left->first)) == sizeof(long)) || sizeof((left->first)) == sizeof(long long))) __compiletime_assert_93(); } while (0); do { *(volatile typeof((left->first)) *)&((left->first)) = ((typeof(left->first))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_94(void) ; if (!((sizeof(*&left->first) == sizeof(char) || sizeof(*&left->first) == sizeof(short) || sizeof(*&left->first) == sizeof(int) || sizeof(*&left->first) == sizeof(long)))) __compiletime_assert_94(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_95(void) ; if (!((sizeof(*&left->first) == sizeof(char) || sizeof(*&left->first) == sizeof(short) || sizeof(*&left->first) == sizeof(int) || sizeof(*&left->first) == sizeof(long)) || sizeof(*&left->first) == sizeof(long long))) __compiletime_assert_95(); } while (0); do { *(volatile typeof(*&left->first) *)&(*&left->first) = ((typeof(*((typeof(left->first))_r_a_p__v)) *)((typeof(left->first))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 do { uintptr_t _r_a_p__v = (uintptr_t)(node1); ; if (__builtin_constant_p(node1) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_96(void) ; if (!((sizeof((right->first)) == sizeof(char) || sizeof((right->first)) == sizeof(short) || sizeof((right->first)) == sizeof(int) || sizeof((right->first)) == sizeof(long)) || sizeof((right->first)) == sizeof(long long))) __compiletime_assert_96(); } while (0); do { *(volatile typeof((right->first)) *)&((right->first)) = ((typeof(right->first))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_97(void) ; if (!((sizeof(*&right->first) == sizeof(char) || sizeof(*&right->first) == sizeof(short) || sizeof(*&right->first) == sizeof(int) || sizeof(*&right->first) == sizeof(long)))) __compiletime_assert_97(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_98(void) ; if (!((sizeof(*&right->first) == sizeof(char) || sizeof(*&right->first) == sizeof(short) || sizeof(*&right->first) == sizeof(int) || sizeof(*&right->first) == sizeof(long)) || sizeof(*&right->first) == sizeof(long long))) __compiletime_assert_98(); } while (0); do { *(volatile typeof(*&right->first) *)&(*&right->first) = ((typeof(*((typeof(right->first))_r_a_p__v)) *)((typeof(right->first))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 do { do { extern void __compiletime_assert_99(void) ; if (!((sizeof(node2->pprev) == sizeof(char) || sizeof(node2->pprev) == sizeof(short) || sizeof(node2->pprev) == sizeof(int) || sizeof(node2->pprev) == sizeof(long)) || sizeof(node2->pprev) == sizeof(long long))) __compiletime_assert_99(); } while (0); do { *(volatile typeof(node2->pprev) *)&(node2->pprev) = (&left->first); } while (0); } while (0);
 do { do { extern void __compiletime_assert_100(void) ; if (!((sizeof(node1->pprev) == sizeof(char) || sizeof(node1->pprev) == sizeof(short) || sizeof(node1->pprev) == sizeof(int) || sizeof(node1->pprev) == sizeof(long)) || sizeof(node1->pprev) == sizeof(long long))) __compiletime_assert_100(); } while (0); do { *(volatile typeof(node1->pprev) *)&(node1->pprev) = (&right->first); } while (0); } while (0);
}
# 556 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_head_rcu(struct hlist_node *n,
     struct hlist_head *h)
{
 struct hlist_node *first = h->first;

 n->next = first;
 do { do { extern void __compiletime_assert_101(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_101(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (&h->first); } while (0); } while (0);
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_102(void) ; if (!((sizeof(((*((struct hlist_node **)(&(h)->first))))) == sizeof(char) || sizeof(((*((struct hlist_node **)(&(h)->first))))) == sizeof(short) || sizeof(((*((struct hlist_node **)(&(h)->first))))) == sizeof(int) || sizeof(((*((struct hlist_node **)(&(h)->first))))) == sizeof(long)) || sizeof(((*((struct hlist_node **)(&(h)->first))))) == sizeof(long long))) __compiletime_assert_102(); } while (0); do { *(volatile typeof(((*((struct hlist_node **)(&(h)->first))))) *)&(((*((struct hlist_node **)(&(h)->first))))) = ((typeof((*((struct hlist_node **)(&(h)->first)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_103(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(long)))) __compiletime_assert_103(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_104(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(long)) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(long long))) __compiletime_assert_104(); } while (0); do { *(volatile typeof(*&(*((struct hlist_node **)(&(h)->first)))) *)&(*&(*((struct hlist_node **)(&(h)->first)))) = ((typeof(*((typeof((*((struct hlist_node **)(&(h)->first)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(h)->first)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 if (first)
  do { do { extern void __compiletime_assert_105(void) ; if (!((sizeof(first->pprev) == sizeof(char) || sizeof(first->pprev) == sizeof(short) || sizeof(first->pprev) == sizeof(int) || sizeof(first->pprev) == sizeof(long)) || sizeof(first->pprev) == sizeof(long long))) __compiletime_assert_105(); } while (0); do { *(volatile typeof(first->pprev) *)&(first->pprev) = (&n->next); } while (0); } while (0);
}
# 587 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_tail_rcu(struct hlist_node *n,
          struct hlist_head *h)
{
 struct hlist_node *i, *last = ((void *)0);


 for (i = h->first; i; i = i->next)
  last = i;

 if (last) {
  n->next = last->next;
  do { do { extern void __compiletime_assert_106(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_106(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (&last->next); } while (0); } while (0);
  do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_107(void) ; if (!((sizeof(((*((struct hlist_node **)(&(last)->next))))) == sizeof(char) || sizeof(((*((struct hlist_node **)(&(last)->next))))) == sizeof(short) || sizeof(((*((struct hlist_node **)(&(last)->next))))) == sizeof(int) || sizeof(((*((struct hlist_node **)(&(last)->next))))) == sizeof(long)) || sizeof(((*((struct hlist_node **)(&(last)->next))))) == sizeof(long long))) __compiletime_assert_107(); } while (0); do { *(volatile typeof(((*((struct hlist_node **)(&(last)->next))))) *)&(((*((struct hlist_node **)(&(last)->next))))) = ((typeof((*((struct hlist_node **)(&(last)->next)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_108(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(long)))) __compiletime_assert_108(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_109(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(long)) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(long long))) __compiletime_assert_109(); } while (0); do { *(volatile typeof(*&(*((struct hlist_node **)(&(last)->next)))) *)&(*&(*((struct hlist_node **)(&(last)->next)))) = ((typeof(*((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 } else {
  hlist_add_head_rcu(n, h);
 }
}
# 623 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_before_rcu(struct hlist_node *n,
     struct hlist_node *next)
{
 do { do { extern void __compiletime_assert_110(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_110(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (next->pprev); } while (0); } while (0);
 n->next = next;
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_111(void) ; if (!((sizeof(((*((struct hlist_node **)((n)->pprev))))) == sizeof(char) || sizeof(((*((struct hlist_node **)((n)->pprev))))) == sizeof(short) || sizeof(((*((struct hlist_node **)((n)->pprev))))) == sizeof(int) || sizeof(((*((struct hlist_node **)((n)->pprev))))) == sizeof(long)) || sizeof(((*((struct hlist_node **)((n)->pprev))))) == sizeof(long long))) __compiletime_assert_111(); } while (0); do { *(volatile typeof(((*((struct hlist_node **)((n)->pprev))))) *)&(((*((struct hlist_node **)((n)->pprev))))) = ((typeof((*((struct hlist_node **)((n)->pprev)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_112(void) ; if (!((sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(long)))) __compiletime_assert_112(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_113(void) ; if (!((sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(long)) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(long long))) __compiletime_assert_113(); } while (0); do { *(volatile typeof(*&(*((struct hlist_node **)((n)->pprev)))) *)&(*&(*((struct hlist_node **)((n)->pprev)))) = ((typeof(*((typeof((*((struct hlist_node **)((n)->pprev)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)((n)->pprev)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 do { do { extern void __compiletime_assert_114(void) ; if (!((sizeof(next->pprev) == sizeof(char) || sizeof(next->pprev) == sizeof(short) || sizeof(next->pprev) == sizeof(int) || sizeof(next->pprev) == sizeof(long)) || sizeof(next->pprev) == sizeof(long long))) __compiletime_assert_114(); } while (0); do { *(volatile typeof(next->pprev) *)&(next->pprev) = (&n->next); } while (0); } while (0);
}
# 650 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_behind_rcu(struct hlist_node *n,
     struct hlist_node *prev)
{
 n->next = prev->next;
 do { do { extern void __compiletime_assert_115(void) ; if (!((sizeof(n->pprev) == sizeof(char) || sizeof(n->pprev) == sizeof(short) || sizeof(n->pprev) == sizeof(int) || sizeof(n->pprev) == sizeof(long)) || sizeof(n->pprev) == sizeof(long long))) __compiletime_assert_115(); } while (0); do { *(volatile typeof(n->pprev) *)&(n->pprev) = (&prev->next); } while (0); } while (0);
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_116(void) ; if (!((sizeof(((*((struct hlist_node **)(&(prev)->next))))) == sizeof(char) || sizeof(((*((struct hlist_node **)(&(prev)->next))))) == sizeof(short) || sizeof(((*((struct hlist_node **)(&(prev)->next))))) == sizeof(int) || sizeof(((*((struct hlist_node **)(&(prev)->next))))) == sizeof(long)) || sizeof(((*((struct hlist_node **)(&(prev)->next))))) == sizeof(long long))) __compiletime_assert_116(); } while (0); do { *(volatile typeof(((*((struct hlist_node **)(&(prev)->next))))) *)&(((*((struct hlist_node **)(&(prev)->next))))) = ((typeof((*((struct hlist_node **)(&(prev)->next)))))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_117(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_117(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_118(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(long)) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(long long))) __compiletime_assert_118(); } while (0); do { *(volatile typeof(*&(*((struct hlist_node **)(&(prev)->next)))) *)&(*&(*((struct hlist_node **)(&(prev)->next)))) = ((typeof(*((typeof((*((struct hlist_node **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(prev)->next)))))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 if (n->next)
  do { do { extern void __compiletime_assert_119(void) ; if (!((sizeof(n->next->pprev) == sizeof(char) || sizeof(n->next->pprev) == sizeof(short) || sizeof(n->next->pprev) == sizeof(int) || sizeof(n->next->pprev) == sizeof(long)) || sizeof(n->next->pprev) == sizeof(long long))) __compiletime_assert_119(); } while (0); do { *(volatile typeof(n->next->pprev) *)&(n->next->pprev) = (&n->next); } while (0); } while (0);
}
# 8 "/home/nathan/src/linux-next/include/linux/dcache.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rculist_bl.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/list_bl.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/bit_spinlock.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/bit_spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bit_spin_lock(int bitnum, unsigned long *addr)
{







 __asm__ __volatile__("" : : : "memory");

 while (__builtin_expect(!!(test_and_set_bit_lock(bitnum, addr)), 0)) {
  __asm__ __volatile__("" : : : "memory");
  do {
   do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
  } while (test_bit(bitnum, addr));
  __asm__ __volatile__("" : : : "memory");
 }

 (void)0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bit_spin_trylock(int bitnum, unsigned long *addr)
{
 __asm__ __volatile__("" : : : "memory");

 if (__builtin_expect(!!(test_and_set_bit_lock(bitnum, addr)), 0)) {
  __asm__ __volatile__("" : : : "memory");
  return 0;
 }

 (void)0;
 return 1;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bit_spin_unlock(int bitnum, unsigned long *addr)
{




 clear_bit_unlock(bitnum, addr);

 __asm__ __volatile__("" : : : "memory");
 (void)0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __bit_spin_unlock(int bitnum, unsigned long *addr)
{




 __clear_bit_unlock(bitnum, addr);

 __asm__ __volatile__("" : : : "memory");
 (void)0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bit_spin_is_locked(int bitnum, unsigned long *addr)
{

 return test_bit(bitnum, addr);





}
# 7 "/home/nathan/src/linux-next/include/linux/list_bl.h" 2
# 34 "/home/nathan/src/linux-next/include/linux/list_bl.h"
struct hlist_bl_head {
 struct hlist_bl_node *first;
};

struct hlist_bl_node {
 struct hlist_bl_node *next, **pprev;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_HLIST_BL_NODE(struct hlist_bl_node *h)
{
 h->next = ((void *)0);
 h->pprev = ((void *)0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_unhashed(const struct hlist_bl_node *h)
{
 return !h->pprev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h)
{
 return (struct hlist_bl_node *)
  ((unsigned long)h->first & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_set_first(struct hlist_bl_head *h,
     struct hlist_bl_node *n)
{
 do { if (__builtin_constant_p((unsigned long)n & 1UL)) { if ((unsigned long)n & 1UL) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (66), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (66), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((unsigned long)n & 1UL))); } } while (0);
 do { if (__builtin_constant_p(((unsigned long)h->first & 1UL) != 1UL)) { if (((unsigned long)h->first & 1UL) != 1UL) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (68), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (68), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(((unsigned long)h->first & 1UL) != 1UL))); } } while (0);

 h->first = (struct hlist_bl_node *)((unsigned long)n | 1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_empty(const struct hlist_bl_head *h)
{
 return !((unsigned long)({ do { extern void __compiletime_assert_120(void) ; if (!((sizeof(h->first) == sizeof(char) || sizeof(h->first) == sizeof(short) || sizeof(h->first) == sizeof(int) || sizeof(h->first) == sizeof(long)) || sizeof(h->first) == sizeof(long long))) __compiletime_assert_120(); } while (0); ({ typeof( _Generic((h->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->first))) __x = (*(const volatile typeof( _Generic((h->first), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (h->first))) *)&(h->first)); do { } while (0); (typeof(h->first))__x; }); }) & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_head(struct hlist_bl_node *n,
     struct hlist_bl_head *h)
{
 struct hlist_bl_node *first = hlist_bl_first(h);

 n->next = first;
 if (first)
  first->pprev = &n->next;
 n->pprev = &h->first;
 hlist_bl_set_first(h, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_before(struct hlist_bl_node *n,
           struct hlist_bl_node *next)
{
 struct hlist_bl_node **pprev = next->pprev;

 n->pprev = pprev;
 n->next = next;
 next->pprev = &n->next;


 do { do { extern void __compiletime_assert_121(void) ; if (!((sizeof(*pprev) == sizeof(char) || sizeof(*pprev) == sizeof(short) || sizeof(*pprev) == sizeof(int) || sizeof(*pprev) == sizeof(long)) || sizeof(*pprev) == sizeof(long long))) __compiletime_assert_121(); } while (0); do { *(volatile typeof(*pprev) *)&(*pprev) = ((struct hlist_bl_node *) ((uintptr_t)n | ((uintptr_t)*pprev & 1UL))); } while (0); } while (0);


}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_behind(struct hlist_bl_node *n,
           struct hlist_bl_node *prev)
{
 n->next = prev->next;
 n->pprev = &prev->next;
 prev->next = n;

 if (n->next)
  n->next->pprev = &n->next;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hlist_bl_del(struct hlist_bl_node *n)
{
 struct hlist_bl_node *next = n->next;
 struct hlist_bl_node **pprev = n->pprev;

 do { if (__builtin_constant_p((unsigned long)n & 1UL)) { if ((unsigned long)n & 1UL) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (120), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/list_bl.h"), "i" (120), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((unsigned long)n & 1UL))); } } while (0);


 do { do { extern void __compiletime_assert_122(void) ; if (!((sizeof(*pprev) == sizeof(char) || sizeof(*pprev) == sizeof(short) || sizeof(*pprev) == sizeof(int) || sizeof(*pprev) == sizeof(long)) || sizeof(*pprev) == sizeof(long long))) __compiletime_assert_122(); } while (0); do { *(volatile typeof(*pprev) *)&(*pprev) = ((struct hlist_bl_node *) ((unsigned long)next | ((unsigned long)*pprev & 1UL))); } while (0); } while (0);



 if (next)
  next->pprev = pprev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del(struct hlist_bl_node *n)
{
 __hlist_bl_del(n);
 n->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del_init(struct hlist_bl_node *n)
{
 if (!hlist_bl_unhashed(n)) {
  __hlist_bl_del(n);
  INIT_HLIST_BL_NODE(n);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_lock(struct hlist_bl_head *b)
{
 bit_spin_lock(0, (unsigned long *)b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_unlock(struct hlist_bl_head *b)
{
 __bit_spin_unlock(0, (unsigned long *)b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_is_locked(struct hlist_bl_head *b)
{
 return bit_spin_is_locked(0, (unsigned long *)b);
}
# 9 "/home/nathan/src/linux-next/include/linux/rculist_bl.h" 2


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_set_first_rcu(struct hlist_bl_head *h,
     struct hlist_bl_node *n)
{
 do { if (__builtin_constant_p((unsigned long)n & 1UL)) { if ((unsigned long)n & 1UL) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rculist_bl.h"), "i" (14), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rculist_bl.h"), "i" (14), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((unsigned long)n & 1UL))); } } while (0);
 do { if (__builtin_constant_p(((unsigned long)h->first & 1UL) != 1UL)) { if (((unsigned long)h->first & 1UL) != 1UL) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rculist_bl.h"), "i" (16), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rculist_bl.h"), "i" (16), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(((unsigned long)h->first & 1UL) != 1UL))); } } while (0);

 do { uintptr_t _r_a_p__v = (uintptr_t)((struct hlist_bl_node *)((unsigned long)n | 1UL)); ; if (__builtin_constant_p((struct hlist_bl_node *)((unsigned long)n | 1UL)) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_123(void) ; if (!((sizeof((h->first)) == sizeof(char) || sizeof((h->first)) == sizeof(short) || sizeof((h->first)) == sizeof(int) || sizeof((h->first)) == sizeof(long)) || sizeof((h->first)) == sizeof(long long))) __compiletime_assert_123(); } while (0); do { *(volatile typeof((h->first)) *)&((h->first)) = ((typeof(h->first))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_124(void) ; if (!((sizeof(*&h->first) == sizeof(char) || sizeof(*&h->first) == sizeof(short) || sizeof(*&h->first) == sizeof(int) || sizeof(*&h->first) == sizeof(long)))) __compiletime_assert_124(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_125(void) ; if (!((sizeof(*&h->first) == sizeof(char) || sizeof(*&h->first) == sizeof(short) || sizeof(*&h->first) == sizeof(int) || sizeof(*&h->first) == sizeof(long)) || sizeof(*&h->first) == sizeof(long long))) __compiletime_assert_125(); } while (0); do { *(volatile typeof(*&h->first) *)&(*&h->first) = ((typeof(*((typeof(h->first))_r_a_p__v)) *)((typeof(h->first))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hlist_bl_node *hlist_bl_first_rcu(struct hlist_bl_head *h)
{
 return (struct hlist_bl_node *)
  ((unsigned long)({ typeof(*(h->first)) *________p1 = (typeof(*(h->first)) *)({ do { extern void __compiletime_assert_126(void) ; if (!((sizeof((h->first)) == sizeof(char) || sizeof((h->first)) == sizeof(short) || sizeof((h->first)) == sizeof(int) || sizeof((h->first)) == sizeof(long)) || sizeof((h->first)) == sizeof(long long))) __compiletime_assert_126(); } while (0); ({ typeof( _Generic(((h->first)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((h->first)))) __x = (*(const volatile typeof( _Generic(((h->first)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((h->first)))) *)&((h->first))); do { } while (0); (typeof((h->first)))__x; }); }); do { } while (0); ; ((typeof(*(h->first)) *)(________p1)); }) & ~1UL);
}
# 46 "/home/nathan/src/linux-next/include/linux/rculist_bl.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del_rcu(struct hlist_bl_node *n)
{
 __hlist_bl_del(n);
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 71 "/home/nathan/src/linux-next/include/linux/rculist_bl.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_head_rcu(struct hlist_bl_node *n,
     struct hlist_bl_head *h)
{
 struct hlist_bl_node *first;


 first = hlist_bl_first(h);

 n->next = first;
 if (first)
  first->pprev = &n->next;
 n->pprev = &h->first;


 hlist_bl_set_first_rcu(h, n);
}
# 9 "/home/nathan/src/linux-next/include/linux/dcache.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/lockref.h" 1
# 25 "/home/nathan/src/linux-next/include/linux/lockref.h"
struct lockref {
 union {

  __u64 __attribute__((aligned(8))) lock_count;

  struct {
   spinlock_t lock;
   int count;
  };
 };
};

extern void lockref_get(struct lockref *);
extern int lockref_put_return(struct lockref *);
extern int lockref_get_not_zero(struct lockref *);
extern int lockref_put_not_zero(struct lockref *);
extern int lockref_get_or_lock(struct lockref *);
extern int lockref_put_or_lock(struct lockref *);

extern void lockref_mark_dead(struct lockref *);
extern int lockref_get_not_dead(struct lockref *);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __lockref_is_dead(const struct lockref *l)
{
 return ((int)l->count < 0);
}
# 14 "/home/nathan/src/linux-next/include/linux/dcache.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/stringhash.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/hash.h" 1
# 60 "/home/nathan/src/linux-next/include/linux/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __hash_32_generic(u32 val)
{
 return val * 0x61C88647;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash_32_generic(u32 val, unsigned int bits)
{

 return __hash_32_generic(val) >> (32 - bits);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32 hash_64_generic(u64 val, unsigned int bits)
{


 return val * 0x61C8864680B583EBull >> (64 - bits);




}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash_ptr(const void *ptr, unsigned int bits)
{
 return hash_64_generic((unsigned long)ptr, bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash32_ptr(const void *ptr)
{
 unsigned long val = (unsigned long)ptr;


 val ^= (val >> 32);

 return (u32)val;
}
# 8 "/home/nathan/src/linux-next/include/linux/stringhash.h" 2
# 42 "/home/nathan/src/linux-next/include/linux/stringhash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
partial_name_hash(unsigned long c, unsigned long prevhash)
{
 return (prevhash + (c << 4) + (c >> 4)) * 11;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int end_name_hash(unsigned long hash)
{
 return hash_64_generic(hash, 32);
}
# 66 "/home/nathan/src/linux-next/include/linux/stringhash.h"
extern unsigned int __attribute__((__pure__)) full_name_hash(const void *salt, const char *, unsigned int);
# 77 "/home/nathan/src/linux-next/include/linux/stringhash.h"
extern u64 __attribute__((__pure__)) hashlen_string(const void *salt, const char *name);
# 15 "/home/nathan/src/linux-next/include/linux/dcache.h" 2


struct path;
struct vfsmount;
# 47 "/home/nathan/src/linux-next/include/linux/dcache.h"
struct qstr {
 union {
  struct {
   u32 hash; u32 len;
  };
  u64 hash_len;
 };
 const unsigned char *name;
};



extern const struct qstr empty_name;
extern const struct qstr slash_name;

struct dentry_stat_t {
 long nr_dentry;
 long nr_unused;
 long age_limit;
 long want_pages;
 long nr_negative;
 long dummy;
};
extern struct dentry_stat_t dentry_stat;
# 89 "/home/nathan/src/linux-next/include/linux/dcache.h"
struct dentry {

 unsigned int d_flags;
 seqcount_t d_seq;
 struct hlist_bl_node d_hash;
 struct dentry *d_parent;
 struct qstr d_name;
 struct inode *d_inode;

 unsigned char d_iname[32];


 struct lockref d_lockref;
 const struct dentry_operations *d_op;
 struct super_block *d_sb;
 unsigned long d_time;
 void *d_fsdata;

 union {
  struct list_head d_lru;
  wait_queue_head_t *d_wait;
 };
 struct list_head d_child;
 struct list_head d_subdirs;



 union {
  struct hlist_node d_alias;
  struct hlist_bl_node d_in_lookup_hash;
   struct callback_head d_rcu;
 } d_u;
} ;







enum dentry_d_lock_class
{
 DENTRY_D_LOCK_NORMAL,
 DENTRY_D_LOCK_NESTED
};

struct dentry_operations {
 int (*d_revalidate)(struct dentry *, unsigned int);
 int (*d_weak_revalidate)(struct dentry *, unsigned int);
 int (*d_hash)(const struct dentry *, struct qstr *);
 int (*d_compare)(const struct dentry *,
   unsigned int, const char *, const struct qstr *);
 int (*d_delete)(const struct dentry *);
 int (*d_init)(struct dentry *);
 void (*d_release)(struct dentry *);
 void (*d_prune)(struct dentry *);
 void (*d_iput)(struct dentry *, struct inode *);
 char *(*d_dname)(struct dentry *, char *, int);
 struct vfsmount *(*d_automount)(struct path *);
 int (*d_manage)(const struct path *, bool);
 struct dentry *(*d_real)(struct dentry *, const struct inode *);
} __attribute__((__aligned__((1 << 7))));
# 224 "/home/nathan/src/linux-next/include/linux/dcache.h"
extern seqlock_t rename_lock;




extern void d_instantiate(struct dentry *, struct inode *);
extern void d_instantiate_new(struct dentry *, struct inode *);
extern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);
extern struct dentry * d_instantiate_anon(struct dentry *, struct inode *);
extern void __d_drop(struct dentry *dentry);
extern void d_drop(struct dentry *dentry);
extern void d_delete(struct dentry *);
extern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op);


extern struct dentry * d_alloc(struct dentry *, const struct qstr *);
extern struct dentry * d_alloc_anon(struct super_block *);
extern struct dentry * d_alloc_parallel(struct dentry *, const struct qstr *,
     wait_queue_head_t *);
extern struct dentry * d_splice_alias(struct inode *, struct dentry *);
extern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);
extern struct dentry * d_exact_alias(struct dentry *, struct inode *);
extern struct dentry *d_find_any_alias(struct inode *inode);
extern struct dentry * d_obtain_alias(struct inode *);
extern struct dentry * d_obtain_root(struct inode *);
extern void shrink_dcache_sb(struct super_block *);
extern void shrink_dcache_parent(struct dentry *);
extern void shrink_dcache_for_umount(struct super_block *);
extern void d_invalidate(struct dentry *);


extern struct dentry * d_make_root(struct inode *);


extern void d_genocide(struct dentry *);

extern void d_tmpfile(struct dentry *, struct inode *);

extern struct dentry *d_find_alias(struct inode *);
extern void d_prune_aliases(struct inode *);


extern int path_has_submounts(const struct path *);




extern void d_rehash(struct dentry *);

extern void d_add(struct dentry *, struct inode *);


extern void d_move(struct dentry *, struct dentry *);
extern void d_exchange(struct dentry *, struct dentry *);
extern struct dentry *d_ancestor(struct dentry *, struct dentry *);


extern struct dentry *d_lookup(const struct dentry *, const struct qstr *);
extern struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);
extern struct dentry *__d_lookup(const struct dentry *, const struct qstr *);
extern struct dentry *__d_lookup_rcu(const struct dentry *parent,
    const struct qstr *name, unsigned *seq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned d_count(const struct dentry *dentry)
{
 return dentry->d_lockref.count;
}




extern __attribute__((__format__(printf, 4, 5)))
char *dynamic_dname(struct dentry *, char *, int, const char *, ...);

extern char *__d_path(const struct path *, const struct path *, char *, int);
extern char *d_absolute_path(const struct path *, char *, int);
extern char *d_path(const struct path *, char *, int);
extern char *dentry_path_raw(struct dentry *, char *, int);
extern char *dentry_path(struct dentry *, char *, int);
# 314 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *dget_dlock(struct dentry *dentry)
{
 if (dentry)
  dentry->d_lockref.count++;
 return dentry;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *dget(struct dentry *dentry)
{
 if (dentry)
  lockref_get(&dentry->d_lockref);
 return dentry;
}

extern struct dentry *dget_parent(struct dentry *dentry);
# 337 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_unhashed(const struct dentry *dentry)
{
 return hlist_bl_unhashed(&dentry->d_hash);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_unlinked(const struct dentry *dentry)
{
 return d_unhashed(dentry) && !((dentry) == (dentry)->d_parent);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cant_mount(const struct dentry *dentry)
{
 return (dentry->d_flags & 0x00000100);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dont_mount(struct dentry *dentry)
{
 spin_lock(&dentry->d_lockref.lock);
 dentry->d_flags |= 0x00000100;
 spin_unlock(&dentry->d_lockref.lock);
}

extern void __d_lookup_done(struct dentry *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_in_lookup(const struct dentry *dentry)
{
 return dentry->d_flags & 0x10000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void d_lookup_done(struct dentry *dentry)
{
 if (__builtin_expect(!!(d_in_lookup(dentry)), 0)) {
  spin_lock(&dentry->d_lockref.lock);
  __d_lookup_done(dentry);
  spin_unlock(&dentry->d_lockref.lock);
 }
}

extern void dput(struct dentry *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_managed(const struct dentry *dentry)
{
 return dentry->d_flags & (0x00010000|0x00020000|0x00040000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_mountpoint(const struct dentry *dentry)
{
 return dentry->d_flags & 0x00010000;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned __d_entry_type(const struct dentry *dentry)
{
 return dentry->d_flags & 0x00700000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_miss(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_whiteout(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00100000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_can_lookup(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00200000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_autodir(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00300000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_dir(const struct dentry *dentry)
{
 return d_can_lookup(dentry) || d_is_autodir(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_symlink(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00600000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_reg(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00400000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_special(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00500000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_file(const struct dentry *dentry)
{
 return d_is_reg(dentry) || d_is_special(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_negative(const struct dentry *dentry)
{

 return d_is_miss(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_flags_negative(unsigned flags)
{
 return (flags & 0x00700000) == 0x00000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_positive(const struct dentry *dentry)
{
 return !d_is_negative(dentry);
}
# 471 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_really_is_negative(const struct dentry *dentry)
{
 return dentry->d_inode == ((void *)0);
}
# 489 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_really_is_positive(const struct dentry *dentry)
{
 return dentry->d_inode != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int simple_positive(const struct dentry *dentry)
{
 return d_really_is_positive(dentry) && !d_unhashed(dentry);
}

extern void d_set_fallthru(struct dentry *dentry);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_fallthru(const struct dentry *dentry)
{
 return dentry->d_flags & 0x01000000;
}


extern int sysctl_vfs_cache_pressure;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vfs_pressure_ratio(unsigned long val)
{
 return ( { typeof(val) quot = (val) / (100); typeof(val) rem = (val) % (100); (quot * (sysctl_vfs_cache_pressure)) + ((rem * (sysctl_vfs_cache_pressure)) / (100)); } );
}
# 521 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_inode(const struct dentry *dentry)
{
 return dentry->d_inode;
}
# 533 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_inode_rcu(const struct dentry *dentry)
{
 return ({ do { extern void __compiletime_assert_127(void) ; if (!((sizeof(dentry->d_inode) == sizeof(char) || sizeof(dentry->d_inode) == sizeof(short) || sizeof(dentry->d_inode) == sizeof(int) || sizeof(dentry->d_inode) == sizeof(long)) || sizeof(dentry->d_inode) == sizeof(long long))) __compiletime_assert_127(); } while (0); ({ typeof( _Generic((dentry->d_inode), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (dentry->d_inode))) __x = (*(const volatile typeof( _Generic((dentry->d_inode), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (dentry->d_inode))) *)&(dentry->d_inode)); do { } while (0); (typeof(dentry->d_inode))__x; }); });
}
# 548 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_backing_inode(const struct dentry *upper)
{
 struct inode *inode = upper->d_inode;

 return inode;
}
# 565 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *d_backing_dentry(struct dentry *upper)
{
 return upper;
}
# 580 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *d_real(struct dentry *dentry,
        const struct inode *inode)
{
 if (__builtin_expect(!!(dentry->d_flags & 0x04000000), 0))
  return dentry->d_op->d_real(dentry, inode);
 else
  return dentry;
}
# 596 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_real_inode(const struct dentry *dentry)
{

 return d_backing_inode(d_real((struct dentry *) dentry, ((void *)0)));
}

struct name_snapshot {
 struct qstr name;
 unsigned char inline_name[32];
};
void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
void release_dentry_name_snapshot(struct name_snapshot *);
# 9 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/path.h" 1




struct dentry;
struct vfsmount;

struct path {
 struct vfsmount *mnt;
 struct dentry *dentry;
} ;

extern void path_get(const struct path *);
extern void path_put(const struct path *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int path_equal(const struct path *path1, const struct path *path2)
{
 return path1->mnt == path2->mnt && path1->dentry == path2->dentry;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void path_put_init(struct path *path)
{
 path_put(path);
 *path = (struct path) { };
}
# 10 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/stat.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/stat.h" 1
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/stat.h"
struct stat {
 unsigned long st_dev;
 ino_t st_ino;

 unsigned long st_nlink;
 mode_t st_mode;




 uid_t st_uid;
 gid_t st_gid;
 unsigned long st_rdev;
 long st_size;
 unsigned long st_blksize;
 unsigned long st_blocks;
 unsigned long st_atime;
 unsigned long st_atime_nsec;
 unsigned long st_mtime;
 unsigned long st_mtime_nsec;
 unsigned long st_ctime;
 unsigned long st_ctime_nsec;
 unsigned long __unused4;
 unsigned long __unused5;

 unsigned long __unused6;

};


struct stat64 {
 unsigned long long st_dev;
 unsigned long long st_ino;
 unsigned int st_mode;
 unsigned int st_nlink;
 unsigned int st_uid;
 unsigned int st_gid;
 unsigned long long st_rdev;
 unsigned short __pad2;
 long long st_size;
 int st_blksize;
 long long st_blocks;
 int st_atime;
 unsigned int st_atime_nsec;
 int st_mtime;
 unsigned int st_mtime_nsec;
 int st_ctime;
 unsigned int st_ctime_nsec;
 unsigned int __unused4;
 unsigned int __unused5;
};
# 7 "/home/nathan/src/linux-next/include/linux/stat.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/stat.h" 1
# 56 "/home/nathan/src/linux-next/include/uapi/linux/stat.h"
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/home/nathan/src/linux-next/include/uapi/linux/stat.h"
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 stx_mnt_id;
 __u64 __spare2;

 __u64 __spare3[12];

};
# 8 "/home/nathan/src/linux-next/include/linux/stat.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/stat.h"
# 1 "/home/nathan/src/linux-next/include/linux/uidgid.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/uidgid.h"
# 1 "/home/nathan/src/linux-next/include/linux/highuid.h" 1
# 35 "/home/nathan/src/linux-next/include/linux/highuid.h"
extern int overflowuid;
extern int overflowgid;

extern void __bad_uid(void);
extern void __bad_gid(void);
# 82 "/home/nathan/src/linux-next/include/linux/highuid.h"
extern int fs_overflowuid;
extern int fs_overflowgid;
# 17 "/home/nathan/src/linux-next/include/linux/uidgid.h" 2

struct user_namespace;
extern struct user_namespace init_user_ns;

typedef struct {
 uid_t val;
} kuid_t;


typedef struct {
 gid_t val;
} kgid_t;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t __kuid_val(kuid_t uid)
{
 return uid.val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t __kgid_val(kgid_t gid)
{
 return gid.val;
}
# 61 "/home/nathan/src/linux-next/include/linux/uidgid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_eq(kuid_t left, kuid_t right)
{
 return __kuid_val(left) == __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_eq(kgid_t left, kgid_t right)
{
 return __kgid_val(left) == __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_gt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) > __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_gt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) > __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_gte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) >= __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_gte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) >= __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_lt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) < __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_lt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) < __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_lte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) <= __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_lte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) <= __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_valid(kuid_t uid)
{
 return __kuid_val(uid) != (uid_t) -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_valid(kgid_t gid)
{
 return __kgid_val(gid) != (gid_t) -1;
}



extern kuid_t make_kuid(struct user_namespace *from, uid_t uid);
extern kgid_t make_kgid(struct user_namespace *from, gid_t gid);

extern uid_t from_kuid(struct user_namespace *to, kuid_t uid);
extern gid_t from_kgid(struct user_namespace *to, kgid_t gid);
extern uid_t from_kuid_munged(struct user_namespace *to, kuid_t uid);
extern gid_t from_kgid_munged(struct user_namespace *to, kgid_t gid);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
{
 return from_kuid(ns, uid) != (uid_t) -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
{
 return from_kgid(ns, gid) != (gid_t) -1;
}
# 21 "/home/nathan/src/linux-next/include/linux/stat.h" 2



struct kstat {
 u32 result_mask;
 umode_t mode;
 unsigned int nlink;
 uint32_t blksize;
 u64 attributes;
 u64 attributes_mask;
# 39 "/home/nathan/src/linux-next/include/linux/stat.h"
 u64 ino;
 dev_t dev;
 dev_t rdev;
 kuid_t uid;
 kgid_t gid;
 loff_t size;
 struct timespec64 atime;
 struct timespec64 mtime;
 struct timespec64 ctime;
 struct timespec64 btime;
 u64 blocks;
 u64 mnt_id;
};
# 11 "/home/nathan/src/linux-next/include/linux/fs.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/list_lru.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/list_lru.h"
# 1 "/home/nathan/src/linux-next/include/linux/shrinker.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/shrinker.h"
struct shrink_control {
 gfp_t gfp_mask;


 int nid;






 unsigned long nr_to_scan;






 unsigned long nr_scanned;


 struct mem_cgroup *memcg;
};
# 60 "/home/nathan/src/linux-next/include/linux/shrinker.h"
struct shrinker {
 unsigned long (*count_objects)(struct shrinker *,
           struct shrink_control *sc);
 unsigned long (*scan_objects)(struct shrinker *,
          struct shrink_control *sc);

 long batch;
 int seeks;
 unsigned flags;


 struct list_head list;


 int id;


 atomic_long_t *nr_deferred;
};
# 90 "/home/nathan/src/linux-next/include/linux/shrinker.h"
extern int prealloc_shrinker(struct shrinker *shrinker);
extern void register_shrinker_prepared(struct shrinker *shrinker);
extern int register_shrinker(struct shrinker *shrinker);
extern void unregister_shrinker(struct shrinker *shrinker);
extern void free_prealloced_shrinker(struct shrinker *shrinker);
# 14 "/home/nathan/src/linux-next/include/linux/list_lru.h" 2

struct mem_cgroup;


enum lru_status {
 LRU_REMOVED,
 LRU_REMOVED_RETRY,

 LRU_ROTATE,
 LRU_SKIP,
 LRU_RETRY,

};

struct list_lru_one {
 struct list_head list;

 long nr_items;
};

struct list_lru_memcg {
 struct callback_head rcu;

 struct list_lru_one *lru[];
};

struct list_lru_node {

 spinlock_t lock;

 struct list_lru_one lru;


 struct list_lru_memcg *memcg_lrus;

 long nr_items;
} __attribute__((__aligned__((1 << 7))));

struct list_lru {
 struct list_lru_node *node;

 struct list_head list;
 int shrinker_id;
 bool memcg_aware;

};

void list_lru_destroy(struct list_lru *lru);
int __list_lru_init(struct list_lru *lru, bool memcg_aware,
      struct lock_class_key *key, struct shrinker *shrinker);
# 72 "/home/nathan/src/linux-next/include/linux/list_lru.h"
int memcg_update_all_list_lrus(int num_memcgs);
void memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg);
# 91 "/home/nathan/src/linux-next/include/linux/list_lru.h"
bool list_lru_add(struct list_lru *lru, struct list_head *item);
# 104 "/home/nathan/src/linux-next/include/linux/list_lru.h"
bool list_lru_del(struct list_lru *lru, struct list_head *item);
# 116 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_count_one(struct list_lru *lru,
     int nid, struct mem_cgroup *memcg);
unsigned long list_lru_count_node(struct list_lru *lru, int nid);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long list_lru_shrink_count(struct list_lru *lru,
        struct shrink_control *sc)
{
 return list_lru_count_one(lru, sc->nid, sc->memcg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long list_lru_count(struct list_lru *lru)
{
 long count = 0;
 int nid;

 for (((nid)) = __first_node(&(node_states[N_NORMAL_MEMORY])); ((nid)) < (1 << 8); ((nid)) = __next_node((((nid))), &((node_states[N_NORMAL_MEMORY]))))
  count += list_lru_count_node(lru, nid);

 return count;
}

void list_lru_isolate(struct list_lru_one *list, struct list_head *item);
void list_lru_isolate_move(struct list_lru_one *list, struct list_head *item,
      struct list_head *head);

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *item,
  struct list_lru_one *list, spinlock_t *lock, void *cb_arg);
# 166 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_walk_one(struct list_lru *lru,
    int nid, struct mem_cgroup *memcg,
    list_lru_walk_cb isolate, void *cb_arg,
    unsigned long *nr_to_walk);
# 183 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_walk_one_irq(struct list_lru *lru,
        int nid, struct mem_cgroup *memcg,
        list_lru_walk_cb isolate, void *cb_arg,
        unsigned long *nr_to_walk);
unsigned long list_lru_walk_node(struct list_lru *lru, int nid,
     list_lru_walk_cb isolate, void *cb_arg,
     unsigned long *nr_to_walk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_shrink_walk(struct list_lru *lru, struct shrink_control *sc,
       list_lru_walk_cb isolate, void *cb_arg)
{
 return list_lru_walk_one(lru, sc->nid, sc->memcg, isolate, cb_arg,
     &sc->nr_to_scan);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_shrink_walk_irq(struct list_lru *lru, struct shrink_control *sc,
    list_lru_walk_cb isolate, void *cb_arg)
{
 return list_lru_walk_one_irq(lru, sc->nid, sc->memcg, isolate, cb_arg,
         &sc->nr_to_scan);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_walk(struct list_lru *lru, list_lru_walk_cb isolate,
       void *cb_arg, unsigned long nr_to_walk)
{
 long isolated = 0;
 int nid;

 for (((nid)) = __first_node(&(node_states[N_NORMAL_MEMORY])); ((nid)) < (1 << 8); ((nid)) = __next_node((((nid))), &((node_states[N_NORMAL_MEMORY])))) {
  isolated += list_lru_walk_node(lru, nid, isolate,
            cb_arg, &nr_to_walk);
  if (nr_to_walk <= 0)
   break;
 }
 return isolated;
}
# 14 "/home/nathan/src/linux-next/include/linux/fs.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/radix-tree.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
# 1 "/home/nathan/src/linux-next/include/linux/xarray.h" 1
# 52 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_value(unsigned long v)
{
 ({ int __ret_warn_on = !!((long)v < 0); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/xarray.h"), "i" (54), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/xarray.h"), "i" (54), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return (void *)((v << 1) | 1);
}
# 65 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_value(const void *entry)
{
 return (unsigned long)entry >> 1;
}
# 77 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_value(const void *entry)
{
 return (unsigned long)entry & 1;
}
# 95 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_tag_pointer(void *p, unsigned long tag)
{
 return (void *)((unsigned long)p | tag);
}
# 110 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_untag_pointer(void *entry)
{
 return (void *)((unsigned long)entry & ~3UL);
}
# 125 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int xa_pointer_tag(void *entry)
{
 return (unsigned long)entry & 3UL;
}
# 143 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_internal(unsigned long v)
{
 return (void *)((v << 2) | 2);
}
# 155 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_internal(const void *entry)
{
 return (unsigned long)entry >> 2;
}
# 167 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_internal(const void *entry)
{
 return ((unsigned long)entry & 3) == 2;
}
# 183 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_zero(const void *entry)
{
 return __builtin_expect(!!(entry == xa_mk_internal(257)), 0);
}
# 199 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_err(const void *entry)
{
 return __builtin_expect(!!(xa_is_internal(entry) && entry >= xa_mk_internal(-4095)), 0);

}
# 217 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_err(void *entry)
{

 if (xa_is_err(entry))
  return (long)entry >> 2;
 return 0;
}
# 236 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_limit {
 u32 max;
 u32 min;
};






typedef unsigned xa_mark_t;







enum xa_lock_type {
 XA_LOCK_IRQ = 1,
 XA_LOCK_BH = 2,
};
# 292 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xarray {
 spinlock_t xa_lock;

 gfp_t xa_flags;
 void * xa_head;
};
# 347 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *xa_load(struct xarray *, unsigned long index);
void *xa_store(struct xarray *, unsigned long index, void *entry, gfp_t);
void *xa_erase(struct xarray *, unsigned long index);
void *xa_store_range(struct xarray *, unsigned long first, unsigned long last,
   void *entry, gfp_t);
bool xa_get_mark(struct xarray *, unsigned long index, xa_mark_t);
void xa_set_mark(struct xarray *, unsigned long index, xa_mark_t);
void xa_clear_mark(struct xarray *, unsigned long index, xa_mark_t);
void *xa_find(struct xarray *xa, unsigned long *index,
  unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
void *xa_find_after(struct xarray *xa, unsigned long *index,
  unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
unsigned int xa_extract(struct xarray *, void **dst, unsigned long start,
  unsigned long max, unsigned int n, xa_mark_t);
void xa_destroy(struct xarray *);
# 374 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_init_flags(struct xarray *xa, gfp_t flags)
{
 do { spinlock_check(&xa->xa_lock); *(&xa->xa_lock) = (spinlock_t) { { .rlock = { .raw_lock = { 0 }, } } }; } while (0);
 xa->xa_flags = flags;
 xa->xa_head = ((void *)0);
}
# 389 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_init(struct xarray *xa)
{
 xa_init_flags(xa, 0);
}
# 401 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_empty(const struct xarray *xa)
{
 return xa->xa_head == ((void *)0);
}
# 414 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_marked(const struct xarray *xa, xa_mark_t mark)
{
 return xa->xa_flags & (( gfp_t)((1U << (23 + 0)) << ( unsigned)(mark)));
}
# 554 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *__xa_erase(struct xarray *, unsigned long index);
void *__xa_store(struct xarray *, unsigned long index, void *entry, gfp_t);
void *__xa_cmpxchg(struct xarray *, unsigned long index, void *old,
  void *entry, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_insert(struct xarray *, unsigned long index,
  void *entry, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_alloc(struct xarray *, u32 *id, void *entry,
  struct xa_limit, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_alloc_cyclic(struct xarray *, u32 *id, void *entry,
  struct xa_limit, u32 *next, gfp_t);
void __xa_set_mark(struct xarray *, unsigned long index, xa_mark_t);
void __xa_clear_mark(struct xarray *, unsigned long index, xa_mark_t);
# 581 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_store_bh(struct xarray *xa, unsigned long index,
  void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_bh(&(xa)->xa_lock);
 curr = __xa_store(xa, index, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return curr;
}
# 607 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_store_irq(struct xarray *xa, unsigned long index,
  void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_irq(&(xa)->xa_lock);
 curr = __xa_store(xa, index, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return curr;
}
# 632 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_erase_bh(struct xarray *xa, unsigned long index)
{
 void *entry;

 spin_lock_bh(&(xa)->xa_lock);
 entry = __xa_erase(xa, index);
 spin_unlock_bh(&(xa)->xa_lock);

 return entry;
}
# 656 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_erase_irq(struct xarray *xa, unsigned long index)
{
 void *entry;

 spin_lock_irq(&(xa)->xa_lock);
 entry = __xa_erase(xa, index);
 spin_unlock_irq(&(xa)->xa_lock);

 return entry;
}
# 682 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock(&(xa)->xa_lock);

 return curr;
}
# 709 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg_bh(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_bh(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return curr;
}
# 736 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg_irq(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_irq(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return curr;
}
# 765 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 794 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert_bh(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 823 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert_irq(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 852 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) int xa_alloc(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 881 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_alloc_bh(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 910 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_alloc_irq(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 943 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 976 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic_bh(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 1009 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic_irq(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 1039 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1057 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve_bh(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg_bh(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1075 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve_irq(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg_irq(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1090 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_release(struct xarray *xa, unsigned long index)
{
 xa_cmpxchg(xa, index, xa_mk_internal(257), ((void *)0), 0);
}
# 1122 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_node {
 unsigned char shift;
 unsigned char offset;
 unsigned char count;
 unsigned char nr_values;
 struct xa_node *parent;
 struct xarray *array;
 union {
  struct list_head private_list;
  struct callback_head callback_head;
 };
 void *slots[(1UL << (0 ? 4 : 6))];
 union {
  unsigned long tags[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
  unsigned long marks[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
 };
};

void xa_dump(const struct xarray *);
void xa_dump_node(const struct xa_node *);
# 1162 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_head(const struct xarray *xa)
{
 return ({ typeof(*(xa->xa_head)) *________p1 = (typeof(*(xa->xa_head)) *)({ do { extern void __compiletime_assert_128(void) ; if (!((sizeof((xa->xa_head)) == sizeof(char) || sizeof((xa->xa_head)) == sizeof(short) || sizeof((xa->xa_head)) == sizeof(int) || sizeof((xa->xa_head)) == sizeof(long)) || sizeof((xa->xa_head)) == sizeof(long long))) __compiletime_assert_128(); } while (0); ({ typeof( _Generic(((xa->xa_head)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((xa->xa_head)))) __x = (*(const volatile typeof( _Generic(((xa->xa_head)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((xa->xa_head)))) *)&((xa->xa_head))); do { } while (0); (typeof((xa->xa_head)))__x; }); }); do { } while (0); ; ((typeof(*(xa->xa_head)) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_head_locked(const struct xarray *xa)
{
 return ({ do { } while (0); ; ((typeof(*(xa->xa_head)) *)((xa->xa_head))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_entry(const struct xarray *xa,
    const struct xa_node *node, unsigned int offset)
{
 do { } while (0);
 return ({ typeof(*(node->slots[offset])) *________p1 = (typeof(*(node->slots[offset])) *)({ do { extern void __compiletime_assert_129(void) ; if (!((sizeof((node->slots[offset])) == sizeof(char) || sizeof((node->slots[offset])) == sizeof(short) || sizeof((node->slots[offset])) == sizeof(int) || sizeof((node->slots[offset])) == sizeof(long)) || sizeof((node->slots[offset])) == sizeof(long long))) __compiletime_assert_129(); } while (0); ({ typeof( _Generic(((node->slots[offset])), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((node->slots[offset])))) __x = (*(const volatile typeof( _Generic(((node->slots[offset])), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((node->slots[offset])))) *)&((node->slots[offset]))); do { } while (0); (typeof((node->slots[offset])))__x; }); }); do { } while (0); ; ((typeof(*(node->slots[offset])) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_entry_locked(const struct xarray *xa,
    const struct xa_node *node, unsigned int offset)
{
 do { } while (0);
 return ({ do { } while (0); ; ((typeof(*(node->slots[offset])) *)((node->slots[offset]))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_parent(const struct xarray *xa,
     const struct xa_node *node)
{
 return ({ typeof(*(node->parent)) *________p1 = (typeof(*(node->parent)) *)({ do { extern void __compiletime_assert_130(void) ; if (!((sizeof((node->parent)) == sizeof(char) || sizeof((node->parent)) == sizeof(short) || sizeof((node->parent)) == sizeof(int) || sizeof((node->parent)) == sizeof(long)) || sizeof((node->parent)) == sizeof(long long))) __compiletime_assert_130(); } while (0); ({ typeof( _Generic(((node->parent)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((node->parent)))) __x = (*(const volatile typeof( _Generic(((node->parent)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((node->parent)))) *)&((node->parent))); do { } while (0); (typeof((node->parent)))__x; }); }); do { } while (0); ; ((typeof(*(node->parent)) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_parent_locked(const struct xarray *xa,
     const struct xa_node *node)
{
 return ({ do { } while (0); ; ((typeof(*(node->parent)) *)((node->parent))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_node(const struct xa_node *node)
{
 return (void *)((unsigned long)node | 2);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_to_node(const void *entry)
{
 return (struct xa_node *)((unsigned long)entry - 2);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_node(const void *entry)
{
 return xa_is_internal(entry) && (unsigned long)entry > 4096;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_sibling(unsigned int offset)
{
 return xa_mk_internal(offset);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_sibling(const void *entry)
{
 return xa_to_internal(entry);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_sibling(const void *entry)
{
 return 1 && xa_is_internal(entry) &&
  (entry < xa_mk_sibling((1UL << (0 ? 4 : 6)) - 1));
}
# 1259 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_retry(const void *entry)
{
 return __builtin_expect(!!(entry == xa_mk_internal(256)), 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_advanced(const void *entry)
{
 return xa_is_internal(entry) && (entry <= xa_mk_internal(256));
}
# 1287 "/home/nathan/src/linux-next/include/linux/xarray.h"
typedef void (*xa_update_node_t)(struct xa_node *node);
# 1306 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_state {
 struct xarray *xa;
 unsigned long xa_index;
 unsigned char xa_shift;
 unsigned char xa_sibs;
 unsigned char xa_offset;
 unsigned char xa_pad;
 struct xa_node *xa_node;
 struct xa_node *xa_alloc;
 xa_update_node_t xa_update;
};
# 1385 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xas_error(const struct xa_state *xas)
{
 return xa_err(xas->xa_node);
}
# 1399 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_err(struct xa_state *xas, long err)
{
 xas->xa_node = ((struct xa_node *)(((unsigned long)err << 2) | 2UL));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_invalid(const struct xa_state *xas)
{
 return (unsigned long)xas->xa_node & 3;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_valid(const struct xa_state *xas)
{
 return !xas_invalid(xas);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_is_node(const struct xa_state *xas)
{
 return xas_valid(xas) && xas->xa_node;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_not_node(struct xa_node *node)
{
 return ((unsigned long)node & 3) || !node;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_frozen(struct xa_node *node)
{
 return (unsigned long)node & 2;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_top(struct xa_node *node)
{
 return node <= ((struct xa_node *)3UL);
}
# 1465 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_reset(struct xa_state *xas)
{
 xas->xa_node = ((struct xa_node *)3UL);
}
# 1482 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_retry(struct xa_state *xas, const void *entry)
{
 if (xa_is_zero(entry))
  return true;
 if (!xa_is_retry(entry))
  return false;
 xas_reset(xas);
 return true;
}

void *xas_load(struct xa_state *);
void *xas_store(struct xa_state *, void *entry);
void *__xas_store(struct xa_state *, void *entry);
void *xas_find(struct xa_state *, unsigned long max);
void *xas_find_conflict(struct xa_state *);

bool xas_get_mark(const struct xa_state *, xa_mark_t);
void xas_set_mark(const struct xa_state *, xa_mark_t);
void xas_clear_mark(const struct xa_state *, xa_mark_t);
void *xas_find_marked(struct xa_state *, unsigned long max, xa_mark_t);
void xas_init_marks(const struct xa_state *);

bool xas_nomem(struct xa_state *, gfp_t);
void xas_pause(struct xa_state *);

void xas_create_range(struct xa_state *);
# 1523 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_reload(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (node)
  return xa_entry(xas->xa, node, xas->xa_offset);
 return xa_head(xas->xa);
}
# 1541 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set(struct xa_state *xas, unsigned long index)
{
 xas->xa_index = index;
 xas->xa_node = ((struct xa_node *)3UL);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_order(struct xa_state *xas, unsigned long index,
     unsigned int order)
{

 xas->xa_index = order < 64 ? (index >> order) << order : 0;
 xas->xa_shift = order - (order % (0 ? 4 : 6));
 xas->xa_sibs = (1 << (order % (0 ? 4 : 6))) - 1;
 xas->xa_node = ((struct xa_node *)3UL);




}
# 1575 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_update(struct xa_state *xas, xa_update_node_t update)
{
 xas->xa_update = update;
}
# 1591 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next_entry(struct xa_state *xas, unsigned long max)
{
 struct xa_node *node = xas->xa_node;
 void *entry;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset != (xas->xa_index & ((1UL << (0 ? 4 : 6)) - 1))), 0))

  return xas_find(xas, max);

 do {
  if (__builtin_expect(!!(xas->xa_index >= max), 0))
   return xas_find(xas, max);
  if (__builtin_expect(!!(xas->xa_offset == ((1UL << (0 ? 4 : 6)) - 1)), 0))
   return xas_find(xas, max);
  entry = xa_entry(xas->xa, node, xas->xa_offset + 1);
  if (__builtin_expect(!!(xa_is_internal(entry)), 0))
   return xas_find(xas, max);
  xas->xa_offset++;
  xas->xa_index++;
 } while (!entry);

 return entry;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int xas_find_chunk(struct xa_state *xas, bool advance,
  xa_mark_t mark)
{
 unsigned long *addr = xas->xa_node->marks[( unsigned)mark];
 unsigned int offset = xas->xa_offset;

 if (advance)
  offset++;
 if ((1UL << (0 ? 4 : 6)) == 64) {
  if (offset < (1UL << (0 ? 4 : 6))) {
   unsigned long data = *addr & (~0UL << offset);
   if (data)
    return __ffs(data);
  }
  return (1UL << (0 ? 4 : 6));
 }

 return find_next_bit(addr, (1UL << (0 ? 4 : 6)), offset);
}
# 1648 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next_marked(struct xa_state *xas, unsigned long max,
        xa_mark_t mark)
{
 struct xa_node *node = xas->xa_node;
 void *entry;
 unsigned int offset;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift), 0))
  return xas_find_marked(xas, max, mark);
 offset = xas_find_chunk(xas, true, mark);
 xas->xa_offset = offset;
 xas->xa_index = (xas->xa_index & ~((1UL << (0 ? 4 : 6)) - 1)) + offset;
 if (xas->xa_index > max)
  return ((void *)0);
 if (offset == (1UL << (0 ? 4 : 6)))
  return xas_find_marked(xas, max, mark);
 entry = xa_entry(xas->xa, node, offset);
 if (!entry)
  return xas_find_marked(xas, max, mark);
 if (!xa_is_retry(entry))
  return entry;
 xas_reset(xas);
 return xas_find_marked(xas, max, mark);
}





enum {
 XA_CHECK_SCHED = 4096,
};
# 1732 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *__xas_next(struct xa_state *);
void *__xas_prev(struct xa_state *);
# 1751 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_prev(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset == 0), 0))

  return __xas_prev(xas);

 xas->xa_index--;
 xas->xa_offset--;
 return xa_entry(xas->xa, node, xas->xa_offset);
}
# 1780 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset == ((1UL << (0 ? 4 : 6)) - 1)), 0))

  return __xas_next(xas);

 xas->xa_index++;
 xas->xa_offset++;
 return xa_entry(xas->xa, node, xas->xa_offset);
}
# 19 "/home/nathan/src/linux-next/include/linux/radix-tree.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/local_lock.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/local_lock_internal.h" 1








typedef struct {




} local_lock_t;
# 52 "/home/nathan/src/linux-next/include/linux/local_lock_internal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_lock_acquire(local_lock_t *l) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_lock_release(local_lock_t *l) { }
# 6 "/home/nathan/src/linux-next/include/linux/local_lock.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/radix-tree.h" 2





struct radix_tree_preload {
 local_lock_t lock;
 unsigned nr;

 struct xa_node *nodes;
};
extern __attribute__((section(".data..percpu" ""))) __typeof__(struct radix_tree_preload) radix_tree_preloads;
# 52 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_tree_is_internal_node(void *ptr)
{
 return ((unsigned long)ptr & 3UL) ==
    2UL;
}
# 83 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_tree_empty(const struct xarray *root)
{
 return root->xa_head == ((void *)0);
}
# 103 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
struct radix_tree_iter {
 unsigned long index;
 unsigned long next_index;
 unsigned long tags;
 struct xa_node *node;
};
# 174 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *radix_tree_deref_slot(void **slot)
{
 return ({ typeof(*(*slot)) *________p1 = (typeof(*(*slot)) *)({ do { extern void __compiletime_assert_131(void) ; if (!((sizeof((*slot)) == sizeof(char) || sizeof((*slot)) == sizeof(short) || sizeof((*slot)) == sizeof(int) || sizeof((*slot)) == sizeof(long)) || sizeof((*slot)) == sizeof(long long))) __compiletime_assert_131(); } while (0); ({ typeof( _Generic(((*slot)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((*slot)))) __x = (*(const volatile typeof( _Generic(((*slot)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((*slot)))) *)&((*slot))); do { } while (0); (typeof((*slot)))__x; }); }); do { } while (0); ; ((typeof(*(*slot)) *)(________p1)); });
}
# 188 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *radix_tree_deref_slot_protected(void **slot,
       spinlock_t *treelock)
{
 return ({ do { } while (0); ; ((typeof(*(*slot)) *)((*slot))); });
}
# 201 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix_tree_deref_retry(void *arg)
{
 return __builtin_expect(!!(radix_tree_is_internal_node(arg)), 0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix_tree_exception(void *arg)
{
 return __builtin_expect(!!((unsigned long)arg & 3UL), 0);
}

int radix_tree_insert(struct xarray *, unsigned long index,
   void *);
void *__radix_tree_lookup(const struct xarray *, unsigned long index,
     struct xa_node **nodep, void ***slotp);
void *radix_tree_lookup(const struct xarray *, unsigned long);
void **radix_tree_lookup_slot(const struct xarray *,
     unsigned long index);
void __radix_tree_replace(struct xarray *, struct xa_node *,
     void **slot, void *entry);
void radix_tree_iter_replace(struct xarray *,
  const struct radix_tree_iter *, void **slot, void *entry);
void radix_tree_replace_slot(struct xarray *,
        void **slot, void *entry);
void radix_tree_iter_delete(struct xarray *,
   struct radix_tree_iter *iter, void **slot);
void *radix_tree_delete_item(struct xarray *, unsigned long, void *);
void *radix_tree_delete(struct xarray *, unsigned long);
unsigned int radix_tree_gang_lookup(const struct xarray *,
   void **results, unsigned long first_index,
   unsigned int max_items);
int radix_tree_preload(gfp_t gfp_mask);
int radix_tree_maybe_preload(gfp_t gfp_mask);
void radix_tree_init(void);
void *radix_tree_tag_set(struct xarray *,
   unsigned long index, unsigned int tag);
void *radix_tree_tag_clear(struct xarray *,
   unsigned long index, unsigned int tag);
int radix_tree_tag_get(const struct xarray *,
   unsigned long index, unsigned int tag);
void radix_tree_iter_tag_clear(struct xarray *,
  const struct radix_tree_iter *iter, unsigned int tag);
unsigned int radix_tree_gang_lookup_tag(const struct xarray *,
  void **results, unsigned long first_index,
  unsigned int max_items, unsigned int tag);
unsigned int radix_tree_gang_lookup_tag_slot(const struct xarray *,
  void ***results, unsigned long first_index,
  unsigned int max_items, unsigned int tag);
int radix_tree_tagged(const struct xarray *, unsigned int tag);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void radix_tree_preload_end(void)
{
 do { local_lock_release(({ do { const void *__vpp_verify = (typeof((&radix_tree_preloads.lock) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&radix_tree_preloads.lock)) *)(&radix_tree_preloads.lock)); (typeof((typeof(*(&radix_tree_preloads.lock)) *)(&radix_tree_preloads.lock))) (__ptr + ((local_paca->data_offset))); }); })); __asm__ __volatile__("" : : : "memory"); } while (0);
}

void **idr_get_free(struct xarray *root,
         struct radix_tree_iter *iter, gfp_t gfp,
         unsigned long max);

enum {
 RADIX_TREE_ITER_TAG_MASK = 0x0f,
 RADIX_TREE_ITER_TAGGED = 0x10,
 RADIX_TREE_ITER_CONTIG = 0x20,
};
# 277 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void **
radix_tree_iter_init(struct radix_tree_iter *iter, unsigned long start)
{
# 288 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
 iter->index = 0;
 iter->next_index = start;
 return ((void *)0);
}
# 306 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
void **radix_tree_next_chunk(const struct xarray *,
        struct radix_tree_iter *iter, unsigned flags);
# 319 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void **
radix_tree_iter_lookup(const struct xarray *root,
   struct radix_tree_iter *iter, unsigned long index)
{
 radix_tree_iter_init(iter, index);
 return radix_tree_next_chunk(root, iter, RADIX_TREE_ITER_CONTIG);
}
# 336 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
void **radix_tree_iter_retry(struct radix_tree_iter *iter)
{
 iter->next_index = iter->index;
 iter->tags = 0;
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
__radix_tree_iter_add(struct radix_tree_iter *iter, unsigned long slots)
{
 return iter->index + slots;
}
# 360 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
void **__attribute__((__warn_unused_result__)) radix_tree_iter_resume(void **slot,
     struct radix_tree_iter *iter);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
radix_tree_chunk_size(struct radix_tree_iter *iter)
{
 return iter->next_index - iter->index;
}
# 394 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void **radix_tree_next_slot(void **slot,
    struct radix_tree_iter *iter, unsigned flags)
{
 if (flags & RADIX_TREE_ITER_TAGGED) {
  iter->tags >>= 1;
  if (__builtin_expect(!!(!iter->tags), 0))
   return ((void *)0);
  if (__builtin_expect(!!(iter->tags & 1ul), 1)) {
   iter->index = __radix_tree_iter_add(iter, 1);
   slot++;
   goto found;
  }
  if (!(flags & RADIX_TREE_ITER_CONTIG)) {
   unsigned offset = __ffs(iter->tags);

   iter->tags >>= offset++;
   iter->index = __radix_tree_iter_add(iter, offset);
   slot += offset;
   goto found;
  }
 } else {
  long count = radix_tree_chunk_size(iter);

  while (--count > 0) {
   slot++;
   iter->index = __radix_tree_iter_add(iter, 1);

   if (__builtin_expect(!!(*slot), 1))
    goto found;
   if (flags & RADIX_TREE_ITER_CONTIG) {

    iter->next_index = 0;
    break;
   }
  }
 }
 return ((void *)0);

 found:
 return slot;
}
# 16 "/home/nathan/src/linux-next/include/linux/fs.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/pid.h" 1








enum pid_type
{
 PIDTYPE_PID,
 PIDTYPE_TGID,
 PIDTYPE_PGID,
 PIDTYPE_SID,
 PIDTYPE_MAX,
};
# 54 "/home/nathan/src/linux-next/include/linux/pid.h"
struct upid {
 int nr;
 struct pid_namespace *ns;
};

struct pid
{
 refcount_t count;
 unsigned int level;
 spinlock_t lock;

 struct hlist_head tasks[PIDTYPE_MAX];
 struct hlist_head inodes;

 wait_queue_head_t wait_pidfd;
 struct callback_head rcu;
 struct upid numbers[1];
};

extern struct pid init_struct_pid;

extern const struct file_operations pidfd_fops;

struct file;

extern struct pid *pidfd_pid(const struct file *file);
struct pid *pidfd_get_pid(unsigned int fd);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *get_pid(struct pid *pid)
{
 if (pid)
  refcount_inc(&pid->count);
 return pid;
}

extern void put_pid(struct pid *pid);
extern struct task_struct *pid_task(struct pid *pid, enum pid_type);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pid_has_task(struct pid *pid, enum pid_type type)
{
 return !hlist_empty(&pid->tasks[type]);
}
extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);

extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);




extern void attach_pid(struct task_struct *task, enum pid_type);
extern void detach_pid(struct task_struct *task, enum pid_type);
extern void change_pid(struct task_struct *task, enum pid_type,
   struct pid *pid);
extern void exchange_tids(struct task_struct *task, struct task_struct *old);
extern void transfer_pid(struct task_struct *old, struct task_struct *new,
    enum pid_type);

struct pid_namespace;
extern struct pid_namespace init_pid_ns;

extern int pid_max;
extern int pid_max_min, pid_max_max;
# 125 "/home/nathan/src/linux-next/include/linux/pid.h"
extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
extern struct pid *find_vpid(int nr);




extern struct pid *find_get_pid(int nr);
extern struct pid *find_ge_pid(int nr, struct pid_namespace *);

extern struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,
        size_t set_tid_size);
extern void free_pid(struct pid *pid);
extern void disable_pid_allocation(struct pid_namespace *ns);
# 149 "/home/nathan/src/linux-next/include/linux/pid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid_namespace *ns_of_pid(struct pid *pid)
{
 struct pid_namespace *ns = ((void *)0);
 if (pid)
  ns = pid->numbers[pid->level].ns;
 return ns;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_child_reaper(struct pid *pid)
{
 return pid->numbers[pid->level].nr == 1;
}
# 179 "/home/nathan/src/linux-next/include/linux/pid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t pid_nr(struct pid *pid)
{
 pid_t nr = 0;
 if (pid)
  nr = pid->numbers[0].nr;
 return nr;
}

pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
pid_t pid_vnr(struct pid *pid);
# 20 "/home/nathan/src/linux-next/include/linux/fs.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/capability.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/capability.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/capability.h" 1
# 39 "/home/nathan/src/linux-next/include/uapi/linux/capability.h"
typedef struct __user_cap_header_struct {
 __u32 version;
 int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
        __u32 effective;
        __u32 permitted;
        __u32 inheritable;
} *cap_user_data_t;
# 72 "/home/nathan/src/linux-next/include/uapi/linux/capability.h"
struct vfs_cap_data {
 __le32 magic_etc;
 struct {
  __le32 permitted;
  __le32 inheritable;
 } data[2];
};




struct vfs_ns_cap_data {
 __le32 magic_etc;
 struct {
  __le32 permitted;
  __le32 inheritable;
 } data[2];
 __le32 rootid;
};
# 17 "/home/nathan/src/linux-next/include/linux/capability.h" 2





extern int file_caps_enabled;

typedef struct kernel_cap_struct {
 __u32 cap[2];
} kernel_cap_t;


struct cpu_vfs_cap_data {
 __u32 magic_etc;
 kernel_cap_t permitted;
 kernel_cap_t inheritable;
 kuid_t rootid;
};





struct file;
struct inode;
struct dentry;
struct task_struct;
struct user_namespace;

extern const kernel_cap_t __cap_empty_set;
extern const kernel_cap_t __cap_init_eff_set;
# 118 "/home/nathan/src/linux-next/include/linux/capability.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_combine(const kernel_cap_t a,
           const kernel_cap_t b)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] | b.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_intersect(const kernel_cap_t a,
      const kernel_cap_t b)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] & b.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop(const kernel_cap_t a,
        const kernel_cap_t drop)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] &~ drop.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_invert(const kernel_cap_t c)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = ~ c.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_isclear(const kernel_cap_t a)
{
 unsigned __capi;
 for (__capi = 0; __capi < 2; ++__capi) {
  if (a.cap[__capi] != 0)
   return false;
 }
 return true;
}
# 166 "/home/nathan/src/linux-next/include/linux/capability.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_issubset(const kernel_cap_t a, const kernel_cap_t set)
{
 kernel_cap_t dest;
 dest = cap_drop(a, set);
 return cap_isclear(dest);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop_fs_set(const kernel_cap_t a)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
 return cap_drop(a, __cap_fs_set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_raise_fs_set(const kernel_cap_t a,
         const kernel_cap_t permitted)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
 return cap_combine(a,
      cap_intersect(permitted, __cap_fs_set));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop_nfsd_set(const kernel_cap_t a)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
 return cap_drop(a, __cap_fs_set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_raise_nfsd_set(const kernel_cap_t a,
           const kernel_cap_t permitted)
{
 const kernel_cap_t __cap_nfsd_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
 return cap_combine(a,
      cap_intersect(permitted, __cap_nfsd_set));
}


extern bool has_capability(struct task_struct *t, int cap);
extern bool has_ns_capability(struct task_struct *t,
         struct user_namespace *ns, int cap);
extern bool has_capability_noaudit(struct task_struct *t, int cap);
extern bool has_ns_capability_noaudit(struct task_struct *t,
          struct user_namespace *ns, int cap);
extern bool capable(int cap);
extern bool ns_capable(struct user_namespace *ns, int cap);
extern bool ns_capable_noaudit(struct user_namespace *ns, int cap);
extern bool ns_capable_setid(struct user_namespace *ns, int cap);
# 250 "/home/nathan/src/linux-next/include/linux/capability.h"
extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);
extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
extern bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool perfmon_capable(void)
{
 return capable(38) || capable(21);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_capable(void)
{
 return capable(39) || capable(21);
}


extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);

extern int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size);
# 25 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/semaphore.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/semaphore.h"
struct semaphore {
 raw_spinlock_t lock;
 unsigned int count;
 struct list_head wait_list;
};
# 31 "/home/nathan/src/linux-next/include/linux/semaphore.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sema_init(struct semaphore *sem, int val)
{
 static struct lock_class_key __key;
 *sem = (struct semaphore) { .lock = (raw_spinlock_t) { .raw_lock = { 0 }, }, .count = val, .wait_list = { &((*sem).wait_list), &((*sem).wait_list) }, };
 do { (void)("semaphore->lock"); (void)(&__key); } while (0);
}

extern void down(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_interruptible(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_killable(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_trylock(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_timeout(struct semaphore *sem, long jiffies);
extern void up(struct semaphore *sem);
# 26 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/fcntl.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h" 1
# 156 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h"
struct f_owner_ex {
 int type;
 __kernel_pid_t pid;
};
# 196 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h"
struct flock {
 short l_type;
 short l_whence;
 __kernel_off_t l_start;
 __kernel_off_t l_len;
 __kernel_pid_t l_pid;

};







struct flock64 {
 short l_type;
 short l_whence;
 __kernel_loff_t l_start;
 __kernel_loff_t l_len;
 __kernel_pid_t l_pid;

};
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/openat2.h" 1
# 19 "/home/nathan/src/linux-next/include/uapi/linux/openat2.h"
struct open_how {
 __u64 flags;
 __u64 mode;
 __u64 resolve;
};
# 7 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 2
# 7 "/home/nathan/src/linux-next/include/linux/fcntl.h" 2
# 27 "/home/nathan/src/linux-next/include/linux/fs.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/migrate_mode.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/migrate_mode.h"
enum migrate_mode {
 MIGRATE_ASYNC,
 MIGRATE_SYNC_LIGHT,
 MIGRATE_SYNC,
 MIGRATE_SYNC_NO_COPY,
};
# 31 "/home/nathan/src/linux-next/include/linux/fs.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/rcuwait.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/signal.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/signal_types.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/signal_types.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/signal.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h" 1
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
typedef unsigned long old_sigset_t;

typedef struct {
 unsigned long sig[(64 / 64)];
} sigset_t;
# 92 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/signal-defs.h" 1
# 18 "/home/nathan/src/linux-next/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
# 93 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h" 2
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
typedef struct sigaltstack {
 void *ss_sp;
 int ss_flags;
 size_t ss_size;
} stack_t;
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/signal.h" 2


struct pt_regs;
void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags);
# 6 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 2
# 1 "./arch/powerpc/include/generated/uapi/asm/siginfo.h" 1
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h" 1







typedef union sigval {
 int sival_int;
 void *sival_ptr;
} sigval_t;
# 32 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
union __sifields {

 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
 } _kill;


 struct {
  __kernel_timer_t _tid;
  int _overrun;
  sigval_t _sigval;
  int _sys_private;
 } _timer;


 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  sigval_t _sigval;
 } _rt;


 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  int _status;
  __kernel_clock_t _utime;
  __kernel_clock_t _stime;
 } _sigchld;


 struct {
  void *_addr;
# 77 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
  union {




   short _addr_lsb;

   struct {
    char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
    void *_lower;
    void *_upper;
   } _addr_bnd;

   struct {
    char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
    __u32 _pkey;
   } _addr_pkey;
  };
 } _sigfault;


 struct {
  long _band;
  int _fd;
 } _sigpoll;


 struct {
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
 } _sigsys;
};
# 129 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo {
 union {
  struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
  int _si_pad[128/sizeof(int)];
 };
} siginfo_t;
# 320 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
typedef struct sigevent {
 sigval_t sigev_value;
 int sigev_signo;
 int sigev_notify;
 union {
  int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
   int _tid;

  struct {
   void (*_function)(sigval_t);
   void *_attribute;
  } _sigev_thread;
 } _sigev_un;
} sigevent_t;
# 2 "./arch/powerpc/include/generated/uapi/asm/siginfo.h" 2
# 7 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 2
# 11 "/home/nathan/src/linux-next/include/linux/signal_types.h" 2

typedef struct kernel_siginfo {
 struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
} kernel_siginfo_t;





struct sigqueue {
 struct list_head list;
 int flags;
 kernel_siginfo_t info;
 struct user_struct *user;
};




struct sigpending {
 struct list_head list;
 sigset_t signal;
};

struct sigaction {

 __sighandler_t sa_handler;
 unsigned long sa_flags;





 __sigrestore_t sa_restorer;

 sigset_t sa_mask;
};

struct k_sigaction {
 struct sigaction sa;



};
# 65 "/home/nathan/src/linux-next/include/linux/signal_types.h"
struct ksignal {
 struct k_sigaction ka;
 kernel_siginfo_t info;
 int sig;
};
# 7 "/home/nathan/src/linux-next/include/linux/signal.h" 2


struct task_struct;


extern int print_fatal_signals;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_siginfo(kernel_siginfo_t *to,
    const kernel_siginfo_t *from)
{
 memcpy(to, from, sizeof(*to));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_siginfo(kernel_siginfo_t *info)
{
 memset(info, 0, sizeof(*info));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_siginfo_to_external(siginfo_t *to,
         const kernel_siginfo_t *from)
{
 memcpy(to, from, sizeof(*from));
 memset(((char *)to) + sizeof(struct kernel_siginfo), 0,
  (sizeof(struct siginfo) - sizeof(struct kernel_siginfo)));
}

int copy_siginfo_to_user(siginfo_t *to, const kernel_siginfo_t *from);
int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t *from);

enum siginfo_layout {
 SIL_KILL,
 SIL_TIMER,
 SIL_POLL,
 SIL_FAULT,
 SIL_FAULT_MCEERR,
 SIL_FAULT_BNDERR,
 SIL_FAULT_PKUERR,
 SIL_CHLD,
 SIL_RT,
 SIL_SYS,
};

enum siginfo_layout siginfo_layout(unsigned sig, int si_code);
# 62 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigaddset(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  set->sig[0] |= 1UL << sig;
 else
  set->sig[sig / 64] |= 1UL << (sig % 64);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigdelset(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  set->sig[0] &= ~(1UL << sig);
 else
  set->sig[sig / 64] &= ~(1UL << (sig % 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigismember(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  return 1 & (set->sig[0] >> sig);
 else
  return 1 & (set->sig[sig / 64] >> (sig % 64));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigisemptyset(sigset_t *set)
{
 switch ((64 / 64)) {
 case 4:
  return (set->sig[3] | set->sig[2] |
   set->sig[1] | set->sig[0]) == 0;
 case 2:
  return (set->sig[1] | set->sig[0]) == 0;
 case 1:
  return set->sig[0] == 0;
 default:
  do { extern void __compiletime_assert_132(void) ; if (!(!(1))) __compiletime_assert_132(); } while (0);
  return 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigequalsets(const sigset_t *set1, const sigset_t *set2)
{
 switch ((64 / 64)) {
 case 4:
  return (set1->sig[3] == set2->sig[3]) &&
   (set1->sig[2] == set2->sig[2]) &&
   (set1->sig[1] == set2->sig[1]) &&
   (set1->sig[0] == set2->sig[0]);
 case 2:
  return (set1->sig[1] == set2->sig[1]) &&
   (set1->sig[0] == set2->sig[0]);
 case 1:
  return set1->sig[0] == set2->sig[0];
 }
 return 0;
}
# 155 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) | (b3)); r->sig[2] = ((a2) | (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) | (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) | (b0)); break; default: do { extern void __compiletime_assert_133(void) ; if (!(!(1))) __compiletime_assert_133(); } while (0); } }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & (b3)); r->sig[2] = ((a2) & (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & (b0)); break; default: do { extern void __compiletime_assert_134(void) ; if (!(!(1))) __compiletime_assert_134(); } while (0); } }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigandnsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & ~(b3)); r->sig[2] = ((a2) & ~(b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & ~(b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & ~(b0)); break; default: do { extern void __compiletime_assert_135(void) ; if (!(!(1))) __compiletime_assert_135(); } while (0); } }
# 185 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signotset(sigset_t *set) { switch ((64 / 64)) { case 4: set->sig[3] = (~(set->sig[3])); set->sig[2] = (~(set->sig[2])); case 2: set->sig[1] = (~(set->sig[1])); case 1: set->sig[0] = (~(set->sig[0])); break; default: do { extern void __compiletime_assert_136(void) ; if (!(!(1))) __compiletime_assert_136(); } while (0); } }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigemptyset(sigset_t *set)
{
 switch ((64 / 64)) {
 default:
  memset(set, 0, sizeof(sigset_t));
  break;
 case 2: set->sig[1] = 0;

 case 1: set->sig[0] = 0;
  break;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigfillset(sigset_t *set)
{
 switch ((64 / 64)) {
 default:
  memset(set, -1, sizeof(sigset_t));
  break;
 case 2: set->sig[1] = -1;

 case 1: set->sig[0] = -1;
  break;
 }
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigaddsetmask(sigset_t *set, unsigned long mask)
{
 set->sig[0] |= mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigdelsetmask(sigset_t *set, unsigned long mask)
{
 set->sig[0] &= ~mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigtestsetmask(sigset_t *set, unsigned long mask)
{
 return (set->sig[0] & mask) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void siginitset(sigset_t *set, unsigned long mask)
{
 set->sig[0] = mask;
 switch ((64 / 64)) {
 default:
  memset(&set->sig[1], 0, sizeof(long)*((64 / 64)-1));
  break;
 case 2: set->sig[1] = 0;
 case 1: ;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void siginitsetinv(sigset_t *set, unsigned long mask)
{
 set->sig[0] = ~mask;
 switch ((64 / 64)) {
 default:
  memset(&set->sig[1], -1, sizeof(long)*((64 / 64)-1));
  break;
 case 2: set->sig[1] = -1;
 case 1: ;
 }
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_sigpending(struct sigpending *sig)
{
 sigemptyset(&sig->signal);
 INIT_LIST_HEAD(&sig->list);
}

extern void flush_sigqueue(struct sigpending *queue);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_signal(unsigned long sig)
{
 return sig <= 64 ? 1 : 0;
}

struct timespec;
struct pt_regs;
enum pid_type;

extern int next_signal(struct sigpending *pending, sigset_t *mask);
extern int do_send_sig_info(int sig, struct kernel_siginfo *info,
    struct task_struct *p, enum pid_type type);
extern int group_send_sig_info(int sig, struct kernel_siginfo *info,
          struct task_struct *p, enum pid_type type);
extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
extern int sigprocmask(int, sigset_t *, sigset_t *);
extern void set_current_blocked(sigset_t *);
extern void __set_current_blocked(const sigset_t *);
extern int show_unhandled_signals;

extern bool get_signal(struct ksignal *ksig);
extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
extern void exit_signals(struct task_struct *tsk);
extern void kernel_sigaction(int, __sighandler_t);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_signal(int sig)
{





 kernel_sigaction(sig, (( __sighandler_t)2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_kernel_signal(int sig)
{





 kernel_sigaction(sig, (( __sighandler_t)3));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disallow_signal(int sig)
{
 kernel_sigaction(sig, (( __sighandler_t)1));
}

extern struct kmem_cache *sighand_cachep;

extern bool unhandled_signal(struct task_struct *tsk, int sig);
# 450 "/home/nathan/src/linux-next/include/linux/signal.h"
void signals_init(void);

int restore_altstack(const stack_t *);
int __save_altstack(stack_t *, unsigned long);
# 466 "/home/nathan/src/linux-next/include/linux/signal.h"
struct seq_file;
extern void render_sigset_t(struct seq_file *, const char *, sigset_t *);
# 7 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/sched.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/sched.h" 1
# 92 "/home/nathan/src/linux-next/include/uapi/linux/sched.h"
struct clone_args {
 __u64 __attribute__((aligned(8))) flags;
 __u64 __attribute__((aligned(8))) pidfd;
 __u64 __attribute__((aligned(8))) child_tid;
 __u64 __attribute__((aligned(8))) parent_tid;
 __u64 __attribute__((aligned(8))) exit_signal;
 __u64 __attribute__((aligned(8))) stack;
 __u64 __attribute__((aligned(8))) stack_size;
 __u64 __attribute__((aligned(8))) tls;
 __u64 __attribute__((aligned(8))) set_tid;
 __u64 __attribute__((aligned(8))) set_tid_size;
 __u64 __attribute__((aligned(8))) cgroup;
};
# 11 "/home/nathan/src/linux-next/include/linux/sched.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/sem.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/ipc.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhash_head {
 struct rhash_head *next;
};

struct rhlist_head {
 struct rhash_head rhead;
 struct rhlist_head *next;
};

struct bucket_table;






struct rhashtable_compare_arg {
 struct rhashtable *ht;
 const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *data, u32 len, u32 seed);
typedef u32 (*rht_obj_hashfn_t)(const void *data, u32 len, u32 seed);
typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *arg,
          const void *obj);
# 56 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable_params {
 u16 nelem_hint;
 u16 key_len;
 u16 key_offset;
 u16 head_offset;
 unsigned int max_size;
 u16 min_size;
 bool automatic_shrinking;
 rht_hashfn_t hashfn;
 rht_obj_hashfn_t obj_hashfn;
 rht_obj_cmpfn_t obj_cmpfn;
};
# 81 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable {
 struct bucket_table *tbl;
 unsigned int key_len;
 unsigned int max_elems;
 struct rhashtable_params p;
 bool rhlist;
 struct work_struct run_work;
 struct mutex mutex;
 spinlock_t lock;
 atomic_t nelems;
};





struct rhltable {
 struct rhashtable ht;
};






struct rhashtable_walker {
 struct list_head list;
 struct bucket_table *tbl;
};
# 120 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable_iter {
 struct rhashtable *ht;
 struct rhash_head *p;
 struct rhlist_head *list;
 struct rhashtable_walker walker;
 unsigned int slot;
 unsigned int skip;
 bool end_of_table;
};

int rhashtable_init(struct rhashtable *ht,
      const struct rhashtable_params *params);
int rhltable_init(struct rhltable *hlt,
    const struct rhashtable_params *params);
# 8 "/home/nathan/src/linux-next/include/linux/ipc.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h" 1
# 10 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h"
struct ipc_perm
{
 __kernel_key_t key;
 __kernel_uid_t uid;
 __kernel_gid_t gid;
 __kernel_uid_t cuid;
 __kernel_gid_t cgid;
 __kernel_mode_t mode;
 unsigned short seq;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ipcbuf.h" 1
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ipcbuf.h"
struct ipc64_perm
{
 __kernel_key_t key;
 __kernel_uid_t uid;
 __kernel_gid_t gid;
 __kernel_uid_t cuid;
 __kernel_gid_t cgid;
 __kernel_mode_t mode;
 unsigned int seq;
 unsigned int __pad1;
 unsigned long long __unused1;
 unsigned long long __unused2;
};
# 23 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h" 2
# 58 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h"
struct ipc_kludge {
 struct msgbuf *msgp;
 long msgtyp;
};
# 9 "/home/nathan/src/linux-next/include/linux/ipc.h" 2



struct kern_ipc_perm {
 spinlock_t lock;
 bool deleted;
 int id;
 key_t key;
 kuid_t uid;
 kgid_t gid;
 kuid_t cuid;
 kgid_t cgid;
 umode_t mode;
 unsigned long seq;
 void *security;

 struct rhash_head khtnode;

 struct callback_head rcu;
 refcount_t refcount;
} __attribute__((__aligned__((1 << 7)))) ;
# 6 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 2
# 25 "/home/nathan/src/linux-next/include/uapi/linux/sem.h"
struct semid_ds {
 struct ipc_perm sem_perm;
 __kernel_old_time_t sem_otime;
 __kernel_old_time_t sem_ctime;
 struct sem *sem_base;
 struct sem_queue *sem_pending;
 struct sem_queue **sem_pending_last;
 struct sem_undo *undo;
 unsigned short sem_nsems;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/sembuf.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/sembuf.h"
struct semid64_ds {
 struct ipc64_perm sem_perm;






 long sem_otime;
 long sem_ctime;

 unsigned long sem_nsems;
 unsigned long __unused3;
 unsigned long __unused4;
};
# 38 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 2


struct sembuf {
 unsigned short sem_num;
 short sem_op;
 short sem_flg;
};


union semun {
 int val;
 struct semid_ds *buf;
 unsigned short *array;
 struct seminfo *__buf;
 void *__pad;
};

struct seminfo {
 int semmap;
 int semmni;
 int semmns;
 int semmnu;
 int semmsl;
 int semopm;
 int semume;
 int semusz;
 int semvmx;
 int semaem;
};
# 6 "/home/nathan/src/linux-next/include/linux/sem.h" 2

struct task_struct;
struct sem_undo_list;



struct sysv_sem {
 struct sem_undo_list *undo_list;
};

extern int copy_semundo(unsigned long clone_flags, struct task_struct *tsk);
extern void exit_sem(struct task_struct *tsk);
# 16 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/shm.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/hugetlb_encode.h" 1
# 8 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 2
# 28 "/home/nathan/src/linux-next/include/uapi/linux/shm.h"
struct shmid_ds {
 struct ipc_perm shm_perm;
 int shm_segsz;
 __kernel_old_time_t shm_atime;
 __kernel_old_time_t shm_dtime;
 __kernel_old_time_t shm_ctime;
 __kernel_ipc_pid_t shm_cpid;
 __kernel_ipc_pid_t shm_lpid;
 unsigned short shm_nattch;
 unsigned short shm_unused;
 void *shm_unused2;
 void *shm_unused3;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h"
struct shmid64_ds {
 struct ipc64_perm shm_perm;

 long shm_atime;
 long shm_dtime;
 long shm_ctime;
# 37 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h"
 size_t shm_segsz;
 __kernel_pid_t shm_cpid;
 __kernel_pid_t shm_lpid;
 unsigned long shm_nattch;
 unsigned long __unused5;
 unsigned long __unused6;
};

struct shminfo64 {
 unsigned long shmmax;
 unsigned long shmmin;
 unsigned long shmmni;
 unsigned long shmseg;
 unsigned long shmall;
 unsigned long __unused1;
 unsigned long __unused2;
 unsigned long __unused3;
 unsigned long __unused4;
};
# 44 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 2
# 93 "/home/nathan/src/linux-next/include/uapi/linux/shm.h"
struct shminfo {
 int shmmax;
 int shmmin;
 int shmmni;
 int shmseg;
 int shmall;
};

struct shm_info {
 int used_ids;
 __kernel_ulong_t shm_tot;
 __kernel_ulong_t shm_rss;
 __kernel_ulong_t shm_swp;
 __kernel_ulong_t swap_attempts;
 __kernel_ulong_t swap_successes;
};
# 8 "/home/nathan/src/linux-next/include/linux/shm.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/shmparam.h" 1
# 9 "/home/nathan/src/linux-next/include/linux/shm.h" 2

struct file;


struct sysv_shm {
 struct list_head shm_clist;
};

long do_shmat(int shmid, char *shmaddr, int shmflg, unsigned long *addr,
       unsigned long shmlba);
bool is_file_shm_hugepages(struct file *file);
void exit_shm(struct task_struct *task);
# 17 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kcov.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h" 1
# 11 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
struct kcov_remote_arg {
 __u32 trace_mode;
 __u32 area_size;
 __u32 num_handles;
 __u64 __attribute__((aligned(8))) common_handle;
 __u64 __attribute__((aligned(8))) handles[0];
};
# 26 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
enum {
# 35 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
 KCOV_TRACE_PC = 0,

 KCOV_TRACE_CMP = 1,
};
# 56 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 kcov_remote_handle(__u64 subsys, __u64 inst)
{
 if (subsys & ~(0xffull << 56) || inst & ~(0xffffffffull))
  return 0;
 return subsys | inst;
}
# 6 "/home/nathan/src/linux-next/include/linux/kcov.h" 2

struct task_struct;
# 57 "/home/nathan/src/linux-next/include/linux/kcov.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_task_init(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_task_exit(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_prepare_switch(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_finish_switch(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start(u64 handle) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_stop(void) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 kcov_common_handle(void)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start_common(u64 id) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start_usb(u64 id) {}
# 18 "/home/nathan/src/linux-next/include/linux/sched.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/plist.h" 1
# 79 "/home/nathan/src/linux-next/include/linux/plist.h"
struct plist_head {
 struct list_head node_list;
};

struct plist_node {
 int prio;
 struct list_head prio_list;
 struct list_head node_list;
};
# 121 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
plist_head_init(struct plist_head *head)
{
 INIT_LIST_HEAD(&head->node_list);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void plist_node_init(struct plist_node *node, int prio)
{
 node->prio = prio;
 INIT_LIST_HEAD(&node->prio_list);
 INIT_LIST_HEAD(&node->node_list);
}

extern void plist_add(struct plist_node *node, struct plist_head *head);
extern void plist_del(struct plist_node *node, struct plist_head *head);

extern void plist_requeue(struct plist_node *node, struct plist_head *head);
# 210 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int plist_head_empty(const struct plist_head *head)
{
 return list_empty(&head->node_list);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int plist_node_empty(const struct plist_node *node)
{
 return list_empty(&node->node_list);
}
# 280 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct plist_node *plist_first(const struct plist_head *head)
{
 return ({ void *__mptr = (void *)(head->node_list.next); do { extern void __compiletime_assert_137(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->node_list.next)), typeof(((struct plist_node *)0)->node_list)) && !__builtin_types_compatible_p(typeof(*(head->node_list.next)), typeof(void))))) __compiletime_assert_137(); } while (0); ((struct plist_node *)(__mptr - __builtin_offsetof(struct plist_node, node_list))); });

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct plist_node *plist_last(const struct plist_head *head)
{
 return ({ void *__mptr = (void *)(head->node_list.prev); do { extern void __compiletime_assert_138(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->node_list.prev)), typeof(((struct plist_node *)0)->node_list)) && !__builtin_types_compatible_p(typeof(*(head->node_list.prev)), typeof(void))))) __compiletime_assert_138(); } while (0); ((struct plist_node *)(__mptr - __builtin_offsetof(struct plist_node, node_list))); });

}
# 20 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
# 1 "/home/nathan/src/linux-next/include/linux/hrtimer_defs.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/timerqueue.h" 1








struct timerqueue_node {
 struct rb_node node;
 ktime_t expires;
};

struct timerqueue_head {
 struct rb_root_cached rb_root;
};


extern bool timerqueue_add(struct timerqueue_head *head,
      struct timerqueue_node *node);
extern bool timerqueue_del(struct timerqueue_head *head,
      struct timerqueue_node *node);
extern struct timerqueue_node *timerqueue_iterate_next(
      struct timerqueue_node *node);
# 33 "/home/nathan/src/linux-next/include/linux/timerqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
 struct rb_node *leftmost = (&head->rb_root)->rb_leftmost;

 return ({ void *__mptr = (void *)(leftmost); do { extern void __compiletime_assert_139(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(leftmost)), typeof(((struct timerqueue_node *)0)->node)) && !__builtin_types_compatible_p(typeof(*(leftmost)), typeof(void))))) __compiletime_assert_139(); } while (0); ((struct timerqueue_node *)(__mptr - __builtin_offsetof(struct timerqueue_node, node))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void timerqueue_init(struct timerqueue_node *node)
{
 ((&node->node)->__rb_parent_color = (unsigned long)(&node->node));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timerqueue_node_queued(struct timerqueue_node *node)
{
 return !((&node->node)->__rb_parent_color == (unsigned long)(&node->node));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timerqueue_node_expires(struct timerqueue_node *node)
{
 return node->expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void timerqueue_init_head(struct timerqueue_head *head)
{
 head->rb_root = (struct rb_root_cached) { {((void *)0), }, ((void *)0) };
}
# 22 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 2

struct hrtimer_clock_base;
struct hrtimer_cpu_base;
# 38 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
enum hrtimer_mode {
 HRTIMER_MODE_ABS = 0x00,
 HRTIMER_MODE_REL = 0x01,
 HRTIMER_MODE_PINNED = 0x02,
 HRTIMER_MODE_SOFT = 0x04,
 HRTIMER_MODE_HARD = 0x08,

 HRTIMER_MODE_ABS_PINNED = HRTIMER_MODE_ABS | HRTIMER_MODE_PINNED,
 HRTIMER_MODE_REL_PINNED = HRTIMER_MODE_REL | HRTIMER_MODE_PINNED,

 HRTIMER_MODE_ABS_SOFT = HRTIMER_MODE_ABS | HRTIMER_MODE_SOFT,
 HRTIMER_MODE_REL_SOFT = HRTIMER_MODE_REL | HRTIMER_MODE_SOFT,

 HRTIMER_MODE_ABS_PINNED_SOFT = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_SOFT,
 HRTIMER_MODE_REL_PINNED_SOFT = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_SOFT,

 HRTIMER_MODE_ABS_HARD = HRTIMER_MODE_ABS | HRTIMER_MODE_HARD,
 HRTIMER_MODE_REL_HARD = HRTIMER_MODE_REL | HRTIMER_MODE_HARD,

 HRTIMER_MODE_ABS_PINNED_HARD = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_HARD,
 HRTIMER_MODE_REL_PINNED_HARD = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_HARD,
};




enum hrtimer_restart {
 HRTIMER_NORESTART,
 HRTIMER_RESTART,
};
# 117 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer {
 struct timerqueue_node node;
 ktime_t _softexpires;
 enum hrtimer_restart (*function)(struct hrtimer *);
 struct hrtimer_clock_base *base;
 u8 state;
 u8 is_rel;
 u8 is_soft;
 u8 is_hard;
};
# 135 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_sleeper {
 struct hrtimer timer;
 struct task_struct *task;
};
# 158 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_clock_base {
 struct hrtimer_cpu_base *cpu_base;
 unsigned int index;
 clockid_t clockid;
 seqcount_t seq;
 struct hrtimer *running;
 struct timerqueue_head active;
 ktime_t (*get_time)(void);
 ktime_t offset;
} __attribute__((__aligned__((1 << 7))));

enum hrtimer_base_type {
 HRTIMER_BASE_MONOTONIC,
 HRTIMER_BASE_REALTIME,
 HRTIMER_BASE_BOOTTIME,
 HRTIMER_BASE_TAI,
 HRTIMER_BASE_MONOTONIC_SOFT,
 HRTIMER_BASE_REALTIME_SOFT,
 HRTIMER_BASE_BOOTTIME_SOFT,
 HRTIMER_BASE_TAI_SOFT,
 HRTIMER_MAX_CLOCK_BASES,
};
# 213 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
 raw_spinlock_t lock;
 unsigned int cpu;
 unsigned int active_bases;
 unsigned int clock_was_set_seq;
 unsigned int hres_active : 1,
     in_hrtirq : 1,
     hang_detected : 1,
     softirq_activated : 1;

 unsigned int nr_events;
 unsigned short nr_retries;
 unsigned short nr_hangs;
 unsigned int max_hang_time;





 ktime_t expires_next;
 struct hrtimer *next_timer;
 ktime_t softirq_expires_next;
 struct hrtimer *softirq_next_timer;
 struct hrtimer_clock_base clock_base[HRTIMER_MAX_CLOCK_BASES];
} __attribute__((__aligned__((1 << 7))));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
 timer->node.expires = time;
 timer->_softexpires = time;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_range(struct hrtimer *timer, ktime_t time, ktime_t delta)
{
 timer->_softexpires = time;
 timer->node.expires = ktime_add_safe(time, delta);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_range_ns(struct hrtimer *timer, ktime_t time, u64 delta)
{
 timer->_softexpires = time;
 timer->node.expires = ktime_add_safe(time, ns_to_ktime(delta));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_tv64(struct hrtimer *timer, s64 tv64)
{
 timer->node.expires = tv64;
 timer->_softexpires = tv64;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_add_expires(struct hrtimer *timer, ktime_t time)
{
 timer->node.expires = ktime_add_safe(timer->node.expires, time);
 timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_add_expires_ns(struct hrtimer *timer, u64 ns)
{
 timer->node.expires = ((timer->node.expires) + (ns));
 timer->_softexpires = ((timer->_softexpires) + (ns));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_expires(const struct hrtimer *timer)
{
 return timer->node.expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)
{
 return timer->_softexpires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_expires_tv64(const struct hrtimer *timer)
{
 return timer->node.expires;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_softexpires_tv64(const struct hrtimer *timer)
{
 return timer->_softexpires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_expires_ns(const struct hrtimer *timer)
{
 return ktime_to_ns(timer->node.expires);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_expires_remaining(const struct hrtimer *timer)
{
 return ((timer->node.expires) - (timer->base->get_time()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_cb_get_time(struct hrtimer *timer)
{
 return timer->base->get_time();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hrtimer_is_hres_active(struct hrtimer *timer)
{
 return 1 ?
  timer->base->cpu_base->hres_active : 0;
}


struct clock_event_device;

extern void hrtimer_interrupt(struct clock_event_device *dev);

extern void clock_was_set_delayed(void);

extern unsigned int hrtimer_resolution;
# 332 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t
__hrtimer_expires_remaining_adjusted(const struct hrtimer *timer, ktime_t now)
{
 ktime_t rem = ((timer->node.expires) - (now));





 if (0 && timer->is_rel)
  rem -= hrtimer_resolution;
 return rem;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t
hrtimer_expires_remaining_adjusted(const struct hrtimer *timer)
{
 return __hrtimer_expires_remaining_adjusted(timer,
          timer->base->get_time());
}

extern void clock_was_set(void);

extern void timerfd_clock_was_set(void);



extern void hrtimers_resume(void);

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct tick_device) tick_cpu_device;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_cancel_wait_running(struct hrtimer *timer)
{
 do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
}





extern void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,
    enum hrtimer_mode mode);
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,
     enum hrtimer_mode mode);
# 389 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_init_on_stack(struct hrtimer *timer,
      clockid_t which_clock,
      enum hrtimer_mode mode)
{
 hrtimer_init(timer, which_clock, mode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,
       clockid_t clock_id,
       enum hrtimer_mode mode)
{
 hrtimer_init_sleeper(sl, clock_id, mode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_hrtimer_on_stack(struct hrtimer *timer) { }



extern void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
       u64 range_ns, const enum hrtimer_mode mode);
# 418 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_start(struct hrtimer *timer, ktime_t tim,
     const enum hrtimer_mode mode)
{
 hrtimer_start_range_ns(timer, tim, 0, mode);
}

extern int hrtimer_cancel(struct hrtimer *timer);
extern int hrtimer_try_to_cancel(struct hrtimer *timer);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_start_expires(struct hrtimer *timer,
      enum hrtimer_mode mode)
{
 u64 delta;
 ktime_t soft, hard;
 soft = hrtimer_get_softexpires(timer);
 hard = hrtimer_get_expires(timer);
 delta = ktime_to_ns(((hard) - (soft)));
 hrtimer_start_range_ns(timer, soft, delta, mode);
}

void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,
       enum hrtimer_mode mode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_restart(struct hrtimer *timer)
{
 hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
}


extern ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_remaining(const struct hrtimer *timer)
{
 return __hrtimer_get_remaining(timer, false);
}

extern u64 hrtimer_get_next_event(void);
extern u64 hrtimer_next_event_without(const struct hrtimer *exclude);

extern bool hrtimer_active(const struct hrtimer *timer);
# 467 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hrtimer_is_queued(struct hrtimer *timer)
{

 return !!(({ do { extern void __compiletime_assert_140(void) ; if (!((sizeof(timer->state) == sizeof(char) || sizeof(timer->state) == sizeof(short) || sizeof(timer->state) == sizeof(int) || sizeof(timer->state) == sizeof(long)) || sizeof(timer->state) == sizeof(long long))) __compiletime_assert_140(); } while (0); ({ typeof( _Generic((timer->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (timer->state))) __x = (*(const volatile typeof( _Generic((timer->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (timer->state))) *)&(timer->state)); do { } while (0); (typeof(timer->state))__x; }); }) & 0x01);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hrtimer_callback_running(struct hrtimer *timer)
{
 return timer->base->running == timer;
}


extern u64
hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);
# 502 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 hrtimer_forward_now(struct hrtimer *timer,
          ktime_t interval)
{
 return hrtimer_forward(timer, timer->base->get_time(), interval);
}



extern int nanosleep_copyout(struct restart_block *, struct timespec64 *);
extern long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,
         const clockid_t clockid);

extern int schedule_hrtimeout_range(ktime_t *expires, u64 delta,
        const enum hrtimer_mode mode);
extern int schedule_hrtimeout_range_clock(ktime_t *expires,
       u64 delta,
       const enum hrtimer_mode mode,
       clockid_t clock_id);
extern int schedule_hrtimeout(ktime_t *expires, const enum hrtimer_mode mode);


extern void hrtimer_run_queues(void);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) hrtimers_init(void);


extern void sysrq_timer_list_show(void);

int hrtimers_prepare_cpu(unsigned int cpu);

int hrtimers_dead_cpu(unsigned int cpu);
# 21 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/seccomp.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h" 1
# 60 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h"
struct seccomp_data {
 int nr;
 __u32 arch;
 __u64 instruction_pointer;
 __u64 args[6];
};

struct seccomp_notif_sizes {
 __u16 seccomp_notif;
 __u16 seccomp_notif_resp;
 __u16 seccomp_data;
};

struct seccomp_notif {
 __u64 id;
 __u32 pid;
 __u32 flags;
 struct seccomp_data data;
};
# 109 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h"
struct seccomp_notif_resp {
 __u64 id;
 __s64 val;
 __s32 error;
 __u32 flags;
};
# 6 "/home/nathan/src/linux-next/include/linux/seccomp.h" 2
# 17 "/home/nathan/src/linux-next/include/linux/seccomp.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/unistd.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unistd.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/unistd_64.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h" 2
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unistd.h" 2
# 9 "/home/nathan/src/linux-next/include/uapi/linux/unistd.h" 2
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 2



# 1 "/home/nathan/src/linux-next/include/asm-generic/seccomp.h" 1
# 31 "/home/nathan/src/linux-next/include/asm-generic/seccomp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const int *get_compat_mode1_syscalls(void)
{
 static const int mode1_syscalls_32[] = {
  3, 4,
  1, 119,
  0,
 };
 return mode1_syscalls_32;
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 2
# 18 "/home/nathan/src/linux-next/include/linux/seccomp.h" 2

struct seccomp_filter;
# 31 "/home/nathan/src/linux-next/include/linux/seccomp.h"
struct seccomp {
 int mode;
 atomic_t filter_count;
 struct seccomp_filter *filter;
};


extern int __secure_computing(const struct seccomp_data *sd);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int secure_computing(void)
{
 if (__builtin_expect(!!(test_ti_thread_flag(((struct thread_info *)get_current()), 10)), 0))
  return __secure_computing(((void *)0));
 return 0;
}




extern long prctl_get_seccomp(void);
extern long prctl_set_seccomp(unsigned long, void *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int seccomp_mode(struct seccomp *s)
{
 return s->mode;
}
# 87 "/home/nathan/src/linux-next/include/linux/seccomp.h"
extern void seccomp_filter_release(struct task_struct *tsk);
extern void get_seccomp_filter(struct task_struct *tsk);
# 101 "/home/nathan/src/linux-next/include/linux/seccomp.h"
extern long seccomp_get_filter(struct task_struct *task,
          unsigned long filter_off, void *data);
extern long seccomp_get_metadata(struct task_struct *task,
     unsigned long filter_off, void *data);
# 22 "/home/nathan/src/linux-next/include/linux/sched.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/resource.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/resource.h" 1
# 24 "/home/nathan/src/linux-next/include/uapi/linux/resource.h"
struct rusage {
 struct __kernel_old_timeval ru_utime;
 struct __kernel_old_timeval ru_stime;
 __kernel_long_t ru_maxrss;
 __kernel_long_t ru_ixrss;
 __kernel_long_t ru_idrss;
 __kernel_long_t ru_isrss;
 __kernel_long_t ru_minflt;
 __kernel_long_t ru_majflt;
 __kernel_long_t ru_nswap;
 __kernel_long_t ru_inblock;
 __kernel_long_t ru_oublock;
 __kernel_long_t ru_msgsnd;
 __kernel_long_t ru_msgrcv;
 __kernel_long_t ru_nsignals;
 __kernel_long_t ru_nvcsw;
 __kernel_long_t ru_nivcsw;
};

struct rlimit {
 __kernel_ulong_t rlim_cur;
 __kernel_ulong_t rlim_max;
};



struct rlimit64 {
 __u64 rlim_cur;
 __u64 rlim_max;
};
# 78 "/home/nathan/src/linux-next/include/uapi/linux/resource.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/resource.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/resource.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/resource.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/resource.h" 2
# 2 "./arch/powerpc/include/generated/uapi/asm/resource.h" 2
# 79 "/home/nathan/src/linux-next/include/uapi/linux/resource.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/resource.h" 2


struct task_struct;

void getrusage(struct task_struct *p, int who, struct rusage *ru);
int do_prlimit(struct task_struct *tsk, unsigned int resource,
  struct rlimit *new_rlim, struct rlimit *old_rlim);
# 26 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/latencytop.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/latencytop.h"
struct task_struct;






struct latency_record {
 unsigned long backtrace[12];
 unsigned int count;
 unsigned long time;
 unsigned long max;
};



extern int latencytop_enabled;
void __account_scheduler_latency(struct task_struct *task, int usecs, int inter);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
account_scheduler_latency(struct task_struct *task, int usecs, int inter)
{
 if (__builtin_expect(!!(latencytop_enabled), 0))
  __account_scheduler_latency(task, usecs, inter);
}

void clear_tsk_latency_tracing(struct task_struct *p);

int sysctl_latencytop(struct ctl_table *table, int write, void *buffer,
  size_t *lenp, loff_t *ppos);
# 27 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/prio.h" 1
# 48 "/home/nathan/src/linux-next/include/linux/sched/prio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long nice_to_rlimit(long nice)
{
 return (19 - nice + 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long rlimit_to_nice(long prio)
{
 return (19 - prio + 1);
}
# 28 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/types.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/sched/types.h"
struct task_cputime {
 u64 stime;
 u64 utime;
 unsigned long long sum_exec_runtime;
};
# 29 "/home/nathan/src/linux-next/include/linux/sched.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h"
struct task_io_accounting {


 u64 rchar;

 u64 wchar;

 u64 syscr;

 u64 syscw;







 u64 read_bytes;





 u64 write_bytes;
# 44 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h"
 u64 cancelled_write_bytes;

};
# 32 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/posix-timers.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/alarmtimer.h" 1








struct rtc_device;

enum alarmtimer_type {
 ALARM_REALTIME,
 ALARM_BOOTTIME,


 ALARM_NUMTYPE,


 ALARM_REALTIME_FREEZER,
 ALARM_BOOTTIME_FREEZER,
};

enum alarmtimer_restart {
 ALARMTIMER_NORESTART,
 ALARMTIMER_RESTART,
};
# 42 "/home/nathan/src/linux-next/include/linux/alarmtimer.h"
struct alarm {
 struct timerqueue_node node;
 struct hrtimer timer;
 enum alarmtimer_restart (*function)(struct alarm *, ktime_t now);
 enum alarmtimer_type type;
 int state;
 void *data;
};

void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
  enum alarmtimer_restart (*function)(struct alarm *, ktime_t));
void alarm_start(struct alarm *alarm, ktime_t start);
void alarm_start_relative(struct alarm *alarm, ktime_t start);
void alarm_restart(struct alarm *alarm);
int alarm_try_to_cancel(struct alarm *alarm);
int alarm_cancel(struct alarm *alarm);

u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval);
u64 alarm_forward_now(struct alarm *alarm, ktime_t interval);
ktime_t alarm_expires_remaining(const struct alarm *alarm);



struct rtc_device *alarmtimer_get_rtcdev(void);
# 8 "/home/nathan/src/linux-next/include/linux/posix-timers.h" 2


struct kernel_siginfo;
struct task_struct;
# 38 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t make_process_cpuclock(const unsigned int pid,
  const clockid_t clock)
{
 return ((~pid) << 3) | clock;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t make_thread_cpuclock(const unsigned int tid,
  const clockid_t clock)
{
 return make_process_cpuclock(tid, clock | 4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t fd_to_clockid(const int fd)
{
 return make_process_cpuclock((unsigned int) fd, 3);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int clockid_to_fd(const clockid_t clk)
{
 return ~(clk >> 3);
}
# 69 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct cpu_timer {
 struct timerqueue_node node;
 struct timerqueue_head *head;
 struct pid *pid;
 struct list_head elist;
 int firing;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpu_timer_enqueue(struct timerqueue_head *head,
         struct cpu_timer *ctmr)
{
 ctmr->head = head;
 return timerqueue_add(head, &ctmr->node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_timer_dequeue(struct cpu_timer *ctmr)
{
 if (ctmr->head) {
  timerqueue_del(ctmr->head, &ctmr->node);
  ctmr->head = ((void *)0);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 cpu_timer_getexpires(struct cpu_timer *ctmr)
{
 return ctmr->node.expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_timer_setexpires(struct cpu_timer *ctmr, u64 exp)
{
 ctmr->node.expires = exp;
}






struct posix_cputimer_base {
 u64 nextevt;
 struct timerqueue_head tqhead;
};
# 122 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct posix_cputimers {
 struct posix_cputimer_base bases[3];
 unsigned int timers_active;
 unsigned int expiry_active;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void posix_cputimers_init(struct posix_cputimers *pct)
{
 memset(pct, 0, sizeof(*pct));
 pct->bases[0].nextevt = ((u64)~0ULL);
 pct->bases[1].nextevt = ((u64)~0ULL);
 pct->bases[2].nextevt = ((u64)~0ULL);
}

void posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void posix_cputimers_rt_watchdog(struct posix_cputimers *pct,
            u64 runtime)
{
 pct->bases[2].nextevt = runtime;
}
# 193 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct k_itimer {
 struct list_head list;
 struct hlist_node t_hash;
 spinlock_t it_lock;
 const struct k_clock *kclock;
 clockid_t it_clock;
 timer_t it_id;
 int it_active;
 s64 it_overrun;
 s64 it_overrun_last;
 int it_requeue_pending;
 int it_sigev_notify;
 ktime_t it_interval;
 struct signal_struct *it_signal;
 union {
  struct pid *it_pid;
  struct task_struct *it_process;
 };
 struct sigqueue *sigq;
 union {
  struct {
   struct hrtimer timer;
  } real;
  struct cpu_timer cpu;
  struct {
   struct alarm alarmtimer;
  } alarm;
 } it;
 struct callback_head rcu;
};

void run_posix_cpu_timers(void);
void posix_cpu_timers_exit(struct task_struct *task);
void posix_cpu_timers_exit_group(struct task_struct *task);
void set_process_cpu_timer(struct task_struct *task, unsigned int clock_idx,
      u64 *newval, u64 *oldval);

void update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new);

void posixtimer_rearm(struct kernel_siginfo *info);
# 33 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h" 1
# 16 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
enum rseq_cpu_id_state {
 RSEQ_CPU_ID_UNINITIALIZED = -1,
 RSEQ_CPU_ID_REGISTRATION_FAILED = -2,
};

enum rseq_flags {
 RSEQ_FLAG_UNREGISTER = (1 << 0),
};

enum rseq_cs_flags_bit {
 RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
 RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
 RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum rseq_cs_flags {
 RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT),
 RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT),
 RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT),
};






struct rseq_cs {

 __u32 version;

 __u32 flags;
 __u64 start_ip;

 __u64 post_commit_offset;
 __u64 abort_ip;
} __attribute__((aligned(4 * sizeof(__u64))));







struct rseq {
# 75 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 cpu_id_start;
# 90 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 cpu_id;
# 109 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 union {
  __u64 ptr64;

  __u64 ptr;
# 124 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 } rseq_cs;
# 144 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 flags;
} __attribute__((aligned(4 * sizeof(__u64))));
# 34 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kcsan.h" 1
# 55 "/home/nathan/src/linux-next/include/linux/kcsan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcsan_init(void) { }
# 35 "/home/nathan/src/linux-next/include/linux/sched.h" 2


struct audit_context;
struct backing_dev_info;
struct bio_list;
struct blk_plug;
struct capture_control;
struct cfs_rq;
struct fs_struct;
struct futex_pi_state;
struct io_context;
struct mempolicy;
struct nameidata;
struct nsproxy;
struct perf_event_context;
struct pid_namespace;
struct pipe_inode_info;
struct rcu_node;
struct reclaim_state;
struct robust_list_head;
struct root_domain;
struct rq;
struct sched_attr;
struct sched_param;
struct seq_file;
struct sighand_struct;
struct signal_struct;
struct task_delay_info;
struct task_group;
# 216 "/home/nathan/src/linux-next/include/linux/sched.h"
extern void scheduler_tick(void);



extern long schedule_timeout(long timeout);
extern long schedule_timeout_interruptible(long timeout);
extern long schedule_timeout_killable(long timeout);
extern long schedule_timeout_uninterruptible(long timeout);
extern long schedule_timeout_idle(long timeout);
           void schedule(void);
extern void schedule_preempt_disabled(void);
           void preempt_schedule_irq(void);

extern int __attribute__((__warn_unused_result__)) io_schedule_prepare(void);
extern void io_schedule_finish(int token);
extern long io_schedule_timeout(long timeout);
extern void io_schedule(void);
# 243 "/home/nathan/src/linux-next/include/linux/sched.h"
struct prev_cputime {

 u64 utime;
 u64 stime;
 raw_spinlock_t lock;

};

enum vtime_state {

 VTIME_INACTIVE = 0,

 VTIME_IDLE,

 VTIME_SYS,

 VTIME_USER,

 VTIME_GUEST,
};

struct vtime {
 seqcount_t seqcount;
 unsigned long long starttime;
 enum vtime_state state;
 unsigned int cpu;
 u64 utime;
 u64 stime;
 u64 gtime;
};







enum uclamp_id {
 UCLAMP_MIN = 0,
 UCLAMP_MAX,
 UCLAMP_CNT
};


extern struct root_domain def_root_domain;
extern struct mutex sched_domains_mutex;


struct sched_info {




 unsigned long pcount;


 unsigned long long run_delay;




 unsigned long long last_arrival;


 unsigned long long last_queued;


};
# 326 "/home/nathan/src/linux-next/include/linux/sched.h"
struct load_weight {
 unsigned long weight;
 u32 inv_weight;
};
# 353 "/home/nathan/src/linux-next/include/linux/sched.h"
struct util_est {
 unsigned int enqueued;
 unsigned int ewma;

} __attribute__((__aligned__(sizeof(u64))));
# 404 "/home/nathan/src/linux-next/include/linux/sched.h"
struct sched_avg {
 u64 last_update_time;
 u64 load_sum;
 u64 runnable_sum;
 u32 util_sum;
 u32 period_contrib;
 unsigned long load_avg;
 unsigned long runnable_avg;
 unsigned long util_avg;
 struct util_est util_est;
} __attribute__((__aligned__((1 << 7))));

struct sched_statistics {

 u64 wait_start;
 u64 wait_max;
 u64 wait_count;
 u64 wait_sum;
 u64 iowait_count;
 u64 iowait_sum;

 u64 sleep_start;
 u64 sleep_max;
 s64 sum_sleep_runtime;

 u64 block_start;
 u64 block_max;
 u64 exec_max;
 u64 slice_max;

 u64 nr_migrations_cold;
 u64 nr_failed_migrations_affine;
 u64 nr_failed_migrations_running;
 u64 nr_failed_migrations_hot;
 u64 nr_forced_migrations;

 u64 nr_wakeups;
 u64 nr_wakeups_sync;
 u64 nr_wakeups_migrate;
 u64 nr_wakeups_local;
 u64 nr_wakeups_remote;
 u64 nr_wakeups_affine;
 u64 nr_wakeups_affine_attempts;
 u64 nr_wakeups_passive;
 u64 nr_wakeups_idle;

};

struct sched_entity {

 struct load_weight load;
 struct rb_node run_node;
 struct list_head group_node;
 unsigned int on_rq;

 u64 exec_start;
 u64 sum_exec_runtime;
 u64 vruntime;
 u64 prev_sum_exec_runtime;

 u64 nr_migrations;

 struct sched_statistics statistics;


 int depth;
 struct sched_entity *parent;

 struct cfs_rq *cfs_rq;

 struct cfs_rq *my_q;

 unsigned long runnable_weight;
# 486 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct sched_avg avg;

};

struct sched_rt_entity {
 struct list_head run_list;
 unsigned long timeout;
 unsigned long watchdog_stamp;
 unsigned int time_slice;
 unsigned short on_rq;
 unsigned short on_list;

 struct sched_rt_entity *back;







} ;

struct sched_dl_entity {
 struct rb_node rb_node;






 u64 dl_runtime;
 u64 dl_deadline;
 u64 dl_period;
 u64 dl_bw;
 u64 dl_density;






 s64 runtime;
 u64 deadline;
 unsigned int flags;
# 555 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned int dl_throttled : 1;
 unsigned int dl_boosted : 1;
 unsigned int dl_yielded : 1;
 unsigned int dl_non_contending : 1;
 unsigned int dl_overrun : 1;





 struct hrtimer dl_timer;
# 574 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct hrtimer inactive_timer;
};
# 612 "/home/nathan/src/linux-next/include/linux/sched.h"
union rcu_special {
 struct {
  u8 blocked;
  u8 need_qs;
  u8 exp_hint;
  u8 need_mb;
 } b;
 u32 s;
};

enum perf_event_task_context {
 perf_invalid_context = -1,
 perf_hw_context = 0,
 perf_sw_context,
 perf_nr_task_contexts,
};

struct wake_q_node {
 struct wake_q_node *next;
};

struct task_struct {





 struct thread_info thread_info;


 volatile long state;







 void *stack;
 refcount_t usage;

 unsigned int flags;
 unsigned int ptrace;


 struct {
  struct llist_node wake_entry;
  unsigned int wake_entry_type;
 };
 int on_cpu;


 unsigned int cpu;

 unsigned int wakee_flips;
 unsigned long wakee_flip_decay_ts;
 struct task_struct *last_wakee;
# 677 "/home/nathan/src/linux-next/include/linux/sched.h"
 int recent_used_cpu;
 int wake_cpu;

 int on_rq;

 int prio;
 int static_prio;
 int normal_prio;
 unsigned int rt_priority;

 const struct sched_class *sched_class;
 struct sched_entity se;
 struct sched_rt_entity rt;

 struct task_group *sched_task_group;

 struct sched_dl_entity dl;
# 704 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct hlist_head preempt_notifiers;



 unsigned int btrace_seq;


 unsigned int policy;
 int nr_cpus_allowed;
 const cpumask_t *cpus_ptr;
 cpumask_t cpus_mask;
# 724 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned long rcu_tasks_nvcsw;
 u8 rcu_tasks_holdout;
 u8 rcu_tasks_idx;
 int rcu_tasks_idle_cpu;
 struct list_head rcu_tasks_holdout_list;



 int trc_reader_nesting;
 int trc_ipi_to_cpu;
 union rcu_special trc_reader_special;
 bool trc_reader_checked;
 struct list_head trc_holdout_list;


 struct sched_info sched_info;

 struct list_head tasks;

 struct plist_node pushable_tasks;
 struct rb_node pushable_dl_tasks;


 struct mm_struct *mm;
 struct mm_struct *active_mm;


 struct vmacache vmacache;


 struct task_rss_stat rss_stat;

 int exit_state;
 int exit_code;
 int exit_signal;

 int pdeath_signal;

 unsigned long jobctl;


 unsigned int personality;


 unsigned sched_reset_on_fork:1;
 unsigned sched_contributes_to_load:1;
 unsigned sched_migrated:1;
 unsigned sched_remote_wakeup:1;

 unsigned sched_psi_wake_requeue:1;



 unsigned :0;




 unsigned in_execve:1;
 unsigned in_iowait:1;

 unsigned restore_sigmask:1;


 unsigned in_user_fault:1;






 unsigned no_cgroup_migration:1;

 unsigned frozen:1;


 unsigned use_memdelay:1;



 unsigned in_memstall:1;


 unsigned long atomic_flags;

 struct restart_block restart_block;

 pid_t pid;
 pid_t tgid;
# 825 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct task_struct *real_parent;


 struct task_struct *parent;




 struct list_head children;
 struct list_head sibling;
 struct task_struct *group_leader;







 struct list_head ptraced;
 struct list_head ptrace_entry;


 struct pid *thread_pid;
 struct hlist_node pid_links[PIDTYPE_MAX];
 struct list_head thread_group;
 struct list_head thread_node;

 struct completion *vfork_done;


 int *set_child_tid;


 int *clear_child_tid;

 u64 utime;
 u64 stime;




 u64 gtime;
 struct prev_cputime prev_cputime;

 struct vtime vtime;



 atomic_t tick_dep_mask;


 unsigned long nvcsw;
 unsigned long nivcsw;


 u64 start_time;


 u64 start_boottime;


 unsigned long min_flt;
 unsigned long maj_flt;


 struct posix_cputimers posix_cputimers;




 const struct cred *ptracer_cred;


 const struct cred *real_cred;


 const struct cred *cred;



 struct key *cached_requested_key;
# 915 "/home/nathan/src/linux-next/include/linux/sched.h"
 char comm[16];

 struct nameidata *nameidata;


 struct sysv_sem sysvsem;
 struct sysv_shm sysvshm;







 struct fs_struct *fs;


 struct files_struct *files;


 struct nsproxy *nsproxy;


 struct signal_struct *signal;
 struct sighand_struct *sighand;
 sigset_t blocked;
 sigset_t real_blocked;

 sigset_t saved_sigmask;
 struct sigpending pending;
 unsigned long sas_ss_sp;
 size_t sas_ss_size;
 unsigned int sas_ss_flags;

 struct callback_head *task_works;



 struct audit_context *audit_context;

 kuid_t loginuid;
 unsigned int sessionid;

 struct seccomp seccomp;


 u64 parent_exec_id;
 u64 self_exec_id;


 spinlock_t alloc_lock;


 raw_spinlock_t pi_lock;

 struct wake_q_node wake_q;



 struct rb_root_cached pi_waiters;

 struct task_struct *pi_top_task;

 struct rt_mutex_waiter *pi_blocked_on;
# 1022 "/home/nathan/src/linux-next/include/linux/sched.h"
 void *journal_info;


 struct bio_list *bio_list;



 struct blk_plug *plug;



 struct reclaim_state *reclaim_state;

 struct backing_dev_info *backing_dev_info;

 struct io_context *io_context;


 struct capture_control *capture_control;


 unsigned long ptrace_message;
 kernel_siginfo_t *last_siginfo;

 struct task_io_accounting ioac;


 unsigned int psi_flags;



 u64 acct_rss_mem1;

 u64 acct_vm_mem1;

 u64 acct_timexpd;



 nodemask_t mems_allowed;

 seqcount_t mems_allowed_seq;
 int cpuset_mem_spread_rotor;
 int cpuset_slab_spread_rotor;



 struct css_set *cgroups;

 struct list_head cg_list;






 struct robust_list_head *robust_list;

 struct compat_robust_list_head *compat_robust_list;

 struct list_head pi_state_list;
 struct futex_pi_state *pi_state_cache;
 struct mutex futex_exit_mutex;
 unsigned int futex_state;


 struct perf_event_context *perf_event_ctxp[perf_nr_task_contexts];
 struct mutex perf_event_mutex;
 struct list_head perf_event_list;






 struct mempolicy *mempolicy;
 short il_prev;
 short pref_node_fork;


 int numa_scan_seq;
 unsigned int numa_scan_period;
 unsigned int numa_scan_period_max;
 int numa_preferred_nid;
 unsigned long numa_migrate_retry;

 u64 node_stamp;
 u64 last_task_numa_placement;
 u64 last_sum_exec_runtime;
 struct callback_head numa_work;
# 1121 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct numa_group *numa_group;
# 1137 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned long *numa_faults;
 unsigned long total_numa_faults;







 unsigned long numa_faults_locality[3];

 unsigned long numa_pages_migrated;



 struct rseq *rseq;
 u32 rseq_sig;




 unsigned long rseq_event_mask;


 struct tlbflush_unmap_batch tlb_ubc;

 union {
  refcount_t rcu_users;
  struct callback_head rcu;
 };


 struct pipe_inode_info *splice_pipe;

 struct page_frag task_frag;


 struct task_delay_info *delays;
# 1185 "/home/nathan/src/linux-next/include/linux/sched.h"
 int nr_dirtied;
 int nr_dirtied_pause;

 unsigned long dirty_paused_when;


 int latency_record_count;
 struct latency_record latency_record[32];





 u64 timer_slack_ns;
 u64 default_timer_slack_ns;
# 1210 "/home/nathan/src/linux-next/include/linux/sched.h"
 int curr_ret_stack;
 int curr_ret_depth;


 struct ftrace_ret_stack *ret_stack;


 unsigned long long ftrace_timestamp;





 atomic_t trace_overrun;


 atomic_t tracing_graph_pause;




 unsigned long trace;


 unsigned long trace_recursion;
# 1263 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct mem_cgroup *memcg_in_oom;
 gfp_t memcg_oom_gfp_mask;
 int memcg_oom_order;


 unsigned int memcg_nr_pages_over_high;


 struct mem_cgroup *active_memcg;



 struct request_queue *throttle_queue;



 struct uprobe_task *utask;


 unsigned int sequential_io;
 unsigned int sequential_io_avg;




 int pagefault_disabled;

 struct task_struct *oom_reaper_list;






 refcount_t stack_refcount;






 void *security;
# 1334 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct thread_struct thread;







};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_pid(struct task_struct *task)
{
 return task->thread_pid;
}
# 1360 "/home/nathan/src/linux-next/include/linux/sched.h"
pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type, struct pid_namespace *ns);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_nr(struct task_struct *tsk)
{
 return tsk->pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PID, ((void *)0));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_nr(struct task_struct *tsk)
{
 return tsk->tgid;
}
# 1393 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pid_alive(const struct task_struct *p)
{
 return p->thread_pid != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ((void *)0));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_session_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_SID, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_ppid_nr_ns(const struct task_struct *tsk, struct pid_namespace *ns)
{
 pid_t pid = 0;

 rcu_read_lock();
 if (pid_alive(tsk))
  pid = task_tgid_nr_ns(({ typeof(*(tsk->real_parent)) *________p1 = (typeof(*(tsk->real_parent)) *)({ do { extern void __compiletime_assert_141(void) ; if (!((sizeof((tsk->real_parent)) == sizeof(char) || sizeof((tsk->real_parent)) == sizeof(short) || sizeof((tsk->real_parent)) == sizeof(int) || sizeof((tsk->real_parent)) == sizeof(long)) || sizeof((tsk->real_parent)) == sizeof(long long))) __compiletime_assert_141(); } while (0); ({ typeof( _Generic(((tsk->real_parent)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((tsk->real_parent)))) __x = (*(const volatile typeof( _Generic(((tsk->real_parent)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((tsk->real_parent)))) *)&((tsk->real_parent))); do { } while (0); (typeof((tsk->real_parent)))__x; }); }); do { } while (0); ; ((typeof(*(tsk->real_parent)) *)(________p1)); }), ns);
 rcu_read_unlock();

 return pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_ppid_nr(const struct task_struct *tsk)
{
 return task_ppid_nr_ns(tsk, &init_pid_ns);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_nr(struct task_struct *tsk)
{
 return task_pgrp_nr_ns(tsk, &init_pid_ns);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int task_state_index(struct task_struct *tsk)
{
 unsigned int tsk_state = ({ do { extern void __compiletime_assert_142(void) ; if (!((sizeof(tsk->state) == sizeof(char) || sizeof(tsk->state) == sizeof(short) || sizeof(tsk->state) == sizeof(int) || sizeof(tsk->state) == sizeof(long)) || sizeof(tsk->state) == sizeof(long long))) __compiletime_assert_142(); } while (0); ({ typeof( _Generic((tsk->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (tsk->state))) __x = (*(const volatile typeof( _Generic((tsk->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (tsk->state))) *)&(tsk->state)); do { } while (0); (typeof(tsk->state))__x; }); });
 unsigned int state = (tsk_state | tsk->exit_state) & (0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040);

 do { extern void __compiletime_assert_143(void) ; if (!(!(((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) == 0 || ((((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) - 1)) != 0)))) __compiletime_assert_143(); } while (0);

 if (tsk_state == (0x0002 | 0x0400))
  state = ((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1);

 return fls(state);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char task_index_to_char(unsigned int state)
{
 static const char state_char[] = "RSDTtXZPI";

 do { extern void __compiletime_assert_144(void) ; if (!(!(1 + ( __builtin_constant_p((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ? ( __builtin_constant_p((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ? ( ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) < 2 ? 0 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 63) ? 63 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 62) ? 62 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 61) ? 61 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 60) ? 60 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 59) ? 59 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 58) ? 58 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 57) ? 57 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 56) ? 56 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 55) ? 55 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 54) ? 54 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 53) ? 53 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 52) ? 52 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 51) ? 51 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 50) ? 50 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 49) ? 49 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 48) ? 48 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 47) ? 47 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 46) ? 46 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 45) ? 45 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 44) ? 44 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 43) ? 43 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 42) ? 42 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 41) ? 41 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 40) ? 40 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 39) ? 39 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 38) ? 38 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 37) ? 37 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 36) ? 36 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 35) ? 35 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 34) ? 34 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 33) ? 33 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 32) ? 32 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 31) ? 31 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 30) ? 30 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 29) ? 29 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 28) ? 28 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 27) ? 27 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 26) ? 26 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 25) ? 25 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 24) ? 24 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 23) ? 23 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 22) ? 22 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 21) ? 21 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 20) ? 20 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 19) ? 19 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 18) ? 18 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 17) ? 17 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 16) ? 16 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 15) ? 15 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 14) ? 14 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 13) ? 13 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 12) ? 12 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 11) ? 11 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 10) ? 10 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 9) ? 9 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 8) ? 8 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 7) ? 7 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 6) ? 6 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 5) ? 5 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 4) ? 4 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 3) ? 3 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) <= 4) ? __ilog2_u32((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) : __ilog2_u64((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ) != sizeof(state_char) - 1))) __compiletime_assert_144(); } while (0);

 return state_char[state];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char task_state_to_char(struct task_struct *tsk)
{
 return task_index_to_char(task_state_index(tsk));
}
# 1491 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_global_init(struct task_struct *tsk)
{
 return task_tgid_nr(tsk) == 1;
}

extern struct pid *cad_pid;
# 1560 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_percpu_thread(void)
{

 return (get_current()->flags & 0x04000000) &&
  (get_current()->nr_cpus_allowed == 1);



}
# 1592 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_no_new_privs(struct task_struct *p) { return test_bit(0, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_no_new_privs(struct task_struct *p) { set_bit(0, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spread_page(struct task_struct *p) { return test_bit(1, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spread_page(struct task_struct *p) { set_bit(1, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spread_page(struct task_struct *p) { clear_bit(1, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spread_slab(struct task_struct *p) { return test_bit(2, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spread_slab(struct task_struct *p) { set_bit(2, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spread_slab(struct task_struct *p) { clear_bit(2, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_disable(struct task_struct *p) { return test_bit(3, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_disable(struct task_struct *p) { set_bit(3, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ssb_disable(struct task_struct *p) { clear_bit(3, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_noexec(struct task_struct *p) { return test_bit(7, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_noexec(struct task_struct *p) { set_bit(7, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ssb_noexec(struct task_struct *p) { clear_bit(7, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_force_disable(struct task_struct *p) { return test_bit(4, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_force_disable(struct task_struct *p) { set_bit(4, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ib_disable(struct task_struct *p) { return test_bit(5, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ib_disable(struct task_struct *p) { set_bit(5, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ib_disable(struct task_struct *p) { clear_bit(5, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ib_force_disable(struct task_struct *p) { return test_bit(6, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ib_force_disable(struct task_struct *p) { set_bit(6, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
current_restore_flags(unsigned long orig_flags, unsigned long flags)
{
 get_current()->flags &= ~flags;
 get_current()->flags |= orig_flags & flags;
}

extern int cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);
extern int task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed);

extern void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask);
extern int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask);
# 1645 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int yield_to(struct task_struct *p, bool preempt);
extern void set_user_nice(struct task_struct *p, long nice);
extern int task_prio(const struct task_struct *p);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice(const struct task_struct *p)
{
 return (((p)->static_prio) - (100 + (19 - -20 + 1) / 2));
}

extern int can_nice(const struct task_struct *p, const int nice);
extern int task_curr(const struct task_struct *p);
extern int idle_cpu(int cpu);
extern int available_idle_cpu(int cpu);
extern int sched_setscheduler(struct task_struct *, int, const struct sched_param *);
extern int sched_setscheduler_nocheck(struct task_struct *, int, const struct sched_param *);
extern int sched_setattr(struct task_struct *, const struct sched_attr *);
extern int sched_setattr_nocheck(struct task_struct *, const struct sched_attr *);
extern struct task_struct *idle_task(int cpu);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_idle_task(const struct task_struct *p)
{
 return !!(p->flags & 0x00000002);
}

extern struct task_struct *curr_task(int cpu);
extern void ia64_set_curr_task(int cpu, struct task_struct *p);

void yield(void);

union thread_union {

 struct task_struct task;




 unsigned long stack[(1 << 14)/sizeof(long)];
};





extern unsigned long init_stack[(1 << 14) / sizeof(unsigned long)];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct thread_info *task_thread_info(struct task_struct *task)
{
 return &task->thread_info;
}
# 1722 "/home/nathan/src/linux-next/include/linux/sched.h"
extern struct task_struct *find_task_by_vpid(pid_t nr);
extern struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns);




extern struct task_struct *find_get_task_by_vpid(pid_t nr);

extern int wake_up_state(struct task_struct *tsk, unsigned int state);
extern int wake_up_process(struct task_struct *tsk);
extern void wake_up_new_task(struct task_struct *tsk);


extern void kick_process(struct task_struct *tsk);




extern void __set_task_comm(struct task_struct *tsk, const char *from, bool exec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_task_comm(struct task_struct *tsk, const char *from)
{
 __set_task_comm(tsk, from, false);
}

extern char *__get_task_comm(char *to, size_t len, struct task_struct *tsk);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void scheduler_ipi(void)
{





 do { if (test_ti_thread_flag(((struct thread_info *)get_current()), 2)) set_preempt_need_resched(); } while (0);
}
extern unsigned long wait_task_inactive(struct task_struct *, long match_state);
# 1776 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 set_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 clear_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_tsk_thread_flag(struct task_struct *tsk, int flag,
       bool value)
{
 update_ti_thread_flag(task_thread_info(tsk), flag, value);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_and_set_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_and_clear_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_tsk_need_resched(struct task_struct *tsk)
{
 set_tsk_thread_flag(tsk,2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_need_resched(struct task_struct *tsk)
{
 clear_tsk_thread_flag(tsk,2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_tsk_need_resched(struct task_struct *tsk)
{
 return __builtin_expect(!!(test_tsk_thread_flag(tsk,2)), 0);
}
# 1829 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int _cond_resched(void);
# 1839 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int __cond_resched_lock(spinlock_t *lock);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cond_resched_rcu(void)
{

 rcu_read_unlock();
 ({ ___might_sleep("include/linux/sched.h", 1850, 0); _cond_resched(); });
 rcu_read_lock();

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int spin_needbreak(spinlock_t *lock)
{



 return 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool need_resched(void)
{
 return __builtin_expect(!!(test_ti_thread_flag(((struct thread_info *)get_current()), 2)), 0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int task_cpu(const struct task_struct *p)
{

 return ({ do { extern void __compiletime_assert_145(void) ; if (!((sizeof(p->cpu) == sizeof(char) || sizeof(p->cpu) == sizeof(short) || sizeof(p->cpu) == sizeof(int) || sizeof(p->cpu) == sizeof(long)) || sizeof(p->cpu) == sizeof(long long))) __compiletime_assert_145(); } while (0); ({ typeof( _Generic((p->cpu), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->cpu))) __x = (*(const volatile typeof( _Generic((p->cpu), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->cpu))) *)&(p->cpu)); do { } while (0); (typeof(p->cpu))__x; }); });



}

extern void set_task_cpu(struct task_struct *p, unsigned int cpu);
# 1918 "/home/nathan/src/linux-next/include/linux/sched.h"
extern long sched_setaffinity(pid_t pid, const struct cpumask *new_mask);
extern long sched_getaffinity(pid_t pid, struct cpumask *mask);
# 1931 "/home/nathan/src/linux-next/include/linux/sched.h"
enum rseq_event_mask_bits {
 RSEQ_EVENT_PREEMPT_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT,
 RSEQ_EVENT_SIGNAL_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT,
 RSEQ_EVENT_MIGRATE_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT,
};

enum rseq_event_mask {
 RSEQ_EVENT_PREEMPT = (1U << RSEQ_EVENT_PREEMPT_BIT),
 RSEQ_EVENT_SIGNAL = (1U << RSEQ_EVENT_SIGNAL_BIT),
 RSEQ_EVENT_MIGRATE = (1U << RSEQ_EVENT_MIGRATE_BIT),
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_set_notify_resume(struct task_struct *t)
{
 if (t->rseq)
  set_tsk_thread_flag(t, 13);
}

void __rseq_handle_notify_resume(struct ksignal *sig, struct pt_regs *regs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_handle_notify_resume(struct ksignal *ksig,
          struct pt_regs *regs)
{
 if (get_current()->rseq)
  __rseq_handle_notify_resume(ksig, regs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_signal_deliver(struct ksignal *ksig,
           struct pt_regs *regs)
{
 __asm__ __volatile__("" : : : "memory");
 __set_bit(RSEQ_EVENT_SIGNAL_BIT, &get_current()->rseq_event_mask);
 __asm__ __volatile__("" : : : "memory");
 rseq_handle_notify_resume(ksig, regs);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_preempt(struct task_struct *t)
{
 __set_bit(RSEQ_EVENT_PREEMPT_BIT, &t->rseq_event_mask);
 rseq_set_notify_resume(t);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_migrate(struct task_struct *t)
{
 __set_bit(RSEQ_EVENT_MIGRATE_BIT, &t->rseq_event_mask);
 rseq_set_notify_resume(t);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_fork(struct task_struct *t, unsigned long clone_flags)
{
 if (clone_flags & 0x00000100) {
  t->rseq = ((void *)0);
  t->rseq_sig = 0;
  t->rseq_event_mask = 0;
 } else {
  t->rseq = get_current()->rseq;
  t->rseq_sig = get_current()->rseq_sig;
  t->rseq_event_mask = get_current()->rseq_event_mask;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_execve(struct task_struct *t)
{
 t->rseq = ((void *)0);
 t->rseq_sig = 0;
 t->rseq_event_mask = 0;
}
# 2033 "/home/nathan/src/linux-next/include/linux/sched.h"
void __exit_umh(struct task_struct *tsk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_umh(struct task_struct *tsk)
{
 if (__builtin_expect(!!(tsk->flags & 0x02000000), 0))
  __exit_umh(tsk);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_syscall(struct pt_regs *regs)
{
}



const struct sched_avg *sched_trace_cfs_rq_avg(struct cfs_rq *cfs_rq);
char *sched_trace_cfs_rq_path(struct cfs_rq *cfs_rq, char *str, int len);
int sched_trace_cfs_rq_cpu(struct cfs_rq *cfs_rq);

const struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq);
const struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq);
const struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq);

int sched_trace_rq_cpu(struct rq *rq);

const struct cpumask *sched_trace_rd_span(struct root_domain *rd);
# 8 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/jobctl.h" 1






struct task_struct;
# 35 "/home/nathan/src/linux-next/include/linux/sched/jobctl.h"
extern bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask);
extern void task_clear_jobctl_trapping(struct task_struct *task);
extern void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask);
# 9 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/task.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/sched/task.h"
# 1 "/home/nathan/src/linux-next/include/linux/uaccess.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/uaccess.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ppc_asm.h" 1
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/extable.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/extable.h"
struct exception_table_entry {
 int insn;
 int fixup;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long extable_fixup(const struct exception_table_entry *x)
{
 return (unsigned long)&x->fixup + x->fixup;
}
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h" 1
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/kup-radix.h" 1
# 69 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/kup-radix.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kuap_restore_amr(struct pt_regs *regs, unsigned long amr)
{
 if (mmu_has_feature(0x80000000UL) && __builtin_expect(!!(regs->kuap != amr), 0)) {
  isync();
  asm volatile("mtspr " "0x1d" ",%0" : : "r" ((unsigned long)(regs->kuap)) : "memory");





 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long kuap_get_and_check_amr(void)
{
 if (mmu_has_feature(0x80000000UL)) {
  unsigned long amr = ({unsigned long rval; asm volatile("mfspr %0," "0x1d" : "=r" (rval)); rval;});
  if (0)
   ({ int __ret_warn_on = !!(amr != ((((0x4000000000000000UL))) | (((0x8000000000000000UL))))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/kup-radix.h"), "i" (87), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
  return amr;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kuap_check_amr(void)
{
 if (0 && mmu_has_feature(0x80000000UL))
  ({ int __ret_warn_on = !!(({unsigned long rval; asm volatile("mfspr %0," "0x1d" : "=r" (rval)); rval;}) != ((((0x4000000000000000UL))) | (((0x8000000000000000UL))))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/kup-radix.h"), "i" (96), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kuap(void)
{
 if (!early_mmu_has_feature(0x80000000UL))
  return 0;

 return ({unsigned long rval; asm volatile("mfspr %0," "0x1d" : "=r" (rval)); rval;});
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_kuap(unsigned long value)
{
 if (!early_mmu_has_feature(0x80000000UL))
  return;





 isync();
 asm volatile("mtspr " "0x1d" ",%0" : : "r" ((unsigned long)(value)) : "memory");
 isync();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void allow_user_access(void *to, const void *from,
           unsigned long size, unsigned long dir)
{

 do { extern void __compiletime_assert_146(void) ; if (!(!(!__builtin_constant_p(dir)))) __compiletime_assert_146(); } while (0);
 if (dir == 1)
  set_kuap((((0x8000000000000000UL))));
 else if (dir == 2)
  set_kuap((((0x4000000000000000UL))));
 else if (dir == (1 | 2))
  set_kuap(0);
 else
  do { extern void __compiletime_assert_147(void) ; if (!(!(1))) __compiletime_assert_147(); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_user_access(void *to, const void *from,
           unsigned long size, unsigned long dir)
{
 set_kuap(((((0x4000000000000000UL))) | (((0x8000000000000000UL)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long prevent_user_access_return(void)
{
 unsigned long flags = get_kuap();

 set_kuap(((((0x4000000000000000UL))) | (((0x8000000000000000UL)))));

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_user_access(unsigned long flags)
{
 set_kuap(flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
bad_kuap_fault(struct pt_regs *regs, unsigned long address, bool is_write)
{
 return ({ int __ret_warn_on = !!(mmu_has_feature(0x80000000UL) && (regs->kuap & (is_write ? (((0x8000000000000000UL))) : (((0x4000000000000000UL)))))); if (__builtin_expect(!!(__ret_warn_on), 0)) do { do { } while(0); __warn_printk("Bug: %s fault blocked by AMR!", is_write ? "Write" : "Read"); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/kup-radix.h"), "i" (166), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); do { } while(0); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });


}
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h" 2
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
# 1 "/home/nathan/src/linux-next/include/linux/pgtable.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/tlbflush.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/tlbflush.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-hash.h" 1
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"
struct ppc64_tlb_batch {
 int active;
 unsigned long index;
 struct mm_struct *mm;
 real_pte_t pte[192];
 unsigned long vpn[192];
 unsigned int psize;
 int ssize;
};
extern __attribute__((section(".data..percpu" ""))) __typeof__(struct ppc64_tlb_batch) ppc64_tlb_batch;

extern void __flush_tlb_pending(struct ppc64_tlb_batch *batch);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_enter_lazy_mmu_mode(void)
{
 struct ppc64_tlb_batch *batch;

 if (radix_enabled())
  return;
 batch = ({ do { const void *__vpp_verify = (typeof((&ppc64_tlb_batch) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch)); (typeof((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch))) (__ptr + ((local_paca->data_offset))); }); });
 batch->active = 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_leave_lazy_mmu_mode(void)
{
 struct ppc64_tlb_batch *batch;

 if (radix_enabled())
  return;
 batch = ({ do { const void *__vpp_verify = (typeof((&ppc64_tlb_batch) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch)); (typeof((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch))) (__ptr + ((local_paca->data_offset))); }); });

 if (batch->index)
  __flush_tlb_pending(batch);
 batch->active = 0;
}



extern void hash__tlbiel_all(unsigned int action);

extern void flush_hash_page(unsigned long vpn, real_pte_t pte, int psize,
       int ssize, unsigned long flags);
extern void flush_hash_range(unsigned long number, int local);
extern void flush_hash_hugepage(unsigned long vsid, unsigned long addr,
    pmd_t *pmdp, unsigned int psize, int ssize,
    unsigned long flags);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_tlb_mm(struct mm_struct *mm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_mm(struct mm_struct *mm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_all_mm(struct mm_struct *mm)
{






 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"), "i" (78), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_all_mm(struct mm_struct *mm)
{






 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"), "i" (89), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_tlb_page(struct vm_area_struct *vma,
       unsigned long vmaddr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_page(struct vm_area_struct *vma,
        unsigned long vmaddr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_range(struct vm_area_struct *vma,
         unsigned long start, unsigned long end)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_kernel_range(unsigned long start,
         unsigned long end)
{
}


struct mmu_gather;
extern void hash__tlb_flush(struct mmu_gather *tlb);

extern void __flush_hash_table_range(unsigned long start, unsigned long end);
extern void flush_tlb_pmd_range(struct mm_struct *mm, pmd_t *pmd,
    unsigned long addr);
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h" 2



enum {
 TLB_INVAL_SCOPE_GLOBAL = 0,
 TLB_INVAL_SCOPE_LPID = 1,
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlbiel_all(void)
{
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h"
 if (early_radix_enabled())
  radix__tlbiel_all(TLB_INVAL_SCOPE_GLOBAL);
 else
  hash__tlbiel_all(TLB_INVAL_SCOPE_GLOBAL);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlbiel_all_lpid(bool radix)
{



 if (radix)
  radix__tlbiel_all(TLB_INVAL_SCOPE_LPID);
 else
  hash__tlbiel_all(TLB_INVAL_SCOPE_LPID);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_pmd_tlb_range(struct vm_area_struct *vma,
           unsigned long start, unsigned long end)
{
 if (radix_enabled())
  return radix__flush_pmd_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_hugetlb_tlb_range(struct vm_area_struct *vma,
        unsigned long start,
        unsigned long end)
{
 if (radix_enabled())
  return radix__flush_hugetlb_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_range(struct vm_area_struct *vma,
       unsigned long start, unsigned long end)
{
 if (radix_enabled())
  return radix__flush_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_kernel_range(unsigned long start,
       unsigned long end)
{
 if (radix_enabled())
  return radix__flush_tlb_kernel_range(start, end);
 return hash__flush_tlb_kernel_range(start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_tlb_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__local_flush_tlb_mm(mm);
 return hash__local_flush_tlb_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_tlb_page(struct vm_area_struct *vma,
     unsigned long vmaddr)
{
 if (radix_enabled())
  return radix__local_flush_tlb_page(vma, vmaddr);
 return hash__local_flush_tlb_page(vma, vmaddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_all_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__local_flush_all_mm(mm);
 return hash__local_flush_all_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlb_flush(struct mmu_gather *tlb)
{
 if (radix_enabled())
  return radix__tlb_flush(tlb);
 return hash__tlb_flush(tlb);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__flush_tlb_mm(mm);
 return hash__flush_tlb_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_page(struct vm_area_struct *vma,
      unsigned long vmaddr)
{
 if (radix_enabled())
  return radix__flush_tlb_page(vma, vmaddr);
 return hash__flush_tlb_page(vma, vmaddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_all_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__flush_all_mm(mm);
 return hash__flush_all_mm(mm);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_fix_spurious_fault(struct vm_area_struct *vma,
      unsigned long address)
{

 if (atomic_read(&vma->vm_mm->context.copros) > 0)
  flush_tlb_page(vma, address);
}

extern bool tlbie_capable;
extern bool tlbie_enabled;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cputlb_use_tlbie(void)
{
 return tlbie_enabled;
}
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/tlbflush.h" 2
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/tlbflush.h" 2
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 2

struct mm_struct;





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h"
extern void set_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep,
         pte_t pte);



extern int ptep_set_access_flags(struct vm_area_struct *vma, unsigned long address,
     pte_t *ptep, pte_t entry, int dirty);

struct file;
extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
         unsigned long size, pgprot_t vma_prot);
# 38 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h"
void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep);
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 2
# 52 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pte_pgprot(pte_t pte)
{
 unsigned long pte_flags;

 pte_flags = pte_val(pte) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1))));
 return ((pgprot_t) { (pte_flags) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pmd_page_vaddr(pmd_t pmd)
{
 return ((unsigned long)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(pmd_val(pmd) & ~0xc0000000000000ffUL) | 0xc000000000000000UL); }));
}






extern unsigned long empty_zero_page[];


extern pgd_t swapper_pg_dir[];

extern void paging_init(void);

extern unsigned long ioremap_bot;
# 92 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
unsigned long vmalloc_to_phys(void *vmalloc_addr);

void pgtable_cache_add(unsigned int shift);

pte_t *early_pte_alloc_kernel(pmd_t *pmdp, unsigned long va);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_initmem_nx(void) { }







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pte_frag_get(mm_context_t *ctx)
{
 return ctx->pte_frag;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_frag_set(mm_context_t *ctx, void *p)
{
 ctx->pte_frag = p;
}
# 159 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_ioremap_addr(const void *x)
{
 unsigned long addr = (unsigned long)x;

 return addr >= ((__kernel_io_start + 0x80000000ul)) && addr < (__kernel_io_end);
}
# 7 "/home/nathan/src/linux-next/include/linux/pgtable.h" 2







# 1 "/home/nathan/src/linux-next/include/asm-generic/pgtable_uffd.h" 1




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int pte_uffd_wp(pte_t pte)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int pmd_uffd_wp(pmd_t pmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pte_t pte_mkuffd_wp(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pmd_t pmd_mkuffd_wp(pmd_t pmd)
{
 return pmd;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pte_t pte_clear_uffd_wp(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pmd_t pmd_clear_uffd_wp(pmd_t pmd)
{
 return pmd;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pte_t pte_swp_mkuffd_wp(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int pte_swp_uffd_wp(pte_t pte)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) pte_t pte_swp_clear_uffd_wp(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_swp_mkuffd_wp(pmd_t pmd)
{
 return pmd;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_swp_uffd_wp(pmd_t pmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_swp_clear_uffd_wp(pmd_t pmd)
{
 return pmd;
}
# 15 "/home/nathan/src/linux-next/include/linux/pgtable.h" 2
# 43 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_index(unsigned long address)
{
 return (address >> 16) & ((1 << __pte_index_size) - 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pmd_index(unsigned long address)
{
 return (address >> (16 + __pte_index_size)) & ((1 << __pmd_index_size) - 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pud_index(unsigned long address)
{
 return (address >> ((16 + __pte_index_size) + __pmd_index_size)) & ((1 << __pud_index_size) - 1);
}
# 70 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t *pte_offset_kernel(pmd_t *pmd, unsigned long address)
{
 return (pte_t *)pmd_page_vaddr(*pmd) + pte_index(address);
}
# 89 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t *pmd_offset(pud_t *pud, unsigned long address)
{
 return (pmd_t *)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(pud_val(*pud) & ~0xc0000000000000ffUL) | 0xc000000000000000UL); }) + pmd_index(address);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t *pud_offset(p4d_t *p4d, unsigned long address)
{
 return (pud_t *)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)((pgd_val((*p4d).pgd)) & ~0xc0000000000000ffUL) | 0xc000000000000000UL); }) + pud_index(address);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgd_t *pgd_offset_pgd(pgd_t *pgd, unsigned long address)
{
 return (pgd + (((address) >> (((16 + __pte_index_size) + __pmd_index_size) + __pud_index_size)) & ((1 << __pgd_index_size) - 1)));
};
# 129 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t *pmd_off(struct mm_struct *mm, unsigned long va)
{
 return pmd_offset(pud_offset(p4d_offset(pgd_offset_pgd((mm)->pgd, (va)), va), va), va);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t *pmd_off_k(unsigned long va)
{
 return pmd_offset(pud_offset(p4d_offset(pgd_offset_pgd((&init_mm)->pgd, ((va))), va), va), va);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t *virt_to_kpte(unsigned long vaddr)
{
 pmd_t *pmd = pmd_off_k(vaddr);

 return pmd_none(*pmd) ? ((void *)0) : pte_offset_kernel(pmd, vaddr);
}
# 219 "/home/nathan/src/linux-next/include/linux/pgtable.h"
int ptep_clear_flush_young(struct vm_area_struct *vma,
      unsigned long address, pte_t *ptep);




extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
      unsigned long address, pmd_t *pmdp);
# 253 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t ptep_get(pte_t *ptep)
{
 return ({ do { extern void __compiletime_assert_148(void) ; if (!((sizeof(*ptep) == sizeof(char) || sizeof(*ptep) == sizeof(short) || sizeof(*ptep) == sizeof(int) || sizeof(*ptep) == sizeof(long)) || sizeof(*ptep) == sizeof(long long))) __compiletime_assert_148(); } while (0); ({ typeof( _Generic((*ptep), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*ptep))) __x = (*(const volatile typeof( _Generic((*ptep), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*ptep))) *)&(*ptep)); do { } while (0); (typeof(*ptep))__x; }); });
}
# 271 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
         unsigned long address,
         pud_t *pudp)
{
 pud_t pud = *pudp;

 pud_clear(pudp);
 return pud;
}
# 294 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pudp_huge_get_and_clear_full(struct mm_struct *mm,
         unsigned long address, pud_t *pudp,
         int full)
{
 return pudp_huge_get_and_clear(mm, address, pudp);
}
# 324 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_mmu_tlb(struct vm_area_struct *vma,
    unsigned long address, pte_t *ptep)
{
}
# 337 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_clear_not_present_full(struct mm_struct *mm,
           unsigned long address,
           pte_t *ptep,
           int full)
{
 pte_clear(mm, address, ptep);
}



extern pte_t ptep_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pte_t *ptep);



extern pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pmd_t *pmdp);
extern pud_t pudp_huge_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pud_t *pudp);
# 379 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_sw_mkyoung(pte_t pte)
{
 return pte;
}
# 436 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pudp_set_wrprotect(struct mm_struct *mm,
          unsigned long address, pud_t *pudp)
{
 do { extern void __compiletime_assert_149(void) ; if (!(!(1))) __compiletime_assert_149(); } while (0);
}
# 475 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t generic_pmdp_establish(struct vm_area_struct *vma,
  unsigned long address, pmd_t *pmdp, pmd_t pmd)
{
 pmd_t old_pmd = *pmdp;
 set_pmd_at(vma->vm_mm, address, pmdp, pmd);
 return old_pmd;
}
# 503 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_unused(pte_t pte)
{
 return 0;
}
# 547 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_same(p4d_t p4d_a, p4d_t p4d_b)
{
 return (pgd_val((p4d_a).pgd)) == (pgd_val((p4d_b).pgd));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_same(pgd_t pgd_a, pgd_t pgd_b)
{
 return pgd_val(pgd_a) == pgd_val(pgd_b);
}
# 607 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_do_swap_page(struct mm_struct *mm,
         struct vm_area_struct *vma,
         unsigned long addr,
         pte_t pte, pte_t oldpte)
{

}
# 625 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_unmap_one(struct mm_struct *mm,
      struct vm_area_struct *vma,
      unsigned long addr,
      pte_t orig_pte)
{
 return 0;
}
# 672 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
{
 if (((oldprot).pgprot) == ((pgprot_noncached(oldprot)).pgprot))
  newprot = pgprot_noncached(newprot);
 if (((oldprot).pgprot) == ((pgprot_writecombine(oldprot)).pgprot))
  newprot = pgprot_writecombine(newprot);
 if (((oldprot).pgprot) == ((pgprot_noncached(oldprot)).pgprot))
  newprot = pgprot_noncached(newprot);
 return newprot;
}
# 721 "/home/nathan/src/linux-next/include/linux/pgtable.h"
void pgd_clear_bad(pgd_t *);
# 730 "/home/nathan/src/linux-next/include/linux/pgtable.h"
void pud_clear_bad(pud_t *);




void pmd_clear_bad(pmd_t *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_none_or_clear_bad(pgd_t *pgd)
{
 if (pgd_none(*pgd))
  return 1;
 if (__builtin_expect(!!(pgd_bad(*pgd)), 0)) {
  pgd_clear_bad(pgd);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_none_or_clear_bad(p4d_t *p4d)
{
 if (p4d_none(*p4d))
  return 1;
 if (__builtin_expect(!!(p4d_bad(*p4d)), 0)) {
  do { } while (0);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none_or_clear_bad(pud_t *pud)
{
 if (pud_none(*pud))
  return 1;
 if (__builtin_expect(!!(pud_bad(*pud)), 0)) {
  pud_clear_bad(pud);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none_or_clear_bad(pmd_t *pmd)
{
 if (pmd_none(*pmd))
  return 1;
 if (__builtin_expect(!!(pmd_bad(*pmd)), 0)) {
  pmd_clear_bad(pmd);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t __ptep_modify_prot_start(struct vm_area_struct *vma,
          unsigned long addr,
          pte_t *ptep)
{





 return ptep_get_and_clear(vma->vm_mm, addr, ptep);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ptep_modify_prot_commit(struct vm_area_struct *vma,
          unsigned long addr,
          pte_t *ptep, pte_t pte)
{




 set_pte_at(vma->vm_mm, addr, ptep, pte);
}
# 977 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int track_pfn_remap(struct vm_area_struct *vma, pgprot_t *prot,
      unsigned long pfn, unsigned long addr,
      unsigned long size)
{
 return 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void track_pfn_insert(struct vm_area_struct *vma, pgprot_t *prot,
        pfn_t pfn)
{
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int track_pfn_copy(struct vm_area_struct *vma)
{
 return 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void untrack_pfn(struct vm_area_struct *vma,
          unsigned long pfn, unsigned long size)
{
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void untrack_pfn_moved(struct vm_area_struct *vma)
{
}
# 1041 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_zero_pfn(unsigned long pfn)
{
 extern unsigned long zero_pfn;
 return pfn == zero_pfn;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long my_zero_pfn(unsigned long addr)
{
 extern unsigned long zero_pfn;
 return zero_pfn;
}
# 1096 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_trans_huge(pud_t pud)
{
 return 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none_or_trans_huge_or_dev_or_clear_bad(pud_t *pud)
{
 pud_t pudval = ({ do { extern void __compiletime_assert_150(void) ; if (!((sizeof(*pud) == sizeof(char) || sizeof(*pud) == sizeof(short) || sizeof(*pud) == sizeof(int) || sizeof(*pud) == sizeof(long)) || sizeof(*pud) == sizeof(long long))) __compiletime_assert_150(); } while (0); ({ typeof( _Generic((*pud), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*pud))) __x = (*(const volatile typeof( _Generic((*pud), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*pud))) *)&(*pud)); do { } while (0); (typeof(*pud))__x; }); });

 if (pud_none(pudval) || pud_trans_huge(pudval) || pud_devmap(pudval))
  return 1;
 if (__builtin_expect(!!(pud_bad(pudval)), 0)) {
  pud_clear_bad(pud);
  return 1;
 }
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_trans_unstable(pud_t *pud)
{




 return 0;

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_read_atomic(pmd_t *pmdp)
{





 return *pmdp;
}
# 1163 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
{
 pmd_t pmdval = pmd_read_atomic(pmd);
# 1181 "/home/nathan/src/linux-next/include/linux/pgtable.h"
 __asm__ __volatile__("" : : : "memory");
# 1198 "/home/nathan/src/linux-next/include/linux/pgtable.h"
 if (pmd_none(pmdval) || pmd_trans_huge(pmdval) ||
  (1 && !pmd_present(pmdval)))
  return 1;
 if (__builtin_expect(!!(pmd_bad(pmdval)), 0)) {
  pmd_clear_bad(pmd);
  return 1;
 }
 return 0;
}
# 1220 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_trans_unstable(pmd_t *pmd)
{

 return pmd_none_or_trans_huge_or_clear_bad(pmd);



}
# 1257 "/home/nathan/src/linux-next/include/linux/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_set_huge(p4d_t *p4d, phys_addr_t addr, pgprot_t prot)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_clear_huge(p4d_t *p4d)
{
 return 0;
}


int pud_set_huge(pud_t *pud, phys_addr_t addr, pgprot_t prot);
int pmd_set_huge(pmd_t *pmd, phys_addr_t addr, pgprot_t prot);
int pud_clear_huge(pud_t *pud);
int pmd_clear_huge(pmd_t *pmd);
int p4d_free_pud_page(p4d_t *p4d, unsigned long addr);
int pud_free_pmd_page(pud_t *pud, unsigned long addr);
int pmd_free_pte_page(pmd_t *pmd, unsigned long addr);
# 1332 "/home/nathan/src/linux-next/include/linux/pgtable.h"
struct file;
int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
   unsigned long size, pgprot_t *vma_prot);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_espfix_bsp(void) { }


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pgtable_cache_init(void);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pfn_modify_allowed(unsigned long pfn, pgprot_t prot)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_has_pfn_modify_check(void)
{
 return false;
}
# 1393 "/home/nathan/src/linux-next/include/linux/pgtable.h"
typedef unsigned int pgtbl_mod_mask;
# 43 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h" 2

void setup_kup(void);


void setup_kuep(bool disabled);





void setup_kuap(bool disabled);
# 69 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_read_from_user(const void *from, unsigned long size)
{
 allow_user_access(((void *)0), from, size, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_write_to_user(void *to, unsigned long size)
{
 allow_user_access(to, ((void *)0), size, 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_read_write_user(void *to, const void *from,
      unsigned long size)
{
 allow_user_access(to, from, size, (1 | 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_read_from_user(const void *from, unsigned long size)
{
 prevent_user_access(((void *)0), from, size, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_write_to_user(void *to, unsigned long size)
{
 prevent_user_access(to, ((void *)0), size, 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_read_write_user(void *to, const void *from,
        unsigned long size)
{
 prevent_user_access(to, from, size, (1 | 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_current_access_user(void)
{
 prevent_user_access(((void *)0), ((void *)0), ~0UL, (4 | 8));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_current_read_from_user(void)
{
 prevent_user_access(((void *)0), ((void *)0), ~0UL, 4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_current_write_to_user(void)
{
 prevent_user_access(((void *)0), ((void *)0), ~0UL, 8);
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 2
# 34 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_fs(mm_segment_t fs)
{
 get_current()->thread.addr_limit = fs;

 set_ti_thread_flag(((struct thread_info *)get_current()), 3);
}
# 153 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern long __put_user_bad(void);
# 299 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern long __get_user_bad(void);
# 436 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern unsigned long __copy_tofrom_user(void *to,
  const void *from, unsigned long size);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_in_user(void *to, const void *from, unsigned long n)
{
 unsigned long ret;

 asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
 allow_read_write_user(to, from, n);
 ret = __copy_tofrom_user(to, from, n);
 prevent_read_write_user(to, from, n);
 return ret;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long raw_copy_from_user(void *to,
  const void *from, unsigned long n)
{
 unsigned long ret;
 if (__builtin_constant_p(n) && (n <= 8)) {
  ret = 1;

  switch (n) {
  case 1:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 1); do { ret = 0; (void)0; if (1 > sizeof(*(u8 *)to)) (*(u8 *)to) = __get_user_bad(); switch (1) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u8 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 1); } while (0);
   break;
  case 2:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 2); do { ret = 0; (void)0; if (2 > sizeof(*(u16 *)to)) (*(u16 *)to) = __get_user_bad(); switch (2) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u16 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 2); } while (0);
   break;
  case 4:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 4); do { ret = 0; (void)0; if (4 > sizeof(*(u32 *)to)) (*(u32 *)to) = __get_user_bad(); switch (4) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u32 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 4); } while (0);
   break;
  case 8:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 8); do { ret = 0; (void)0; if (8 > sizeof(*(u64 *)to)) (*(u64 *)to) = __get_user_bad(); switch (8) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u64 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 8); } while (0);
   break;
  }
  if (ret == 0)
   return 0;
 }

 asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
 allow_read_from_user(from, n);
 ret = __copy_tofrom_user(( void *)to, from, n);
 prevent_read_from_user(from, n);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_to_user_allowed(void *to, const void *from, unsigned long n)
{
 if (__builtin_constant_p(n) && (n <= 8)) {
  unsigned long ret = 1;

  switch (n) {
  case 1:
   do { ret = 0; switch (1) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 2:
   do { ret = 0; switch (2) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 4:
   do { ret = 0; switch (4) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 8:
   do { ret = 0; switch (8) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  }
  if (ret == 0)
   return 0;
 }

 return __copy_tofrom_user(to, ( const void *)from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_to_user(void *to, const void *from, unsigned long n)
{
 unsigned long ret;

 allow_write_to_user(to, n);
 ret = raw_copy_to_user_allowed(to, from, n);
 prevent_write_to_user(to, n);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_to_user_mcsafe(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(from, n, true)), 1)) {
  if (((void)0, (((( unsigned long)(to)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg)))) {
   allow_write_to_user(to, n);
   n = memcpy_mcsafe((void *)to, from, n);
   prevent_write_to_user(to, n);
  }
 }

 return n;
}

unsigned long __arch_clear_user(void *addr, unsigned long size);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long clear_user(void *addr, unsigned long size)
{
 unsigned long ret = size;
 might_fault();
 if (__builtin_expect(!!(((void)0, (((( unsigned long)(addr)) <= ((get_current()->thread.addr_limit)).seg) && (((size)) <= ((get_current()->thread.addr_limit)).seg)))), 1)) {
  allow_write_to_user(addr, size);
  ret = __arch_clear_user(addr, size);
  prevent_write_to_user(addr, size);
 }
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __clear_user(void *addr, unsigned long size)
{
 return clear_user(addr, size);
}

extern long strncpy_from_user(char *dst, const char *src, long count);
extern __attribute__((__warn_unused_result__)) long strnlen_user(const char *str, long n);

extern long __copy_from_user_flushcache(void *dst, const void *src,
  unsigned size);
extern void memcpy_page_flushcache(char *to, struct page *page, size_t offset,
      size_t len);

static __attribute__((__warn_unused_result__)) inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool user_access_begin(const void *ptr, size_t len)
{
 if (__builtin_expect(!!(!((void)0, (((( unsigned long)(ptr)) <= ((get_current()->thread.addr_limit)).seg) && (((len)) <= ((get_current()->thread.addr_limit)).seg)))), 0))
  return false;
 allow_read_write_user((void *)ptr, ptr, len);
 return true;
}





static __attribute__((__warn_unused_result__)) inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
user_read_access_begin(const void *ptr, size_t len)
{
 if (__builtin_expect(!!(!((void)0, (((( unsigned long)(ptr)) <= ((get_current()->thread.addr_limit)).seg) && (((len)) <= ((get_current()->thread.addr_limit)).seg)))), 0))
  return false;
 allow_read_from_user(ptr, len);
 return true;
}



static __attribute__((__warn_unused_result__)) inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
user_write_access_begin(const void *ptr, size_t len)
{
 if (__builtin_expect(!!(!((void)0, (((( unsigned long)(ptr)) <= ((get_current()->thread.addr_limit)).seg) && (((len)) <= ((get_current()->thread.addr_limit)).seg)))), 0))
  return false;
 allow_write_to_user((void *)ptr, len);
 return true;
}
# 12 "/home/nathan/src/linux-next/include/linux/uaccess.h" 2
# 58 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user_inatomic(void *to, const void *from, unsigned long n)
{
 instrument_copy_from_user(to, from, n);
 check_object_size(to, n, false);
 return raw_copy_from_user(to, from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 instrument_copy_from_user(to, from, n);
 check_object_size(to, n, false);
 return raw_copy_from_user(to, from, n);
}
# 88 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_to_user_inatomic(void *to, const void *from, unsigned long n)
{
 instrument_copy_to_user(to, from, n);
 check_object_size(from, n, true);
 return raw_copy_to_user(to, from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_to_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 instrument_copy_to_user(to, from, n);
 check_object_size(from, n, true);
 return raw_copy_to_user(to, from, n);
}
# 120 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern __attribute__((__warn_unused_result__)) unsigned long
_copy_from_user(void *, const void *, unsigned long);
# 136 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern __attribute__((__warn_unused_result__)) unsigned long
_copy_to_user(void *, const void *, unsigned long);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_from_user(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(to, n, false)), 1))
  n = _copy_from_user(to, from, n);
 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_to_user(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(from, n, true)), 1))
  n = _copy_to_user(to, from, n);
 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_in_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 if (((void)0, (((( unsigned long)(to)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg))) && ((void)0, (((( unsigned long)(from)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg))))
  n = raw_copy_in_user(to, from, n);
 return n;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void pagefault_disabled_inc(void)
{
 get_current()->pagefault_disabled++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void pagefault_disabled_dec(void)
{
 get_current()->pagefault_disabled--;
}
# 183 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pagefault_disable(void)
{
 pagefault_disabled_inc();




 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pagefault_enable(void)
{




 __asm__ __volatile__("" : : : "memory");
 pagefault_disabled_dec();
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pagefault_disabled(void)
{
 return get_current()->pagefault_disabled != 0;
}
# 225 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user_inatomic_nocache(void *to, const void *from,
      unsigned long n)
{
 return __copy_from_user_inatomic(to, from, n);
}



extern __attribute__((__warn_unused_result__)) int check_zeroed_user(const void *from, size_t size);
# 283 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) int
copy_struct_from_user(void *dst, size_t ksize, const void *src,
        size_t usize)
{
 size_t size = __builtin_choose_expr(((!!(sizeof((typeof(ksize) *)1 == (typeof(usize) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(ksize) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(usize) * 0l)) : (int *)8))))), ((ksize) < (usize) ? (ksize) : (usize)), ({ typeof(ksize) __UNIQUE_ID___x151 = (ksize); typeof(usize) __UNIQUE_ID___y152 = (usize); ((__UNIQUE_ID___x151) < (__UNIQUE_ID___y152) ? (__UNIQUE_ID___x151) : (__UNIQUE_ID___y152)); }));
 size_t rest = __builtin_choose_expr(((!!(sizeof((typeof(ksize) *)1 == (typeof(usize) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(ksize) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(usize) * 0l)) : (int *)8))))), ((ksize) > (usize) ? (ksize) : (usize)), ({ typeof(ksize) __UNIQUE_ID___x153 = (ksize); typeof(usize) __UNIQUE_ID___y154 = (usize); ((__UNIQUE_ID___x153) > (__UNIQUE_ID___y154) ? (__UNIQUE_ID___x153) : (__UNIQUE_ID___y154)); })) - size;


 if (usize < ksize) {
  memset(dst + size, 0, rest);
 } else if (usize > ksize) {
  int ret = check_zeroed_user(src + size, rest);
  if (ret <= 0)
   return ret ?: -7;
 }

 if (copy_from_user(dst, src, size))
  return -14;
 return 0;
}

bool probe_kernel_read_allowed(const void *unsafe_src, size_t size);

extern long probe_kernel_read(void *dst, const void *src, size_t size);
extern long probe_user_read(void *dst, const void *src, size_t size);

extern long __attribute__((__no_instrument_function__)) probe_kernel_write(void *dst, const void *src, size_t size);
extern long __attribute__((__no_instrument_function__)) probe_user_write(void *dst, const void *src, size_t size);

long strncpy_from_kernel_nofault(char *dst, const void *unsafe_addr,
  long count);

long strncpy_from_user_nofault(char *dst, const void *unsafe_addr,
  long count);
long strnlen_user_nofault(const void *unsafe_addr, long count);
# 349 "/home/nathan/src/linux-next/include/linux/uaccess.h"
void usercopy_warn(const char *name, const char *detail, bool to_user,
     unsigned long offset, unsigned long len);
void __attribute__((__noreturn__)) usercopy_abort(const char *name, const char *detail,
          bool to_user, unsigned long offset,
          unsigned long len);
# 12 "/home/nathan/src/linux-next/include/linux/sched/task.h" 2

struct task_struct;
struct rusage;
union thread_union;
struct css_set;




struct kernel_clone_args {
 u64 flags;
 int *pidfd;
 int *child_tid;
 int *parent_tid;
 int exit_signal;
 unsigned long stack;
 unsigned long stack_size;
 unsigned long tls;
 pid_t *set_tid;

 size_t set_tid_size;
 int cgroup;
 struct cgroup *cgrp;
 struct css_set *cset;
};







extern rwlock_t tasklist_lock;
extern spinlock_t mmlist_lock;

extern union thread_union init_thread_union;
extern struct task_struct init_task;





extern void schedule_tail(struct task_struct *prev);
extern void init_idle(struct task_struct *idle, int cpu);

extern int sched_fork(unsigned long clone_flags, struct task_struct *p);
extern void sched_dead(struct task_struct *p);

void __attribute__((__noreturn__)) do_task_dead(void);

extern void proc_caches_init(void);

extern void fork_init(void);

extern void release_task(struct task_struct * p);


extern int copy_thread_tls(unsigned long, unsigned long, unsigned long,
   struct task_struct *, unsigned long);
# 84 "/home/nathan/src/linux-next/include/linux/sched/task.h"
extern void flush_thread(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_thread(struct task_struct *tsk)
{
}

extern void do_group_exit(int);

extern void exit_files(struct task_struct *);
extern void exit_itimers(struct signal_struct *);

extern long _do_fork(struct kernel_clone_args *kargs);
extern bool legacy_clone_args_valid(const struct kernel_clone_args *kargs);
extern long do_fork(unsigned long, unsigned long, unsigned long, int *, int *);
struct task_struct *fork_idle(int);
struct mm_struct *copy_init_mm(void);
extern pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
extern long kernel_wait4(pid_t, int *, int, struct rusage *);

extern void free_task(struct task_struct *tsk);



extern void sched_exec(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *get_task_struct(struct task_struct *t)
{
 refcount_inc(&t->usage);
 return t;
}

extern void __put_task_struct(struct task_struct *t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_task_struct(struct task_struct *t)
{
 if (refcount_dec_and_test(&t->usage))
  __put_task_struct(t);
}

void put_task_struct_rcu_user(struct task_struct *task);
# 142 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_thread_struct_whitelist(unsigned long *offset,
      unsigned long *size)
{
 *offset = 0;

 *size = (sizeof(struct task_struct)) - __builtin_offsetof(struct task_struct, thread);
}
# 157 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vm_struct *task_stack_vm_area(const struct task_struct *t)
{
 return ((void *)0);
}
# 173 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_lock(struct task_struct *p)
{
 spin_lock(&p->alloc_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_unlock(struct task_struct *p)
{
 spin_unlock(&p->alloc_lock);
}
# 10 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/cred.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/cred.h"
# 1 "/home/nathan/src/linux-next/include/linux/key.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/key.h"
# 1 "/home/nathan/src/linux-next/include/linux/sysctl.h" 1
# 30 "/home/nathan/src/linux-next/include/linux/sysctl.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/sysctl.h" 1
# 35 "/home/nathan/src/linux-next/include/uapi/linux/sysctl.h"
struct __sysctl_args {
 int *name;
 int nlen;
 void *oldval;
 size_t *oldlenp;
 void *newval;
 size_t newlen;
 unsigned long __unused[4];
};





enum
{
 CTL_KERN=1,
 CTL_VM=2,
 CTL_NET=3,
 CTL_PROC=4,
 CTL_FS=5,
 CTL_DEBUG=6,
 CTL_DEV=7,
 CTL_BUS=8,
 CTL_ABI=9,
 CTL_CPU=10,
 CTL_ARLAN=254,
 CTL_S390DBF=5677,
 CTL_SUNRPC=7249,
 CTL_PM=9899,
 CTL_FRV=9898,
};


enum
{
 CTL_BUS_ISA=1
};


enum
{
 INOTIFY_MAX_USER_INSTANCES=1,
 INOTIFY_MAX_USER_WATCHES=2,
 INOTIFY_MAX_QUEUED_EVENTS=3
};


enum
{
 KERN_OSTYPE=1,
 KERN_OSRELEASE=2,
 KERN_OSREV=3,
 KERN_VERSION=4,
 KERN_SECUREMASK=5,
 KERN_PROF=6,
 KERN_NODENAME=7,
 KERN_DOMAINNAME=8,

 KERN_PANIC=15,
 KERN_REALROOTDEV=16,

 KERN_SPARC_REBOOT=21,
 KERN_CTLALTDEL=22,
 KERN_PRINTK=23,
 KERN_NAMETRANS=24,
 KERN_PPC_HTABRECLAIM=25,
 KERN_PPC_ZEROPAGED=26,
 KERN_PPC_POWERSAVE_NAP=27,
 KERN_MODPROBE=28,
 KERN_SG_BIG_BUFF=29,
 KERN_ACCT=30,
 KERN_PPC_L2CR=31,

 KERN_RTSIGNR=32,
 KERN_RTSIGMAX=33,

 KERN_SHMMAX=34,
 KERN_MSGMAX=35,
 KERN_MSGMNB=36,
 KERN_MSGPOOL=37,
 KERN_SYSRQ=38,
 KERN_MAX_THREADS=39,
  KERN_RANDOM=40,
  KERN_SHMALL=41,
  KERN_MSGMNI=42,
  KERN_SEM=43,
  KERN_SPARC_STOP_A=44,
  KERN_SHMMNI=45,
 KERN_OVERFLOWUID=46,
 KERN_OVERFLOWGID=47,
 KERN_SHMPATH=48,
 KERN_HOTPLUG=49,
 KERN_IEEE_EMULATION_WARNINGS=50,
 KERN_S390_USER_DEBUG_LOGGING=51,
 KERN_CORE_USES_PID=52,
 KERN_TAINTED=53,
 KERN_CADPID=54,
 KERN_PIDMAX=55,
   KERN_CORE_PATTERN=56,
 KERN_PANIC_ON_OOPS=57,
 KERN_HPPA_PWRSW=58,
 KERN_HPPA_UNALIGNED=59,
 KERN_PRINTK_RATELIMIT=60,
 KERN_PRINTK_RATELIMIT_BURST=61,
 KERN_PTY=62,
 KERN_NGROUPS_MAX=63,
 KERN_SPARC_SCONS_PWROFF=64,
 KERN_HZ_TIMER=65,
 KERN_UNKNOWN_NMI_PANIC=66,
 KERN_BOOTLOADER_TYPE=67,
 KERN_RANDOMIZE=68,
 KERN_SETUID_DUMPABLE=69,
 KERN_SPIN_RETRY=70,
 KERN_ACPI_VIDEO_FLAGS=71,
 KERN_IA64_UNALIGNED=72,
 KERN_COMPAT_LOG=73,
 KERN_MAX_LOCK_DEPTH=74,
 KERN_NMI_WATCHDOG=75,
 KERN_PANIC_ON_NMI=76,
 KERN_PANIC_ON_WARN=77,
 KERN_PANIC_PRINT=78,
};




enum
{
 VM_UNUSED1=1,
 VM_UNUSED2=2,
 VM_UNUSED3=3,
 VM_UNUSED4=4,
 VM_OVERCOMMIT_MEMORY=5,
 VM_UNUSED5=6,
 VM_UNUSED7=7,
 VM_UNUSED8=8,
 VM_UNUSED9=9,
 VM_PAGE_CLUSTER=10,
 VM_DIRTY_BACKGROUND=11,
 VM_DIRTY_RATIO=12,
 VM_DIRTY_WB_CS=13,
 VM_DIRTY_EXPIRE_CS=14,
 VM_NR_PDFLUSH_THREADS=15,
 VM_OVERCOMMIT_RATIO=16,
 VM_PAGEBUF=17,
 VM_HUGETLB_PAGES=18,
 VM_SWAPPINESS=19,
 VM_LOWMEM_RESERVE_RATIO=20,
 VM_MIN_FREE_KBYTES=21,
 VM_MAX_MAP_COUNT=22,
 VM_LAPTOP_MODE=23,
 VM_BLOCK_DUMP=24,
 VM_HUGETLB_GROUP=25,
 VM_VFS_CACHE_PRESSURE=26,
 VM_LEGACY_VA_LAYOUT=27,
 VM_SWAP_TOKEN_TIMEOUT=28,
 VM_DROP_PAGECACHE=29,
 VM_PERCPU_PAGELIST_FRACTION=30,
 VM_ZONE_RECLAIM_MODE=31,
 VM_MIN_UNMAPPED=32,
 VM_PANIC_ON_OOM=33,
 VM_VDSO_ENABLED=34,
 VM_MIN_SLAB=35,
};



enum
{
 NET_CORE=1,
 NET_ETHER=2,
 NET_802=3,
 NET_UNIX=4,
 NET_IPV4=5,
 NET_IPX=6,
 NET_ATALK=7,
 NET_NETROM=8,
 NET_AX25=9,
 NET_BRIDGE=10,
 NET_ROSE=11,
 NET_IPV6=12,
 NET_X25=13,
 NET_TR=14,
 NET_DECNET=15,
 NET_ECONET=16,
 NET_SCTP=17,
 NET_LLC=18,
 NET_NETFILTER=19,
 NET_DCCP=20,
 NET_IRDA=412,
};


enum
{
 RANDOM_POOLSIZE=1,
 RANDOM_ENTROPY_COUNT=2,
 RANDOM_READ_THRESH=3,
 RANDOM_WRITE_THRESH=4,
 RANDOM_BOOT_ID=5,
 RANDOM_UUID=6
};


enum
{
 PTY_MAX=1,
 PTY_NR=2
};


enum
{
 BUS_ISA_MEM_BASE=1,
 BUS_ISA_PORT_BASE=2,
 BUS_ISA_PORT_SHIFT=3
};


enum
{
 NET_CORE_WMEM_MAX=1,
 NET_CORE_RMEM_MAX=2,
 NET_CORE_WMEM_DEFAULT=3,
 NET_CORE_RMEM_DEFAULT=4,

 NET_CORE_MAX_BACKLOG=6,
 NET_CORE_FASTROUTE=7,
 NET_CORE_MSG_COST=8,
 NET_CORE_MSG_BURST=9,
 NET_CORE_OPTMEM_MAX=10,
 NET_CORE_HOT_LIST_LENGTH=11,
 NET_CORE_DIVERT_VERSION=12,
 NET_CORE_NO_CONG_THRESH=13,
 NET_CORE_NO_CONG=14,
 NET_CORE_LO_CONG=15,
 NET_CORE_MOD_CONG=16,
 NET_CORE_DEV_WEIGHT=17,
 NET_CORE_SOMAXCONN=18,
 NET_CORE_BUDGET=19,
 NET_CORE_AEVENT_ETIME=20,
 NET_CORE_AEVENT_RSEQTH=21,
 NET_CORE_WARNINGS=22,
};







enum
{
 NET_UNIX_DESTROY_DELAY=1,
 NET_UNIX_DELETE_DELAY=2,
 NET_UNIX_MAX_DGRAM_QLEN=3,
};


enum
{
 NET_NF_CONNTRACK_MAX=1,
 NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
 NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
 NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
 NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
 NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
 NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
 NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
 NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
 NET_NF_CONNTRACK_UDP_TIMEOUT=10,
 NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
 NET_NF_CONNTRACK_ICMP_TIMEOUT=12,
 NET_NF_CONNTRACK_GENERIC_TIMEOUT=13,
 NET_NF_CONNTRACK_BUCKETS=14,
 NET_NF_CONNTRACK_LOG_INVALID=15,
 NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
 NET_NF_CONNTRACK_TCP_LOOSE=17,
 NET_NF_CONNTRACK_TCP_BE_LIBERAL=18,
 NET_NF_CONNTRACK_TCP_MAX_RETRANS=19,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
 NET_NF_CONNTRACK_COUNT=27,
 NET_NF_CONNTRACK_ICMPV6_TIMEOUT=28,
 NET_NF_CONNTRACK_FRAG6_TIMEOUT=29,
 NET_NF_CONNTRACK_FRAG6_LOW_THRESH=30,
 NET_NF_CONNTRACK_FRAG6_HIGH_THRESH=31,
 NET_NF_CONNTRACK_CHECKSUM=32,
};


enum
{

 NET_IPV4_FORWARD=8,
 NET_IPV4_DYNADDR=9,

 NET_IPV4_CONF=16,
 NET_IPV4_NEIGH=17,
 NET_IPV4_ROUTE=18,
 NET_IPV4_FIB_HASH=19,
 NET_IPV4_NETFILTER=20,

 NET_IPV4_TCP_TIMESTAMPS=33,
 NET_IPV4_TCP_WINDOW_SCALING=34,
 NET_IPV4_TCP_SACK=35,
 NET_IPV4_TCP_RETRANS_COLLAPSE=36,
 NET_IPV4_DEFAULT_TTL=37,
 NET_IPV4_AUTOCONFIG=38,
 NET_IPV4_NO_PMTU_DISC=39,
 NET_IPV4_TCP_SYN_RETRIES=40,
 NET_IPV4_IPFRAG_HIGH_THRESH=41,
 NET_IPV4_IPFRAG_LOW_THRESH=42,
 NET_IPV4_IPFRAG_TIME=43,
 NET_IPV4_TCP_MAX_KA_PROBES=44,
 NET_IPV4_TCP_KEEPALIVE_TIME=45,
 NET_IPV4_TCP_KEEPALIVE_PROBES=46,
 NET_IPV4_TCP_RETRIES1=47,
 NET_IPV4_TCP_RETRIES2=48,
 NET_IPV4_TCP_FIN_TIMEOUT=49,
 NET_IPV4_IP_MASQ_DEBUG=50,
 NET_TCP_SYNCOOKIES=51,
 NET_TCP_STDURG=52,
 NET_TCP_RFC1337=53,
 NET_TCP_SYN_TAILDROP=54,
 NET_TCP_MAX_SYN_BACKLOG=55,
 NET_IPV4_LOCAL_PORT_RANGE=56,
 NET_IPV4_ICMP_ECHO_IGNORE_ALL=57,
 NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS=58,
 NET_IPV4_ICMP_SOURCEQUENCH_RATE=59,
 NET_IPV4_ICMP_DESTUNREACH_RATE=60,
 NET_IPV4_ICMP_TIMEEXCEED_RATE=61,
 NET_IPV4_ICMP_PARAMPROB_RATE=62,
 NET_IPV4_ICMP_ECHOREPLY_RATE=63,
 NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES=64,
 NET_IPV4_IGMP_MAX_MEMBERSHIPS=65,
 NET_TCP_TW_RECYCLE=66,
 NET_IPV4_ALWAYS_DEFRAG=67,
 NET_IPV4_TCP_KEEPALIVE_INTVL=68,
 NET_IPV4_INET_PEER_THRESHOLD=69,
 NET_IPV4_INET_PEER_MINTTL=70,
 NET_IPV4_INET_PEER_MAXTTL=71,
 NET_IPV4_INET_PEER_GC_MINTIME=72,
 NET_IPV4_INET_PEER_GC_MAXTIME=73,
 NET_TCP_ORPHAN_RETRIES=74,
 NET_TCP_ABORT_ON_OVERFLOW=75,
 NET_TCP_SYNACK_RETRIES=76,
 NET_TCP_MAX_ORPHANS=77,
 NET_TCP_MAX_TW_BUCKETS=78,
 NET_TCP_FACK=79,
 NET_TCP_REORDERING=80,
 NET_TCP_ECN=81,
 NET_TCP_DSACK=82,
 NET_TCP_MEM=83,
 NET_TCP_WMEM=84,
 NET_TCP_RMEM=85,
 NET_TCP_APP_WIN=86,
 NET_TCP_ADV_WIN_SCALE=87,
 NET_IPV4_NONLOCAL_BIND=88,
 NET_IPV4_ICMP_RATELIMIT=89,
 NET_IPV4_ICMP_RATEMASK=90,
 NET_TCP_TW_REUSE=91,
 NET_TCP_FRTO=92,
 NET_TCP_LOW_LATENCY=93,
 NET_IPV4_IPFRAG_SECRET_INTERVAL=94,
 NET_IPV4_IGMP_MAX_MSF=96,
 NET_TCP_NO_METRICS_SAVE=97,
 NET_TCP_DEFAULT_WIN_SCALE=105,
 NET_TCP_MODERATE_RCVBUF=106,
 NET_TCP_TSO_WIN_DIVISOR=107,
 NET_TCP_BIC_BETA=108,
 NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR=109,
 NET_TCP_CONG_CONTROL=110,
 NET_TCP_ABC=111,
 NET_IPV4_IPFRAG_MAX_DIST=112,
  NET_TCP_MTU_PROBING=113,
 NET_TCP_BASE_MSS=114,
 NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS=115,
 NET_TCP_DMA_COPYBREAK=116,
 NET_TCP_SLOW_START_AFTER_IDLE=117,
 NET_CIPSOV4_CACHE_ENABLE=118,
 NET_CIPSOV4_CACHE_BUCKET_SIZE=119,
 NET_CIPSOV4_RBM_OPTFMT=120,
 NET_CIPSOV4_RBM_STRICTVALID=121,
 NET_TCP_AVAIL_CONG_CONTROL=122,
 NET_TCP_ALLOWED_CONG_CONTROL=123,
 NET_TCP_MAX_SSTHRESH=124,
 NET_TCP_FRTO_RESPONSE=125,
};

enum {
 NET_IPV4_ROUTE_FLUSH=1,
 NET_IPV4_ROUTE_MIN_DELAY=2,
 NET_IPV4_ROUTE_MAX_DELAY=3,
 NET_IPV4_ROUTE_GC_THRESH=4,
 NET_IPV4_ROUTE_MAX_SIZE=5,
 NET_IPV4_ROUTE_GC_MIN_INTERVAL=6,
 NET_IPV4_ROUTE_GC_TIMEOUT=7,
 NET_IPV4_ROUTE_GC_INTERVAL=8,
 NET_IPV4_ROUTE_REDIRECT_LOAD=9,
 NET_IPV4_ROUTE_REDIRECT_NUMBER=10,
 NET_IPV4_ROUTE_REDIRECT_SILENCE=11,
 NET_IPV4_ROUTE_ERROR_COST=12,
 NET_IPV4_ROUTE_ERROR_BURST=13,
 NET_IPV4_ROUTE_GC_ELASTICITY=14,
 NET_IPV4_ROUTE_MTU_EXPIRES=15,
 NET_IPV4_ROUTE_MIN_PMTU=16,
 NET_IPV4_ROUTE_MIN_ADVMSS=17,
 NET_IPV4_ROUTE_SECRET_INTERVAL=18,
 NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS=19,
};

enum
{
 NET_PROTO_CONF_ALL=-2,
 NET_PROTO_CONF_DEFAULT=-3


};

enum
{
 NET_IPV4_CONF_FORWARDING=1,
 NET_IPV4_CONF_MC_FORWARDING=2,
 NET_IPV4_CONF_PROXY_ARP=3,
 NET_IPV4_CONF_ACCEPT_REDIRECTS=4,
 NET_IPV4_CONF_SECURE_REDIRECTS=5,
 NET_IPV4_CONF_SEND_REDIRECTS=6,
 NET_IPV4_CONF_SHARED_MEDIA=7,
 NET_IPV4_CONF_RP_FILTER=8,
 NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE=9,
 NET_IPV4_CONF_BOOTP_RELAY=10,
 NET_IPV4_CONF_LOG_MARTIANS=11,
 NET_IPV4_CONF_TAG=12,
 NET_IPV4_CONF_ARPFILTER=13,
 NET_IPV4_CONF_MEDIUM_ID=14,
 NET_IPV4_CONF_NOXFRM=15,
 NET_IPV4_CONF_NOPOLICY=16,
 NET_IPV4_CONF_FORCE_IGMP_VERSION=17,
 NET_IPV4_CONF_ARP_ANNOUNCE=18,
 NET_IPV4_CONF_ARP_IGNORE=19,
 NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
 NET_IPV4_CONF_ARP_ACCEPT=21,
 NET_IPV4_CONF_ARP_NOTIFY=22,
};


enum
{
 NET_IPV4_NF_CONNTRACK_MAX=1,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
 NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT=10,
 NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
 NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT=12,
 NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT=13,
 NET_IPV4_NF_CONNTRACK_BUCKETS=14,
 NET_IPV4_NF_CONNTRACK_LOG_INVALID=15,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
 NET_IPV4_NF_CONNTRACK_TCP_LOOSE=17,
 NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL=18,
 NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS=19,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
 NET_IPV4_NF_CONNTRACK_COUNT=27,
 NET_IPV4_NF_CONNTRACK_CHECKSUM=28,
};


enum {
 NET_IPV6_CONF=16,
 NET_IPV6_NEIGH=17,
 NET_IPV6_ROUTE=18,
 NET_IPV6_ICMP=19,
 NET_IPV6_BINDV6ONLY=20,
 NET_IPV6_IP6FRAG_HIGH_THRESH=21,
 NET_IPV6_IP6FRAG_LOW_THRESH=22,
 NET_IPV6_IP6FRAG_TIME=23,
 NET_IPV6_IP6FRAG_SECRET_INTERVAL=24,
 NET_IPV6_MLD_MAX_MSF=25,
};

enum {
 NET_IPV6_ROUTE_FLUSH=1,
 NET_IPV6_ROUTE_GC_THRESH=2,
 NET_IPV6_ROUTE_MAX_SIZE=3,
 NET_IPV6_ROUTE_GC_MIN_INTERVAL=4,
 NET_IPV6_ROUTE_GC_TIMEOUT=5,
 NET_IPV6_ROUTE_GC_INTERVAL=6,
 NET_IPV6_ROUTE_GC_ELASTICITY=7,
 NET_IPV6_ROUTE_MTU_EXPIRES=8,
 NET_IPV6_ROUTE_MIN_ADVMSS=9,
 NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS=10
};

enum {
 NET_IPV6_FORWARDING=1,
 NET_IPV6_HOP_LIMIT=2,
 NET_IPV6_MTU=3,
 NET_IPV6_ACCEPT_RA=4,
 NET_IPV6_ACCEPT_REDIRECTS=5,
 NET_IPV6_AUTOCONF=6,
 NET_IPV6_DAD_TRANSMITS=7,
 NET_IPV6_RTR_SOLICITS=8,
 NET_IPV6_RTR_SOLICIT_INTERVAL=9,
 NET_IPV6_RTR_SOLICIT_DELAY=10,
 NET_IPV6_USE_TEMPADDR=11,
 NET_IPV6_TEMP_VALID_LFT=12,
 NET_IPV6_TEMP_PREFERED_LFT=13,
 NET_IPV6_REGEN_MAX_RETRY=14,
 NET_IPV6_MAX_DESYNC_FACTOR=15,
 NET_IPV6_MAX_ADDRESSES=16,
 NET_IPV6_FORCE_MLD_VERSION=17,
 NET_IPV6_ACCEPT_RA_DEFRTR=18,
 NET_IPV6_ACCEPT_RA_PINFO=19,
 NET_IPV6_ACCEPT_RA_RTR_PREF=20,
 NET_IPV6_RTR_PROBE_INTERVAL=21,
 NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
 NET_IPV6_PROXY_NDP=23,
 NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
 NET_IPV6_ACCEPT_RA_FROM_LOCAL=26,
 NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN=27,
 __NET_IPV6_MAX
};


enum {
 NET_IPV6_ICMP_RATELIMIT = 1,
 NET_IPV6_ICMP_ECHO_IGNORE_ALL = 2
};


enum {
 NET_NEIGH_MCAST_SOLICIT=1,
 NET_NEIGH_UCAST_SOLICIT=2,
 NET_NEIGH_APP_SOLICIT=3,
 NET_NEIGH_RETRANS_TIME=4,
 NET_NEIGH_REACHABLE_TIME=5,
 NET_NEIGH_DELAY_PROBE_TIME=6,
 NET_NEIGH_GC_STALE_TIME=7,
 NET_NEIGH_UNRES_QLEN=8,
 NET_NEIGH_PROXY_QLEN=9,
 NET_NEIGH_ANYCAST_DELAY=10,
 NET_NEIGH_PROXY_DELAY=11,
 NET_NEIGH_LOCKTIME=12,
 NET_NEIGH_GC_INTERVAL=13,
 NET_NEIGH_GC_THRESH1=14,
 NET_NEIGH_GC_THRESH2=15,
 NET_NEIGH_GC_THRESH3=16,
 NET_NEIGH_RETRANS_TIME_MS=17,
 NET_NEIGH_REACHABLE_TIME_MS=18,
};


enum {
 NET_DCCP_DEFAULT=1,
};


enum {
 NET_IPX_PPROP_BROADCASTING=1,
 NET_IPX_FORWARDING=2
};


enum {
 NET_LLC2=1,
 NET_LLC_STATION=2,
};


enum {
 NET_LLC2_TIMEOUT=1,
};


enum {
 NET_LLC_STATION_ACK_TIMEOUT=1,
};


enum {
 NET_LLC2_ACK_TIMEOUT=1,
 NET_LLC2_P_TIMEOUT=2,
 NET_LLC2_REJ_TIMEOUT=3,
 NET_LLC2_BUSY_TIMEOUT=4,
};


enum {
 NET_ATALK_AARP_EXPIRY_TIME=1,
 NET_ATALK_AARP_TICK_TIME=2,
 NET_ATALK_AARP_RETRANSMIT_LIMIT=3,
 NET_ATALK_AARP_RESOLVE_TIME=4
};



enum {
 NET_NETROM_DEFAULT_PATH_QUALITY=1,
 NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER=2,
 NET_NETROM_NETWORK_TTL_INITIALISER=3,
 NET_NETROM_TRANSPORT_TIMEOUT=4,
 NET_NETROM_TRANSPORT_MAXIMUM_TRIES=5,
 NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY=6,
 NET_NETROM_TRANSPORT_BUSY_DELAY=7,
 NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE=8,
 NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT=9,
 NET_NETROM_ROUTING_CONTROL=10,
 NET_NETROM_LINK_FAILS_COUNT=11,
 NET_NETROM_RESET=12
};


enum {
 NET_AX25_IP_DEFAULT_MODE=1,
 NET_AX25_DEFAULT_MODE=2,
 NET_AX25_BACKOFF_TYPE=3,
 NET_AX25_CONNECT_MODE=4,
 NET_AX25_STANDARD_WINDOW=5,
 NET_AX25_EXTENDED_WINDOW=6,
 NET_AX25_T1_TIMEOUT=7,
 NET_AX25_T2_TIMEOUT=8,
 NET_AX25_T3_TIMEOUT=9,
 NET_AX25_IDLE_TIMEOUT=10,
 NET_AX25_N2=11,
 NET_AX25_PACLEN=12,
 NET_AX25_PROTOCOL=13,
 NET_AX25_DAMA_SLAVE_TIMEOUT=14
};


enum {
 NET_ROSE_RESTART_REQUEST_TIMEOUT=1,
 NET_ROSE_CALL_REQUEST_TIMEOUT=2,
 NET_ROSE_RESET_REQUEST_TIMEOUT=3,
 NET_ROSE_CLEAR_REQUEST_TIMEOUT=4,
 NET_ROSE_ACK_HOLD_BACK_TIMEOUT=5,
 NET_ROSE_ROUTING_CONTROL=6,
 NET_ROSE_LINK_FAIL_TIMEOUT=7,
 NET_ROSE_MAX_VCS=8,
 NET_ROSE_WINDOW_SIZE=9,
 NET_ROSE_NO_ACTIVITY_TIMEOUT=10
};


enum {
 NET_X25_RESTART_REQUEST_TIMEOUT=1,
 NET_X25_CALL_REQUEST_TIMEOUT=2,
 NET_X25_RESET_REQUEST_TIMEOUT=3,
 NET_X25_CLEAR_REQUEST_TIMEOUT=4,
 NET_X25_ACK_HOLD_BACK_TIMEOUT=5,
 NET_X25_FORWARD=6
};


enum
{
 NET_TR_RIF_TIMEOUT=1
};


enum {
 NET_DECNET_NODE_TYPE = 1,
 NET_DECNET_NODE_ADDRESS = 2,
 NET_DECNET_NODE_NAME = 3,
 NET_DECNET_DEFAULT_DEVICE = 4,
 NET_DECNET_TIME_WAIT = 5,
 NET_DECNET_DN_COUNT = 6,
 NET_DECNET_DI_COUNT = 7,
 NET_DECNET_DR_COUNT = 8,
 NET_DECNET_DST_GC_INTERVAL = 9,
 NET_DECNET_CONF = 10,
 NET_DECNET_NO_FC_MAX_CWND = 11,
 NET_DECNET_MEM = 12,
 NET_DECNET_RMEM = 13,
 NET_DECNET_WMEM = 14,
 NET_DECNET_DEBUG_LEVEL = 255
};


enum {
 NET_DECNET_CONF_LOOPBACK = -2,
 NET_DECNET_CONF_DDCMP = -3,
 NET_DECNET_CONF_PPP = -4,
 NET_DECNET_CONF_X25 = -5,
 NET_DECNET_CONF_GRE = -6,
 NET_DECNET_CONF_ETHER = -7


};


enum {
 NET_DECNET_CONF_DEV_PRIORITY = 1,
 NET_DECNET_CONF_DEV_T1 = 2,
 NET_DECNET_CONF_DEV_T2 = 3,
 NET_DECNET_CONF_DEV_T3 = 4,
 NET_DECNET_CONF_DEV_FORWARDING = 5,
 NET_DECNET_CONF_DEV_BLKSIZE = 6,
 NET_DECNET_CONF_DEV_STATE = 7
};


enum {
 NET_SCTP_RTO_INITIAL = 1,
 NET_SCTP_RTO_MIN = 2,
 NET_SCTP_RTO_MAX = 3,
 NET_SCTP_RTO_ALPHA = 4,
 NET_SCTP_RTO_BETA = 5,
 NET_SCTP_VALID_COOKIE_LIFE = 6,
 NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
 NET_SCTP_PATH_MAX_RETRANS = 8,
 NET_SCTP_MAX_INIT_RETRANSMITS = 9,
 NET_SCTP_HB_INTERVAL = 10,
 NET_SCTP_PRESERVE_ENABLE = 11,
 NET_SCTP_MAX_BURST = 12,
 NET_SCTP_ADDIP_ENABLE = 13,
 NET_SCTP_PRSCTP_ENABLE = 14,
 NET_SCTP_SNDBUF_POLICY = 15,
 NET_SCTP_SACK_TIMEOUT = 16,
 NET_SCTP_RCVBUF_POLICY = 17,
};


enum {
 NET_BRIDGE_NF_CALL_ARPTABLES = 1,
 NET_BRIDGE_NF_CALL_IPTABLES = 2,
 NET_BRIDGE_NF_CALL_IP6TABLES = 3,
 NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
 NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
};



enum
{
 FS_NRINODE=1,
 FS_STATINODE=2,
 FS_MAXINODE=3,
 FS_NRDQUOT=4,
 FS_MAXDQUOT=5,
 FS_NRFILE=6,
 FS_MAXFILE=7,
 FS_DENTRY=8,
 FS_NRSUPER=9,
 FS_MAXSUPER=10,
 FS_OVERFLOWUID=11,
 FS_OVERFLOWGID=12,
 FS_LEASES=13,
 FS_DIR_NOTIFY=14,
 FS_LEASE_TIME=15,
 FS_DQSTATS=16,
 FS_XFS=17,
 FS_AIO_NR=18,
 FS_AIO_MAX_NR=19,
 FS_INOTIFY=20,
 FS_OCFS2=988,
};


enum {
 FS_DQ_LOOKUPS = 1,
 FS_DQ_DROPS = 2,
 FS_DQ_READS = 3,
 FS_DQ_WRITES = 4,
 FS_DQ_CACHE_HITS = 5,
 FS_DQ_ALLOCATED = 6,
 FS_DQ_FREE = 7,
 FS_DQ_SYNCS = 8,
 FS_DQ_WARNINGS = 9,
};




enum {
 DEV_CDROM=1,
 DEV_HWMON=2,
 DEV_PARPORT=3,
 DEV_RAID=4,
 DEV_MAC_HID=5,
 DEV_SCSI=6,
 DEV_IPMI=7,
};


enum {
 DEV_CDROM_INFO=1,
 DEV_CDROM_AUTOCLOSE=2,
 DEV_CDROM_AUTOEJECT=3,
 DEV_CDROM_DEBUG=4,
 DEV_CDROM_LOCK=5,
 DEV_CDROM_CHECK_MEDIA=6
};


enum {
 DEV_PARPORT_DEFAULT=-3
};


enum {
 DEV_RAID_SPEED_LIMIT_MIN=1,
 DEV_RAID_SPEED_LIMIT_MAX=2
};


enum {
 DEV_PARPORT_DEFAULT_TIMESLICE=1,
 DEV_PARPORT_DEFAULT_SPINTIME=2
};


enum {
 DEV_PARPORT_SPINTIME=1,
 DEV_PARPORT_BASE_ADDR=2,
 DEV_PARPORT_IRQ=3,
 DEV_PARPORT_DMA=4,
 DEV_PARPORT_MODES=5,
 DEV_PARPORT_DEVICES=6,
 DEV_PARPORT_AUTOPROBE=16
};


enum {
 DEV_PARPORT_DEVICES_ACTIVE=-3,
};


enum {
 DEV_PARPORT_DEVICE_TIMESLICE=1,
};


enum {
 DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES=1,
 DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES=2,
 DEV_MAC_HID_MOUSE_BUTTON_EMULATION=3,
 DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE=4,
 DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE=5,
 DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES=6
};


enum {
 DEV_SCSI_LOGGING_LEVEL=1,
};


enum {
 DEV_IPMI_POWEROFF_POWERCYCLE=1,
};


enum
{
 ABI_DEFHANDLER_COFF=1,
 ABI_DEFHANDLER_ELF=2,
 ABI_DEFHANDLER_LCALL7=3,
 ABI_DEFHANDLER_LIBCSO=4,
 ABI_TRACE=5,
 ABI_FAKE_UTSNAME=6,
};
# 31 "/home/nathan/src/linux-next/include/linux/sysctl.h" 2


struct completion;
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;






extern const int sysctl_vals[];

typedef int proc_handler(struct ctl_table *ctl, int write, void *buffer,
  size_t *lenp, loff_t *ppos);

int proc_dostring(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_dointvec(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_douintvec(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_dointvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_douintvec_minmax(struct ctl_table *table, int write, void *buffer,
  size_t *lenp, loff_t *ppos);
int proc_dointvec_jiffies(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_dointvec_userhz_jiffies(struct ctl_table *, int, void *, size_t *,
  loff_t *);
int proc_dointvec_ms_jiffies(struct ctl_table *, int, void *, size_t *,
  loff_t *);
int proc_doulongvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int, void *,
  size_t *, loff_t *);
int proc_do_large_bitmap(struct ctl_table *, int, void *, size_t *, loff_t *);
int proc_do_static_key(struct ctl_table *table, int write, void *buffer,
  size_t *lenp, loff_t *ppos);
# 96 "/home/nathan/src/linux-next/include/linux/sysctl.h"
struct ctl_table_poll {
 atomic_t event;
 wait_queue_head_t wait;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *proc_sys_poll_event(struct ctl_table_poll *poll)
{
 return (void *)(unsigned long)atomic_read(&poll->event);
}
# 114 "/home/nathan/src/linux-next/include/linux/sysctl.h"
struct ctl_table {
 const char *procname;
 void *data;
 int maxlen;
 umode_t mode;
 struct ctl_table *child;
 proc_handler *proc_handler;
 struct ctl_table_poll *poll;
 void *extra1;
 void *extra2;
} ;

struct ctl_node {
 struct rb_node node;
 struct ctl_table_header *header;
};



struct ctl_table_header {
 union {
  struct {
   struct ctl_table *ctl_table;
   int used;
   int count;
   int nreg;
  };
  struct callback_head rcu;
 };
 struct completion *unregistering;
 struct ctl_table *ctl_table_arg;
 struct ctl_table_root *root;
 struct ctl_table_set *set;
 struct ctl_dir *parent;
 struct ctl_node *node;
 struct hlist_head inodes;
};

struct ctl_dir {

 struct ctl_table_header header;
 struct rb_root root;
};

struct ctl_table_set {
 int (*is_seen)(struct ctl_table_set *);
 struct ctl_dir dir;
};

struct ctl_table_root {
 struct ctl_table_set default_set;
 struct ctl_table_set *(*lookup)(struct ctl_table_root *root);
 void (*set_ownership)(struct ctl_table_header *head,
         struct ctl_table *table,
         kuid_t *uid, kgid_t *gid);
 int (*permissions)(struct ctl_table_header *head, struct ctl_table *table);
};


struct ctl_path {
 const char *procname;
};



void proc_sys_poll_notify(struct ctl_table_poll *poll);

extern void setup_sysctl_set(struct ctl_table_set *p,
 struct ctl_table_root *root,
 int (*is_seen)(struct ctl_table_set *));
extern void retire_sysctl_set(struct ctl_table_set *set);

struct ctl_table_header *__register_sysctl_table(
 struct ctl_table_set *set,
 const char *path, struct ctl_table *table);
struct ctl_table_header *__register_sysctl_paths(
 struct ctl_table_set *set,
 const struct ctl_path *path, struct ctl_table *table);
struct ctl_table_header *register_sysctl(const char *path, struct ctl_table *table);
struct ctl_table_header *register_sysctl_table(struct ctl_table * table);
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
      struct ctl_table *table);

void unregister_sysctl_table(struct ctl_table_header * table);

extern int sysctl_init(void);
void do_sysctl_args(void);

extern int pwrsw_enabled;
extern int unaligned_enabled;
extern int unaligned_dump_stack;
extern int no_unaligned_warning;

extern struct ctl_table sysctl_mount_point[];
extern struct ctl_table random_table[];
extern struct ctl_table firmware_config_table[];
extern struct ctl_table epoll_table[];
# 244 "/home/nathan/src/linux-next/include/linux/sysctl.h"
int sysctl_max_threads(struct ctl_table *table, int write, void *buffer,
  size_t *lenp, loff_t *ppos);
# 18 "/home/nathan/src/linux-next/include/linux/key.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/assoc_array.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/assoc_array.h"
struct assoc_array {
 struct assoc_array_ptr *root;
 unsigned long nr_leaves_on_tree;
};




struct assoc_array_ops {

 unsigned long (*get_key_chunk)(const void *index_key, int level);


 unsigned long (*get_object_key_chunk)(const void *object, int level);


 bool (*compare_object)(const void *object, const void *index_key);




 int (*diff_objects)(const void *object, const void *index_key);


 void (*free_object)(void *object);
};




struct assoc_array_edit;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void assoc_array_init(struct assoc_array *array)
{
 array->root = ((void *)0);
 array->nr_leaves_on_tree = 0;
}

extern int assoc_array_iterate(const struct assoc_array *array,
          int (*iterator)(const void *object,
            void *iterator_data),
          void *iterator_data);
extern void *assoc_array_find(const struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key);
extern void assoc_array_destroy(struct assoc_array *array,
    const struct assoc_array_ops *ops);
extern struct assoc_array_edit *assoc_array_insert(struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key,
         void *object);
extern void assoc_array_insert_set_object(struct assoc_array_edit *edit,
       void *object);
extern struct assoc_array_edit *assoc_array_delete(struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key);
extern struct assoc_array_edit *assoc_array_clear(struct assoc_array *array,
        const struct assoc_array_ops *ops);
extern void assoc_array_apply_edit(struct assoc_array_edit *edit);
extern void assoc_array_cancel_edit(struct assoc_array_edit *edit);
extern int assoc_array_gc(struct assoc_array *array,
     const struct assoc_array_ops *ops,
     bool (*iterator)(void *object, void *iterator_data),
     void *iterator_data);
# 21 "/home/nathan/src/linux-next/include/linux/key.h" 2







typedef int32_t key_serial_t;


typedef uint32_t key_perm_t;

struct key;
struct net;
# 77 "/home/nathan/src/linux-next/include/linux/key.h"
enum key_need_perm {
 KEY_NEED_UNSPECIFIED,
 KEY_NEED_VIEW,
 KEY_NEED_READ,
 KEY_NEED_WRITE,
 KEY_NEED_SEARCH,
 KEY_NEED_LINK,
 KEY_NEED_SETATTR,
 KEY_NEED_UNLINK,
 KEY_SYSADMIN_OVERRIDE,
 KEY_AUTHTOKEN_OVERRIDE,
 KEY_DEFER_PERM_CHECK,
};

struct seq_file;
struct user_struct;
struct signal_struct;
struct cred;

struct key_type;
struct key_owner;
struct key_tag;
struct keyring_list;
struct keyring_name;

struct key_tag {
 struct callback_head rcu;
 refcount_t usage;
 bool removed;
};

struct keyring_index_key {

 unsigned long hash;
 union {
  struct {

   u16 desc_len;
   char desc[sizeof(long) - 2];




  };
  unsigned long x;
 };
 struct key_type *type;
 struct key_tag *domain_tag;
 const char *description;
};

union key_payload {
 void *rcu_data0;
 void *data[4];
};
# 147 "/home/nathan/src/linux-next/include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) key_ref_t make_key_ref(const struct key *key,
         bool possession)
{
 return (key_ref_t) ((unsigned long) key | possession);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *key_ref_to_ptr(const key_ref_t key_ref)
{
 return (struct key *) ((unsigned long) key_ref & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_key_possessed(const key_ref_t key_ref)
{
 return (unsigned long) key_ref & 1UL;
}

typedef int (*key_restrict_link_func_t)(struct key *dest_keyring,
     const struct key_type *type,
     const union key_payload *payload,
     struct key *restriction_key);

struct key_restriction {
 key_restrict_link_func_t check;
 struct key *key;
 struct key_type *keytype;
};

enum key_state {
 KEY_IS_UNINSTANTIATED,
 KEY_IS_POSITIVE,
};
# 189 "/home/nathan/src/linux-next/include/linux/key.h"
struct key {
 refcount_t usage;
 key_serial_t serial;
 union {
  struct list_head graveyard_link;
  struct rb_node serial_node;
 };



 struct rw_semaphore sem;
 struct key_user *user;
 void *security;
 union {
  time64_t expiry;
  time64_t revoked_at;
 };
 time64_t last_used_at;
 kuid_t uid;
 kgid_t gid;
 key_perm_t perm;
 unsigned short quotalen;
 unsigned short datalen;



 short state;






 unsigned long flags;
# 239 "/home/nathan/src/linux-next/include/linux/key.h"
 union {
  struct keyring_index_key index_key;
  struct {
   unsigned long hash;
   unsigned long len_desc;
   struct key_type *type;
   struct key_tag *domain_tag;
   char *description;
  };
 };





 union {
  union key_payload payload;
  struct {

   struct list_head name_link;
   struct assoc_array keys;
  };
 };
# 274 "/home/nathan/src/linux-next/include/linux/key.h"
 struct key_restriction *restrict_link;
};

extern struct key *key_alloc(struct key_type *type,
        const char *desc,
        kuid_t uid, kgid_t gid,
        const struct cred *cred,
        key_perm_t perm,
        unsigned long flags,
        struct key_restriction *restrict_link);
# 293 "/home/nathan/src/linux-next/include/linux/key.h"
extern void key_revoke(struct key *key);
extern void key_invalidate(struct key *key);
extern void key_put(struct key *key);
extern bool key_put_tag(struct key_tag *tag);
extern void key_remove_domain(struct key_tag *domain_tag);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *__key_get(struct key *key)
{
 refcount_inc(&key->usage);
 return key;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *key_get(struct key *key)
{
 return key ? __key_get(key) : key;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void key_ref_put(key_ref_t key_ref)
{
 key_put(key_ref_to_ptr(key_ref));
}

extern struct key *request_key_tag(struct key_type *type,
       const char *description,
       struct key_tag *domain_tag,
       const char *callout_info);

extern struct key *request_key_rcu(struct key_type *type,
       const char *description,
       struct key_tag *domain_tag);

extern struct key *request_key_with_auxdata(struct key_type *type,
         const char *description,
         struct key_tag *domain_tag,
         const void *callout_info,
         size_t callout_len,
         void *aux);
# 339 "/home/nathan/src/linux-next/include/linux/key.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *request_key(struct key_type *type,
          const char *description,
          const char *callout_info)
{
 return request_key_tag(type, description, ((void *)0), callout_info);
}
# 378 "/home/nathan/src/linux-next/include/linux/key.h"
extern int wait_for_key_construction(struct key *key, bool intr);

extern int key_validate(const struct key *key);

extern key_ref_t key_create_or_update(key_ref_t keyring,
          const char *type,
          const char *description,
          const void *payload,
          size_t plen,
          key_perm_t perm,
          unsigned long flags);

extern int key_update(key_ref_t key,
        const void *payload,
        size_t plen);

extern int key_link(struct key *keyring,
      struct key *key);

extern int key_move(struct key *key,
      struct key *from_keyring,
      struct key *to_keyring,
      unsigned int flags);

extern int key_unlink(struct key *keyring,
        struct key *key);

extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
     const struct cred *cred,
     key_perm_t perm,
     unsigned long flags,
     struct key_restriction *restrict_link,
     struct key *dest);

extern int restrict_link_reject(struct key *keyring,
    const struct key_type *type,
    const union key_payload *payload,
    struct key *restriction_key);

extern int keyring_clear(struct key *keyring);

extern key_ref_t keyring_search(key_ref_t keyring,
    struct key_type *type,
    const char *description,
    bool recurse);

extern int keyring_add_key(struct key *keyring,
      struct key *key);

extern int keyring_restrict(key_ref_t keyring, const char *type,
       const char *restriction);

extern struct key *key_lookup(key_serial_t id);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) key_serial_t key_serial(const struct key *key)
{
 return key ? key->serial : 0;
}

extern void key_set_timeout(struct key *, unsigned);

extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
     enum key_need_perm need_perm);
extern void key_free_user_ns(struct user_namespace *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) short key_read_state(const struct key *key)
{

 return ({ typeof(*&key->state) ___p1 = ({ do { extern void __compiletime_assert_155(void) ; if (!((sizeof(*&key->state) == sizeof(char) || sizeof(*&key->state) == sizeof(short) || sizeof(*&key->state) == sizeof(int) || sizeof(*&key->state) == sizeof(long)) || sizeof(*&key->state) == sizeof(long long))) __compiletime_assert_155(); } while (0); ({ typeof( _Generic((*&key->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&key->state))) __x = (*(const volatile typeof( _Generic((*&key->state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (*&key->state))) *)&(*&key->state)); do { } while (0); (typeof(*&key->state))__x; }); }); do { extern void __compiletime_assert_156(void) ; if (!((sizeof(*&key->state) == sizeof(char) || sizeof(*&key->state) == sizeof(short) || sizeof(*&key->state) == sizeof(int) || sizeof(*&key->state) == sizeof(long)))) __compiletime_assert_156(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}
# 456 "/home/nathan/src/linux-next/include/linux/key.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool key_is_positive(const struct key *key)
{
 return key_read_state(key) == KEY_IS_POSITIVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool key_is_negative(const struct key *key)
{
 return key_read_state(key) < 0;
}
# 479 "/home/nathan/src/linux-next/include/linux/key.h"
extern struct ctl_table key_sysctls[];




extern int install_thread_keyring_to_cred(struct cred *cred);
extern void key_fsuid_changed(struct cred *new_cred);
extern void key_fsgid_changed(struct cred *new_cred);
extern void key_init(void);
# 14 "/home/nathan/src/linux-next/include/linux/cred.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/sched/user.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/ratelimit.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/ratelimit.h"
struct ratelimit_state {
 raw_spinlock_t lock;

 int interval;
 int burst;
 int printed;
 int missed;
 unsigned long begin;
 unsigned long flags;
};
# 40 "/home/nathan/src/linux-next/include/linux/ratelimit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_state_init(struct ratelimit_state *rs,
     int interval, int burst)
{
 memset(rs, 0, sizeof(*rs));

 do { *(&rs->lock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0);
 rs->interval = interval;
 rs->burst = burst;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_default_init(struct ratelimit_state *rs)
{
 return ratelimit_state_init(rs, (5 * 100),
     10);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_state_exit(struct ratelimit_state *rs)
{
 if (!(rs->flags & ((((1UL))) << (0))))
  return;

 if (rs->missed) {
  printk("\001" "4" "%s: %d output lines suppressed due to ratelimiting\n", get_current()->comm, rs->missed);

  rs->missed = 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
ratelimit_set_flags(struct ratelimit_state *rs, unsigned long flags)
{
 rs->flags = flags;
}

extern struct ratelimit_state printk_ratelimit_state;

extern int ___ratelimit(struct ratelimit_state *rs, const char *func);
# 9 "/home/nathan/src/linux-next/include/linux/sched/user.h" 2




struct user_struct {
 refcount_t __count;
 atomic_t processes;
 atomic_t sigpending;

 atomic_t fanotify_listeners;


 atomic_long_t epoll_watches;



 unsigned long mq_bytes;

 unsigned long locked_shm;
 unsigned long unix_inflight;
 atomic_long_t pipe_bufs;


 struct hlist_node uidhash_node;
 kuid_t uid;



 atomic_long_t locked_vm;



 struct ratelimit_state ratelimit;
};

extern int uids_sysfs_init(void);

extern struct user_struct *find_user(kuid_t);

extern struct user_struct root_user;




extern struct user_struct * alloc_uid(kuid_t);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_struct *get_uid(struct user_struct *u)
{
 refcount_inc(&u->__count);
 return u;
}
extern void free_uid(struct user_struct *);
# 18 "/home/nathan/src/linux-next/include/linux/cred.h" 2

struct cred;
struct inode;




struct group_info {
 atomic_t usage;
 int ngroups;
 kgid_t gid[0];
} ;
# 40 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct group_info *get_group_info(struct group_info *gi)
{
 atomic_inc(&gi->usage);
 return gi;
}
# 56 "/home/nathan/src/linux-next/include/linux/cred.h"
extern struct group_info init_groups;

extern struct group_info *groups_alloc(int);
extern void groups_free(struct group_info *);

extern int in_group_p(kgid_t);
extern int in_egroup_p(kgid_t);
extern int groups_search(const struct group_info *, kgid_t);

extern int set_current_groups(struct group_info *);
extern void set_groups(struct cred *, struct group_info *);
extern bool may_setgroups(void);
extern void groups_sort(struct group_info *);
# 111 "/home/nathan/src/linux-next/include/linux/cred.h"
struct cred {
 atomic_t usage;







 kuid_t uid;
 kgid_t gid;
 kuid_t suid;
 kgid_t sgid;
 kuid_t euid;
 kgid_t egid;
 kuid_t fsuid;
 kgid_t fsgid;
 unsigned securebits;
 kernel_cap_t cap_inheritable;
 kernel_cap_t cap_permitted;
 kernel_cap_t cap_effective;
 kernel_cap_t cap_bset;
 kernel_cap_t cap_ambient;

 unsigned char jit_keyring;

 struct key *session_keyring;
 struct key *process_keyring;
 struct key *thread_keyring;
 struct key *request_key_auth;


 void *security;

 struct user_struct *user;
 struct user_namespace *user_ns;
 struct group_info *group_info;

 union {
  int non_rcu;
  struct callback_head rcu;
 };
} ;

extern void __put_cred(struct cred *);
extern void exit_creds(struct task_struct *);
extern int copy_creds(struct task_struct *, unsigned long);
extern const struct cred *get_task_cred(struct task_struct *);
extern struct cred *cred_alloc_blank(void);
extern struct cred *prepare_creds(void);
extern struct cred *prepare_exec_creds(void);
extern int commit_creds(struct cred *);
extern void abort_creds(struct cred *);
extern const struct cred *override_creds(const struct cred *);
extern void revert_creds(const struct cred *);
extern struct cred *prepare_kernel_cred(struct task_struct *);
extern int change_create_files_as(struct cred *, struct inode *);
extern int set_security_override(struct cred *, u32);
extern int set_security_override_from_ctx(struct cred *, const char *);
extern int set_create_files_as(struct cred *, struct inode *);
extern int cred_fscmp(const struct cred *, const struct cred *);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) cred_init(void);
# 203 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_creds(const struct cred *cred)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_creds_for_do_exit(struct task_struct *tsk)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_process_creds(void)
{
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_ambient_invariant_ok(const struct cred *cred)
{
 return cap_issubset(cred->cap_ambient,
       cap_intersect(cred->cap_permitted,
       cred->cap_inheritable));
}
# 228 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cred *get_new_cred(struct cred *cred)
{
 atomic_inc(&cred->usage);
 return cred;
}
# 247 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cred *get_cred(const struct cred *cred)
{
 struct cred *nonconst_cred = (struct cred *) cred;
 if (!cred)
  return cred;
 validate_creds(cred);
 nonconst_cred->non_rcu = 0;
 return get_new_cred(nonconst_cred);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cred *get_cred_rcu(const struct cred *cred)
{
 struct cred *nonconst_cred = (struct cred *) cred;
 if (!cred)
  return ((void *)0);
 if (!atomic_inc_not_zero((&nonconst_cred->usage)))
  return ((void *)0);
 validate_creds(cred);
 nonconst_cred->non_rcu = 0;
 return cred;
}
# 280 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_cred(const struct cred *_cred)
{
 struct cred *cred = (struct cred *) _cred;

 if (cred) {
  validate_creds(cred);
  if (atomic_dec_and_test(&(cred)->usage))
   __put_cred(cred);
 }
}
# 390 "/home/nathan/src/linux-next/include/linux/cred.h"
extern struct user_namespace init_user_ns;
# 11 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
struct sighand_struct {
 spinlock_t siglock;
 refcount_t count;
 wait_queue_head_t signalfd_wqh;
 struct k_sigaction action[64];
};




struct pacct_struct {
 int ac_flag;
 long ac_exitcode;
 unsigned long ac_mem;
 u64 ac_utime, ac_stime;
 unsigned long ac_minflt, ac_majflt;
};

struct cpu_itimer {
 u64 expires;
 u64 incr;
};





struct task_cputime_atomic {
 atomic64_t utime;
 atomic64_t stime;
 atomic64_t sum_exec_runtime;
};
# 66 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
struct thread_group_cputimer {
 struct task_cputime_atomic cputime_atomic;
};

struct multiprocess_signals {
 sigset_t signal;
 struct hlist_node node;
};
# 82 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
struct signal_struct {
 refcount_t sigcnt;
 atomic_t live;
 int nr_threads;
 struct list_head thread_head;

 wait_queue_head_t wait_chldexit;


 struct task_struct *curr_target;


 struct sigpending shared_pending;


 struct hlist_head multiprocess;


 int group_exit_code;





 int notify_count;
 struct task_struct *group_exit_task;


 int group_stop_count;
 unsigned int flags;
# 122 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 unsigned int is_child_subreaper:1;
 unsigned int has_child_subreaper:1;




 int posix_timer_id;
 struct list_head posix_timers;


 struct hrtimer real_timer;
 ktime_t it_real_incr;






 struct cpu_itimer it[2];





 struct thread_group_cputimer cputimer;



 struct posix_cputimers posix_cputimers;


 struct pid *pids[PIDTYPE_MAX];


 atomic_t tick_dep_mask;


 struct pid *tty_old_pgrp;


 int leader;

 struct tty_struct *tty;


 struct autogroup *autogroup;







 seqlock_t stats_lock;
 u64 utime, stime, cutime, cstime;
 u64 gtime;
 u64 cgtime;
 struct prev_cputime prev_cputime;
 unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
 unsigned long inblock, oublock, cinblock, coublock;
 unsigned long maxrss, cmaxrss;
 struct task_io_accounting ioac;







 unsigned long long sum_sched_runtime;
# 203 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 struct rlimit rlim[16];


 struct pacct_struct pacct;


 struct taskstats *stats;


 unsigned audit_tty;
 struct tty_audit_buf *tty_audit_buf;






 bool oom_flag_origin;
 short oom_score_adj;
 short oom_score_adj_min;

 struct mm_struct *oom_mm;


 struct mutex cred_guard_mutex;





 struct mutex exec_update_mutex;



} ;
# 258 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signal_set_stop_flags(struct signal_struct *sig,
      unsigned int flags)
{
 ({ int __ret_warn_on = !!(sig->flags & (0x00000004|0x00000008)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (261), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (261), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 sig->flags = (sig->flags & ~((0x00000010|0x00000020) | 0x00000001 | 0x00000002)) | flags;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_group_exit(const struct signal_struct *sig)
{
 return (sig->flags & 0x00000004) ||
  (sig->group_exit_task != ((void *)0));
}

extern void flush_signals(struct task_struct *);
extern void ignore_signals(struct task_struct *);
extern void flush_signal_handlers(struct task_struct *, int force_default);
extern int dequeue_signal(struct task_struct *task,
     sigset_t *mask, kernel_siginfo_t *info);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernel_dequeue_signal(void)
{
 struct task_struct *task = get_current();
 kernel_siginfo_t __info;
 int ret;

 spin_lock_irq(&task->sighand->siglock);
 ret = dequeue_signal(task, &task->blocked, &__info);
 spin_unlock_irq(&task->sighand->siglock);

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kernel_signal_stop(void)
{
 spin_lock_irq(&get_current()->sighand->siglock);
 if (get_current()->jobctl & (1UL << 16))
  do { unsigned long flags; do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(&get_current()->pi_lock); } while (0); get_current()->state = ((0x0100 | 0x0004)); do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); _raw_spin_unlock_irqrestore(&get_current()->pi_lock, flags); } while (0); } while (0);
 spin_unlock_irq(&get_current()->sighand->siglock);

 schedule();
}
# 311 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
int force_sig_fault_to_task(int sig, int code, void *addr


 , struct task_struct *t);
int force_sig_fault(int sig, int code, void *addr

                                                                );
int send_sig_fault(int sig, int code, void *addr


 , struct task_struct *t);

int force_sig_mceerr(int code, void *, short);
int send_sig_mceerr(int code, void *, short, struct task_struct *);

int force_sig_bnderr(void *addr, void *lower, void *upper);
int force_sig_pkuerr(void *addr, u32 pkey);

int force_sig_ptrace_errno_trap(int errno, void *addr);

extern int send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
extern void force_sigsegv(int sig);
extern int force_sig_info(struct kernel_siginfo *);
extern int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp);
extern int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid);
extern int kill_pid_usb_asyncio(int sig, int errno, sigval_t addr, struct pid *,
    const struct cred *);
extern int kill_pgrp(struct pid *pid, int sig, int priv);
extern int kill_pid(struct pid *pid, int sig, int priv);
extern __attribute__((__warn_unused_result__)) bool do_notify_parent(struct task_struct *, int);
extern void __wake_up_parent(struct task_struct *p, struct task_struct *parent);
extern void force_sig(int);
extern int send_sig(int, struct task_struct *, int);
extern int zap_other_threads(struct task_struct *p);
extern struct sigqueue *sigqueue_alloc(void);
extern void sigqueue_free(struct sigqueue *);
extern int send_sigqueue(struct sigqueue *, struct pid *, enum pid_type);
extern int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int restart_syscall(void)
{
 set_tsk_thread_flag(get_current(), 1);
 return -513;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_pending(struct task_struct *p)
{
 return __builtin_expect(!!(test_tsk_thread_flag(p,1)), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __fatal_signal_pending(struct task_struct *p)
{
 return __builtin_expect(!!(sigismember(&p->pending.signal, 9)), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fatal_signal_pending(struct task_struct *p)
{
 return signal_pending(p) && __fatal_signal_pending(p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_pending_state(long state, struct task_struct *p)
{
 if (!(state & (0x0001 | 0x0100)))
  return 0;
 if (!signal_pending(p))
  return 0;

 return (state & 0x0001) || __fatal_signal_pending(p);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fault_signal_pending(vm_fault_t fault_flags,
     struct pt_regs *regs)
{
 return __builtin_expect(!!((fault_flags & VM_FAULT_RETRY) && (fatal_signal_pending(get_current()) || (((((regs)->msr) >> 14) & 0x1) && signal_pending(get_current())))), 0);


}







extern void recalc_sigpending_and_wake(struct task_struct *t);
extern void recalc_sigpending(void);
extern void calculate_sigpending(void);

extern void signal_wake_up_state(struct task_struct *t, unsigned int state);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signal_wake_up(struct task_struct *t, bool resume)
{
 signal_wake_up_state(t, resume ? 0x0100 : 0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptrace_signal_wake_up(struct task_struct *t, bool resume)
{
 signal_wake_up_state(t, resume ? 0x0008 : 0);
}

void task_join_group_stop(struct task_struct *task);
# 465 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_restore_sigmask(void)
{
 get_current()->restore_sigmask = true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_restore_sigmask(struct task_struct *task)
{
 task->restore_sigmask = false;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_restore_sigmask(void)
{
 get_current()->restore_sigmask = false;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_restore_sigmask(void)
{
 return get_current()->restore_sigmask;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_tsk_restore_sigmask(struct task_struct *task)
{
 return task->restore_sigmask;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_clear_restore_sigmask(void)
{
 if (!get_current()->restore_sigmask)
  return false;
 get_current()->restore_sigmask = false;
 return true;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_saved_sigmask(void)
{
 if (test_and_clear_restore_sigmask())
  __set_current_blocked(&get_current()->saved_sigmask);
}

extern int set_user_sigmask(const sigset_t *umask, size_t sigsetsize);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_saved_sigmask_unless(bool interrupted)
{
 if (interrupted)
  ({ int __ret_warn_on = !!(!test_ti_thread_flag(((struct thread_info *)get_current()), 1)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (505), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (505), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 else
  restore_saved_sigmask();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sigset_t *sigmask_to_save(void)
{
 sigset_t *res = &get_current()->blocked;
 if (__builtin_expect(!!(test_restore_sigmask()), 0))
  res = &get_current()->saved_sigmask;
 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kill_cad_pid(int sig, int priv)
{
 return kill_pid(cad_pid, sig, priv);
}
# 530 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int on_sig_stack(unsigned long sp)
{
# 541 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 if (get_current()->sas_ss_flags & (1U << 31))
  return 0;





 return sp > get_current()->sas_ss_sp &&
  sp - get_current()->sas_ss_sp <= get_current()->sas_ss_size;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sas_ss_flags(unsigned long sp)
{
 if (!get_current()->sas_ss_size)
  return 2;

 return on_sig_stack(sp) ? 1 : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sas_ss_reset(struct task_struct *p)
{
 p->sas_ss_sp = 0;
 p->sas_ss_size = 0;
 p->sas_ss_flags = 2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long sigsp(unsigned long sp, struct ksignal *ksig)
{
 if (__builtin_expect(!!((ksig->ka.sa.sa_flags & 0x08000000U)), 0) && ! sas_ss_flags(sp))



  return get_current()->sas_ss_sp + get_current()->sas_ss_size;

 return sp;
}

extern void __cleanup_sighand(struct sighand_struct *);
extern void flush_itimer_signals(void);
# 591 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
extern bool current_is_single_threaded(void);
# 613 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
typedef int (*proc_visitor)(struct task_struct *p, void *data);
void walk_process_tree(struct task_struct *top, proc_visitor, void *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct pid *task_pid_type(struct task_struct *task, enum pid_type type)
{
 struct pid *pid;
 if (type == PIDTYPE_PID)
  pid = task_pid(task);
 else
  pid = task->signal->pids[type];
 return pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_tgid(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_TGID];
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_pgrp(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_PGID];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_session(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_SID];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_nr_threads(struct task_struct *task)
{
 return task->signal->nr_threads;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool thread_group_leader(struct task_struct *p)
{
 return p->exit_signal >= 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
bool same_thread_group(struct task_struct *p1, struct task_struct *p2)
{
 return p1->signal == p2->signal;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *next_thread(const struct task_struct *p)
{
 return ({ void *__mptr = (void *)(({ do { extern void __compiletime_assert_157(void) ; if (!((sizeof(p->thread_group.next) == sizeof(char) || sizeof(p->thread_group.next) == sizeof(short) || sizeof(p->thread_group.next) == sizeof(int) || sizeof(p->thread_group.next) == sizeof(long)) || sizeof(p->thread_group.next) == sizeof(long long))) __compiletime_assert_157(); } while (0); ({ typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) __x = (*(const volatile typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) *)&(p->thread_group.next)); do { } while (0); (typeof(p->thread_group.next))__x; }); })); do { extern void __compiletime_assert_158(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(({ do { extern void __compiletime_assert_157(void) ; if (!((sizeof(p->thread_group.next) == sizeof(char) || sizeof(p->thread_group.next) == sizeof(short) || sizeof(p->thread_group.next) == sizeof(int) || sizeof(p->thread_group.next) == sizeof(long)) || sizeof(p->thread_group.next) == sizeof(long long))) __compiletime_assert_157(); } while (0); ({ typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) __x = (*(const volatile typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) *)&(p->thread_group.next)); do { } while (0); (typeof(p->thread_group.next))__x; }); }))), typeof(((struct task_struct *)0)->thread_group)) && !__builtin_types_compatible_p(typeof(*(({ do { extern void __compiletime_assert_157(void) ; if (!((sizeof(p->thread_group.next) == sizeof(char) || sizeof(p->thread_group.next) == sizeof(short) || sizeof(p->thread_group.next) == sizeof(int) || sizeof(p->thread_group.next) == sizeof(long)) || sizeof(p->thread_group.next) == sizeof(long long))) __compiletime_assert_157(); } while (0); ({ typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) __x = (*(const volatile typeof( _Generic((p->thread_group.next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (p->thread_group.next))) *)&(p->thread_group.next)); do { } while (0); (typeof(p->thread_group.next))__x; }); }))), typeof(void))))) __compiletime_assert_158(); } while (0); ((struct task_struct *)(__mptr - __builtin_offsetof(struct task_struct, thread_group))); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int thread_group_empty(struct task_struct *p)
{
 return list_empty(&p->thread_group);
}




extern struct sighand_struct *__lock_task_sighand(struct task_struct *task,
       unsigned long *flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sighand_struct *lock_task_sighand(struct task_struct *task,
             unsigned long *flags)
{
 struct sighand_struct *ret;

 ret = __lock_task_sighand(task, flags);
 (void)(ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unlock_task_sighand(struct task_struct *task,
      unsigned long *flags)
{
 spin_unlock_irqrestore(&task->sighand->siglock, *flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long task_rlimit(const struct task_struct *task,
  unsigned int limit)
{
 return ({ do { extern void __compiletime_assert_159(void) ; if (!((sizeof(task->signal->rlim[limit].rlim_cur) == sizeof(char) || sizeof(task->signal->rlim[limit].rlim_cur) == sizeof(short) || sizeof(task->signal->rlim[limit].rlim_cur) == sizeof(int) || sizeof(task->signal->rlim[limit].rlim_cur) == sizeof(long)) || sizeof(task->signal->rlim[limit].rlim_cur) == sizeof(long long))) __compiletime_assert_159(); } while (0); ({ typeof( _Generic((task->signal->rlim[limit].rlim_cur), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (task->signal->rlim[limit].rlim_cur))) __x = (*(const volatile typeof( _Generic((task->signal->rlim[limit].rlim_cur), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (task->signal->rlim[limit].rlim_cur))) *)&(task->signal->rlim[limit].rlim_cur)); do { } while (0); (typeof(task->signal->rlim[limit].rlim_cur))__x; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long task_rlimit_max(const struct task_struct *task,
  unsigned int limit)
{
 return ({ do { extern void __compiletime_assert_160(void) ; if (!((sizeof(task->signal->rlim[limit].rlim_max) == sizeof(char) || sizeof(task->signal->rlim[limit].rlim_max) == sizeof(short) || sizeof(task->signal->rlim[limit].rlim_max) == sizeof(int) || sizeof(task->signal->rlim[limit].rlim_max) == sizeof(long)) || sizeof(task->signal->rlim[limit].rlim_max) == sizeof(long long))) __compiletime_assert_160(); } while (0); ({ typeof( _Generic((task->signal->rlim[limit].rlim_max), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (task->signal->rlim[limit].rlim_max))) __x = (*(const volatile typeof( _Generic((task->signal->rlim[limit].rlim_max), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (task->signal->rlim[limit].rlim_max))) *)&(task->signal->rlim[limit].rlim_max)); do { } while (0); (typeof(task->signal->rlim[limit].rlim_max))__x; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long rlimit(unsigned int limit)
{
 return task_rlimit(get_current(), limit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long rlimit_max(unsigned int limit)
{
 return task_rlimit_max(get_current(), limit);
}
# 7 "/home/nathan/src/linux-next/include/linux/rcuwait.h" 2
# 16 "/home/nathan/src/linux-next/include/linux/rcuwait.h"
struct rcuwait {
 struct task_struct *task;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcuwait_init(struct rcuwait *w)
{
 w->task = ((void *)0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcuwait_active(struct rcuwait *w)
{
 return !!({ typeof(*(w->task)) *_________p1 = (typeof(*(w->task)) *)({ do { extern void __compiletime_assert_161(void) ; if (!((sizeof((w->task)) == sizeof(char) || sizeof((w->task)) == sizeof(short) || sizeof((w->task)) == sizeof(int) || sizeof((w->task)) == sizeof(long)) || sizeof((w->task)) == sizeof(long long))) __compiletime_assert_161(); } while (0); ({ typeof( _Generic(((w->task)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((w->task)))) __x = (*(const volatile typeof( _Generic(((w->task)), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((w->task)))) *)&((w->task))); do { } while (0); (typeof((w->task)))__x; }); }); ; ((typeof(*(w->task)) *)(_________p1)); });
}

extern int rcuwait_wake_up(struct rcuwait *w);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prepare_to_rcuwait(struct rcuwait *w)
{
 do { uintptr_t _r_a_p__v = (uintptr_t)(get_current()); ; if (__builtin_constant_p(get_current()) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_162(void) ; if (!((sizeof((w->task)) == sizeof(char) || sizeof((w->task)) == sizeof(short) || sizeof((w->task)) == sizeof(int) || sizeof((w->task)) == sizeof(long)) || sizeof((w->task)) == sizeof(long long))) __compiletime_assert_162(); } while (0); do { *(volatile typeof((w->task)) *)&((w->task)) = ((typeof(w->task))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_163(void) ; if (!((sizeof(*&w->task) == sizeof(char) || sizeof(*&w->task) == sizeof(short) || sizeof(*&w->task) == sizeof(int) || sizeof(*&w->task) == sizeof(long)))) __compiletime_assert_163(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_164(void) ; if (!((sizeof(*&w->task) == sizeof(char) || sizeof(*&w->task) == sizeof(short) || sizeof(*&w->task) == sizeof(int) || sizeof(*&w->task) == sizeof(long)) || sizeof(*&w->task) == sizeof(long long))) __compiletime_assert_164(); } while (0); do { *(volatile typeof(*&w->task) *)&(*&w->task) = ((typeof(*((typeof(w->task))_r_a_p__v)) *)((typeof(w->task))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void finish_rcuwait(struct rcuwait *w)
{
        do { uintptr_t _r_a_p__v = (uintptr_t)(((void *)0)); ; if (__builtin_constant_p(((void *)0)) && (_r_a_p__v) == (uintptr_t)((void *)0)) do { do { extern void __compiletime_assert_165(void) ; if (!((sizeof((w->task)) == sizeof(char) || sizeof((w->task)) == sizeof(short) || sizeof((w->task)) == sizeof(int) || sizeof((w->task)) == sizeof(long)) || sizeof((w->task)) == sizeof(long long))) __compiletime_assert_165(); } while (0); do { *(volatile typeof((w->task)) *)&((w->task)) = ((typeof(w->task))(_r_a_p__v)); } while (0); } while (0); else do { do { extern void __compiletime_assert_166(void) ; if (!((sizeof(*&w->task) == sizeof(char) || sizeof(*&w->task) == sizeof(short) || sizeof(*&w->task) == sizeof(int) || sizeof(*&w->task) == sizeof(long)))) __compiletime_assert_166(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); do { do { extern void __compiletime_assert_167(void) ; if (!((sizeof(*&w->task) == sizeof(char) || sizeof(*&w->task) == sizeof(short) || sizeof(*&w->task) == sizeof(int) || sizeof(*&w->task) == sizeof(long)) || sizeof(*&w->task) == sizeof(long long))) __compiletime_assert_167(); } while (0); do { *(volatile typeof(*&w->task) *)&(*&w->task) = ((typeof(*((typeof(w->task))_r_a_p__v)) *)((typeof(w->task))_r_a_p__v)); } while (0); } while (0); } while (0); } while (0);
 get_current()->state = (0x0000);
}
# 8 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/rcu_sync.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/rcu_sync.h"
struct rcu_sync {
 int gp_state;
 int gp_count;
 wait_queue_head_t gp_wait;

 struct callback_head cb_head;
};
# 32 "/home/nathan/src/linux-next/include/linux/rcu_sync.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rcu_sync_is_idle(struct rcu_sync *rsp)
{
 do { } while (0);

 return !({ do { extern void __compiletime_assert_168(void) ; if (!((sizeof(rsp->gp_state) == sizeof(char) || sizeof(rsp->gp_state) == sizeof(short) || sizeof(rsp->gp_state) == sizeof(int) || sizeof(rsp->gp_state) == sizeof(long)) || sizeof(rsp->gp_state) == sizeof(long long))) __compiletime_assert_168(); } while (0); ({ typeof( _Generic((rsp->gp_state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (rsp->gp_state))) __x = (*(const volatile typeof( _Generic((rsp->gp_state), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (rsp->gp_state))) *)&(rsp->gp_state)); do { } while (0); (typeof(rsp->gp_state))__x; }); });
}

extern void rcu_sync_init(struct rcu_sync *);
extern void rcu_sync_enter_start(struct rcu_sync *);
extern void rcu_sync_enter(struct rcu_sync *);
extern void rcu_sync_exit(struct rcu_sync *);
extern void rcu_sync_dtor(struct rcu_sync *);
# 10 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 2


struct percpu_rw_semaphore {
 struct rcu_sync rss;
 unsigned int *read_count;
 struct rcuwait writer;
 wait_queue_head_t waiters;
 atomic_t block;



};
# 45 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
extern bool __percpu_down_read(struct percpu_rw_semaphore *, bool);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_down_read(struct percpu_rw_semaphore *sem)
{
 do { _cond_resched(); } while (0);

 do { } while (0);

 __asm__ __volatile__("" : : : "memory");
# 62 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
 if (__builtin_expect(!!(rcu_sync_is_idle(&sem->rss)), 1))
  ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 else
  __percpu_down_read(sem, false);




 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_down_read_trylock(struct percpu_rw_semaphore *sem)
{
 bool ret = true;

 __asm__ __volatile__("" : : : "memory");



 if (__builtin_expect(!!(rcu_sync_is_idle(&sem->rss)), 1))
  ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 else
  ret = __percpu_down_read(sem, true);
 __asm__ __volatile__("" : : : "memory");





 if (ret)
  do { } while (0);

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_up_read(struct percpu_rw_semaphore *sem)
{
 do { } while (0);

 __asm__ __volatile__("" : : : "memory");



 if (__builtin_expect(!!(rcu_sync_is_idle(&sem->rss)), 1)) {
  ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 } else {




  __asm__ __volatile__ ("sync" : : : "memory");





  ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
  rcuwait_wake_up(&sem->writer);
 }
 __asm__ __volatile__("" : : : "memory");
}

extern void percpu_down_write(struct percpu_rw_semaphore *);
extern void percpu_up_write(struct percpu_rw_semaphore *);

extern int __percpu_init_rwsem(struct percpu_rw_semaphore *,
    const char *, struct lock_class_key *);

extern void percpu_free_rwsem(struct percpu_rw_semaphore *);
# 141 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_rwsem_release(struct percpu_rw_semaphore *sem,
     bool read, unsigned long ip)
{
 do { } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_rwsem_acquire(struct percpu_rw_semaphore *sem,
     bool read, unsigned long ip)
{
 do { } while (0);
}
# 34 "/home/nathan/src/linux-next/include/linux/fs.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/delayed_call.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/delayed_call.h"
struct delayed_call {
 void (*fn)(void *);
 void *arg;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_delayed_call(struct delayed_call *call,
  void (*fn)(void *), void *arg)
{
 call->fn = fn;
 call->arg = arg;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_delayed_call(struct delayed_call *call)
{
 if (call->fn)
  call->fn(call->arg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_delayed_call(struct delayed_call *call)
{
 call->fn = ((void *)0);
}
# 36 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/uuid.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/uuid.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h" 1
# 23 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h"
typedef struct {
 __u8 b[16];
} guid_t;
# 35 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h"
typedef guid_t uuid_le;
# 12 "/home/nathan/src/linux-next/include/linux/uuid.h" 2




typedef struct {
 __u8 b[16];
} uuid_t;
# 33 "/home/nathan/src/linux-next/include/linux/uuid.h"
extern const guid_t guid_null;
extern const uuid_t uuid_null;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool guid_equal(const guid_t *u1, const guid_t *u2)
{
 return memcmp(u1, u2, sizeof(guid_t)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void guid_copy(guid_t *dst, const guid_t *src)
{
 memcpy(dst, src, sizeof(guid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void import_guid(guid_t *dst, const __u8 *src)
{
 memcpy(dst, src, sizeof(guid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void export_guid(__u8 *dst, const guid_t *src)
{
 memcpy(dst, src, sizeof(guid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool guid_is_null(const guid_t *guid)
{
 return guid_equal(guid, &guid_null);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uuid_equal(const uuid_t *u1, const uuid_t *u2)
{
 return memcmp(u1, u2, sizeof(uuid_t)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void uuid_copy(uuid_t *dst, const uuid_t *src)
{
 memcpy(dst, src, sizeof(uuid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void import_uuid(uuid_t *dst, const __u8 *src)
{
 memcpy(dst, src, sizeof(uuid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void export_uuid(__u8 *dst, const uuid_t *src)
{
 memcpy(dst, src, sizeof(uuid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uuid_is_null(const uuid_t *uuid)
{
 return uuid_equal(uuid, &uuid_null);
}

void generate_random_uuid(unsigned char uuid[16]);
void generate_random_guid(unsigned char guid[16]);

extern void guid_gen(guid_t *u);
extern void uuid_gen(uuid_t *u);

bool __attribute__((__warn_unused_result__)) uuid_is_valid(const char *uuid);

extern const u8 guid_index[16];
extern const u8 uuid_index[16];

int guid_parse(const char *uuid, guid_t *u);
int uuid_parse(const char *uuid, uuid_t *u);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int uuid_le_cmp(const guid_t u1, const guid_t u2)
{
 return memcmp(&u1, &u2, sizeof(guid_t));
}
# 37 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/errseq.h" 1







typedef u32 errseq_t;

errseq_t errseq_set(errseq_t *eseq, int err);
errseq_t errseq_sample(errseq_t *eseq);
int errseq_check(errseq_t *eseq, errseq_t since);
int errseq_check_and_advance(errseq_t *eseq, errseq_t *since);
# 38 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/ioprio.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/sched/rt.h" 1






struct task_struct;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rt_prio(int prio)
{
 if (__builtin_expect(!!(prio < 100), 0))
  return 1;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rt_task(struct task_struct *p)
{
 return rt_prio(p->prio);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_is_realtime(struct task_struct *tsk)
{
 int policy = tsk->policy;

 if (policy == 1 || policy == 2)
  return true;
 if (policy == 6)
  return true;
 return false;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *rt_mutex_get_top_task(struct task_struct *p)
{
 return p->pi_top_task;
}
extern void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task);
extern void rt_mutex_adjust_pi(struct task_struct *p);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tsk_is_pi_blocked(struct task_struct *tsk)
{
 return tsk->pi_blocked_on != ((void *)0);
}
# 58 "/home/nathan/src/linux-next/include/linux/sched/rt.h"
extern void normalize_rt_tasks(void);
# 7 "/home/nathan/src/linux-next/include/linux/ioprio.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/iocontext.h" 1








enum {
 ICQ_EXITED = 1 << 2,
 ICQ_DESTROYED = 1 << 3,
};
# 73 "/home/nathan/src/linux-next/include/linux/iocontext.h"
struct io_cq {
 struct request_queue *q;
 struct io_context *ioc;







 union {
  struct list_head q_node;
  struct kmem_cache *__rcu_icq_cache;
 };
 union {
  struct hlist_node ioc_node;
  struct callback_head __rcu_head;
 };

 unsigned int flags;
};





struct io_context {
 atomic_long_t refcount;
 atomic_t active_ref;
 atomic_t nr_tasks;


 spinlock_t lock;

 unsigned short ioprio;




 int nr_batch_requests;
 unsigned long last_waited;

 struct xarray icq_tree;
 struct io_cq *icq_hint;
 struct hlist_head icq_list;

 struct work_struct release_work;
};
# 130 "/home/nathan/src/linux-next/include/linux/iocontext.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void get_io_context_active(struct io_context *ioc)
{
 ({ int __ret_warn_on = !!(atomic_long_read(&ioc->refcount) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (132), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 ({ int __ret_warn_on = !!(atomic_read(&ioc->active_ref) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (133), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 atomic_long_inc(&ioc->refcount);
 atomic_inc(&ioc->active_ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ioc_task_link(struct io_context *ioc)
{
 get_io_context_active(ioc);

 ({ int __ret_warn_on = !!(atomic_read(&ioc->nr_tasks) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (142), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 atomic_inc(&ioc->nr_tasks);
}

struct task_struct;

void put_io_context(struct io_context *ioc);
void put_io_context_active(struct io_context *ioc);
void exit_io_context(struct task_struct *task);
struct io_context *get_task_io_context(struct task_struct *task,
           gfp_t gfp_flags, int node);
# 8 "/home/nathan/src/linux-next/include/linux/ioprio.h" 2
# 27 "/home/nathan/src/linux-next/include/linux/ioprio.h"
enum {
 IOPRIO_CLASS_NONE,
 IOPRIO_CLASS_RT,
 IOPRIO_CLASS_BE,
 IOPRIO_CLASS_IDLE,
};






enum {
 IOPRIO_WHO_PROCESS = 1,
 IOPRIO_WHO_PGRP,
 IOPRIO_WHO_USER,
};
# 54 "/home/nathan/src/linux-next/include/linux/ioprio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice_ioprio(struct task_struct *task)
{
 return (task_nice(task) + 20) / 5;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice_ioclass(struct task_struct *task)
{
 if (task->policy == 5)
  return IOPRIO_CLASS_IDLE;
 else if (task_is_realtime(task))
  return IOPRIO_CLASS_RT;
 else
  return IOPRIO_CLASS_BE;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_current_ioprio(void)
{
 struct io_context *ioc = get_current()->io_context;

 if (ioc)
  return ioc->ioprio;
 return (((IOPRIO_CLASS_NONE) << (13)) | 0);
}




extern int ioprio_best(unsigned short aprio, unsigned short bprio);

extern int set_task_ioprio(struct task_struct *task, int ioprio);


extern int ioprio_check_cap(int ioprio);
# 39 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/fs_types.h" 1
# 71 "/home/nathan/src/linux-next/include/linux/fs_types.h"
extern unsigned char fs_ftype_to_dtype(unsigned int filetype);
extern unsigned char fs_umode_to_ftype(umode_t mode);
extern unsigned char fs_umode_to_dtype(umode_t mode);
# 40 "/home/nathan/src/linux-next/include/linux/fs.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/watch_queue.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/watch_queue.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/linux/ioctl.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/ioctl.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/ioctl.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/ioctl.h" 2





extern unsigned int __invalid_size_argument_for_IOC;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/ioctl.h" 2
# 8 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h" 2






enum watch_notification_type {
 WATCH_TYPE_META = 0,
 WATCH_TYPE_KEY_NOTIFY = 1,
 WATCH_TYPE_MOUNT_NOTIFY = 2,
 WATCH_TYPE_SB_NOTIFY = 3,
 WATCH_TYPE___NR = 4
};

enum watch_meta_notification_subtype {
 WATCH_META_REMOVAL_NOTIFICATION = 0,
 WATCH_META_LOSS_NOTIFICATION = 1,
};





struct watch_notification {
 __u32 type:24;
 __u32 subtype:8;
 __u32 info;
# 49 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h"
};




struct watch_notification_type_filter {
 __u32 type;
 __u32 info_filter;
 __u32 info_mask;
 __u32 subtype_filter[8];
};

struct watch_notification_filter {
 __u32 nr_filters;
 __u32 __reserved;
 struct watch_notification_type_filter filters[];
};
# 76 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h"
struct watch_notification_removal {
 struct watch_notification watch;
 __u64 id;
};




enum key_notification_subtype {
 NOTIFY_KEY_INSTANTIATED = 0,
 NOTIFY_KEY_UPDATED = 1,
 NOTIFY_KEY_LINKED = 2,
 NOTIFY_KEY_UNLINKED = 3,
 NOTIFY_KEY_CLEARED = 4,
 NOTIFY_KEY_REVOKED = 5,
 NOTIFY_KEY_INVALIDATED = 6,
 NOTIFY_KEY_SETATTR = 7,
};






struct key_notification {
 struct watch_notification watch;
 __u32 key_id;
 __u32 aux;
};




enum mount_notification_subtype {
 NOTIFY_MOUNT_NEW_MOUNT = 0,
 NOTIFY_MOUNT_UNMOUNT = 1,
 NOTIFY_MOUNT_EXPIRY = 2,
 NOTIFY_MOUNT_READONLY = 3,
 NOTIFY_MOUNT_SETATTR = 4,
 NOTIFY_MOUNT_MOVE_FROM = 5,
 NOTIFY_MOUNT_MOVE_TO = 6,
};
# 129 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h"
struct mount_notification {
 struct watch_notification watch;
 __u32 triggered_on;
 __u32 auxiliary_mount;
 __u32 topology_changes;
 __u32 attr_changes;
 __u32 aux_topology_changes;
 __u32 __padding;
};




enum superblock_notification_type {
 NOTIFY_SUPERBLOCK_READONLY = 0,
 NOTIFY_SUPERBLOCK_ERROR = 1,
 NOTIFY_SUPERBLOCK_EDQUOT = 2,
 NOTIFY_SUPERBLOCK_NETWORK = 3,
};
# 156 "/home/nathan/src/linux-next/include/uapi/linux/watch_queue.h"
struct superblock_notification {
 struct watch_notification watch;
 __u64 sb_id;
};

struct superblock_error_notification {
 struct superblock_notification s;
 __u32 error_number;
 __u32 error_cookie;
};
# 14 "/home/nathan/src/linux-next/include/linux/watch_queue.h" 2
# 43 "/home/nathan/src/linux-next/include/linux/fs.h" 2


# 1 "/home/nathan/src/linux-next/include/uapi/linux/fs.h" 1
# 54 "/home/nathan/src/linux-next/include/uapi/linux/fs.h"
struct file_clone_range {
 __s64 src_fd;
 __u64 src_offset;
 __u64 src_length;
 __u64 dest_offset;
};

struct fstrim_range {
 __u64 start;
 __u64 len;
 __u64 minlen;
};






struct file_dedupe_range_info {
 __s64 dest_fd;
 __u64 dest_offset;
 __u64 bytes_deduped;






 __s32 status;
 __u32 reserved;
};


struct file_dedupe_range {
 __u64 src_offset;
 __u64 src_length;
 __u16 dest_count;
 __u16 reserved1;
 __u32 reserved2;
 struct file_dedupe_range_info info[0];
};


struct files_stat_struct {
 unsigned long nr_files;
 unsigned long nr_free_files;
 unsigned long max_files;
};

struct inodes_stat_t {
 long nr_inodes;
 long nr_unused;
 long dummy[5];
};







struct fsxattr {
 __u32 fsx_xflags;
 __u32 fsx_extsize;
 __u32 fsx_nextents;
 __u32 fsx_projid;
 __u32 fsx_cowextsize;
 unsigned char fsx_pad[8];
};
# 286 "/home/nathan/src/linux-next/include/uapi/linux/fs.h"
typedef int __kernel_rwf_t;
# 46 "/home/nathan/src/linux-next/include/linux/fs.h" 2

struct backing_dev_info;
struct bdi_writeback;
struct bio;
struct export_operations;
struct fiemap_extent_info;
struct hd_geometry;
struct iovec;
struct kiocb;
struct kobject;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct vm_area_struct;
struct vfsmount;
struct cred;
struct swap_info_struct;
struct seq_file;
struct workqueue_struct;
struct iov_iter;
struct fscrypt_info;
struct fscrypt_operations;
struct fsverity_info;
struct fsverity_operations;
struct fs_context;
struct fs_parameter_spec;
struct fsinfo_context;

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) inode_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) inode_init_early(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) files_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) files_maxfiles_init(void);

extern struct files_stat_struct files_stat;
extern unsigned long get_max_files(void);
extern unsigned int sysctl_nr_open;
extern struct inodes_stat_t inodes_stat;
extern int leases_enable, lease_break_time;
extern int sysctl_protected_symlinks;
extern int sysctl_protected_hardlinks;
extern int sysctl_protected_fifos;
extern int sysctl_protected_regular;

typedef __kernel_rwf_t rwf_t;

struct buffer_head;
typedef int (get_block_t)(struct inode *inode, sector_t iblock,
   struct buffer_head *bh_result, int create);
typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
   ssize_t bytes, void *private);
# 229 "/home/nathan/src/linux-next/include/linux/fs.h"
struct iattr {
 unsigned int ia_valid;
 umode_t ia_mode;
 kuid_t ia_uid;
 kgid_t ia_gid;
 loff_t ia_size;
 struct timespec64 ia_atime;
 struct timespec64 ia_mtime;
 struct timespec64 ia_ctime;






 struct file *ia_file;
};





# 1 "/home/nathan/src/linux-next/include/linux/quota.h" 1
# 40 "/home/nathan/src/linux-next/include/linux/quota.h"
# 1 "/home/nathan/src/linux-next/include/linux/percpu_counter.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
struct percpu_counter {
 raw_spinlock_t lock;
 s64 count;

 struct list_head list;

 s32 *counters;
};

extern int percpu_counter_batch;

int __percpu_counter_init(struct percpu_counter *fbc, s64 amount, gfp_t gfp,
     struct lock_class_key *key);
# 41 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
void percpu_counter_destroy(struct percpu_counter *fbc);
void percpu_counter_set(struct percpu_counter *fbc, s64 amount);
void percpu_counter_add_batch(struct percpu_counter *fbc, s64 amount,
         s32 batch);
s64 __percpu_counter_sum(struct percpu_counter *fbc);
int __percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int percpu_counter_compare(struct percpu_counter *fbc, s64 rhs)
{
 return __percpu_counter_compare(fbc, rhs, percpu_counter_batch);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
 percpu_counter_add_batch(fbc, amount, percpu_counter_batch);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
{
 s64 ret = __percpu_counter_sum(fbc);
 return ret < 0 ? 0 : ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_sum(struct percpu_counter *fbc)
{
 return __percpu_counter_sum(fbc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_read(struct percpu_counter *fbc)
{
 return fbc->count;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_read_positive(struct percpu_counter *fbc)
{

 s64 ret = ({ do { extern void __compiletime_assert_169(void) ; if (!((sizeof(fbc->count) == sizeof(char) || sizeof(fbc->count) == sizeof(short) || sizeof(fbc->count) == sizeof(int) || sizeof(fbc->count) == sizeof(long)) || sizeof(fbc->count) == sizeof(long long))) __compiletime_assert_169(); } while (0); ({ typeof( _Generic((fbc->count), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (fbc->count))) __x = (*(const volatile typeof( _Generic((fbc->count), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (fbc->count))) *)&(fbc->count)); do { } while (0); (typeof(fbc->count))__x; }); });

 if (ret >= 0)
  return ret;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_counter_initialized(struct percpu_counter *fbc)
{
 return (fbc->counters != ((void *)0));
}
# 177 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_inc(struct percpu_counter *fbc)
{
 percpu_counter_add(fbc, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_dec(struct percpu_counter *fbc)
{
 percpu_counter_add(fbc, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
{
 percpu_counter_add(fbc, -amount);
}
# 41 "/home/nathan/src/linux-next/include/linux/quota.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h" 1
# 53 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_disk_quota {
 __s8 d_version;
 __s8 d_flags;
 __u16 d_fieldmask;
 __u32 d_id;
 __u64 d_blk_hardlimit;
 __u64 d_blk_softlimit;
 __u64 d_ino_hardlimit;
 __u64 d_ino_softlimit;
 __u64 d_bcount;
 __u64 d_icount;
 __s32 d_itimer;

 __s32 d_btimer;
 __u16 d_iwarns;
 __u16 d_bwarns;
 __s32 d_padding2;
 __u64 d_rtb_hardlimit;
 __u64 d_rtb_softlimit;
 __u64 d_rtbcount;
 __s32 d_rtbtimer;
 __u16 d_rtbwarns;
 __s16 d_padding3;
 char d_padding4[8];
} fs_disk_quota_t;
# 149 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat {
 __u64 qfs_ino;
 __u64 qfs_nblks;
 __u32 qfs_nextents;
} fs_qfilestat_t;

typedef struct fs_quota_stat {
 __s8 qs_version;
 __u16 qs_flags;
 __s8 qs_pad;
 fs_qfilestat_t qs_uquota;
 fs_qfilestat_t qs_gquota;
 __u32 qs_incoredqs;
 __s32 qs_btimelimit;
 __s32 qs_itimelimit;
 __s32 qs_rtbtimelimit;
 __u16 qs_bwarnlimit;
 __u16 qs_iwarnlimit;
} fs_quota_stat_t;
# 192 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
 __u64 qfs_ino;
 __u64 qfs_nblks;
 __u32 qfs_nextents;
 __u32 qfs_pad;
};

struct fs_quota_statv {
 __s8 qs_version;
 __u8 qs_pad1;
 __u16 qs_flags;
 __u32 qs_incoredqs;
 struct fs_qfilestatv qs_uquota;
 struct fs_qfilestatv qs_gquota;
 struct fs_qfilestatv qs_pquota;
 __s32 qs_btimelimit;
 __s32 qs_itimelimit;
 __s32 qs_rtbtimelimit;
 __u16 qs_bwarnlimit;
 __u16 qs_iwarnlimit;
 __u64 qs_pad2[8];
};
# 43 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dqblk_v1.h" 1
# 44 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dqblk_v2.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/dqblk_qtree.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/dqblk_qtree.h"
struct dquot;
struct kqid;


struct qtree_fmt_operations {
 void (*mem2disk_dqblk)(void *disk, struct dquot *dquot);
 void (*disk2mem_dqblk)(struct dquot *dquot, void *disk);
 int (*is_id)(void *disk, struct dquot *dquot);
};


struct qtree_mem_dqinfo {
 struct super_block *dqi_sb;
 int dqi_type;
 unsigned int dqi_blocks;
 unsigned int dqi_free_blk;
 unsigned int dqi_free_entry;
 unsigned int dqi_blocksize_bits;
 unsigned int dqi_entry_size;
 unsigned int dqi_usable_bs;
 unsigned int dqi_qtree_depth;
 const struct qtree_fmt_operations *dqi_ops;
};

int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qtree_depth(struct qtree_mem_dqinfo *info)
{
 unsigned int epb = info->dqi_usable_bs >> 2;
 unsigned long long entries = epb;
 int i;

 for (i = 1; entries < (1ULL << 32); i++)
  entries *= epb;
 return i;
}
int qtree_get_next_id(struct qtree_mem_dqinfo *info, struct kqid *qid);
# 10 "/home/nathan/src/linux-next/include/linux/dqblk_v2.h" 2
# 45 "/home/nathan/src/linux-next/include/linux/quota.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/projid.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/projid.h"
struct user_namespace;
extern struct user_namespace init_user_ns;

typedef __kernel_uid32_t projid_t;

typedef struct {
 projid_t val;
} kprojid_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) projid_t __kprojid_val(kprojid_t projid)
{
 return projid.val;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_eq(kprojid_t left, kprojid_t right)
{
 return __kprojid_val(left) == __kprojid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_lt(kprojid_t left, kprojid_t right)
{
 return __kprojid_val(left) < __kprojid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_valid(kprojid_t projid)
{
 return !projid_eq(projid, (kprojid_t){ -1 });
}



extern kprojid_t make_kprojid(struct user_namespace *from, projid_t projid);

extern projid_t from_kprojid(struct user_namespace *to, kprojid_t projid);
extern projid_t from_kprojid_munged(struct user_namespace *to, kprojid_t projid);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kprojid_has_mapping(struct user_namespace *ns, kprojid_t projid)
{
 return from_kprojid(ns, projid) != (projid_t)-1;
}
# 49 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/quota.h" 1
# 90 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 QIF_BLIMITS_B = 0,
 QIF_SPACE_B,
 QIF_ILIMITS_B,
 QIF_INODES_B,
 QIF_BTIME_B,
 QIF_ITIME_B,
};
# 110 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
struct if_dqblk {
 __u64 dqb_bhardlimit;
 __u64 dqb_bsoftlimit;
 __u64 dqb_curspace;
 __u64 dqb_ihardlimit;
 __u64 dqb_isoftlimit;
 __u64 dqb_curinodes;
 __u64 dqb_btime;
 __u64 dqb_itime;
 __u32 dqb_valid;
};

struct if_nextdqblk {
 __u64 dqb_bhardlimit;
 __u64 dqb_bsoftlimit;
 __u64 dqb_curspace;
 __u64 dqb_ihardlimit;
 __u64 dqb_isoftlimit;
 __u64 dqb_curinodes;
 __u64 dqb_btime;
 __u64 dqb_itime;
 __u32 dqb_valid;
 __u32 dqb_id;
};
# 144 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 DQF_ROOT_SQUASH_B = 0,
 DQF_SYS_FILE_B = 16,

 DQF_PRIVATE
};






struct if_dqinfo {
 __u64 dqi_bgrace;
 __u64 dqi_igrace;
 __u32 dqi_flags;
 __u32 dqi_valid;
};
# 178 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 QUOTA_NL_C_UNSPEC,
 QUOTA_NL_C_WARNING,
 __QUOTA_NL_C_MAX,
};


enum {
 QUOTA_NL_A_UNSPEC,
 QUOTA_NL_A_QTYPE,
 QUOTA_NL_A_EXCESS_ID,
 QUOTA_NL_A_WARNING,
 QUOTA_NL_A_DEV_MAJOR,
 QUOTA_NL_A_DEV_MINOR,
 QUOTA_NL_A_CAUSED_ID,
 QUOTA_NL_A_PAD,
 __QUOTA_NL_A_MAX,
};
# 50 "/home/nathan/src/linux-next/include/linux/quota.h" 2




enum quota_type {
 USRQUOTA = 0,
 GRPQUOTA = 1,
 PRJQUOTA = 2,
};






typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;

struct kqid {
 union {
  kuid_t uid;
  kgid_t gid;
  kprojid_t projid;
 };
 enum quota_type type;
};

extern bool qid_eq(struct kqid left, struct kqid right);
extern bool qid_lt(struct kqid left, struct kqid right);
extern qid_t from_kqid(struct user_namespace *to, struct kqid qid);
extern qid_t from_kqid_munged(struct user_namespace *to, struct kqid qid);
extern bool qid_valid(struct kqid qid);
# 97 "/home/nathan/src/linux-next/include/linux/quota.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid(struct user_namespace *from,
        enum quota_type type, qid_t qid)
{
 struct kqid kqid;

 kqid.type = type;
 switch (type) {
 case USRQUOTA:
  kqid.uid = make_kuid(from, qid);
  break;
 case GRPQUOTA:
  kqid.gid = make_kgid(from, qid);
  break;
 case PRJQUOTA:
  kqid.projid = make_kprojid(from, qid);
  break;
 default:
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/quota.h"), "i" (114), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 }
 return kqid;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_invalid(enum quota_type type)
{
 struct kqid kqid;

 kqid.type = type;
 switch (type) {
 case USRQUOTA:
  kqid.uid = (kuid_t){ -1 };
  break;
 case GRPQUOTA:
  kqid.gid = (kgid_t){ -1 };
  break;
 case PRJQUOTA:
  kqid.projid = (kprojid_t){ -1 };
  break;
 default:
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/quota.h"), "i" (141), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 }
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_uid(kuid_t uid)
{
 struct kqid kqid;
 kqid.type = USRQUOTA;
 kqid.uid = uid;
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_gid(kgid_t gid)
{
 struct kqid kqid;
 kqid.type = GRPQUOTA;
 kqid.gid = gid;
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_projid(kprojid_t projid)
{
 struct kqid kqid;
 kqid.type = PRJQUOTA;
 kqid.projid = projid;
 return kqid;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qid_has_mapping(struct user_namespace *ns, struct kqid qid)
{
 return from_kqid(ns, qid) != (qid_t) -1;
}


extern spinlock_t dq_data_lock;
# 205 "/home/nathan/src/linux-next/include/linux/quota.h"
struct mem_dqblk {
 qsize_t dqb_bhardlimit;
 qsize_t dqb_bsoftlimit;
 qsize_t dqb_curspace;
 qsize_t dqb_rsvspace;
 qsize_t dqb_ihardlimit;
 qsize_t dqb_isoftlimit;
 qsize_t dqb_curinodes;
 time64_t dqb_btime;
 time64_t dqb_itime;
};




struct quota_format_type;

struct mem_dqinfo {
 struct quota_format_type *dqi_format;
 int dqi_fmt_id;

 struct list_head dqi_dirty_list;
 unsigned long dqi_flags;
 unsigned int dqi_bgrace;
 unsigned int dqi_igrace;
 qsize_t dqi_max_spc_limit;
 qsize_t dqi_max_ino_limit;
 void *dqi_priv;
};

struct super_block;






enum {
 DQF_INFO_DIRTY_B = DQF_PRIVATE,
};


extern void mark_info_dirty(struct super_block *sb, int type);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int info_dirty(struct mem_dqinfo *info)
{
 return test_bit(DQF_INFO_DIRTY_B, &info->dqi_flags);
}

enum {
 DQST_LOOKUPS,
 DQST_DROPS,
 DQST_READS,
 DQST_WRITES,
 DQST_CACHE_HITS,
 DQST_ALLOC_DQUOTS,
 DQST_FREE_DQUOTS,
 DQST_SYNCS,
 _DQST_DQSTAT_LAST
};

struct dqstats {
 unsigned long stat[_DQST_DQSTAT_LAST];
 struct percpu_counter counter[_DQST_DQSTAT_LAST];
};

extern struct dqstats dqstats;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dqstats_inc(unsigned int type)
{
 percpu_counter_inc(&dqstats.counter[type]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dqstats_dec(unsigned int type)
{
 percpu_counter_dec(&dqstats.counter[type]);
}
# 294 "/home/nathan/src/linux-next/include/linux/quota.h"
struct dquot {
 struct hlist_node dq_hash;
 struct list_head dq_inuse;
 struct list_head dq_free;
 struct list_head dq_dirty;
 struct mutex dq_lock;
 spinlock_t dq_dqb_lock;
 atomic_t dq_count;
 struct super_block *dq_sb;
 struct kqid dq_id;
 loff_t dq_off;
 unsigned long dq_flags;
 struct mem_dqblk dq_dqb;
};


struct quota_format_ops {
 int (*check_quota_file)(struct super_block *sb, int type);
 int (*read_file_info)(struct super_block *sb, int type);
 int (*write_file_info)(struct super_block *sb, int type);
 int (*free_file_info)(struct super_block *sb, int type);
 int (*read_dqblk)(struct dquot *dquot);
 int (*commit_dqblk)(struct dquot *dquot);
 int (*release_dqblk)(struct dquot *dquot);
 int (*get_next_id)(struct super_block *sb, struct kqid *qid);
};


struct dquot_operations {
 int (*write_dquot) (struct dquot *);
 struct dquot *(*alloc_dquot)(struct super_block *, int);
 void (*destroy_dquot)(struct dquot *);
 int (*acquire_dquot) (struct dquot *);
 int (*release_dquot) (struct dquot *);
 int (*mark_dirty) (struct dquot *);
 int (*write_info) (struct super_block *, int);


 qsize_t *(*get_reserved_space) (struct inode *);
 int (*get_projid) (struct inode *, kprojid_t *);

 int (*get_inode_usage) (struct inode *, qsize_t *);

 int (*get_next_id) (struct super_block *sb, struct kqid *qid);
};

struct path;


struct qc_dqblk {
 int d_fieldmask;
 u64 d_spc_hardlimit;
 u64 d_spc_softlimit;
 u64 d_ino_hardlimit;
 u64 d_ino_softlimit;
 u64 d_space;
 u64 d_ino_count;
 s64 d_ino_timer;

 s64 d_spc_timer;
 int d_ino_warns;
 int d_spc_warns;
 u64 d_rt_spc_hardlimit;
 u64 d_rt_spc_softlimit;
 u64 d_rt_space;
 s64 d_rt_spc_timer;
 int d_rt_spc_warns;
};
# 395 "/home/nathan/src/linux-next/include/linux/quota.h"
struct qc_type_state {
 unsigned int flags;
 unsigned int spc_timelimit;

 unsigned int ino_timelimit;
 unsigned int rt_spc_timelimit;
 unsigned int spc_warnlimit;
 unsigned int ino_warnlimit;
 unsigned int rt_spc_warnlimit;
 unsigned long long ino;
 blkcnt_t blocks;
 blkcnt_t nextents;
};

struct qc_state {
 unsigned int s_incoredqs;
 struct qc_type_state s_state[3];
};


struct qc_info {
 int i_fieldmask;
 unsigned int i_flags;
 unsigned int i_spc_timelimit;

 unsigned int i_ino_timelimit;
 unsigned int i_rt_spc_timelimit;
 unsigned int i_spc_warnlimit;
 unsigned int i_ino_warnlimit;
 unsigned int i_rt_spc_warnlimit;
};


struct quotactl_ops {
 int (*quota_on)(struct super_block *, int, int, const struct path *);
 int (*quota_off)(struct super_block *, int);
 int (*quota_enable)(struct super_block *, unsigned int);
 int (*quota_disable)(struct super_block *, unsigned int);
 int (*quota_sync)(struct super_block *, int);
 int (*set_info)(struct super_block *, int, struct qc_info *);
 int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
 int (*get_nextdqblk)(struct super_block *, struct kqid *,
        struct qc_dqblk *);
 int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
 int (*get_state)(struct super_block *, struct qc_state *);
 int (*rm_xquota)(struct super_block *, unsigned int);
};

struct quota_format_type {
 int qf_fmt_id;
 const struct quota_format_ops *qf_ops;
 struct module *qf_owner;
 struct quota_format_type *qf_next;
};
# 463 "/home/nathan/src/linux-next/include/linux/quota.h"
enum {
 _DQUOT_USAGE_ENABLED = 0,
 _DQUOT_LIMITS_ENABLED,
 _DQUOT_SUSPENDED,


 _DQUOT_STATE_FLAGS
};
# 490 "/home/nathan/src/linux-next/include/linux/quota.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dquot_state_flag(unsigned int flags, int type)
{
 return flags << type;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dquot_generic_flag(unsigned int flags, int type)
{
 return (flags >> type) & ((1 << _DQUOT_USAGE_ENABLED * 3) | (1 << _DQUOT_LIMITS_ENABLED * 3) | (1 << _DQUOT_SUSPENDED * 3));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned dquot_state_types(unsigned flags, unsigned flag)
{
 do { extern void __compiletime_assert_170(void) ; if (!(!((flag) == 0 || (((flag) & ((flag) - 1)) != 0)))) __compiletime_assert_170(); } while (0);
 return (flags / flag) & ((1 << 3) - 1);
}


extern void quota_send_warning(struct kqid qid, dev_t dev,
          const char warntype);
# 518 "/home/nathan/src/linux-next/include/linux/quota.h"
struct quota_info {
 unsigned int flags;
 struct rw_semaphore dqio_sem;
 struct inode *files[3];
 struct mem_dqinfo info[3];
 const struct quota_format_ops *ops[3];
};

int register_quota_format(struct quota_format_type *fmt);
void unregister_quota_format(struct quota_format_type *fmt);

struct quota_module_name {
 int qm_fmt_id;
 char *qm_mod_name;
};
# 251 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 284 "/home/nathan/src/linux-next/include/linux/fs.h"
enum positive_aop_returns {
 AOP_WRITEPAGE_ACTIVATE = 0x80000,
 AOP_TRUNCATED_PAGE = 0x80001,
};
# 297 "/home/nathan/src/linux-next/include/linux/fs.h"
struct page;
struct address_space;
struct writeback_control;
struct readahead_control;





enum rw_hint {
 WRITE_LIFE_NOT_SET = 0,
 WRITE_LIFE_NONE = 1,
 WRITE_LIFE_SHORT = 2,
 WRITE_LIFE_MEDIUM = 3,
 WRITE_LIFE_LONG = 4,
 WRITE_LIFE_EXTREME = 5,
};
# 326 "/home/nathan/src/linux-next/include/linux/fs.h"
struct kiocb {
 struct file *ki_filp;




 loff_t ki_pos;
 void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 void *private;
 int ki_flags;
 u16 ki_hint;
 u16 ki_ioprio;
 union {
  unsigned int ki_cookie;
  struct wait_page_queue *ki_waitq;
 };


};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_sync_kiocb(struct kiocb *kiocb)
{
 return kiocb->ki_complete == ((void *)0);
}
# 360 "/home/nathan/src/linux-next/include/linux/fs.h"
typedef struct {
 size_t written;
 size_t count;
 union {
  char *buf;
  void *data;
 } arg;
 int error;
} read_descriptor_t;

typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
  unsigned long, unsigned long);

struct address_space_operations {
 int (*writepage)(struct page *page, struct writeback_control *wbc);
 int (*readpage)(struct file *, struct page *);


 int (*writepages)(struct address_space *, struct writeback_control *);


 int (*set_page_dirty)(struct page *page);





 int (*readpages)(struct file *filp, struct address_space *mapping,
   struct list_head *pages, unsigned nr_pages);
 void (*readahead)(struct readahead_control *);

 int (*write_begin)(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned flags,
    struct page **pagep, void **fsdata);
 int (*write_end)(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned copied,
    struct page *page, void *fsdata);


 sector_t (*bmap)(struct address_space *, sector_t);
 void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 int (*releasepage) (struct page *, gfp_t);
 void (*freepage)(struct page *);
 ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);




 int (*migratepage) (struct address_space *,
   struct page *, struct page *, enum migrate_mode);
 bool (*isolate_page)(struct page *, isolate_mode_t);
 void (*putback_page)(struct page *);
 int (*launder_page) (struct page *);
 int (*is_partially_uptodate) (struct page *, unsigned long,
     unsigned long);
 void (*is_dirty_writeback) (struct page *, bool *, bool *);
 int (*error_remove_page)(struct address_space *, struct page *);


 int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
    sector_t *span);
 void (*swap_deactivate)(struct file *file);
};

extern const struct address_space_operations empty_aops;





int pagecache_write_begin(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned flags,
    struct page **pagep, void **fsdata);

int pagecache_write_end(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned copied,
    struct page *page, void *fsdata);
# 457 "/home/nathan/src/linux-next/include/linux/fs.h"
struct address_space {
 struct inode *host;
 struct xarray i_pages;
 gfp_t gfp_mask;
 atomic_t i_mmap_writable;




 struct rb_root_cached i_mmap;
 struct rw_semaphore i_mmap_rwsem;
 unsigned long nrpages;
 unsigned long nrexceptional;
 unsigned long writeback_index;
 const struct address_space_operations *a_ops;
 unsigned long flags;
 errseq_t wb_err;
 spinlock_t private_lock;
 struct list_head private_list;
 void *private_data;
} __attribute__((aligned(sizeof(long)))) ;





struct request_queue;

struct block_device {
 dev_t bd_dev;
 int bd_openers;
 struct inode * bd_inode;
 struct super_block * bd_super;
 struct mutex bd_mutex;
 void * bd_claiming;
 void * bd_holder;
 int bd_holders;
 bool bd_write_holder;

 struct list_head bd_holder_disks;

 struct block_device * bd_contains;
 unsigned bd_block_size;
 u8 bd_partno;
 struct hd_struct * bd_part;

 unsigned bd_part_count;
 int bd_invalidated;
 struct gendisk * bd_disk;
 struct request_queue * bd_queue;
 struct backing_dev_info *bd_bdi;
 struct list_head bd_list;






 unsigned long bd_private;


 int bd_fsfreeze_count;

 struct mutex bd_fsfreeze_mutex;
} ;
# 531 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)
{
 return xa_marked(&mapping->i_pages, tag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_lock_write(struct address_space *mapping)
{
 down_write(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int i_mmap_trylock_write(struct address_space *mapping)
{
 return down_write_trylock(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_unlock_write(struct address_space *mapping)
{
 up_write(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_lock_read(struct address_space *mapping)
{
 down_read(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_unlock_read(struct address_space *mapping)
{
 up_read(&mapping->i_mmap_rwsem);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_mapped(struct address_space *mapping)
{
 return !(({ do { extern void __compiletime_assert_171(void) ; if (!((sizeof((&mapping->i_mmap.rb_root)->rb_node) == sizeof(char) || sizeof((&mapping->i_mmap.rb_root)->rb_node) == sizeof(short) || sizeof((&mapping->i_mmap.rb_root)->rb_node) == sizeof(int) || sizeof((&mapping->i_mmap.rb_root)->rb_node) == sizeof(long)) || sizeof((&mapping->i_mmap.rb_root)->rb_node) == sizeof(long long))) __compiletime_assert_171(); } while (0); ({ typeof( _Generic(((&mapping->i_mmap.rb_root)->rb_node), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&mapping->i_mmap.rb_root)->rb_node))) __x = (*(const volatile typeof( _Generic(((&mapping->i_mmap.rb_root)->rb_node), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&mapping->i_mmap.rb_root)->rb_node))) *)&((&mapping->i_mmap.rb_root)->rb_node)); do { } while (0); (typeof((&mapping->i_mmap.rb_root)->rb_node))__x; }); }) == ((void *)0));
}
# 578 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_writably_mapped(struct address_space *mapping)
{
 return atomic_read(&mapping->i_mmap_writable) > 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_map_writable(struct address_space *mapping)
{
 return atomic_inc_unless_negative(&mapping->i_mmap_writable) ?
  0 : -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_unmap_writable(struct address_space *mapping)
{
 atomic_dec(&mapping->i_mmap_writable);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_deny_writable(struct address_space *mapping)
{
 return atomic_dec_unless_positive(&mapping->i_mmap_writable) ?
  0 : -16;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_allow_writable(struct address_space *mapping)
{
 atomic_inc(&mapping->i_mmap_writable);
}
# 616 "/home/nathan/src/linux-next/include/linux/fs.h"
struct posix_acl;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct posix_acl *
uncached_acl_sentinel(struct task_struct *task)
{
 return (void *)task + 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
is_uncached_acl(struct posix_acl *acl)
{
 return (long)acl & 1;
}







struct fsnotify_mark_connector;






struct inode {
 umode_t i_mode;
 unsigned short i_opflags;
 kuid_t i_uid;
 kgid_t i_gid;
 unsigned int i_flags;


 struct posix_acl *i_acl;
 struct posix_acl *i_default_acl;


 const struct inode_operations *i_op;
 struct super_block *i_sb;
 struct address_space *i_mapping;


 void *i_security;



 unsigned long i_ino;







 union {
  const unsigned int i_nlink;
  unsigned int __i_nlink;
 };
 dev_t i_rdev;
 loff_t i_size;
 struct timespec64 i_atime;
 struct timespec64 i_mtime;
 struct timespec64 i_ctime;
 spinlock_t i_lock;
 unsigned short i_bytes;
 u8 i_blkbits;
 u8 i_write_hint;
 blkcnt_t i_blocks;






 unsigned long i_state;
 struct rw_semaphore i_rwsem;

 unsigned long dirtied_when;
 unsigned long dirtied_time_when;

 struct hlist_node i_hash;
 struct list_head i_io_list;

 struct bdi_writeback *i_wb;


 int i_wb_frn_winner;
 u16 i_wb_frn_avg_time;
 u16 i_wb_frn_history;

 struct list_head i_lru;
 struct list_head i_sb_list;
 struct list_head i_wb_list;
 union {
  struct hlist_head i_dentry;
  struct callback_head i_rcu;
 };
 atomic64_t i_version;
 atomic64_t i_sequence;
 atomic_t i_count;
 atomic_t i_dio_count;
 atomic_t i_writecount;

 atomic_t i_readcount;

 union {
  const struct file_operations *i_fop;
  void (*free_inode)(struct inode *);
 };
 struct file_lock_context *i_flctx;
 struct address_space i_data;
 struct list_head i_devices;
 union {
  struct pipe_inode_info *i_pipe;
  struct block_device *i_bdev;
  struct cdev *i_cdev;
  char *i_link;
  unsigned i_dir_seq;
 };

 __u32 i_generation;


 __u32 i_fsnotify_mask;
 struct fsnotify_mark_connector *i_fsnotify_marks;



 struct fscrypt_info *i_crypt_info;



 struct fsverity_info *i_verity_info;


 void *i_private;
} ;

struct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int i_blocksize(const struct inode *node)
{
 return (1 << node->i_blkbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_unhashed(struct inode *inode)
{
 return hlist_unhashed(&inode->i_hash);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_fake_hash(struct inode *inode)
{
 hlist_add_fake(&inode->i_hash);
}
# 797 "/home/nathan/src/linux-next/include/linux/fs.h"
enum inode_i_mutex_lock_class
{
 I_MUTEX_NORMAL,
 I_MUTEX_PARENT,
 I_MUTEX_CHILD,
 I_MUTEX_XATTR,
 I_MUTEX_NONDIR2,
 I_MUTEX_PARENT2,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock(struct inode *inode)
{
 down_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_unlock(struct inode *inode)
{
 up_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_shared(struct inode *inode)
{
 down_read(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_unlock_shared(struct inode *inode)
{
 up_read(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_trylock(struct inode *inode)
{
 return down_write_trylock(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_trylock_shared(struct inode *inode)
{
 return down_read_trylock(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_is_locked(struct inode *inode)
{
 return rwsem_is_locked(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_nested(struct inode *inode, unsigned subclass)
{
 down_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_shared_nested(struct inode *inode, unsigned subclass)
{
 down_read(&inode->i_rwsem);
}

void lock_two_nondirectories(struct inode *, struct inode*);
void unlock_two_nondirectories(struct inode *, struct inode*);
# 865 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t i_size_read(const struct inode *inode)
{
# 884 "/home/nathan/src/linux-next/include/linux/fs.h"
 return inode->i_size;

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_size_write(struct inode *inode, loff_t i_size)
{
# 906 "/home/nathan/src/linux-next/include/linux/fs.h"
 inode->i_size = i_size;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned iminor(const struct inode *inode)
{
 return ((unsigned int) ((inode->i_rdev) & ((1U << 20) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned imajor(const struct inode *inode)
{
 return ((unsigned int) ((inode->i_rdev) >> 20));
}

extern struct block_device *I_BDEV(struct inode *inode);

struct fown_struct {
 rwlock_t lock;
 struct pid *pid;
 enum pid_type pid_type;
 kuid_t uid, euid;
 int signum;
};




struct file_ra_state {
 unsigned long start;
 unsigned int size;
 unsigned int async_size;


 unsigned int ra_pages;
 unsigned int mmap_miss;
 loff_t prev_pos;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ra_has_index(struct file_ra_state *ra, unsigned long index)
{
 return (index >= ra->start &&
  index < ra->start + ra->size);
}

struct file {
 union {
  struct llist_node fu_llist;
  struct callback_head fu_rcuhead;
 } f_u;
 struct path f_path;
 struct inode *f_inode;
 const struct file_operations *f_op;





 spinlock_t f_lock;
 enum rw_hint f_write_hint;
 atomic_long_t f_count;
 unsigned int f_flags;
 fmode_t f_mode;
 struct mutex f_pos_lock;
 loff_t f_pos;
 struct fown_struct f_owner;
 const struct cred *f_cred;
 struct file_ra_state f_ra;

 u64 f_version;

 void *f_security;


 void *private_data;



 struct list_head f_ep_links;
 struct list_head f_tfile_llink;

 struct address_space *f_mapping;
 errseq_t f_wb_err;
 errseq_t f_sb_err;
}
  __attribute__((aligned(4)));

struct file_handle {
 __u32 handle_bytes;
 int handle_type;

 unsigned char f_handle[];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct file *get_file(struct file *f)
{
 atomic_long_inc(&f->f_count);
 return f;
}
# 1044 "/home/nathan/src/linux-next/include/linux/fs.h"
typedef void *fl_owner_t;

struct file_lock;

struct file_lock_operations {
 void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 void (*fl_release_private)(struct file_lock *);
};

struct lock_manager_operations {
 fl_owner_t (*lm_get_owner)(fl_owner_t);
 void (*lm_put_owner)(fl_owner_t);
 void (*lm_notify)(struct file_lock *);
 int (*lm_grant)(struct file_lock *, int);
 bool (*lm_break)(struct file_lock *);
 int (*lm_change)(struct file_lock *, int, struct list_head *);
 void (*lm_setup)(struct file_lock *, void **);
 bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct lock_manager {
 struct list_head list;




 bool block_opens;
};

struct net;
void locks_start_grace(struct net *, struct lock_manager *);
void locks_end_grace(struct lock_manager *);
bool locks_in_grace(struct net *);
bool opens_in_grace(struct net *);



# 1 "/home/nathan/src/linux-next/include/linux/nfs_fs_i.h" 1




struct nlm_lockowner;




struct nfs_lock_info {
 u32 state;
 struct nlm_lockowner *owner;
 struct list_head list;
};

struct nfs4_lock_state;
struct nfs4_lock_info {
 struct nfs4_lock_state *owner;
};
# 1081 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1099 "/home/nathan/src/linux-next/include/linux/fs.h"
struct file_lock {
 struct file_lock *fl_blocker;
 struct list_head fl_list;
 struct hlist_node fl_link;
 struct list_head fl_blocked_requests;


 struct list_head fl_blocked_member;


 fl_owner_t fl_owner;
 unsigned int fl_flags;
 unsigned char fl_type;
 unsigned int fl_pid;
 int fl_link_cpu;
 wait_queue_head_t fl_wait;
 struct file *fl_file;
 loff_t fl_start;
 loff_t fl_end;

 struct fasync_struct * fl_fasync;

 unsigned long fl_break_time;
 unsigned long fl_downgrade_time;

 const struct file_lock_operations *fl_ops;
 const struct lock_manager_operations *fl_lmops;
 union {
  struct nfs_lock_info nfs_fl;
  struct nfs4_lock_info nfs4_fl;
  struct {
   struct list_head link;
   int state;
   unsigned int debug_id;
  } afs;
 } fl_u;
} ;

struct file_lock_context {
 spinlock_t flc_lock;
 struct list_head flc_flock;
 struct list_head flc_posix;
 struct list_head flc_lease;
};
# 1151 "/home/nathan/src/linux-next/include/linux/fs.h"
extern void send_sigio(struct fown_struct *fown, int fd, int band);




extern int fcntl_getlk(struct file *, unsigned int, struct flock *);
extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
   struct flock *);







extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
extern int fcntl_getlease(struct file *filp);


void locks_free_lock_context(struct inode *inode);
void locks_free_lock(struct file_lock *fl);
extern void locks_init_lock(struct file_lock *);
extern struct file_lock * locks_alloc_lock(void);
extern void locks_copy_lock(struct file_lock *, struct file_lock *);
extern void locks_copy_conflock(struct file_lock *, struct file_lock *);
extern void locks_remove_posix(struct file *, fl_owner_t);
extern void locks_remove_file(struct file *);
extern void locks_release_private(struct file_lock *);
extern void posix_test_lock(struct file *, struct file_lock *);
extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
extern int locks_delete_block(struct file_lock *);
extern int vfs_test_lock(struct file *, struct file_lock *);
extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
extern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);
extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
extern void lease_get_mtime(struct inode *, struct timespec64 *time);
extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
extern int lease_modify(struct file_lock *, int, struct list_head *);

struct notifier_block;
extern int lease_register_notifier(struct notifier_block *);
extern void lease_unregister_notifier(struct notifier_block *);

struct files_struct;
extern void show_fd_locks(struct seq_file *f,
    struct file *filp, struct files_struct *files);
# 1336 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *file_inode(const struct file *f)
{
 return f->f_inode;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *file_dentry(const struct file *file)
{
 return d_real(file->f_path.dentry, file_inode(file));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
{
 return locks_lock_inode_wait(file_inode(filp), fl);
}

struct fasync_struct {
 rwlock_t fa_lock;
 int magic;
 int fa_fd;
 struct fasync_struct *fa_next;
 struct file *fa_file;
 struct callback_head fa_rcu;
};




extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
extern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);
extern int fasync_remove_entry(struct file *, struct fasync_struct **);
extern struct fasync_struct *fasync_alloc(void);
extern void fasync_free(struct fasync_struct *);


extern void kill_fasync(struct fasync_struct **, int, int);

extern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
extern int f_setown(struct file *filp, unsigned long arg, int force);
extern void f_delown(struct file *filp);
extern pid_t f_getown(struct file *filp);
extern int send_sigurg(struct fown_struct *fown);
# 1429 "/home/nathan/src/linux-next/include/linux/fs.h"
enum {
 SB_UNFROZEN = 0,
 SB_FREEZE_WRITE = 1,
 SB_FREEZE_PAGEFAULT = 2,
 SB_FREEZE_FS = 3,

 SB_FREEZE_COMPLETE = 4,
};



struct sb_writers {
 int frozen;
 wait_queue_head_t wait_unfrozen;
 struct percpu_rw_semaphore rw_sem[(SB_FREEZE_COMPLETE - 1)];
};

struct super_block {
 struct list_head s_list;
 dev_t s_dev;
 unsigned char s_blocksize_bits;
 unsigned long s_blocksize;
 loff_t s_maxbytes;
 struct file_system_type *s_type;
 const struct super_operations *s_op;
 const struct dquot_operations *dq_op;
 const struct quotactl_ops *s_qcop;
 const struct export_operations *s_export_op;
 unsigned long s_flags;
 unsigned long s_iflags;
 unsigned long s_magic;
 struct dentry *s_root;
 struct rw_semaphore s_umount;
 int s_count;
 atomic_t s_active;

 void *s_security;

 const struct xattr_handler **s_xattr;

 const struct fscrypt_operations *s_cop;
 struct key *s_master_keys;


 const struct fsverity_operations *s_vop;

 struct hlist_bl_head s_roots;
 struct list_head s_mounts;
 struct block_device *s_bdev;
 struct backing_dev_info *s_bdi;
 struct mtd_info *s_mtd;
 struct hlist_node s_instances;
 unsigned int s_quota_types;
 struct quota_info s_dquot;

 struct sb_writers s_writers;






 void *s_fs_info;


 u32 s_time_gran;

 time64_t s_time_min;
 time64_t s_time_max;

 __u32 s_fsnotify_mask;
 struct fsnotify_mark_connector *s_fsnotify_marks;


 char s_id[32];
 uuid_t s_uuid;

 unsigned int s_max_links;
 fmode_t s_mode;





 struct mutex s_vfs_rename_mutex;





 const char *s_subtype;

 const struct dentry_operations *s_d_op;




 int cleancache_poolid;

 struct shrinker s_shrink;


 atomic_long_t s_remove_count;


 atomic_long_t s_fsnotify_inode_refs;


 int s_readonly_remount;


 errseq_t s_wb_err;


 struct workqueue_struct *s_dio_done_wq;
 struct hlist_head s_pins;






 struct user_namespace *s_user_ns;






 struct list_lru s_dentry_lru;
 struct list_lru s_inode_lru;
 struct callback_head rcu;
 struct work_struct destroy_work;

 struct mutex s_sync_lock;




 int s_stack_depth;


 spinlock_t s_inode_list_lock __attribute__((__aligned__((1 << 7))));
 struct list_head s_inodes;

 spinlock_t s_inode_wblist_lock;
 struct list_head s_inodes_wb;


 u64 s_unique_id;




 atomic_t s_change_counter;
 atomic_t s_notify_counter;
} ;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t i_uid_read(const struct inode *inode)
{
 return from_kuid(inode->i_sb->s_user_ns, inode->i_uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t i_gid_read(const struct inode *inode)
{
 return from_kgid(inode->i_sb->s_user_ns, inode->i_gid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_uid_write(struct inode *inode, uid_t uid)
{
 inode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_gid_write(struct inode *inode, gid_t gid)
{
 inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
}

extern struct timespec64 current_time(struct inode *inode);





void __sb_end_write(struct super_block *sb, int level);
int __sb_start_write(struct super_block *sb, int level, bool wait);
# 1633 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_write(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_WRITE);
}
# 1645 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_pagefault(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_PAGEFAULT);
}
# 1657 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_intwrite(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_FS);
}
# 1681 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_write(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_WRITE, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_start_write_trylock(struct super_block *sb)
{
 return __sb_start_write(sb, SB_FREEZE_WRITE, false);
}
# 1710 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_pagefault(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_PAGEFAULT, true);
}
# 1728 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_intwrite(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_FS, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_start_intwrite_trylock(struct super_block *sb)
{
 return __sb_start_write(sb, SB_FREEZE_FS, false);
}


extern bool inode_owner_or_capable(const struct inode *inode);




extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
extern int vfs_symlink(struct inode *, struct dentry *, const char *);
extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
extern int vfs_rmdir(struct inode *, struct dentry *);
extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_whiteout(struct inode *dir, struct dentry *dentry)
{
 return vfs_mknod(dir, dentry, 0020000 | 0, 0);
}

extern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,
      int open_flag);

int vfs_mkobj(struct dentry *, umode_t,
  int (*f)(struct dentry *, umode_t, void *),
  void *);

extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);


extern long compat_ptr_ioctl(struct file *file, unsigned int cmd,
     unsigned long arg);







extern void inode_init_owner(struct inode *inode, const struct inode *dir,
   umode_t mode);
extern bool may_open_dev(const struct path *path);







struct dir_context;
typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
    unsigned);

struct dir_context {
 filldir_t actor;
 loff_t pos;
};

struct block_device_operations;
# 1843 "/home/nathan/src/linux-next/include/linux/fs.h"
struct iov_iter;

struct file_operations {
 struct module *owner;
 loff_t (*llseek) (struct file *, loff_t, int);
 ssize_t (*read) (struct file *, char *, size_t, loff_t *);
 ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
 ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 int (*iopoll)(struct kiocb *kiocb, bool spin);
 int (*iterate) (struct file *, struct dir_context *);
 int (*iterate_shared) (struct file *, struct dir_context *);
 __poll_t (*poll) (struct file *, struct poll_table_struct *);
 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 int (*mmap) (struct file *, struct vm_area_struct *);
 unsigned long mmap_supported_flags;
 int (*open) (struct inode *, struct file *);
 int (*flush) (struct file *, fl_owner_t id);
 int (*release) (struct inode *, struct file *);
 int (*fsync) (struct file *, loff_t, loff_t, int datasync);
 int (*fasync) (int, struct file *, int);
 int (*lock) (struct file *, int, struct file_lock *);
 ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
 unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
 int (*check_flags)(int);
 int (*flock) (struct file *, int, struct file_lock *);
 ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 int (*setlease)(struct file *, long, struct file_lock **, void **);
 long (*fallocate)(struct file *file, int mode, loff_t offset,
     loff_t len);
 void (*show_fdinfo)(struct seq_file *m, struct file *f);



 ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
   loff_t, size_t, unsigned int);
 loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
       struct file *file_out, loff_t pos_out,
       loff_t len, unsigned int remap_flags);
 int (*fadvise)(struct file *, loff_t, loff_t, int);
} ;

struct inode_operations {
 struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
 const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);
 int (*permission) (struct inode *, int);
 struct posix_acl * (*get_acl)(struct inode *, int);

 int (*readlink) (struct dentry *, char *,int);

 int (*create) (struct inode *,struct dentry *, umode_t, bool);
 int (*link) (struct dentry *,struct inode *,struct dentry *);
 int (*unlink) (struct inode *,struct dentry *);
 int (*symlink) (struct inode *,struct dentry *,const char *);
 int (*mkdir) (struct inode *,struct dentry *,umode_t);
 int (*rmdir) (struct inode *,struct dentry *);
 int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 int (*rename) (struct inode *, struct dentry *,
   struct inode *, struct dentry *, unsigned int);
 int (*setattr) (struct dentry *, struct iattr *);
 int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);
 ssize_t (*listxattr) (struct dentry *, char *, size_t);
 int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
        u64 len);
 int (*update_time)(struct inode *, struct timespec64 *, int);
 int (*atomic_open)(struct inode *, struct dentry *,
      struct file *, unsigned open_flag,
      umode_t create_mode);
 int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 int (*set_acl)(struct inode *, struct posix_acl *, int);
} __attribute__((__aligned__((1 << 7))));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t call_read_iter(struct file *file, struct kiocb *kio,
         struct iov_iter *iter)
{
 return file->f_op->read_iter(kio, iter);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t call_write_iter(struct file *file, struct kiocb *kio,
          struct iov_iter *iter)
{
 return file->f_op->write_iter(kio, iter);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int call_mmap(struct file *file, struct vm_area_struct *vma)
{
 return file->f_op->mmap(file, vma);
}

ssize_t rw_copy_check_uvector(int type, const struct iovec * uvector,
         unsigned long nr_segs, unsigned long fast_segs,
         struct iovec *fast_pointer,
         struct iovec **ret_pointer);

extern ssize_t __vfs_read(struct file *, char *, size_t, loff_t *);
extern ssize_t vfs_read(struct file *, char *, size_t, loff_t *);
extern ssize_t vfs_write(struct file *, const char *, size_t, loff_t *);
extern ssize_t vfs_readv(struct file *, const struct iovec *,
  unsigned long, loff_t *, rwf_t);
extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
       loff_t, size_t, unsigned int);
extern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,
           struct file *file_out, loff_t pos_out,
           size_t len, unsigned int flags);
extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
      struct file *file_out, loff_t pos_out,
      loff_t *count,
      unsigned int remap_flags);
extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
      struct file *file_out, loff_t pos_out,
      loff_t len, unsigned int remap_flags);
extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
       struct file *file_out, loff_t pos_out,
       loff_t len, unsigned int remap_flags);
extern int vfs_dedupe_file_range(struct file *file,
     struct file_dedupe_range *same);
extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
     struct file *dst_file, loff_t dst_pos,
     loff_t len, unsigned int remap_flags);


struct super_operations {
    struct inode *(*alloc_inode)(struct super_block *sb);
 void (*destroy_inode)(struct inode *);
 void (*free_inode)(struct inode *);

    void (*dirty_inode) (struct inode *, int flags);
 int (*write_inode) (struct inode *, struct writeback_control *wbc);
 int (*drop_inode) (struct inode *);
 void (*evict_inode) (struct inode *);
 void (*put_super) (struct super_block *);
 int (*sync_fs)(struct super_block *sb, int wait);
 int (*freeze_super) (struct super_block *);
 int (*freeze_fs) (struct super_block *);
 int (*thaw_super) (struct super_block *);
 int (*unfreeze_fs) (struct super_block *);
 int (*statfs) (struct dentry *, struct kstatfs *);



 int (*remount_fs) (struct super_block *, int *, char *);
 void (*umount_begin) (struct super_block *);

 int (*show_options)(struct seq_file *, struct dentry *);
 int (*show_devname)(struct seq_file *, struct dentry *);
 int (*show_path)(struct seq_file *, struct dentry *);
 int (*show_stats)(struct seq_file *, struct dentry *);

 ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 struct dquot **(*get_dquots)(struct inode *);

 int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 long (*nr_cached_objects)(struct super_block *,
      struct shrink_control *);
 long (*free_cached_objects)(struct super_block *,
        struct shrink_control *);
};
# 2044 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & 1; }
# 2074 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool HAS_UNMAPPED_ID(struct inode *inode)
{
 return !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum rw_hint file_write_hint(struct file *file)
{
 if (file->f_write_hint != WRITE_LIFE_NOT_SET)
  return file->f_write_hint;

 return file_inode(file)->i_write_hint;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int iocb_flags(struct file *file);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 ki_hint_validate(enum rw_hint hint)
{
 typeof(((struct kiocb *)0)->ki_hint) max_hint = -1;

 if (hint <= max_hint)
  return hint;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
{
 *kiocb = (struct kiocb) {
  .ki_filp = filp,
  .ki_flags = iocb_flags(filp),
  .ki_hint = ki_hint_validate(file_write_hint(filp)),
  .ki_ioprio = get_current_ioprio(),
 };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,
          struct file *filp)
{
 *kiocb = (struct kiocb) {
  .ki_filp = filp,
  .ki_flags = kiocb_src->ki_flags,
  .ki_hint = kiocb_src->ki_hint,
  .ki_ioprio = kiocb_src->ki_ioprio,
  .ki_pos = kiocb_src->ki_pos,
 };
}
# 2214 "/home/nathan/src/linux-next/include/linux/fs.h"
extern void __mark_inode_dirty(struct inode *, int);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_inode_dirty(struct inode *inode)
{
 __mark_inode_dirty(inode, (((1 << 0) | (1 << 1)) | (1 << 2)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_inode_dirty_sync(struct inode *inode)
{
 __mark_inode_dirty(inode, (1 << 0));
}

extern void inc_nlink(struct inode *inode);
extern void drop_nlink(struct inode *inode);
extern void clear_nlink(struct inode *inode);
extern void set_nlink(struct inode *inode, unsigned int nlink);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_inc_link_count(struct inode *inode)
{
 inc_nlink(inode);
 mark_inode_dirty(inode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dec_link_count(struct inode *inode)
{
 drop_nlink(inode);
 mark_inode_dirty(inode);
}

enum file_time_flags {
 S_ATIME = 1,
 S_MTIME = 2,
 S_CTIME = 4,
 S_VERSION = 8,
};

extern bool atime_needs_update(const struct path *, struct inode *);
extern void touch_atime(const struct path *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_accessed(struct file *file)
{
 if (!(file->f_flags & 01000000))
  touch_atime(&file->f_path);
}

extern int file_modified(struct file *file);

int sync_inode(struct inode *inode, struct writeback_control *wbc);
int sync_inode_metadata(struct inode *inode, int wait);

struct file_system_type {
 const char *name;
 int fs_flags;






 int (*init_fs_context)(struct fs_context *);
 const struct fs_parameter_spec *parameters;
 struct dentry *(*mount) (struct file_system_type *, int,
         const char *, void *);
 void (*kill_sb) (struct super_block *);
 struct module *owner;
 struct file_system_type * next;
 struct hlist_head fs_supers;

 struct lock_class_key s_lock_key;
 struct lock_class_key s_umount_key;
 struct lock_class_key s_vfs_rename_key;
 struct lock_class_key s_writers_key[(SB_FREEZE_COMPLETE - 1)];

 struct lock_class_key i_lock_key;
 struct lock_class_key i_mutex_key;
 struct lock_class_key i_mutex_dir_key;
};




extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 int flags, const char *dev_name, void *data,
 int (*fill_super)(struct super_block *, void *, int));
# 2304 "/home/nathan/src/linux-next/include/linux/fs.h"
extern struct dentry *mount_single(struct file_system_type *fs_type,
 int flags, void *data,
 int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_nodev(struct file_system_type *fs_type,
 int flags, void *data,
 int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);
void generic_shutdown_super(struct super_block *sb);

void kill_block_super(struct super_block *sb);






void kill_anon_super(struct super_block *sb);
void kill_litter_super(struct super_block *sb);
void deactivate_super(struct super_block *sb);
void deactivate_locked_super(struct super_block *sb);
int set_anon_super(struct super_block *s, void *data);
int set_anon_super_fc(struct super_block *s, struct fs_context *fc);
int get_anon_bdev(dev_t *);
void free_anon_bdev(dev_t);
struct super_block *sget_fc(struct fs_context *fc,
       int (*test)(struct super_block *, struct fs_context *),
       int (*set)(struct super_block *, struct fs_context *));
struct super_block *sget(struct file_system_type *type,
   int (*test)(struct super_block *,void *),
   int (*set)(struct super_block *,void *),
   int flags, void *data);
# 2353 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);
extern struct vfsmount *kern_mount(struct file_system_type *);
extern void kern_unmount(struct vfsmount *mnt);
extern int may_umount_tree(struct vfsmount *);
extern int may_umount(struct vfsmount *);
extern long do_mount(const char *, const char *,
       const char *, unsigned long, void *);
extern struct vfsmount *collect_mounts(const struct path *);
extern void drop_collected_mounts(struct vfsmount *);
extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
     struct vfsmount *);
extern int vfs_statfs(const struct path *, struct kstatfs *);
extern int user_statfs(const char *, struct kstatfs *);
extern int fd_statfs(int, struct kstatfs *);
extern int freeze_super(struct super_block *super);
extern int thaw_super(struct super_block *super);
extern bool our_mnt(struct vfsmount *mnt);
extern __attribute__((__format__(printf, 2, 3)))
int super_setup_bdi_name(struct super_block *sb, char *fmt, ...);
extern int super_setup_bdi(struct super_block *sb);

extern int current_umask(void);

extern void ihold(struct inode * inode);
extern void iput(struct inode *);
extern int generic_update_time(struct inode *, struct timespec64 *, int);


extern struct kobject *fs_kobj;
# 2435 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_mandatory_locked(struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_mandatory_area(struct inode *inode, struct file *filp,
                                       loff_t start, loff_t end, unsigned char type)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __mandatory_lock(struct inode *inode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mandatory_lock(struct inode *inode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_verify_locked(struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_verify_truncate(struct inode *inode, struct file *filp,
     size_t size)
{
 return 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_lease(struct inode *inode, unsigned int mode)
{






 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode, mode, 32);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_deleg(struct inode *inode, unsigned int mode)
{






 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode, mode, 4);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
 int ret;

 ret = break_deleg(inode, 00000001|00004000);
 if (ret == -11 && delegated_inode) {
  *delegated_inode = inode;
  ihold(inode);
 }
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_deleg_wait(struct inode **delegated_inode)
{
 int ret;

 ret = break_deleg(*delegated_inode, 00000001);
 iput(*delegated_inode);
 *delegated_inode = ((void *)0);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_layout(struct inode *inode, bool wait)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode,
    wait ? 00000001 : 00000001 | 00004000,
    2048);
 return 0;
}
# 2561 "/home/nathan/src/linux-next/include/linux/fs.h"
struct audit_names;
struct filename {
 const char *name;
 const char *uptr;
 int refcnt;
 struct audit_names *aname;
 const char iname[];
};
_Static_assert(__builtin_offsetof(struct filename, iname) % sizeof(long) == 0, "offsetof(struct filename, iname) % sizeof(long) == 0");

extern long vfs_truncate(const struct path *, loff_t);
extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
         struct file *filp);
extern int vfs_fallocate(struct file *file, int mode, loff_t offset,
   loff_t len);
extern long do_sys_open(int dfd, const char *filename, int flags,
   umode_t mode);
extern struct file *file_open_name(struct filename *, int, umode_t);
extern struct file *filp_open(const char *, int, umode_t);
extern struct file *file_open_root(struct dentry *, struct vfsmount *,
       const char *, int, umode_t);
extern struct file * dentry_open(const struct path *, int, const struct cred *);
extern struct file * open_with_fake_path(const struct path *, int,
      struct inode*, const struct cred *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct file *file_clone_open(struct file *file)
{
 return dentry_open(&file->f_path, file->f_flags, file->f_cred);
}
extern int filp_close(struct file *, fl_owner_t id);

extern struct filename *getname_flags(const char *, int, int *);
extern struct filename *getname(const char *);
extern struct filename *getname_kernel(const char *);
extern void putname(struct filename *name);

extern int finish_open(struct file *file, struct dentry *dentry,
   int (*open)(struct inode *, struct file *));
extern int finish_no_open(struct file *file, struct dentry *dentry);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) vfs_caches_init_early(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) vfs_caches_init(void);

extern struct kmem_cache *names_cachep;





extern int register_blkdev(unsigned int, const char *);
extern void unregister_blkdev(unsigned int, const char *);
extern struct block_device *bdget(dev_t);
extern struct block_device *bdgrab(struct block_device *bdev);
extern void bd_set_size(struct block_device *, loff_t size);
extern void bd_forget(struct inode *inode);
extern void bdput(struct block_device *);
extern void invalidate_bdev(struct block_device *);
extern void iterate_bdevs(void (*)(struct block_device *, void *), void *);
extern int sync_blockdev(struct block_device *bdev);
extern void kill_bdev(struct block_device *);
extern struct super_block *freeze_bdev(struct block_device *);
extern void emergency_thaw_all(void);
extern void emergency_thaw_bdev(struct super_block *sb);
extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
extern int fsync_bdev(struct block_device *);

extern struct super_block *blockdev_superblock;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sb_is_blkdev_sb(struct super_block *sb)
{
 return sb == blockdev_superblock;
}
# 2663 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int sync_filesystem(struct super_block *);
extern const struct file_operations def_blk_fops;
extern const struct file_operations def_chr_fops;

extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);
extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
            void *holder);
extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
           void *holder);
extern struct block_device *bd_start_claiming(struct block_device *bdev,
           void *holder);
extern void bd_finish_claiming(struct block_device *bdev,
          struct block_device *whole, void *holder);
extern void bd_abort_claiming(struct block_device *bdev,
         struct block_device *whole, void *holder);
extern void blkdev_put(struct block_device *bdev, fmode_t mode);


extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
extern void bd_unlink_disk_holder(struct block_device *bdev,
      struct gendisk *disk);
# 2707 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
extern int register_chrdev_region(dev_t, unsigned, const char *);
extern int __register_chrdev(unsigned int major, unsigned int baseminor,
        unsigned int count, const char *name,
        const struct file_operations *fops);
extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
    unsigned int count, const char *name);
extern void unregister_chrdev_region(dev_t, unsigned);
extern void chrdev_show(struct seq_file *,off_t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_chrdev(unsigned int major, const char *name,
      const struct file_operations *fops)
{
 return __register_chrdev(major, 0, 256, name, fops);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unregister_chrdev(unsigned int major, const char *name)
{
 __unregister_chrdev(major, 0, 256, name);
}







extern const char *bdevname(struct block_device *bdev, char *buffer);
extern struct block_device *lookup_bdev(const char *);
extern void blkdev_show(struct seq_file *,off_t);





extern void init_special_inode(struct inode *, umode_t, dev_t);


extern void make_bad_inode(struct inode *);
extern bool is_bad_inode(struct inode *);


extern int revalidate_disk(struct gendisk *);
extern int check_disk_change(struct block_device *);
extern int __invalidate_device(struct block_device *, bool);

unsigned long invalidate_mapping_pages(struct address_space *mapping,
     unsigned long start, unsigned long end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void invalidate_remote_inode(struct inode *inode)
{
 if ((((inode->i_mode) & 00170000) == 0100000) || (((inode->i_mode) & 00170000) == 0040000) ||
     (((inode->i_mode) & 00170000) == 0120000))
  invalidate_mapping_pages(inode->i_mapping, 0, -1);
}
extern int invalidate_inode_pages2(struct address_space *mapping);
extern int invalidate_inode_pages2_range(struct address_space *mapping,
      unsigned long start, unsigned long end);
extern int write_inode_now(struct inode *, int);
extern int filemap_fdatawrite(struct address_space *);
extern int filemap_flush(struct address_space *);
extern int filemap_fdatawait_keep_errors(struct address_space *mapping);
extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
       loff_t lend);
extern int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
  loff_t start_byte, loff_t end_byte);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_fdatawait(struct address_space *mapping)
{
 return filemap_fdatawait_range(mapping, 0, ((long long)(~0ULL >> 1)));
}

extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
      loff_t lend);
extern int filemap_write_and_wait_range(struct address_space *mapping,
            loff_t lstart, loff_t lend);
extern int __filemap_fdatawrite_range(struct address_space *mapping,
    loff_t start, loff_t end, int sync_mode);
extern int filemap_fdatawrite_range(struct address_space *mapping,
    loff_t start, loff_t end);
extern int filemap_check_errors(struct address_space *mapping);
extern void __filemap_set_wb_err(struct address_space *mapping, int err);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_write_and_wait(struct address_space *mapping)
{
 return filemap_write_and_wait_range(mapping, 0, ((long long)(~0ULL >> 1)));
}

extern int __attribute__((__warn_unused_result__)) file_fdatawait_range(struct file *file, loff_t lstart,
      loff_t lend);
extern int __attribute__((__warn_unused_result__)) file_check_and_advance_wb_err(struct file *file);
extern int __attribute__((__warn_unused_result__)) file_write_and_wait_range(struct file *file,
      loff_t start, loff_t end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int file_write_and_wait(struct file *file)
{
 return file_write_and_wait_range(file, 0, ((long long)(~0ULL >> 1)));
}
# 2820 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_set_wb_err(struct address_space *mapping, int err)
{

 if (__builtin_expect(!!(err), 0))
  __filemap_set_wb_err(mapping, err);
}
# 2837 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_check_wb_err(struct address_space *mapping,
     errseq_t since)
{
 return errseq_check(&mapping->wb_err, since);
}
# 2850 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) errseq_t filemap_sample_wb_err(struct address_space *mapping)
{
 return errseq_sample(&mapping->wb_err);
}
# 2862 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) errseq_t file_sample_sb_err(struct file *file)
{
 return errseq_sample(&file->f_path.dentry->d_sb->s_wb_err);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_nr_thps(struct address_space *mapping)
{



 return 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_nr_thps_inc(struct address_space *mapping)
{



 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2881), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_nr_thps_dec(struct address_space *mapping)
{



 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2890), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

}

extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
      int datasync);
extern int vfs_fsync(struct file *file, int datasync);

extern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,
    unsigned int flags);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)
{
 if (iocb->ki_flags & (1 << 4)) {
  int ret = vfs_fsync_range(iocb->ki_filp,
    iocb->ki_pos - count, iocb->ki_pos - 1,
    (iocb->ki_flags & (1 << 5)) ? 0 : 1);
  if (ret)
   return ret;
 }

 return count;
}

extern void emergency_sync(void);
extern void emergency_remount(void);


extern int bmap(struct inode *inode, sector_t *block);







extern int notify_change(struct dentry *, struct iattr *, struct inode **);
extern int inode_permission(struct inode *, int);
extern int generic_permission(struct inode *, int);
extern int __check_sticky(struct inode *dir, struct inode *inode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool execute_ok(struct inode *inode)
{
 return (inode->i_mode & (00100|00010|00001)) || (((inode->i_mode) & 00170000) == 0040000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_start_write(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return;
 __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool file_start_write_trylock(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return true;
 return __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_end_write(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return;
 __sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);
}
# 2978 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_write_access(struct inode *inode)
{
 return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -26;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int deny_write_access(struct file *file)
{
 struct inode *inode = file_inode(file);
 return atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -26;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_write_access(struct inode * inode)
{
 atomic_dec(&inode->i_writecount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_write_access(struct file *file)
{
 if (file)
  atomic_inc(&file_inode(file)->i_writecount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inode_is_open_for_write(const struct inode *inode)
{
 return atomic_read(&inode->i_writecount) > 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_readcount_dec(struct inode *inode)
{
 do { if (__builtin_constant_p(!atomic_read(&inode->i_readcount))) { if (!atomic_read(&inode->i_readcount)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (3004), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (3004), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!atomic_read(&inode->i_readcount)))); } } while (0);
 atomic_dec(&inode->i_readcount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_readcount_inc(struct inode *inode)
{
 atomic_inc(&inode->i_readcount);
}
# 3021 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int do_pipe_flags(int *, int);
# 3038 "/home/nathan/src/linux-next/include/linux/fs.h"
enum kernel_read_file_id {
 READING_UNKNOWN, READING_FIRMWARE, READING_FIRMWARE_PREALLOC_BUFFER, READING_FIRMWARE_EFI_EMBEDDED, READING_MODULE, READING_KEXEC_IMAGE, READING_KEXEC_INITRAMFS, READING_POLICY, READING_X509_CERTIFICATE, READING_MAX_ID,
};

static const char * const kernel_read_file_str[] = {
 "unknown", "firmware", "firmware", "firmware", "kernel-module", "kexec-image", "kexec-initramfs", "security-policy", "x509-certificate", "",
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kernel_read_file_id_str(enum kernel_read_file_id id)
{
 if ((unsigned)id >= READING_MAX_ID)
  return kernel_read_file_str[READING_UNKNOWN];

 return kernel_read_file_str[id];
}

extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
       enum kernel_read_file_id);
extern int kernel_read_file_from_path(const char *, void **, loff_t *, loff_t,
          enum kernel_read_file_id);
extern int kernel_read_file_from_path_initns(const char *, void **, loff_t *, loff_t,
          enum kernel_read_file_id);
extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
        enum kernel_read_file_id);
extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
extern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);
extern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);
extern struct file * open_exec(const char *);


extern bool is_subdir(struct dentry *, struct dentry *);
extern bool path_is_under(const struct path *, const struct path *);

extern char *file_path(struct file *, char *, int);




extern loff_t default_llseek(struct file *file, loff_t offset, int whence);

extern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);

extern int inode_init_always(struct super_block *, struct inode *);
extern void inode_init_once(struct inode *);
extern void address_space_init_once(struct address_space *mapping);
extern struct inode * igrab(struct inode *);
extern ino_t iunique(struct super_block *, ino_t);
extern int inode_needs_sync(struct inode *inode);
extern int generic_delete_inode(struct inode *inode);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int generic_drop_inode(struct inode *inode)
{
 return !inode->i_nlink || inode_unhashed(inode) ||
  (inode->i_state & (1 << 16));
}
extern void d_mark_dontcache(struct inode *inode);

extern struct inode *ilookup5_nowait(struct super_block *sb,
  unsigned long hashval, int (*test)(struct inode *, void *),
  void *data);
extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
  int (*test)(struct inode *, void *), void *data);
extern struct inode *ilookup(struct super_block *sb, unsigned long ino);

extern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,
  int (*test)(struct inode *, void *),
  int (*set)(struct inode *, void *),
  void *data);
extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
extern struct inode * iget_locked(struct super_block *, unsigned long);
extern struct inode *find_inode_nowait(struct super_block *,
           unsigned long,
           int (*match)(struct inode *,
          unsigned long, void *),
           void *data);
extern struct inode *find_inode_rcu(struct super_block *, unsigned long,
        int (*)(struct inode *, void *), void *);
extern struct inode *find_inode_by_ino_rcu(struct super_block *, unsigned long);
extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
extern int insert_inode_locked(struct inode *);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_annotate_inode_mutex_key(struct inode *inode) { };

extern void unlock_new_inode(struct inode *);
extern void discard_new_inode(struct inode *);
extern unsigned int get_next_ino(void);
extern void evict_inodes(struct super_block *sb);

extern void __iget(struct inode * inode);
extern void iget_failed(struct inode *);
extern void clear_inode(struct inode *);
extern void __destroy_inode(struct inode *);
extern struct inode *new_inode_pseudo(struct super_block *sb);
extern struct inode *new_inode(struct super_block *sb);
extern void free_inode_nonrcu(struct inode *inode);
extern int should_remove_suid(struct dentry *);
extern int file_remove_privs(struct file *);

extern void __insert_inode_hash(struct inode *, unsigned long hashval);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void insert_inode_hash(struct inode *inode)
{
 __insert_inode_hash(inode, inode->i_ino);
}

extern void __remove_inode_hash(struct inode *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void remove_inode_hash(struct inode *inode)
{
 if (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))
  __remove_inode_hash(inode);
}

extern void inode_sb_list_add(struct inode *inode);


extern int bdev_read_only(struct block_device *);

extern int set_blocksize(struct block_device *, int);
extern int sb_set_blocksize(struct super_block *, int);
extern int sb_min_blocksize(struct super_block *, int);

extern int generic_file_mmap(struct file *, struct vm_area_struct *);
extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
    struct file *file_out, loff_t pos_out,
    loff_t *count, unsigned int remap_flags);
extern int generic_file_rw_checks(struct file *file_in, struct file *file_out);
extern int generic_copy_file_checks(struct file *file_in, loff_t pos_in,
        struct file *file_out, loff_t pos_out,
        size_t *count, unsigned int flags);
extern ssize_t generic_file_buffered_read(struct kiocb *iocb,
  struct iov_iter *to, ssize_t already_read);
extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);
extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);

ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
  rwf_t flags);
ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,
  rwf_t flags);
ssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,
      struct iov_iter *iter);
ssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,
       struct iov_iter *iter);


extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);
extern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);
extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
   int datasync);
extern void block_sync_page(struct page *page);


extern ssize_t generic_file_splice_read(struct file *, loff_t *,
  struct pipe_inode_info *, size_t, unsigned int);
extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
  struct file *, loff_t *, size_t, unsigned int);
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
  struct file *out, loff_t *, size_t len, unsigned int flags);
extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
  loff_t *opos, size_t len, unsigned int flags);


extern void
file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
extern loff_t noop_llseek(struct file *file, loff_t offset, int whence);
extern loff_t no_llseek(struct file *file, loff_t offset, int whence);
extern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);
extern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
  int whence, loff_t maxsize, loff_t eof);
extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
  int whence, loff_t size);
extern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);
extern loff_t no_seek_end_llseek(struct file *, loff_t, int);
extern int generic_file_open(struct inode * inode, struct file * filp);
extern int nonseekable_open(struct inode * inode, struct file * filp);
extern int stream_open(struct inode * inode, struct file * filp);


typedef void (dio_submit_t)(struct bio *bio, struct inode *inode,
       loff_t file_offset);

enum {

 DIO_LOCKING = 0x01,


 DIO_SKIP_HOLES = 0x02,
};

void dio_end_io(struct bio *bio);

ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
        struct block_device *bdev, struct iov_iter *iter,
        get_block_t get_block,
        dio_iodone_t end_io, dio_submit_t submit_io,
        int flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t blockdev_direct_IO(struct kiocb *iocb,
      struct inode *inode,
      struct iov_iter *iter,
      get_block_t get_block)
{
 return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
   get_block, ((void *)0), ((void *)0), DIO_LOCKING | DIO_SKIP_HOLES);
}


void inode_dio_wait(struct inode *inode);
# 3259 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dio_begin(struct inode *inode)
{
 atomic_inc(&inode->i_dio_count);
}
# 3271 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dio_end(struct inode *inode)
{
 if (atomic_dec_and_test(&inode->i_dio_count))
  wake_up_bit(&inode->i_state, 9);
}




void dio_warn_stale_pagecache(struct file *filp);

extern void inode_set_flags(struct inode *inode, unsigned int flags,
       unsigned int mask);

extern const struct file_operations generic_ro_fops;



extern int readlink_copy(char *, int, const char *);
extern int page_readlink(struct dentry *, char *, int);
extern const char *page_get_link(struct dentry *, struct inode *,
     struct delayed_call *);
extern void page_put_link(void *);
extern int __page_symlink(struct inode *inode, const char *symname, int len,
  int nofs);
extern int page_symlink(struct inode *inode, const char *symname, int len);
extern const struct inode_operations page_symlink_inode_operations;
extern void kfree_link(void *);
extern void generic_fillattr(struct inode *, struct kstat *);
extern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);
extern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);
void __inode_add_bytes(struct inode *inode, loff_t bytes);
void inode_add_bytes(struct inode *inode, loff_t bytes);
void __inode_sub_bytes(struct inode *inode, loff_t bytes);
void inode_sub_bytes(struct inode *inode, loff_t bytes);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t __inode_get_bytes(struct inode *inode)
{
 return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
}
loff_t inode_get_bytes(struct inode *inode);
void inode_set_bytes(struct inode *inode, loff_t bytes);
const char *simple_get_link(struct dentry *, struct inode *,
       struct delayed_call *);
extern const struct inode_operations simple_symlink_inode_operations;

extern int iterate_dir(struct file *, struct dir_context *);

extern int vfs_statx(int, const char *, int, struct kstat *, u32);
extern int vfs_statx_fd(unsigned int, struct kstat *, u32, unsigned int);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_stat(const char *filename, struct kstat *stat)
{
 return vfs_statx(-100, filename, 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_lstat(const char *name, struct kstat *stat)
{
 return vfs_statx(-100, name, 0x100 | 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_fstatat(int dfd, const char *filename,
         struct kstat *stat, int flags)
{
 return vfs_statx(dfd, filename, flags | 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_fstat(int fd, struct kstat *stat)
{
 return vfs_statx_fd(fd, stat, 0x000007ffU, 0);
}


extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
extern int vfs_readlink(struct dentry *, char *, int);

extern struct file_system_type *get_filesystem(struct file_system_type *fs);
extern void put_filesystem(struct file_system_type *fs);
extern struct file_system_type *get_fs_type(const char *name);
extern struct super_block *get_super(struct block_device *);
extern struct super_block *get_super_thawed(struct block_device *);
extern struct super_block *get_super_exclusive_thawed(struct block_device *bdev);
extern struct super_block *get_active_super(struct block_device *bdev);
extern void drop_super(struct super_block *sb);
extern void drop_super_exclusive(struct super_block *sb);
extern void iterate_supers(void (*)(struct super_block *, void *), void *);
extern void iterate_supers_type(struct file_system_type *,
           void (*)(struct super_block *, void *), void *);

extern int dcache_dir_open(struct inode *, struct file *);
extern int dcache_dir_close(struct inode *, struct file *);
extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
extern int dcache_readdir(struct file *, struct dir_context *);
extern int simple_setattr(struct dentry *, struct iattr *);
extern int simple_getattr(const struct path *, struct kstat *, u32, unsigned int);
extern int simple_statfs(struct dentry *, struct kstatfs *);
extern int simple_open(struct inode *inode, struct file *file);
extern int simple_link(struct dentry *, struct inode *, struct dentry *);
extern int simple_unlink(struct inode *, struct dentry *);
extern int simple_rmdir(struct inode *, struct dentry *);
extern int simple_rename(struct inode *, struct dentry *,
    struct inode *, struct dentry *, unsigned int);
extern void simple_recursive_removal(struct dentry *,
                              void (*callback)(struct dentry *));
extern int noop_fsync(struct file *, loff_t, loff_t, int);
extern int noop_set_page_dirty(struct page *page);
extern void noop_invalidatepage(struct page *page, unsigned int offset,
  unsigned int length);
extern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);
extern int simple_empty(struct dentry *);
extern int simple_readpage(struct file *file, struct page *page);
extern int simple_write_begin(struct file *file, struct address_space *mapping,
   loff_t pos, unsigned len, unsigned flags,
   struct page **pagep, void **fsdata);
extern int simple_write_end(struct file *file, struct address_space *mapping,
   loff_t pos, unsigned len, unsigned copied,
   struct page *page, void *fsdata);
extern int always_delete_dentry(const struct dentry *);
extern struct inode *alloc_anon_inode(struct super_block *);
extern int simple_nosetlease(struct file *, long, struct file_lock **, void **);
extern const struct dentry_operations simple_dentry_operations;

extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);
extern ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
extern const struct file_operations simple_dir_operations;
extern const struct inode_operations simple_dir_inode_operations;
extern void make_empty_dir_inode(struct inode *inode);
extern bool is_empty_dir_inode(struct inode *inode);
struct tree_descr { const char *name; const struct file_operations *ops; int mode; };
struct dentry *d_alloc_name(struct dentry *, const char *);
extern int simple_fill_super(struct super_block *, unsigned long,
        const struct tree_descr *);
extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
extern void simple_release_fs(struct vfsmount **mount, int *count);

extern ssize_t simple_read_from_buffer(void *to, size_t count,
   loff_t *ppos, const void *from, size_t available);
extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
  const void *from, size_t count);

extern int __generic_file_fsync(struct file *, loff_t, loff_t, int);
extern int generic_file_fsync(struct file *, loff_t, loff_t, int);

extern int generic_check_addressable(unsigned, u64);


extern int buffer_migrate_page(struct address_space *,
    struct page *, struct page *,
    enum migrate_mode);
extern int buffer_migrate_page_norefs(struct address_space *,
    struct page *, struct page *,
    enum migrate_mode);





extern int setattr_prepare(struct dentry *, struct iattr *);
extern int inode_newsize_ok(const struct inode *, loff_t offset);
extern void setattr_copy(struct inode *inode, const struct iattr *attr);

extern int file_update_time(struct file *file);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vma_is_dax(const struct vm_area_struct *vma)
{
 return vma->vm_file && ((vma->vm_file->f_mapping->host)->i_flags & 8192);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vma_is_fsdax(struct vm_area_struct *vma)
{
 struct inode *inode;

 if (!vma->vm_file)
  return false;
 if (!vma_is_dax(vma))
  return false;
 inode = file_inode(vma->vm_file);
 if ((((inode->i_mode) & 00170000) == 0020000))
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int iocb_flags(struct file *file)
{
 int res = 0;
 if (file->f_flags & 00002000)
  res |= (1 << 1);
 if (file->f_flags & 0400000)
  res |= (1 << 2);
 if ((file->f_flags & 00010000) || (((file->f_mapping->host)->i_sb->s_flags & (16)) || ((file->f_mapping->host)->i_flags & 1)))
  res |= (1 << 4);
 if (file->f_flags & 04000000)
  res |= (1 << 5);
 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)
{
 if (__builtin_expect(!!(flags & ~((( __kernel_rwf_t)0x00000001) | (( __kernel_rwf_t)0x00000002) | (( __kernel_rwf_t)0x00000004) | (( __kernel_rwf_t)0x00000008) | (( __kernel_rwf_t)0x00000010))), 0))
  return -95;

 if (flags & (( __kernel_rwf_t)0x00000008)) {
  if (!(ki->ki_filp->f_mode & (( fmode_t)0x8000000)))
   return -95;
  ki->ki_flags |= (1 << 7);
 }
 if (flags & (( __kernel_rwf_t)0x00000001))
  ki->ki_flags |= (1 << 3);
 if (flags & (( __kernel_rwf_t)0x00000002))
  ki->ki_flags |= (1 << 4);
 if (flags & (( __kernel_rwf_t)0x00000004))
  ki->ki_flags |= ((1 << 4) | (1 << 5));
 if (flags & (( __kernel_rwf_t)0x00000010))
  ki->ki_flags |= (1 << 1);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t parent_ino(struct dentry *dentry)
{
 ino_t res;





 spin_lock(&dentry->d_lockref.lock);
 res = dentry->d_parent->d_inode->i_ino;
 spin_unlock(&dentry->d_lockref.lock);
 return res;
}







struct simple_transaction_argresp {
 ssize_t size;
 char data[0];
};



char *simple_transaction_get(struct file *file, const char *buf,
    size_t size);
ssize_t simple_transaction_read(struct file *file, char *buf,
    size_t size, loff_t *pos);
int simple_transaction_release(struct inode *inode, struct file *file);

void simple_transaction_set(struct file *file, size_t n);
# 3553 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__format__(printf, 1, 2)))
void __simple_attr_check_format(const char *fmt, ...)
{

}

int simple_attr_open(struct inode *inode, struct file *file,
       int (*get)(void *, u64 *), int (*set)(void *, u64),
       const char *fmt);
int simple_attr_release(struct inode *inode, struct file *file);
ssize_t simple_attr_read(struct file *file, char *buf,
    size_t len, loff_t *ppos);
ssize_t simple_attr_write(struct file *file, const char *buf,
     size_t len, loff_t *ppos);

struct ctl_table;
int proc_nr_files(struct ctl_table *table, int write,
    void *buffer, size_t *lenp, loff_t *ppos);
int proc_nr_dentry(struct ctl_table *table, int write,
    void *buffer, size_t *lenp, loff_t *ppos);
int proc_nr_inodes(struct ctl_table *table, int write,
     void *buffer, size_t *lenp, loff_t *ppos);
int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) get_filesystem_list(char *buf);
# 3584 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_sxid(umode_t mode)
{
 return (mode & 0004000) || ((mode & 0002000) && (mode & 00010));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int check_sticky(struct inode *dir, struct inode *inode)
{
 if (!(dir->i_mode & 0001000))
  return 0;

 return __check_sticky(dir, inode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_has_no_xattr(struct inode *inode)
{
 if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & (1<<28)))
  inode->i_flags |= 4096;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_root_inode(struct inode *inode)
{
 return inode == inode->i_sb->s_root->d_inode;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit(struct dir_context *ctx,
       const char *name, int namelen,
       u64 ino, unsigned type)
{
 return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dot(struct file *file, struct dir_context *ctx)
{
 return ctx->actor(ctx, ".", 1, ctx->pos,
     file->f_path.dentry->d_inode->i_ino, 4) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)
{
 return ctx->actor(ctx, "..", 2, ctx->pos,
     parent_ino(file->f_path.dentry), 4) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dots(struct file *file, struct dir_context *ctx)
{
 if (ctx->pos == 0) {
  if (!dir_emit_dot(file, ctx))
   return false;
  ctx->pos = 1;
 }
 if (ctx->pos == 1) {
  if (!dir_emit_dotdot(file, ctx))
   return false;
  ctx->pos = 2;
 }
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_relax(struct inode *inode)
{
 inode_unlock(inode);
 inode_lock(inode);
 return !((inode)->i_flags & 16);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_relax_shared(struct inode *inode)
{
 inode_unlock_shared(inode);
 inode_lock_shared(inode);
 return !((inode)->i_flags & 16);
}

extern bool path_noexec(const struct path *path);
extern void inode_nohighmem(struct inode *inode);


extern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,
         int advice);
extern int generic_fadvise(struct file *file, loff_t offset, loff_t len,
      int advice);


extern struct sock *io_uring_get_socket(struct file *file);







int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
        unsigned int flags);

int vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,
        struct fsxattr *fa);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)
{
 memset(fa, 0, sizeof(*fa));
 fa->fsx_xflags = xflags;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_drain_writes(struct inode *inode)
{
 inode_dio_wait(inode);
 return filemap_write_and_wait(inode->i_mapping);
}

extern void __notify_sb(struct super_block *s,
   enum superblock_notification_type subtype,
   u32 info);
extern void __notify_sb_error(struct super_block *s, int error);
extern void __notify_sb_EQDUOT(struct super_block *s);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void notify_sb(struct super_block *s,
        enum superblock_notification_type subtype,
        u32 info)
{





}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notify_sb_error(struct super_block *s, int error)
{





 return error;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notify_sb_EQDUOT(struct super_block *s)
{





 return -122;
}
# 12 "/home/nathan/src/linux-next/include/linux/seq_file.h" 2


struct seq_operations;

struct seq_file {
 char *buf;
 size_t size;
 size_t from;
 size_t count;
 size_t pad_until;
 loff_t index;
 loff_t read_pos;
 struct mutex lock;
 const struct seq_operations *op;
 int poll_event;
 const struct file *file;
 void *private;
};

struct seq_operations {
 void * (*start) (struct seq_file *m, loff_t *pos);
 void (*stop) (struct seq_file *m, void *v);
 void * (*next) (struct seq_file *m, void *v, loff_t *pos);
 int (*show) (struct seq_file *m, void *v);
};
# 50 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool seq_has_overflowed(struct seq_file *m)
{
 return m->count == m->size;
}
# 63 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t seq_get_buf(struct seq_file *m, char **bufp)
{
 do { if (__builtin_constant_p(m->count > m->size)) { if (m->count > m->size) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (65), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (65), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(m->count > m->size))); } } while (0);
 if (m->count < m->size)
  *bufp = m->buf + m->count;
 else
  *bufp = ((void *)0);

 return m->size - m->count;
}
# 83 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_commit(struct seq_file *m, int num)
{
 if (num < 0) {
  m->count = m->size;
 } else {
  do { if (__builtin_constant_p(m->count + num > m->size)) { if (m->count + num > m->size) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (88), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (88), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(m->count + num > m->size))); } } while (0);
  m->count += num;
 }
}
# 101 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_setwidth(struct seq_file *m, size_t size)
{
 m->pad_until = m->count + size;
}
void seq_pad(struct seq_file *m, char c);

char *mangle_path(char *s, const char *p, const char *esc);
int seq_open(struct file *, const struct seq_operations *);
ssize_t seq_read(struct file *, char *, size_t, loff_t *);
loff_t seq_lseek(struct file *, loff_t, int);
int seq_release(struct inode *, struct file *);
int seq_write(struct seq_file *seq, const void *data, size_t len);

__attribute__((__format__(printf, 2, 0)))
void seq_vprintf(struct seq_file *m, const char *fmt, va_list args);
__attribute__((__format__(printf, 2, 3)))
void seq_printf(struct seq_file *m, const char *fmt, ...);
void seq_putc(struct seq_file *m, char c);
void seq_puts(struct seq_file *m, const char *s);
void seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,
          unsigned long long num, unsigned int width);
void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
    unsigned long long num);
void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num);
void seq_put_hex_ll(struct seq_file *m, const char *delimiter,
      unsigned long long v, unsigned int width);

void seq_escape(struct seq_file *m, const char *s, const char *esc);
void seq_escape_mem_ascii(struct seq_file *m, const char *src, size_t isz);

void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
    int rowsize, int groupsize, const void *buf, size_t len,
    bool ascii);

int seq_path(struct seq_file *, const struct path *, const char *);
int seq_file_path(struct seq_file *, struct file *, const char *);
int seq_dentry(struct seq_file *, struct dentry *, const char *);
int seq_path_root(struct seq_file *m, const struct path *path,
    const struct path *root, const char *esc);

int single_open(struct file *, int (*)(struct seq_file *, void *), void *);
int single_open_size(struct file *, int (*)(struct seq_file *, void *), void *, size_t);
int single_release(struct inode *, struct file *);
void *__seq_open_private(struct file *, const struct seq_operations *, int);
int seq_open_private(struct file *, const struct seq_operations *, int);
int seq_release_private(struct inode *, struct file *);
# 194 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_namespace *seq_user_ns(struct seq_file *seq)
{

 return seq->file->f_cred->user_ns;




}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_show_option(struct seq_file *m, const char *name,
       const char *value)
{
 seq_putc(m, ',');
 seq_escape(m, name, ",= \t\n\\");
 if (value) {
  seq_putc(m, '=');
  seq_escape(m, value, ", \t\n\\");
 }
}
# 244 "/home/nathan/src/linux-next/include/linux/seq_file.h"
extern struct list_head *seq_list_start(struct list_head *head,
  loff_t pos);
extern struct list_head *seq_list_start_head(struct list_head *head,
  loff_t pos);
extern struct list_head *seq_list_next(void *v, struct list_head *head,
  loff_t *ppos);





extern struct hlist_node *seq_hlist_start(struct hlist_head *head,
       loff_t pos);
extern struct hlist_node *seq_hlist_start_head(struct hlist_head *head,
            loff_t pos);
extern struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,
      loff_t *ppos);

extern struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,
           loff_t pos);
extern struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,
         loff_t pos);
extern struct hlist_node *seq_hlist_next_rcu(void *v,
         struct hlist_head *head,
         loff_t *ppos);


extern struct hlist_node *seq_hlist_start_percpu(struct hlist_head *head, int *cpu, loff_t pos);

extern struct hlist_node *seq_hlist_next_percpu(void *v, struct hlist_head *head, int *cpu, loff_t *pos);

void seq_file_init(void);
# 32 "/home/nathan/src/linux-next/include/drm/drm_print.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/device.h"
# 1 "/home/nathan/src/linux-next/include/linux/dev_printk.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/dev_printk.h"
struct device;



__attribute__((__format__(printf, 3, 0))) __attribute__((__cold__))
int dev_vprintk_emit(int level, const struct device *dev,
       const char *fmt, va_list args);
__attribute__((__format__(printf, 3, 4))) __attribute__((__cold__))
int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...);

__attribute__((__format__(printf, 3, 4))) __attribute__((__cold__))
void dev_printk(const char *level, const struct device *dev,
  const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_emerg(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_alert(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_crit(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_err(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_warn(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_notice(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_info(const struct device *dev, const char *fmt, ...);
# 16 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/ioport.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/ioport.h"
struct resource {
 resource_size_t start;
 resource_size_t end;
 const char *name;
 unsigned long flags;
 unsigned long desc;
 struct resource *parent, *sibling, *child;
};
# 129 "/home/nathan/src/linux-next/include/linux/ioport.h"
enum {
 IORES_DESC_NONE = 0,
 IORES_DESC_CRASH_KERNEL = 1,
 IORES_DESC_ACPI_TABLES = 2,
 IORES_DESC_ACPI_NV_STORAGE = 3,
 IORES_DESC_PERSISTENT_MEMORY = 4,
 IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
 IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
 IORES_DESC_RESERVED = 7,
 IORES_DESC_SOFT_RESERVED = 8,
};




enum {
 IORES_MAP_SYSTEM_RAM = ((((1UL))) << (0)),
 IORES_MAP_ENCRYPTED = ((((1UL))) << (1)),
};
# 180 "/home/nathan/src/linux-next/include/linux/ioport.h"
extern struct resource ioport_resource;
extern struct resource iomem_resource;

extern struct resource *request_resource_conflict(struct resource *root, struct resource *new);
extern int request_resource(struct resource *root, struct resource *new);
extern int release_resource(struct resource *new);
void release_child_resources(struct resource *new);
extern void reserve_region_with_split(struct resource *root,
        resource_size_t start, resource_size_t end,
        const char *name);
extern struct resource *insert_resource_conflict(struct resource *parent, struct resource *new);
extern int insert_resource(struct resource *parent, struct resource *new);
extern void insert_resource_expand_to_fit(struct resource *root, struct resource *new);
extern int remove_resource(struct resource *old);
extern void arch_remove_reservations(struct resource *avail);
extern int allocate_resource(struct resource *root, struct resource *new,
        resource_size_t size, resource_size_t min,
        resource_size_t max, resource_size_t align,
        resource_size_t (*alignf)(void *,
             const struct resource *,
             resource_size_t,
             resource_size_t),
        void *alignf_data);
struct resource *lookup_resource(struct resource *root, resource_size_t start);
int adjust_resource(struct resource *res, resource_size_t start,
      resource_size_t size);
resource_size_t resource_alignment(struct resource *res);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) resource_size_t resource_size(const struct resource *res)
{
 return res->end - res->start + 1;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long resource_type(const struct resource *res)
{
 return res->flags & 0x00001f00;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long resource_ext_type(const struct resource *res)
{
 return res->flags & 0x01000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool resource_contains(struct resource *r1, struct resource *r2)
{
 if (resource_type(r1) != resource_type(r2))
  return false;
 if (r1->flags & 0x20000000 || r2->flags & 0x20000000)
  return false;
 return r1->start <= r2->start && r1->end >= r2->end;
}
# 239 "/home/nathan/src/linux-next/include/linux/ioport.h"
extern struct resource * __request_region(struct resource *,
     resource_size_t start,
     resource_size_t n,
     const char *name, int flags);





extern void __release_region(struct resource *, resource_size_t,
    resource_size_t);

extern int release_mem_region_adjustable(struct resource *, resource_size_t,
    resource_size_t);



struct device;

extern int devm_request_resource(struct device *dev, struct resource *root,
     struct resource *new);
extern void devm_release_resource(struct device *dev, struct resource *new);






extern struct resource * __devm_request_region(struct device *dev,
    struct resource *parent, resource_size_t start,
    resource_size_t n, const char *name);






extern void __devm_release_region(struct device *dev, struct resource *parent,
      resource_size_t start, resource_size_t n);
extern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);
extern bool iomem_is_exclusive(u64 addr);

extern int
walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
  void *arg, int (*func)(unsigned long, unsigned long, void *));
extern int
walk_mem_res(u64 start, u64 end, void *arg,
      int (*func)(struct resource *, void *));
extern int
walk_system_ram_res(u64 start, u64 end, void *arg,
      int (*func)(struct resource *, void *));
extern int
walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start, u64 end,
      void *arg, int (*func)(struct resource *, void *));


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool resource_overlaps(struct resource *r1, struct resource *r2)
{
       return (r1->start <= r2->end && r1->end >= r2->start);
}

struct resource *devm_request_free_mem_region(struct device *dev,
  struct resource *base, unsigned long size);
struct resource *request_free_mem_region(struct resource *base,
  unsigned long size, const char *name);


void revoke_devmem(struct resource *res);
# 17 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kobject.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/kobject.h"
# 1 "/home/nathan/src/linux-next/include/linux/sysfs.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/sysfs.h"
# 1 "/home/nathan/src/linux-next/include/linux/kernfs.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/kernfs.h"
# 1 "/home/nathan/src/linux-next/include/linux/idr.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/idr.h"
struct idr {
 struct xarray idr_rt;
 unsigned int idr_base;
 unsigned int idr_next;
};
# 66 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int idr_get_cursor(const struct idr *idr)
{
 return ({ do { extern void __compiletime_assert_172(void) ; if (!((sizeof(idr->idr_next) == sizeof(char) || sizeof(idr->idr_next) == sizeof(short) || sizeof(idr->idr_next) == sizeof(int) || sizeof(idr->idr_next) == sizeof(long)) || sizeof(idr->idr_next) == sizeof(long long))) __compiletime_assert_172(); } while (0); ({ typeof( _Generic((idr->idr_next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (idr->idr_next))) __x = (*(const volatile typeof( _Generic((idr->idr_next), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: (idr->idr_next))) *)&(idr->idr_next)); do { } while (0); (typeof(idr->idr_next))__x; }); });
}
# 79 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_set_cursor(struct idr *idr, unsigned int val)
{
 do { do { extern void __compiletime_assert_173(void) ; if (!((sizeof(idr->idr_next) == sizeof(char) || sizeof(idr->idr_next) == sizeof(short) || sizeof(idr->idr_next) == sizeof(int) || sizeof(idr->idr_next) == sizeof(long)) || sizeof(idr->idr_next) == sizeof(long long))) __compiletime_assert_173(); } while (0); do { *(volatile typeof(idr->idr_next) *)&(idr->idr_next) = (val); } while (0); } while (0);
}
# 112 "/home/nathan/src/linux-next/include/linux/idr.h"
void idr_preload(gfp_t gfp_mask);

int idr_alloc(struct idr *, void *ptr, int start, int end, gfp_t);
int __attribute__((__warn_unused_result__)) idr_alloc_u32(struct idr *, void *ptr, u32 *id,
    unsigned long max, gfp_t);
int idr_alloc_cyclic(struct idr *, void *ptr, int start, int end, gfp_t);
void *idr_remove(struct idr *, unsigned long id);
void *idr_find(const struct idr *, unsigned long id);
int idr_for_each(const struct idr *,
   int (*fn)(int id, void *p, void *data), void *data);
void *idr_get_next(struct idr *, int *nextid);
void *idr_get_next_ul(struct idr *, unsigned long *nextid);
void *idr_replace(struct idr *, void *, unsigned long id);
void idr_destroy(struct idr *);
# 135 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_init_base(struct idr *idr, int base)
{
 xa_init_flags(&idr->idr_rt, ((( gfp_t)4) | ( gfp_t) (1 << (((23 + 0)) + 0))));
 idr->idr_base = base;
 idr->idr_next = 0;
}
# 149 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_init(struct idr *idr)
{
 idr_init_base(idr, 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool idr_is_empty(const struct idr *idr)
{
 return radix_tree_empty(&idr->idr_rt) &&
  radix_tree_tagged(&idr->idr_rt, 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_preload_end(void)
{
 do { local_lock_release(({ do { const void *__vpp_verify = (typeof((&radix_tree_preloads.lock) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&radix_tree_preloads.lock)) *)(&radix_tree_preloads.lock)); (typeof((typeof(*(&radix_tree_preloads.lock)) *)(&radix_tree_preloads.lock))) (__ptr + ((local_paca->data_offset))); }); })); __asm__ __volatile__("" : : : "memory"); } while (0);
}
# 240 "/home/nathan/src/linux-next/include/linux/idr.h"
struct ida_bitmap {
 unsigned long bitmap[(128 / sizeof(long))];
};

struct ida {
 struct xarray xa;
};
# 255 "/home/nathan/src/linux-next/include/linux/idr.h"
int ida_alloc_range(struct ida *, unsigned int min, unsigned int max, gfp_t);
void ida_free(struct ida *, unsigned int id);
void ida_destroy(struct ida *ida);
# 270 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc(struct ida *ida, gfp_t gfp)
{
 return ida_alloc_range(ida, 0, ~0, gfp);
}
# 287 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc_min(struct ida *ida, unsigned int min, gfp_t gfp)
{
 return ida_alloc_range(ida, min, ~0, gfp);
}
# 304 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc_max(struct ida *ida, unsigned int max, gfp_t gfp)
{
 return ida_alloc_range(ida, 0, max, gfp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ida_init(struct ida *ida)
{
 xa_init_flags(&ida->xa, ((( gfp_t)XA_LOCK_IRQ) | ((( gfp_t)4U) | (( gfp_t)((1U << (23 + 0)) << ( unsigned)((( xa_mark_t)0U)))))));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ida_is_empty(const struct ida *ida)
{
 return xa_empty(&ida->xa);
}
# 14 "/home/nathan/src/linux-next/include/linux/kernfs.h" 2






struct file;
struct dentry;
struct iattr;
struct seq_file;
struct vm_area_struct;
struct super_block;
struct file_system_type;
struct poll_table_struct;
struct fs_context;

struct kernfs_fs_context;
struct kernfs_open_node;
struct kernfs_iattrs;

enum kernfs_node_type {
 KERNFS_DIR = 0x0001,
 KERNFS_FILE = 0x0002,
 KERNFS_LINK = 0x0004,
};






enum kernfs_node_flag {
 KERNFS_ACTIVATED = 0x0010,
 KERNFS_NS = 0x0020,
 KERNFS_HAS_SEQ_SHOW = 0x0040,
 KERNFS_HAS_MMAP = 0x0080,
 KERNFS_LOCKDEP = 0x0100,
 KERNFS_SUICIDAL = 0x0400,
 KERNFS_SUICIDED = 0x0800,
 KERNFS_EMPTY_DIR = 0x1000,
 KERNFS_HAS_RELEASE = 0x2000,
};


enum kernfs_root_flag {






 KERNFS_ROOT_CREATE_DEACTIVATED = 0x0001,
# 76 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 0x0002,





 KERNFS_ROOT_SUPPORT_EXPORTOP = 0x0004,




 KERNFS_ROOT_SUPPORT_USER_XATTR = 0x0008,
};


struct kernfs_elem_dir {
 unsigned long subdirs;

 struct rb_root children;





 struct kernfs_root *root;
};

struct kernfs_elem_symlink {
 struct kernfs_node *target_kn;
};

struct kernfs_elem_attr {
 const struct kernfs_ops *ops;
 struct kernfs_open_node *open;
 loff_t size;
 struct kernfs_node *notify_next;
};
# 123 "/home/nathan/src/linux-next/include/linux/kernfs.h"
struct kernfs_node {
 atomic_t count;
 atomic_t active;
# 135 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 struct kernfs_node *parent;
 const char *name;

 struct rb_node rb;

 const void *ns;
 unsigned int hash;
 union {
  struct kernfs_elem_dir dir;
  struct kernfs_elem_symlink symlink;
  struct kernfs_elem_attr attr;
 };

 void *priv;





 u64 id;

 unsigned short flags;
 umode_t mode;
 struct kernfs_iattrs *iattr;
};
# 168 "/home/nathan/src/linux-next/include/linux/kernfs.h"
struct kernfs_syscall_ops {
 int (*show_options)(struct seq_file *sf, struct kernfs_root *root);

 int (*mkdir)(struct kernfs_node *parent, const char *name,
       umode_t mode);
 int (*rmdir)(struct kernfs_node *kn);
 int (*rename)(struct kernfs_node *kn, struct kernfs_node *new_parent,
        const char *new_name);
 int (*show_path)(struct seq_file *sf, struct kernfs_node *kn,
    struct kernfs_root *root);
};

struct kernfs_root {

 struct kernfs_node *kn;
 unsigned int flags;


 struct idr ino_idr;
 u32 last_id_lowbits;
 u32 id_highbits;
 struct kernfs_syscall_ops *syscall_ops;


 struct list_head supers;

 wait_queue_head_t deactivate_waitq;
};

struct kernfs_open_file {

 struct kernfs_node *kn;
 struct file *file;
 struct seq_file *seq_file;
 void *priv;


 struct mutex mutex;
 struct mutex prealloc_mutex;
 int event;
 struct list_head list;
 char *prealloc_buf;

 size_t atomic_write_len;
 bool mmapped:1;
 bool released:1;
 const struct vm_operations_struct *vm_ops;
};

struct kernfs_ops {




 int (*open)(struct kernfs_open_file *of);
 void (*release)(struct kernfs_open_file *of);
# 236 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 int (*seq_show)(struct seq_file *sf, void *v);

 void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
 void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
 void (*seq_stop)(struct seq_file *sf, void *v);

 ssize_t (*read)(struct kernfs_open_file *of, char *buf, size_t bytes,
   loff_t off);
# 252 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 size_t atomic_write_len;






 bool prealloc;
 ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
    loff_t off);

 __poll_t (*poll)(struct kernfs_open_file *of,
    struct poll_table_struct *pt);

 int (*mmap)(struct kernfs_open_file *of, struct vm_area_struct *vma);




};




struct kernfs_fs_context {
 struct kernfs_root *root;
 void *ns_tag;
 unsigned long magic;


 bool new_sb_created;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
{
 return kn->flags & 0x000f;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_id_ino(u64 id)
{

 if (sizeof(ino_t) >= sizeof(u64))
  return id;
 else
  return (u32)id;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 kernfs_id_gen(u64 id)
{

 if (sizeof(ino_t) >= sizeof(u64))
  return 1;
 else
  return id >> 32;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_ino(struct kernfs_node *kn)
{
 return kernfs_id_ino(kn->id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_gen(struct kernfs_node *kn)
{
 return kernfs_id_gen(kn->id);
}
# 328 "/home/nathan/src/linux-next/include/linux/kernfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kernfs_enable_ns(struct kernfs_node *kn)
{
 ({ int __ret_warn_on = !!(kernfs_type(kn) != KERNFS_DIR); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kernfs.h"), "i" (330), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 ({ int __ret_warn_on = !!(!(({ do { extern void __compiletime_assert_174(void) ; if (!((sizeof((&kn->dir.children)->rb_node) == sizeof(char) || sizeof((&kn->dir.children)->rb_node) == sizeof(short) || sizeof((&kn->dir.children)->rb_node) == sizeof(int) || sizeof((&kn->dir.children)->rb_node) == sizeof(long)) || sizeof((&kn->dir.children)->rb_node) == sizeof(long long))) __compiletime_assert_174(); } while (0); ({ typeof( _Generic(((&kn->dir.children)->rb_node), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&kn->dir.children)->rb_node))) __x = (*(const volatile typeof( _Generic(((&kn->dir.children)->rb_node), char: (char)0, unsigned char: (unsigned char)0, signed char: (signed char)0, unsigned short: (unsigned short)0, signed short: (signed short)0, unsigned int: (unsigned int)0, signed int: (signed int)0, unsigned long: (unsigned long)0, signed long: (signed long)0, unsigned long long: (unsigned long long)0, signed long long: (signed long long)0, default: ((&kn->dir.children)->rb_node))) *)&((&kn->dir.children)->rb_node)); do { } while (0); (typeof((&kn->dir.children)->rb_node))__x; }); }) == ((void *)0))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kernfs.h"), "i" (331), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 kn->flags |= KERNFS_NS;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kernfs_ns_enabled(struct kernfs_node *kn)
{
 return kn->flags & KERNFS_NS;
}

int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
int kernfs_path_from_node(struct kernfs_node *root_kn, struct kernfs_node *kn,
     char *buf, size_t buflen);
void pr_cont_kernfs_name(struct kernfs_node *kn);
void pr_cont_kernfs_path(struct kernfs_node *kn);
struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
        const char *name, const void *ns);
struct kernfs_node *kernfs_walk_and_get_ns(struct kernfs_node *parent,
        const char *path, const void *ns);
void kernfs_get(struct kernfs_node *kn);
void kernfs_put(struct kernfs_node *kn);

struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry);
struct kernfs_root *kernfs_root_from_sb(struct super_block *sb);
struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);

struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
      struct super_block *sb);
struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
           unsigned int flags, void *priv);
void kernfs_destroy_root(struct kernfs_root *root);

struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
      const char *name, umode_t mode,
      kuid_t uid, kgid_t gid,
      void *priv, const void *ns);
struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,
         const char *name);
struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
      const char *name, umode_t mode,
      kuid_t uid, kgid_t gid,
      loff_t size,
      const struct kernfs_ops *ops,
      void *priv, const void *ns,
      struct lock_class_key *key);
struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
           const char *name,
           struct kernfs_node *target);
void kernfs_activate(struct kernfs_node *kn);
void kernfs_remove(struct kernfs_node *kn);
void kernfs_break_active_protection(struct kernfs_node *kn);
void kernfs_unbreak_active_protection(struct kernfs_node *kn);
bool kernfs_remove_self(struct kernfs_node *kn);
int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
        const void *ns);
int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
       const char *new_name, const void *new_ns);
int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
__poll_t kernfs_generic_poll(struct kernfs_open_file *of,
        struct poll_table_struct *pt);
void kernfs_notify(struct kernfs_node *kn);

int kernfs_xattr_get(struct kernfs_node *kn, const char *name,
       void *value, size_t size);
int kernfs_xattr_set(struct kernfs_node *kn, const char *name,
       const void *value, size_t size, int flags);

const void *kernfs_super_ns(struct super_block *sb);
int kernfs_get_tree(struct fs_context *fc);
void kernfs_free_fs_context(struct fs_context *fc);
void kernfs_kill_sb(struct super_block *sb);

void kernfs_init(void);

struct kernfs_node *kernfs_find_and_get_node_by_id(struct kernfs_root *root,
         u64 id);
# 540 "/home/nathan/src/linux-next/include/linux/kernfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)
{
 return kernfs_path_from_node(kn, ((void *)0), buf, buflen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_find_and_get(struct kernfs_node *kn, const char *name)
{
 return kernfs_find_and_get_ns(kn, name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_walk_and_get(struct kernfs_node *kn, const char *path)
{
 return kernfs_walk_and_get_ns(kn, path, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_dir(struct kernfs_node *parent, const char *name, umode_t mode,
    void *priv)
{
 return kernfs_create_dir_ns(parent, name, mode,
        (kuid_t){ 0 }, (kgid_t){ 0 },
        priv, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
        umode_t mode, kuid_t uid, kgid_t gid,
        loff_t size, const struct kernfs_ops *ops,
        void *priv, const void *ns)
{
 struct lock_class_key *key = ((void *)0);




 return __kernfs_create_file(parent, name, mode, uid, gid,
        size, ops, priv, ns, key);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_file(struct kernfs_node *parent, const char *name, umode_t mode,
     loff_t size, const struct kernfs_ops *ops, void *priv)
{
 return kernfs_create_file_ns(parent, name, mode,
         (kuid_t){ 0 }, (kgid_t){ 0 },
         size, ops, priv, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_remove_by_name(struct kernfs_node *parent,
     const char *name)
{
 return kernfs_remove_by_name_ns(parent, name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_rename(struct kernfs_node *kn,
    struct kernfs_node *new_parent,
    const char *new_name)
{
 return kernfs_rename_ns(kn, new_parent, new_name, ((void *)0));
}
# 17 "/home/nathan/src/linux-next/include/linux/sysfs.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/kobject_ns.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/kobject_ns.h"
struct sock;
struct kobject;





enum kobj_ns_type {
 KOBJ_NS_TYPE_NONE = 0,
 KOBJ_NS_TYPE_NET,
 KOBJ_NS_TYPES
};
# 39 "/home/nathan/src/linux-next/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
 enum kobj_ns_type type;
 bool (*current_may_mount)(void);
 void *(*grab_current_ns)(void);
 const void *(*netlink_ns)(struct sock *sk);
 const void *(*initial_ns)(void);
 void (*drop_ns)(void *);
};

int kobj_ns_type_register(const struct kobj_ns_type_operations *ops);
int kobj_ns_type_registered(enum kobj_ns_type type);
const struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent);
const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj);

bool kobj_ns_current_may_mount(enum kobj_ns_type type);
void *kobj_ns_grab_current(enum kobj_ns_type type);
const void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk);
const void *kobj_ns_initial(enum kobj_ns_type type);
void kobj_ns_drop(enum kobj_ns_type type, void *ns);
# 22 "/home/nathan/src/linux-next/include/linux/sysfs.h" 2



struct kobject;
struct module;
struct bin_attribute;
enum kobj_ns_type;

struct attribute {
 const char *name;
 umode_t mode;





};
# 84 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct attribute_group {
 const char *name;
 umode_t (*is_visible)(struct kobject *,
           struct attribute *, int);
 umode_t (*is_bin_visible)(struct kobject *,
        struct bin_attribute *, int);
 struct attribute **attrs;
 struct bin_attribute **bin_attrs;
};
# 158 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct file;
struct vm_area_struct;

struct bin_attribute {
 struct attribute attr;
 size_t size;
 void *private;
 ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
   char *, loff_t, size_t);
 ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,
    char *, loff_t, size_t);
 int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,
      struct vm_area_struct *vma);
};
# 223 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct sysfs_ops {
 ssize_t (*show)(struct kobject *, struct attribute *, char *);
 ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};



int __attribute__((__warn_unused_result__)) sysfs_create_dir_ns(struct kobject *kobj, const void *ns);
void sysfs_remove_dir(struct kobject *kobj);
int __attribute__((__warn_unused_result__)) sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,
         const void *new_ns);
int __attribute__((__warn_unused_result__)) sysfs_move_dir_ns(struct kobject *kobj,
       struct kobject *new_parent_kobj,
       const void *new_ns);
int __attribute__((__warn_unused_result__)) sysfs_create_mount_point(struct kobject *parent_kobj,
       const char *name);
void sysfs_remove_mount_point(struct kobject *parent_kobj,
         const char *name);

int __attribute__((__warn_unused_result__)) sysfs_create_file_ns(struct kobject *kobj,
          const struct attribute *attr,
          const void *ns);
int __attribute__((__warn_unused_result__)) sysfs_create_files(struct kobject *kobj,
       const struct attribute * const *attr);
int __attribute__((__warn_unused_result__)) sysfs_chmod_file(struct kobject *kobj,
      const struct attribute *attr, umode_t mode);
struct kernfs_node *sysfs_break_active_protection(struct kobject *kobj,
        const struct attribute *attr);
void sysfs_unbreak_active_protection(struct kernfs_node *kn);
void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,
     const void *ns);
bool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr);
void sysfs_remove_files(struct kobject *kobj, const struct attribute * const *attr);

int __attribute__((__warn_unused_result__)) sysfs_create_bin_file(struct kobject *kobj,
           const struct bin_attribute *attr);
void sysfs_remove_bin_file(struct kobject *kobj,
      const struct bin_attribute *attr);

int __attribute__((__warn_unused_result__)) sysfs_create_link(struct kobject *kobj, struct kobject *target,
       const char *name);
int __attribute__((__warn_unused_result__)) sysfs_create_link_nowarn(struct kobject *kobj,
       struct kobject *target,
       const char *name);
void sysfs_remove_link(struct kobject *kobj, const char *name);

int sysfs_rename_link_ns(struct kobject *kobj, struct kobject *target,
    const char *old_name, const char *new_name,
    const void *new_ns);

void sysfs_delete_link(struct kobject *dir, struct kobject *targ,
   const char *name);

int __attribute__((__warn_unused_result__)) sysfs_create_group(struct kobject *kobj,
        const struct attribute_group *grp);
int __attribute__((__warn_unused_result__)) sysfs_create_groups(struct kobject *kobj,
         const struct attribute_group **groups);
int __attribute__((__warn_unused_result__)) sysfs_update_groups(struct kobject *kobj,
         const struct attribute_group **groups);
int sysfs_update_group(struct kobject *kobj,
         const struct attribute_group *grp);
void sysfs_remove_group(struct kobject *kobj,
   const struct attribute_group *grp);
void sysfs_remove_groups(struct kobject *kobj,
    const struct attribute_group **groups);
int sysfs_add_file_to_group(struct kobject *kobj,
   const struct attribute *attr, const char *group);
void sysfs_remove_file_from_group(struct kobject *kobj,
   const struct attribute *attr, const char *group);
int sysfs_merge_group(struct kobject *kobj,
         const struct attribute_group *grp);
void sysfs_unmerge_group(struct kobject *kobj,
         const struct attribute_group *grp);
int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
       struct kobject *target, const char *link_name);
void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
      const char *link_name);
int compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
      struct kobject *target_kobj,
      const char *target_name,
      const char *symlink_name);

void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr);

int __attribute__((__warn_unused_result__)) sysfs_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_enable_ns(struct kernfs_node *kn)
{
 return kernfs_enable_ns(kn);
}

int sysfs_file_change_owner(struct kobject *kobj, const char *name, kuid_t kuid,
       kgid_t kgid);
int sysfs_change_owner(struct kobject *kobj, kuid_t kuid, kgid_t kgid);
int sysfs_link_change_owner(struct kobject *kobj, struct kobject *targ,
       const char *name, kuid_t kuid, kgid_t kgid);
int sysfs_groups_change_owner(struct kobject *kobj,
         const struct attribute_group **groups,
         kuid_t kuid, kgid_t kgid);
int sysfs_group_change_owner(struct kobject *kobj,
        const struct attribute_group *groups, kuid_t kuid,
        kgid_t kgid);
# 574 "/home/nathan/src/linux-next/include/linux/sysfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) sysfs_create_file(struct kobject *kobj,
       const struct attribute *attr)
{
 return sysfs_create_file_ns(kobj, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_remove_file(struct kobject *kobj,
         const struct attribute *attr)
{
 sysfs_remove_file_ns(kobj, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
        const char *old_name, const char *new_name)
{
 return sysfs_rename_link_ns(kobj, target, old_name, new_name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_notify_dirent(struct kernfs_node *kn)
{
 kernfs_notify(kn);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent,
         const char *name)
{
 return kernfs_find_and_get(parent, name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *sysfs_get(struct kernfs_node *kn)
{
 kernfs_get(kn);
 return kn;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_put(struct kernfs_node *kn)
{
 kernfs_put(kn);
}
# 21 "/home/nathan/src/linux-next/include/linux/kobject.h" 2
# 41 "/home/nathan/src/linux-next/include/linux/kobject.h"
extern u64 uevent_seqnum;
# 53 "/home/nathan/src/linux-next/include/linux/kobject.h"
enum kobject_action {
 KOBJ_ADD,
 KOBJ_REMOVE,
 KOBJ_CHANGE,
 KOBJ_MOVE,
 KOBJ_ONLINE,
 KOBJ_OFFLINE,
 KOBJ_BIND,
 KOBJ_UNBIND,
 KOBJ_MAX
};

struct kobject {
 const char *name;
 struct list_head entry;
 struct kobject *parent;
 struct kset *kset;
 struct kobj_type *ktype;
 struct kernfs_node *sd;
 struct kref kref;



 unsigned int state_initialized:1;
 unsigned int state_in_sysfs:1;
 unsigned int state_add_uevent_sent:1;
 unsigned int state_remove_uevent_sent:1;
 unsigned int uevent_suppress:1;
};

extern __attribute__((__format__(printf, 2, 3)))
int kobject_set_name(struct kobject *kobj, const char *name, ...);
extern __attribute__((__format__(printf, 2, 0)))
int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
      va_list vargs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kobject_name(const struct kobject *kobj)
{
 return kobj->name;
}

extern void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
extern __attribute__((__format__(printf, 3, 4))) __attribute__((__warn_unused_result__))
int kobject_add(struct kobject *kobj, struct kobject *parent,
  const char *fmt, ...);
extern __attribute__((__format__(printf, 4, 5))) __attribute__((__warn_unused_result__))
int kobject_init_and_add(struct kobject *kobj,
    struct kobj_type *ktype, struct kobject *parent,
    const char *fmt, ...);

extern void kobject_del(struct kobject *kobj);

extern struct kobject * __attribute__((__warn_unused_result__)) kobject_create(void);
extern struct kobject * __attribute__((__warn_unused_result__)) kobject_create_and_add(const char *name,
      struct kobject *parent);

extern int __attribute__((__warn_unused_result__)) kobject_rename(struct kobject *, const char *new_name);
extern int __attribute__((__warn_unused_result__)) kobject_move(struct kobject *, struct kobject *);

extern struct kobject *kobject_get(struct kobject *kobj);
extern struct kobject * __attribute__((__warn_unused_result__)) kobject_get_unless_zero(
      struct kobject *kobj);
extern void kobject_put(struct kobject *kobj);

extern const void *kobject_namespace(struct kobject *kobj);
extern void kobject_get_ownership(struct kobject *kobj,
      kuid_t *uid, kgid_t *gid);
extern char *kobject_get_path(struct kobject *kobj, gfp_t flag);
# 132 "/home/nathan/src/linux-next/include/linux/kobject.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kobject_has_children(struct kobject *kobj)
{
 ({ int __ret_warn_on = !!(kref_read(&kobj->kref) == 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kobject.h"), "i" (134), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

 return kobj->sd && kobj->sd->dir.subdirs;
}

struct kobj_type {
 void (*release)(struct kobject *kobj);
 const struct sysfs_ops *sysfs_ops;
 struct attribute **default_attrs;
 const struct attribute_group **default_groups;
 const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
 const void *(*namespace)(struct kobject *kobj);
 void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid);
};

struct kobj_uevent_env {
 char *argv[3];
 char *envp[64];
 int envp_idx;
 char buf[2048];
 int buflen;
};

struct kset_uevent_ops {
 int (* const filter)(struct kset *kset, struct kobject *kobj);
 const char *(* const name)(struct kset *kset, struct kobject *kobj);
 int (* const uevent)(struct kset *kset, struct kobject *kobj,
        struct kobj_uevent_env *env);
};

struct kobj_attribute {
 struct attribute attr;
 ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
   char *buf);
 ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
    const char *buf, size_t count);
};

extern const struct sysfs_ops kobj_sysfs_ops;

struct sock;
# 193 "/home/nathan/src/linux-next/include/linux/kobject.h"
struct kset {
 struct list_head list;
 spinlock_t list_lock;
 struct kobject kobj;
 const struct kset_uevent_ops *uevent_ops;
} ;

extern void kset_init(struct kset *kset);
extern int __attribute__((__warn_unused_result__)) kset_register(struct kset *kset);
extern void kset_unregister(struct kset *kset);
extern struct kset * __attribute__((__warn_unused_result__)) kset_create_and_add(const char *name,
      const struct kset_uevent_ops *u,
      struct kobject *parent_kobj);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kset *to_kset(struct kobject *kobj)
{
 return kobj ? ({ void *__mptr = (void *)(kobj); do { extern void __compiletime_assert_175(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(kobj)), typeof(((struct kset *)0)->kobj)) && !__builtin_types_compatible_p(typeof(*(kobj)), typeof(void))))) __compiletime_assert_175(); } while (0); ((struct kset *)(__mptr - __builtin_offsetof(struct kset, kobj))); }) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kset *kset_get(struct kset *k)
{
 return k ? to_kset(kobject_get(&k->kobj)) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kset_put(struct kset *k)
{
 kobject_put(&k->kobj);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kobj_type *get_ktype(struct kobject *kobj)
{
 return kobj->ktype;
}

extern struct kobject *kset_find_obj(struct kset *, const char *);


extern struct kobject *kernel_kobj;

extern struct kobject *mm_kobj;

extern struct kobject *hypervisor_kobj;

extern struct kobject *power_kobj;

extern struct kobject *firmware_kobj;

int kobject_uevent(struct kobject *kobj, enum kobject_action action);
int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
   char *envp[]);
int kobject_synth_uevent(struct kobject *kobj, const char *buf, size_t count);

__attribute__((__format__(printf, 2, 3)))
int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...);
# 18 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/klist.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/klist.h"
struct klist_node;
struct klist {
 spinlock_t k_lock;
 struct list_head k_list;
 void (*get)(struct klist_node *);
 void (*put)(struct klist_node *);
} __attribute__ ((aligned (sizeof(void *))));
# 34 "/home/nathan/src/linux-next/include/linux/klist.h"
extern void klist_init(struct klist *k, void (*get)(struct klist_node *),
         void (*put)(struct klist_node *));

struct klist_node {
 void *n_klist;
 struct list_head n_node;
 struct kref n_ref;
};

extern void klist_add_tail(struct klist_node *n, struct klist *k);
extern void klist_add_head(struct klist_node *n, struct klist *k);
extern void klist_add_behind(struct klist_node *n, struct klist_node *pos);
extern void klist_add_before(struct klist_node *n, struct klist_node *pos);

extern void klist_del(struct klist_node *n);
extern void klist_remove(struct klist_node *n);

extern int klist_node_attached(struct klist_node *n);


struct klist_iter {
 struct klist *i_klist;
 struct klist_node *i_cur;
};


extern void klist_iter_init(struct klist *k, struct klist_iter *i);
extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,
     struct klist_node *n);
extern void klist_iter_exit(struct klist_iter *i);
extern struct klist_node *klist_prev(struct klist_iter *i);
extern struct klist_node *klist_next(struct klist_iter *i);
# 19 "/home/nathan/src/linux-next/include/linux/device.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/pm.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/pm.h"
extern void (*pm_power_off)(void);
extern void (*pm_power_off_prepare)(void);

struct device;

extern void pm_vt_switch_required(struct device *dev, bool required);
extern void pm_vt_switch_unregister(struct device *dev);
# 42 "/home/nathan/src/linux-next/include/linux/pm.h"
struct device;


extern const char power_group_name[];




typedef struct pm_message {
 int event;
} pm_message_t;
# 278 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_ops {
 int (*prepare)(struct device *dev);
 void (*complete)(struct device *dev);
 int (*suspend)(struct device *dev);
 int (*resume)(struct device *dev);
 int (*freeze)(struct device *dev);
 int (*thaw)(struct device *dev);
 int (*poweroff)(struct device *dev);
 int (*restore)(struct device *dev);
 int (*suspend_late)(struct device *dev);
 int (*resume_early)(struct device *dev);
 int (*freeze_late)(struct device *dev);
 int (*thaw_early)(struct device *dev);
 int (*poweroff_late)(struct device *dev);
 int (*restore_early)(struct device *dev);
 int (*suspend_noirq)(struct device *dev);
 int (*resume_noirq)(struct device *dev);
 int (*freeze_noirq)(struct device *dev);
 int (*thaw_noirq)(struct device *dev);
 int (*poweroff_noirq)(struct device *dev);
 int (*restore_noirq)(struct device *dev);
 int (*runtime_suspend)(struct device *dev);
 int (*runtime_resume)(struct device *dev);
 int (*runtime_idle)(struct device *dev);
};
# 496 "/home/nathan/src/linux-next/include/linux/pm.h"
enum rpm_status {
 RPM_ACTIVE = 0,
 RPM_RESUMING,
 RPM_SUSPENDED,
 RPM_SUSPENDING,
};
# 518 "/home/nathan/src/linux-next/include/linux/pm.h"
enum rpm_request {
 RPM_REQ_NONE = 0,
 RPM_REQ_IDLE,
 RPM_REQ_SUSPEND,
 RPM_REQ_AUTOSUSPEND,
 RPM_REQ_RESUME,
};

struct wakeup_source;
struct wake_irq;
struct pm_domain_data;

struct pm_subsys_data {
 spinlock_t lock;
 unsigned int refcount;




 struct pm_domain_data *domain_data;

};
# 559 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_info {
 pm_message_t power_state;
 unsigned int can_wakeup:1;
 unsigned int async_suspend:1;
 bool in_dpm_list:1;
 bool is_prepared:1;
 bool is_suspended:1;
 bool is_noirq_suspended:1;
 bool is_late_suspended:1;
 bool no_pm:1;
 bool early_init:1;
 bool direct_complete:1;
 u32 driver_flags;
 spinlock_t lock;

 struct list_head entry;
 struct completion completion;
 struct wakeup_source *wakeup;
 bool wakeup_path:1;
 bool syscore:1;
 bool no_pm_callbacks:1;
 unsigned int must_resume:1;
 unsigned int may_skip_resume:1;




 struct hrtimer suspend_timer;
 unsigned long timer_expires;
 struct work_struct work;
 wait_queue_head_t wait_queue;
 struct wake_irq *wakeirq;
 atomic_t usage_count;
 atomic_t child_count;
 unsigned int disable_depth:3;
 unsigned int idle_notification:1;
 unsigned int request_pending:1;
 unsigned int deferred_resume:1;
 unsigned int runtime_auto:1;
 bool ignore_children:1;
 unsigned int no_callbacks:1;
 unsigned int irq_safe:1;
 unsigned int use_autosuspend:1;
 unsigned int timer_autosuspends:1;
 unsigned int memalloc_noio:1;
 unsigned int links_count;
 enum rpm_request request;
 enum rpm_status runtime_status;
 int runtime_error;
 int autosuspend_delay;
 u64 last_busy;
 u64 active_time;
 u64 suspended_time;
 u64 accounting_timestamp;

 struct pm_subsys_data *subsys_data;
 void (*set_latency_tolerance)(struct device *, s32);
 struct dev_pm_qos *qos;
};

extern int dev_pm_get_subsys_data(struct device *dev);
extern void dev_pm_put_subsys_data(struct device *dev);
# 636 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_domain {
 struct dev_pm_ops ops;
 int (*start)(struct device *dev);
 void (*detach)(struct device *dev, bool power_off);
 int (*activate)(struct device *dev);
 void (*sync)(struct device *dev);
 void (*dismiss)(struct device *dev);
};
# 700 "/home/nathan/src/linux-next/include/linux/pm.h"
extern void device_pm_lock(void);
extern void dpm_resume_start(pm_message_t state);
extern void dpm_resume_end(pm_message_t state);
extern void dpm_resume_noirq(pm_message_t state);
extern void dpm_resume_early(pm_message_t state);
extern void dpm_resume(pm_message_t state);
extern void dpm_complete(pm_message_t state);

extern void device_pm_unlock(void);
extern int dpm_suspend_end(pm_message_t state);
extern int dpm_suspend_start(pm_message_t state);
extern int dpm_suspend_noirq(pm_message_t state);
extern int dpm_suspend_late(pm_message_t state);
extern int dpm_suspend(pm_message_t state);
extern int dpm_prepare(pm_message_t state);

extern void __suspend_report_result(const char *function, void *fn, int ret);






extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));

extern int pm_generic_prepare(struct device *dev);
extern int pm_generic_suspend_late(struct device *dev);
extern int pm_generic_suspend_noirq(struct device *dev);
extern int pm_generic_suspend(struct device *dev);
extern int pm_generic_resume_early(struct device *dev);
extern int pm_generic_resume_noirq(struct device *dev);
extern int pm_generic_resume(struct device *dev);
extern int pm_generic_freeze_noirq(struct device *dev);
extern int pm_generic_freeze_late(struct device *dev);
extern int pm_generic_freeze(struct device *dev);
extern int pm_generic_thaw_noirq(struct device *dev);
extern int pm_generic_thaw_early(struct device *dev);
extern int pm_generic_thaw(struct device *dev);
extern int pm_generic_restore_noirq(struct device *dev);
extern int pm_generic_restore_early(struct device *dev);
extern int pm_generic_restore(struct device *dev);
extern int pm_generic_poweroff_noirq(struct device *dev);
extern int pm_generic_poweroff_late(struct device *dev);
extern int pm_generic_poweroff(struct device *dev);
extern void pm_generic_complete(struct device *dev);

extern bool dev_pm_skip_resume(struct device *dev);
extern bool dev_pm_skip_suspend(struct device *dev);
# 794 "/home/nathan/src/linux-next/include/linux/pm.h"
enum dpm_order {
 DPM_ORDER_NONE,
 DPM_ORDER_DEV_AFTER_PARENT,
 DPM_ORDER_PARENT_BEFORE_DEV,
 DPM_ORDER_DEV_LAST,
};
# 25 "/home/nathan/src/linux-next/include/linux/device.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/device/bus.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/device/bus.h"
struct device_driver;
struct fwnode_handle;
# 82 "/home/nathan/src/linux-next/include/linux/device/bus.h"
struct bus_type {
 const char *name;
 const char *dev_name;
 struct device *dev_root;
 const struct attribute_group **bus_groups;
 const struct attribute_group **dev_groups;
 const struct attribute_group **drv_groups;

 int (*match)(struct device *dev, struct device_driver *drv);
 int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 int (*probe)(struct device *dev);
 void (*sync_state)(struct device *dev);
 int (*remove)(struct device *dev);
 void (*shutdown)(struct device *dev);

 int (*online)(struct device *dev);
 int (*offline)(struct device *dev);

 int (*suspend)(struct device *dev, pm_message_t state);
 int (*resume)(struct device *dev);

 int (*num_vf)(struct device *dev);

 int (*dma_configure)(struct device *dev);

 const struct dev_pm_ops *pm;

 const struct iommu_ops *iommu_ops;

 struct subsys_private *p;
 struct lock_class_key lock_key;

 bool need_parent_lock;
};

extern int __attribute__((__warn_unused_result__)) bus_register(struct bus_type *bus);

extern void bus_unregister(struct bus_type *bus);

extern int __attribute__((__warn_unused_result__)) bus_rescan_devices(struct bus_type *bus);

struct bus_attribute {
 struct attribute attr;
 ssize_t (*show)(struct bus_type *bus, char *buf);
 ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};
# 136 "/home/nathan/src/linux-next/include/linux/device/bus.h"
extern int __attribute__((__warn_unused_result__)) bus_create_file(struct bus_type *,
     struct bus_attribute *);
extern void bus_remove_file(struct bus_type *, struct bus_attribute *);


int device_match_name(struct device *dev, const void *name);
int device_match_of_node(struct device *dev, const void *np);
int device_match_fwnode(struct device *dev, const void *fwnode);
int device_match_devt(struct device *dev, const void *pdevt);
int device_match_acpi_dev(struct device *dev, const void *adev);
int device_match_any(struct device *dev, const void *unused);


struct subsys_dev_iter {
 struct klist_iter ki;
 const struct device_type *type;
};
void subsys_dev_iter_init(struct subsys_dev_iter *iter,
    struct bus_type *subsys,
    struct device *start,
    const struct device_type *type);
struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
void subsys_dev_iter_exit(struct subsys_dev_iter *iter);

int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
       int (*fn)(struct device *dev, void *data));
struct device *bus_find_device(struct bus_type *bus, struct device *start,
          const void *data,
          int (*match)(struct device *dev, const void *data));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *bus_find_device_by_name(struct bus_type *bus,
           struct device *start,
           const char *name)
{
 return bus_find_device(bus, start, name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_of_node(struct bus_type *bus, const struct device_node *np)
{
 return bus_find_device(bus, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_fwnode(struct bus_type *bus, const struct fwnode_handle *fwnode)
{
 return bus_find_device(bus, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *bus_find_device_by_devt(struct bus_type *bus,
           dev_t devt)
{
 return bus_find_device(bus, ((void *)0), &devt, device_match_devt);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_next_device(struct bus_type *bus,struct device *cur)
{
 return bus_find_device(bus, cur, ((void *)0), device_match_any);
}
# 242 "/home/nathan/src/linux-next/include/linux/device/bus.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_acpi_dev(struct bus_type *bus, const void *adev)
{
 return ((void *)0);
}


struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
     struct device *hint);
int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
       void *data, int (*fn)(struct device_driver *, void *));
void bus_sort_breadthfirst(struct bus_type *bus,
      int (*compare)(const struct device *a,
       const struct device *b));






struct notifier_block;

extern int bus_register_notifier(struct bus_type *bus,
     struct notifier_block *nb);
extern int bus_unregister_notifier(struct bus_type *bus,
       struct notifier_block *nb);
# 285 "/home/nathan/src/linux-next/include/linux/device/bus.h"
extern struct kset *bus_get_kset(struct bus_type *bus);
extern struct klist *bus_get_device_klist(struct bus_type *bus);
# 30 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device/class.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct device;
struct fwnode_handle;
# 54 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct class {
 const char *name;
 struct module *owner;

 const struct attribute_group **class_groups;
 const struct attribute_group **dev_groups;
 struct kobject *dev_kobj;

 int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
 char *(*devnode)(struct device *dev, umode_t *mode);

 void (*class_release)(struct class *class);
 void (*dev_release)(struct device *dev);

 int (*shutdown_pre)(struct device *dev);

 const struct kobj_ns_type_operations *ns_type;
 const void *(*namespace)(struct device *dev);

 void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid);

 const struct dev_pm_ops *pm;

 struct subsys_private *p;
};

struct class_dev_iter {
 struct klist_iter ki;
 const struct device_type *type;
};

extern struct kobject *sysfs_dev_block_kobj;
extern struct kobject *sysfs_dev_char_kobj;
extern int __attribute__((__warn_unused_result__)) __class_register(struct class *class,
      struct lock_class_key *key);
extern void class_unregister(struct class *class);
# 99 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct class_compat;
struct class_compat *class_compat_register(const char *name);
void class_compat_unregister(struct class_compat *cls);
int class_compat_create_link(struct class_compat *cls, struct device *dev,
        struct device *device_link);
void class_compat_remove_link(struct class_compat *cls, struct device *dev,
         struct device *device_link);

extern void class_dev_iter_init(struct class_dev_iter *iter,
    struct class *class,
    struct device *start,
    const struct device_type *type);
extern struct device *class_dev_iter_next(struct class_dev_iter *iter);
extern void class_dev_iter_exit(struct class_dev_iter *iter);

extern int class_for_each_device(struct class *class, struct device *start,
     void *data,
     int (*fn)(struct device *dev, void *data));
extern struct device *class_find_device(struct class *class,
     struct device *start, const void *data,
     int (*match)(struct device *, const void *));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *class_find_device_by_name(struct class *class,
             const char *name)
{
 return class_find_device(class, ((void *)0), name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_of_node(struct class *class, const struct device_node *np)
{
 return class_find_device(class, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_fwnode(struct class *class,
       const struct fwnode_handle *fwnode)
{
 return class_find_device(class, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *class_find_device_by_devt(struct class *class,
             dev_t devt)
{
 return class_find_device(class, ((void *)0), &devt, device_match_devt);
}
# 184 "/home/nathan/src/linux-next/include/linux/device/class.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_acpi_dev(struct class *class, const void *adev)
{
 return ((void *)0);
}


struct class_attribute {
 struct attribute attr;
 ssize_t (*show)(struct class *class, struct class_attribute *attr,
   char *buf);
 ssize_t (*store)(struct class *class, struct class_attribute *attr,
   const char *buf, size_t count);
};
# 206 "/home/nathan/src/linux-next/include/linux/device/class.h"
extern int __attribute__((__warn_unused_result__)) class_create_file_ns(struct class *class,
          const struct class_attribute *attr,
          const void *ns);
extern void class_remove_file_ns(struct class *class,
     const struct class_attribute *attr,
     const void *ns);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) class_create_file(struct class *class,
     const struct class_attribute *attr)
{
 return class_create_file_ns(class, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void class_remove_file(struct class *class,
         const struct class_attribute *attr)
{
 return class_remove_file_ns(class, attr, ((void *)0));
}


struct class_attribute_string {
 struct class_attribute attr;
 char *str;
};
# 238 "/home/nathan/src/linux-next/include/linux/device/class.h"
extern ssize_t show_class_attr_string(struct class *class, struct class_attribute *attr,
                        char *buf);

struct class_interface {
 struct list_head node;
 struct class *class;

 int (*add_dev) (struct device *, struct class_interface *);
 void (*remove_dev) (struct device *, struct class_interface *);
};

extern int __attribute__((__warn_unused_result__)) class_interface_register(struct class_interface *);
extern void class_interface_unregister(struct class_interface *);

extern struct class * __attribute__((__warn_unused_result__)) __class_create(struct module *owner,
        const char *name,
        struct lock_class_key *key);
extern void class_destroy(struct class *cls);
# 31 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device/driver.h" 1
# 44 "/home/nathan/src/linux-next/include/linux/device/driver.h"
enum probe_type {
 PROBE_DEFAULT_STRATEGY,
 PROBE_PREFER_ASYNCHRONOUS,
 PROBE_FORCE_SYNCHRONOUS,
};
# 95 "/home/nathan/src/linux-next/include/linux/device/driver.h"
struct device_driver {
 const char *name;
 struct bus_type *bus;

 struct module *owner;
 const char *mod_name;

 bool suppress_bind_attrs;
 enum probe_type probe_type;

 const struct of_device_id *of_match_table;
 const struct acpi_device_id *acpi_match_table;

 int (*probe) (struct device *dev);
 void (*sync_state)(struct device *dev);
 int (*remove) (struct device *dev);
 void (*shutdown) (struct device *dev);
 int (*suspend) (struct device *dev, pm_message_t state);
 int (*resume) (struct device *dev);
 const struct attribute_group **groups;
 const struct attribute_group **dev_groups;

 const struct dev_pm_ops *pm;
 void (*coredump) (struct device *dev);

 struct driver_private *p;
};


extern int __attribute__((__warn_unused_result__)) driver_register(struct device_driver *drv);
extern void driver_unregister(struct device_driver *drv);

extern struct device_driver *driver_find(const char *name,
      struct bus_type *bus);
extern int driver_probe_done(void);
extern void wait_for_device_probe(void);



struct driver_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device_driver *driver, char *buf);
 ssize_t (*store)(struct device_driver *driver, const char *buf,
    size_t count);
};
# 148 "/home/nathan/src/linux-next/include/linux/device/driver.h"
extern int __attribute__((__warn_unused_result__)) driver_create_file(struct device_driver *driver,
     const struct driver_attribute *attr);
extern void driver_remove_file(struct device_driver *driver,
          const struct driver_attribute *attr);

extern int __attribute__((__warn_unused_result__)) driver_for_each_device(struct device_driver *drv,
            struct device *start,
            void *data,
            int (*fn)(struct device *dev,
        void *));
struct device *driver_find_device(struct device_driver *drv,
      struct device *start, const void *data,
      int (*match)(struct device *dev, const void *data));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_device_by_name(struct device_driver *drv,
       const char *name)
{
 return driver_find_device(drv, ((void *)0), name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_of_node(struct device_driver *drv,
         const struct device_node *np)
{
 return driver_find_device(drv, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_fwnode(struct device_driver *drv,
        const struct fwnode_handle *fwnode)
{
 return driver_find_device(drv, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_device_by_devt(struct device_driver *drv,
       dev_t devt)
{
 return driver_find_device(drv, ((void *)0), &devt, device_match_devt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_next_device(struct device_driver *drv,
           struct device *start)
{
 return driver_find_device(drv, start, ((void *)0), device_match_any);
}
# 232 "/home/nathan/src/linux-next/include/linux/device/driver.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_acpi_dev(struct device_driver *drv, const void *adev)
{
 return ((void *)0);
}


extern int driver_deferred_probe_timeout;
void driver_deferred_probe_add(struct device *dev);
int driver_deferred_probe_check_state(struct device *dev);
void driver_init(void);
# 32 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/device.h" 1







struct device_node;

struct pci_dn;
struct iommu_table;
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/device.h"
struct dev_archdata {




 bool iommu_bypass : 1;





 dma_addr_t dma_offset;


 struct iommu_table *iommu_table_base;



 void *iommu_domain;


 struct pci_dn *pci_data;


 struct eeh_dev *edev;





 struct cxl_context *cxl_ctx;

};

struct pdev_archdata {
 u64 dma_mask;
};
# 33 "/home/nathan/src/linux-next/include/linux/device.h" 2

struct device;
struct device_private;
struct device_driver;
struct driver_private;
struct module;
struct class;
struct subsys_private;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct dev_pin_info;
struct dev_iommu;
# 61 "/home/nathan/src/linux-next/include/linux/device.h"
struct subsys_interface {
 const char *name;
 struct bus_type *subsys;
 struct list_head node;
 int (*add_dev)(struct device *dev, struct subsys_interface *sif);
 void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};

int subsys_interface_register(struct subsys_interface *sif);
void subsys_interface_unregister(struct subsys_interface *sif);

int subsys_system_register(struct bus_type *subsys,
      const struct attribute_group **groups);
int subsys_virtual_register(struct bus_type *subsys,
       const struct attribute_group **groups);
# 86 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_type {
 const char *name;
 const struct attribute_group **groups;
 int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 char *(*devnode)(struct device *dev, umode_t *mode,
    kuid_t *uid, kgid_t *gid);
 void (*release)(struct device *dev);

 const struct dev_pm_ops *pm;
};


struct device_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device *dev, struct device_attribute *attr,
   char *buf);
 ssize_t (*store)(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
};

struct dev_ext_attribute {
 struct device_attribute attr;
 void *var;
};

ssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,
     char *buf);
ssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,
      const char *buf, size_t count);
ssize_t device_show_int(struct device *dev, struct device_attribute *attr,
   char *buf);
ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
   char *buf);
ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
# 148 "/home/nathan/src/linux-next/include/linux/device.h"
extern int device_create_file(struct device *device,
         const struct device_attribute *entry);
extern void device_remove_file(struct device *dev,
          const struct device_attribute *attr);
extern bool device_remove_file_self(struct device *dev,
        const struct device_attribute *attr);
extern int __attribute__((__warn_unused_result__)) device_create_bin_file(struct device *dev,
     const struct bin_attribute *attr);
extern void device_remove_bin_file(struct device *dev,
       const struct bin_attribute *attr);


typedef void (*dr_release_t)(struct device *dev, void *res);
typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);


extern void *__devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
     int nid, const char *name) __attribute__((__malloc__));
# 179 "/home/nathan/src/linux-next/include/linux/device.h"
extern void devres_for_each_res(struct device *dev, dr_release_t release,
    dr_match_t match, void *match_data,
    void (*fn)(struct device *, void *, void *),
    void *data);
extern void devres_free(void *res);
extern void devres_add(struct device *dev, void *res);
extern void *devres_find(struct device *dev, dr_release_t release,
    dr_match_t match, void *match_data);
extern void *devres_get(struct device *dev, void *new_res,
   dr_match_t match, void *match_data);
extern void *devres_remove(struct device *dev, dr_release_t release,
      dr_match_t match, void *match_data);
extern int devres_destroy(struct device *dev, dr_release_t release,
     dr_match_t match, void *match_data);
extern int devres_release(struct device *dev, dr_release_t release,
     dr_match_t match, void *match_data);


extern void * __attribute__((__warn_unused_result__)) devres_open_group(struct device *dev, void *id,
          gfp_t gfp);
extern void devres_close_group(struct device *dev, void *id);
extern void devres_remove_group(struct device *dev, void *id);
extern int devres_release_group(struct device *dev, void *id);


extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) __attribute__((__malloc__));
extern __attribute__((__format__(printf, 3, 0)))
char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
        va_list ap) __attribute__((__malloc__));
extern __attribute__((__format__(printf, 3, 4)))
char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...) __attribute__((__malloc__));
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
 return devm_kmalloc(dev, size, gfp | (( gfp_t)0x100u));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kmalloc_array(struct device *dev,
           size_t n, size_t size, gfp_t flags)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);

 return devm_kmalloc(dev, bytes, flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kcalloc(struct device *dev,
     size_t n, size_t size, gfp_t flags)
{
 return devm_kmalloc_array(dev, n, size, flags | (( gfp_t)0x100u));
}
extern void devm_kfree(struct device *dev, const void *p);
extern char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp) __attribute__((__malloc__));
extern const char *devm_kstrdup_const(struct device *dev,
          const char *s, gfp_t gfp);
extern void *devm_kmemdup(struct device *dev, const void *src, size_t len,
     gfp_t gfp);

extern unsigned long devm_get_free_pages(struct device *dev,
      gfp_t gfp_mask, unsigned int order);
extern void devm_free_pages(struct device *dev, unsigned long addr);

void *devm_ioremap_resource(struct device *dev,
        const struct resource *res);
void *devm_ioremap_resource_wc(struct device *dev,
           const struct resource *res);

void *devm_of_iomap(struct device *dev,
       struct device_node *node, int index,
       resource_size_t *size);


int devm_add_action(struct device *dev, void (*action)(void *), void *data);
void devm_remove_action(struct device *dev, void (*action)(void *), void *data);
void devm_release_action(struct device *dev, void (*action)(void *), void *data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int devm_add_action_or_reset(struct device *dev,
        void (*action)(void *), void *data)
{
 int ret;

 ret = devm_add_action(dev, action, data);
 if (ret)
  action(data);

 return ret;
}
# 281 "/home/nathan/src/linux-next/include/linux/device.h"
void *__devm_alloc_percpu(struct device *dev, size_t size,
       size_t align);
void devm_free_percpu(struct device *dev, void *pdata);

struct device_dma_parameters {




 unsigned int max_segment_size;
 unsigned long segment_boundary_mask;
};
# 305 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_connection {
 struct fwnode_handle *fwnode;
 const char *endpoint[2];
 const char *id;
 struct list_head list;
};

typedef void *(*devcon_match_fn_t)(struct device_connection *con, int ep,
       void *data);

void *fwnode_connection_find_match(struct fwnode_handle *fwnode,
       const char *con_id, void *data,
       devcon_match_fn_t match);
void *device_connection_find_match(struct device *dev, const char *con_id,
       void *data, devcon_match_fn_t match);

struct device *device_connection_find(struct device *dev, const char *con_id);

void device_connection_add(struct device_connection *con);
void device_connection_remove(struct device_connection *con);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_connections_add(struct device_connection *cons)
{
 struct device_connection *c;

 for (c = cons; c->endpoint[0]; c++)
  device_connection_add(c);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_connections_remove(struct device_connection *cons)
{
 struct device_connection *c;

 for (c = cons; c->endpoint[0]; c++)
  device_connection_remove(c);
}
# 359 "/home/nathan/src/linux-next/include/linux/device.h"
enum device_link_state {
 DL_STATE_NONE = -1,
 DL_STATE_DORMANT = 0,
 DL_STATE_AVAILABLE,
 DL_STATE_CONSUMER_PROBE,
 DL_STATE_ACTIVE,
 DL_STATE_SUPPLIER_UNBIND,
};
# 402 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_link {
 struct device *supplier;
 struct list_head s_node;
 struct device *consumer;
 struct list_head c_node;
 enum device_link_state status;
 u32 flags;
 refcount_t rpm_active;
 struct kref kref;

 struct callback_head callback_head;

 bool supplier_preactivated;
};
# 424 "/home/nathan/src/linux-next/include/linux/device.h"
enum dl_dev_state {
 DL_DEV_NO_DRIVER = 0,
 DL_DEV_PROBING,
 DL_DEV_DRIVER_BOUND,
 DL_DEV_UNBINDING,
};
# 441 "/home/nathan/src/linux-next/include/linux/device.h"
struct dev_links_info {
 struct list_head suppliers;
 struct list_head consumers;
 struct list_head needs_suppliers;
 struct list_head defer_sync;
 bool need_for_probe;
 enum dl_dev_state status;
};
# 535 "/home/nathan/src/linux-next/include/linux/device.h"
struct device {
 struct kobject kobj;
 struct device *parent;

 struct device_private *p;

 const char *init_name;
 const struct device_type *type;

 struct bus_type *bus;
 struct device_driver *driver;

 void *platform_data;

 void *driver_data;




 struct mutex mutex;



 struct dev_links_info links;
 struct dev_pm_info power;
 struct dev_pm_domain *pm_domain;


 struct irq_domain *msi_domain;





 struct list_head msi_list;


 const struct dma_map_ops *dma_ops;
 u64 *dma_mask;
 u64 coherent_dma_mask;




 u64 bus_dma_limit;
 unsigned long dma_pfn_offset;

 struct device_dma_parameters *dma_parms;

 struct list_head dma_pools;


 struct dma_coherent_mem *dma_mem;







 struct dev_archdata archdata;

 struct device_node *of_node;
 struct fwnode_handle *fwnode;


 int numa_node;

 dev_t devt;
 u32 id;

 spinlock_t devres_lock;
 struct list_head devres_head;

 struct class *class;
 const struct attribute_group **groups;

 void (*release)(struct device *dev);
 struct iommu_group *iommu_group;
 struct dev_iommu *iommu;

 bool offline_disabled:1;
 bool offline:1;
 bool of_node_reused:1;
 bool state_synced:1;





};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *kobj_to_dev(struct kobject *kobj)
{
 return ({ void *__mptr = (void *)(kobj); do { extern void __compiletime_assert_176(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(kobj)), typeof(((struct device *)0)->kobj)) && !__builtin_types_compatible_p(typeof(*(kobj)), typeof(void))))) __compiletime_assert_176(); } while (0); ((struct device *)(__mptr - __builtin_offsetof(struct device, kobj))); });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_iommu_mapped(struct device *dev)
{
 return (dev->iommu_group != ((void *)0));
}



# 1 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
struct wake_irq;
# 43 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
struct wakeup_source {
 const char *name;
 int id;
 struct list_head entry;
 spinlock_t lock;
 struct wake_irq *wakeirq;
 struct timer_list timer;
 unsigned long timer_expires;
 ktime_t total_time;
 ktime_t max_time;
 ktime_t last_time;
 ktime_t start_prevent_time;
 ktime_t prevent_sleep_time;
 unsigned long event_count;
 unsigned long active_count;
 unsigned long relax_count;
 unsigned long expire_count;
 unsigned long wakeup_count;
 struct device *dev;
 bool active:1;
 bool autosleep_enabled:1;
};
# 77 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_can_wakeup(struct device *dev)
{
 return dev->power.can_wakeup;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_may_wakeup(struct device *dev)
{
 return dev->power.can_wakeup && !!dev->power.wakeup;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_set_wakeup_path(struct device *dev)
{
 dev->power.wakeup_path = true;
}


extern struct wakeup_source *wakeup_source_create(const char *name);
extern void wakeup_source_destroy(struct wakeup_source *ws);
extern void wakeup_source_add(struct wakeup_source *ws);
extern void wakeup_source_remove(struct wakeup_source *ws);
extern struct wakeup_source *wakeup_source_register(struct device *dev,
          const char *name);
extern void wakeup_source_unregister(struct wakeup_source *ws);
extern int wakeup_sources_read_lock(void);
extern void wakeup_sources_read_unlock(int idx);
extern struct wakeup_source *wakeup_sources_walk_start(void);
extern struct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws);
extern int device_wakeup_enable(struct device *dev);
extern int device_wakeup_disable(struct device *dev);
extern void device_set_wakeup_capable(struct device *dev, bool capable);
extern int device_init_wakeup(struct device *dev, bool val);
extern int device_set_wakeup_enable(struct device *dev, bool enable);
extern void __pm_stay_awake(struct wakeup_source *ws);
extern void pm_stay_awake(struct device *dev);
extern void __pm_relax(struct wakeup_source *ws);
extern void pm_relax(struct device *dev);
extern void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard);
extern void pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard);
# 195 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
{
 return pm_wakeup_ws_event(ws, msec, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pm_wakeup_event(struct device *dev, unsigned int msec)
{
 return pm_wakeup_dev_event(dev, msec, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pm_wakeup_hard_event(struct device *dev)
{
 return pm_wakeup_dev_event(dev, 0, true);
}
# 644 "/home/nathan/src/linux-next/include/linux/device.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *dev_name(const struct device *dev)
{

 if (dev->init_name)
  return dev->init_name;

 return kobject_name(&dev->kobj);
}

extern __attribute__((__format__(printf, 2, 3)))
int dev_set_name(struct device *dev, const char *name, ...);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_to_node(struct device *dev)
{
 return dev->numa_node;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_dev_node(struct device *dev, int node)
{
 dev->numa_node = node;
}
# 676 "/home/nathan/src/linux-next/include/linux/device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *dev_get_msi_domain(const struct device *dev)
{

 return dev->msi_domain;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
{

 dev->msi_domain = d;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dev_get_drvdata(const struct device *dev)
{
 return dev->driver_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_drvdata(struct device *dev, void *data)
{
 dev->driver_data = data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pm_subsys_data *dev_to_psd(struct device *dev)
{
 return dev ? dev->power.subsys_data : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dev_get_uevent_suppress(const struct device *dev)
{
 return dev->kobj.uevent_suppress;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_uevent_suppress(struct device *dev, int val)
{
 dev->kobj.uevent_suppress = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_is_registered(struct device *dev)
{
 return dev->kobj.state_in_sysfs;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_enable_async_suspend(struct device *dev)
{
 if (!dev->power.is_prepared)
  dev->power.async_suspend = true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_disable_async_suspend(struct device *dev)
{
 if (!dev->power.is_prepared)
  dev->power.async_suspend = false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_async_suspend_enabled(struct device *dev)
{
 return !!dev->power.async_suspend;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_pm_not_required(struct device *dev)
{
 return dev->power.no_pm;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_set_pm_not_required(struct device *dev)
{
 dev->power.no_pm = true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_pm_syscore_device(struct device *dev, bool val)
{

 dev->power.syscore = val;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_pm_set_driver_flags(struct device *dev, u32 flags)
{
 dev->power.driver_flags = flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_pm_test_driver_flags(struct device *dev, u32 flags)
{
 return !!(dev->power.driver_flags & flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_lock(struct device *dev)
{
 mutex_lock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_lock_interruptible(struct device *dev)
{
 return mutex_lock_interruptible(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_trylock(struct device *dev)
{
 return mutex_trylock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_unlock(struct device *dev)
{
 mutex_unlock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_lock_assert(struct device *dev)
{
 do { (void)(&dev->mutex); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *dev_of_node(struct device *dev)
{
 if (!1 || !dev)
  return ((void *)0);
 return dev->of_node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_has_sync_state(struct device *dev)
{
 if (!dev)
  return false;
 if (dev->driver && dev->driver->sync_state)
  return true;
 if (dev->bus && dev->bus->sync_state)
  return true;
 return false;
}




extern int __attribute__((__warn_unused_result__)) device_register(struct device *dev);
extern void device_unregister(struct device *dev);
extern void device_initialize(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_add(struct device *dev);
extern void device_del(struct device *dev);
extern int device_for_each_child(struct device *dev, void *data,
       int (*fn)(struct device *dev, void *data));
extern int device_for_each_child_reverse(struct device *dev, void *data,
       int (*fn)(struct device *dev, void *data));
extern struct device *device_find_child(struct device *dev, void *data,
    int (*match)(struct device *dev, void *data));
extern struct device *device_find_child_by_name(struct device *parent,
      const char *name);
extern int device_rename(struct device *dev, const char *new_name);
extern int device_move(struct device *dev, struct device *new_parent,
         enum dpm_order dpm_order);
extern int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
extern const char *device_get_devnode(struct device *dev,
          umode_t *mode, kuid_t *uid, kgid_t *gid,
          const char **tmp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_supports_offline(struct device *dev)
{
 return dev->bus && dev->bus->offline && dev->bus->online;
}

extern void lock_device_hotplug(void);
extern void unlock_device_hotplug(void);
extern int lock_device_hotplug_sysfs(void);
extern int device_offline(struct device *dev);
extern int device_online(struct device *dev);
extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
extern void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
void device_set_of_node_from_dev(struct device *dev, const struct device *dev2);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_num_vf(struct device *dev)
{
 if (dev->bus && dev->bus->num_vf)
  return dev->bus->num_vf(dev);
 return 0;
}




extern struct device *__root_device_register(const char *name,
          struct module *owner);





extern void root_device_unregister(struct device *root);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dev_get_platdata(const struct device *dev)
{
 return dev->platform_data;
}





extern int __attribute__((__warn_unused_result__)) device_bind_driver(struct device *dev);
extern void device_release_driver(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_attach(struct device *dev);
extern int __attribute__((__warn_unused_result__)) driver_attach(struct device_driver *drv);
extern void device_initial_probe(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_reprobe(struct device *dev);

extern bool device_is_bound(struct device *dev);




extern __attribute__((__format__(printf, 5, 6)))
struct device *device_create(struct class *cls, struct device *parent,
        dev_t devt, void *drvdata,
        const char *fmt, ...);
extern __attribute__((__format__(printf, 6, 7)))
struct device *device_create_with_groups(struct class *cls,
        struct device *parent, dev_t devt, void *drvdata,
        const struct attribute_group **groups,
        const char *fmt, ...);
extern void device_destroy(struct class *cls, dev_t devt);

extern int __attribute__((__warn_unused_result__)) device_add_groups(struct device *dev,
     const struct attribute_group **groups);
extern void device_remove_groups(struct device *dev,
     const struct attribute_group **groups);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) device_add_group(struct device *dev,
     const struct attribute_group *grp)
{
 const struct attribute_group *groups[] = { grp, ((void *)0) };

 return device_add_groups(dev, groups);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_remove_group(struct device *dev,
           const struct attribute_group *grp)
{
 const struct attribute_group *groups[] = { grp, ((void *)0) };

 return device_remove_groups(dev, groups);
}

extern int __attribute__((__warn_unused_result__)) devm_device_add_groups(struct device *dev,
     const struct attribute_group **groups);
extern void devm_device_remove_groups(struct device *dev,
          const struct attribute_group **groups);
extern int __attribute__((__warn_unused_result__)) devm_device_add_group(struct device *dev,
     const struct attribute_group *grp);
extern void devm_device_remove_group(struct device *dev,
         const struct attribute_group *grp);







extern int (*platform_notify)(struct device *dev);

extern int (*platform_notify_remove)(struct device *dev);






extern struct device *get_device(struct device *dev);
extern void put_device(struct device *dev);
extern bool kill_device(struct device *dev);


extern int devtmpfs_mount(void);





extern void device_shutdown(void);


extern const char *dev_driver_string(const struct device *dev);


struct device_link *device_link_add(struct device *consumer,
        struct device *supplier, u32 flags);
void device_link_del(struct device_link *link);
void device_link_remove(void *consumer, struct device *supplier);
void device_links_supplier_sync_state_pause(void);
void device_links_supplier_sync_state_resume(void);
# 33 "/home/nathan/src/linux-next/include/drm/drm_print.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/debugfs.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/debugfs.h"
struct device;
struct file_operations;

struct debugfs_blob_wrapper {
 void *data;
 unsigned long size;
};

struct debugfs_reg32 {
 char *name;
 unsigned long offset;
};

struct debugfs_regset32 {
 const struct debugfs_reg32 *regs;
 int nregs;
 void *base;
 struct device *dev;
};

extern struct dentry *arch_debugfs_dir;
# 58 "/home/nathan/src/linux-next/include/linux/debugfs.h"
typedef struct vfsmount *(*debugfs_automount_t)(struct dentry *, void *);



struct dentry *debugfs_lookup(const char *name, struct dentry *parent);

struct dentry *debugfs_create_file(const char *name, umode_t mode,
       struct dentry *parent, void *data,
       const struct file_operations *fops);
struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
       struct dentry *parent, void *data,
       const struct file_operations *fops);

void debugfs_create_file_size(const char *name, umode_t mode,
         struct dentry *parent, void *data,
         const struct file_operations *fops,
         loff_t file_size);

struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);

struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
          const char *dest);

struct dentry *debugfs_create_automount(const char *name,
     struct dentry *parent,
     debugfs_automount_t f,
     void *data);

void debugfs_remove(struct dentry *dentry);


const struct file_operations *debugfs_real_fops(const struct file *filp);

int debugfs_file_get(struct dentry *dentry);
void debugfs_file_put(struct dentry *dentry);

ssize_t debugfs_attr_read(struct file *file, char *buf,
   size_t len, loff_t *ppos);
ssize_t debugfs_attr_write(struct file *file, const char *buf,
   size_t len, loff_t *ppos);

struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,
                struct dentry *new_dir, const char *new_name);

void debugfs_create_u8(const char *name, umode_t mode, struct dentry *parent,
         u8 *value);
void debugfs_create_u16(const char *name, umode_t mode, struct dentry *parent,
   u16 *value);
void debugfs_create_u32(const char *name, umode_t mode, struct dentry *parent,
   u32 *value);
void debugfs_create_u64(const char *name, umode_t mode, struct dentry *parent,
   u64 *value);
struct dentry *debugfs_create_ulong(const char *name, umode_t mode,
        struct dentry *parent, unsigned long *value);
void debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent,
         u8 *value);
void debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent,
   u16 *value);
void debugfs_create_x32(const char *name, umode_t mode, struct dentry *parent,
   u32 *value);
void debugfs_create_x64(const char *name, umode_t mode, struct dentry *parent,
   u64 *value);
void debugfs_create_size_t(const char *name, umode_t mode,
      struct dentry *parent, size_t *value);
void debugfs_create_atomic_t(const char *name, umode_t mode,
        struct dentry *parent, atomic_t *value);
struct dentry *debugfs_create_bool(const char *name, umode_t mode,
      struct dentry *parent, bool *value);

struct dentry *debugfs_create_blob(const char *name, umode_t mode,
      struct dentry *parent,
      struct debugfs_blob_wrapper *blob);

void debugfs_create_regset32(const char *name, umode_t mode,
        struct dentry *parent,
        struct debugfs_regset32 *regset);

void debugfs_print_regs32(struct seq_file *s, const struct debugfs_reg32 *regs,
     int nregs, void *base, char *prefix);

void debugfs_create_u32_array(const char *name, umode_t mode,
         struct dentry *parent, u32 *array, u32 elements);

struct dentry *debugfs_create_devm_seqfile(struct device *dev, const char *name,
        struct dentry *parent,
        int (*read_fn)(struct seq_file *s,
         void *data));

bool debugfs_initialized(void);

ssize_t debugfs_read_file_bool(struct file *file, char *user_buf,
          size_t count, loff_t *ppos);

ssize_t debugfs_write_file_bool(struct file *file, const char *user_buf,
    size_t count, loff_t *ppos);
# 360 "/home/nathan/src/linux-next/include/linux/debugfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debugfs_create_xul(const char *name, umode_t mode,
          struct dentry *parent,
          unsigned long *value)
{
 if (sizeof(*value) == sizeof(u32))
  debugfs_create_x32(name, mode, parent, (u32 *)value);
 else
  debugfs_create_x64(name, mode, parent, (u64 *)value);
}
# 34 "/home/nathan/src/linux-next/include/drm/drm_print.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/drm/drm.h" 1
# 43 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
typedef unsigned int drm_handle_t;
# 84 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
typedef unsigned int drm_context_t;
typedef unsigned int drm_drawable_t;
typedef unsigned int drm_magic_t;
# 97 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_clip_rect {
 unsigned short x1;
 unsigned short y1;
 unsigned short x2;
 unsigned short y2;
};




struct drm_drawable_info {
 unsigned int num_rects;
 struct drm_clip_rect *rects;
};




struct drm_tex_region {
 unsigned char next;
 unsigned char prev;
 unsigned char in_use;
 unsigned char padding;
 unsigned int age;
};
# 130 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_hw_lock {
 __volatile__ unsigned int lock;
 char padding[60];
};






struct drm_version {
 int version_major;
 int version_minor;
 int version_patchlevel;
 __kernel_size_t name_len;
 char *name;
 __kernel_size_t date_len;
 char *date;
 __kernel_size_t desc_len;
 char *desc;
};






struct drm_unique {
 __kernel_size_t unique_len;
 char *unique;
};

struct drm_list {
 int count;
 struct drm_version *version;
};

struct drm_block {
 int unused;
};






struct drm_control {
 enum {
  DRM_ADD_COMMAND,
  DRM_RM_COMMAND,
  DRM_INST_HANDLER,
  DRM_UNINST_HANDLER
 } func;
 int irq;
};




enum drm_map_type {
 _DRM_FRAME_BUFFER = 0,
 _DRM_REGISTERS = 1,
 _DRM_SHM = 2,
 _DRM_AGP = 3,
 _DRM_SCATTER_GATHER = 4,
 _DRM_CONSISTENT = 5
};




enum drm_map_flags {
 _DRM_RESTRICTED = 0x01,
 _DRM_READ_ONLY = 0x02,
 _DRM_LOCKED = 0x04,
 _DRM_KERNEL = 0x08,
 _DRM_WRITE_COMBINING = 0x10,
 _DRM_CONTAINS_LOCK = 0x20,
 _DRM_REMOVABLE = 0x40,
 _DRM_DRIVER = 0x80
};

struct drm_ctx_priv_map {
 unsigned int ctx_id;
 void *handle;
};







struct drm_map {
 unsigned long offset;
 unsigned long size;
 enum drm_map_type type;
 enum drm_map_flags flags;
 void *handle;

 int mtrr;

};




struct drm_client {
 int idx;
 int auth;
 unsigned long pid;
 unsigned long uid;
 unsigned long magic;
 unsigned long iocs;
};

enum drm_stat_type {
 _DRM_STAT_LOCK,
 _DRM_STAT_OPENS,
 _DRM_STAT_CLOSES,
 _DRM_STAT_IOCTLS,
 _DRM_STAT_LOCKS,
 _DRM_STAT_UNLOCKS,
 _DRM_STAT_VALUE,
 _DRM_STAT_BYTE,
 _DRM_STAT_COUNT,

 _DRM_STAT_IRQ,
 _DRM_STAT_PRIMARY,
 _DRM_STAT_SECONDARY,
 _DRM_STAT_DMA,
 _DRM_STAT_SPECIAL,
 _DRM_STAT_MISSED

};




struct drm_stats {
 unsigned long count;
 struct {
  unsigned long value;
  enum drm_stat_type type;
 } data[15];
};




enum drm_lock_flags {
 _DRM_LOCK_READY = 0x01,
 _DRM_LOCK_QUIESCENT = 0x02,
 _DRM_LOCK_FLUSH = 0x04,
 _DRM_LOCK_FLUSH_ALL = 0x08,



 _DRM_HALT_ALL_QUEUES = 0x10,
 _DRM_HALT_CUR_QUEUES = 0x20
};






struct drm_lock {
 int context;
 enum drm_lock_flags flags;
};
# 310 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
enum drm_dma_flags {

 _DRM_DMA_BLOCK = 0x01,
# 322 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
 _DRM_DMA_WHILE_LOCKED = 0x02,
 _DRM_DMA_PRIORITY = 0x04,


 _DRM_DMA_WAIT = 0x10,
 _DRM_DMA_SMALLER_OK = 0x20,
 _DRM_DMA_LARGER_OK = 0x40
};






struct drm_buf_desc {
 int count;
 int size;
 int low_mark;
 int high_mark;
 enum {
  _DRM_PAGE_ALIGN = 0x01,
  _DRM_AGP_BUFFER = 0x02,
  _DRM_SG_BUFFER = 0x04,
  _DRM_FB_BUFFER = 0x08,
  _DRM_PCI_BUFFER_RO = 0x10
 } flags;
 unsigned long agp_start;



};




struct drm_buf_info {
 int count;
 struct drm_buf_desc *list;
};




struct drm_buf_free {
 int count;
 int *list;
};






struct drm_buf_pub {
 int idx;
 int total;
 int used;
 void *address;
};




struct drm_buf_map {
 int count;



 void *virtual;

 struct drm_buf_pub *list;
};
# 402 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_dma {
 int context;
 int send_count;
 int *send_indices;
 int *send_sizes;
 enum drm_dma_flags flags;
 int request_count;
 int request_size;
 int *request_indices;
 int *request_sizes;
 int granted_count;
};

enum drm_ctx_flags {
 _DRM_CONTEXT_PRESERVED = 0x01,
 _DRM_CONTEXT_2DONLY = 0x02
};






struct drm_ctx {
 drm_context_t handle;
 enum drm_ctx_flags flags;
};




struct drm_ctx_res {
 int count;
 struct drm_ctx *contexts;
};




struct drm_draw {
 drm_drawable_t handle;
};




typedef enum {
 DRM_DRAWABLE_CLIPRECTS
} drm_drawable_info_type_t;

struct drm_update_draw {
 drm_drawable_t handle;
 unsigned int type;
 unsigned int num;
 unsigned long long data;
};




struct drm_auth {
 drm_magic_t magic;
};






struct drm_irq_busid {
 int irq;
 int busnum;
 int devnum;
 int funcnum;
};

enum drm_vblank_seq_type {
 _DRM_VBLANK_ABSOLUTE = 0x0,
 _DRM_VBLANK_RELATIVE = 0x1,

 _DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,
 _DRM_VBLANK_EVENT = 0x4000000,
 _DRM_VBLANK_FLIP = 0x8000000,
 _DRM_VBLANK_NEXTONMISS = 0x10000000,
 _DRM_VBLANK_SECONDARY = 0x20000000,
 _DRM_VBLANK_SIGNAL = 0x40000000
};






struct drm_wait_vblank_request {
 enum drm_vblank_seq_type type;
 unsigned int sequence;
 unsigned long signal;
};

struct drm_wait_vblank_reply {
 enum drm_vblank_seq_type type;
 unsigned int sequence;
 long tval_sec;
 long tval_usec;
};






union drm_wait_vblank {
 struct drm_wait_vblank_request request;
 struct drm_wait_vblank_reply reply;
};
# 526 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_modeset_ctl {
 __u32 crtc;
 __u32 cmd;
};






struct drm_agp_mode {
 unsigned long mode;
};






struct drm_agp_buffer {
 unsigned long size;
 unsigned long handle;
 unsigned long type;
 unsigned long physical;
};






struct drm_agp_binding {
 unsigned long handle;
 unsigned long offset;
};
# 569 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_agp_info {
 int agp_version_major;
 int agp_version_minor;
 unsigned long mode;
 unsigned long aperture_base;
 unsigned long aperture_size;
 unsigned long memory_allowed;
 unsigned long memory_used;


 unsigned short id_vendor;
 unsigned short id_device;
};




struct drm_scatter_gather {
 unsigned long size;
 unsigned long handle;
};




struct drm_set_version {
 int drm_di_major;
 int drm_di_minor;
 int drm_dd_major;
 int drm_dd_minor;
};


struct drm_gem_close {

 __u32 handle;
 __u32 pad;
};


struct drm_gem_flink {

 __u32 handle;


 __u32 name;
};


struct drm_gem_open {

 __u32 name;


 __u32 handle;


 __u64 size;
};
# 656 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_get_cap {
 __u64 capability;
 __u64 value;
};
# 702 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_set_client_cap {
 __u64 capability;
 __u64 value;
};



struct drm_prime_handle {
 __u32 handle;


 __u32 flags;


 __s32 fd;
};

struct drm_syncobj_create {
 __u32 handle;

 __u32 flags;
};

struct drm_syncobj_destroy {
 __u32 handle;
 __u32 pad;
};



struct drm_syncobj_handle {
 __u32 handle;
 __u32 flags;

 __s32 fd;
 __u32 pad;
};

struct drm_syncobj_transfer {
 __u32 src_handle;
 __u32 dst_handle;
 __u64 src_point;
 __u64 dst_point;
 __u32 flags;
 __u32 pad;
};




struct drm_syncobj_wait {
 __u64 handles;

 __s64 timeout_nsec;
 __u32 count_handles;
 __u32 flags;
 __u32 first_signaled;
 __u32 pad;
};

struct drm_syncobj_timeline_wait {
 __u64 handles;

 __u64 points;

 __s64 timeout_nsec;
 __u32 count_handles;
 __u32 flags;
 __u32 first_signaled;
 __u32 pad;
};


struct drm_syncobj_array {
 __u64 handles;
 __u32 count_handles;
 __u32 pad;
};


struct drm_syncobj_timeline_array {
 __u64 handles;
 __u64 points;
 __u32 count_handles;
 __u32 flags;
};



struct drm_crtc_get_sequence {
 __u32 crtc_id;
 __u32 active;
 __u64 sequence;
 __s64 sequence_ns;
};
# 805 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_crtc_queue_sequence {
 __u32 crtc_id;
 __u32 flags;
 __u64 sequence;
 __u64 user_data;
};






# 1 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h" 1
# 30 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
# 1 "/home/nathan/src/linux-next/include/uapi/drm/drm.h" 1
# 31 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h" 2
# 221 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_modeinfo {
 __u32 clock;
 __u16 hdisplay;
 __u16 hsync_start;
 __u16 hsync_end;
 __u16 htotal;
 __u16 hskew;
 __u16 vdisplay;
 __u16 vsync_start;
 __u16 vsync_end;
 __u16 vtotal;
 __u16 vscan;

 __u32 vrefresh;

 __u32 flags;
 __u32 type;
 char name[32];
};

struct drm_mode_card_res {
 __u64 fb_id_ptr;
 __u64 crtc_id_ptr;
 __u64 connector_id_ptr;
 __u64 encoder_id_ptr;
 __u32 count_fbs;
 __u32 count_crtcs;
 __u32 count_connectors;
 __u32 count_encoders;
 __u32 min_width;
 __u32 max_width;
 __u32 min_height;
 __u32 max_height;
};

struct drm_mode_crtc {
 __u64 set_connectors_ptr;
 __u32 count_connectors;

 __u32 crtc_id;
 __u32 fb_id;

 __u32 x;
 __u32 y;

 __u32 gamma_size;
 __u32 mode_valid;
 struct drm_mode_modeinfo mode;
};





struct drm_mode_set_plane {
 __u32 plane_id;
 __u32 crtc_id;
 __u32 fb_id;
 __u32 flags;


 __s32 crtc_x;
 __s32 crtc_y;
 __u32 crtc_w;
 __u32 crtc_h;


 __u32 src_x;
 __u32 src_y;
 __u32 src_h;
 __u32 src_w;
};

struct drm_mode_get_plane {
 __u32 plane_id;

 __u32 crtc_id;
 __u32 fb_id;

 __u32 possible_crtcs;
 __u32 gamma_size;

 __u32 count_format_types;
 __u64 format_type_ptr;
};

struct drm_mode_get_plane_res {
 __u64 plane_id_ptr;
 __u32 count_planes;
};
# 322 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_get_encoder {
 __u32 encoder_id;
 __u32 encoder_type;

 __u32 crtc_id;

 __u32 possible_crtcs;
 __u32 possible_clones;
};



enum drm_mode_subconnector {
 DRM_MODE_SUBCONNECTOR_Automatic = 0,
 DRM_MODE_SUBCONNECTOR_Unknown = 0,
 DRM_MODE_SUBCONNECTOR_DVID = 3,
 DRM_MODE_SUBCONNECTOR_DVIA = 4,
 DRM_MODE_SUBCONNECTOR_Composite = 5,
 DRM_MODE_SUBCONNECTOR_SVIDEO = 6,
 DRM_MODE_SUBCONNECTOR_Component = 8,
 DRM_MODE_SUBCONNECTOR_SCART = 9,
};
# 366 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_get_connector {

 __u64 encoders_ptr;
 __u64 modes_ptr;
 __u64 props_ptr;
 __u64 prop_values_ptr;

 __u32 count_modes;
 __u32 count_props;
 __u32 count_encoders;

 __u32 encoder_id;
 __u32 connector_id;
 __u32 connector_type;
 __u32 connector_type_id;

 __u32 connection;
 __u32 mm_width;
 __u32 mm_height;
 __u32 subpixel;

 __u32 pad;
};
# 419 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_property_enum {
 __u64 value;
 char name[32];
};

struct drm_mode_get_property {
 __u64 values_ptr;
 __u64 enum_blob_ptr;

 __u32 prop_id;
 __u32 flags;
 char name[32];

 __u32 count_values;


 __u32 count_enum_blobs;
};

struct drm_mode_connector_set_property {
 __u64 value;
 __u32 prop_id;
 __u32 connector_id;
};
# 454 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_obj_get_properties {
 __u64 props_ptr;
 __u64 prop_values_ptr;
 __u32 count_props;
 __u32 obj_id;
 __u32 obj_type;
};

struct drm_mode_obj_set_property {
 __u64 value;
 __u32 prop_id;
 __u32 obj_id;
 __u32 obj_type;
};

struct drm_mode_get_blob {
 __u32 blob_id;
 __u32 length;
 __u64 data;
};

struct drm_mode_fb_cmd {
 __u32 fb_id;
 __u32 width;
 __u32 height;
 __u32 pitch;
 __u32 bpp;
 __u32 depth;

 __u32 handle;
};




struct drm_mode_fb_cmd2 {
 __u32 fb_id;
 __u32 width;
 __u32 height;
 __u32 pixel_format;
 __u32 flags;
# 520 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
 __u32 handles[4];
 __u32 pitches[4];
 __u32 offsets[4];
 __u64 modifier[4];
};
# 559 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_fb_dirty_cmd {
 __u32 fb_id;
 __u32 flags;
 __u32 color;
 __u32 num_clips;
 __u64 clips_ptr;
};

struct drm_mode_mode_cmd {
 __u32 connector_id;
 struct drm_mode_modeinfo mode;
};
# 590 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_cursor {
 __u32 flags;
 __u32 crtc_id;
 __s32 x;
 __s32 y;
 __u32 width;
 __u32 height;

 __u32 handle;
};

struct drm_mode_cursor2 {
 __u32 flags;
 __u32 crtc_id;
 __s32 x;
 __s32 y;
 __u32 width;
 __u32 height;

 __u32 handle;
 __s32 hot_x;
 __s32 hot_y;
};

struct drm_mode_crtc_lut {
 __u32 crtc_id;
 __u32 gamma_size;


 __u64 red;
 __u64 green;
 __u64 blue;
};

struct drm_color_ctm {




 __u64 matrix[9];
};

struct drm_color_lut {




 __u16 red;
 __u16 green;
 __u16 blue;
 __u16 reserved;
};
# 652 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct hdr_metadata_infoframe {




 __u8 eotf;



 __u8 metadata_type;
# 670 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
 struct {
  __u16 x, y;
  } display_primaries[3];
# 681 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
 struct {
  __u16 x, y;
  } white_point;





 __u16 max_display_mastering_luminance;






 __u16 min_display_mastering_luminance;





 __u16 max_cll;





 __u16 max_fall;
};






struct hdr_output_metadata {



 __u32 metadata_type;



 union {
  struct hdr_metadata_infoframe hdmi_metadata_type1;
 };
};
# 763 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_crtc_page_flip {
 __u32 crtc_id;
 __u32 fb_id;
 __u32 flags;
 __u32 reserved;
 __u64 user_data;
};
# 791 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_crtc_page_flip_target {
 __u32 crtc_id;
 __u32 fb_id;
 __u32 flags;
 __u32 sequence;
 __u64 user_data;
};


struct drm_mode_create_dumb {
 __u32 height;
 __u32 width;
 __u32 bpp;
 __u32 flags;

 __u32 handle;
 __u32 pitch;
 __u64 size;
};


struct drm_mode_map_dumb {

 __u32 handle;
 __u32 pad;





 __u64 offset;
};

struct drm_mode_destroy_dumb {
 __u32 handle;
};
# 840 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_atomic {
 __u32 flags;
 __u32 count_objs;
 __u64 objs_ptr;
 __u64 count_props_ptr;
 __u64 props_ptr;
 __u64 prop_values_ptr;
 __u64 reserved;
 __u64 user_data;
};

struct drm_format_modifier_blob {


 __u32 version;


 __u32 flags;


 __u32 count_formats;


 __u32 formats_offset;


 __u32 count_modifiers;


 __u32 modifiers_offset;



};

struct drm_format_modifier {
# 893 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
 __u64 formats;
 __u32 offset;
 __u32 pad;


 __u64 modifier;
};
# 909 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_create_blob {

 __u64 data;

 __u32 length;

 __u32 blob_id;
};






struct drm_mode_destroy_blob {
 __u32 blob_id;
};
# 936 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_create_lease {

 __u64 object_ids;

 __u32 object_count;

 __u32 flags;


 __u32 lessee_id;

 __u32 fd;
};
# 957 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_list_lessees {







 __u32 count_lessees;
 __u32 pad;




 __u64 lessees_ptr;
};
# 981 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_get_lease {







 __u32 count_objects;
 __u32 pad;




 __u64 objects_ptr;
};






struct drm_mode_revoke_lease {


 __u32 lessee_id;
};
# 1021 "/home/nathan/src/linux-next/include/uapi/drm/drm_mode.h"
struct drm_mode_rect {
 __s32 x1;
 __s32 y1;
 __s32 x2;
 __s32 y2;
};
# 817 "/home/nathan/src/linux-next/include/uapi/drm/drm.h" 2
# 976 "/home/nathan/src/linux-next/include/uapi/drm/drm.h"
struct drm_event {
 __u32 type;
 __u32 length;
};





struct drm_event_vblank {
 struct drm_event base;
 __u64 user_data;
 __u32 tv_sec;
 __u32 tv_usec;
 __u32 sequence;
 __u32 crtc_id;
};




struct drm_event_crtc_sequence {
 struct drm_event base;
 __u64 user_data;
 __s64 time_ns;
 __u64 sequence;
};
# 36 "/home/nathan/src/linux-next/include/drm/drm_print.h" 2


extern unsigned int __drm_debug;
# 75 "/home/nathan/src/linux-next/include/drm/drm_print.h"
struct drm_printer {

 void (*printfn)(struct drm_printer *p, struct va_format *vaf);
 void (*puts)(struct drm_printer *p, const char *str);
 void *arg;
 const char *prefix;
};

void __drm_printfn_coredump(struct drm_printer *p, struct va_format *vaf);
void __drm_puts_coredump(struct drm_printer *p, const char *str);
void __drm_printfn_seq_file(struct drm_printer *p, struct va_format *vaf);
void __drm_puts_seq_file(struct drm_printer *p, const char *str);
void __drm_printfn_info(struct drm_printer *p, struct va_format *vaf);
void __drm_printfn_debug(struct drm_printer *p, struct va_format *vaf);
void __drm_printfn_err(struct drm_printer *p, struct va_format *vaf);

__attribute__((__format__(printf, 2, 3)))
void drm_printf(struct drm_printer *p, const char *f, ...);
void drm_puts(struct drm_printer *p, const char *str);
void drm_print_regset32(struct drm_printer *p, struct debugfs_regset32 *regset);
void drm_print_bits(struct drm_printer *p, unsigned long value,
      const char * const bits[], unsigned int nbits);

__attribute__((__format__(printf, 2, 0)))






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
drm_vprintf(struct drm_printer *p, const char *fmt, va_list *va)
{
 struct va_format vaf = { .fmt = fmt, .va = va };

 p->printfn(p, &vaf);
}
# 128 "/home/nathan/src/linux-next/include/drm/drm_print.h"
struct drm_print_iterator {
 void *data;
 ssize_t start;
 ssize_t remain;

 ssize_t offset;
};
# 172 "/home/nathan/src/linux-next/include/drm/drm_print.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct drm_printer
drm_coredump_printer(struct drm_print_iterator *iter)
{
 struct drm_printer p = {
  .printfn = __drm_printfn_coredump,
  .puts = __drm_puts_coredump,
  .arg = iter,
 };


 iter->offset = 0;

 return p;
}
# 194 "/home/nathan/src/linux-next/include/drm/drm_print.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct drm_printer drm_seq_file_printer(struct seq_file *f)
{
 struct drm_printer p = {
  .printfn = __drm_printfn_seq_file,
  .puts = __drm_puts_seq_file,
  .arg = f,
 };
 return p;
}
# 211 "/home/nathan/src/linux-next/include/drm/drm_print.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct drm_printer drm_info_printer(struct device *dev)
{
 struct drm_printer p = {
  .printfn = __drm_printfn_info,
  .arg = dev,
 };
 return p;
}
# 227 "/home/nathan/src/linux-next/include/drm/drm_print.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct drm_printer drm_debug_printer(const char *prefix)
{
 struct drm_printer p = {
  .printfn = __drm_printfn_debug,
  .prefix = prefix
 };
 return p;
}
# 243 "/home/nathan/src/linux-next/include/drm/drm_print.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct drm_printer drm_err_printer(const char *prefix)
{
 struct drm_printer p = {
  .printfn = __drm_printfn_err,
  .prefix = prefix
 };
 return p;
}
# 277 "/home/nathan/src/linux-next/include/drm/drm_print.h"
enum drm_debug_category {




 DRM_UT_CORE = 0x01,




 DRM_UT_DRIVER = 0x02,



 DRM_UT_KMS = 0x04,



 DRM_UT_PRIME = 0x08,



 DRM_UT_ATOMIC = 0x10,



 DRM_UT_VBL = 0x20,



 DRM_UT_STATE = 0x40,



 DRM_UT_LEASE = 0x80,



 DRM_UT_DP = 0x100,



 DRM_UT_DRMRES = 0x200,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool drm_debug_enabled(enum drm_debug_category category)
{
 return __builtin_expect(!!(__drm_debug & category), 0);
}







__attribute__((__format__(printf, 3, 4)))
void drm_dev_printk(const struct device *dev, const char *level,
      const char *format, ...);
__attribute__((__format__(printf, 3, 4)))
void drm_dev_dbg(const struct device *dev, enum drm_debug_category category,
   const char *format, ...);
# 459 "/home/nathan/src/linux-next/include/drm/drm_print.h"
__attribute__((__format__(printf, 2, 3)))
void __drm_dbg(enum drm_debug_category category, const char *format, ...);
__attribute__((__format__(printf, 1, 2)))
void __drm_err(const char *format, ...);
# 38 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2

# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h" 1
# 27 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/amd_shared.h" 1
# 26 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/amd_shared.h"
# 1 "/home/nathan/src/linux-next/include/drm/amd_asic_type.h" 1
# 28 "/home/nathan/src/linux-next/include/drm/amd_asic_type.h"
enum amd_asic_type {
 CHIP_TAHITI = 0,
 CHIP_PITCAIRN,
 CHIP_VERDE,
 CHIP_OLAND,
 CHIP_HAINAN,
 CHIP_BONAIRE,
 CHIP_KAVERI,
 CHIP_KABINI,
 CHIP_HAWAII,
 CHIP_MULLINS,
 CHIP_TOPAZ,
 CHIP_TONGA,
 CHIP_FIJI,
 CHIP_CARRIZO,
 CHIP_STONEY,
 CHIP_POLARIS10,
 CHIP_POLARIS11,
 CHIP_POLARIS12,
 CHIP_VEGAM,
 CHIP_VEGA10,
 CHIP_VEGA12,
 CHIP_VEGA20,
 CHIP_RAVEN,
 CHIP_ARCTURUS,
 CHIP_RENOIR,
 CHIP_NAVI10,
 CHIP_NAVI14,
 CHIP_NAVI12,
 CHIP_SIENNA_CICHLID,
 CHIP_LAST,
};

extern const char *amdgpu_asic_name[];
# 27 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/amd_shared.h" 2







enum amd_chip_flags {
 AMD_ASIC_MASK = 0x0000ffffUL,
 AMD_FLAGS_MASK = 0xffff0000UL,
 AMD_IS_MOBILITY = 0x00010000UL,
 AMD_IS_APU = 0x00020000UL,
 AMD_IS_PX = 0x00040000UL,
 AMD_EXP_HW_SUPPORT = 0x00080000UL,
};

enum amd_apu_flags {
 AMD_APU_IS_RAVEN = 0x00000001UL,
 AMD_APU_IS_RAVEN2 = 0x00000002UL,
 AMD_APU_IS_PICASSO = 0x00000004UL,
 AMD_APU_IS_RENOIR = 0x00000008UL,
};

enum amd_ip_block_type {
 AMD_IP_BLOCK_TYPE_COMMON,
 AMD_IP_BLOCK_TYPE_GMC,
 AMD_IP_BLOCK_TYPE_IH,
 AMD_IP_BLOCK_TYPE_SMC,
 AMD_IP_BLOCK_TYPE_PSP,
 AMD_IP_BLOCK_TYPE_DCE,
 AMD_IP_BLOCK_TYPE_GFX,
 AMD_IP_BLOCK_TYPE_SDMA,
 AMD_IP_BLOCK_TYPE_UVD,
 AMD_IP_BLOCK_TYPE_VCE,
 AMD_IP_BLOCK_TYPE_ACP,
 AMD_IP_BLOCK_TYPE_VCN,
 AMD_IP_BLOCK_TYPE_MES,
 AMD_IP_BLOCK_TYPE_JPEG
};

enum amd_clockgating_state {
 AMD_CG_STATE_GATE = 0,
 AMD_CG_STATE_UNGATE,
};


enum amd_powergating_state {
 AMD_PG_STATE_GATE = 0,
 AMD_PG_STATE_UNGATE,
};
# 131 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/amd_shared.h"
enum PP_FEATURE_MASK {
 PP_SCLK_DPM_MASK = 0x1,
 PP_MCLK_DPM_MASK = 0x2,
 PP_PCIE_DPM_MASK = 0x4,
 PP_SCLK_DEEP_SLEEP_MASK = 0x8,
 PP_POWER_CONTAINMENT_MASK = 0x10,
 PP_UVD_HANDSHAKE_MASK = 0x20,
 PP_SMC_VOLTAGE_CONTROL_MASK = 0x40,
 PP_VBI_TIME_SUPPORT_MASK = 0x80,
 PP_ULV_MASK = 0x100,
 PP_ENABLE_GFX_CG_THRU_SMU = 0x200,
 PP_CLOCK_STRETCH_MASK = 0x400,
 PP_OD_FUZZY_FAN_CONTROL_MASK = 0x800,
 PP_SOCCLK_DPM_MASK = 0x1000,
 PP_DCEFCLK_DPM_MASK = 0x2000,
 PP_OVERDRIVE_MASK = 0x4000,
 PP_GFXOFF_MASK = 0x8000,
 PP_ACG_MASK = 0x10000,
 PP_STUTTER_MODE = 0x20000,
 PP_AVFS_MASK = 0x40000,
};

enum DC_FEATURE_MASK {
 DC_FBC_MASK = 0x1,
 DC_MULTI_MON_PP_MCLK_SWITCH_MASK = 0x2,
 DC_DISABLE_FRACTIONAL_PWM_MASK = 0x4,
 DC_PSR_MASK = 0x8,
};

enum DC_DEBUG_MASK {
 DC_DISABLE_PIPE_SPLIT = 0x1,
 DC_DISABLE_STUTTER = 0x2,
 DC_DISABLE_DSC = 0x4,
 DC_DISABLE_CLOCK_GATING = 0x8
};

enum amd_dpm_forced_level;



struct amd_ip_funcs {

 char *name;






 int (*early_init)(void *handle);

 int (*late_init)(void *handle);

 int (*sw_init)(void *handle);

 int (*sw_fini)(void *handle);

 int (*hw_init)(void *handle);

 int (*hw_fini)(void *handle);

 void (*late_fini)(void *handle);

 int (*suspend)(void *handle);

 int (*resume)(void *handle);

 bool (*is_idle)(void *handle);

 int (*wait_for_idle)(void *handle);

 bool (*check_soft_reset)(void *handle);

 int (*pre_soft_reset)(void *handle);

 int (*soft_reset)(void *handle);

 int (*post_soft_reset)(void *handle);

 int (*set_clockgating_state)(void *handle,
         enum amd_clockgating_state state);

 int (*set_powergating_state)(void *handle,
         enum amd_powergating_state state);

 void (*get_clockgating_state)(void *handle, u32 *flags);

 int (*enable_umd_pstate)(void *handle, enum amd_dpm_forced_level *level);
};
# 28 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h" 2

struct cgs_device;




enum cgs_ind_reg {
 CGS_IND_REG__PCIE,
 CGS_IND_REG__SMC,
 CGS_IND_REG__UVD_CTX,
 CGS_IND_REG__DIDT,
 CGS_IND_REG_GC_CAC,
 CGS_IND_REG_SE_CAC,
 CGS_IND_REG__AUDIO_ENDPT
};




enum cgs_ucode_id {
 CGS_UCODE_ID_SMU = 0,
 CGS_UCODE_ID_SMU_SK,
 CGS_UCODE_ID_SDMA0,
 CGS_UCODE_ID_SDMA1,
 CGS_UCODE_ID_CP_CE,
 CGS_UCODE_ID_CP_PFP,
 CGS_UCODE_ID_CP_ME,
 CGS_UCODE_ID_CP_MEC,
 CGS_UCODE_ID_CP_MEC_JT1,
 CGS_UCODE_ID_CP_MEC_JT2,
 CGS_UCODE_ID_GMCON_RENG,
 CGS_UCODE_ID_RLC_G,
 CGS_UCODE_ID_STORAGE,
 CGS_UCODE_ID_MAXIMUM,
};




struct cgs_firmware_info {
 uint16_t version;
 uint16_t fw_version;
 uint16_t feature_version;
 uint32_t image_size;
 uint64_t mc_addr;


 uint32_t ucode_start_address;

 void *kptr;
 bool is_kicker;
};

typedef unsigned long cgs_handle_t;
# 90 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h"
typedef uint32_t (*cgs_read_register_t)(struct cgs_device *cgs_device, unsigned offset);







typedef void (*cgs_write_register_t)(struct cgs_device *cgs_device, unsigned offset,
         uint32_t value);
# 108 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h"
typedef uint32_t (*cgs_read_ind_register_t)(struct cgs_device *cgs_device, enum cgs_ind_reg space,
         unsigned index);







typedef void (*cgs_write_ind_register_t)(struct cgs_device *cgs_device, enum cgs_ind_reg space,
      unsigned index, uint32_t value);
# 136 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../include/cgs_common.h"
typedef int (*cgs_get_firmware_info)(struct cgs_device *cgs_device,
         enum cgs_ucode_id type,
         struct cgs_firmware_info *info);

struct cgs_ops {

 cgs_read_register_t read_register;
 cgs_write_register_t write_register;
 cgs_read_ind_register_t read_ind_register;
 cgs_write_ind_register_t write_ind_register;

 cgs_get_firmware_info get_firmware_info;
};

struct cgs_os_ops;

struct cgs_device
{
 const struct cgs_ops *ops;

};
# 40 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2
# 59 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/switch_to.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/switch_to.h"
struct thread_struct;
struct task_struct;
struct pt_regs;

extern struct task_struct *__switch_to(struct task_struct *,
 struct task_struct *);


extern struct task_struct *_switch(struct thread_struct *prev,
       struct thread_struct *next);

extern void switch_booke_debug_regs(struct debug_reg *new_debug);

extern int emulate_altivec(struct pt_regs *);


void restore_math(struct pt_regs *regs);






void restore_tm_state(struct pt_regs *regs);

extern void flush_all_to_thread(struct task_struct *);
extern void giveup_all(struct task_struct *);


extern void enable_kernel_fp(void);
extern void flush_fp_to_thread(struct task_struct *);
extern void giveup_fpu(struct task_struct *);
extern void save_fpu(struct task_struct *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_kernel_fp(void)
{
 msr_check_and_clear((1UL<<(13)));
}






extern void enable_kernel_altivec(void);
extern void flush_altivec_to_thread(struct task_struct *);
extern void giveup_altivec(struct task_struct *);
extern void save_altivec(struct task_struct *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_kernel_altivec(void)
{
 msr_check_and_clear((1UL<<(25)));
}






extern void enable_kernel_vsx(void);
extern void flush_vsx_to_thread(struct task_struct *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_kernel_vsx(void)
{
 msr_check_and_clear((1UL<<(13))|(1UL<<(25))|(1UL<<(23)));
}
# 86 "/home/nathan/src/linux-next/arch/powerpc/include/asm/switch_to.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __giveup_spe(struct task_struct *t) { }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_task_ebb(struct task_struct *t)
{


    t->thread.ebbrr = 0;
    t->thread.ebbhr = 0;
    t->thread.bescr = 0;
    t->thread.mmcr2 = 0;
    t->thread.mmcr0 = 0;
    t->thread.siar = 0;
    t->thread.sdar = 0;
    t->thread.sier = 0;
    t->thread.used_ebb = 0;

}

extern int set_thread_tidr(struct task_struct *t);
# 60 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/os_types.h" 2
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 1
# 33 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h" 1
# 57 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 {
 long long value;
};







static const struct fixed31_32 dc_fixpt_zero = { 0 };
static const struct fixed31_32 dc_fixpt_epsilon = { 1LL };
static const struct fixed31_32 dc_fixpt_half = { 0x80000000LL };
static const struct fixed31_32 dc_fixpt_one = { 0x100000000LL };

static const struct fixed31_32 dc_fixpt_pi = { 13493037705LL };
static const struct fixed31_32 dc_fixpt_two_pi = { 26986075409LL };
static const struct fixed31_32 dc_fixpt_e = { 11674931555LL };
static const struct fixed31_32 dc_fixpt_ln2 = { 2977044471LL };
static const struct fixed31_32 dc_fixpt_ln2_div_2 = { 1488522236LL };
# 87 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_from_fraction(long long numerator, long long denominator);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_from_int(int arg)
{
 struct fixed31_32 res;

 res.value = (long long) arg << 32;

 return res;
}
# 111 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_neg(struct fixed31_32 arg)
{
 struct fixed31_32 res;

 res.value = -arg.value;

 return res;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_abs(struct fixed31_32 arg)
{
 if (arg.value < 0)
  return dc_fixpt_neg(arg);
 else
  return arg;
}
# 141 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_fixpt_lt(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 return arg1.value < arg2.value;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_fixpt_le(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 return arg1.value <= arg2.value;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_fixpt_eq(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 return arg1.value == arg2.value;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_min(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 if (arg1.value <= arg2.value)
  return arg1;
 else
  return arg2;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_max(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 if (arg1.value <= arg2.value)
  return arg2;
 else
  return arg1;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_clamp(
 struct fixed31_32 arg,
 struct fixed31_32 min_value,
 struct fixed31_32 max_value)
{
 if (dc_fixpt_le(arg, min_value))
  return min_value;
 else if (dc_fixpt_le(max_value, arg))
  return max_value;
 else
  return arg;
}
# 216 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_shl(struct fixed31_32 arg, unsigned char shift)
{
 ({ int __ret_warn_on = !!(!(((arg.value >= 0) && (arg.value <= ((long long)(~0ULL >> 1)) >> shift)) || ((arg.value < 0) && (arg.value >= ~(((long long)(~0ULL >> 1)) >> shift))))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (219), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });


 arg.value = arg.value << shift;

 return arg;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_shr(struct fixed31_32 arg, unsigned char shift)
{
 bool negative = arg.value < 0;

 if (negative)
  arg.value = -arg.value;
 arg.value = arg.value >> shift;
 if (negative)
  arg.value = -arg.value;
 return arg;
}
# 251 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_add(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 struct fixed31_32 res;

 ({ int __ret_warn_on = !!(!(((arg1.value >= 0) && (((long long)(~0ULL >> 1)) - arg1.value >= arg2.value)) || ((arg1.value < 0) && ((-((long long)(~0ULL >> 1)) - 1) - arg1.value <= arg2.value)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (256), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });


 res.value = arg1.value + arg2.value;

 return res;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_add_int(struct fixed31_32 arg1, int arg2)
{
 return dc_fixpt_add(arg1, dc_fixpt_from_int(arg2));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_sub(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 struct fixed31_32 res;

 ({ int __ret_warn_on = !!(!(((arg2.value >= 0) && ((-((long long)(~0ULL >> 1)) - 1) + arg2.value <= arg1.value)) || ((arg2.value < 0) && (((long long)(~0ULL >> 1)) + arg2.value >= arg1.value)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (281), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });


 res.value = arg1.value - arg2.value;

 return res;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_sub_int(struct fixed31_32 arg1, int arg2)
{
 return dc_fixpt_sub(arg1, dc_fixpt_from_int(arg2));
}
# 307 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_mul(struct fixed31_32 arg1, struct fixed31_32 arg2);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_mul_int(struct fixed31_32 arg1, int arg2)
{
 return dc_fixpt_mul(arg1, dc_fixpt_from_int(arg2));
}





struct fixed31_32 dc_fixpt_sqr(struct fixed31_32 arg);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_div_int(struct fixed31_32 arg1, long long arg2)
{
 return dc_fixpt_from_fraction(arg1.value, dc_fixpt_from_int(arg2).value);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_div(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 return dc_fixpt_from_fraction(arg1.value, arg2.value);
}
# 355 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_recip(struct fixed31_32 arg);
# 370 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_sinc(struct fixed31_32 arg);
# 380 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_sin(struct fixed31_32 arg);
# 392 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_cos(struct fixed31_32 arg);
# 406 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_exp(struct fixed31_32 arg);
# 418 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
struct fixed31_32 dc_fixpt_log(struct fixed31_32 arg);
# 432 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_pow(struct fixed31_32 arg1, struct fixed31_32 arg2)
{
 return dc_fixpt_exp(
  dc_fixpt_mul(
   dc_fixpt_log(arg1),
   arg2));
}
# 449 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dc_fixpt_floor(struct fixed31_32 arg)
{
 unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;

 if (arg.value >= 0)
  return (int)(arg_value >> 32);
 else
  return -(int)(arg_value >> 32);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dc_fixpt_round(struct fixed31_32 arg)
{
 unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;

 const long long summand = dc_fixpt_half.value;

 ({ int __ret_warn_on = !!(!(((long long)(~0ULL >> 1)) - (long long)arg_value >= summand)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (469), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

 arg_value += summand;

 if (arg.value >= 0)
  return (int)(arg_value >> 32);
 else
  return -(int)(arg_value >> 32);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dc_fixpt_ceil(struct fixed31_32 arg)
{
 unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;

 const long long summand = dc_fixpt_one.value -
  dc_fixpt_epsilon.value;

 ({ int __ret_warn_on = !!(!(((long long)(~0ULL >> 1)) - (long long)arg_value >= summand)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (490), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

 arg_value += summand;

 if (arg.value >= 0)
  return (int)(arg_value >> 32);
 else
  return -(int)(arg_value >> 32);
}







unsigned int dc_fixpt_u4d19(struct fixed31_32 arg);

unsigned int dc_fixpt_u3d19(struct fixed31_32 arg);

unsigned int dc_fixpt_u2d19(struct fixed31_32 arg);

unsigned int dc_fixpt_u0d19(struct fixed31_32 arg);

unsigned int dc_fixpt_clamp_u0d14(struct fixed31_32 arg);

unsigned int dc_fixpt_clamp_u0d10(struct fixed31_32 arg);

int dc_fixpt_s4d19(struct fixed31_32 arg);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fixed31_32 dc_fixpt_truncate(struct fixed31_32 arg, unsigned int frac_bits)
{
 bool negative = arg.value < 0;

 if (frac_bits >= 32) {
  ({ int __ret_warn_on = !!(!(frac_bits == 32)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/include/fixed31_32.h"), "i" (525), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
  return arg;
 }

 if (negative)
  arg.value = -arg.value;
 arg.value &= (~0LL) << (32 - frac_bits);
 if (negative)
  arg.value = -arg.value;
 return arg;
}
# 34 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/irq_types.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/irq_types.h"
struct dc_context;

typedef void (*interrupt_handler)(void *);

typedef void *irq_handler_idx;




enum dc_irq_source {

 DC_IRQ_SOURCE_INVALID = 0,

 DC_IRQ_SOURCE_HPD1,
 DC_IRQ_SOURCE_HPD2,
 DC_IRQ_SOURCE_HPD3,
 DC_IRQ_SOURCE_HPD4,
 DC_IRQ_SOURCE_HPD5,
 DC_IRQ_SOURCE_HPD6,

 DC_IRQ_SOURCE_HPD1RX,
 DC_IRQ_SOURCE_HPD2RX,
 DC_IRQ_SOURCE_HPD3RX,
 DC_IRQ_SOURCE_HPD4RX,
 DC_IRQ_SOURCE_HPD5RX,
 DC_IRQ_SOURCE_HPD6RX,

 DC_IRQ_SOURCE_I2C_DDC1,
 DC_IRQ_SOURCE_I2C_DDC2,
 DC_IRQ_SOURCE_I2C_DDC3,
 DC_IRQ_SOURCE_I2C_DDC4,
 DC_IRQ_SOURCE_I2C_DDC5,
 DC_IRQ_SOURCE_I2C_DDC6,

 DC_IRQ_SOURCE_DPSINK1,
 DC_IRQ_SOURCE_DPSINK2,
 DC_IRQ_SOURCE_DPSINK3,
 DC_IRQ_SOURCE_DPSINK4,
 DC_IRQ_SOURCE_DPSINK5,
 DC_IRQ_SOURCE_DPSINK6,

 DC_IRQ_SOURCE_TIMER,

 DC_IRQ_SOURCE_PFLIP_FIRST,
 DC_IRQ_SOURCE_PFLIP1 = DC_IRQ_SOURCE_PFLIP_FIRST,
 DC_IRQ_SOURCE_PFLIP2,
 DC_IRQ_SOURCE_PFLIP3,
 DC_IRQ_SOURCE_PFLIP4,
 DC_IRQ_SOURCE_PFLIP5,
 DC_IRQ_SOURCE_PFLIP6,
 DC_IRQ_SOURCE_PFLIP_UNDERLAY0,
 DC_IRQ_SOURCE_PFLIP_LAST = DC_IRQ_SOURCE_PFLIP_UNDERLAY0,

 DC_IRQ_SOURCE_GPIOPAD0,
 DC_IRQ_SOURCE_GPIOPAD1,
 DC_IRQ_SOURCE_GPIOPAD2,
 DC_IRQ_SOURCE_GPIOPAD3,
 DC_IRQ_SOURCE_GPIOPAD4,
 DC_IRQ_SOURCE_GPIOPAD5,
 DC_IRQ_SOURCE_GPIOPAD6,
 DC_IRQ_SOURCE_GPIOPAD7,
 DC_IRQ_SOURCE_GPIOPAD8,
 DC_IRQ_SOURCE_GPIOPAD9,
 DC_IRQ_SOURCE_GPIOPAD10,
 DC_IRQ_SOURCE_GPIOPAD11,
 DC_IRQ_SOURCE_GPIOPAD12,
 DC_IRQ_SOURCE_GPIOPAD13,
 DC_IRQ_SOURCE_GPIOPAD14,
 DC_IRQ_SOURCE_GPIOPAD15,
 DC_IRQ_SOURCE_GPIOPAD16,
 DC_IRQ_SOURCE_GPIOPAD17,
 DC_IRQ_SOURCE_GPIOPAD18,
 DC_IRQ_SOURCE_GPIOPAD19,
 DC_IRQ_SOURCE_GPIOPAD20,
 DC_IRQ_SOURCE_GPIOPAD21,
 DC_IRQ_SOURCE_GPIOPAD22,
 DC_IRQ_SOURCE_GPIOPAD23,
 DC_IRQ_SOURCE_GPIOPAD24,
 DC_IRQ_SOURCE_GPIOPAD25,
 DC_IRQ_SOURCE_GPIOPAD26,
 DC_IRQ_SOURCE_GPIOPAD27,
 DC_IRQ_SOURCE_GPIOPAD28,
 DC_IRQ_SOURCE_GPIOPAD29,
 DC_IRQ_SOURCE_GPIOPAD30,

 DC_IRQ_SOURCE_DC1UNDERFLOW,
 DC_IRQ_SOURCE_DC2UNDERFLOW,
 DC_IRQ_SOURCE_DC3UNDERFLOW,
 DC_IRQ_SOURCE_DC4UNDERFLOW,
 DC_IRQ_SOURCE_DC5UNDERFLOW,
 DC_IRQ_SOURCE_DC6UNDERFLOW,

 DC_IRQ_SOURCE_DMCU_SCP,
 DC_IRQ_SOURCE_VBIOS_SW,

 DC_IRQ_SOURCE_VUPDATE1,
 DC_IRQ_SOURCE_VUPDATE2,
 DC_IRQ_SOURCE_VUPDATE3,
 DC_IRQ_SOURCE_VUPDATE4,
 DC_IRQ_SOURCE_VUPDATE5,
 DC_IRQ_SOURCE_VUPDATE6,

 DC_IRQ_SOURCE_VBLANK1,
 DC_IRQ_SOURCE_VBLANK2,
 DC_IRQ_SOURCE_VBLANK3,
 DC_IRQ_SOURCE_VBLANK4,
 DC_IRQ_SOURCE_VBLANK5,
 DC_IRQ_SOURCE_VBLANK6,

 DC_IRQ_SOURCE_DC1_VLINE0,
 DC_IRQ_SOURCE_DC2_VLINE0,
 DC_IRQ_SOURCE_DC3_VLINE0,
 DC_IRQ_SOURCE_DC4_VLINE0,
 DC_IRQ_SOURCE_DC5_VLINE0,
 DC_IRQ_SOURCE_DC6_VLINE0,

 DC_IRQ_SOURCE_DC1_VLINE1,
 DC_IRQ_SOURCE_DC2_VLINE1,
 DC_IRQ_SOURCE_DC3_VLINE1,
 DC_IRQ_SOURCE_DC4_VLINE1,
 DC_IRQ_SOURCE_DC5_VLINE1,
 DC_IRQ_SOURCE_DC6_VLINE1,


 DAL_IRQ_SOURCES_NUMBER
};

enum irq_type
{
 IRQ_TYPE_PFLIP = DC_IRQ_SOURCE_PFLIP1,
 IRQ_TYPE_VUPDATE = DC_IRQ_SOURCE_VUPDATE1,
 IRQ_TYPE_VBLANK = DC_IRQ_SOURCE_VBLANK1,
};
# 173 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/irq_types.h"
enum dc_interrupt_context {
 INTERRUPT_LOW_IRQ_CONTEXT = 0,
 INTERRUPT_HIGH_IRQ_CONTEXT,
 INTERRUPT_CONTEXT_NUMBER
};

enum dc_interrupt_porlarity {
 INTERRUPT_POLARITY_DEFAULT = 0,
 INTERRUPT_POLARITY_LOW = INTERRUPT_POLARITY_DEFAULT,
 INTERRUPT_POLARITY_HIGH,
 INTERRUPT_POLARITY_BOTH
};






struct dc_timer_interrupt_params {
 uint32_t micro_sec_interval;
 enum dc_interrupt_context int_context;
};

struct dc_interrupt_params {



 enum dc_interrupt_porlarity requested_polarity;




 enum dc_interrupt_porlarity current_polarity;
 enum dc_irq_source irq_source;
 enum dc_interrupt_context int_context;
};
# 35 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_dp_types.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_dp_types.h"
enum dc_lane_count {
 LANE_COUNT_UNKNOWN = 0,
 LANE_COUNT_ONE = 1,
 LANE_COUNT_TWO = 2,
 LANE_COUNT_FOUR = 4,
 LANE_COUNT_EIGHT = 8,
 LANE_COUNT_DP_MAX = LANE_COUNT_FOUR
};
# 47 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_dp_types.h"
enum dc_link_rate {
 LINK_RATE_UNKNOWN = 0,
 LINK_RATE_LOW = 0x06,
 LINK_RATE_RATE_2 = 0x08,
 LINK_RATE_RATE_3 = 0x09,
 LINK_RATE_HIGH = 0x0A,
 LINK_RATE_RBR2 = 0x0C,
 LINK_RATE_RATE_6 = 0x10,
 LINK_RATE_HIGH2 = 0x14,
 LINK_RATE_HIGH3 = 0x1E
};

enum dc_link_spread {
 LINK_SPREAD_DISABLED = 0x00,

 LINK_SPREAD_05_DOWNSPREAD_30KHZ = 0x10,

 LINK_SPREAD_05_DOWNSPREAD_33KHZ = 0x11
};

enum dc_voltage_swing {
 VOLTAGE_SWING_LEVEL0 = 0,
 VOLTAGE_SWING_LEVEL1,
 VOLTAGE_SWING_LEVEL2,
 VOLTAGE_SWING_LEVEL3,
 VOLTAGE_SWING_MAX_LEVEL = VOLTAGE_SWING_LEVEL3
};

enum dc_pre_emphasis {
 PRE_EMPHASIS_DISABLED = 0,
 PRE_EMPHASIS_LEVEL1,
 PRE_EMPHASIS_LEVEL2,
 PRE_EMPHASIS_LEVEL3,
 PRE_EMPHASIS_MAX_LEVEL = PRE_EMPHASIS_LEVEL3
};



enum dc_post_cursor2 {
 POST_CURSOR2_DISABLED = 0,
 POST_CURSOR2_LEVEL1,
 POST_CURSOR2_LEVEL2,
 POST_CURSOR2_LEVEL3,
 POST_CURSOR2_MAX_LEVEL = POST_CURSOR2_LEVEL3,
};

enum dc_dp_training_pattern {
 DP_TRAINING_PATTERN_SEQUENCE_1 = 0,
 DP_TRAINING_PATTERN_SEQUENCE_2,
 DP_TRAINING_PATTERN_SEQUENCE_3,
 DP_TRAINING_PATTERN_SEQUENCE_4,
};

struct dc_link_settings {
 enum dc_lane_count lane_count;
 enum dc_link_rate link_rate;
 enum dc_link_spread link_spread;
 bool use_link_rate_set;
 uint8_t link_rate_set;
};

struct dc_lane_settings {
 enum dc_voltage_swing VOLTAGE_SWING;
 enum dc_pre_emphasis PRE_EMPHASIS;
 enum dc_post_cursor2 POST_CURSOR2;
};

struct dc_link_training_settings {
 struct dc_link_settings link;
 struct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX];
};

struct dc_link_training_overrides {
 enum dc_voltage_swing *voltage_swing;
 enum dc_pre_emphasis *pre_emphasis;
 enum dc_post_cursor2 *post_cursor2;

 uint16_t *cr_pattern_time;
 uint16_t *eq_pattern_time;
 enum dc_dp_training_pattern *pattern_for_eq;

 enum dc_link_spread *downspread;
 bool *alternate_scrambler_reset;
 bool *enhanced_framing;
 bool *mst_enable;
 bool *fec_enable;
};

union dpcd_rev {
 struct {
  uint8_t MINOR:4;
  uint8_t MAJOR:4;
 } bits;
 uint8_t raw;
};

union max_lane_count {
 struct {
  uint8_t MAX_LANE_COUNT:5;
  uint8_t POST_LT_ADJ_REQ_SUPPORTED:1;
  uint8_t TPS3_SUPPORTED:1;
  uint8_t ENHANCED_FRAME_CAP:1;
 } bits;
 uint8_t raw;
};

union max_down_spread {
 struct {
  uint8_t MAX_DOWN_SPREAD:1;
  uint8_t RESERVED:5;
  uint8_t NO_AUX_HANDSHAKE_LINK_TRAINING:1;
  uint8_t TPS4_SUPPORTED:1;
 } bits;
 uint8_t raw;
};

union mstm_cap {
 struct {
  uint8_t MST_CAP:1;
  uint8_t RESERVED:7;
 } bits;
 uint8_t raw;
};

union lane_count_set {
 struct {
  uint8_t LANE_COUNT_SET:5;
  uint8_t POST_LT_ADJ_REQ_GRANTED:1;
  uint8_t RESERVED:1;
  uint8_t ENHANCED_FRAMING:1;
 } bits;
 uint8_t raw;
};

union lane_status {
 struct {
  uint8_t CR_DONE_0:1;
  uint8_t CHANNEL_EQ_DONE_0:1;
  uint8_t SYMBOL_LOCKED_0:1;
  uint8_t RESERVED0:1;
  uint8_t CR_DONE_1:1;
  uint8_t CHANNEL_EQ_DONE_1:1;
  uint8_t SYMBOL_LOCKED_1:1;
  uint8_t RESERVED_1:1;
 } bits;
 uint8_t raw;
};

union device_service_irq {
 struct {
  uint8_t REMOTE_CONTROL_CMD_PENDING:1;
  uint8_t AUTOMATED_TEST:1;
  uint8_t CP_IRQ:1;
  uint8_t MCCS_IRQ:1;
  uint8_t DOWN_REP_MSG_RDY:1;
  uint8_t UP_REQ_MSG_RDY:1;
  uint8_t SINK_SPECIFIC:1;
  uint8_t reserved:1;
 } bits;
 uint8_t raw;
};

union sink_count {
 struct {
  uint8_t SINK_COUNT:6;
  uint8_t CPREADY:1;
  uint8_t RESERVED:1;
 } bits;
 uint8_t raw;
};

union lane_align_status_updated {
 struct {
  uint8_t INTERLANE_ALIGN_DONE:1;
  uint8_t POST_LT_ADJ_REQ_IN_PROGRESS:1;
  uint8_t RESERVED:4;
  uint8_t DOWNSTREAM_PORT_STATUS_CHANGED:1;
  uint8_t LINK_STATUS_UPDATED:1;
 } bits;
 uint8_t raw;
};

union lane_adjust {
 struct {
  uint8_t VOLTAGE_SWING_LANE:2;
  uint8_t PRE_EMPHASIS_LANE:2;
  uint8_t RESERVED:4;
 } bits;
 uint8_t raw;
};

union dpcd_training_pattern {
 struct {
  uint8_t TRAINING_PATTERN_SET:4;
  uint8_t RECOVERED_CLOCK_OUT_EN:1;
  uint8_t SCRAMBLING_DISABLE:1;
  uint8_t SYMBOL_ERROR_COUNT_SEL:2;
 } v1_4;
 struct {
  uint8_t TRAINING_PATTERN_SET:2;
  uint8_t LINK_QUAL_PATTERN_SET:2;
  uint8_t RESERVED:4;
 } v1_3;
 uint8_t raw;
};




union dpcd_training_lane {
 struct {
  uint8_t VOLTAGE_SWING_SET:2;
  uint8_t MAX_SWING_REACHED:1;
  uint8_t PRE_EMPHASIS_SET:2;
  uint8_t MAX_PRE_EMPHASIS_REACHED:1;
  uint8_t RESERVED:2;
 } bits;
 uint8_t raw;
};


union dwnstream_port_caps_byte0 {
 struct {
  uint8_t DWN_STRM_PORTX_TYPE:3;
  uint8_t DWN_STRM_PORTX_HPD:1;
  uint8_t RESERVERD:4;
 } bits;
 uint8_t raw;
};


enum dpcd_downstream_port_detailed_type {
 DOWN_STREAM_DETAILED_DP = 0,
 DOWN_STREAM_DETAILED_VGA,
 DOWN_STREAM_DETAILED_DVI,
 DOWN_STREAM_DETAILED_HDMI,
 DOWN_STREAM_DETAILED_NONDDC,
 DOWN_STREAM_DETAILED_DP_PLUS_PLUS
};

union dwnstream_port_caps_byte2 {
 struct {
  uint8_t MAX_BITS_PER_COLOR_COMPONENT:2;
  uint8_t RESERVED:6;
 } bits;
 uint8_t raw;
};

union dp_downstream_port_present {
 uint8_t byte;
 struct {
  uint8_t PORT_PRESENT:1;
  uint8_t PORT_TYPE:2;
  uint8_t FMT_CONVERSION:1;
  uint8_t DETAILED_CAPS:1;
  uint8_t RESERVED:3;
 } fields;
};

union dwnstream_port_caps_byte3_dvi {
 struct {
  uint8_t RESERVED1:1;
  uint8_t DUAL_LINK:1;
  uint8_t HIGH_COLOR_DEPTH:1;
  uint8_t RESERVED2:5;
 } bits;
 uint8_t raw;
};

union dwnstream_port_caps_byte3_hdmi {
 struct {
  uint8_t FRAME_SEQ_TO_FRAME_PACK:1;
  uint8_t YCrCr422_PASS_THROUGH:1;
  uint8_t YCrCr420_PASS_THROUGH:1;
  uint8_t YCrCr422_CONVERSION:1;
  uint8_t YCrCr420_CONVERSION:1;
  uint8_t RESERVED:3;
 } bits;
 uint8_t raw;
};



union dwnstream_portxcaps {
 struct {
  union dwnstream_port_caps_byte0 byte0;
  unsigned char max_TMDS_clock;
  union dwnstream_port_caps_byte2 byte2;

  union {
   union dwnstream_port_caps_byte3_dvi byteDVI;
   union dwnstream_port_caps_byte3_hdmi byteHDMI;
  } byte3;
 } bytes;

 unsigned char raw[4];
};

union downstream_port {
 struct {
  unsigned char present:1;
  unsigned char type:2;
  unsigned char format_conv:1;
  unsigned char detailed_caps:1;
  unsigned char reserved:3;
 } bits;
 unsigned char raw;
};


union sink_status {
 struct {
  uint8_t RX_PORT0_STATUS:1;
  uint8_t RX_PORT1_STATUS:1;
  uint8_t RESERVED:6;
 } bits;
 uint8_t raw;
};



union hpd_irq_data {
 struct {
  union sink_count sink_cnt;
  union device_service_irq device_service_irq;
  union lane_status lane01_status;
  union lane_status lane23_status;
  union lane_align_status_updated lane_status_updated;
  union sink_status sink_status;
 } bytes;
 uint8_t raw[6];
};

union down_stream_port_count {
 struct {
  uint8_t DOWN_STR_PORT_COUNT:4;
  uint8_t RESERVED:2;




  uint8_t IGNORE_MSA_TIMING_PARAM:1;




  uint8_t OUI_SUPPORT:1;
 } bits;
 uint8_t raw;
};

union down_spread_ctrl {
 struct {
  uint8_t RESERVED1:4;




  uint8_t SPREAD_AMP:1;
  uint8_t RESERVED2:2;



  uint8_t IGNORE_MSA_TIMING_PARAM:1;
 } bits;
 uint8_t raw;
};

union dpcd_edp_config {
 struct {
  uint8_t PANEL_MODE_EDP:1;
  uint8_t FRAMING_CHANGE_ENABLE:1;
  uint8_t RESERVED:5;
  uint8_t PANEL_SELF_TEST_ENABLE:1;
 } bits;
 uint8_t raw;
};

struct dp_device_vendor_id {
 uint8_t ieee_oui[3];
 uint8_t ieee_device_id[6];
};

struct dp_sink_hw_fw_revision {
 uint8_t ieee_hw_rev;
 uint8_t ieee_fw_rev[2];
};

struct dpcd_vendor_signature {
 bool is_valid;

 union dpcd_ieee_vendor_signature {
  struct {
   uint8_t ieee_oui[3];
   uint8_t ieee_device_id[6];
   uint8_t ieee_hw_rev;
   uint8_t ieee_fw_rev[2];
  };
  uint8_t raw[12];
 } data;
};

struct dpcd_amd_signature {
 uint8_t AMD_IEEE_TxSignature_byte1;
 uint8_t AMD_IEEE_TxSignature_byte2;
 uint8_t AMD_IEEE_TxSignature_byte3;
 uint8_t device_id_byte1;
 uint8_t device_id_byte2;
 uint8_t zero[4];
 uint8_t dce_version;
 uint8_t dal_version_byte1;
 uint8_t dal_version_byte2;
};

struct dpcd_source_backlight_set {
 struct {
  uint8_t byte0;
  uint8_t byte1;
  uint8_t byte2;
  uint8_t byte3;
 } backlight_level_millinits;

 struct {
  uint8_t byte0;
  uint8_t byte1;
 } backlight_transition_time_ms;
};

union dpcd_source_backlight_get {
 struct {
  uint32_t backlight_millinits_peak;
  uint32_t backlight_millinits_avg;
 } bytes;
 uint8_t raw[8];
};


union edp_configuration_cap {
 struct {
  uint8_t ALT_SCRAMBLER_RESET:1;
  uint8_t FRAMING_CHANGE:1;
  uint8_t RESERVED:1;
  uint8_t DPCD_DISPLAY_CONTROL_CAPABLE:1;
  uint8_t RESERVED2:4;
 } bits;
 uint8_t raw;
};

union dprx_feature {
 struct {
  uint8_t GTC_CAP:1;
  uint8_t SST_SPLIT_SDP_CAP:1;
  uint8_t AV_SYNC_CAP:1;
  uint8_t VSC_SDP_COLORIMETRY_SUPPORTED:1;
  uint8_t VSC_EXT_VESA_SDP_SUPPORTED:1;
  uint8_t VSC_EXT_VESA_SDP_CHAINING_SUPPORTED:1;
  uint8_t VSC_EXT_CEA_SDP_SUPPORTED:1;
  uint8_t VSC_EXT_CEA_SDP_CHAINING_SUPPORTED:1;
 } bits;
 uint8_t raw;
};

union training_aux_rd_interval {
 struct {
  uint8_t TRAINIG_AUX_RD_INTERVAL:7;
  uint8_t EXT_RECEIVER_CAP_FIELD_PRESENT:1;
 } bits;
 uint8_t raw;
};


union test_request {
 struct {
 uint8_t LINK_TRAINING :1;
 uint8_t LINK_TEST_PATTRN :1;
 uint8_t EDID_READ :1;
 uint8_t PHY_TEST_PATTERN :1;
 uint8_t RESERVED :1;
 uint8_t AUDIO_TEST_PATTERN :1;
 uint8_t TEST_AUDIO_DISABLED_VIDEO :1;
 } bits;
 uint8_t raw;
};

union test_response {
 struct {
  uint8_t ACK :1;
  uint8_t NO_ACK :1;
  uint8_t EDID_CHECKSUM_WRITE:1;
  uint8_t RESERVED :5;
 } bits;
 uint8_t raw;
};

union phy_test_pattern {
 struct {



  uint8_t PATTERN :3;

  uint8_t RESERVED :5;
 } bits;
 uint8_t raw;
};


union compliance_test_state {
 struct {
  unsigned char STEREO_3D_RUNNING : 1;
  unsigned char RESERVED : 7;
 } bits;
 unsigned char raw;
};

union link_test_pattern {
 struct {

  unsigned char PATTERN :2;
  unsigned char RESERVED:6;
 } bits;
 unsigned char raw;
};

union test_misc {
 struct dpcd_test_misc_bits {
  unsigned char SYNC_CLOCK :1;

  unsigned char CLR_FORMAT :2;

  unsigned char DYN_RANGE :1;
  unsigned char YCBCR_COEFS :1;

  unsigned char BPC :3;
 } bits;
 unsigned char raw;
};

union audio_test_mode {
 struct {
  unsigned char sampling_rate :4;
  unsigned char channel_count :4;
 } bits;
 unsigned char raw;
};

union audio_test_pattern_period {
 struct {
  unsigned char pattern_period :4;
  unsigned char reserved :4;
 } bits;
 unsigned char raw;
};

struct audio_test_pattern_type {
 unsigned char value;
};

struct dp_audio_test_data_flags {
 uint8_t test_requested :1;
 uint8_t disable_video :1;
};

struct dp_audio_test_data {

 struct dp_audio_test_data_flags flags;
 uint8_t sampling_rate;
 uint8_t channel_count;
 uint8_t pattern_type;
 uint8_t pattern_period[8];
};


union dpcd_fec_capability {
 struct {
  uint8_t FEC_CAPABLE:1;
  uint8_t UNCORRECTED_BLOCK_ERROR_COUNT_CAPABLE:1;
  uint8_t CORRECTED_BLOCK_ERROR_COUNT_CAPABLE:1;
  uint8_t BIT_ERROR_COUNT_CAPABLE:1;
  uint8_t RESERVED:4;
 } bits;
 uint8_t raw;
};


struct dpcd_dsc_support {
 uint8_t DSC_SUPPORT :1;
 uint8_t DSC_PASSTHROUGH_SUPPORT :1;
 uint8_t RESERVED :6;
};

struct dpcd_dsc_algorithm_revision {
 uint8_t DSC_VERSION_MAJOR :4;
 uint8_t DSC_VERSION_MINOR :4;
};

struct dpcd_dsc_rc_buffer_block_size {
 uint8_t RC_BLOCK_BUFFER_SIZE :2;
 uint8_t RESERVED :6;
};

struct dpcd_dsc_slice_capability1 {
 uint8_t ONE_SLICE_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t TWO_SLICES_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t RESERVED :1;
 uint8_t FOUR_SLICES_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t SIX_SLICES_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t EIGHT_SLICES_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t TEN_SLICES_PER_DP_DSC_SINK_DEVICE :1;
 uint8_t TWELVE_SLICES_PER_DP_DSC_SINK_DEVICE :1;
};

struct dpcd_dsc_line_buffer_bit_depth {
 uint8_t LINE_BUFFER_BIT_DEPTH :4;
 uint8_t RESERVED :4;
};

struct dpcd_dsc_block_prediction_support {
 uint8_t BLOCK_PREDICTION_SUPPORT:1;
 uint8_t RESERVED :7;
};

struct dpcd_maximum_bits_per_pixel_supported_by_the_decompressor {
 uint8_t MAXIMUM_BITS_PER_PIXEL_SUPPORTED_BY_THE_DECOMPRESSOR_LOW :7;
 uint8_t MAXIMUM_BITS_PER_PIXEL_SUPPORTED_BY_THE_DECOMPRESSOR_HIGH :7;
 uint8_t RESERVED :2;
};

struct dpcd_dsc_decoder_color_format_capabilities {
 uint8_t RGB_SUPPORT :1;
 uint8_t Y_CB_CR_444_SUPPORT :1;
 uint8_t Y_CB_CR_SIMPLE_422_SUPPORT :1;
 uint8_t Y_CB_CR_NATIVE_422_SUPPORT :1;
 uint8_t Y_CB_CR_NATIVE_420_SUPPORT :1;
 uint8_t RESERVED :3;
};

struct dpcd_dsc_decoder_color_depth_capabilities {
 uint8_t RESERVED0 :1;
 uint8_t EIGHT_BITS_PER_COLOR_SUPPORT :1;
 uint8_t TEN_BITS_PER_COLOR_SUPPORT :1;
 uint8_t TWELVE_BITS_PER_COLOR_SUPPORT :1;
 uint8_t RESERVED1 :4;
};

struct dpcd_peak_dsc_throughput_dsc_sink {
 uint8_t THROUGHPUT_MODE_0:4;
 uint8_t THROUGHPUT_MODE_1:4;
};

struct dpcd_dsc_slice_capabilities_2 {
 uint8_t SIXTEEN_SLICES_PER_DSC_SINK_DEVICE :1;
 uint8_t TWENTY_SLICES_PER_DSC_SINK_DEVICE :1;
 uint8_t TWENTYFOUR_SLICES_PER_DSC_SINK_DEVICE :1;
 uint8_t RESERVED :5;
};

struct dpcd_bits_per_pixel_increment{
 uint8_t INCREMENT_OF_BITS_PER_PIXEL_SUPPORTED :3;
 uint8_t RESERVED :5;
};
union dpcd_dsc_basic_capabilities {
 struct {
  struct dpcd_dsc_support dsc_support;
  struct dpcd_dsc_algorithm_revision dsc_algorithm_revision;
  struct dpcd_dsc_rc_buffer_block_size dsc_rc_buffer_block_size;
  uint8_t dsc_rc_buffer_size;
  struct dpcd_dsc_slice_capability1 dsc_slice_capabilities_1;
  struct dpcd_dsc_line_buffer_bit_depth dsc_line_buffer_bit_depth;
  struct dpcd_dsc_block_prediction_support dsc_block_prediction_support;
  struct dpcd_maximum_bits_per_pixel_supported_by_the_decompressor maximum_bits_per_pixel_supported_by_the_decompressor;
  struct dpcd_dsc_decoder_color_format_capabilities dsc_decoder_color_format_capabilities;
  struct dpcd_dsc_decoder_color_depth_capabilities dsc_decoder_color_depth_capabilities;
  struct dpcd_peak_dsc_throughput_dsc_sink peak_dsc_throughput_dsc_sink;
  uint8_t dsc_maximum_slice_width;
  struct dpcd_dsc_slice_capabilities_2 dsc_slice_capabilities_2;
  uint8_t reserved;
  struct dpcd_bits_per_pixel_increment bits_per_pixel_increment;
 } fields;
 uint8_t raw[16];
};

union dpcd_dsc_ext_capabilities {
 struct {
  uint8_t BRANCH_OVERALL_THROUGHPUT_0;
  uint8_t BRANCH_OVERALL_THROUGHPUT_1;
  uint8_t BRANCH_MAX_LINE_WIDTH;
 } fields;
 uint8_t raw[3];
};

struct dpcd_dsc_capabilities {
 union dpcd_dsc_basic_capabilities dsc_basic_caps;
 union dpcd_dsc_ext_capabilities dsc_ext_caps;
};


struct psr_caps {
 unsigned char psr_version;
 unsigned int psr_rfb_setup_time;
 bool psr_exit_link_training_required;
};
# 36 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/signal_types.h" 1
# 34 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/signal_types.h"
enum signal_type {
 SIGNAL_TYPE_NONE = 0L,
 SIGNAL_TYPE_DVI_SINGLE_LINK = (1 << 0),
 SIGNAL_TYPE_DVI_DUAL_LINK = (1 << 1),
 SIGNAL_TYPE_HDMI_TYPE_A = (1 << 2),
 SIGNAL_TYPE_LVDS = (1 << 3),
 SIGNAL_TYPE_RGB = (1 << 4),
 SIGNAL_TYPE_DISPLAY_PORT = (1 << 5),
 SIGNAL_TYPE_DISPLAY_PORT_MST = (1 << 6),
 SIGNAL_TYPE_EDP = (1 << 7),
 SIGNAL_TYPE_VIRTUAL = (1 << 9),
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_hdmi_tmds_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_HDMI_TYPE_A);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_hdmi_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_HDMI_TYPE_A);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_dp_sst_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_DISPLAY_PORT ||
  signal == SIGNAL_TYPE_EDP);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_dp_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_DISPLAY_PORT ||
  signal == SIGNAL_TYPE_EDP ||
  signal == SIGNAL_TYPE_DISPLAY_PORT_MST);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_embedded_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_EDP || signal == SIGNAL_TYPE_LVDS);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_lvds_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_LVDS);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_dvi_signal(enum signal_type signal)
{
 switch (signal) {
 case SIGNAL_TYPE_DVI_SINGLE_LINK:
 case SIGNAL_TYPE_DVI_DUAL_LINK:
  return true;
 break;
 default:
  return false;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_dvi_single_link_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_DVI_SINGLE_LINK);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_dual_link_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_DVI_DUAL_LINK);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_audio_capable_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_DISPLAY_PORT ||
  signal == SIGNAL_TYPE_DISPLAY_PORT_MST ||
  dc_is_hdmi_signal(signal));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dc_is_virtual_signal(enum signal_type signal)
{
 return (signal == SIGNAL_TYPE_VIRTUAL);
}
# 32 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h" 2
# 45 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
union large_integer {
 struct {
  uint32_t low_part;
  int32_t high_part;
 };

 struct {
  uint32_t low_part;
  int32_t high_part;
 } u;

 int64_t quad_part;
};



enum dc_plane_addr_type {
 PLN_ADDR_TYPE_GRAPHICS = 0,
 PLN_ADDR_TYPE_GRPH_STEREO,
 PLN_ADDR_TYPE_VIDEO_PROGRESSIVE,



};

struct dc_plane_address {
 enum dc_plane_addr_type type;
 bool tmz_surface;
 union {
  struct{
   union large_integer addr;
   union large_integer meta_addr;
   union large_integer dcc_const_color;
  } grph;


  struct {
   union large_integer left_addr;
   union large_integer left_meta_addr;
   union large_integer left_dcc_const_color;

   union large_integer right_addr;
   union large_integer right_meta_addr;
   union large_integer right_dcc_const_color;
# 100 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
  } grph_stereo;


  struct {
   union large_integer luma_addr;
   union large_integer luma_meta_addr;
   union large_integer luma_dcc_const_color;

   union large_integer chroma_addr;
   union large_integer chroma_meta_addr;
   union large_integer chroma_dcc_const_color;
  } video_progressive;
# 124 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
 };

 union large_integer page_table_base;

 uint8_t vmid;
};

struct dc_size {
 int width;
 int height;
};

struct rect {
 int x;
 int y;
 int width;
 int height;
};

struct plane_size {




 int surface_pitch;
 int chroma_pitch;
 struct rect surface_size;
 struct rect chroma_size;
};

struct dc_plane_dcc_param {
 bool enable;

 int meta_pitch;
 bool independent_64b_blks;




 int meta_pitch_c;
 bool independent_64b_blks_c;



};


enum surface_pixel_format {
 SURFACE_PIXEL_FORMAT_GRPH_BEGIN = 0,

 SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS =
  SURFACE_PIXEL_FORMAT_GRPH_BEGIN,

 SURFACE_PIXEL_FORMAT_GRPH_ARGB1555,

 SURFACE_PIXEL_FORMAT_GRPH_RGB565,

 SURFACE_PIXEL_FORMAT_GRPH_ARGB8888,

 SURFACE_PIXEL_FORMAT_GRPH_ABGR8888,

 SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010,

 SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010,



 SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS,

 SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616,

 SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F,

 SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F,

 SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FIX,
 SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FIX,
 SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FLOAT,
 SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FLOAT,




 SURFACE_PIXEL_FORMAT_VIDEO_BEGIN,
 SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr =
  SURFACE_PIXEL_FORMAT_VIDEO_BEGIN,
 SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb,
 SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr,
 SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb,
  SURFACE_PIXEL_FORMAT_SUBSAMPLE_END,
 SURFACE_PIXEL_FORMAT_VIDEO_ACrYCb2101010,
 SURFACE_PIXEL_FORMAT_VIDEO_CrYCbA1010102,
 SURFACE_PIXEL_FORMAT_VIDEO_AYCrCb8888,
 SURFACE_PIXEL_FORMAT_INVALID


};




enum pixel_format {

 PIXEL_FORMAT_UNINITIALIZED,
 PIXEL_FORMAT_INDEX8,
 PIXEL_FORMAT_RGB565,
 PIXEL_FORMAT_ARGB8888,
 PIXEL_FORMAT_ARGB2101010,
 PIXEL_FORMAT_ARGB2101010_XRBIAS,
 PIXEL_FORMAT_FP16,

 PIXEL_FORMAT_420BPP8,
 PIXEL_FORMAT_420BPP10,

 PIXEL_FORMAT_INVALID,

 PIXEL_FORMAT_GRPH_BEGIN = PIXEL_FORMAT_INDEX8,
 PIXEL_FORMAT_GRPH_END = PIXEL_FORMAT_FP16,
 PIXEL_FORMAT_VIDEO_BEGIN = PIXEL_FORMAT_420BPP8,
 PIXEL_FORMAT_VIDEO_END = PIXEL_FORMAT_420BPP10,
 PIXEL_FORMAT_UNKNOWN
};

enum tile_split_values {
 DC_DISPLAY_MICRO_TILING = 0x0,
 DC_THIN_MICRO_TILING = 0x1,
 DC_DEPTH_MICRO_TILING = 0x2,
 DC_ROTATED_MICRO_TILING = 0x3,
};

enum tripleBuffer_enable {
 DC_TRIPLEBUFFER_DISABLE = 0x0,
 DC_TRIPLEBUFFER_ENABLE = 0x1,
};




enum array_mode_values {
 DC_ARRAY_LINEAR_GENERAL = 0,
 DC_ARRAY_LINEAR_ALLIGNED,
 DC_ARRAY_1D_TILED_THIN1,
 DC_ARRAY_1D_TILED_THICK,
 DC_ARRAY_2D_TILED_THIN1,
 DC_ARRAY_PRT_TILED_THIN1,
 DC_ARRAY_PRT_2D_TILED_THIN1,
 DC_ARRAY_2D_TILED_THICK,
 DC_ARRAY_2D_TILED_X_THICK,
 DC_ARRAY_PRT_TILED_THICK,
 DC_ARRAY_PRT_2D_TILED_THICK,
 DC_ARRAY_PRT_3D_TILED_THIN1,
 DC_ARRAY_3D_TILED_THIN1,
 DC_ARRAY_3D_TILED_THICK,
 DC_ARRAY_3D_TILED_X_THICK,
 DC_ARRAY_PRT_3D_TILED_THICK,
};

enum tile_mode_values {
 DC_ADDR_SURF_MICRO_TILING_DISPLAY = 0x0,
 DC_ADDR_SURF_MICRO_TILING_NON_DISPLAY = 0x1,
};

enum swizzle_mode_values {
 DC_SW_LINEAR = 0,
 DC_SW_256B_S = 1,
 DC_SW_256_D = 2,
 DC_SW_256_R = 3,
 DC_SW_4KB_S = 5,
 DC_SW_4KB_D = 6,
 DC_SW_4KB_R = 7,
 DC_SW_64KB_S = 9,
 DC_SW_64KB_D = 10,
 DC_SW_64KB_R = 11,
 DC_SW_VAR_S = 13,
 DC_SW_VAR_D = 14,
 DC_SW_VAR_R = 15,
 DC_SW_64KB_S_T = 17,
 DC_SW_64KB_D_T = 18,
 DC_SW_4KB_S_X = 21,
 DC_SW_4KB_D_X = 22,
 DC_SW_4KB_R_X = 23,
 DC_SW_64KB_S_X = 25,
 DC_SW_64KB_D_X = 26,
 DC_SW_64KB_R_X = 27,
 DC_SW_VAR_S_X = 29,
 DC_SW_VAR_D_X = 30,
 DC_SW_VAR_R_X = 31,
 DC_SW_MAX = 32,
 DC_SW_UNKNOWN = DC_SW_MAX
};

union dc_tiling_info {

 struct {





  unsigned int num_banks;





  unsigned int bank_width;
  unsigned int bank_width_c;





  unsigned int bank_height;
  unsigned int bank_height_c;



  unsigned int tile_aspect;
  unsigned int tile_aspect_c;
# 352 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
  enum tile_split_values tile_split;
  enum tile_split_values tile_split_c;






  enum tile_mode_values tile_mode;
  enum tile_mode_values tile_mode_c;





  unsigned int pipe_config;
# 376 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
  enum array_mode_values array_mode;
 } gfx8;

 struct {
  enum swizzle_mode_values swizzle;
  unsigned int num_pipes;
  unsigned int max_compressed_frags;
  unsigned int pipe_interleave;

  unsigned int num_banks;
  unsigned int num_shader_engines;
  unsigned int num_rb_per_se;
  bool shaderEnable;

  bool meta_linear;
  bool rb_aligned;
  bool pipe_aligned;
  unsigned int num_pkrs;
 } gfx9;
};


enum dc_rotation_angle {
 ROTATION_ANGLE_0 = 0,
 ROTATION_ANGLE_90,
 ROTATION_ANGLE_180,
 ROTATION_ANGLE_270,
 ROTATION_ANGLE_COUNT
};

enum dc_scan_direction {
 SCAN_DIRECTION_UNKNOWN = 0,
 SCAN_DIRECTION_HORIZONTAL = 1,
 SCAN_DIRECTION_VERTICAL = 2,
};

struct dc_cursor_position {
 uint32_t x;
 uint32_t y;

 uint32_t x_hotspot;
 uint32_t y_hotspot;




 bool enable;


 bool translate_by_source;
};

struct dc_cursor_mi_param {
 unsigned int pixel_clk_khz;
 unsigned int ref_clk_khz;
 struct rect viewport;
 struct fixed31_32 h_scale_ratio;
 struct fixed31_32 v_scale_ratio;
 enum dc_rotation_angle rotation;
 bool mirror;
};



enum {
 GAMMA_RGB_256_ENTRIES = 256,
 GAMMA_RGB_FLOAT_1024_ENTRIES = 1024,
 GAMMA_CS_TFM_1D_ENTRIES = 4096,
 GAMMA_CUSTOM_ENTRIES = 4096,
 GAMMA_MAX_ENTRIES = 4096
};

enum dc_gamma_type {
 GAMMA_RGB_256 = 1,
 GAMMA_RGB_FLOAT_1024 = 2,
 GAMMA_CS_TFM_1D = 3,
 GAMMA_CUSTOM = 4,
};

struct dc_csc_transform {
 uint16_t matrix[12];
 bool enable_adjustment;
};

struct dc_rgb_fixed {
 struct fixed31_32 red;
 struct fixed31_32 green;
 struct fixed31_32 blue;
};

struct dc_gamma {
 struct kref refcount;
 enum dc_gamma_type type;
 unsigned int num_entries;

 struct dc_gamma_entries {
  struct fixed31_32 red[GAMMA_MAX_ENTRIES];
  struct fixed31_32 green[GAMMA_MAX_ENTRIES];
  struct fixed31_32 blue[GAMMA_MAX_ENTRIES];
 } entries;


 struct dc_context *ctx;




 bool is_identity;
};
# 494 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
enum dc_cursor_color_format {
 CURSOR_MODE_MONO,
 CURSOR_MODE_COLOR_1BIT_AND,
 CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA,
 CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA,
 CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED,
 CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED
};







union dc_cursor_attribute_flags {
 struct {
  uint32_t ENABLE_MAGNIFICATION:1;
  uint32_t INVERSE_TRANSPARENT_CLAMPING:1;
  uint32_t HORIZONTAL_MIRROR:1;
  uint32_t VERTICAL_MIRROR:1;
  uint32_t INVERT_PIXEL_DATA:1;
  uint32_t ZERO_EXPANSION:1;
  uint32_t MIN_MAX_INVERT:1;
  uint32_t ENABLE_CURSOR_DEGAMMA:1;
  uint32_t RESERVED:24;
 } bits;
 uint32_t value;
};

struct dc_cursor_attributes {
 union large_integer address;
 uint32_t pitch;


 uint32_t width;
 uint32_t height;

 enum dc_cursor_color_format color_format;
 uint32_t sdr_white_level;


 enum dc_rotation_angle rotation_angle;

 union dc_cursor_attribute_flags attribute_flags;
};

struct dpp_cursor_attributes {
 int bias;
 int scale;
};



enum dc_color_space {
 COLOR_SPACE_UNKNOWN,
 COLOR_SPACE_SRGB,
 COLOR_SPACE_XR_RGB,
 COLOR_SPACE_SRGB_LIMITED,
 COLOR_SPACE_MSREF_SCRGB,
 COLOR_SPACE_YCBCR601,
 COLOR_SPACE_YCBCR709,
 COLOR_SPACE_XV_YCC_709,
 COLOR_SPACE_XV_YCC_601,
 COLOR_SPACE_YCBCR601_LIMITED,
 COLOR_SPACE_YCBCR709_LIMITED,
 COLOR_SPACE_2020_RGB_FULLRANGE,
 COLOR_SPACE_2020_RGB_LIMITEDRANGE,
 COLOR_SPACE_2020_YCBCR,
 COLOR_SPACE_ADOBERGB,
 COLOR_SPACE_DCIP3,
 COLOR_SPACE_DISPLAYNATIVE,
 COLOR_SPACE_DOLBYVISION,
 COLOR_SPACE_APPCTRL,
 COLOR_SPACE_CUSTOMPOINTS,
 COLOR_SPACE_YCBCR709_BLACK,
};

enum dc_dither_option {
 DITHER_OPTION_DEFAULT,
 DITHER_OPTION_DISABLE,
 DITHER_OPTION_FM6,
 DITHER_OPTION_FM8,
 DITHER_OPTION_FM10,
 DITHER_OPTION_SPATIAL6_FRAME_RANDOM,
 DITHER_OPTION_SPATIAL8_FRAME_RANDOM,
 DITHER_OPTION_SPATIAL10_FRAME_RANDOM,
 DITHER_OPTION_SPATIAL6,
 DITHER_OPTION_SPATIAL8,
 DITHER_OPTION_SPATIAL10,
 DITHER_OPTION_TRUN6,
 DITHER_OPTION_TRUN8,
 DITHER_OPTION_TRUN10,
 DITHER_OPTION_TRUN10_SPATIAL8,
 DITHER_OPTION_TRUN10_SPATIAL6,
 DITHER_OPTION_TRUN10_FM8,
 DITHER_OPTION_TRUN10_FM6,
 DITHER_OPTION_TRUN10_SPATIAL8_FM6,
 DITHER_OPTION_SPATIAL10_FM8,
 DITHER_OPTION_SPATIAL10_FM6,
 DITHER_OPTION_TRUN8_SPATIAL6,
 DITHER_OPTION_TRUN8_FM6,
 DITHER_OPTION_SPATIAL8_FM6,
 DITHER_OPTION_MAX = DITHER_OPTION_SPATIAL8_FM6,
 DITHER_OPTION_INVALID
};

enum dc_quantization_range {
 QUANTIZATION_RANGE_UNKNOWN,
 QUANTIZATION_RANGE_FULL,
 QUANTIZATION_RANGE_LIMITED
};

enum dc_dynamic_expansion {
 DYN_EXPANSION_AUTO,
 DYN_EXPANSION_DISABLE
};




struct scaling_taps {
 uint32_t v_taps;
 uint32_t h_taps;
 uint32_t v_taps_c;
 uint32_t h_taps_c;
 bool integer_scaling;
};

enum dc_timing_standard {
 DC_TIMING_STANDARD_UNDEFINED,
 DC_TIMING_STANDARD_DMT,
 DC_TIMING_STANDARD_GTF,
 DC_TIMING_STANDARD_CVT,
 DC_TIMING_STANDARD_CVT_RB,
 DC_TIMING_STANDARD_CEA770,
 DC_TIMING_STANDARD_CEA861,
 DC_TIMING_STANDARD_HDMI,
 DC_TIMING_STANDARD_TV_NTSC,
 DC_TIMING_STANDARD_TV_NTSC_J,
 DC_TIMING_STANDARD_TV_PAL,
 DC_TIMING_STANDARD_TV_PAL_M,
 DC_TIMING_STANDARD_TV_PAL_CN,
 DC_TIMING_STANDARD_TV_SECAM,
 DC_TIMING_STANDARD_EXPLICIT,

 DC_TIMING_STANDARD_USER_OVERRIDE,

 DC_TIMING_STANDARD_MAX
};

enum dc_color_depth {
 COLOR_DEPTH_UNDEFINED,
 COLOR_DEPTH_666,
 COLOR_DEPTH_888,
 COLOR_DEPTH_101010,
 COLOR_DEPTH_121212,
 COLOR_DEPTH_141414,
 COLOR_DEPTH_161616,
 COLOR_DEPTH_999,
 COLOR_DEPTH_111111,
 COLOR_DEPTH_COUNT
};

enum dc_pixel_encoding {
 PIXEL_ENCODING_UNDEFINED,
 PIXEL_ENCODING_RGB,
 PIXEL_ENCODING_YCBCR422,
 PIXEL_ENCODING_YCBCR444,
 PIXEL_ENCODING_YCBCR420,
 PIXEL_ENCODING_COUNT
};

enum dc_aspect_ratio {
 ASPECT_RATIO_NO_DATA,
 ASPECT_RATIO_4_3,
 ASPECT_RATIO_16_9,
 ASPECT_RATIO_64_27,
 ASPECT_RATIO_256_135,
 ASPECT_RATIO_FUTURE
};

enum scanning_type {
 SCANNING_TYPE_NODATA = 0,
 SCANNING_TYPE_OVERSCAN,
 SCANNING_TYPE_UNDERSCAN,
 SCANNING_TYPE_FUTURE,
 SCANNING_TYPE_UNDEFINED
};

struct dc_crtc_timing_flags {
 uint32_t INTERLACE :1;
 uint32_t HSYNC_POSITIVE_POLARITY :1;

 uint32_t VSYNC_POSITIVE_POLARITY :1;


 uint32_t HORZ_COUNT_BY_TWO:1;

 uint32_t EXCLUSIVE_3D :1;


 uint32_t RIGHT_EYE_3D_POLARITY :1;

 uint32_t SUB_SAMPLE_3D :1;

 uint32_t USE_IN_3D_VIEW_ONLY :1;

 uint32_t STEREO_3D_PREFERENCE :1;

 uint32_t Y_ONLY :1;

 uint32_t YCBCR420 :1;
 uint32_t DTD_COUNTER :5;

 uint32_t FORCE_HDR :1;



 uint32_t LTE_340MCSC_SCRAMBLE:1;

 uint32_t DSC : 1;
};

enum dc_timing_3d_format {
 TIMING_3D_FORMAT_NONE,
 TIMING_3D_FORMAT_FRAME_ALTERNATE,
 TIMING_3D_FORMAT_INBAND_FA,
 TIMING_3D_FORMAT_DP_HDMI_INBAND_FA,

 TIMING_3D_FORMAT_SIDEBAND_FA,
 TIMING_3D_FORMAT_HW_FRAME_PACKING,
 TIMING_3D_FORMAT_SW_FRAME_PACKING,
 TIMING_3D_FORMAT_ROW_INTERLEAVE,
 TIMING_3D_FORMAT_COLUMN_INTERLEAVE,
 TIMING_3D_FORMAT_PIXEL_INTERLEAVE,
 TIMING_3D_FORMAT_SIDE_BY_SIDE,
 TIMING_3D_FORMAT_TOP_AND_BOTTOM,
 TIMING_3D_FORMAT_SBS_SW_PACKED,

 TIMING_3D_FORMAT_TB_SW_PACKED,


 TIMING_3D_FORMAT_MAX,
};

struct dc_dsc_config {
 uint32_t num_slices_h;
 uint32_t num_slices_v;
 uint32_t bits_per_pixel;
 bool block_pred_enable;
 uint32_t linebuf_depth;
 uint32_t version_minor;
 bool ycbcr422_simple;
 int32_t rc_buffer_size;
};
struct dc_crtc_timing {
 uint32_t h_total;
 uint32_t h_border_left;
 uint32_t h_addressable;
 uint32_t h_border_right;
 uint32_t h_front_porch;
 uint32_t h_sync_width;

 uint32_t v_total;
 uint32_t v_border_top;
 uint32_t v_addressable;
 uint32_t v_border_bottom;
 uint32_t v_front_porch;
 uint32_t v_sync_width;

 uint32_t pix_clk_100hz;

 uint32_t vic;
 uint32_t hdmi_vic;
 enum dc_timing_3d_format timing_3d_format;
 enum dc_color_depth display_color_depth;
 enum dc_pixel_encoding pixel_encoding;
 enum dc_aspect_ratio aspect_ratio;
 enum scanning_type scan_type;

 struct dc_crtc_timing_flags flags;
 struct dc_dsc_config dsc_cfg;
};

enum trigger_delay {
 TRIGGER_DELAY_NEXT_PIXEL = 0,
 TRIGGER_DELAY_NEXT_LINE,
};

enum crtc_event {
 CRTC_EVENT_VSYNC_RISING = 0,
 CRTC_EVENT_VSYNC_FALLING
};

struct crtc_trigger_info {
 bool enabled;
 struct dc_stream_state *event_source;
 enum crtc_event event;
 enum trigger_delay delay;
};

struct dc_crtc_timing_adjust {
 uint32_t v_total_min;
 uint32_t v_total_max;
 uint32_t v_total_mid;
 uint32_t v_total_mid_frame_num;
};



enum vram_type {
 VIDEO_MEMORY_TYPE_GDDR5 = 2,
 VIDEO_MEMORY_TYPE_DDR3 = 3,
 VIDEO_MEMORY_TYPE_DDR4 = 4,
 VIDEO_MEMORY_TYPE_HBM = 5,
 VIDEO_MEMORY_TYPE_GDDR6 = 6,
};

enum dwb_cnv_out_bpc {
 DWB_CNV_OUT_BPC_8BPC = 0,
 DWB_CNV_OUT_BPC_10BPC = 1,
};

enum dwb_output_depth {
 DWB_OUTPUT_PIXEL_DEPTH_8BPC = 0,
 DWB_OUTPUT_PIXEL_DEPTH_10BPC = 1,
};

enum dwb_capture_rate {
 dwb_capture_rate_0 = 0,
 dwb_capture_rate_1 = 1,
 dwb_capture_rate_2 = 2,
 dwb_capture_rate_3 = 3,
};

enum dwb_scaler_mode {
 dwb_scaler_mode_bypass444 = 0,
 dwb_scaler_mode_rgb444 = 1,
 dwb_scaler_mode_yuv444 = 2,
 dwb_scaler_mode_yuv420 = 3
};

enum dwb_subsample_position {
 DWB_INTERSTITIAL_SUBSAMPLING = 0,
 DWB_COSITED_SUBSAMPLING = 1
};

enum dwb_stereo_eye_select {
 DWB_STEREO_EYE_LEFT = 1,
 DWB_STEREO_EYE_RIGHT = 2,
};

enum dwb_stereo_type {
 DWB_STEREO_TYPE_FRAME_PACKING = 0,
 DWB_STEREO_TYPE_FRAME_SEQUENTIAL = 3,
};
# 890 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_hw_types.h"
struct mcif_buf_params {
 unsigned long long luma_address[4];
 unsigned long long chroma_address[4];
 unsigned int luma_pitch;
 unsigned int chroma_pitch;
 unsigned int warmup_pitch;
 unsigned int swlock;



};



struct tg_color {

 uint16_t color_r_cr;
 uint16_t color_g_y;
 uint16_t color_b_cb;
};
# 37 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/dal_types.h" 1
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/dal_types.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/dal_types.h" 2

struct dal_logger;
struct dc_bios;

enum dce_version {
 DCE_VERSION_UNKNOWN = (-1),
 DCE_VERSION_8_0,
 DCE_VERSION_8_1,
 DCE_VERSION_8_3,
 DCE_VERSION_10_0,
 DCE_VERSION_11_0,
 DCE_VERSION_11_2,
 DCE_VERSION_11_22,
 DCE_VERSION_12_0,
 DCE_VERSION_12_1,
 DCE_VERSION_MAX,
 DCN_VERSION_1_0,
 DCN_VERSION_1_01,
 DCN_VERSION_2_0,
 DCN_VERSION_2_1,
 DCN_VERSION_3_0,
 DCN_VERSION_MAX
};
# 38 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_id.h" 1
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_id.h"
enum object_type {
 OBJECT_TYPE_UNKNOWN = 0,


 OBJECT_TYPE_GPU,
 OBJECT_TYPE_ENCODER,
 OBJECT_TYPE_CONNECTOR,
 OBJECT_TYPE_ROUTER,
 OBJECT_TYPE_GENERIC,


 OBJECT_TYPE_AUDIO,
 OBJECT_TYPE_CONTROLLER,
 OBJECT_TYPE_CLOCK_SOURCE,
 OBJECT_TYPE_ENGINE,

 OBJECT_TYPE_COUNT
};


enum object_enum_id {
 ENUM_ID_UNKNOWN = 0,
 ENUM_ID_1,
 ENUM_ID_2,
 ENUM_ID_3,
 ENUM_ID_4,
 ENUM_ID_5,
 ENUM_ID_6,
 ENUM_ID_7,

 ENUM_ID_COUNT
};


enum generic_id {
 GENERIC_ID_UNKNOWN = 0,
 GENERIC_ID_MXM_OPM,
 GENERIC_ID_GLSYNC,
 GENERIC_ID_STEREO,

 GENERIC_ID_COUNT
};


enum controller_id {
 CONTROLLER_ID_UNDEFINED = 0,
 CONTROLLER_ID_D0,
 CONTROLLER_ID_D1,
 CONTROLLER_ID_D2,
 CONTROLLER_ID_D3,
 CONTROLLER_ID_D4,
 CONTROLLER_ID_D5,
 CONTROLLER_ID_UNDERLAY0,
 CONTROLLER_ID_MAX = CONTROLLER_ID_UNDERLAY0
};
# 93 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_id.h"
enum clock_source_id {
 CLOCK_SOURCE_ID_UNDEFINED = 0,
 CLOCK_SOURCE_ID_PLL0,
 CLOCK_SOURCE_ID_PLL1,
 CLOCK_SOURCE_ID_PLL2,
 CLOCK_SOURCE_ID_EXTERNAL,
 CLOCK_SOURCE_ID_DCPLL,
 CLOCK_SOURCE_ID_DFS,
 CLOCK_SOURCE_ID_VCE,

 CLOCK_SOURCE_ID_DP_DTO,

 CLOCK_SOURCE_COMBO_PHY_PLL0,
 CLOCK_SOURCE_COMBO_PHY_PLL1,
 CLOCK_SOURCE_COMBO_PHY_PLL2,
 CLOCK_SOURCE_COMBO_PHY_PLL3,
 CLOCK_SOURCE_COMBO_PHY_PLL4,
 CLOCK_SOURCE_COMBO_PHY_PLL5,
 CLOCK_SOURCE_COMBO_DISPLAY_PLL0
};


enum encoder_id {
 ENCODER_ID_UNKNOWN = 0,


 ENCODER_ID_INTERNAL_LVDS,
 ENCODER_ID_INTERNAL_TMDS1,
 ENCODER_ID_INTERNAL_TMDS2,
 ENCODER_ID_INTERNAL_DAC1,
 ENCODER_ID_INTERNAL_DAC2,


 ENCODER_ID_INTERNAL_LVTM1,
 ENCODER_ID_INTERNAL_HDMI,


 ENCODER_ID_INTERNAL_KLDSCP_TMDS1,
 ENCODER_ID_INTERNAL_KLDSCP_DAC1,
 ENCODER_ID_INTERNAL_KLDSCP_DAC2,

 ENCODER_ID_EXTERNAL_MVPU_FPGA,
 ENCODER_ID_INTERNAL_DDI,
 ENCODER_ID_INTERNAL_UNIPHY,
 ENCODER_ID_INTERNAL_KLDSCP_LVTMA,
 ENCODER_ID_INTERNAL_UNIPHY1,
 ENCODER_ID_INTERNAL_UNIPHY2,
 ENCODER_ID_EXTERNAL_NUTMEG,
 ENCODER_ID_EXTERNAL_TRAVIS,

 ENCODER_ID_INTERNAL_WIRELESS,
 ENCODER_ID_INTERNAL_UNIPHY3,
 ENCODER_ID_INTERNAL_VIRTUAL,
};


enum connector_id {
 CONNECTOR_ID_UNKNOWN = 0,
 CONNECTOR_ID_SINGLE_LINK_DVII = 1,
 CONNECTOR_ID_DUAL_LINK_DVII = 2,
 CONNECTOR_ID_SINGLE_LINK_DVID = 3,
 CONNECTOR_ID_DUAL_LINK_DVID = 4,
 CONNECTOR_ID_VGA = 5,
 CONNECTOR_ID_HDMI_TYPE_A = 12,
 CONNECTOR_ID_LVDS = 14,
 CONNECTOR_ID_PCIE = 16,
 CONNECTOR_ID_HARDCODE_DVI = 18,
 CONNECTOR_ID_DISPLAY_PORT = 19,
 CONNECTOR_ID_EDP = 20,
 CONNECTOR_ID_MXM = 21,
 CONNECTOR_ID_WIRELESS = 22,
 CONNECTOR_ID_MIRACAST = 23,

 CONNECTOR_ID_VIRTUAL = 100
};


enum audio_id {
 AUDIO_ID_UNKNOWN = 0,
 AUDIO_ID_INTERNAL_AZALIA
};


enum engine_id {
 ENGINE_ID_DIGA,
 ENGINE_ID_DIGB,
 ENGINE_ID_DIGC,
 ENGINE_ID_DIGD,
 ENGINE_ID_DIGE,
 ENGINE_ID_DIGF,
 ENGINE_ID_DIGG,
 ENGINE_ID_DACA,
 ENGINE_ID_DACB,
 ENGINE_ID_VCE,
 ENGINE_ID_VIRTUAL,

 ENGINE_ID_COUNT,
 ENGINE_ID_UNKNOWN = (-1L)
};

enum transmitter_color_depth {
 TRANSMITTER_COLOR_DEPTH_24 = 0,
 TRANSMITTER_COLOR_DEPTH_30,
 TRANSMITTER_COLOR_DEPTH_36,
 TRANSMITTER_COLOR_DEPTH_48
};

enum dp_alt_mode {
 DP_Alt_mode__Unknown = 0,
 DP_Alt_mode__Connect,
 DP_Alt_mode__NoConnect,
};
# 220 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_id.h"
struct graphics_object_id {
 uint32_t id:8;
 uint32_t enum_id:4;
 uint32_t type:4;
 uint32_t reserved:16;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct graphics_object_id dal_graphics_object_id_init(
 uint32_t id,
 enum object_enum_id enum_id,
 enum object_type type)
{
 struct graphics_object_id result = {
  id, enum_id, type, 0
 };

 return result;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uint32_t dal_graphics_object_id_to_uint(
 struct graphics_object_id id)
{
 return id.id + (id.enum_id << 0x8) + (id.type << 0xc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum controller_id dal_graphics_object_id_get_controller_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_CONTROLLER)
  return (enum controller_id) id.id;
 return CONTROLLER_ID_UNDEFINED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum clock_source_id dal_graphics_object_id_get_clock_source_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_CLOCK_SOURCE)
  return (enum clock_source_id) id.id;
 return CLOCK_SOURCE_ID_UNDEFINED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum encoder_id dal_graphics_object_id_get_encoder_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_ENCODER)
  return (enum encoder_id) id.id;
 return ENCODER_ID_UNKNOWN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum connector_id dal_graphics_object_id_get_connector_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_CONNECTOR)
  return (enum connector_id) id.id;
 return CONNECTOR_ID_UNKNOWN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum audio_id dal_graphics_object_id_get_audio_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_AUDIO)
  return (enum audio_id) id.id;
 return AUDIO_ID_UNKNOWN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum engine_id dal_graphics_object_id_get_engine_id(
 struct graphics_object_id id)
{
 if (id.type == OBJECT_TYPE_ENGINE)
  return (enum engine_id) id.id;
 return ENGINE_ID_UNKNOWN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dal_graphics_object_id_equal(
 struct graphics_object_id id_1,
 struct graphics_object_id id_2)
{
 if ((id_1.id == id_2.id) && (id_1.enum_id == id_2.enum_id) &&
  (id_1.type == id_2.type)) {
  return true;
 }
 return false;
}
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h" 2
# 45 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h"
enum hpd_source_id {
 HPD_SOURCEID1 = 0,
 HPD_SOURCEID2,
 HPD_SOURCEID3,
 HPD_SOURCEID4,
 HPD_SOURCEID5,
 HPD_SOURCEID6,

 HPD_SOURCEID_COUNT,
 HPD_SOURCEID_UNKNOWN
};


enum channel_id {
 CHANNEL_ID_UNKNOWN = 0,
 CHANNEL_ID_DDC1,
 CHANNEL_ID_DDC2,
 CHANNEL_ID_DDC3,
 CHANNEL_ID_DDC4,
 CHANNEL_ID_DDC5,
 CHANNEL_ID_DDC6,
 CHANNEL_ID_DDC_VGA,
 CHANNEL_ID_I2C_PAD,
 CHANNEL_ID_COUNT
};
# 81 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h"
enum transmitter {
 TRANSMITTER_UNKNOWN = (-1L),
 TRANSMITTER_UNIPHY_A,
 TRANSMITTER_UNIPHY_B,
 TRANSMITTER_UNIPHY_C,
 TRANSMITTER_UNIPHY_D,
 TRANSMITTER_UNIPHY_E,
 TRANSMITTER_UNIPHY_F,
 TRANSMITTER_NUTMEG_CRT,
 TRANSMITTER_TRAVIS_CRT,
 TRANSMITTER_TRAVIS_LCD,
 TRANSMITTER_UNIPHY_G,
 TRANSMITTER_COUNT
};



enum sync_source {
 SYNC_SOURCE_NONE = 0,


 SYNC_SOURCE_CONTROLLER0,
 SYNC_SOURCE_CONTROLLER1,
 SYNC_SOURCE_CONTROLLER2,
 SYNC_SOURCE_CONTROLLER3,
 SYNC_SOURCE_CONTROLLER4,
 SYNC_SOURCE_CONTROLLER5,


 SYNC_SOURCE_GSL_GROUP0,
 SYNC_SOURCE_GSL_GROUP1,
 SYNC_SOURCE_GSL_GROUP2,



 SYNC_SOURCE_GSL_IO_FIRST,
 SYNC_SOURCE_GSL_IO_GENLOCK_CLOCK = SYNC_SOURCE_GSL_IO_FIRST,
 SYNC_SOURCE_GSL_IO_GENLOCK_VSYNC,
 SYNC_SOURCE_GSL_IO_SWAPLOCK_A,
 SYNC_SOURCE_GSL_IO_SWAPLOCK_B,
 SYNC_SOURCE_GSL_IO_LAST = SYNC_SOURCE_GSL_IO_SWAPLOCK_B,


 SYNC_SOURCE_IO_FIRST,
 SYNC_SOURCE_IO_GENERIC_A = SYNC_SOURCE_IO_FIRST,
 SYNC_SOURCE_IO_GENERIC_B,
 SYNC_SOURCE_IO_GENERIC_C,
 SYNC_SOURCE_IO_GENERIC_D,
 SYNC_SOURCE_IO_GENERIC_E,
 SYNC_SOURCE_IO_GENERIC_F,
 SYNC_SOURCE_IO_HPD1,
 SYNC_SOURCE_IO_HPD2,
 SYNC_SOURCE_IO_HSYNC_A,
 SYNC_SOURCE_IO_VSYNC_A,
 SYNC_SOURCE_IO_HSYNC_B,
 SYNC_SOURCE_IO_VSYNC_B,
 SYNC_SOURCE_IO_LAST = SYNC_SOURCE_IO_VSYNC_B,


 SYNC_SOURCE_DUAL_GPU_PIN
};
# 151 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/grph_object_defs.h"
enum connector_layout_type {
 CONNECTOR_LAYOUT_TYPE_UNKNOWN,
 CONNECTOR_LAYOUT_TYPE_DVI_D,
 CONNECTOR_LAYOUT_TYPE_DVI_I,
 CONNECTOR_LAYOUT_TYPE_VGA,
 CONNECTOR_LAYOUT_TYPE_HDMI,
 CONNECTOR_LAYOUT_TYPE_DP,
 CONNECTOR_LAYOUT_TYPE_MINI_DP,
};
struct connector_layout_info {
 struct graphics_object_id connector_id;
 enum connector_layout_type connector_type;
 unsigned int length;
 unsigned int position;
};


struct slot_layout_info {
 unsigned int length;
 unsigned int width;
 unsigned int num_of_connectors;
 struct connector_layout_info connectors[(16)];
};

struct board_layout_info {
 unsigned int num_of_slots;


 unsigned int is_number_of_slots_valid : 1;
 unsigned int is_slots_size_valid : 1;
 unsigned int is_connector_offsets_valid : 1;
 unsigned int is_connector_lengths_valid : 1;

 struct slot_layout_info slots[(4)];
};
# 39 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2


# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_cp_psp.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_cp_psp.h"
struct dc_link;

struct cp_psp_stream_config {
 uint8_t otg_inst;
 uint8_t link_enc_inst;
 uint8_t stream_enc_inst;
 uint8_t mst_supported;
 void *dm_stream_ctx;
 bool dpms_off;
};

struct cp_psp_funcs {
 void (*update_stream_config)(void *handle, struct cp_psp_stream_config *config);
};

struct cp_psp {
 void *handle;
 struct cp_psp_funcs funcs;
};
# 42 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2



struct dc_plane_state;
struct dc_stream_state;
struct dc_link;
struct dc_sink;
struct dal;
struct dc_dmub_srv;




enum dce_environment {
 DCE_ENV_PRODUCTION_DRV = 0,



 DCE_ENV_FPGA_MAXIMUS,


 DCE_ENV_DIAG,




 DCE_ENV_VIRTUAL_HW
};
# 78 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
struct hw_asic_id {
 uint32_t chip_id;
 uint32_t chip_family;
 uint32_t pci_revision_id;
 uint32_t hw_internal_rev;
 uint32_t vram_type;
 uint32_t vram_width;
 uint32_t feature_flags;
 uint32_t fake_paths_num;
 void *atombios_base_address;
};

struct dc_perf_trace {
 unsigned long read_count;
 unsigned long write_count;
 unsigned long last_entry_read;
 unsigned long last_entry_write;
};

struct dc_context {
 struct dc *dc;

 void *driver_context;
 struct dc_perf_trace *perf_trace;
 void *cgs_device;

 enum dce_environment dce_environment;
 struct hw_asic_id asic_id;




 enum dce_version dce_version;
 struct dc_bios *dc_bios;
 bool created_bios;
 struct gpio_service *gpio_service;
 uint32_t dc_sink_id_count;
 uint32_t dc_stream_id_count;
 uint64_t fbc_gpu_addr;
 struct dc_dmub_srv *dmub_srv;


 struct cp_psp cp_psp;

};
# 131 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_ddc_types.h" 1
# 28 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_ddc_types.h"
enum aux_transaction_type {
 AUX_TRANSACTION_TYPE_DP,
 AUX_TRANSACTION_TYPE_I2C
};


enum i2caux_transaction_action {
 I2CAUX_TRANSACTION_ACTION_I2C_WRITE = 0x00,
 I2CAUX_TRANSACTION_ACTION_I2C_READ = 0x10,
 I2CAUX_TRANSACTION_ACTION_I2C_STATUS_REQUEST = 0x20,

 I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT = 0x40,
 I2CAUX_TRANSACTION_ACTION_I2C_READ_MOT = 0x50,
 I2CAUX_TRANSACTION_ACTION_I2C_STATUS_REQUEST_MOT = 0x60,

 I2CAUX_TRANSACTION_ACTION_DP_WRITE = 0x80,
 I2CAUX_TRANSACTION_ACTION_DP_READ = 0x90
};

enum aux_channel_operation_result {
 AUX_CHANNEL_OPERATION_SUCCEEDED,
 AUX_CHANNEL_OPERATION_FAILED_REASON_UNKNOWN,
 AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY,
 AUX_CHANNEL_OPERATION_FAILED_TIMEOUT,
 AUX_CHANNEL_OPERATION_FAILED_HPD_DISCON,
 AUX_CHANNEL_OPERATION_FAILED_ENGINE_ACQUIRE
};


struct aux_request_transaction_data {
 enum aux_transaction_type type;
 enum i2caux_transaction_action action;

 uint32_t address;

 uint8_t delay;
 uint32_t length;
 uint8_t *data;
};

enum aux_transaction_reply {
 AUX_TRANSACTION_REPLY_AUX_ACK = 0x00,
 AUX_TRANSACTION_REPLY_AUX_NACK = 0x01,
 AUX_TRANSACTION_REPLY_AUX_DEFER = 0x02,
 AUX_TRANSACTION_REPLY_I2C_OVER_AUX_NACK = 0x04,
 AUX_TRANSACTION_REPLY_I2C_OVER_AUX_DEFER = 0x08,

 AUX_TRANSACTION_REPLY_I2C_ACK = 0x00,
 AUX_TRANSACTION_REPLY_I2C_NACK = 0x10,
 AUX_TRANSACTION_REPLY_I2C_DEFER = 0x20,

 AUX_TRANSACTION_REPLY_HPD_DISCON = 0x40,

 AUX_TRANSACTION_REPLY_INVALID = 0xFF
};

struct aux_reply_transaction_data {
 enum aux_transaction_reply status;
 uint32_t length;
 uint8_t *data;
};

struct i2c_payload {
 bool write;
 uint8_t address;
 uint32_t length;
 uint8_t *data;
};

enum i2c_command_engine {
 I2C_COMMAND_ENGINE_DEFAULT,
 I2C_COMMAND_ENGINE_SW,
 I2C_COMMAND_ENGINE_HW
};

struct i2c_command {
 struct i2c_payload *payloads;
 uint8_t number_of_payloads;

 enum i2c_command_engine engine;



 uint32_t speed;
};

struct gpio_ddc_hw_info {
 bool hw_supported;
 uint32_t ddc_channel;
};

struct ddc {
 struct gpio *pin_data;
 struct gpio *pin_clock;
 struct gpio_ddc_hw_info hw_info;
 struct dc_context *ctx;
};

union ddc_wa {
 struct {
  uint32_t DP_SKIP_POWER_OFF:1;
  uint32_t DP_AUX_POWER_UP_WA_DELAY:1;
 } bits;
 uint32_t raw;
};

struct ddc_flags {
 uint8_t EDID_QUERY_DONE_ONCE:1;
 uint8_t IS_INTERNAL_DISPLAY:1;
 uint8_t FORCE_READ_REPEATED_START:1;
 uint8_t EDID_STRESS_READ:1;

};

enum ddc_transaction_type {
 DDC_TRANSACTION_TYPE_NONE = 0,
 DDC_TRANSACTION_TYPE_I2C,
 DDC_TRANSACTION_TYPE_I2C_OVER_AUX,
 DDC_TRANSACTION_TYPE_I2C_OVER_AUX_WITH_DEFER,
 DDC_TRANSACTION_TYPE_I2C_OVER_AUX_RETRY_DEFER
};

enum display_dongle_type {
 DISPLAY_DONGLE_NONE = 0,

 DISPLAY_DONGLE_DP_VGA_CONVERTER,
 DISPLAY_DONGLE_DP_DVI_CONVERTER,
 DISPLAY_DONGLE_DP_HDMI_CONVERTER,

 DISPLAY_DONGLE_DP_DVI_DONGLE,
 DISPLAY_DONGLE_DP_HDMI_DONGLE,

 DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE,
};

struct ddc_service {
 struct ddc *ddc_pin;
 struct ddc_flags flags;
 union ddc_wa wa;
 enum ddc_transaction_type transaction_type;
 enum display_dongle_type dongle_type;
 struct dc_context *ctx;
 struct dc_link *link;

 uint32_t address;
 uint32_t edid_buf_len;
 uint8_t edid_buf[1024];
};
# 132 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h" 2

enum tiling_mode {
 TILING_MODE_INVALID,
 TILING_MODE_LINEAR,
 TILING_MODE_TILED,
 TILING_MODE_COUNT
};

enum view_3d_format {
 VIEW_3D_FORMAT_NONE = 0,
 VIEW_3D_FORMAT_FRAME_SEQUENTIAL,
 VIEW_3D_FORMAT_SIDE_BY_SIDE,
 VIEW_3D_FORMAT_TOP_AND_BOTTOM,
 VIEW_3D_FORMAT_COUNT,
 VIEW_3D_FORMAT_FIRST = VIEW_3D_FORMAT_FRAME_SEQUENTIAL
};

enum plane_stereo_format {
 PLANE_STEREO_FORMAT_NONE = 0,
 PLANE_STEREO_FORMAT_SIDE_BY_SIDE = 1,
 PLANE_STEREO_FORMAT_TOP_AND_BOTTOM = 2,
 PLANE_STEREO_FORMAT_FRAME_ALTERNATE = 3,
 PLANE_STEREO_FORMAT_ROW_INTERLEAVED = 5,
 PLANE_STEREO_FORMAT_COLUMN_INTERLEAVED = 6,
 PLANE_STEREO_FORMAT_CHECKER_BOARD = 7
};






enum dc_edid_connector_type {
 DC_EDID_CONNECTOR_UNKNOWN = 0,
 DC_EDID_CONNECTOR_ANALOG = 1,
 DC_EDID_CONNECTOR_DIGITAL = 10,
 DC_EDID_CONNECTOR_DVI = 11,
 DC_EDID_CONNECTOR_HDMIA = 12,
 DC_EDID_CONNECTOR_MDDI = 14,
 DC_EDID_CONNECTOR_DISPLAYPORT = 15
};

enum dc_edid_status {
 EDID_OK,
 EDID_BAD_INPUT,
 EDID_NO_RESPONSE,
 EDID_BAD_CHECKSUM,
 EDID_THE_SAME,
};

enum act_return_status {
 ACT_SUCCESS,
 ACT_LINK_LOST,
 ACT_FAILED
};


struct dc_cea_audio_mode {
 uint8_t format_code;
 uint8_t channel_count;
 uint8_t sample_rate;
 union {
  uint8_t sample_size;

  uint8_t max_bit_rate;
  uint8_t audio_codec_vendor_specific;
 };
};

struct dc_edid {
 uint32_t length;
 uint8_t raw_edid[1024];
};
# 215 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
union display_content_support {
 unsigned int raw;
 struct {
  unsigned int valid_content_type :1;
  unsigned int game_content :1;
  unsigned int cinema_content :1;
  unsigned int photo_content :1;
  unsigned int graphics_content :1;
  unsigned int reserved :27;
 } bits;
};

struct dc_panel_patch {
 unsigned int dppowerup_delay;
 unsigned int extra_t12_ms;
 unsigned int extra_delay_backlight_off;
 unsigned int extra_t7_ms;
 unsigned int skip_scdc_overwrite;
 unsigned int delay_ignore_msa;
 unsigned int disable_fec;
};

struct dc_edid_caps {

 uint16_t manufacturer_id;
 uint16_t product_id;
 uint32_t serial_number;
 uint8_t manufacture_week;
 uint8_t manufacture_year;
 uint8_t display_name[20];


 uint8_t speaker_flags;
 uint32_t audio_mode_count;
 struct dc_cea_audio_mode audio_modes[16];
 uint32_t audio_latency;
 uint32_t video_latency;

 union display_content_support content_support;

 uint8_t qs_bit;
 uint8_t qy_bit;


 bool lte_340mcsc_scramble;

 bool edid_hdmi;
 bool hdr_supported;

 struct dc_panel_patch panel_patch;
};

struct view {
 uint32_t width;
 uint32_t height;
};

struct dc_mode_flags {

 uint32_t INTERLACE :1;

 uint32_t NATIVE :1;

 uint32_t PREFERRED :1;


 uint32_t REDUCED_BLANKING :1;

 uint32_t VIDEO_OPTIMIZED_RATE :1;

 uint32_t PACKED_PIXEL_FORMAT :1;

 uint32_t PREFERRED_VIEW :1;

 uint32_t TILED_MODE :1;
 uint32_t DSE_MODE :1;




 uint32_t MIRACAST_REFRESH_DIVIDER;
};


enum dc_timing_source {
 TIMING_SOURCE_UNDEFINED,


 TIMING_SOURCE_USER_FORCED,
 TIMING_SOURCE_USER_OVERRIDE,
 TIMING_SOURCE_CUSTOM,
 TIMING_SOURCE_EXPLICIT,


 TIMING_SOURCE_EDID_CEA_SVD_3D,
 TIMING_SOURCE_EDID_CEA_SVD_PREFERRED,
 TIMING_SOURCE_EDID_CEA_SVD_420,
 TIMING_SOURCE_EDID_DETAILED,
 TIMING_SOURCE_EDID_ESTABLISHED,
 TIMING_SOURCE_EDID_STANDARD,
 TIMING_SOURCE_EDID_CEA_SVD,
 TIMING_SOURCE_EDID_CVT_3BYTE,
 TIMING_SOURCE_EDID_4BYTE,
 TIMING_SOURCE_VBIOS,
 TIMING_SOURCE_CV,
 TIMING_SOURCE_TV,
 TIMING_SOURCE_HDMI_VIC,


 TIMING_SOURCE_DEFAULT,


 TIMING_SOURCE_CUSTOM_BASE,


 TIMING_SOURCE_RANGELIMIT,
 TIMING_SOURCE_OS_FORCED,
 TIMING_SOURCE_IMPLICIT,


 TIMING_SOURCE_BASICMODE,

 TIMING_SOURCE_COUNT
};


struct stereo_3d_features {
 bool supported ;
 bool allTimings ;
 bool cloneMode ;
 bool scaling ;
 bool singleFrameSWPacked;
};

enum dc_timing_support_method {
 TIMING_SUPPORT_METHOD_UNDEFINED,
 TIMING_SUPPORT_METHOD_EXPLICIT,
 TIMING_SUPPORT_METHOD_IMPLICIT,
 TIMING_SUPPORT_METHOD_NATIVE
};

struct dc_mode_info {
 uint32_t pixel_width;
 uint32_t pixel_height;
 uint32_t field_rate;



 enum dc_timing_standard timing_standard;
 enum dc_timing_source timing_source;
 struct dc_mode_flags flags;
};

enum dc_power_state {
 DC_POWER_STATE_ON = 1,
 DC_POWER_STATE_STANDBY,
 DC_POWER_STATE_SUSPEND,
 DC_POWER_STATE_OFF
};


enum dc_video_power_state {
 DC_VIDEO_POWER_UNSPECIFIED = 0,
 DC_VIDEO_POWER_ON = 1,
 DC_VIDEO_POWER_STANDBY,
 DC_VIDEO_POWER_SUSPEND,
 DC_VIDEO_POWER_OFF,
 DC_VIDEO_POWER_HIBERNATE,
 DC_VIDEO_POWER_SHUTDOWN,
 DC_VIDEO_POWER_ULPS,
 DC_VIDEO_POWER_AFTER_RESET,
 DC_VIDEO_POWER_MAXIMUM
};

enum dc_acpi_cm_power_state {
 DC_ACPI_CM_POWER_STATE_D0 = 1,
 DC_ACPI_CM_POWER_STATE_D1 = 2,
 DC_ACPI_CM_POWER_STATE_D2 = 4,
 DC_ACPI_CM_POWER_STATE_D3 = 8
};

enum dc_connection_type {
 dc_connection_none,
 dc_connection_single,
 dc_connection_mst_branch,
 dc_connection_active_dongle
};

struct dc_csc_adjustments {
 struct fixed31_32 contrast;
 struct fixed31_32 saturation;
 struct fixed31_32 brightness;
 struct fixed31_32 hue;
};

enum dpcd_downstream_port_max_bpc {
 DOWN_STREAM_MAX_8BPC = 0,
 DOWN_STREAM_MAX_10BPC,
 DOWN_STREAM_MAX_12BPC,
 DOWN_STREAM_MAX_16BPC
};


enum link_training_offset {
 DPRX = 0,
 LTTPR_PHY_REPEATER1 = 1,
 LTTPR_PHY_REPEATER2 = 2,
 LTTPR_PHY_REPEATER3 = 3,
 LTTPR_PHY_REPEATER4 = 4,
 LTTPR_PHY_REPEATER5 = 5,
 LTTPR_PHY_REPEATER6 = 6,
 LTTPR_PHY_REPEATER7 = 7,
 LTTPR_PHY_REPEATER8 = 8
};

struct dc_lttpr_caps {
 union dpcd_rev revision;
 uint8_t mode;
 uint8_t max_lane_count;
 uint8_t max_link_rate;
 uint8_t phy_repeater_cnt;
 uint8_t max_ext_timeout;
 uint8_t aux_rd_interval[8 - 1];
};

struct dc_dongle_caps {

 enum display_dongle_type dongle_type;
 bool extendedCapValid;


 bool is_dp_hdmi_s3d_converter;
 bool is_dp_hdmi_ycbcr422_pass_through;
 bool is_dp_hdmi_ycbcr420_pass_through;
 bool is_dp_hdmi_ycbcr422_converter;
 bool is_dp_hdmi_ycbcr420_converter;
 uint32_t dp_hdmi_max_bpc;
 uint32_t dp_hdmi_max_pixel_clk_in_khz;
};

enum scaling_transformation {
 SCALING_TRANSFORMATION_UNINITIALIZED,
 SCALING_TRANSFORMATION_IDENTITY = 0x0001,
 SCALING_TRANSFORMATION_CENTER_TIMING = 0x0002,
 SCALING_TRANSFORMATION_FULL_SCREEN_SCALE = 0x0004,
 SCALING_TRANSFORMATION_PRESERVE_ASPECT_RATIO_SCALE = 0x0008,
 SCALING_TRANSFORMATION_DAL_DECIDE = 0x0010,
 SCALING_TRANSFORMATION_INVALID = 0x80000000,


 SCALING_TRANSFORMATION_BEGING = SCALING_TRANSFORMATION_IDENTITY,
 SCALING_TRANSFORMATION_END =
  SCALING_TRANSFORMATION_PRESERVE_ASPECT_RATIO_SCALE
};

enum display_content_type {
 DISPLAY_CONTENT_TYPE_NO_DATA = 0,
 DISPLAY_CONTENT_TYPE_GRAPHICS = 1,
 DISPLAY_CONTENT_TYPE_PHOTO = 2,
 DISPLAY_CONTENT_TYPE_CINEMA = 4,
 DISPLAY_CONTENT_TYPE_GAME = 8
};
# 492 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
struct dwb_stereo_params {
 bool stereo_enabled;
 enum dwb_stereo_type stereo_type;
 bool stereo_polarity;
 enum dwb_stereo_eye_select stereo_eye_select;
};

struct dc_dwb_cnv_params {
 unsigned int src_width;
 unsigned int src_height;
 unsigned int crop_width;
 bool crop_en;
 unsigned int crop_height;
 unsigned int crop_x;
 unsigned int crop_y;
 enum dwb_cnv_out_bpc cnv_out_bpc;






};

struct dc_dwb_params {






 struct dc_dwb_cnv_params cnv_params;
 unsigned int dest_width;
 unsigned int dest_height;
 enum dwb_scaler_mode out_format;
 enum dwb_output_depth output_depth;
 enum dwb_capture_rate capture_rate;
 struct scaling_taps scaler_taps;
 enum dwb_subsample_position subsample_position;
 struct dc_transfer_func *out_transfer_func;
};



union audio_sample_rates {
 struct sample_rates {
  uint8_t RATE_32:1;
  uint8_t RATE_44_1:1;
  uint8_t RATE_48:1;
  uint8_t RATE_88_2:1;
  uint8_t RATE_96:1;
  uint8_t RATE_176_4:1;
  uint8_t RATE_192:1;
 } rate;

 uint8_t all;
};

struct audio_speaker_flags {
 uint32_t FL_FR:1;
 uint32_t LFE:1;
 uint32_t FC:1;
 uint32_t RL_RR:1;
 uint32_t RC:1;
 uint32_t FLC_FRC:1;
 uint32_t RLC_RRC:1;
 uint32_t SUPPORT_AI:1;
};

struct audio_speaker_info {
 uint32_t ALLSPEAKERS:7;
 uint32_t SUPPORT_AI:1;
};


struct audio_info_flags {

 union {

  struct audio_speaker_flags speaker_flags;
  struct audio_speaker_info info;

  uint8_t all;
 };
};

enum audio_format_code {
 AUDIO_FORMAT_CODE_FIRST = 1,
 AUDIO_FORMAT_CODE_LINEARPCM = AUDIO_FORMAT_CODE_FIRST,

 AUDIO_FORMAT_CODE_AC3,

 AUDIO_FORMAT_CODE_MPEG1,

 AUDIO_FORMAT_CODE_MP3,

 AUDIO_FORMAT_CODE_MPEG2,
 AUDIO_FORMAT_CODE_AAC,
 AUDIO_FORMAT_CODE_DTS,
 AUDIO_FORMAT_CODE_ATRAC,
 AUDIO_FORMAT_CODE_1BITAUDIO,
 AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS,
 AUDIO_FORMAT_CODE_DTS_HD,
 AUDIO_FORMAT_CODE_MAT_MLP,
 AUDIO_FORMAT_CODE_DST,
 AUDIO_FORMAT_CODE_WMAPRO,
 AUDIO_FORMAT_CODE_LAST,
 AUDIO_FORMAT_CODE_COUNT =
  AUDIO_FORMAT_CODE_LAST - AUDIO_FORMAT_CODE_FIRST
};

struct audio_mode {

 enum audio_format_code format_code;

 uint8_t channel_count;

 union audio_sample_rates sample_rates;
 union {

  uint8_t sample_size;

  uint8_t max_bit_rate;

  uint8_t vendor_specific;
 };
};

struct audio_info {
 struct audio_info_flags flags;
 uint32_t video_latency;
 uint32_t audio_latency;
 uint32_t display_index;
 uint8_t display_name[20];
 uint32_t manufacture_id;
 uint32_t product_id;

 uint32_t port_id[2];
 uint32_t mode_count;

 struct audio_mode modes[16];
};
struct audio_check {
 unsigned int audio_packet_type;
 unsigned int max_audiosample_rate;
 unsigned int acat;
};
enum dc_infoframe_type {
 DC_HDMI_INFOFRAME_TYPE_VENDOR = 0x81,
 DC_HDMI_INFOFRAME_TYPE_AVI = 0x82,
 DC_HDMI_INFOFRAME_TYPE_SPD = 0x83,
 DC_HDMI_INFOFRAME_TYPE_AUDIO = 0x84,
 DC_DP_INFOFRAME_TYPE_PPS = 0x10,
};

struct dc_info_packet {
 bool valid;
 uint8_t hb0;
 uint8_t hb1;
 uint8_t hb2;
 uint8_t hb3;
 uint8_t sb[32];
};

struct dc_info_packet_128 {
 bool valid;
 uint8_t hb0;
 uint8_t hb1;
 uint8_t hb2;
 uint8_t hb3;
 uint8_t sb[128];
};



struct dc_plane_flip_time {
 unsigned int time_elapsed_in_us[10];
 unsigned int index;
 unsigned int prev_update_time_in_us;
};

struct psr_config {
 unsigned char psr_version;
 unsigned int psr_rfb_setup_time;
 bool psr_exit_link_training_required;
 bool psr_frame_capture_indication_req;
 unsigned int psr_sdp_transmit_line_num_deadline;
 bool allow_smu_optimizations;
};

union dmcu_psr_level {
 struct {
  unsigned int SKIP_CRC:1;
  unsigned int SKIP_DP_VID_STREAM_DISABLE:1;
  unsigned int SKIP_PHY_POWER_DOWN:1;
  unsigned int SKIP_AUX_ACK_CHECK:1;
  unsigned int SKIP_CRTC_DISABLE:1;
  unsigned int SKIP_AUX_RFB_CAPTURE_CHECK:1;
  unsigned int SKIP_SMU_NOTIFICATION:1;
  unsigned int SKIP_AUTO_STATE_ADVANCE:1;
  unsigned int DISABLE_PSR_ENTRY_ABORT:1;
  unsigned int SKIP_SINGLE_OTG_DISABLE:1;
  unsigned int RESERVED:22;
 } bits;
 unsigned int u32all;
};

enum physical_phy_id {
 PHYLD_0,
 PHYLD_1,
 PHYLD_2,
 PHYLD_3,
 PHYLD_4,
 PHYLD_5,
 PHYLD_6,
 PHYLD_7,
 PHYLD_8,
 PHYLD_9,
 PHYLD_COUNT,
 PHYLD_UNKNOWN = (-1L)
};

enum phy_type {
 PHY_TYPE_UNKNOWN = 1,
 PHY_TYPE_PCIE_PHY = 2,
 PHY_TYPE_UNIPHY = 3,
};

struct psr_context {

 enum channel_id channel;

 enum transmitter transmitterId;

 enum engine_id engineId;

 enum controller_id controllerId;

 enum phy_type phyType;

 enum physical_phy_id smuPhyId;





 unsigned int crtcTimingVerticalTotal;



 bool psrSupportedDisplayConfig;

 bool psrExitLinkTrainingRequired;






 bool psrFrameCaptureIndicationReq;



 unsigned int sdpTransmitLineNumDeadline;



 unsigned int vsync_rate_hz;
 unsigned int skipPsrWaitForPllLock;
 unsigned int numberOfControllers;




 bool rfb_update_auto_en;

 unsigned int timehyst_frames;

 unsigned int hyst_lines;



 unsigned int aux_repeats;

 union dmcu_psr_level psr_level;



 unsigned int frame_delay;
 bool allow_smu_optimizations;
};

struct colorspace_transform {
 struct fixed31_32 matrix[12];
 bool enable_remap;
};

enum i2c_mot_mode {
 I2C_MOT_UNDEF,
 I2C_MOT_TRUE,
 I2C_MOT_FALSE
};

struct AsicStateEx {
 unsigned int memoryClock;
 unsigned int displayClock;
 unsigned int engineClock;
 unsigned int maxSupportedDppClock;
 unsigned int dppClock;
 unsigned int socClock;
 unsigned int dcfClockDeepSleep;
 unsigned int fClock;
 unsigned int phyClock;
};


enum dc_clock_type {
 DC_CLOCK_TYPE_DISPCLK = 0,
 DC_CLOCK_TYPE_DPPCLK = 1,
};

struct dc_clock_config {
 uint32_t max_clock_khz;
 uint32_t min_clock_khz;
 uint32_t bw_requirequired_clock_khz;
 uint32_t current_clock_khz;
};


union dsc_slice_caps1 {
 struct {
  uint8_t NUM_SLICES_1 : 1;
  uint8_t NUM_SLICES_2 : 1;
  uint8_t RESERVED : 1;
  uint8_t NUM_SLICES_4 : 1;
  uint8_t NUM_SLICES_6 : 1;
  uint8_t NUM_SLICES_8 : 1;
  uint8_t NUM_SLICES_10 : 1;
  uint8_t NUM_SLICES_12 : 1;
 } bits;
 uint8_t raw;
};

union dsc_slice_caps2 {
 struct {
  uint8_t NUM_SLICES_16 : 1;
  uint8_t NUM_SLICES_20 : 1;
  uint8_t NUM_SLICES_24 : 1;
  uint8_t RESERVED : 5;
 } bits;
 uint8_t raw;
};

union dsc_color_formats {
 struct {
  uint8_t RGB : 1;
  uint8_t YCBCR_444 : 1;
  uint8_t YCBCR_SIMPLE_422 : 1;
  uint8_t YCBCR_NATIVE_422 : 1;
  uint8_t YCBCR_NATIVE_420 : 1;
  uint8_t RESERVED : 3;
 } bits;
 uint8_t raw;
};

union dsc_color_depth {
 struct {
  uint8_t RESERVED1 : 1;
  uint8_t COLOR_DEPTH_8_BPC : 1;
  uint8_t COLOR_DEPTH_10_BPC : 1;
  uint8_t COLOR_DEPTH_12_BPC : 1;
  uint8_t RESERVED2 : 3;
 } bits;
 uint8_t raw;
};

struct dsc_dec_dpcd_caps {
 bool is_dsc_supported;
 uint8_t dsc_version;
 int32_t rc_buffer_size;
 union dsc_slice_caps1 slice_caps1;
 union dsc_slice_caps2 slice_caps2;
 int32_t lb_bit_depth;
 bool is_block_pred_supported;
 int32_t edp_max_bits_per_pixel;
 union dsc_color_formats color_formats;
 union dsc_color_depth color_depth;
 int32_t throughput_mode_0_mps;
 int32_t throughput_mode_1_mps;
 int32_t max_slice_width;
 uint32_t bpp_increment_div;


 uint32_t branch_overall_throughput_0_mps;
 uint32_t branch_overall_throughput_1_mps;
 uint32_t branch_max_line_width;
};
# 899 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dc_types.h"
enum dc_psr_version {
 DC_PSR_VERSION_1 = 0,
 DC_PSR_VERSION_UNSUPPORTED = 0xFFFFFFFF,
};
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services_types.h" 2

struct pp_smu_funcs;

struct dm_pp_clock_range {
 int min_khz;
 int max_khz;
};

enum dm_pp_clocks_state {
 DM_PP_CLOCKS_STATE_INVALID,
 DM_PP_CLOCKS_STATE_ULTRA_LOW,
 DM_PP_CLOCKS_STATE_LOW,
 DM_PP_CLOCKS_STATE_NOMINAL,
 DM_PP_CLOCKS_STATE_PERFORMANCE,


 DM_PP_CLOCKS_DPM_STATE_LEVEL_INVALID = DM_PP_CLOCKS_STATE_INVALID,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_0,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_1,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_2,

 DM_PP_CLOCKS_DPM_STATE_LEVEL_3,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_4,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_5,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_6,
 DM_PP_CLOCKS_DPM_STATE_LEVEL_7,

 DM_PP_CLOCKS_MAX_STATES
};

struct dm_pp_gpu_clock_range {
 enum dm_pp_clocks_state clock_state;
 struct dm_pp_clock_range sclk;
 struct dm_pp_clock_range mclk;
 struct dm_pp_clock_range eclk;
 struct dm_pp_clock_range dclk;
};

enum dm_pp_clock_type {
 DM_PP_CLOCK_TYPE_DISPLAY_CLK = 1,
 DM_PP_CLOCK_TYPE_ENGINE_CLK,
 DM_PP_CLOCK_TYPE_MEMORY_CLK,
 DM_PP_CLOCK_TYPE_DCFCLK,
 DM_PP_CLOCK_TYPE_DCEFCLK,
 DM_PP_CLOCK_TYPE_SOCCLK,
 DM_PP_CLOCK_TYPE_PIXELCLK,
 DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
 DM_PP_CLOCK_TYPE_DPPCLK,
 DM_PP_CLOCK_TYPE_FCLK,
};
# 97 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services_types.h"
struct dm_pp_clock_levels {
 uint32_t num_levels;
 uint32_t clocks_in_khz[16];
};

struct dm_pp_clock_with_latency {
 uint32_t clocks_in_khz;
 uint32_t latency_in_us;
};

struct dm_pp_clock_levels_with_latency {
 uint32_t num_levels;
 struct dm_pp_clock_with_latency data[16];
};

struct dm_pp_clock_with_voltage {
 uint32_t clocks_in_khz;
 uint32_t voltage_in_mv;
};

struct dm_pp_clock_levels_with_voltage {
 uint32_t num_levels;
 struct dm_pp_clock_with_voltage data[16];
};

struct dm_pp_single_disp_config {
 enum signal_type signal;
 uint8_t transmitter;
 uint8_t ddi_channel_mapping;
 uint8_t pipe_idx;
 uint32_t src_height;
 uint32_t src_width;
 uint32_t v_refresh;
 uint32_t sym_clock;
 struct dc_link_settings link_settings;
};



enum dm_pp_wm_set_id {
 WM_SET_A = 0,
 WM_SET_B,
 WM_SET_C,
 WM_SET_D,
 WM_SET_INVALID = 0xffff,
};

struct dm_pp_clock_range_for_wm_set {
 enum dm_pp_wm_set_id wm_set_id;
 uint32_t wm_min_eng_clk_in_khz;
 uint32_t wm_max_eng_clk_in_khz;
 uint32_t wm_min_mem_clk_in_khz;
 uint32_t wm_max_mem_clk_in_khz;
};

struct dm_pp_wm_sets_with_clock_ranges {
 uint32_t num_wm_sets;
 struct dm_pp_clock_range_for_wm_set wm_clk_ranges[4];
};

struct dm_pp_clock_range_for_dmif_wm_set_soc15 {
 enum dm_pp_wm_set_id wm_set_id;
 uint32_t wm_min_dcfclk_clk_in_khz;
 uint32_t wm_max_dcfclk_clk_in_khz;
 uint32_t wm_min_mem_clk_in_khz;
 uint32_t wm_max_mem_clk_in_khz;
};

struct dm_pp_clock_range_for_mcif_wm_set_soc15 {
 enum dm_pp_wm_set_id wm_set_id;
 uint32_t wm_min_socclk_clk_in_khz;
 uint32_t wm_max_socclk_clk_in_khz;
 uint32_t wm_min_mem_clk_in_khz;
 uint32_t wm_max_mem_clk_in_khz;
};

struct dm_pp_wm_sets_with_clock_ranges_soc15 {
 uint32_t num_wm_dmif_sets;
 uint32_t num_wm_mcif_sets;
 struct dm_pp_clock_range_for_dmif_wm_set_soc15
  wm_dmif_clocks_ranges[4];
 struct dm_pp_clock_range_for_mcif_wm_set_soc15
  wm_mcif_clocks_ranges[4];
};



struct dm_pp_display_configuration {
 bool nb_pstate_switch_disable;
 bool cpu_cc6_disable;
 bool cpu_pstate_disable;
 uint32_t cpu_pstate_separation_time;

 uint32_t min_memory_clock_khz;
 uint32_t min_engine_clock_khz;
 uint32_t min_engine_clock_deep_sleep_khz;

 uint32_t avail_mclk_switch_time_us;
 uint32_t avail_mclk_switch_time_in_disp_active_us;
 uint32_t min_dcfclock_khz;
 uint32_t min_dcfc_deep_sleep_clock_khz;

 uint32_t disp_clk_khz;

 bool all_displays_in_sync;

 uint8_t display_count;
 struct dm_pp_single_disp_config disp_configs[6];



 uint8_t crtc_index;

 uint32_t line_time_in_us;
};

struct dm_bl_data_point {

  uint8_t luminance;



  uint8_t signal_level;
};



struct dm_acpi_atif_backlight_caps {
 uint16_t size;
 uint16_t flags;
 uint8_t error_code;
 uint8_t ac_level_percentage;
 uint8_t dc_level_percentage;
 uint8_t min_input_signal;
 uint8_t max_input_signal;
 uint8_t num_data_points;
 struct dm_bl_data_point data_points[99];
};

enum dm_acpi_display_type {
 AcpiDisplayType_LCD1 = 0,
 AcpiDisplayType_CRT1 = 1,
 AcpiDisplayType_DFP1 = 3,
 AcpiDisplayType_CRT2 = 4,
 AcpiDisplayType_LCD2 = 5,
 AcpiDisplayType_DFP2 = 7,
 AcpiDisplayType_DFP3 = 9,
 AcpiDisplayType_DFP4 = 10,
 AcpiDisplayType_DFP5 = 11,
 AcpiDisplayType_DFP6 = 12
};

struct dm_pp_power_level_change_request {
 enum dm_pp_clocks_state power_level;
};

struct dm_pp_clock_for_voltage_req {
 enum dm_pp_clock_type clk_type;
 uint32_t clocks_in_khz;
};

struct dm_pp_static_clock_info {
 uint32_t max_sclk_khz;
 uint32_t max_mclk_khz;


 enum dm_pp_clocks_state max_clocks_state;
};

struct dtn_min_clk_info {
 uint32_t disp_clk_khz;
 uint32_t min_engine_clock_khz;
 uint32_t min_memory_clock_khz;
};
# 38 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/logger_interface.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/logger_interface.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/logger_types.h" 1
# 72 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/logger_types.h"
struct dal_logger;

struct dc_log_buffer_ctx {
 char *buf;
 size_t pos;
 size_t size;
};

enum dc_log_type {
 LOG_ERROR = 0,
 LOG_WARNING,
 LOG_DEBUG,
 LOG_DC,
 LOG_DTN,
 LOG_SURFACE,
 LOG_HW_HOTPLUG,
 LOG_HW_LINK_TRAINING,
 LOG_HW_SET_MODE,
 LOG_HW_RESUME_S3,
 LOG_HW_AUDIO,
 LOG_HW_HPD_IRQ,
 LOG_MST,
 LOG_SCALER,
 LOG_BIOS,
 LOG_BANDWIDTH_CALCS,
 LOG_BANDWIDTH_VALIDATION,
 LOG_I2C_AUX,
 LOG_SYNC,
 LOG_BACKLIGHT,
 LOG_FEATURE_OVERRIDE,
 LOG_DETECTION_EDID_PARSER,
 LOG_DETECTION_DP_CAPS,
 LOG_RESOURCE,
 LOG_DML,
 LOG_EVENT_MODE_SET,
 LOG_EVENT_DETECTION,
 LOG_EVENT_LINK_TRAINING,
 LOG_EVENT_LINK_LOSS,
 LOG_EVENT_UNDERFLOW,
 LOG_IF_TRACE,
 LOG_PERF_TRACE,
 LOG_DISPLAYSTATS,
 LOG_HDMI_RETIMER_REDRIVER,
 LOG_DSC,
 LOG_DWB,
 LOG_GAMMA_DEBUG,
 LOG_MAX_HW_POINTS,
 LOG_ALL_TF_CHANNELS,
 LOG_SAMPLE_1DLUT,
 LOG_SECTION_TOTAL_COUNT
};
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/logger_interface.h" 2

struct dc_context;
struct dc_link;
struct dc_surface_update;
struct resource_context;
struct dc_state;







void pre_surface_trace(
  struct dc *dc,
  const struct dc_plane_state *const *plane_states,
  int surface_count);

void update_surface_trace(
  struct dc *dc,
  const struct dc_surface_update *updates,
  int surface_count);

void post_surface_trace(struct dc *dc);

void context_timing_trace(
  struct dc *dc,
  struct resource_context *res_ctx);

void context_clock_trace(
  struct dc *dc,
  struct dc_state *context);
# 39 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/link_service_types.h" 1
# 34 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/link_service_types.h"
struct ddc;
struct irq_manager;

enum {
 MAX_CONTROLLER_NUM = 6
};

enum dp_power_state {
 DP_POWER_STATE_D0 = 1,
 DP_POWER_STATE_D3
};

enum edp_revision {

 EDP_REVISION_11 = 0x00,

 EDP_REVISION_12 = 0x01,

 EDP_REVISION_13 = 0x02
};

enum {
 LINK_RATE_REF_FREQ_IN_KHZ = 27000
};

enum link_training_result {
 LINK_TRAINING_SUCCESS,
 LINK_TRAINING_CR_FAIL_LANE0,
 LINK_TRAINING_CR_FAIL_LANE1,
 LINK_TRAINING_CR_FAIL_LANE23,

 LINK_TRAINING_EQ_FAIL_CR,

 LINK_TRAINING_EQ_FAIL_EQ,
 LINK_TRAINING_LQA_FAIL,
};

struct link_training_settings {
 struct dc_link_settings link_settings;
 struct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX];

 enum dc_voltage_swing *voltage_swing;
 enum dc_pre_emphasis *pre_emphasis;
 enum dc_post_cursor2 *post_cursor2;

 uint16_t cr_pattern_time;
 uint16_t eq_pattern_time;
 enum dc_dp_training_pattern pattern_for_eq;

 bool enhanced_framing;
 bool allow_invalid_msa_timing_param;
};



enum dp_test_pattern {


 DP_TEST_PATTERN_VIDEO_MODE = 0,


 DP_TEST_PATTERN_PHY_PATTERN_BEGIN,
 DP_TEST_PATTERN_D102 = DP_TEST_PATTERN_PHY_PATTERN_BEGIN,
 DP_TEST_PATTERN_SYMBOL_ERROR,
 DP_TEST_PATTERN_PRBS7,
 DP_TEST_PATTERN_80BIT_CUSTOM,
 DP_TEST_PATTERN_CP2520_1,
 DP_TEST_PATTERN_CP2520_2,
 DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE = DP_TEST_PATTERN_CP2520_2,
 DP_TEST_PATTERN_CP2520_3,


 DP_TEST_PATTERN_TRAINING_PATTERN1,
 DP_TEST_PATTERN_TRAINING_PATTERN2,
 DP_TEST_PATTERN_TRAINING_PATTERN3,
 DP_TEST_PATTERN_TRAINING_PATTERN4,
 DP_TEST_PATTERN_PHY_PATTERN_END = DP_TEST_PATTERN_TRAINING_PATTERN4,


 DP_TEST_PATTERN_COLOR_SQUARES,
 DP_TEST_PATTERN_COLOR_SQUARES_CEA,
 DP_TEST_PATTERN_VERTICAL_BARS,
 DP_TEST_PATTERN_HORIZONTAL_BARS,
 DP_TEST_PATTERN_COLOR_RAMP,


 DP_TEST_PATTERN_AUDIO_OPERATOR_DEFINED,
 DP_TEST_PATTERN_AUDIO_SAWTOOTH,

 DP_TEST_PATTERN_UNSUPPORTED
};

enum dp_test_pattern_color_space {
 DP_TEST_PATTERN_COLOR_SPACE_RGB,
 DP_TEST_PATTERN_COLOR_SPACE_YCBCR601,
 DP_TEST_PATTERN_COLOR_SPACE_YCBCR709,
 DP_TEST_PATTERN_COLOR_SPACE_UNDEFINED
};

enum dp_panel_mode {

 DP_PANEL_MODE_DEFAULT,

 DP_PANEL_MODE_EDP,

 DP_PANEL_MODE_SPECIAL
};


union dpcd_training_lane_set {
 struct {

  uint8_t VOLTAGE_SWING_SET:2;
  uint8_t MAX_SWING_REACHED:1;
  uint8_t PRE_EMPHASIS_SET:2;
  uint8_t MAX_PRE_EMPHASIS_REACHED:1;

  uint8_t POST_CURSOR2_SET:2;
# 161 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/include/link_service_types.h"
 } bits;

 uint8_t raw;
};



struct dp_mst_stream_allocation {
 uint8_t vcp_id;


 uint8_t slot_count;
};


struct dp_mst_stream_allocation_table {

 int stream_count;

 struct dp_mst_stream_allocation stream_allocations[MAX_CONTROLLER_NUM];
};
# 40 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h" 2



struct dmub_srv;
struct dc_dmub_srv;

irq_handler_idx dm_register_interrupt(
 struct dc_context *ctx,
 struct dc_interrupt_params *int_params,
 interrupt_handler ih,
 void *handler_args);







uint32_t dm_read_reg_func(
 const struct dc_context *ctx,
 uint32_t address,
 const char *func_name);
# 73 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dm_write_reg_func(
 const struct dc_context *ctx,
 uint32_t address,
 uint32_t value,
 const char *func_name)
{






 (((struct cgs_device *)ctx->cgs_device)->ops->write_register(ctx->cgs_device,address,value));
 trace_amdgpu_dc_wreg(&ctx->perf_trace->write_count, address, value);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uint32_t dm_read_index_reg(
 const struct dc_context *ctx,
 enum cgs_ind_reg addr_space,
 uint32_t index)
{
 return (((struct cgs_device *)ctx->cgs_device)->ops->read_ind_register(ctx->cgs_device,addr_space,index));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dm_write_index_reg(
 const struct dc_context *ctx,
 enum cgs_ind_reg addr_space,
 uint32_t index,
 uint32_t value)
{
 (((struct cgs_device *)ctx->cgs_device)->ops->write_ind_register(ctx->cgs_device,addr_space,index,value));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uint32_t get_reg_field_value_ex(
 uint32_t reg_value,
 uint32_t mask,
 uint8_t shift)
{
 return (mask & reg_value) >> shift;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uint32_t set_reg_field_value_ex(
 uint32_t reg_value,
 uint32_t value,
 uint32_t mask,
 uint8_t shift)
{
 ({ int __ret_warn_on = !!(!(mask != 0)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"), "i" (126), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return (reg_value & ~mask) | (mask & (value << shift));
}
# 137 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
uint32_t generic_reg_set_ex(const struct dc_context *ctx,
  uint32_t addr, uint32_t reg_val, int n,
  uint8_t shift1, uint32_t mask1, uint32_t field_value1, ...);

uint32_t generic_reg_update_ex(const struct dc_context *ctx,
  uint32_t addr, int n,
  uint8_t shift1, uint32_t mask1, uint32_t field_value1, ...);

struct dc_dmub_srv *dc_dmub_srv_create(struct dc *dc, struct dmub_srv *dmub);
void dc_dmub_srv_destroy(struct dc_dmub_srv **dmub_srv);

void reg_sequence_start_gather(const struct dc_context *ctx);
void reg_sequence_start_execute(const struct dc_context *ctx);
void reg_sequence_wait_done(const struct dc_context *ctx);
# 159 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
void generic_reg_wait(const struct dc_context *ctx,
 uint32_t addr, uint32_t mask, uint32_t shift, uint32_t condition_value,
 unsigned int delay_between_poll_us, unsigned int time_out_num_tries,
 const char *func_name, int line);

unsigned int snprintf_count(char *pBuf, unsigned int bufSize, char *fmt, ...);
# 208 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
bool dm_pp_get_clock_levels_by_type(
 const struct dc_context *ctx,
 enum dm_pp_clock_type clk_type,
 struct dm_pp_clock_levels *clk_level_info);

bool dm_pp_get_clock_levels_by_type_with_latency(
 const struct dc_context *ctx,
 enum dm_pp_clock_type clk_type,
 struct dm_pp_clock_levels_with_latency *clk_level_info);

bool dm_pp_get_clock_levels_by_type_with_voltage(
 const struct dc_context *ctx,
 enum dm_pp_clock_type clk_type,
 struct dm_pp_clock_levels_with_voltage *clk_level_info);

bool dm_pp_notify_wm_clock_changes(
 const struct dc_context *ctx,
 struct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges);

void dm_pp_get_funcs(struct dc_context *ctx,
  struct pp_smu_funcs *funcs);
# 241 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
bool dm_pp_apply_display_requirements(
 const struct dc_context *ctx,
 const struct dm_pp_display_configuration *pp_display_cfg);

bool dm_pp_apply_power_level_change_request(
 const struct dc_context *ctx,
 struct dm_pp_power_level_change_request *level_change_req);

bool dm_pp_apply_clock_for_voltage_request(
 const struct dc_context *ctx,
 struct dm_pp_clock_for_voltage_req *clock_for_voltage_req);

bool dm_pp_get_static_clocks(
 const struct dc_context *ctx,
 struct dm_pp_static_clock_info *static_clk_info);



struct persistent_data_flag {
 bool save_per_link;
 bool save_per_edid;
};

bool dm_query_extended_brightness_caps
 (struct dc_context *ctx, enum dm_acpi_display_type display,
   struct dm_acpi_atif_backlight_caps *pCaps);

bool dm_dmcu_set_pipe(struct dc_context *ctx, unsigned int controller_id);
# 278 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long long dm_get_timestamp(struct dc_context *ctx)
{
 return ktime_get_raw_ns();
}

unsigned long long dm_get_elapse_time_in_ns(struct dc_context *ctx,
  unsigned long long current_time_stamp,
  unsigned long long last_time_stamp);
# 302 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dm_services.h"
void dm_dtn_log_begin(struct dc_context *ctx,
 struct dc_log_buffer_ctx *log_ctx);
void dm_dtn_log_append_v(struct dc_context *ctx,
 struct dc_log_buffer_ctx *log_ctx,
 const char *msg, ...);
void dm_dtn_log_end(struct dc_context *ctx,
 struct dc_log_buffer_ctx *log_ctx);
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dc_features.h" 1
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_structs.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_structs.h"
typedef struct _vcs_dpi_voltage_scaling_st voltage_scaling_st;
typedef struct _vcs_dpi_soc_bounding_box_st soc_bounding_box_st;
typedef struct _vcs_dpi_ip_params_st ip_params_st;
typedef struct _vcs_dpi_display_pipe_source_params_st display_pipe_source_params_st;
typedef struct _vcs_dpi_display_output_params_st display_output_params_st;
typedef struct _vcs_dpi_scaler_ratio_depth_st scaler_ratio_depth_st;
typedef struct _vcs_dpi_scaler_taps_st scaler_taps_st;
typedef struct _vcs_dpi_display_pipe_dest_params_st display_pipe_dest_params_st;
typedef struct _vcs_dpi_display_pipe_params_st display_pipe_params_st;
typedef struct _vcs_dpi_display_clocks_and_cfg_st display_clocks_and_cfg_st;
typedef struct _vcs_dpi_display_e2e_pipe_params_st display_e2e_pipe_params_st;
typedef struct _vcs_dpi_display_data_rq_misc_params_st display_data_rq_misc_params_st;
typedef struct _vcs_dpi_display_data_rq_sizing_params_st display_data_rq_sizing_params_st;
typedef struct _vcs_dpi_display_data_rq_dlg_params_st display_data_rq_dlg_params_st;
typedef struct _vcs_dpi_display_rq_dlg_params_st display_rq_dlg_params_st;
typedef struct _vcs_dpi_display_rq_sizing_params_st display_rq_sizing_params_st;
typedef struct _vcs_dpi_display_rq_misc_params_st display_rq_misc_params_st;
typedef struct _vcs_dpi_display_rq_params_st display_rq_params_st;
typedef struct _vcs_dpi_display_dlg_regs_st display_dlg_regs_st;
typedef struct _vcs_dpi_display_ttu_regs_st display_ttu_regs_st;
typedef struct _vcs_dpi_display_data_rq_regs_st display_data_rq_regs_st;
typedef struct _vcs_dpi_display_rq_regs_st display_rq_regs_st;
typedef struct _vcs_dpi_display_dlg_sys_params_st display_dlg_sys_params_st;
typedef struct _vcs_dpi_display_arb_params_st display_arb_params_st;

struct _vcs_dpi_voltage_scaling_st {
 int state;
 double dscclk_mhz;
 double dcfclk_mhz;
 double socclk_mhz;
 double phyclk_d18_mhz;
 double dram_speed_mts;
 double fabricclk_mhz;
 double dispclk_mhz;
 double dram_bw_per_chan_gbps;
 double phyclk_mhz;
 double dppclk_mhz;
 double dtbclk_mhz;
};

struct _vcs_dpi_soc_bounding_box_st {
 struct _vcs_dpi_voltage_scaling_st clock_limits[9];
 unsigned int num_states;
 double sr_exit_time_us;
 double sr_enter_plus_exit_time_us;
 double urgent_latency_us;
 double urgent_latency_pixel_data_only_us;
 double urgent_latency_pixel_mixed_with_vm_data_us;
 double urgent_latency_vm_data_only_us;
 double writeback_latency_us;
 double ideal_dram_bw_after_urgent_percent;
 double pct_ideal_dram_sdp_bw_after_urgent_pixel_only;
 double pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm;
 double pct_ideal_dram_sdp_bw_after_urgent_vm_only;
 double pct_ideal_sdp_bw_after_urgent;
 double max_avg_sdp_bw_use_normal_percent;
 double max_avg_dram_bw_use_normal_percent;
 unsigned int max_request_size_bytes;
 double downspread_percent;
 double dram_page_open_time_ns;
 double dram_rw_turnaround_time_ns;
 double dram_return_buffer_per_channel_bytes;
 double dram_channel_width_bytes;
 double fabric_datapath_to_dcn_data_return_bytes;
 double dcn_downspread_percent;
 double dispclk_dppclk_vco_speed_mhz;
 double dfs_vco_period_ps;
 unsigned int urgent_out_of_order_return_per_channel_pixel_only_bytes;
 unsigned int urgent_out_of_order_return_per_channel_pixel_and_vm_bytes;
 unsigned int urgent_out_of_order_return_per_channel_vm_only_bytes;
 unsigned int round_trip_ping_latency_dcfclk_cycles;
 unsigned int urgent_out_of_order_return_per_channel_bytes;
 unsigned int channel_interleave_bytes;
 unsigned int num_banks;
 unsigned int num_chans;
 unsigned int vmm_page_size_bytes;
 unsigned int hostvm_min_page_size_bytes;
 unsigned int gpuvm_min_page_size_bytes;
 double dram_clock_change_latency_us;
 double dummy_pstate_latency_us;
 double writeback_dram_clock_change_latency_us;
 unsigned int return_bus_width_bytes;
 unsigned int voltage_override;
 double xfc_bus_transport_time_us;
 double xfc_xbuf_latency_tolerance_us;
 int use_urgent_burst_bw;
 double min_dcfclk;
 bool do_urgent_latency_adjustment;
 double urgent_latency_adjustment_fabric_clock_component_us;
 double urgent_latency_adjustment_fabric_clock_reference_mhz;
 bool disable_dram_clock_change_vactive_support;
 bool allow_dram_clock_one_display_vactive;
};

struct _vcs_dpi_ip_params_st {
 bool use_min_dcfclk;



 bool gpuvm_enable;
 bool hostvm_enable;
 bool dsc422_native_support;
 unsigned int gpuvm_max_page_table_levels;
 unsigned int hostvm_max_page_table_levels;
 unsigned int hostvm_cached_page_table_levels;
 unsigned int pte_group_size_bytes;
 unsigned int max_inter_dcn_tile_repeaters;
 unsigned int num_dsc;
 unsigned int odm_capable;
 unsigned int rob_buffer_size_kbytes;
 unsigned int det_buffer_size_kbytes;
 unsigned int dpte_buffer_size_in_pte_reqs_luma;
 unsigned int dpte_buffer_size_in_pte_reqs_chroma;
 unsigned int pde_proc_buffer_size_64k_reqs;
 unsigned int dpp_output_buffer_pixels;
 unsigned int opp_output_buffer_lines;
 unsigned int pixel_chunk_size_kbytes;
 unsigned char pte_enable;
 unsigned int pte_chunk_size_kbytes;
 unsigned int meta_chunk_size_kbytes;
 unsigned int min_meta_chunk_size_bytes;
 unsigned int writeback_chunk_size_kbytes;
 unsigned int line_buffer_size_bits;
 unsigned int max_line_buffer_lines;
 unsigned int writeback_luma_buffer_size_kbytes;
 unsigned int writeback_chroma_buffer_size_kbytes;
 unsigned int writeback_chroma_line_buffer_width_pixels;

 unsigned int writeback_interface_buffer_size_kbytes;
 unsigned int writeback_line_buffer_buffer_size;

 unsigned int writeback_10bpc420_supported;
 double writeback_max_hscl_ratio;
 double writeback_max_vscl_ratio;
 double writeback_min_hscl_ratio;
 double writeback_min_vscl_ratio;
 double maximum_dsc_bits_per_component;
 unsigned int writeback_max_hscl_taps;
 unsigned int writeback_max_vscl_taps;
 unsigned int writeback_line_buffer_luma_buffer_size;
 unsigned int writeback_line_buffer_chroma_buffer_size;

 unsigned int max_page_table_levels;
 unsigned int max_num_dpp;
 unsigned int max_num_otg;
 unsigned int cursor_chunk_size;
 unsigned int cursor_buffer_size;
 unsigned int max_num_wb;
 unsigned int max_dchub_pscl_bw_pix_per_clk;
 unsigned int max_pscl_lb_bw_pix_per_clk;
 unsigned int max_lb_vscl_bw_pix_per_clk;
 unsigned int max_vscl_hscl_bw_pix_per_clk;
 double max_hscl_ratio;
 double max_vscl_ratio;
 unsigned int hscl_mults;
 unsigned int vscl_mults;
 unsigned int max_hscl_taps;
 unsigned int max_vscl_taps;
 unsigned int xfc_supported;
 unsigned int ptoi_supported;
 unsigned int gfx7_compat_tiling_supported;

 bool odm_combine_4to1_supported;
 bool dynamic_metadata_vm_enabled;
 unsigned int max_num_hdmi_frl_outputs;

 unsigned int xfc_fill_constant_bytes;
 double dispclk_ramp_margin_percent;
 double xfc_fill_bw_overhead_percent;
 double underscan_factor;
 unsigned int min_vblank_lines;
 unsigned int dppclk_delay_subtotal;
 unsigned int dispclk_delay_subtotal;
 double dcfclk_cstate_latency;
 unsigned int dppclk_delay_scl;
 unsigned int dppclk_delay_scl_lb_only;
 unsigned int dppclk_delay_cnvc_formatter;
 unsigned int dppclk_delay_cnvc_cursor;
 unsigned int is_line_buffer_bpp_fixed;
 unsigned int line_buffer_fixed_bpp;
 unsigned int dcc_supported;

 unsigned int IsLineBufferBppFixed;
 unsigned int LineBufferFixedBpp;
 unsigned int can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one;
 unsigned int bug_forcing_LC_req_same_size_fixed;
 unsigned int number_of_cursors;
};

struct _vcs_dpi_display_xfc_params_st {
 double xfc_tslv_vready_offset_us;
 double xfc_tslv_vupdate_width_us;
 double xfc_tslv_vupdate_offset_us;
 int xfc_slv_chunk_size_bytes;
};

struct _vcs_dpi_display_pipe_source_params_st {
 int source_format;
 double dcc_fraction_of_zs_req_luma;
 double dcc_fraction_of_zs_req_chroma;
 unsigned char dcc;
 unsigned int dcc_rate;
 unsigned int dcc_rate_chroma;
 unsigned char dcc_use_global;
 unsigned char vm;
 bool unbounded_req_mode;
 bool gpuvm;
 bool hostvm;
 bool gpuvm_levels_force_en;
 unsigned int gpuvm_levels_force;
 bool hostvm_levels_force_en;
 unsigned int hostvm_levels_force;
 int source_scan;
 int sw_mode;
 int macro_tile_size;
 unsigned int surface_width_y;
 unsigned int surface_height_y;
 unsigned int surface_width_c;
 unsigned int surface_height_c;
 unsigned int viewport_width;
 unsigned int viewport_height;
 unsigned int viewport_y_y;
 unsigned int viewport_y_c;
 unsigned int viewport_width_c;
 unsigned int viewport_height_c;
 unsigned int data_pitch;
 unsigned int data_pitch_c;
 unsigned int meta_pitch;
 unsigned int meta_pitch_c;
 unsigned int cur0_src_width;
 int cur0_bpp;
 unsigned int cur1_src_width;
 int cur1_bpp;
 int num_cursors;
 unsigned char is_hsplit;
 unsigned char dynamic_metadata_enable;
 unsigned int dynamic_metadata_lines_before_active;
 unsigned int dynamic_metadata_xmit_bytes;
 unsigned int hsplit_grp;
 unsigned char xfc_enable;
 unsigned char xfc_slave;
 unsigned char immediate_flip;
 struct _vcs_dpi_display_xfc_params_st xfc_params;

 unsigned char v_total_min;
 unsigned char v_total_max;
};
struct writeback_st {
 int wb_src_height;
 int wb_src_width;
 int wb_dst_width;
 int wb_dst_height;
 int wb_pixel_format;
 int wb_htaps_luma;
 int wb_vtaps_luma;
 int wb_htaps_chroma;
 int wb_vtaps_chroma;
 double wb_hratio;
 double wb_vratio;
};

struct _vcs_dpi_display_output_params_st {
 int dp_lanes;
 double output_bpp;
 int dsc_enable;
 int wb_enable;
 int num_active_wb;
 int output_bpc;
 int output_type;
 int output_format;
 int dsc_slices;
 int max_audio_sample_rate;
 struct writeback_st wb;
};

struct _vcs_dpi_scaler_ratio_depth_st {
 double hscl_ratio;
 double vscl_ratio;
 double hscl_ratio_c;
 double vscl_ratio_c;
 double vinit;
 double vinit_c;
 double vinit_bot;
 double vinit_bot_c;
 int lb_depth;
 int scl_enable;
};

struct _vcs_dpi_scaler_taps_st {
 unsigned int htaps;
 unsigned int vtaps;
 unsigned int htaps_c;
 unsigned int vtaps_c;
};

struct _vcs_dpi_display_pipe_dest_params_st {
 unsigned int recout_width;
 unsigned int recout_height;
 unsigned int full_recout_width;
 unsigned int full_recout_height;
 unsigned int hblank_start;
 unsigned int hblank_end;
 unsigned int vblank_start;
 unsigned int vblank_end;
 unsigned int htotal;
 unsigned int vtotal;
 unsigned int refresh_rate;
 unsigned int vfront_porch;
 unsigned int vactive;
 unsigned int hactive;
 unsigned int vstartup_start;
 unsigned int vupdate_offset;
 unsigned int vupdate_width;
 unsigned int vready_offset;
 unsigned char interlaced;
 double pixel_rate_mhz;
 unsigned char synchronized_vblank_all_planes;
 unsigned char synchronize_timing_if_single_refresh_rate;
 unsigned char otg_inst;
 unsigned int odm_combine;
 unsigned char use_maximum_vstartup;
 unsigned int vtotal_max;
 unsigned int vtotal_min;
};

struct _vcs_dpi_display_pipe_params_st {
 display_pipe_source_params_st src;
 display_pipe_dest_params_st dest;
 scaler_ratio_depth_st scale_ratio_depth;
 scaler_taps_st scale_taps;
};

struct _vcs_dpi_display_clocks_and_cfg_st {
 int voltage;
 double dppclk_mhz;
 double refclk_mhz;
 double dispclk_mhz;
 double dcfclk_mhz;
 double socclk_mhz;
};

struct _vcs_dpi_display_e2e_pipe_params_st {
 display_pipe_params_st pipe;
 display_output_params_st dout;
 display_clocks_and_cfg_st clks_cfg;
};

struct _vcs_dpi_display_data_rq_misc_params_st {
 unsigned int full_swath_bytes;
 unsigned int stored_swath_bytes;
 unsigned int blk256_height;
 unsigned int blk256_width;
 unsigned int req_height;
 unsigned int req_width;
};

struct _vcs_dpi_display_data_rq_sizing_params_st {
 unsigned int chunk_bytes;
 unsigned int min_chunk_bytes;
 unsigned int meta_chunk_bytes;
 unsigned int min_meta_chunk_bytes;
 unsigned int mpte_group_bytes;
 unsigned int dpte_group_bytes;
};

struct _vcs_dpi_display_data_rq_dlg_params_st {
 unsigned int swath_width_ub;
 unsigned int swath_height;
 unsigned int req_per_swath_ub;
 unsigned int meta_pte_bytes_per_frame_ub;
 unsigned int dpte_req_per_row_ub;
 unsigned int dpte_groups_per_row_ub;
 unsigned int dpte_row_height;
 unsigned int dpte_bytes_per_row_ub;
 unsigned int meta_chunks_per_row_ub;
 unsigned int meta_req_per_row_ub;
 unsigned int meta_row_height;
 unsigned int meta_bytes_per_row_ub;
};

struct _vcs_dpi_display_rq_dlg_params_st {
 display_data_rq_dlg_params_st rq_l;
 display_data_rq_dlg_params_st rq_c;
};

struct _vcs_dpi_display_rq_sizing_params_st {
 display_data_rq_sizing_params_st rq_l;
 display_data_rq_sizing_params_st rq_c;
};

struct _vcs_dpi_display_rq_misc_params_st {
 display_data_rq_misc_params_st rq_l;
 display_data_rq_misc_params_st rq_c;
};

struct _vcs_dpi_display_rq_params_st {
 unsigned char yuv420;
 unsigned char yuv420_10bpc;
 unsigned char rgbe_alpha;
 display_rq_misc_params_st misc;
 display_rq_sizing_params_st sizing;
 display_rq_dlg_params_st dlg;
};

struct _vcs_dpi_display_dlg_regs_st {
 unsigned int refcyc_h_blank_end;
 unsigned int dlg_vblank_end;
 unsigned int min_dst_y_next_start;
 unsigned int refcyc_per_htotal;
 unsigned int refcyc_x_after_scaler;
 unsigned int dst_y_after_scaler;
 unsigned int dst_y_prefetch;
 unsigned int dst_y_per_vm_vblank;
 unsigned int dst_y_per_row_vblank;
 unsigned int dst_y_per_vm_flip;
 unsigned int dst_y_per_row_flip;
 unsigned int ref_freq_to_pix_freq;
 unsigned int vratio_prefetch;
 unsigned int vratio_prefetch_c;
 unsigned int refcyc_per_pte_group_vblank_l;
 unsigned int refcyc_per_pte_group_vblank_c;
 unsigned int refcyc_per_meta_chunk_vblank_l;
 unsigned int refcyc_per_meta_chunk_vblank_c;
 unsigned int refcyc_per_pte_group_flip_l;
 unsigned int refcyc_per_pte_group_flip_c;
 unsigned int refcyc_per_meta_chunk_flip_l;
 unsigned int refcyc_per_meta_chunk_flip_c;
 unsigned int dst_y_per_pte_row_nom_l;
 unsigned int dst_y_per_pte_row_nom_c;
 unsigned int refcyc_per_pte_group_nom_l;
 unsigned int refcyc_per_pte_group_nom_c;
 unsigned int dst_y_per_meta_row_nom_l;
 unsigned int dst_y_per_meta_row_nom_c;
 unsigned int refcyc_per_meta_chunk_nom_l;
 unsigned int refcyc_per_meta_chunk_nom_c;
 unsigned int refcyc_per_line_delivery_pre_l;
 unsigned int refcyc_per_line_delivery_pre_c;
 unsigned int refcyc_per_line_delivery_l;
 unsigned int refcyc_per_line_delivery_c;
 unsigned int chunk_hdl_adjust_cur0;
 unsigned int chunk_hdl_adjust_cur1;
 unsigned int vready_after_vcount0;
 unsigned int dst_y_offset_cur0;
 unsigned int dst_y_offset_cur1;
 unsigned int xfc_reg_transfer_delay;
 unsigned int xfc_reg_precharge_delay;
 unsigned int xfc_reg_remote_surface_flip_latency;
 unsigned int xfc_reg_prefetch_margin;
 unsigned int dst_y_delta_drq_limit;
 unsigned int refcyc_per_vm_group_vblank;
 unsigned int refcyc_per_vm_group_flip;
 unsigned int refcyc_per_vm_req_vblank;
 unsigned int refcyc_per_vm_req_flip;
 unsigned int refcyc_per_vm_dmdata;
 unsigned int dmdata_dl_delta;
};

struct _vcs_dpi_display_ttu_regs_st {
 unsigned int qos_level_low_wm;
 unsigned int qos_level_high_wm;
 unsigned int min_ttu_vblank;
 unsigned int qos_level_flip;
 unsigned int refcyc_per_req_delivery_l;
 unsigned int refcyc_per_req_delivery_c;
 unsigned int refcyc_per_req_delivery_cur0;
 unsigned int refcyc_per_req_delivery_cur1;
 unsigned int refcyc_per_req_delivery_pre_l;
 unsigned int refcyc_per_req_delivery_pre_c;
 unsigned int refcyc_per_req_delivery_pre_cur0;
 unsigned int refcyc_per_req_delivery_pre_cur1;
 unsigned int qos_level_fixed_l;
 unsigned int qos_level_fixed_c;
 unsigned int qos_level_fixed_cur0;
 unsigned int qos_level_fixed_cur1;
 unsigned int qos_ramp_disable_l;
 unsigned int qos_ramp_disable_c;
 unsigned int qos_ramp_disable_cur0;
 unsigned int qos_ramp_disable_cur1;
};

struct _vcs_dpi_display_data_rq_regs_st {
 unsigned int chunk_size;
 unsigned int min_chunk_size;
 unsigned int meta_chunk_size;
 unsigned int min_meta_chunk_size;
 unsigned int dpte_group_size;
 unsigned int mpte_group_size;
 unsigned int swath_height;
 unsigned int pte_row_height_linear;
};

struct _vcs_dpi_display_rq_regs_st {
 display_data_rq_regs_st rq_regs_l;
 display_data_rq_regs_st rq_regs_c;
 unsigned int drq_expansion_mode;
 unsigned int prq_expansion_mode;
 unsigned int mrq_expansion_mode;
 unsigned int crq_expansion_mode;
 unsigned int plane1_base_address;
};

struct _vcs_dpi_display_dlg_sys_params_st {
 double t_mclk_wm_us;
 double t_urg_wm_us;
 double t_sr_wm_us;
 double t_extra_us;
 double mem_trip_us;
 double t_srx_delay_us;
 double deepsleep_dcfclk_mhz;
 double total_flip_bw;
 unsigned int total_flip_bytes;
};

struct _vcs_dpi_display_arb_params_st {
 int max_req_outstanding;
 int min_req_outstanding;
 int sat_level_us;
};
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_enums.h" 1
# 28 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_enums.h"
enum output_encoder_class {
 dm_dp = 0, dm_hdmi = 1, dm_wb = 2, dm_edp
};
enum output_format_class {
 dm_444 = 0, dm_420 = 1, dm_n422, dm_s422
};
enum source_format_class {
 dm_444_16 = 0,
 dm_444_32 = 1,
 dm_444_64 = 2,
 dm_420_8 = 3,
 dm_420_10 = 4,
 dm_420_12 = 5,
 dm_422_8 = 6,
 dm_422_10 = 7,
 dm_444_8 = 8,
 dm_mono_8 = dm_444_8,
 dm_mono_16 = dm_444_16,
 dm_rgbe = 9,
 dm_rgbe_alpha = 10,
};
enum output_bpc_class {
 dm_out_6 = 0, dm_out_8 = 1, dm_out_10 = 2, dm_out_12 = 3, dm_out_16 = 4
};
enum scan_direction_class {
 dm_horz = 0, dm_vert = 1
};
enum dm_swizzle_mode {
 dm_sw_linear = 0,
 dm_sw_256b_s = 1,
 dm_sw_256b_d = 2,
 dm_sw_SPARE_0 = 3,
 dm_sw_SPARE_1 = 4,
 dm_sw_4kb_s = 5,
 dm_sw_4kb_d = 6,
 dm_sw_SPARE_2 = 7,
 dm_sw_SPARE_3 = 8,
 dm_sw_64kb_s = 9,
 dm_sw_64kb_d = 10,
 dm_sw_SPARE_4 = 11,
 dm_sw_SPARE_5 = 12,
 dm_sw_var_s = 13,
 dm_sw_var_d = 14,
 dm_sw_SPARE_6 = 15,
 dm_sw_SPARE_7 = 16,
 dm_sw_64kb_s_t = 17,
 dm_sw_64kb_d_t = 18,
 dm_sw_SPARE_10 = 19,
 dm_sw_SPARE_11 = 20,
 dm_sw_4kb_s_x = 21,
 dm_sw_4kb_d_x = 22,
 dm_sw_SPARE_12 = 23,
 dm_sw_SPARE_13 = 24,
 dm_sw_64kb_s_x = 25,
 dm_sw_64kb_d_x = 26,
 dm_sw_SPARE_14 = 27,
 dm_sw_SPARE_15 = 28,
 dm_sw_var_s_x = 29,
 dm_sw_var_d_x = 30,
 dm_sw_64kb_r_x,
 dm_sw_gfx7_2d_thin_l_vp,
 dm_sw_gfx7_2d_thin_gl,
};
enum lb_depth {
 dm_lb_10 = 0, dm_lb_8 = 1, dm_lb_6 = 2, dm_lb_12 = 3, dm_lb_16 = 4,
 dm_lb_19 = 5
};
enum voltage_state {
 dm_vmin = 0, dm_vmid = 1, dm_vnom = 2, dm_vmax = 3
};
enum source_macro_tile_size {
 dm_4k_tile = 0, dm_64k_tile = 1, dm_256k_tile = 2
};
enum cursor_bpp {
 dm_cur_2bit = 0, dm_cur_32bit = 1, dm_cur_64bit = 2
};
enum clock_change_support {
 dm_dram_clock_change_uninitialized = 0,
 dm_dram_clock_change_vactive,
 dm_dram_clock_change_vblank,
 dm_dram_clock_change_unsupported
};

enum output_standard {
 dm_std_uninitialized = 0, dm_std_cvtr2, dm_std_cvt
};

enum mpc_combine_affinity {
 dm_mpc_always_when_possible,
 dm_mpc_reduce_voltage,
 dm_mpc_reduce_voltage_and_clocks,
 dm_mpc_never
};

enum RequestType {
 REQ_256Bytes, REQ_128BytesNonContiguous, REQ_128BytesContiguous, REQ_NA
};

enum self_refresh_affinity {
 dm_try_to_allow_self_refresh_and_mclk_switch,
 dm_allow_self_refresh_and_mclk_switch,
 dm_allow_self_refresh,
 dm_neither_self_refresh_nor_mclk_switch
};

enum dm_validation_status {
 DML_VALIDATION_OK,
 DML_FAIL_SCALE_RATIO_TAP,
 DML_FAIL_SOURCE_PIXEL_FORMAT,
 DML_FAIL_VIEWPORT_SIZE,
 DML_FAIL_TOTAL_V_ACTIVE_BW,
 DML_FAIL_DIO_SUPPORT,
 DML_FAIL_NOT_ENOUGH_DSC,
 DML_FAIL_DSC_CLK_REQUIRED,
 DML_FAIL_DSC_VALIDATION_FAILURE,
 DML_FAIL_URGENT_LATENCY,
 DML_FAIL_REORDERING_BUFFER,
 DML_FAIL_DISPCLK_DPPCLK,
 DML_FAIL_TOTAL_AVAILABLE_PIPES,
 DML_FAIL_NUM_OTG,
 DML_FAIL_WRITEBACK_MODE,
 DML_FAIL_WRITEBACK_LATENCY,
 DML_FAIL_WRITEBACK_SCALE_RATIO_TAP,
 DML_FAIL_CURSOR_SUPPORT,
 DML_FAIL_PITCH_SUPPORT,
 DML_FAIL_PTE_BUFFER_SIZE,
 DML_FAIL_HOST_VM_IMMEDIATE_FLIP,
 DML_FAIL_DSC_INPUT_BPC,
 DML_FAIL_PREFETCH_SUPPORT,
 DML_FAIL_V_RATIO_PREFETCH,
};

enum writeback_config {
 dm_normal,
 dm_whole_buffer_for_single_stream_no_interleave,
 dm_whole_buffer_for_single_stream_interleave,
};

enum odm_combine_mode {
 dm_odm_combine_mode_disabled,
 dm_odm_combine_mode_2to1,
 dm_odm_combine_mode_4to1,
};

enum odm_combine_policy {
 dm_odm_combine_policy_dal,
 dm_odm_combine_policy_none,
 dm_odm_combine_policy_2to1,
 dm_odm_combine_policy_4to1,
};

enum immediate_flip_requirement {
 dm_immediate_flip_not_required,
 dm_immediate_flip_required,
};

enum unbounded_requesting_policy {
 dm_unbounded_requesting,
 dm_unbounded_requesting_edp_only,
 dm_unbounded_requesting_disable
};
# 32 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_vba.h" 1
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_vba.h"
struct display_mode_lib;

void ModeSupportAndSystemConfiguration(struct display_mode_lib *mode_lib);



double get_clk_dcf_deepsleep(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_urgent(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_memory_trip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_writeback_urgent(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_stutter_exit(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_stutter_enter_exit(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_dram_clock_change(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_wm_writeback_dram_clock_change(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_stutter_efficiency_no_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_stutter_efficiency(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_stutter_period(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_urgent_latency(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_urgent_extra_latency(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_nonurgent_latency(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_dram_clock_change_latency(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_dispclk_calculated(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_total_data_read_bw(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_return_bw(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_tcalc(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_fraction_of_urgent_bandwidth(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);
double get_fraction_of_urgent_bandwidth_imm_flip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes);



double get_dsc_delay(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dppclk_calculated(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dscclk_calculated(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_min_ttu_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_min_ttu_vblank_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_vratio_prefetch_l(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_vratio_prefetch_c(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_x_after_scaler(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_after_scaler(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_per_vm_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_per_row_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_prefetch(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_per_vm_flip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dst_y_per_row_flip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_group_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_group_flip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_req_vblank(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_req_flip(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_group_vblank_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_group_flip_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_req_vblank_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_req_flip_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_vm_dmdata_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_dmdata_dl_delta_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_line_delivery_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_line_delivery_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_line_delivery_pre_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_line_delivery_pre_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_req_delivery_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_req_delivery_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_req_delivery_pre_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_req_delivery_pre_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_cursor_req_delivery_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_cursor_req_delivery_pre_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_nom_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_nom_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_vblank_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_vblank_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_flip_l_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_refcyc_per_meta_chunk_flip_c_in_us(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);

double get_vupdate_offset(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_vupdate_width(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);
double get_vready_offset(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe);

unsigned int get_vstartup_calculated(
  struct display_mode_lib *mode_lib,
  const display_e2e_pipe_params_st *pipes,
  unsigned int num_pipes,
  unsigned int which_pipe);

double get_total_immediate_flip_bytes(
  struct display_mode_lib *mode_lib,
  const display_e2e_pipe_params_st *pipes,
  unsigned int num_pipes);
double get_total_immediate_flip_bw(
  struct display_mode_lib *mode_lib,
  const display_e2e_pipe_params_st *pipes,
  unsigned int num_pipes);
double get_total_prefetch_bw(
  struct display_mode_lib *mode_lib,
  const display_e2e_pipe_params_st *pipes,
  unsigned int num_pipes);
unsigned int dml_get_voltage_level(
  struct display_mode_lib *mode_lib,
  const display_e2e_pipe_params_st *pipes,
  unsigned int num_pipes);

void PixelClockAdjustmentForProgressiveToInterlaceUnit(struct display_mode_lib *mode_lib);

bool Calculate256BBlockSizes(
  enum source_format_class SourcePixelFormat,
  enum dm_swizzle_mode SurfaceTiling,
  unsigned int BytePerPixelY,
  unsigned int BytePerPixelC,
  unsigned int *BlockHeight256BytesY,
  unsigned int *BlockHeight256BytesC,
  unsigned int *BlockWidth256BytesY,
  unsigned int *BlockWidth256BytesC);

struct vba_vars_st {
 ip_params_st ip;
 soc_bounding_box_st soc;

 int maxMpcComb;
 bool UseMaximumVStartup;

 double WritebackDISPCLK;
 double DPPCLKUsingSingleDPPLuma;
 double DPPCLKUsingSingleDPPChroma;
 double DISPCLKWithRamping;
 double DISPCLKWithoutRamping;
 double GlobalDPPCLK;
 double DISPCLKWithRampingRoundedToDFSGranularity;
 double DISPCLKWithoutRampingRoundedToDFSGranularity;
 double MaxDispclkRoundedToDFSGranularity;
 bool DCCEnabledAnyPlane;
 double ReturnBandwidthToDCN;
 unsigned int TotalActiveDPP;
 unsigned int TotalDCCActiveDPP;
 double UrgentRoundTripAndOutOfOrderLatency;
 double StutterPeriod;
 double FrameTimeForMinFullDETBufferingTime;
 double AverageReadBandwidth;
 double TotalRowReadBandwidth;
 double PartOfBurstThatFitsInROB;
 double StutterBurstTime;
 unsigned int NextPrefetchMode;
 double NextMaxVStartup;
 double VBlankTime;
 double SmallestVBlank;
 double DCFCLKDeepSleepPerPlane[8];
 double EffectiveDETPlusLBLinesLuma;
 double EffectiveDETPlusLBLinesChroma;
 double UrgentLatencySupportUsLuma;
 double UrgentLatencySupportUsChroma;
 unsigned int DSCFormatFactor;

 bool DummyPStateCheck;
 bool DRAMClockChangeSupportsVActive;
 bool PrefetchModeSupported;
 bool PrefetchAndImmediateFlipSupported;
 enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank;
 double XFCRemoteSurfaceFlipDelay;
 double TInitXFill;
 double TslvChk;
 double SrcActiveDrainRate;
 bool ImmediateFlipSupported;
 enum mpc_combine_affinity WhenToDoMPCCombine;

 bool PrefetchERROR;

 unsigned int VStartupLines;
 unsigned int ActiveDPPs;
 unsigned int LBLatencyHidingSourceLinesY;
 unsigned int LBLatencyHidingSourceLinesC;
 double ActiveDRAMClockChangeLatencyMargin[8];
 double MinActiveDRAMClockChangeMargin;
 double InitFillLevel;
 double FinalFillMargin;
 double FinalFillLevel;
 double RemainingFillLevel;
 double TFinalxFill;




 double SRExitTime;
 double SREnterPlusExitTime;
 double UrgentLatencyPixelDataOnly;
 double UrgentLatencyPixelMixedWithVMData;
 double UrgentLatencyVMDataOnly;
 double UrgentLatency;
 double WritebackLatency;
 double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly;
 double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData;
 double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;
 double MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation;
 double MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation;
 double NumberOfChannels;
 double DRAMChannelWidth;
 double FabricDatapathToDCNDataReturn;
 double ReturnBusWidth;
 double Downspreading;
 double DISPCLKDPPCLKDSCCLKDownSpreading;
 double DISPCLKDPPCLKVCOSpeed;
 double RoundTripPingLatencyCycles;
 double UrgentOutOfOrderReturnPerChannel;
 double UrgentOutOfOrderReturnPerChannelPixelDataOnly;
 double UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData;
 double UrgentOutOfOrderReturnPerChannelVMDataOnly;
 unsigned int VMMPageSize;
 double DRAMClockChangeLatency;
 double XFCBusTransportTime;
 bool UseUrgentBurstBandwidth;
 double XFCXBUFLatencyTolerance;




 unsigned int ROBBufferSizeInKByte;
 double DETBufferSizeInKByte;
 double DETBufferSizeInTime;
 unsigned int DPPOutputBufferPixels;
 unsigned int OPPOutputBufferLines;
 unsigned int PixelChunkSizeInKByte;
 double ReturnBW;
 bool GPUVMEnable;
 bool HostVMEnable;
 unsigned int GPUVMMaxPageTableLevels;
 unsigned int HostVMMaxPageTableLevels;
 unsigned int HostVMCachedPageTableLevels;
 unsigned int OverrideGPUVMPageTableLevels;
 unsigned int OverrideHostVMPageTableLevels;
 unsigned int MetaChunkSize;
 unsigned int MinMetaChunkSizeBytes;
 unsigned int WritebackChunkSize;
 bool ODMCapability;
 unsigned int NumberOfDSC;
 unsigned int LineBufferSize;
 unsigned int MaxLineBufferLines;
 unsigned int WritebackInterfaceLumaBufferSize;
 unsigned int WritebackInterfaceChromaBufferSize;
 unsigned int WritebackChromaLineBufferWidth;
 enum writeback_config WritebackConfiguration;
 double MaxDCHUBToPSCLThroughput;
 double MaxPSCLToLBThroughput;
 unsigned int PTEBufferSizeInRequestsLuma;
 unsigned int PTEBufferSizeInRequestsChroma;
 double DISPCLKRampingMargin;
 unsigned int MaxInterDCNTileRepeaters;
 bool XFCSupported;
 double XFCSlvChunkSize;
 double XFCFillBWOverhead;
 double XFCFillConstant;
 double XFCTSlvVupdateOffset;
 double XFCTSlvVupdateWidth;
 double XFCTSlvVreadyOffset;
 double DPPCLKDelaySubtotal;
 double DPPCLKDelaySCL;
 double DPPCLKDelaySCLLBOnly;
 double DPPCLKDelayCNVCFormater;
 double DPPCLKDelayCNVCCursor;
 double DISPCLKDelaySubtotal;
 bool ProgressiveToInterlaceUnitInOPP;

 int VoltageLevel;
 double FabricClock;
 double DRAMSpeed;
 double DISPCLK;
 double SOCCLK;
 double DCFCLK;

 unsigned int NumberOfActivePlanes;
 unsigned int NumberOfDSCSlices[8];
 unsigned int ViewportWidth[8];
 unsigned int ViewportHeight[8];
 unsigned int ViewportYStartY[8];
 unsigned int ViewportYStartC[8];
 unsigned int PitchY[8];
 unsigned int PitchC[8];
 double HRatio[8];
 double VRatio[8];
 unsigned int htaps[8];
 unsigned int vtaps[8];
 unsigned int HTAPsChroma[8];
 unsigned int VTAPsChroma[8];
 unsigned int HTotal[8];
 unsigned int VTotal[8];
 unsigned int VTotal_Max[8];
 unsigned int VTotal_Min[8];
 int DPPPerPlane[8];
 double PixelClock[8];
 double PixelClockBackEnd[8];
 bool DCCEnable[8];
 bool FECEnable[8];
 unsigned int DCCMetaPitchY[8];
 unsigned int DCCMetaPitchC[8];
 enum scan_direction_class SourceScan[8];
 enum source_format_class SourcePixelFormat[8];
 bool WritebackEnable[8];
 unsigned int ActiveWritebacksPerPlane[8];
 double WritebackDestinationWidth[8];
 double WritebackDestinationHeight[8];
 double WritebackSourceHeight[8];
 enum source_format_class WritebackPixelFormat[8];
 unsigned int WritebackLumaHTaps[8];
 unsigned int WritebackLumaVTaps[8];
 unsigned int WritebackChromaHTaps[8];
 unsigned int WritebackChromaVTaps[8];
 double WritebackHRatio[8];
 double WritebackVRatio[8];
 unsigned int HActive[8];
 unsigned int VActive[8];
 bool Interlace[8];
 enum dm_swizzle_mode SurfaceTiling[8];
 unsigned int ScalerRecoutWidth[8];
 bool DynamicMetadataEnable[8];
 int DynamicMetadataLinesBeforeActiveRequired[8];
 unsigned int DynamicMetadataTransmittedBytes[8];
 double DCCRate[8];
 double AverageDCCCompressionRate;
 enum odm_combine_mode ODMCombineEnabled[8];
 double OutputBpp[8];
 bool DSCEnabled[8];
 unsigned int DSCInputBitPerComponent[8];
 enum output_format_class OutputFormat[8];
 enum output_encoder_class Output[8];
 unsigned int BlendingAndTiming[8];
 bool SynchronizedVBlank;
 unsigned int NumberOfCursors[8];
 unsigned int CursorWidth[8][2];
 unsigned int CursorBPP[8][2];
 bool XFCEnabled[8];
 bool ScalerEnabled[8];


 bool ImmediateFlipSupport;
 double DETBufferSizeY[8];
 double DETBufferSizeC[8];
 unsigned int SwathHeightY[8];
 unsigned int SwathHeightC[8];
 unsigned int LBBitPerPixel[8];
 double LastPixelOfLineExtraWatermark;
 double TotalDataReadBandwidth;
 unsigned int TotalActiveWriteback;
 unsigned int EffectiveLBLatencyHidingSourceLinesLuma;
 unsigned int EffectiveLBLatencyHidingSourceLinesChroma;
 double BandwidthAvailableForImmediateFlip;
 unsigned int PrefetchMode[9][2];
 unsigned int PrefetchModePerState[9][2];
 unsigned int MinPrefetchMode;
 unsigned int MaxPrefetchMode;
 bool AnyLinesForVMOrRowTooLarge;
 double MaxVStartup;
 bool IgnoreViewportPositioning;
 bool ErrorResult[8];



 double DCFCLKDeepSleep;
 double UrgentWatermark;
 double UrgentExtraLatency;
 double WritebackUrgentWatermark;
 double StutterExitWatermark;
 double StutterEnterPlusExitWatermark;
 double DRAMClockChangeWatermark;
 double WritebackDRAMClockChangeWatermark;
 double StutterEfficiency;
 double StutterEfficiencyNotIncludingVBlank;
 double NonUrgentLatencyTolerance;
 double MinActiveDRAMClockChangeLatencySupported;




 double DISPCLK_calculated;
 double DPPCLK_calculated[8];

 unsigned int VUpdateOffsetPix[8];
 double VUpdateWidthPix[8];
 double VReadyOffsetPix[8];

 unsigned int TotImmediateFlipBytes;
 double TCalc;

 display_e2e_pipe_params_st cache_pipes[8];
 unsigned int cache_num_pipes;
 unsigned int pipe_plane[8];



 bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
 double MaxHSCLRatio;
 double MaxVSCLRatio;
 unsigned int MaxNumWriteback;
 bool WritebackLumaAndChromaScalingSupported;
 bool Cursor64BppSupport;
 double DCFCLKPerState[9];
 double DCFCLKState[9][2];
 double FabricClockPerState[9];
 double SOCCLKPerState[9];
 double PHYCLKPerState[9];
 double DTBCLKPerState[9];
 double MaxDppclk[9];
 double MaxDSCCLK[9];
 double DRAMSpeedPerState[9];
 double MaxDispclk[9];
 int VoltageOverrideLevel;


 bool ScaleRatioAndTapsSupport;
 bool SourceFormatPixelAndScanSupport;
 double TotalBandwidthConsumedGBytePerSecond;
 bool DCCEnabledInAnyPlane;
 bool WritebackLatencySupport;
 bool WritebackModeSupport;
 bool Writeback10bpc420Supported;
 bool BandwidthSupport[9];
 unsigned int TotalNumberOfActiveWriteback;
 double CriticalPoint;
 double ReturnBWToDCNPerState;
 bool IsErrorResult[9][2][8];
 bool prefetch_vm_bw_valid;
 bool prefetch_row_bw_valid;
 bool NumberOfOTGSupport;
 bool NonsupportedDSCInputBPC;
 bool WritebackScaleRatioAndTapsSupport;
 bool CursorSupport;
 bool PitchSupport;
 enum dm_validation_status ValidationStatus[9];

 double WritebackLineBufferLumaBufferSize;
 double WritebackLineBufferChromaBufferSize;
 double WritebackMinHSCLRatio;
 double WritebackMinVSCLRatio;
 double WritebackMaxHSCLRatio;
 double WritebackMaxVSCLRatio;
 double WritebackMaxHSCLTaps;
 double WritebackMaxVSCLTaps;
 unsigned int MaxNumDPP;
 unsigned int MaxNumOTG;
 double CursorBufferSize;
 double CursorChunkSize;
 unsigned int Mode;
 double OutputLinkDPLanes[8];
 double ForcedOutputLinkBPP[8];
 double ImmediateFlipBW[8];
 double MaxMaxVStartup[9][2];

 double WritebackLumaVExtra;
 double WritebackChromaVExtra;
 double WritebackRequiredDISPCLK;
 double MaximumSwathWidthSupport;
 double MaximumSwathWidthInDETBuffer;
 double MaximumSwathWidthInLineBuffer;
 double MaxDispclkRoundedDownToDFSGranularity;
 double MaxDppclkRoundedDownToDFSGranularity;
 double PlaneRequiredDISPCLKWithoutODMCombine;
 double PlaneRequiredDISPCLKWithODMCombine;
 double PlaneRequiredDISPCLK;
 double TotalNumberOfActiveOTG;
 double FECOverhead;
 double EffectiveFECOverhead;
 double Outbpp;
 unsigned int OutbppDSC;
 double TotalDSCUnitsRequired;
 double bpp;
 unsigned int slices;
 double SwathWidthGranularityY;
 double RoundedUpMaxSwathSizeBytesY;
 double SwathWidthGranularityC;
 double RoundedUpMaxSwathSizeBytesC;
 double EffectiveDETLBLinesLuma;
 double EffectiveDETLBLinesChroma;
 double ProjectedDCFCLKDeepSleep[9][2];
 double PDEAndMetaPTEBytesPerFrameY;
 double PDEAndMetaPTEBytesPerFrameC;
 unsigned int MetaRowBytesY;
 unsigned int MetaRowBytesC;
 unsigned int DPTEBytesPerRowC;
 unsigned int DPTEBytesPerRowY;
 double ExtraLatency;
 double TimeCalc;
 double TWait;
 double MaximumReadBandwidthWithPrefetch;
 double MaximumReadBandwidthWithoutPrefetch;
 double total_dcn_read_bw_with_flip;
 double total_dcn_read_bw_with_flip_no_urgent_burst;
 double FractionOfUrgentBandwidth;
 double FractionOfUrgentBandwidthImmediateFlip;


 double IdealSDPPortBandwidthPerState[9][2];
 unsigned int NoOfDPP[9][2][8];
 int NoOfDPPThisState[8];
 enum odm_combine_mode ODMCombineEnablePerState[9][8];
 double SwathWidthYThisState[8];
 unsigned int SwathHeightCPerState[9][2][8];
 unsigned int SwathHeightYThisState[8];
 unsigned int SwathHeightCThisState[8];
 double VRatioPreY[9][2][8];
 double VRatioPreC[9][2][8];
 double RequiredPrefetchPixelDataBWLuma[9][2][8];
 double RequiredPrefetchPixelDataBWChroma[9][2][8];
 double RequiredDPPCLK[9][2][8];
 double RequiredDPPCLKThisState[8];
 bool PTEBufferSizeNotExceededY[9][2][8];
 bool PTEBufferSizeNotExceededC[9][2][8];
 bool BandwidthWithoutPrefetchSupported[9][2];
 bool PrefetchSupported[9][2];
 bool VRatioInPrefetchSupported[9][2];
 double RequiredDISPCLK[9][2];
 bool DISPCLK_DPPCLK_Support[9][2];
 bool TotalAvailablePipesSupport[9][2];
 unsigned int TotalNumberOfActiveDPP[9][2];
 unsigned int TotalNumberOfDCCActiveDPP[9][2];
 bool ModeSupport[9][2];
 double ReturnBWPerState[9][2];
 bool DIOSupport[9];
 bool NotEnoughDSCUnits[9];
 bool DSCCLKRequiredMoreThanSupported[9];
 bool DTBCLKRequiredMoreThanSupported[9];
 double UrgentRoundTripAndOutOfOrderLatencyPerState[9];
 bool ROBSupport[9][2];
 bool PTEBufferSizeNotExceeded[9][2];
 bool TotalVerticalActiveBandwidthSupport[9][2];
 double MaxTotalVerticalActiveAvailableBandwidth[9][2];
 double PrefetchBW[8];
 double PDEAndMetaPTEBytesPerFrame[9][2][8];
 double MetaRowBytes[9][2][8];
 double DPTEBytesPerRow[9][2][8];
 double PrefetchLinesY[9][2][8];
 double PrefetchLinesC[9][2][8];
 unsigned int MaxNumSwY[8];
 unsigned int MaxNumSwC[8];
 double PrefillY[8];
 double PrefillC[8];
 double LineTimesForPrefetch[8];
 double LinesForMetaPTE[8];
 double LinesForMetaAndDPTERow[8];
 double MinDPPCLKUsingSingleDPP[8];
 double SwathWidthYSingleDPP[8];
 double BytePerPixelInDETY[8];
 double BytePerPixelInDETC[8];
 bool RequiresDSC[9][8];
 unsigned int NumberOfDSCSlice[9][8];
 double RequiresFEC[9][8];
 double OutputBppPerState[9][8];
 double DSCDelayPerState[9][8];
 bool ViewportSizeSupport[9][2];
 unsigned int Read256BlockHeightY[8];
 unsigned int Read256BlockWidthY[8];
 unsigned int Read256BlockHeightC[8];
 unsigned int Read256BlockWidthC[8];
 double MaxSwathHeightY[8];
 double MaxSwathHeightC[8];
 double MinSwathHeightY[8];
 double MinSwathHeightC[8];
 double ReadBandwidthLuma[8];
 double ReadBandwidthChroma[8];
 double ReadBandwidth[8];
 double WriteBandwidth[8];
 double PSCL_FACTOR[8];
 double PSCL_FACTOR_CHROMA[8];
 double MaximumVStartup[9][2][8];
 unsigned int MacroTileWidthY[8];
 unsigned int MacroTileWidthC[8];
 double AlignedDCCMetaPitch[8];
 double AlignedYPitch[8];
 double AlignedCPitch[8];
 double MaximumSwathWidth[8];
 double cursor_bw[8];
 double cursor_bw_pre[8];
 double Tno_bw[8];
 double prefetch_vmrow_bw[8];
 double DestinationLinesToRequestVMInImmediateFlip[8];
 double DestinationLinesToRequestRowInImmediateFlip[8];
 double final_flip_bw[8];
 bool ImmediateFlipSupportedForState[9][2];
 double WritebackDelay[9][8];
 unsigned int vm_group_bytes[8];
 unsigned int dpte_group_bytes[8];
 unsigned int dpte_row_height[8];
 unsigned int meta_req_height[8];
 unsigned int meta_req_width[8];
 unsigned int meta_row_height[8];
 unsigned int meta_row_width[8];
 unsigned int dpte_row_height_chroma[8];
 unsigned int meta_req_height_chroma[8];
 unsigned int meta_req_width_chroma[8];
 unsigned int meta_row_height_chroma[8];
 unsigned int meta_row_width_chroma[8];
 bool ImmediateFlipSupportedForPipe[8];
 double meta_row_bw[8];
 double dpte_row_bw[8];
 double DisplayPipeLineDeliveryTimeLuma[8];
 double DisplayPipeLineDeliveryTimeChroma[8];
 double DisplayPipeRequestDeliveryTimeLuma[8];
 double DisplayPipeRequestDeliveryTimeChroma[8];
 enum clock_change_support DRAMClockChangeSupport[9][2];
 double UrgentBurstFactorCursor[8];
 double UrgentBurstFactorCursorPre[8];
 double UrgentBurstFactorLuma[8];
 double UrgentBurstFactorLumaPre[8];
 double UrgentBurstFactorChroma[8];
 double UrgentBurstFactorChromaPre[8];


 bool MPCCombine[9][2][8];
 double SwathWidthCSingleDPP[8];
 double MaximumSwathWidthInLineBufferLuma;
 double MaximumSwathWidthInLineBufferChroma;
 double MaximumSwathWidthLuma[8];
 double MaximumSwathWidthChroma[8];
 enum odm_combine_mode odm_combine_dummy[8];
 double dummy1[8];
 double dummy2[8];
 double dummy3[8];
 double dummy4[8];
 double dummy5;
 double dummy6;
 double dummy7[8];
 double dummy8[8];
 double dummy13[8];
 unsigned int dummyinteger1ms[8];
 double dummyinteger2ms[8];
 unsigned int dummyinteger3[8];
 unsigned int dummyinteger4[8];
 unsigned int dummyinteger5;
 unsigned int dummyinteger6;
 unsigned int dummyinteger7;
 unsigned int dummyinteger8;
 unsigned int dummyinteger9;
 unsigned int dummyinteger10;
 unsigned int dummyinteger11;
 unsigned int dummyinteger12;
 unsigned int dummyinteger30;
 unsigned int dummyinteger31;
 unsigned int dummyinteger32;
 unsigned int dummyintegerarr1[8];
 unsigned int dummyintegerarr2[8];
 unsigned int dummyintegerarr3[8];
 unsigned int dummyintegerarr4[8];
 bool dummysinglestring;
 bool SingleDPPViewportSizeSupportPerPlane[8];
 double PlaneRequiredDISPCLKWithODMCombine2To1;
 double PlaneRequiredDISPCLKWithODMCombine4To1;
 unsigned int TotalNumberOfSingleDPPPlanes[9][2];
 bool LinkDSCEnable;
 bool ODMCombine4To1SupportCheckOK[9];
 enum odm_combine_mode ODMCombineEnableThisState[8];
 double SwathWidthCThisState[8];
 bool ViewportSizeSupportPerPlane[8];
 double AlignedDCCMetaPitchY[8];
 double AlignedDCCMetaPitchC[8];

 unsigned int NotEnoughUrgentLatencyHiding;
 unsigned int NotEnoughUrgentLatencyHidingPre;
 int PTEBufferSizeInRequestsForLuma;
 int PTEBufferSizeInRequestsForChroma;


 int dpte_group_bytes_chroma;
 unsigned int vm_group_bytes_chroma;
 double dst_x_after_scaler;
 double dst_y_after_scaler;
 unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;


 double PrefetchBandwidth[8];
 double VInitPreFillY[8];
 double VInitPreFillC[8];
 unsigned int MaxNumSwathY[8];
 unsigned int MaxNumSwathC[8];
 unsigned int VStartup[8];
 double DSTYAfterScaler[8];
 double DSTXAfterScaler[8];
 bool AllowDRAMClockChangeDuringVBlank[8];
 bool AllowDRAMSelfRefreshDuringVBlank[8];
 double VRatioPrefetchY[8];
 double VRatioPrefetchC[8];
 double DestinationLinesForPrefetch[8];
 double DestinationLinesToRequestVMInVBlank[8];
 double DestinationLinesToRequestRowInVBlank[8];
 double MinTTUVBlank[8];
 double BytePerPixelDETY[8];
 double BytePerPixelDETC[8];
 double SwathWidthY[8];
 double SwathWidthSingleDPPY[8];
 double CursorRequestDeliveryTime[8];
 double CursorRequestDeliveryTimePrefetch[8];
 double ReadBandwidthPlaneLuma[8];
 double ReadBandwidthPlaneChroma[8];
 double DisplayPipeLineDeliveryTimeLumaPrefetch[8];
 double DisplayPipeLineDeliveryTimeChromaPrefetch[8];
 double DisplayPipeRequestDeliveryTimeLumaPrefetch[8];
 double DisplayPipeRequestDeliveryTimeChromaPrefetch[8];
 double PixelPTEBytesPerRow[8];
 double PDEAndMetaPTEBytesFrame[8];
 double MetaRowByte[8];
 double PrefetchSourceLinesY[8];
 double RequiredPrefetchPixDataBWLuma[8];
 double RequiredPrefetchPixDataBWChroma[8];
 double PrefetchSourceLinesC[8];
 double PSCL_THROUGHPUT_LUMA[8];
 double PSCL_THROUGHPUT_CHROMA[8];
 double DSCCLK_calculated[8];
 unsigned int DSCDelay[8];
 unsigned int MaxVStartupLines[8];
 double DPPCLKUsingSingleDPP[8];
 double DPPCLK[8];
 unsigned int DCCYMaxUncompressedBlock[8];
 unsigned int DCCYMaxCompressedBlock[8];
 unsigned int DCCYIndependent64ByteBlock[8];
 double MaximumDCCCompressionYSurface[8];
 unsigned int BlockHeight256BytesY[8];
 unsigned int BlockHeight256BytesC[8];
 unsigned int BlockWidth256BytesY[8];
 unsigned int BlockWidth256BytesC[8];
 double XFCSlaveVUpdateOffset[8];
 double XFCSlaveVupdateWidth[8];
 double XFCSlaveVReadyOffset[8];
 double XFCTransferDelay[8];
 double XFCPrechargeDelay[8];
 double XFCRemoteSurfaceFlipLatency[8];
 double XFCPrefetchMargin[8];
 unsigned int dpte_row_width_luma_ub[8];
 unsigned int dpte_row_width_chroma_ub[8];
 double FullDETBufferingTimeY[8];
 double FullDETBufferingTimeC[8];
 double DST_Y_PER_PTE_ROW_NOM_L[8];
 double DST_Y_PER_PTE_ROW_NOM_C[8];
 double DST_Y_PER_META_ROW_NOM_L[8];
 double TimePerMetaChunkNominal[8];
 double TimePerMetaChunkVBlank[8];
 double TimePerMetaChunkFlip[8];
 unsigned int swath_width_luma_ub[8];
 unsigned int swath_width_chroma_ub[8];
 unsigned int PixelPTEReqWidthY[8];
 unsigned int PixelPTEReqHeightY[8];
 unsigned int PTERequestSizeY[8];
 unsigned int PixelPTEReqWidthC[8];
 unsigned int PixelPTEReqHeightC[8];
 unsigned int PTERequestSizeC[8];
 double time_per_pte_group_nom_luma[8];
 double time_per_pte_group_nom_chroma[8];
 double time_per_pte_group_vblank_luma[8];
 double time_per_pte_group_vblank_chroma[8];
 double time_per_pte_group_flip_luma[8];
 double time_per_pte_group_flip_chroma[8];
 double TimePerVMGroupVBlank[8];
 double TimePerVMGroupFlip[8];
 double TimePerVMRequestVBlank[8];
 double TimePerVMRequestFlip[8];
 unsigned int dpde0_bytes_per_frame_ub_l[8];
 unsigned int meta_pte_bytes_per_frame_ub_l[8];
 unsigned int dpde0_bytes_per_frame_ub_c[8];
 unsigned int meta_pte_bytes_per_frame_ub_c[8];
 double LinesToFinishSwathTransferStutterCriticalPlane;
 unsigned int BytePerPixelYCriticalPlane;
 double SwathWidthYCriticalPlane;
 double LinesInDETY[8];
 double LinesInDETYRoundedDownToSwath[8];

 double SwathWidthSingleDPPC[8];
 double SwathWidthC[8];
 unsigned int BytePerPixelY[8];
 unsigned int BytePerPixelC[8];
 unsigned int dummyinteger1;
 unsigned int dummyinteger2;
 double FinalDRAMClockChangeLatency;
 double Tdmdl_vm[8];
 double Tdmdl[8];
 double TSetup[8];
 unsigned int ThisVStartup;
 bool WritebackAllowDRAMClockChangeEndPosition[8];
 double DST_Y_PER_META_ROW_NOM_C[8];
 double TimePerChromaMetaChunkNominal[8];
 double TimePerChromaMetaChunkVBlank[8];
 double TimePerChromaMetaChunkFlip[8];
 unsigned int DCCCMaxUncompressedBlock[8];
 unsigned int DCCCMaxCompressedBlock[8];
 unsigned int DCCCIndependent64ByteBlock[8];
 double VStartupMargin;
 bool NotEnoughTimeForDynamicMetadata;


 unsigned int MaximumMaxVStartupLines;
 double FabricAndDRAMBandwidth;
 double LinesInDETLuma;
 double LinesInDETChroma;
 unsigned int ImmediateFlipBytes[8];
 unsigned int LinesInDETC[8];
 unsigned int LinesInDETCRoundedDownToSwath[8];
 double UrgentLatencySupportUsPerState[9][2][8];
 double UrgentLatencySupportUs[8];
 double FabricAndDRAMBandwidthPerState[9];
 bool UrgentLatencySupport[9][2];
 unsigned int SwathWidthYPerState[9][2][8];
 unsigned int SwathHeightYPerState[9][2][8];
 double qual_row_bw[8];
 double prefetch_row_bw[8];
 double prefetch_vm_bw[8];

 double PTEGroupSize;
 unsigned int PDEProcessingBufIn64KBReqs;

 double MaxTotalVActiveRDBandwidth;
 bool DoUrgentLatencyAdjustment;
 double UrgentLatencyAdjustmentFabricClockComponent;
 double UrgentLatencyAdjustmentFabricClockReference;
 double MinUrgentLatencySupportUs;
 double MinFullDETBufferingTime;
 double AverageReadBandwidthGBytePerSecond;
 bool FirstMainPlane;

 unsigned int ViewportWidthChroma[8];
 unsigned int ViewportHeightChroma[8];
 double HRatioChroma[8];
 double VRatioChroma[8];
 int WritebackSourceWidth[8];

 bool ModeIsSupported;
 bool ODMCombine4To1Supported;

 unsigned int SurfaceWidthY[8];
 unsigned int SurfaceWidthC[8];
 unsigned int SurfaceHeightY[8];
 unsigned int SurfaceHeightC[8];
 unsigned int WritebackHTaps[8];
 unsigned int WritebackVTaps[8];
 bool DSCEnable[8];

 double DRAMClockChangeLatencyOverride;

 double GPUVMMinPageSize;
 double HostVMMinPageSize;

 bool MPCCombineEnable[8];
 unsigned int HostVMMaxNonCachedPageTableLevels;
 bool DynamicMetadataVMEnabled;
 double WritebackInterfaceBufferSize;
 double WritebackLineBufferSize;

 double DCCRateLuma[8];
 double DCCRateChroma[8];

 double PHYCLKD18PerState[9];

 bool WritebackSupportInterleaveAndUsingWholeBufferForASingleStream;
 bool NumberOfHDMIFRLSupport;
 unsigned int MaxNumHDMIFRLOutputs;
 int AudioSampleRate[8];
 int AudioSampleLayout[8];

 int PercentMarginOverMinimumRequiredDCFCLK;
 bool DynamicMetadataSupported[9][2];
 enum immediate_flip_requirement ImmediateFlipRequirement;
 double DETBufferSizeYThisState[8];
 double DETBufferSizeCThisState[8];
 bool NoUrgentLatencyHiding[8];
 bool NoUrgentLatencyHidingPre[8];
 int swath_width_luma_ub_this_state[8];
 int swath_width_chroma_ub_this_state[8];
 double UrgLatency[9];
 double VActiveCursorBandwidth[9][2][8];
 double VActivePixelBandwidth[9][2][8];
 bool NoTimeForPrefetch[9][2][8];
 bool NoTimeForDynamicMetadata[9][2][8];
 double dpte_row_bandwidth[9][2][8];
 double meta_row_bandwidth[9][2][8];
 double DETBufferSizeYAllStates[9][2][8];
 double DETBufferSizeCAllStates[9][2][8];
 int swath_width_luma_ub_all_states[9][2][8];
 int swath_width_chroma_ub_all_states[9][2][8];
 bool NotUrgentLatencyHiding[9][2];
 unsigned int SwathHeightYAllStates[9][2][8];
 unsigned int SwathHeightCAllStates[9][2][8];
 unsigned int SwathWidthYAllStates[9][2][8];
 unsigned int SwathWidthCAllStates[9][2][8];
 double TotalDPTERowBandwidth[9][2];
 double TotalMetaRowBandwidth[9][2];
 double TotalVActiveCursorBandwidth[9][2];
 double TotalVActivePixelBandwidth[9][2];
 double WritebackDelayTime[8];
 unsigned int DCCYIndependentBlock[8];
 unsigned int DCCCIndependentBlock[8];
 unsigned int dummyinteger15;
 unsigned int dummyinteger16;
 unsigned int dummyinteger17;
 unsigned int dummyinteger18;
 unsigned int dummyinteger19;
 unsigned int dummyinteger20;
 unsigned int dummyinteger21;
 unsigned int dummyinteger22;
 unsigned int dummyinteger23;
 unsigned int dummyinteger24;
 unsigned int dummyinteger25;
 unsigned int dummyinteger26;
 unsigned int dummyinteger27;
 unsigned int dummyinteger28;
 unsigned int dummyinteger29;
 bool dummystring[8];
 double BPP;
 enum odm_combine_policy ODMCombinePolicy;
 bool UseMinimumRequiredDCFCLK;



 bool AllowDramClockChangeOneDisplayVactive;
 bool SynchronizeTimingsIfSingleRefreshRate;

};

bool CalculateMinAndMaxPrefetchMode(
  enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank,
  unsigned int *MinPrefetchMode,
  unsigned int *MaxPrefetchMode);

double CalculateWriteBackDISPCLK(
  enum source_format_class WritebackPixelFormat,
  double PixelClock,
  double WritebackHRatio,
  double WritebackVRatio,
  unsigned int WritebackLumaHTaps,
  unsigned int WritebackLumaVTaps,
  unsigned int WritebackChromaHTaps,
  unsigned int WritebackChromaVTaps,
  double WritebackDestinationWidth,
  unsigned int HTotal,
  unsigned int WritebackChromaLineBufferWidth);
# 33 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../display_mode_lib.h" 2

enum dml_project {
 DML_PROJECT_UNDEFINED,
 DML_PROJECT_RAVEN1,
 DML_PROJECT_NAVI10,
 DML_PROJECT_NAVI10v2,
 DML_PROJECT_DCN21,



};

struct display_mode_lib;

struct dml_funcs {
 void (*rq_dlg_get_dlg_reg)(
   struct display_mode_lib *mode_lib,
   display_dlg_regs_st *dlg_regs,
   display_ttu_regs_st *ttu_regs,
   display_e2e_pipe_params_st *e2e_pipe_param,
   const unsigned int num_pipes,
   const unsigned int pipe_idx,
   const bool cstate_en,
   const bool pstate_en,
   const bool vm_en,
   const bool ignore_viewport_pos,
   const bool immediate_flip_support);
 void (*rq_dlg_get_rq_reg)(
  struct display_mode_lib *mode_lib,
  display_rq_regs_st *rq_regs,
  const display_pipe_params_st pipe_param);
 void (*recalculate)(struct display_mode_lib *mode_lib);
 void (*validate)(struct display_mode_lib *mode_lib);
};

struct display_mode_lib {
 struct _vcs_dpi_ip_params_st ip;
 struct _vcs_dpi_soc_bounding_box_st soc;
 enum dml_project project;
 struct vba_vars_st vba;
 struct dal_logger *logger;
 struct dml_funcs funcs;
};

void dml_init_instance(struct display_mode_lib *lib,
  const struct _vcs_dpi_soc_bounding_box_st *soc_bb,
  const struct _vcs_dpi_ip_params_st *ip_params,
  enum dml_project project);

const char *dml_get_status_message(enum dm_validation_status status);
# 27 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.h"
void dml20_recalculate(struct display_mode_lib *mode_lib);
void dml20_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_lib);
# 28 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_inline_defs.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_inline_defs.h"
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/inc/dcn_calc_math.h" 1
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/inc/dcn_calc_math.h"
float dcn_bw_mod(const float arg1, const float arg2);
float dcn_bw_min2(const float arg1, const float arg2);
unsigned int dcn_bw_max(const unsigned int arg1, const unsigned int arg2);
float dcn_bw_max2(const float arg1, const float arg2);
float dcn_bw_floor2(const float arg, const float significance);
float dcn_bw_floor(const float arg);
float dcn_bw_ceil2(const float arg, const float significance);
float dcn_bw_ceil(const float arg);
float dcn_bw_max3(float v1, float v2, float v3);
float dcn_bw_max5(float v1, float v2, float v3, float v4, float v5);
float dcn_bw_pow(float a, float exp);
float dcn_bw_log(float a, float b);
double dcn_bw_fabs(double a);
# 30 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_inline_defs.h" 2
# 1 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_logger.h" 1
# 31 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_inline_defs.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_min(double a, double b)
{
 return (double) dcn_bw_min2(a, b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_min3(double a, double b, double c)
{
 return dml_min(dml_min(a, b), c);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_min4(double a, double b, double c, double d)
{
 return dml_min(dml_min(a, b), dml_min(c, d));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_max(double a, double b)
{
 return (double) dcn_bw_max2(a, b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_max3(double a, double b, double c)
{
 return dml_max(dml_max(a, b), c);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_max4(double a, double b, double c, double d)
{
 return dml_max(dml_max(a, b), dml_max(c, d));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_max5(double a, double b, double c, double d, double e)
{
 return dml_max(dml_max4(a, b, c, d), e);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_ceil(double a, double granularity)
{
 return (double) dcn_bw_ceil2(a, granularity);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_floor(double a, double granularity)
{
 return (double) dcn_bw_floor2(a, granularity);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_round(double a)
{
 double round_pt = 0.5;
 double ceil = dml_ceil(a, 1);
 double floor = dml_floor(a, 1);

 if (a - floor >= round_pt)
  return ceil;
 else
  return floor;
}
# 98 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/../dml_inline_defs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dml_log2(double x)
{
 unsigned long long ix = *((unsigned long long *)&x);

 return (int)((ix >> 52) & 0x7ff) - 1023;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_pow(double a, int exp)
{
 return (double) dcn_bw_pow(a, exp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_fmod(double f, int val)
{
 return (double) dcn_bw_mod(f, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_ceil_2(double f)
{
 return (double) dcn_bw_ceil2(f, 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_ceil_ex(double x, double granularity)
{
 return (double) dcn_bw_ceil2(x, granularity);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_floor_ex(double x, double granularity)
{
 return (double) dcn_bw_floor2(x, granularity);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dml_round_to_multiple(unsigned int num,
       unsigned int multiple,
       unsigned char up)
{
 unsigned int remainder;

 if (multiple == 0)
  return num;

 remainder = num % multiple;

 if (remainder == 0)
  return num;

 if (up)
  return (num + multiple - remainder);
 else
  return (num - remainder);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) double dml_abs(double a)
{
 if (a > 0)
  return a;
 else
  return (a*(-1));
}
# 29 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c" 2
# 43 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c"
static double adjust_ReturnBW(
  struct display_mode_lib *mode_lib,
  double ReturnBW,
  bool DCCEnabledAnyPlane,
  double ReturnBandwidthToDCN);
static unsigned int dscceComputeDelay(
  unsigned int bpc,
  double bpp,
  unsigned int sliceWidth,
  unsigned int numSlices,
  enum output_format_class pixelFormat);
static unsigned int dscComputeDelay(enum output_format_class pixelFormat);

static bool CalculatePrefetchSchedule(
  struct display_mode_lib *mode_lib,
  double DPPCLK,
  double DISPCLK,
  double PixelClock,
  double DCFCLKDeepSleep,
  unsigned int DSCDelay,
  unsigned int DPPPerPlane,
  bool ScalerEnabled,
  unsigned int NumberOfCursors,
  double DPPCLKDelaySubtotal,
  double DPPCLKDelaySCL,
  double DPPCLKDelaySCLLBOnly,
  double DPPCLKDelayCNVCFormater,
  double DPPCLKDelayCNVCCursor,
  double DISPCLKDelaySubtotal,
  unsigned int ScalerRecoutWidth,
  enum output_format_class OutputFormat,
  unsigned int VBlank,
  unsigned int HTotal,
  unsigned int MaxInterDCNTileRepeaters,
  unsigned int VStartup,
  unsigned int PageTableLevels,
  bool GPUVMEnable,
  bool DynamicMetadataEnable,
  unsigned int DynamicMetadataLinesBeforeActiveRequired,
  unsigned int DynamicMetadataTransmittedBytes,
  bool DCCEnable,
  double UrgentLatencyPixelDataOnly,
  double UrgentExtraLatency,
  double TCalc,
  unsigned int PDEAndMetaPTEBytesFrame,
  unsigned int MetaRowByte,
  unsigned int PixelPTEBytesPerRow,
  double PrefetchSourceLinesY,
  unsigned int SwathWidthY,
  double BytePerPixelDETY,
  double VInitPreFillY,
  unsigned int MaxNumSwathY,
  double PrefetchSourceLinesC,
  double BytePerPixelDETC,
  double VInitPreFillC,
  unsigned int MaxNumSwathC,
  unsigned int SwathHeightY,
  unsigned int SwathHeightC,
  double TWait,
  bool XFCEnabled,
  double XFCRemoteSurfaceFlipDelay,
  bool InterlaceEnable,
  bool ProgressiveToInterlaceUnitInOPP,
  double *DSTXAfterScaler,
  double *DSTYAfterScaler,
  double *DestinationLinesForPrefetch,
  double *PrefetchBandwidth,
  double *DestinationLinesToRequestVMInVBlank,
  double *DestinationLinesToRequestRowInVBlank,
  double *VRatioPrefetchY,
  double *VRatioPrefetchC,
  double *RequiredPrefetchPixDataBW,
  unsigned int *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,
  double *Tno_bw,
  unsigned int *VUpdateOffsetPix,
  double *VUpdateWidthPix,
  double *VReadyOffsetPix);
static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);
static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);
static double CalculatePrefetchSourceLines(
  struct display_mode_lib *mode_lib,
  double VRatio,
  double vtaps,
  bool Interlace,
  bool ProgressiveToInterlaceUnitInOPP,
  unsigned int SwathHeight,
  unsigned int ViewportYStart,
  double *VInitPreFill,
  unsigned int *MaxNumSwath);
static unsigned int CalculateVMAndRowBytes(
  struct display_mode_lib *mode_lib,
  bool DCCEnable,
  unsigned int BlockHeight256Bytes,
  unsigned int BlockWidth256Bytes,
  enum source_format_class SourcePixelFormat,
  unsigned int SurfaceTiling,
  unsigned int BytePerPixel,
  enum scan_direction_class ScanDirection,
  unsigned int ViewportWidth,
  unsigned int ViewportHeight,
  unsigned int SwathWidthY,
  bool GPUVMEnable,
  unsigned int VMMPageSize,
  unsigned int PTEBufferSizeInRequestsLuma,
  unsigned int PDEProcessingBufIn64KBReqs,
  unsigned int Pitch,
  unsigned int DCCMetaPitch,
  unsigned int *MacroTileWidth,
  unsigned int *MetaRowByte,
  unsigned int *PixelPTEBytesPerRow,
  bool *PTEBufferSizeNotExceeded,
  unsigned int *dpte_row_height,
  unsigned int *meta_row_height);
static double CalculateTWait(
  unsigned int PrefetchMode,
  double DRAMClockChangeLatency,
  double UrgentLatencyPixelDataOnly,
  double SREnterPlusExitTime);
static double CalculateRemoteSurfaceFlipDelay(
  struct display_mode_lib *mode_lib,
  double VRatio,
  double SwathWidth,
  double Bpp,
  double LineTime,
  double XFCTSlvVupdateOffset,
  double XFCTSlvVupdateWidth,
  double XFCTSlvVreadyOffset,
  double XFCXBUFLatencyTolerance,
  double XFCFillBWOverhead,
  double XFCSlvChunkSize,
  double XFCBusTransportTime,
  double TCalc,
  double TWait,
  double *SrcActiveDrainRate,
  double *TInitXFill,
  double *TslvChk);
static void CalculateActiveRowBandwidth(
  bool GPUVMEnable,
  enum source_format_class SourcePixelFormat,
  double VRatio,
  bool DCCEnable,
  double LineTime,
  unsigned int MetaRowByteLuma,
  unsigned int MetaRowByteChroma,
  unsigned int meta_row_height_luma,
  unsigned int meta_row_height_chroma,
  unsigned int PixelPTEBytesPerRowLuma,
  unsigned int PixelPTEBytesPerRowChroma,
  unsigned int dpte_row_height_luma,
  unsigned int dpte_row_height_chroma,
  double *meta_row_bw,
  double *dpte_row_bw,
  double *qual_row_bw);
static void CalculateFlipSchedule(
  struct display_mode_lib *mode_lib,
  double UrgentExtraLatency,
  double UrgentLatencyPixelDataOnly,
  unsigned int GPUVMMaxPageTableLevels,
  bool GPUVMEnable,
  double BandwidthAvailableForImmediateFlip,
  unsigned int TotImmediateFlipBytes,
  enum source_format_class SourcePixelFormat,
  unsigned int ImmediateFlipBytes,
  double LineTime,
  double VRatio,
  double Tno_bw,
  double PDEAndMetaPTEBytesFrame,
  unsigned int MetaRowByte,
  unsigned int PixelPTEBytesPerRow,
  bool DCCEnable,
  unsigned int dpte_row_height,
  unsigned int meta_row_height,
  double qual_row_bw,
  double *DestinationLinesToRequestVMInImmediateFlip,
  double *DestinationLinesToRequestRowInImmediateFlip,
  double *final_flip_bw,
  bool *ImmediateFlipSupportedForPipe);
static double CalculateWriteBackDelay(
  enum source_format_class WritebackPixelFormat,
  double WritebackHRatio,
  double WritebackVRatio,
  unsigned int WritebackLumaHTaps,
  unsigned int WritebackLumaVTaps,
  unsigned int WritebackChromaHTaps,
  unsigned int WritebackChromaVTaps,
  unsigned int WritebackDestinationWidth);

static void dml20_DisplayPipeConfiguration(struct display_mode_lib *mode_lib);
static void dml20_DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(
  struct display_mode_lib *mode_lib);

void dml20_recalculate(struct display_mode_lib *mode_lib)
{
 ModeSupportAndSystemConfiguration(mode_lib);
 mode_lib->vba.FabricAndDRAMBandwidth = dml_min(
  mode_lib->vba.DRAMSpeed * mode_lib->vba.NumberOfChannels * mode_lib->vba.DRAMChannelWidth,
  mode_lib->vba.FabricClock * mode_lib->vba.FabricDatapathToDCNDataReturn) / 1000.0;
 PixelClockAdjustmentForProgressiveToInterlaceUnit(mode_lib);
 dml20_DisplayPipeConfiguration(mode_lib);
 dml20_DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(mode_lib);
}

static double adjust_ReturnBW(
  struct display_mode_lib *mode_lib,
  double ReturnBW,
  bool DCCEnabledAnyPlane,
  double ReturnBandwidthToDCN)
{
 double CriticalCompression;

 if (DCCEnabledAnyPlane
   && ReturnBandwidthToDCN
     > mode_lib->vba.DCFCLK * mode_lib->vba.ReturnBusWidth / 4.0)
  ReturnBW =
    dml_min(
      ReturnBW,
      ReturnBandwidthToDCN * 4
        * (1.0
          - mode_lib->vba.UrgentLatencyPixelDataOnly
            / ((mode_lib->vba.ROBBufferSizeInKByte
              - mode_lib->vba.PixelChunkSizeInKByte)
              * 1024
              / ReturnBandwidthToDCN
              - mode_lib->vba.DCFCLK
                * mode_lib->vba.ReturnBusWidth
                / 4)
          + mode_lib->vba.UrgentLatencyPixelDataOnly));

 CriticalCompression = 2.0 * mode_lib->vba.ReturnBusWidth * mode_lib->vba.DCFCLK
   * mode_lib->vba.UrgentLatencyPixelDataOnly
   / (ReturnBandwidthToDCN * mode_lib->vba.UrgentLatencyPixelDataOnly
     + (mode_lib->vba.ROBBufferSizeInKByte
       - mode_lib->vba.PixelChunkSizeInKByte)
       * 1024);

 if (DCCEnabledAnyPlane && CriticalCompression > 1.0 && CriticalCompression < 4.0)
  ReturnBW =
    dml_min(
      ReturnBW,
      4.0 * ReturnBandwidthToDCN
        * (mode_lib->vba.ROBBufferSizeInKByte
          - mode_lib->vba.PixelChunkSizeInKByte)
        * 1024
        * mode_lib->vba.ReturnBusWidth
        * mode_lib->vba.DCFCLK
        * mode_lib->vba.UrgentLatencyPixelDataOnly
        / dml_pow(
          (ReturnBandwidthToDCN
            * mode_lib->vba.UrgentLatencyPixelDataOnly
            + (mode_lib->vba.ROBBufferSizeInKByte
              - mode_lib->vba.PixelChunkSizeInKByte)
              * 1024),
          2));

 return ReturnBW;
}

static unsigned int dscceComputeDelay(
  unsigned int bpc,
  double bpp,
  unsigned int sliceWidth,
  unsigned int numSlices,
  enum output_format_class pixelFormat)
{
# 316 "/home/nathan/src/linux-next/drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c"
 unsigned int rcModelSize = 8192;


 unsigned int pixelsPerClock, lstall, D, initalXmitDelay, w, s, ix, wx, p, l0, a, ax, l,
   Delay, pixels;

 if (pixelFormat == dm_n422 || pixelFormat == dm_420)
  pixelsPerClock = 2;

 else
  pixelsPerClock = 1;


 initalXmitDelay = dml_round(rcModelSize / 2.0 / bpp / pixelsPerClock);


 if (bpc == 8)
  D = 81;
 else if (bpc == 10)
  D = 89;
 else
  D = 113;


 w = sliceWidth / pixelsPerClock;


 if (pixelFormat == dm_s422)
  s = 1;
 else
  s = 0;


 ix = initalXmitDelay + 45;
 wx = (w + 2) / 3;
 p = 3 * wx - w;
 l0 = ix / w;
 a = ix + p * l0;
 ax = (a + 2) / 3 + D + 6 + 1;
 l = (ax + wx - 1) / wx;
 if ((ix % w) == 0 && p != 0)
  lstall = 1;
 else
  lstall = 0;
 Delay = l * wx * (numSlices - 1) + ax + s + lstall + 22;


 pixels = Delay * 3 * pixelsPerClock;
 return pixels;
}

static unsigned int dscComputeDelay(enum output_format_class pixelFormat)
{
 unsigned int Delay = 0;

 if (pixelFormat == dm_420) {

  Delay = Delay + 2;

  Delay = Delay + 0;

  Delay = Delay + 3;

  Delay = Delay + 2;

  Delay = Delay + 12;

  Delay = Delay + 13;

  Delay = Delay + 2;

  Delay = Delay + 7;

  Delay = Delay + 3;

  Delay = Delay + 2;

  Delay = Delay + 1;

  Delay = Delay + 1;
 } else if (pixelFormat == dm_n422) {

  Delay = Delay + 2;

  Delay = Delay + 1;

  Delay = Delay + 5;

  Delay = Delay + 25;

  Delay = Delay + 2;

  Delay = Delay + 10;

  Delay = Delay + 2;

  Delay = Delay + 1;

  Delay = Delay + 1;
 } else {

  Delay = Delay + 2;

  Delay = Delay + 0;

  Delay = Delay + 3;

  Delay = Delay + 12;

  Delay = Delay + 2;

  Delay = Delay + 7;

  Delay = Delay + 1;

  Delay = Delay + 2;

  Delay = Delay + 1;
 }

 return Delay;
}

static bool CalculatePrefetchSchedule(
  struct display_mode_lib *mode_lib,
  double DPPCLK,
  double DISPCLK,
  double PixelClock,
  double DCFCLKDeepSleep,
  unsigned int DSCDelay,
  unsigned int DPPPerPlane,
  bool ScalerEnabled,
  unsigned int NumberOfCursors,
  double DPPCLKDelaySubtotal,
  double DPPCLKDelaySCL,
  double DPPCLKDelaySCLLBOnly,
  double DPPCLKDelayCNVCFormater,
  double DPPCLKDelayCNVCCursor,
  double DISPCLKDelaySubtotal,
  unsigned int ScalerRecoutWidth,
  enum output_format_class OutputFormat,
  unsigned int VBlank,
  unsigned int HTotal,
  unsigned int MaxInterDCNTileRepeaters,
  unsigned int VStartup,
  unsigned int PageTableLevels,
  bool GPUVMEnable,
  bool DynamicMetadataEnable,
  unsigned int DynamicMetadataLinesBeforeActiveRequired,
  unsigned int DynamicMetadataTransmittedBytes,
  bool DCCEnable,
  double UrgentLatencyPixelDataOnly,
  double UrgentExtraLatency,
  double TCalc,
  unsigned int PDEAndMetaPTEBytesFrame,
  unsigned int MetaRowByte,
  unsigned int PixelPTEBytesPerRow,
  double PrefetchSourceLinesY,
  unsigned int SwathWidthY,
  double BytePerPixelDETY,
  double VInitPreFillY,
  unsigned int MaxNumSwathY,
  double PrefetchSourceLinesC,
  double BytePerPixelDETC,
  double VInitPreFillC,
  unsigned int MaxNumSwathC,
  unsigned int SwathHeightY,
  unsigned int SwathHeightC,
  double TWait,
  bool XFCEnabled,
  double XFCRemoteSurfaceFlipDelay,
  bool InterlaceEnable,
  bool ProgressiveToInterlaceUnitInOPP,
  double *DSTXAfterScaler,
  double *DSTYAfterScaler,
  double *DestinationLinesForPrefetch,
  double *PrefetchBandwidth,
  double *DestinationLinesToRequestVMInVBlank,
  double *DestinationLinesToRequestRowInVBlank,
  double *VRatioPrefetchY,
  double *VRatioPrefetchC,
  double *RequiredPrefetchPixDataBW,
  unsigned int *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,
  double *Tno_bw,
  unsigned int *VUpdateOffsetPix,
  double *VUpdateWidthPix,
  double *VReadyOffsetPix)
{
 bool MyError = false;
 unsigned int DPPCycles, DISPCLKCycles;
 double DSTTotalPixelsAfterScaler, TotalRepeaterDelayTime;
 double Tdm, LineTime, Tsetup;
 double dst_y_prefetch_equ;
 double Tsw_oto;
 double prefetch_bw_oto;
 double Tvm_oto;
 double Tr0_oto;
 double Tpre_oto;
 double dst_y_prefetch_oto;
 double TimeForFetchingMetaPTE = 0;
 double TimeForFetchingRowInVBlank = 0;
 double LinesToRequestPrefetchPixelData = 0;

 if (ScalerEnabled)
  DPPCycles = DPPCLKDelaySubtotal + DPPCLKDelaySCL;
 else
  DPPCycles = DPPCLKDelaySubtotal + DPPCLKDelaySCLLBOnly;

 DPPCycles = DPPCycles + DPPCLKDelayCNVCFormater + NumberOfCursors * DPPCLKDelayCNVCCursor;

 DISPCLKCycles = DISPCLKDelaySubtotal;

 if (DPPCLK == 0.0 || DISPCLK == 0.0)
  return true;

 *DSTXAfterScaler = DPPCycles * PixelClock / DPPCLK + DISPCLKCycles * PixelClock / DISPCLK
   + DSCDelay;

 if (DPPPerPlane > 1)
  *DSTXAfterScaler = *DSTXAfterScaler + ScalerRecoutWidth;

 if (OutputFormat == dm_420 || (InterlaceEnable && ProgressiveToInterlaceUnitInOPP))
  *DSTYAfterScaler = 1;
 else
  *DSTYAfterScaler = 0;

 DSTTotalPixelsAfterScaler = ((double) (*DSTYAfterScaler * HTotal)) + *DSTXAfterScaler;
 *DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / HTotal, 1);
 *DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * HTotal));

 *VUpdateOffsetPix = dml_ceil(HTotal / 4.0, 1);
 TotalRepeaterDelayTime = MaxInterDCNTileRepeaters * (2.0 / DPPCLK + 3.0 / DISPCLK);
 *VUpdateWidthPix = (14.0 / DCFCLKDeepSleep + 12.0 / DPPCLK + TotalRepeaterDelayTime)
   * PixelClock;

 *VReadyOffsetPix = dml_max(
   150.0 / DPPCLK,
   TotalRepeaterDelayTime + 20.0 / DCFCLKDeepSleep + 10.0 / DPPCLK)
   * PixelClock;

 Tsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;

 LineTime = (double) HTotal / PixelClock;

 if (DynamicMetadataEnable) {
  double Tdmbf, Tdmec, Tdmsks;

  Tdm = dml_max(0.0, UrgentExtraLatency - TCalc);
  Tdmbf = DynamicMetadataTransmittedBytes / 4.0 / DISPCLK;
  Tdmec = LineTime;
  if (DynamicMetadataLinesBeforeActiveRequired == 0)
   Tdmsks = VBlank * LineTime / 2.0;
  else
   Tdmsks = DynamicMetadataLinesBeforeActiveRequired * LineTime;
  if (InterlaceEnable && !ProgressiveToInterlaceUnitInOPP)
   Tdmsks = Tdmsks / 2;
  if (VStartup * LineTime
    < Tsetup + TWait + UrgentExtraLatency + Tdmbf + Tdmec + Tdmsks) {
   MyError = true;
   *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata = (Tsetup + TWait
     + UrgentExtraLatency + Tdmbf + Tdmec + Tdmsks) / LineTime;
  } else
   *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata = 0.0;
 } else
  Tdm = 0;

 if (GPUVMEnable) {
  if (PageTableLevels == 4)
   *Tno_bw = UrgentExtraLatency + UrgentLatencyPixelDataOnly;
  else if (PageTableLevels == 3)
   *Tno_bw = UrgentExtraLatency;
  else
   *Tno_bw = 0;
 } else if (DCCEnable)
  *Tno_bw = LineTime;
 else
  *Tno_bw = LineTime / 4;

 dst_y_prefetch_equ = VStartup - dml_max(TCalc + TWait, XFCRemoteSurfaceFlipDelay) / LineTime
   - (Tsetup + Tdm) / LineTime
   - (*DSTYAfterScaler + *DSTXAfterScaler / HTotal);

 Tsw_oto = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) * LineTime;

 prefetch_bw_oto = (MetaRowByte + PixelPTEBytesPerRow
   + PrefetchSourceLinesY * SwathWidthY * dml_ceil(BytePerPixelDETY, 1)
   + PrefetchSourceLinesC * SwathWidthY / 2 * dml_ceil(BytePerPixelDETC, 2))
   / Tsw_oto;

 if (GPUVMEnable == true) {
  Tvm_oto =
    dml_max(
      *Tno_bw + PDEAndMetaPTEBytesFrame / prefetch_bw_oto,
      dml_max(
        UrgentExtraLatency
          + UrgentLatencyPixelDataOnly
            * (PageTableLevels
              - 1),
        LineTime / 4.0));
 } else
  Tvm_oto = LineTime / 4.0;

 if ((GPUVMEnable == true || DCCEnable == true)) {
  Tr0_oto = dml_max(
    (MetaRowByte + PixelPTEBytesPerRow) / prefetch_bw_oto,
    dml_max(UrgentLatencyPixelDataOnly, dml_max(LineTime - Tvm_oto, LineTime / 4)));
 } else
  Tr0_oto = LineTime - Tvm_oto;

 Tpre_oto = Tvm_oto + Tr0_oto + Tsw_oto;

 dst_y_prefetch_oto = Tpre_oto / LineTime;

 if (dst_y_prefetch_oto < dst_y_prefetch_equ)
  *DestinationLinesForPrefetch = dst_y_prefetch_oto;
 else
  *DestinationLinesForPrefetch = dst_y_prefetch_equ;

 *DestinationLinesForPrefetch = dml_floor(4.0 * (*DestinationLinesForPrefetch + 0.125), 1)
   / 4;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug177 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: VStartup: %d\n"), .lineno = 637, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug177.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug177.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug177.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug177.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug177, "[DML]:""DML: VStartup: %d\n", VStartup); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug178 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: TCalc: %f\n"), .lineno = 638, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug178.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug178.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug178.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug178.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug178, "[DML]:""DML: TCalc: %f\n", TCalc); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug179 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: TWait: %f\n"), .lineno = 639, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug179.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug179.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug179.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug179.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug179, "[DML]:""DML: TWait: %f\n", TWait); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug180 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: XFCRemoteSurfaceFlipDelay: %f\n"), .lineno = 640, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug180.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug180.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug180.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug180.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug180, "[DML]:""DML: XFCRemoteSurfaceFlipDelay: %f\n", XFCRemoteSurfaceFlipDelay); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug181 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: LineTime: %f\n"), .lineno = 641, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug181.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug181.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug181.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug181.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug181, "[DML]:""DML: LineTime: %f\n", LineTime); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug182 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: Tsetup: %f\n"), .lineno = 642, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug182.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug182.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug182.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug182.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug182, "[DML]:""DML: Tsetup: %f\n", Tsetup); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug183 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: Tdm: %f\n"), .lineno = 643, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug183.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug183.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug183.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug183.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug183, "[DML]:""DML: Tdm: %f\n", Tdm); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug184 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: DSTYAfterScaler: %f\n"), .lineno = 644, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug184.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug184.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug184.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug184.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug184, "[DML]:""DML: DSTYAfterScaler: %f\n", *DSTYAfterScaler); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug185 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: DSTXAfterScaler: %f\n"), .lineno = 645, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug185.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug185.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug185.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug185.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug185, "[DML]:""DML: DSTXAfterScaler: %f\n", *DSTXAfterScaler); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug186 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: HTotal: %d\n"), .lineno = 646, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug186.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug186.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug186.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug186.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug186, "[DML]:""DML: HTotal: %d\n", HTotal); } while (0); };

 *PrefetchBandwidth = 0;
 *DestinationLinesToRequestVMInVBlank = 0;
 *DestinationLinesToRequestRowInVBlank = 0;
 *VRatioPrefetchY = 0;
 *VRatioPrefetchC = 0;
 *RequiredPrefetchPixDataBW = 0;
 if (*DestinationLinesForPrefetch > 1) {
  *PrefetchBandwidth = (PDEAndMetaPTEBytesFrame + 2 * MetaRowByte
    + 2 * PixelPTEBytesPerRow
    + PrefetchSourceLinesY * SwathWidthY * dml_ceil(BytePerPixelDETY, 1)
    + PrefetchSourceLinesC * SwathWidthY / 2
      * dml_ceil(BytePerPixelDETC, 2))
    / (*DestinationLinesForPrefetch * LineTime - *Tno_bw);
  if (GPUVMEnable) {
   TimeForFetchingMetaPTE =
     dml_max(
       *Tno_bw
         + (double) PDEAndMetaPTEBytesFrame
           / *PrefetchBandwidth,
       dml_max(
         UrgentExtraLatency
           + UrgentLatencyPixelDataOnly
             * (PageTableLevels
               - 1),
         LineTime / 4));
  } else {
   if (NumberOfCursors > 0 || XFCEnabled)
    TimeForFetchingMetaPTE = LineTime / 4;
   else
    TimeForFetchingMetaPTE = 0.0;
  }

  if ((GPUVMEnable == true || DCCEnable == true)) {
   TimeForFetchingRowInVBlank =
     dml_max(
       (MetaRowByte + PixelPTEBytesPerRow)
         / *PrefetchBandwidth,
       dml_max(
         UrgentLatencyPixelDataOnly,
         dml_max(
           LineTime
             - TimeForFetchingMetaPTE,
           LineTime
             / 4.0)));
  } else {
   if (NumberOfCursors > 0 || XFCEnabled)
    TimeForFetchingRowInVBlank = LineTime - TimeForFetchingMetaPTE;
   else
    TimeForFetchingRowInVBlank = 0.0;
  }

  *DestinationLinesToRequestVMInVBlank = dml_floor(
    4.0 * (TimeForFetchingMetaPTE / LineTime + 0.125),
    1) / 4.0;

  *DestinationLinesToRequestRowInVBlank = dml_floor(
    4.0 * (TimeForFetchingRowInVBlank / LineTime + 0.125),
    1) / 4.0;

  LinesToRequestPrefetchPixelData =
    *DestinationLinesForPrefetch
      - ((NumberOfCursors > 0 || GPUVMEnable
        || DCCEnable) ?
        (*DestinationLinesToRequestVMInVBlank
          + *DestinationLinesToRequestRowInVBlank) :
        0.0);

  if (LinesToRequestPrefetchPixelData > 0) {

   *VRatioPrefetchY = (double) PrefetchSourceLinesY
     / LinesToRequestPrefetchPixelData;
   *VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);
   if ((SwathHeightY > 4) && (VInitPreFillY > 3)) {
    if (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {
     *VRatioPrefetchY =
       dml_max(
         (double) PrefetchSourceLinesY
           / LinesToRequestPrefetchPixelData,
         (double) MaxNumSwathY
           * SwathHeightY
           / (LinesToRequestPrefetchPixelData
             - (VInitPreFillY
               - 3.0)
               / 2.0));
     *VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);
    } else {
     MyError = true;
     *VRatioPrefetchY = 0;
    }
   }

   *VRatioPrefetchC = (double) PrefetchSourceLinesC
     / LinesToRequestPrefetchPixelData;
   *VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);

   if ((SwathHeightC > 4)) {
    if (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {
     *VRatioPrefetchC =
       dml_max(
         *VRatioPrefetchC,
         (double) MaxNumSwathC
           * SwathHeightC
           / (LinesToRequestPrefetchPixelData
             - (VInitPreFillC
               - 3.0)
               / 2.0));
     *VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);
    } else {
     MyError = true;
     *VRatioPrefetchC = 0;
    }
   }

   *RequiredPrefetchPixDataBW =
     DPPPerPlane
       * ((double) PrefetchSourceLinesY
         / LinesToRequestPrefetchPixelData
         * dml_ceil(
           BytePerPixelDETY,
           1)
         + (double) PrefetchSourceLinesC
           / LinesToRequestPrefetchPixelData
           * dml_ceil(
             BytePerPixelDETC,
             2)
           / 2)
       * SwathWidthY / LineTime;
  } else {
   MyError = true;
   *VRatioPrefetchY = 0;
   *VRatioPrefetchC = 0;
   *RequiredPrefetchPixDataBW = 0;
  }

 } else {
  MyError = true;
 }

 if (MyError) {
  *PrefetchBandwidth = 0;
  TimeForFetchingMetaPTE = 0;
  TimeForFetchingRowInVBlank = 0;
  *DestinationLinesToRequestVMInVBlank = 0;
  *DestinationLinesToRequestRowInVBlank = 0;
  *DestinationLinesForPrefetch = 0;
  LinesToRequestPrefetchPixelData = 0;
  *VRatioPrefetchY = 0;
  *VRatioPrefetchC = 0;
  *RequiredPrefetchPixDataBW = 0;
 }

 return MyError;
}

static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)
{
 return VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);
}

static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)
{
 return VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);
}

static double CalculatePrefetchSourceLines(
  struct display_mode_lib *mode_lib,
  double VRatio,
  double vtaps,
  bool Interlace,
  bool ProgressiveToInterlaceUnitInOPP,
  unsigned int SwathHeight,
  unsigned int ViewportYStart,
  double *VInitPreFill,
  unsigned int *MaxNumSwath)
{
 unsigned int MaxPartialSwath;

 if (ProgressiveToInterlaceUnitInOPP)
  *VInitPreFill = dml_floor((VRatio + vtaps + 1) / 2.0, 1);
 else
  *VInitPreFill = dml_floor((VRatio + vtaps + 1 + Interlace * 0.5 * VRatio) / 2.0, 1);

 if (!mode_lib->vba.IgnoreViewportPositioning) {

  *MaxNumSwath = dml_ceil((*VInitPreFill - 1.0) / SwathHeight, 1) + 1.0;

  if (*VInitPreFill > 1.0)
   MaxPartialSwath = (unsigned int) (*VInitPreFill - 2) % SwathHeight;
  else
   MaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 2)
     % SwathHeight;
  MaxPartialSwath = dml_max(1U, MaxPartialSwath);

 } else {

  if (ViewportYStart != 0)
   {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug187 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""WARNING DML: using viewport y position of 0 even though actual viewport y position is non-zero in prefetch source lines calculation\n"), .lineno = 845, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug187.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug187.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug187.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug187.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug187, "[DML]:""WARNING DML: using viewport y position of 0 even though actual viewport y position is non-zero in prefetch source lines calculation\n"); } while (0); };


  *MaxNumSwath = dml_ceil(*VInitPreFill / SwathHeight, 1);

  if (*VInitPreFill > 1.0)
   MaxPartialSwath = (unsigned int) (*VInitPreFill - 1) % SwathHeight;
  else
   MaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 1)
     % SwathHeight;
 }

 return *MaxNumSwath * SwathHeight + MaxPartialSwath;
}

static unsigned int CalculateVMAndRowBytes(
  struct display_mode_lib *mode_lib,
  bool DCCEnable,
  unsigned int BlockHeight256Bytes,
  unsigned int BlockWidth256Bytes,
  enum source_format_class SourcePixelFormat,
  unsigned int SurfaceTiling,
  unsigned int BytePerPixel,
  enum scan_direction_class ScanDirection,
  unsigned int ViewportWidth,
  unsigned int ViewportHeight,
  unsigned int SwathWidth,
  bool GPUVMEnable,
  unsigned int VMMPageSize,
  unsigned int PTEBufferSizeInRequestsLuma,
  unsigned int PDEProcessingBufIn64KBReqs,
  unsigned int Pitch,
  unsigned int DCCMetaPitch,
  unsigned int *MacroTileWidth,
  unsigned int *MetaRowByte,
  unsigned int *PixelPTEBytesPerRow,
  bool *PTEBufferSizeNotExceeded,
  unsigned int *dpte_row_height,
  unsigned int *meta_row_height)
{
 unsigned int MetaRequestHeight;
 unsigned int MetaRequestWidth;
 unsigned int MetaSurfWidth;
 unsigned int MetaSurfHeight;
 unsigned int MPDEBytesFrame;
 unsigned int MetaPTEBytesFrame;
 unsigned int DCCMetaSurfaceBytes;

 unsigned int MacroTileSizeBytes;
 unsigned int MacroTileHeight;
 unsigned int DPDE0BytesFrame;
 unsigned int ExtraDPDEBytesFrame;
 unsigned int PDEAndMetaPTEBytesFrame;

 if (DCCEnable == true) {
  MetaRequestHeight = 8 * BlockHeight256Bytes;
  MetaRequestWidth = 8 * BlockWidth256Bytes;
  if (ScanDirection == dm_horz) {
   *meta_row_height = MetaRequestHeight;
   MetaSurfWidth = dml_ceil((double) SwathWidth - 1, MetaRequestWidth)
     + MetaRequestWidth;
   *MetaRowByte = MetaSurfWidth * MetaRequestHeight * BytePerPixel / 256.0;
  } else {
   *meta_row_height = MetaRequestWidth;
   MetaSurfHeight = dml_ceil((double) SwathWidth - 1, MetaRequestHeight)
     + MetaRequestHeight;
   *MetaRowByte = MetaSurfHeight * MetaRequestWidth * BytePerPixel / 256.0;
  }
  if (ScanDirection == dm_horz) {
   DCCMetaSurfaceBytes = DCCMetaPitch
     * (dml_ceil(ViewportHeight - 1, 64 * BlockHeight256Bytes)
       + 64 * BlockHeight256Bytes) * BytePerPixel
     / 256;
  } else {
   DCCMetaSurfaceBytes = DCCMetaPitch
     * (dml_ceil(
       (double) ViewportHeight - 1,
       64 * BlockHeight256Bytes)
       + 64 * BlockHeight256Bytes) * BytePerPixel
     / 256;
  }
  if (GPUVMEnable == true) {
   MetaPTEBytesFrame = (dml_ceil(
     (double) (DCCMetaSurfaceBytes - VMMPageSize)
       / (8 * VMMPageSize),
     1) + 1) * 64;
   MPDEBytesFrame = 128 * (mode_lib->vba.GPUVMMaxPageTableLevels - 1);
  } else {
   MetaPTEBytesFrame = 0;
   MPDEBytesFrame = 0;
  }
 } else {
  MetaPTEBytesFrame = 0;
  MPDEBytesFrame = 0;
  *MetaRowByte = 0;
 }

 if (SurfaceTiling == dm_sw_linear || SurfaceTiling == dm_sw_gfx7_2d_thin_gl || SurfaceTiling == dm_sw_gfx7_2d_thin_l_vp) {
  MacroTileSizeBytes = 256;
  MacroTileHeight = BlockHeight256Bytes;
 } else if (SurfaceTiling == dm_sw_4kb_s || SurfaceTiling == dm_sw_4kb_s_x
   || SurfaceTiling == dm_sw_4kb_d || SurfaceTiling == dm_sw_4kb_d_x) {
  MacroTileSizeBytes = 4096;
  MacroTileHeight = 4 * BlockHeight256Bytes;
 } else if (SurfaceTiling == dm_sw_64kb_s || SurfaceTiling == dm_sw_64kb_s_t
   || SurfaceTiling == dm_sw_64kb_s_x || SurfaceTiling == dm_sw_64kb_d
   || SurfaceTiling == dm_sw_64kb_d_t || SurfaceTiling == dm_sw_64kb_d_x
   || SurfaceTiling == dm_sw_64kb_r_x) {
  MacroTileSizeBytes = 65536;
  MacroTileHeight = 16 * BlockHeight256Bytes;
 } else {
  MacroTileSizeBytes = 262144;
  MacroTileHeight = 32 * BlockHeight256Bytes;
 }
 *MacroTileWidth = MacroTileSizeBytes / BytePerPixel / MacroTileHeight;

 if (GPUVMEnable == true && mode_lib->vba.GPUVMMaxPageTableLevels > 1) {
  if (ScanDirection == dm_horz) {
   DPDE0BytesFrame =
     64
       * (dml_ceil(
         ((Pitch
           * (dml_ceil(
             ViewportHeight
               - 1,
             MacroTileHeight)
             + MacroTileHeight)
           * BytePerPixel)
           - MacroTileSizeBytes)
           / (8
             * 2097152),
         1) + 1);
  } else {
   DPDE0BytesFrame =
     64
       * (dml_ceil(
         ((Pitch
           * (dml_ceil(
             (double) SwathWidth
               - 1,
             MacroTileHeight)
             + MacroTileHeight)
           * BytePerPixel)
           - MacroTileSizeBytes)
           / (8
             * 2097152),
         1) + 1);
  }
  ExtraDPDEBytesFrame = 128 * (mode_lib->vba.GPUVMMaxPageTableLevels - 2);
 } else {
  DPDE0BytesFrame = 0;
  ExtraDPDEBytesFrame = 0;
 }

 PDEAndMetaPTEBytesFrame = MetaPTEBytesFrame + MPDEBytesFrame + DPDE0BytesFrame
   + ExtraDPDEBytesFrame;

 if (GPUVMEnable == true) {
  unsigned int PTERequestSize;
  unsigned int PixelPTEReqHeight;
  unsigned int PixelPTEReqWidth;
  double FractionOfPTEReturnDrop;
  unsigned int EffectivePDEProcessingBufIn64KBReqs;

  if (SurfaceTiling == dm_sw_linear) {
   PixelPTEReqHeight = 1;
   PixelPTEReqWidth = 8.0 * VMMPageSize / BytePerPixel;
   PTERequestSize = 64;
   FractionOfPTEReturnDrop = 0;
  } else if (MacroTileSizeBytes == 4096) {
   PixelPTEReqHeight = MacroTileHeight;
   PixelPTEReqWidth = 8 * *MacroTileWidth;
   PTERequestSize = 64;
   if (ScanDirection == dm_horz)
    FractionOfPTEReturnDrop = 0;
   else
    FractionOfPTEReturnDrop = 7 / 8;
  } else if (VMMPageSize == 4096 && MacroTileSizeBytes > 4096) {
   PixelPTEReqHeight = 16 * BlockHeight256Bytes;
   PixelPTEReqWidth = 16 * BlockWidth256Bytes;
   PTERequestSize = 128;
   FractionOfPTEReturnDrop = 0;
  } else {
   PixelPTEReqHeight = MacroTileHeight;
   PixelPTEReqWidth = 8 * *MacroTileWidth;
   PTERequestSize = 64;
   FractionOfPTEReturnDrop = 0;
  }

  if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10)
   EffectivePDEProcessingBufIn64KBReqs = PDEProcessingBufIn64KBReqs / 2;
  else
   EffectivePDEProcessingBufIn64KBReqs = PDEProcessingBufIn64KBReqs;

  if (SurfaceTiling == dm_sw_linear) {
   *dpte_row_height =
     dml_min(
       128,
       1
         << (unsigned int) dml_floor(
           dml_log2(
             dml_min(
               (double) PTEBufferSizeInRequestsLuma
                 * PixelPTEReqWidth,
               EffectivePDEProcessingBufIn64KBReqs
                 * 65536.0
                 / BytePerPixel)
               / Pitch),
           1));
   *PixelPTEBytesPerRow = PTERequestSize
     * (dml_ceil(
       (double) (Pitch * *dpte_row_height - 1)
         / PixelPTEReqWidth,
       1) + 1);
  } else if (ScanDirection == dm_horz) {
   *dpte_row_height = PixelPTEReqHeight;
   *PixelPTEBytesPerRow = PTERequestSize
     * (dml_ceil(((double) SwathWidth - 1) / PixelPTEReqWidth, 1)
       + 1);
  } else {
   *dpte_row_height = dml_min(PixelPTEReqWidth, *MacroTileWidth);
   *PixelPTEBytesPerRow = PTERequestSize
     * (dml_ceil(
       ((double) SwathWidth - 1)
         / PixelPTEReqHeight,
       1) + 1);
  }
  if (*PixelPTEBytesPerRow * (1 - FractionOfPTEReturnDrop)
    <= 64 * PTEBufferSizeInRequestsLuma) {
   *PTEBufferSizeNotExceeded = true;
  } else {
   *PTEBufferSizeNotExceeded = false;
  }
 } else {
  *PixelPTEBytesPerRow = 0;
  *PTEBufferSizeNotExceeded = true;
 }

 return PDEAndMetaPTEBytesFrame;
}

static void dml20_DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(
  struct display_mode_lib *mode_lib)
{
 unsigned int j, k;

 mode_lib->vba.WritebackDISPCLK = 0.0;
 mode_lib->vba.DISPCLKWithRamping = 0;
 mode_lib->vba.DISPCLKWithoutRamping = 0;
 mode_lib->vba.GlobalDPPCLK = 0.0;



 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.WritebackEnable[k]) {
   mode_lib->vba.WritebackDISPCLK =
     dml_max(
       mode_lib->vba.WritebackDISPCLK,
       CalculateWriteBackDISPCLK(
         mode_lib->vba.WritebackPixelFormat[k],
         mode_lib->vba.PixelClock[k],
         mode_lib->vba.WritebackHRatio[k],
         mode_lib->vba.WritebackVRatio[k],
         mode_lib->vba.WritebackLumaHTaps[k],
         mode_lib->vba.WritebackLumaVTaps[k],
         mode_lib->vba.WritebackChromaHTaps[k],
         mode_lib->vba.WritebackChromaVTaps[k],
         mode_lib->vba.WritebackDestinationWidth[k],
         mode_lib->vba.HTotal[k],
         mode_lib->vba.WritebackChromaLineBufferWidth));
  }
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.HRatio[k] > 1) {
   mode_lib->vba.PSCL_THROUGHPUT_LUMA[k] = dml_min(
     mode_lib->vba.MaxDCHUBToPSCLThroughput,
     mode_lib->vba.MaxPSCLToLBThroughput
       * mode_lib->vba.HRatio[k]
       / dml_ceil(
         mode_lib->vba.htaps[k]
           / 6.0,
         1));
  } else {
   mode_lib->vba.PSCL_THROUGHPUT_LUMA[k] = dml_min(
     mode_lib->vba.MaxDCHUBToPSCLThroughput,
     mode_lib->vba.MaxPSCLToLBThroughput);
  }

  mode_lib->vba.DPPCLKUsingSingleDPPLuma =
    mode_lib->vba.PixelClock[k]
      * dml_max(
        mode_lib->vba.vtaps[k] / 6.0
          * dml_min(
            1.0,
            mode_lib->vba.HRatio[k]),
        dml_max(
          mode_lib->vba.HRatio[k]
            * mode_lib->vba.VRatio[k]
            / mode_lib->vba.PSCL_THROUGHPUT_LUMA[k],
          1.0));

  if ((mode_lib->vba.htaps[k] > 6 || mode_lib->vba.vtaps[k] > 6)
    && mode_lib->vba.DPPCLKUsingSingleDPPLuma
      < 2 * mode_lib->vba.PixelClock[k]) {
   mode_lib->vba.DPPCLKUsingSingleDPPLuma = 2 * mode_lib->vba.PixelClock[k];
  }

  if ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8
    && mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {
   mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k] = 0.0;
   mode_lib->vba.DPPCLKUsingSingleDPP[k] =
     mode_lib->vba.DPPCLKUsingSingleDPPLuma;
  } else {
   if (mode_lib->vba.HRatio[k] > 1) {
    mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k] =
      dml_min(
        mode_lib->vba.MaxDCHUBToPSCLThroughput,
        mode_lib->vba.MaxPSCLToLBThroughput
          * mode_lib->vba.HRatio[k]
          / 2
          / dml_ceil(
            mode_lib->vba.HTAPsChroma[k]
              / 6.0,
            1.0));
   } else {
    mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k] = dml_min(
      mode_lib->vba.MaxDCHUBToPSCLThroughput,
      mode_lib->vba.MaxPSCLToLBThroughput);
   }
   mode_lib->vba.DPPCLKUsingSingleDPPChroma =
     mode_lib->vba.PixelClock[k]
       * dml_max(
         mode_lib->vba.VTAPsChroma[k]
           / 6.0
           * dml_min(
             1.0,
             mode_lib->vba.HRatio[k]
               / 2),
         dml_max(
           mode_lib->vba.HRatio[k]
             * mode_lib->vba.VRatio[k]
             / 4
             / mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k],
           1.0));

   if ((mode_lib->vba.HTAPsChroma[k] > 6 || mode_lib->vba.VTAPsChroma[k] > 6)
     && mode_lib->vba.DPPCLKUsingSingleDPPChroma
       < 2 * mode_lib->vba.PixelClock[k]) {
    mode_lib->vba.DPPCLKUsingSingleDPPChroma = 2
      * mode_lib->vba.PixelClock[k];
   }

   mode_lib->vba.DPPCLKUsingSingleDPP[k] = dml_max(
     mode_lib->vba.DPPCLKUsingSingleDPPLuma,
     mode_lib->vba.DPPCLKUsingSingleDPPChroma);
  }
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.BlendingAndTiming[k] != k)
   continue;
  if (mode_lib->vba.ODMCombineEnabled[k]) {
   mode_lib->vba.DISPCLKWithRamping =
     dml_max(
       mode_lib->vba.DISPCLKWithRamping,
       mode_lib->vba.PixelClock[k] / 2
         * (1
           + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
             / 100)
         * (1
           + mode_lib->vba.DISPCLKRampingMargin
             / 100));
   mode_lib->vba.DISPCLKWithoutRamping =
     dml_max(
       mode_lib->vba.DISPCLKWithoutRamping,
       mode_lib->vba.PixelClock[k] / 2
         * (1
           + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
             / 100));
  } else if (!mode_lib->vba.ODMCombineEnabled[k]) {
   mode_lib->vba.DISPCLKWithRamping =
     dml_max(
       mode_lib->vba.DISPCLKWithRamping,
       mode_lib->vba.PixelClock[k]
         * (1
           + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
             / 100)
         * (1
           + mode_lib->vba.DISPCLKRampingMargin
             / 100));
   mode_lib->vba.DISPCLKWithoutRamping =
     dml_max(
       mode_lib->vba.DISPCLKWithoutRamping,
       mode_lib->vba.PixelClock[k]
         * (1
           + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
             / 100));
  }
 }

 mode_lib->vba.DISPCLKWithRamping = dml_max(
   mode_lib->vba.DISPCLKWithRamping,
   mode_lib->vba.WritebackDISPCLK);
 mode_lib->vba.DISPCLKWithoutRamping = dml_max(
   mode_lib->vba.DISPCLKWithoutRamping,
   mode_lib->vba.WritebackDISPCLK);

 ({ int __ret_warn_on = !!(!(mode_lib->vba.DISPCLKDPPCLKVCOSpeed != 0)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c"), "i" (1252), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 mode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(
   mode_lib->vba.DISPCLKWithRamping,
   mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
 mode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(
   mode_lib->vba.DISPCLKWithoutRamping,
   mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
 mode_lib->vba.MaxDispclkRoundedToDFSGranularity = RoundToDFSGranularityDown(
   mode_lib->vba.soc.clock_limits[mode_lib->vba.soc.num_states].dispclk_mhz,
   mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
 if (mode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity
   > mode_lib->vba.MaxDispclkRoundedToDFSGranularity) {
  mode_lib->vba.DISPCLK_calculated =
    mode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity;
 } else if (mode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity
   > mode_lib->vba.MaxDispclkRoundedToDFSGranularity) {
  mode_lib->vba.DISPCLK_calculated = mode_lib->vba.MaxDispclkRoundedToDFSGranularity;
 } else {
  mode_lib->vba.DISPCLK_calculated =
    mode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity;
 }
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug188 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   dispclk_mhz (calculated) = %f"), .lineno = 1273, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug188.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug188.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug188.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug188.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug188, "[DML]:""   dispclk_mhz (calculated) = %f", mode_lib->vba.DISPCLK_calculated); } while (0); };

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.DPPPerPlane[k] == 0) {
   mode_lib->vba.DPPCLK_calculated[k] = 0;
  } else {
   mode_lib->vba.DPPCLK_calculated[k] = mode_lib->vba.DPPCLKUsingSingleDPP[k]
     / mode_lib->vba.DPPPerPlane[k]
     * (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100);
  }
  mode_lib->vba.GlobalDPPCLK = dml_max(
    mode_lib->vba.GlobalDPPCLK,
    mode_lib->vba.DPPCLK_calculated[k]);
 }
 mode_lib->vba.GlobalDPPCLK = RoundToDFSGranularityUp(
   mode_lib->vba.GlobalDPPCLK,
   mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.DPPCLK_calculated[k] = mode_lib->vba.GlobalDPPCLK / 255
    * dml_ceil(
      mode_lib->vba.DPPCLK_calculated[k] * 255
        / mode_lib->vba.GlobalDPPCLK,
      1);
  {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug189 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   dppclk_mhz[%i] (calculated) = %f"), .lineno = 1296, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug189.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug189.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug189.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug189.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug189, "[DML]:""   dppclk_mhz[%i] (calculated) = %f", k, mode_lib->vba.DPPCLK_calculated[k]); } while (0); };
 }


 mode_lib->vba.DCCEnabledAnyPlane = false;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)
  if (mode_lib->vba.DCCEnable[k])
   mode_lib->vba.DCCEnabledAnyPlane = true;

 mode_lib->vba.ReturnBandwidthToDCN = dml_min(
   mode_lib->vba.ReturnBusWidth * mode_lib->vba.DCFCLK,
   mode_lib->vba.FabricAndDRAMBandwidth * 1000)
   * mode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly / 100;

 mode_lib->vba.ReturnBW = mode_lib->vba.ReturnBandwidthToDCN;
 mode_lib->vba.ReturnBW = adjust_ReturnBW(
   mode_lib,
   mode_lib->vba.ReturnBW,
   mode_lib->vba.DCCEnabledAnyPlane,
   mode_lib->vba.ReturnBandwidthToDCN);


 mode_lib->vba.ReturnBandwidthToDCN = dml_min(
   mode_lib->vba.ReturnBusWidth * mode_lib->vba.DCFCLK,
   mode_lib->vba.FabricAndDRAMBandwidth * 1000);
 mode_lib->vba.ReturnBW = adjust_ReturnBW(
   mode_lib,
   mode_lib->vba.ReturnBW,
   mode_lib->vba.DCCEnabledAnyPlane,
   mode_lib->vba.ReturnBandwidthToDCN);

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug190 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   dcfclk_mhz         = %f"), .lineno = 1327, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug190.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug190.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug190.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug190.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug190, "[DML]:""   dcfclk_mhz         = %f", mode_lib->vba.DCFCLK); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug191 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   return_bw_to_dcn   = %f"), .lineno = 1328, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug191.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug191.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug191.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug191.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug191, "[DML]:""   return_bw_to_dcn   = %f", mode_lib->vba.ReturnBandwidthToDCN); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug192 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   return_bus_bw      = %f"), .lineno = 1329, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug192.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug192.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug192.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug192.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug192, "[DML]:""   return_bus_bw      = %f", mode_lib->vba.ReturnBW); } while (0); };

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  bool MainPlaneDoesODMCombine = false;

  if (mode_lib->vba.SourceScan[k] == dm_horz)
   mode_lib->vba.SwathWidthSingleDPPY[k] = mode_lib->vba.ViewportWidth[k];
  else
   mode_lib->vba.SwathWidthSingleDPPY[k] = mode_lib->vba.ViewportHeight[k];

  if (mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)
   MainPlaneDoesODMCombine = true;
  for (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)
   if (mode_lib->vba.BlendingAndTiming[k] == j
     && mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)
    MainPlaneDoesODMCombine = true;

  if (MainPlaneDoesODMCombine == true)
   mode_lib->vba.SwathWidthY[k] = dml_min(
     (double) mode_lib->vba.SwathWidthSingleDPPY[k],
     dml_round(
       mode_lib->vba.HActive[k] / 2.0
         * mode_lib->vba.HRatio[k]));
  else {
   if (mode_lib->vba.DPPPerPlane[k] == 0) {
    mode_lib->vba.SwathWidthY[k] = 0;
   } else {
    mode_lib->vba.SwathWidthY[k] = mode_lib->vba.SwathWidthSingleDPPY[k]
      / mode_lib->vba.DPPPerPlane[k];
   }
  }
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {
   mode_lib->vba.BytePerPixelDETY[k] = 8;
   mode_lib->vba.BytePerPixelDETC[k] = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {
   mode_lib->vba.BytePerPixelDETY[k] = 4;
   mode_lib->vba.BytePerPixelDETC[k] = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16) {
   mode_lib->vba.BytePerPixelDETY[k] = 2;
   mode_lib->vba.BytePerPixelDETC[k] = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8) {
   mode_lib->vba.BytePerPixelDETY[k] = 1;
   mode_lib->vba.BytePerPixelDETC[k] = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {
   mode_lib->vba.BytePerPixelDETY[k] = 1;
   mode_lib->vba.BytePerPixelDETC[k] = 2;
  } else {
   mode_lib->vba.BytePerPixelDETY[k] = 4.0 / 3.0;
   mode_lib->vba.BytePerPixelDETC[k] = 8.0 / 3.0;
  }
 }

 mode_lib->vba.TotalDataReadBandwidth = 0.0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.ReadBandwidthPlaneLuma[k] = mode_lib->vba.SwathWidthSingleDPPY[k]
    * dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1)
    / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
    * mode_lib->vba.VRatio[k];
  mode_lib->vba.ReadBandwidthPlaneChroma[k] = mode_lib->vba.SwathWidthSingleDPPY[k]
    / 2 * dml_ceil(mode_lib->vba.BytePerPixelDETC[k], 2)
    / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
    * mode_lib->vba.VRatio[k] / 2;
  {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug193 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   read_bw[%i] = %fBps"), .lineno = 1398, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug193.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug193.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug193.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug193.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug193, "[DML]:""   read_bw[%i] = %fBps", k, mode_lib->vba.ReadBandwidthPlaneLuma[k] + mode_lib->vba.ReadBandwidthPlaneChroma[k]); } while (0); };




  mode_lib->vba.TotalDataReadBandwidth += mode_lib->vba.ReadBandwidthPlaneLuma[k]
    + mode_lib->vba.ReadBandwidthPlaneChroma[k];
 }

 mode_lib->vba.TotalDCCActiveDPP = 0;
 mode_lib->vba.TotalActiveDPP = 0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.TotalActiveDPP = mode_lib->vba.TotalActiveDPP
    + mode_lib->vba.DPPPerPlane[k];
  if (mode_lib->vba.DCCEnable[k])
   mode_lib->vba.TotalDCCActiveDPP = mode_lib->vba.TotalDCCActiveDPP
     + mode_lib->vba.DPPPerPlane[k];
 }

 mode_lib->vba.UrgentRoundTripAndOutOfOrderLatency =
   (mode_lib->vba.RoundTripPingLatencyCycles + 32) / mode_lib->vba.DCFCLK
     + mode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelDataOnly
       * mode_lib->vba.NumberOfChannels
       / mode_lib->vba.ReturnBW;

 mode_lib->vba.LastPixelOfLineExtraWatermark = 0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  double DataFabricLineDeliveryTimeLuma, DataFabricLineDeliveryTimeChroma;

  if (mode_lib->vba.VRatio[k] <= 1.0)
   mode_lib->vba.DisplayPipeLineDeliveryTimeLuma[k] =
     (double) mode_lib->vba.SwathWidthY[k]
       * mode_lib->vba.DPPPerPlane[k]
       / mode_lib->vba.HRatio[k]
       / mode_lib->vba.PixelClock[k];
  else
   mode_lib->vba.DisplayPipeLineDeliveryTimeLuma[k] =
     (double) mode_lib->vba.SwathWidthY[k]
       / mode_lib->vba.PSCL_THROUGHPUT_LUMA[k]
       / mode_lib->vba.DPPCLK[k];

  DataFabricLineDeliveryTimeLuma = mode_lib->vba.SwathWidthSingleDPPY[k]
    * mode_lib->vba.SwathHeightY[k]
    * dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1)
    / (mode_lib->vba.ReturnBW * mode_lib->vba.ReadBandwidthPlaneLuma[k]
      / mode_lib->vba.TotalDataReadBandwidth);
  mode_lib->vba.LastPixelOfLineExtraWatermark = dml_max(
    mode_lib->vba.LastPixelOfLineExtraWatermark,
    DataFabricLineDeliveryTimeLuma
      - mode_lib->vba.DisplayPipeLineDeliveryTimeLuma[k]);

  if (mode_lib->vba.BytePerPixelDETC[k] == 0)
   mode_lib->vba.DisplayPipeLineDeliveryTimeChroma[k] = 0.0;
  else if (mode_lib->vba.VRatio[k] / 2.0 <= 1.0)
   mode_lib->vba.DisplayPipeLineDeliveryTimeChroma[k] =
     mode_lib->vba.SwathWidthY[k] / 2.0
       * mode_lib->vba.DPPPerPlane[k]
       / (mode_lib->vba.HRatio[k] / 2.0)
       / mode_lib->vba.PixelClock[k];
  else
   mode_lib->vba.DisplayPipeLineDeliveryTimeChroma[k] =
     mode_lib->vba.SwathWidthY[k] / 2.0
       / mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k]
       / mode_lib->vba.DPPCLK[k];

  DataFabricLineDeliveryTimeChroma = mode_lib->vba.SwathWidthSingleDPPY[k] / 2.0
    * mode_lib->vba.SwathHeightC[k]
    * dml_ceil(mode_lib->vba.BytePerPixelDETC[k], 2)
    / (mode_lib->vba.ReturnBW
      * mode_lib->vba.ReadBandwidthPlaneChroma[k]
      / mode_lib->vba.TotalDataReadBandwidth);
  mode_lib->vba.LastPixelOfLineExtraWatermark =
    dml_max(
      mode_lib->vba.LastPixelOfLineExtraWatermark,
      DataFabricLineDeliveryTimeChroma
        - mode_lib->vba.DisplayPipeLineDeliveryTimeChroma[k]);
 }

 mode_lib->vba.UrgentExtraLatency = mode_lib->vba.UrgentRoundTripAndOutOfOrderLatency
   + (mode_lib->vba.TotalActiveDPP * mode_lib->vba.PixelChunkSizeInKByte
     + mode_lib->vba.TotalDCCActiveDPP
       * mode_lib->vba.MetaChunkSize) * 1024.0
     / mode_lib->vba.ReturnBW;

 if (mode_lib->vba.GPUVMEnable)
  mode_lib->vba.UrgentExtraLatency += mode_lib->vba.TotalActiveDPP
    * mode_lib->vba.PTEGroupSize / mode_lib->vba.ReturnBW;

 mode_lib->vba.UrgentWatermark = mode_lib->vba.UrgentLatencyPixelDataOnly
   + mode_lib->vba.LastPixelOfLineExtraWatermark
   + mode_lib->vba.UrgentExtraLatency;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug194 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   urgent_extra_latency = %fus"), .lineno = 1486, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug194.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug194.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug194.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug194.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug194, "[DML]:""   urgent_extra_latency = %fus", mode_lib->vba.UrgentExtraLatency); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug195 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_urgent = %fus"), .lineno = 1487, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug195.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug195.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug195.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug195.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug195, "[DML]:""   wm_urgent = %fus", mode_lib->vba.UrgentWatermark); } while (0); };

 mode_lib->vba.UrgentLatency = mode_lib->vba.UrgentLatencyPixelDataOnly;

 mode_lib->vba.TotalActiveWriteback = 0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.WritebackEnable[k])
   mode_lib->vba.TotalActiveWriteback = mode_lib->vba.TotalActiveWriteback + mode_lib->vba.ActiveWritebacksPerPlane[k];
 }

 if (mode_lib->vba.TotalActiveWriteback <= 1)
  mode_lib->vba.WritebackUrgentWatermark = mode_lib->vba.WritebackLatency;
 else
  mode_lib->vba.WritebackUrgentWatermark = mode_lib->vba.WritebackLatency
    + mode_lib->vba.WritebackChunkSize * 1024.0 / 32
      / mode_lib->vba.SOCCLK;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug196 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_wb_urgent = %fus"), .lineno = 1504, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug196.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug196.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug196.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug196.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug196, "[DML]:""   wm_wb_urgent = %fus", mode_lib->vba.WritebackUrgentWatermark); } while (0); };


 mode_lib->vba.DRAMClockChangeWatermark = mode_lib->vba.DRAMClockChangeLatency
   + mode_lib->vba.UrgentWatermark;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug197 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_pstate_change = %fus"), .lineno = 1510, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug197.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug197.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug197.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug197.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug197, "[DML]:""   wm_pstate_change = %fus", mode_lib->vba.DRAMClockChangeWatermark); } while (0); };

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug198 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   calculating wb pstate watermark"), .lineno = 1512, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug198.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug198.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug198.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug198.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug198, "[DML]:""   calculating wb pstate watermark"); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug199 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""      total wb outputs %d"), .lineno = 1513, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug199.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug199.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug199.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug199.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug199, "[DML]:""      total wb outputs %d", mode_lib->vba.TotalActiveWriteback); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug200 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""      socclk frequency %f Mhz"), .lineno = 1514, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug200.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug200.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug200.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug200.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug200, "[DML]:""      socclk frequency %f Mhz", mode_lib->vba.SOCCLK); } while (0); };

 if (mode_lib->vba.TotalActiveWriteback <= 1)
  mode_lib->vba.WritebackDRAMClockChangeWatermark =
    mode_lib->vba.DRAMClockChangeLatency
      + mode_lib->vba.WritebackLatency;
 else
  mode_lib->vba.WritebackDRAMClockChangeWatermark =
    mode_lib->vba.DRAMClockChangeLatency
      + mode_lib->vba.WritebackLatency
      + mode_lib->vba.WritebackChunkSize * 1024.0 / 32
        / mode_lib->vba.SOCCLK;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug201 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_wb_pstate %fus"), .lineno = 1527, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug201.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug201.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug201.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug201.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug201, "[DML]:""   wm_wb_pstate %fus", mode_lib->vba.WritebackDRAMClockChangeWatermark); } while (0); };


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.LinesInDETY[k] = mode_lib->vba.DETBufferSizeY[k]
    / mode_lib->vba.BytePerPixelDETY[k] / mode_lib->vba.SwathWidthY[k];
  mode_lib->vba.LinesInDETYRoundedDownToSwath[k] = dml_floor(
    mode_lib->vba.LinesInDETY[k],
    mode_lib->vba.SwathHeightY[k]);
  mode_lib->vba.FullDETBufferingTimeY[k] =
    mode_lib->vba.LinesInDETYRoundedDownToSwath[k]
      * (mode_lib->vba.HTotal[k]
        / mode_lib->vba.PixelClock[k])
      / mode_lib->vba.VRatio[k];
  if (mode_lib->vba.BytePerPixelDETC[k] > 0) {
   mode_lib->vba.LinesInDETC[k] = mode_lib->vba.DETBufferSizeC[k]
     / mode_lib->vba.BytePerPixelDETC[k]
     / (mode_lib->vba.SwathWidthY[k] / 2);
   mode_lib->vba.LinesInDETCRoundedDownToSwath[k] = dml_floor(
     mode_lib->vba.LinesInDETC[k],
     mode_lib->vba.SwathHeightC[k]);
   mode_lib->vba.FullDETBufferingTimeC[k] =
     mode_lib->vba.LinesInDETCRoundedDownToSwath[k]
       * (mode_lib->vba.HTotal[k]
         / mode_lib->vba.PixelClock[k])
       / (mode_lib->vba.VRatio[k] / 2);
  } else {
   mode_lib->vba.LinesInDETC[k] = 0;
   mode_lib->vba.LinesInDETCRoundedDownToSwath[k] = 0;
   mode_lib->vba.FullDETBufferingTimeC[k] = 999999;
  }
 }

 mode_lib->vba.MinFullDETBufferingTime = 999999.0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.FullDETBufferingTimeY[k]
    < mode_lib->vba.MinFullDETBufferingTime) {
   mode_lib->vba.MinFullDETBufferingTime =
     mode_lib->vba.FullDETBufferingTimeY[k];
   mode_lib->vba.FrameTimeForMinFullDETBufferingTime =
     (double) mode_lib->vba.VTotal[k] * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k];
  }
  if (mode_lib->vba.FullDETBufferingTimeC[k]
    < mode_lib->vba.MinFullDETBufferingTime) {
   mode_lib->vba.MinFullDETBufferingTime =
     mode_lib->vba.FullDETBufferingTimeC[k];
   mode_lib->vba.FrameTimeForMinFullDETBufferingTime =
     (double) mode_lib->vba.VTotal[k] * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k];
  }
 }

 mode_lib->vba.AverageReadBandwidthGBytePerSecond = 0.0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.DCCEnable[k]) {
   mode_lib->vba.AverageReadBandwidthGBytePerSecond =
     mode_lib->vba.AverageReadBandwidthGBytePerSecond
       + mode_lib->vba.ReadBandwidthPlaneLuma[k]
         / mode_lib->vba.DCCRate[k]
         / 1000
       + mode_lib->vba.ReadBandwidthPlaneChroma[k]
         / mode_lib->vba.DCCRate[k]
         / 1000;
  } else {
   mode_lib->vba.AverageReadBandwidthGBytePerSecond =
     mode_lib->vba.AverageReadBandwidthGBytePerSecond
       + mode_lib->vba.ReadBandwidthPlaneLuma[k]
         / 1000
       + mode_lib->vba.ReadBandwidthPlaneChroma[k]
         / 1000;
  }
  if (mode_lib->vba.DCCEnable[k]) {
   mode_lib->vba.AverageReadBandwidthGBytePerSecond =
     mode_lib->vba.AverageReadBandwidthGBytePerSecond
       + mode_lib->vba.ReadBandwidthPlaneLuma[k]
         / 1000 / 256
       + mode_lib->vba.ReadBandwidthPlaneChroma[k]
         / 1000 / 256;
  }
  if (mode_lib->vba.GPUVMEnable) {
   mode_lib->vba.AverageReadBandwidthGBytePerSecond =
     mode_lib->vba.AverageReadBandwidthGBytePerSecond
       + mode_lib->vba.ReadBandwidthPlaneLuma[k]
         / 1000 / 512
       + mode_lib->vba.ReadBandwidthPlaneChroma[k]
         / 1000 / 512;
  }
 }

 mode_lib->vba.PartOfBurstThatFitsInROB =
   dml_min(
     mode_lib->vba.MinFullDETBufferingTime
       * mode_lib->vba.TotalDataReadBandwidth,
     mode_lib->vba.ROBBufferSizeInKByte * 1024
       * mode_lib->vba.TotalDataReadBandwidth
       / (mode_lib->vba.AverageReadBandwidthGBytePerSecond
         * 1000));
 mode_lib->vba.StutterBurstTime = mode_lib->vba.PartOfBurstThatFitsInROB
   * (mode_lib->vba.AverageReadBandwidthGBytePerSecond * 1000)
   / mode_lib->vba.TotalDataReadBandwidth / mode_lib->vba.ReturnBW
   + (mode_lib->vba.MinFullDETBufferingTime
     * mode_lib->vba.TotalDataReadBandwidth
     - mode_lib->vba.PartOfBurstThatFitsInROB)
     / (mode_lib->vba.DCFCLK * 64);
 if (mode_lib->vba.TotalActiveWriteback == 0) {
  mode_lib->vba.StutterEfficiencyNotIncludingVBlank = (1
    - (mode_lib->vba.SRExitTime + mode_lib->vba.StutterBurstTime)
      / mode_lib->vba.MinFullDETBufferingTime) * 100;
 } else {
  mode_lib->vba.StutterEfficiencyNotIncludingVBlank = 0;
 }

 mode_lib->vba.SmallestVBlank = 999999;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.SynchronizedVBlank || mode_lib->vba.NumberOfActivePlanes == 1) {
   mode_lib->vba.VBlankTime = (double) (mode_lib->vba.VTotal[k]
     - mode_lib->vba.VActive[k]) * mode_lib->vba.HTotal[k]
     / mode_lib->vba.PixelClock[k];
  } else {
   mode_lib->vba.VBlankTime = 0;
  }
  mode_lib->vba.SmallestVBlank = dml_min(
    mode_lib->vba.SmallestVBlank,
    mode_lib->vba.VBlankTime);
 }

 mode_lib->vba.StutterEfficiency = (mode_lib->vba.StutterEfficiencyNotIncludingVBlank / 100
   * (mode_lib->vba.FrameTimeForMinFullDETBufferingTime
     - mode_lib->vba.SmallestVBlank)
   + mode_lib->vba.SmallestVBlank)
   / mode_lib->vba.FrameTimeForMinFullDETBufferingTime * 100;


 mode_lib->vba.DCFCLKDeepSleep = 8.0;

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; k++) {
  if (mode_lib->vba.BytePerPixelDETC[k] > 0) {
   mode_lib->vba.DCFCLKDeepSleepPerPlane[k] =
     dml_max(
       1.1 * mode_lib->vba.SwathWidthY[k]
         * dml_ceil(
           mode_lib->vba.BytePerPixelDETY[k],
           1) / 32
         / mode_lib->vba.DisplayPipeLineDeliveryTimeLuma[k],
       1.1 * mode_lib->vba.SwathWidthY[k] / 2.0
         * dml_ceil(
           mode_lib->vba.BytePerPixelDETC[k],
           2) / 32
         / mode_lib->vba.DisplayPipeLineDeliveryTimeChroma[k]);
  } else
   mode_lib->vba.DCFCLKDeepSleepPerPlane[k] = 1.1 * mode_lib->vba.SwathWidthY[k]
     * dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1) / 64.0
     / mode_lib->vba.DisplayPipeLineDeliveryTimeLuma[k];
  mode_lib->vba.DCFCLKDeepSleepPerPlane[k] = dml_max(
    mode_lib->vba.DCFCLKDeepSleepPerPlane[k],
    mode_lib->vba.PixelClock[k] / 16.0);
  mode_lib->vba.DCFCLKDeepSleep = dml_max(
    mode_lib->vba.DCFCLKDeepSleep,
    mode_lib->vba.DCFCLKDeepSleepPerPlane[k]);

  {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug202 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   dcfclk_deepsleep_per_plane[%i] = %fMHz"), .lineno = 1691, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug202.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug202.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug202.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug202.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug202, "[DML]:""   dcfclk_deepsleep_per_plane[%i] = %fMHz", k, mode_lib->vba.DCFCLKDeepSleepPerPlane[k]); } while (0); };



 }

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug203 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   dcfclk_deepsleep_mhz = %fMHz"), .lineno = 1694, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug203.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug203.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug203.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug203.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug203, "[DML]:""   dcfclk_deepsleep_mhz = %fMHz", mode_lib->vba.DCFCLKDeepSleep); } while (0); };


 mode_lib->vba.StutterExitWatermark = mode_lib->vba.SRExitTime
   + mode_lib->vba.LastPixelOfLineExtraWatermark
   + mode_lib->vba.UrgentExtraLatency + 10 / mode_lib->vba.DCFCLKDeepSleep;
 mode_lib->vba.StutterEnterPlusExitWatermark = mode_lib->vba.SREnterPlusExitTime
   + mode_lib->vba.LastPixelOfLineExtraWatermark
   + mode_lib->vba.UrgentExtraLatency;

 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug204 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_cstate_exit       = %fus"), .lineno = 1704, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug204.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug204.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug204.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug204.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug204, "[DML]:""   wm_cstate_exit       = %fus", mode_lib->vba.StutterExitWatermark); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug205 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""   wm_cstate_enter_exit = %fus"), .lineno = 1705, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug205.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug205.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug205.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug205.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug205, "[DML]:""   wm_cstate_enter_exit = %fus", mode_lib->vba.StutterEnterPlusExitWatermark); } while (0); };


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.EffectiveDETPlusLBLinesLuma =
    dml_floor(
      mode_lib->vba.LinesInDETY[k]
        + dml_min(
          mode_lib->vba.LinesInDETY[k]
            * mode_lib->vba.DPPCLK[k]
            * mode_lib->vba.BytePerPixelDETY[k]
            * mode_lib->vba.PSCL_THROUGHPUT_LUMA[k]
            / (mode_lib->vba.ReturnBW
              / mode_lib->vba.DPPPerPlane[k]),
          (double) mode_lib->vba.EffectiveLBLatencyHidingSourceLinesLuma),
      mode_lib->vba.SwathHeightY[k]);

  mode_lib->vba.UrgentLatencySupportUsLuma = mode_lib->vba.EffectiveDETPlusLBLinesLuma
    * (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
    / mode_lib->vba.VRatio[k]
    - mode_lib->vba.EffectiveDETPlusLBLinesLuma
      * mode_lib->vba.SwathWidthY[k]
      * mode_lib->vba.BytePerPixelDETY[k]
      / (mode_lib->vba.ReturnBW
        / mode_lib->vba.DPPPerPlane[k]);

  if (mode_lib->vba.BytePerPixelDETC[k] > 0) {
   mode_lib->vba.EffectiveDETPlusLBLinesChroma =
     dml_floor(
       mode_lib->vba.LinesInDETC[k]
         + dml_min(
           mode_lib->vba.LinesInDETC[k]
             * mode_lib->vba.DPPCLK[k]
             * mode_lib->vba.BytePerPixelDETC[k]
             * mode_lib->vba.PSCL_THROUGHPUT_CHROMA[k]
             / (mode_lib->vba.ReturnBW
               / mode_lib->vba.DPPPerPlane[k]),
           (double) mode_lib->vba.EffectiveLBLatencyHidingSourceLinesChroma),
       mode_lib->vba.SwathHeightC[k]);
   mode_lib->vba.UrgentLatencySupportUsChroma =
     mode_lib->vba.EffectiveDETPlusLBLinesChroma
       * (mode_lib->vba.HTotal[k]
         / mode_lib->vba.PixelClock[k])
       / (mode_lib->vba.VRatio[k] / 2)
       - mode_lib->vba.EffectiveDETPlusLBLinesChroma
         * (mode_lib->vba.SwathWidthY[k]
           / 2)
         * mode_lib->vba.BytePerPixelDETC[k]
         / (mode_lib->vba.ReturnBW
           / mode_lib->vba.DPPPerPlane[k]);
   mode_lib->vba.UrgentLatencySupportUs[k] = dml_min(
     mode_lib->vba.UrgentLatencySupportUsLuma,
     mode_lib->vba.UrgentLatencySupportUsChroma);
  } else {
   mode_lib->vba.UrgentLatencySupportUs[k] =
     mode_lib->vba.UrgentLatencySupportUsLuma;
  }
 }

 mode_lib->vba.MinUrgentLatencySupportUs = 999999;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.MinUrgentLatencySupportUs = dml_min(
    mode_lib->vba.MinUrgentLatencySupportUs,
    mode_lib->vba.UrgentLatencySupportUs[k]);
 }


 mode_lib->vba.NonUrgentLatencyTolerance = mode_lib->vba.MinUrgentLatencySupportUs
   - mode_lib->vba.UrgentWatermark;


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if ((mode_lib->vba.BlendingAndTiming[k] != k) || !mode_lib->vba.DSCEnabled[k]) {
   mode_lib->vba.DSCCLK_calculated[k] = 0.0;
  } else {
   if (mode_lib->vba.OutputFormat[k] == dm_420
     || mode_lib->vba.OutputFormat[k] == dm_n422)
    mode_lib->vba.DSCFormatFactor = 2;
   else
    mode_lib->vba.DSCFormatFactor = 1;
   if (mode_lib->vba.ODMCombineEnabled[k])
    mode_lib->vba.DSCCLK_calculated[k] =
      mode_lib->vba.PixelClockBackEnd[k] / 6
        / mode_lib->vba.DSCFormatFactor
        / (1
          - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
            / 100);
   else
    mode_lib->vba.DSCCLK_calculated[k] =
      mode_lib->vba.PixelClockBackEnd[k] / 3
        / mode_lib->vba.DSCFormatFactor
        / (1
          - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading
            / 100);
  }
 }



 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  double bpp = mode_lib->vba.OutputBpp[k];
  unsigned int slices = mode_lib->vba.NumberOfDSCSlices[k];

  if (mode_lib->vba.DSCEnabled[k] && bpp != 0) {
   if (!mode_lib->vba.ODMCombineEnabled[k]) {
    mode_lib->vba.DSCDelay[k] =
      dscceComputeDelay(
        mode_lib->vba.DSCInputBitPerComponent[k],
        bpp,
        dml_ceil(
          (double) mode_lib->vba.HActive[k]
            / mode_lib->vba.NumberOfDSCSlices[k],
          1),
        slices,
        mode_lib->vba.OutputFormat[k])
        + dscComputeDelay(
          mode_lib->vba.OutputFormat[k]);
   } else {
    mode_lib->vba.DSCDelay[k] =
      2
        * (dscceComputeDelay(
          mode_lib->vba.DSCInputBitPerComponent[k],
          bpp,
          dml_ceil(
            (double) mode_lib->vba.HActive[k]
              / mode_lib->vba.NumberOfDSCSlices[k],
            1),
          slices / 2.0,
          mode_lib->vba.OutputFormat[k])
          + dscComputeDelay(
            mode_lib->vba.OutputFormat[k]));
   }
   mode_lib->vba.DSCDelay[k] = mode_lib->vba.DSCDelay[k]
     * mode_lib->vba.PixelClock[k]
     / mode_lib->vba.PixelClockBackEnd[k];
  } else {
   mode_lib->vba.DSCDelay[k] = 0;
  }
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)
  for (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)
   if (j != k && mode_lib->vba.BlendingAndTiming[k] == j
     && mode_lib->vba.DSCEnabled[j])
    mode_lib->vba.DSCDelay[k] = mode_lib->vba.DSCDelay[j];


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  unsigned int PDEAndMetaPTEBytesFrameY;
  unsigned int PixelPTEBytesPerRowY;
  unsigned int MetaRowByteY;
  unsigned int MetaRowByteC;
  unsigned int PDEAndMetaPTEBytesFrameC;
  unsigned int PixelPTEBytesPerRowC;

  Calculate256BBlockSizes(
    mode_lib->vba.SourcePixelFormat[k],
    mode_lib->vba.SurfaceTiling[k],
    dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1),
    dml_ceil(mode_lib->vba.BytePerPixelDETC[k], 2),
    &mode_lib->vba.BlockHeight256BytesY[k],
    &mode_lib->vba.BlockHeight256BytesC[k],
    &mode_lib->vba.BlockWidth256BytesY[k],
    &mode_lib->vba.BlockWidth256BytesC[k]);
  PDEAndMetaPTEBytesFrameY = CalculateVMAndRowBytes(
    mode_lib,
    mode_lib->vba.DCCEnable[k],
    mode_lib->vba.BlockHeight256BytesY[k],
    mode_lib->vba.BlockWidth256BytesY[k],
    mode_lib->vba.SourcePixelFormat[k],
    mode_lib->vba.SurfaceTiling[k],
    dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1),
    mode_lib->vba.SourceScan[k],
    mode_lib->vba.ViewportWidth[k],
    mode_lib->vba.ViewportHeight[k],
    mode_lib->vba.SwathWidthY[k],
    mode_lib->vba.GPUVMEnable,
    mode_lib->vba.VMMPageSize,
    mode_lib->vba.PTEBufferSizeInRequestsLuma,
    mode_lib->vba.PDEProcessingBufIn64KBReqs,
    mode_lib->vba.PitchY[k],
    mode_lib->vba.DCCMetaPitchY[k],
    &mode_lib->vba.MacroTileWidthY[k],
    &MetaRowByteY,
    &PixelPTEBytesPerRowY,
    &mode_lib->vba.PTEBufferSizeNotExceeded[mode_lib->vba.VoltageLevel][0],
    &mode_lib->vba.dpte_row_height[k],
    &mode_lib->vba.meta_row_height[k]);
  mode_lib->vba.PrefetchSourceLinesY[k] = CalculatePrefetchSourceLines(
    mode_lib,
    mode_lib->vba.VRatio[k],
    mode_lib->vba.vtaps[k],
    mode_lib->vba.Interlace[k],
    mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
    mode_lib->vba.SwathHeightY[k],
    mode_lib->vba.ViewportYStartY[k],
    &mode_lib->vba.VInitPreFillY[k],
    &mode_lib->vba.MaxNumSwathY[k]);

  if ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64
    && mode_lib->vba.SourcePixelFormat[k] != dm_444_32
    && mode_lib->vba.SourcePixelFormat[k] != dm_444_16
    && mode_lib->vba.SourcePixelFormat[k] != dm_444_8)) {
   PDEAndMetaPTEBytesFrameC =
     CalculateVMAndRowBytes(
       mode_lib,
       mode_lib->vba.DCCEnable[k],
       mode_lib->vba.BlockHeight256BytesC[k],
       mode_lib->vba.BlockWidth256BytesC[k],
       mode_lib->vba.SourcePixelFormat[k],
       mode_lib->vba.SurfaceTiling[k],
       dml_ceil(
         mode_lib->vba.BytePerPixelDETC[k],
         2),
       mode_lib->vba.SourceScan[k],
       mode_lib->vba.ViewportWidth[k] / 2,
       mode_lib->vba.ViewportHeight[k] / 2,
       mode_lib->vba.SwathWidthY[k] / 2,
       mode_lib->vba.GPUVMEnable,
       mode_lib->vba.VMMPageSize,
       mode_lib->vba.PTEBufferSizeInRequestsLuma,
       mode_lib->vba.PDEProcessingBufIn64KBReqs,
       mode_lib->vba.PitchC[k],
       0,
       &mode_lib->vba.MacroTileWidthC[k],
       &MetaRowByteC,
       &PixelPTEBytesPerRowC,
       &mode_lib->vba.PTEBufferSizeNotExceeded[mode_lib->vba.VoltageLevel][0],
       &mode_lib->vba.dpte_row_height_chroma[k],
       &mode_lib->vba.meta_row_height_chroma[k]);
   mode_lib->vba.PrefetchSourceLinesC[k] = CalculatePrefetchSourceLines(
     mode_lib,
     mode_lib->vba.VRatio[k] / 2,
     mode_lib->vba.VTAPsChroma[k],
     mode_lib->vba.Interlace[k],
     mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
     mode_lib->vba.SwathHeightC[k],
     mode_lib->vba.ViewportYStartC[k],
     &mode_lib->vba.VInitPreFillC[k],
     &mode_lib->vba.MaxNumSwathC[k]);
  } else {
   PixelPTEBytesPerRowC = 0;
   PDEAndMetaPTEBytesFrameC = 0;
   MetaRowByteC = 0;
   mode_lib->vba.MaxNumSwathC[k] = 0;
   mode_lib->vba.PrefetchSourceLinesC[k] = 0;
  }

  mode_lib->vba.PixelPTEBytesPerRow[k] = PixelPTEBytesPerRowY + PixelPTEBytesPerRowC;
  mode_lib->vba.PDEAndMetaPTEBytesFrame[k] = PDEAndMetaPTEBytesFrameY
    + PDEAndMetaPTEBytesFrameC;
  mode_lib->vba.MetaRowByte[k] = MetaRowByteY + MetaRowByteC;

  CalculateActiveRowBandwidth(
    mode_lib->vba.GPUVMEnable,
    mode_lib->vba.SourcePixelFormat[k],
    mode_lib->vba.VRatio[k],
    mode_lib->vba.DCCEnable[k],
    mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],
    MetaRowByteY,
    MetaRowByteC,
    mode_lib->vba.meta_row_height[k],
    mode_lib->vba.meta_row_height_chroma[k],
    PixelPTEBytesPerRowY,
    PixelPTEBytesPerRowC,
    mode_lib->vba.dpte_row_height[k],
    mode_lib->vba.dpte_row_height_chroma[k],
    &mode_lib->vba.meta_row_bw[k],
    &mode_lib->vba.dpte_row_bw[k],
    &mode_lib->vba.qual_row_bw[k]);
 }

 mode_lib->vba.TCalc = 24.0 / mode_lib->vba.DCFCLKDeepSleep;

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.BlendingAndTiming[k] == k) {
   if (mode_lib->vba.WritebackEnable[k] == true) {
    mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k] =
      mode_lib->vba.WritebackLatency
        + CalculateWriteBackDelay(
          mode_lib->vba.WritebackPixelFormat[k],
          mode_lib->vba.WritebackHRatio[k],
          mode_lib->vba.WritebackVRatio[k],
          mode_lib->vba.WritebackLumaHTaps[k],
          mode_lib->vba.WritebackLumaVTaps[k],
          mode_lib->vba.WritebackChromaHTaps[k],
          mode_lib->vba.WritebackChromaVTaps[k],
          mode_lib->vba.WritebackDestinationWidth[k])
          / mode_lib->vba.DISPCLK;
   } else
    mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k] = 0;
   for (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j) {
    if (mode_lib->vba.BlendingAndTiming[j] == k
      && mode_lib->vba.WritebackEnable[j] == true) {
     mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k] =
       dml_max(
         mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k],
         mode_lib->vba.WritebackLatency
           + CalculateWriteBackDelay(
             mode_lib->vba.WritebackPixelFormat[j],
             mode_lib->vba.WritebackHRatio[j],
             mode_lib->vba.WritebackVRatio[j],
             mode_lib->vba.WritebackLumaHTaps[j],
             mode_lib->vba.WritebackLumaVTaps[j],
             mode_lib->vba.WritebackChromaHTaps[j],
             mode_lib->vba.WritebackChromaVTaps[j],
             mode_lib->vba.WritebackDestinationWidth[j])
             / mode_lib->vba.DISPCLK);
    }
   }
  }
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)
  for (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)
   if (mode_lib->vba.BlendingAndTiming[k] == j)
    mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k] =
      mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][j];

 mode_lib->vba.VStartupLines = 13;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.MaxVStartupLines[k] =
    mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k]
      - dml_max(
        1.0,
        dml_ceil(
          mode_lib->vba.WritebackDelay[mode_lib->vba.VoltageLevel][k]
            / (mode_lib->vba.HTotal[k]
              / mode_lib->vba.PixelClock[k]),
          1));
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)
  mode_lib->vba.MaximumMaxVStartupLines = dml_max(
    mode_lib->vba.MaximumMaxVStartupLines,
    mode_lib->vba.MaxVStartupLines[k]);

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.cursor_bw[k] = 0.0;
  for (j = 0; j < mode_lib->vba.NumberOfCursors[k]; ++j)
   mode_lib->vba.cursor_bw[k] += mode_lib->vba.CursorWidth[k][j]
     * mode_lib->vba.CursorBPP[k][j] / 8.0
     / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
     * mode_lib->vba.VRatio[k];
 }

 do {
  double MaxTotalRDBandwidth = 0;
  bool DestinationLineTimesForPrefetchLessThan2 = false;
  bool VRatioPrefetchMoreThan4 = false;
  bool prefetch_vm_bw_valid = true;
  bool prefetch_row_bw_valid = true;
  double TWait = CalculateTWait(
    mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb],
    mode_lib->vba.DRAMClockChangeLatency,
    mode_lib->vba.UrgentLatencyPixelDataOnly,
    mode_lib->vba.SREnterPlusExitTime);

  for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
   if (mode_lib->vba.XFCEnabled[k] == true) {
    mode_lib->vba.XFCRemoteSurfaceFlipDelay =
      CalculateRemoteSurfaceFlipDelay(
        mode_lib,
        mode_lib->vba.VRatio[k],
        mode_lib->vba.SwathWidthY[k],
        dml_ceil(
          mode_lib->vba.BytePerPixelDETY[k],
          1),
        mode_lib->vba.HTotal[k]
          / mode_lib->vba.PixelClock[k],
        mode_lib->vba.XFCTSlvVupdateOffset,
        mode_lib->vba.XFCTSlvVupdateWidth,
        mode_lib->vba.XFCTSlvVreadyOffset,
        mode_lib->vba.XFCXBUFLatencyTolerance,
        mode_lib->vba.XFCFillBWOverhead,
        mode_lib->vba.XFCSlvChunkSize,
        mode_lib->vba.XFCBusTransportTime,
        mode_lib->vba.TCalc,
        TWait,
        &mode_lib->vba.SrcActiveDrainRate,
        &mode_lib->vba.TInitXFill,
        &mode_lib->vba.TslvChk);
   } else {
    mode_lib->vba.XFCRemoteSurfaceFlipDelay = 0;
   }
   mode_lib->vba.ErrorResult[k] =
     CalculatePrefetchSchedule(
       mode_lib,
       mode_lib->vba.DPPCLK[k],
       mode_lib->vba.DISPCLK,
       mode_lib->vba.PixelClock[k],
       mode_lib->vba.DCFCLKDeepSleep,
       mode_lib->vba.DSCDelay[k],
       mode_lib->vba.DPPPerPlane[k],
       mode_lib->vba.ScalerEnabled[k],
       mode_lib->vba.NumberOfCursors[k],
       mode_lib->vba.DPPCLKDelaySubtotal,
       mode_lib->vba.DPPCLKDelaySCL,
       mode_lib->vba.DPPCLKDelaySCLLBOnly,
       mode_lib->vba.DPPCLKDelayCNVCFormater,
       mode_lib->vba.DPPCLKDelayCNVCCursor,
       mode_lib->vba.DISPCLKDelaySubtotal,
       (unsigned int) (mode_lib->vba.SwathWidthY[k]
         / mode_lib->vba.HRatio[k]),
       mode_lib->vba.OutputFormat[k],
       mode_lib->vba.VTotal[k]
         - mode_lib->vba.VActive[k],
       mode_lib->vba.HTotal[k],
       mode_lib->vba.MaxInterDCNTileRepeaters,
       dml_min(
         mode_lib->vba.VStartupLines,
         mode_lib->vba.MaxVStartupLines[k]),
       mode_lib->vba.GPUVMMaxPageTableLevels,
       mode_lib->vba.GPUVMEnable,
       mode_lib->vba.DynamicMetadataEnable[k],
       mode_lib->vba.DynamicMetadataLinesBeforeActiveRequired[k],
       mode_lib->vba.DynamicMetadataTransmittedBytes[k],
       mode_lib->vba.DCCEnable[k],
       mode_lib->vba.UrgentLatencyPixelDataOnly,
       mode_lib->vba.UrgentExtraLatency,
       mode_lib->vba.TCalc,
       mode_lib->vba.PDEAndMetaPTEBytesFrame[k],
       mode_lib->vba.MetaRowByte[k],
       mode_lib->vba.PixelPTEBytesPerRow[k],
       mode_lib->vba.PrefetchSourceLinesY[k],
       mode_lib->vba.SwathWidthY[k],
       mode_lib->vba.BytePerPixelDETY[k],
       mode_lib->vba.VInitPreFillY[k],
       mode_lib->vba.MaxNumSwathY[k],
       mode_lib->vba.PrefetchSourceLinesC[k],
       mode_lib->vba.BytePerPixelDETC[k],
       mode_lib->vba.VInitPreFillC[k],
       mode_lib->vba.MaxNumSwathC[k],
       mode_lib->vba.SwathHeightY[k],
       mode_lib->vba.SwathHeightC[k],
       TWait,
       mode_lib->vba.XFCEnabled[k],
       mode_lib->vba.XFCRemoteSurfaceFlipDelay,
       mode_lib->vba.Interlace[k],
       mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
       &mode_lib->vba.DSTXAfterScaler[k],
       &mode_lib->vba.DSTYAfterScaler[k],
       &mode_lib->vba.DestinationLinesForPrefetch[k],
       &mode_lib->vba.PrefetchBandwidth[k],
       &mode_lib->vba.DestinationLinesToRequestVMInVBlank[k],
       &mode_lib->vba.DestinationLinesToRequestRowInVBlank[k],
       &mode_lib->vba.VRatioPrefetchY[k],
       &mode_lib->vba.VRatioPrefetchC[k],
       &mode_lib->vba.RequiredPrefetchPixDataBWLuma[k],
       &mode_lib->vba.VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,
       &mode_lib->vba.Tno_bw[k],
       &mode_lib->vba.VUpdateOffsetPix[k],
       &mode_lib->vba.VUpdateWidthPix[k],
       &mode_lib->vba.VReadyOffsetPix[k]);
   if (mode_lib->vba.BlendingAndTiming[k] == k) {
    mode_lib->vba.VStartup[k] = dml_min(
      mode_lib->vba.VStartupLines,
      mode_lib->vba.MaxVStartupLines[k]);
    if (mode_lib->vba.VStartupRequiredWhenNotEnoughTimeForDynamicMetadata
      != 0) {
     mode_lib->vba.VStartup[k] =
       mode_lib->vba.VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
    }
   } else {
    mode_lib->vba.VStartup[k] =
      dml_min(
        mode_lib->vba.VStartupLines,
        mode_lib->vba.MaxVStartupLines[mode_lib->vba.BlendingAndTiming[k]]);
   }
  }

  for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {

   if (mode_lib->vba.PDEAndMetaPTEBytesFrame[k] == 0)
    mode_lib->vba.prefetch_vm_bw[k] = 0;
   else if (mode_lib->vba.DestinationLinesToRequestVMInVBlank[k] > 0) {
    mode_lib->vba.prefetch_vm_bw[k] =
      (double) mode_lib->vba.PDEAndMetaPTEBytesFrame[k]
        / (mode_lib->vba.DestinationLinesToRequestVMInVBlank[k]
          * mode_lib->vba.HTotal[k]
          / mode_lib->vba.PixelClock[k]);
   } else {
    mode_lib->vba.prefetch_vm_bw[k] = 0;
    prefetch_vm_bw_valid = false;
   }
   if (mode_lib->vba.MetaRowByte[k] + mode_lib->vba.PixelPTEBytesPerRow[k]
     == 0)
    mode_lib->vba.prefetch_row_bw[k] = 0;
   else if (mode_lib->vba.DestinationLinesToRequestRowInVBlank[k] > 0) {
    mode_lib->vba.prefetch_row_bw[k] =
      (double) (mode_lib->vba.MetaRowByte[k]
        + mode_lib->vba.PixelPTEBytesPerRow[k])
        / (mode_lib->vba.DestinationLinesToRequestRowInVBlank[k]
          * mode_lib->vba.HTotal[k]
          / mode_lib->vba.PixelClock[k]);
   } else {
    mode_lib->vba.prefetch_row_bw[k] = 0;
    prefetch_row_bw_valid = false;
   }

   MaxTotalRDBandwidth =
     MaxTotalRDBandwidth + mode_lib->vba.cursor_bw[k]
       + dml_max(
         mode_lib->vba.prefetch_vm_bw[k],
         dml_max(
           mode_lib->vba.prefetch_row_bw[k],
           dml_max(
             mode_lib->vba.ReadBandwidthPlaneLuma[k]
               + mode_lib->vba.ReadBandwidthPlaneChroma[k],
             mode_lib->vba.RequiredPrefetchPixDataBWLuma[k])
             + mode_lib->vba.meta_row_bw[k]
             + mode_lib->vba.dpte_row_bw[k]));

   if (mode_lib->vba.DestinationLinesForPrefetch[k] < 2)
    DestinationLineTimesForPrefetchLessThan2 = true;
   if (mode_lib->vba.VRatioPrefetchY[k] > 4
     || mode_lib->vba.VRatioPrefetchC[k] > 4)
    VRatioPrefetchMoreThan4 = true;
  }

  if (MaxTotalRDBandwidth <= mode_lib->vba.ReturnBW && prefetch_vm_bw_valid
    && prefetch_row_bw_valid && !VRatioPrefetchMoreThan4
    && !DestinationLineTimesForPrefetchLessThan2)
   mode_lib->vba.PrefetchModeSupported = true;
  else {
   mode_lib->vba.PrefetchModeSupported = false;
   {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug206 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: CalculatePrefetchSchedule ***failed***. Bandwidth violation. Results are NOT valid\n"), .lineno = 2232, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug206.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug206.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug206.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug206.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug206, "[DML]:""DML: CalculatePrefetchSchedule ***failed***. Bandwidth violation. Results are NOT valid\n"); } while (0); };

  }

  if (mode_lib->vba.PrefetchModeSupported == true) {
   double final_flip_bw[8];
   unsigned int ImmediateFlipBytes[8];
   double total_dcn_read_bw_with_flip = 0;

   mode_lib->vba.BandwidthAvailableForImmediateFlip = mode_lib->vba.ReturnBW;
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    mode_lib->vba.BandwidthAvailableForImmediateFlip =
      mode_lib->vba.BandwidthAvailableForImmediateFlip
        - mode_lib->vba.cursor_bw[k]
        - dml_max(
          mode_lib->vba.ReadBandwidthPlaneLuma[k]
            + mode_lib->vba.ReadBandwidthPlaneChroma[k]
            + mode_lib->vba.qual_row_bw[k],
          mode_lib->vba.PrefetchBandwidth[k]);
   }

   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    ImmediateFlipBytes[k] = 0;
    if ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8
      && mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {
     ImmediateFlipBytes[k] =
       mode_lib->vba.PDEAndMetaPTEBytesFrame[k]
         + mode_lib->vba.MetaRowByte[k]
         + mode_lib->vba.PixelPTEBytesPerRow[k];
    }
   }
   mode_lib->vba.TotImmediateFlipBytes = 0;
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    if ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8
      && mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {
     mode_lib->vba.TotImmediateFlipBytes =
       mode_lib->vba.TotImmediateFlipBytes
         + ImmediateFlipBytes[k];
    }
   }
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    CalculateFlipSchedule(
      mode_lib,
      mode_lib->vba.UrgentExtraLatency,
      mode_lib->vba.UrgentLatencyPixelDataOnly,
      mode_lib->vba.GPUVMMaxPageTableLevels,
      mode_lib->vba.GPUVMEnable,
      mode_lib->vba.BandwidthAvailableForImmediateFlip,
      mode_lib->vba.TotImmediateFlipBytes,
      mode_lib->vba.SourcePixelFormat[k],
      ImmediateFlipBytes[k],
      mode_lib->vba.HTotal[k]
        / mode_lib->vba.PixelClock[k],
      mode_lib->vba.VRatio[k],
      mode_lib->vba.Tno_bw[k],
      mode_lib->vba.PDEAndMetaPTEBytesFrame[k],
      mode_lib->vba.MetaRowByte[k],
      mode_lib->vba.PixelPTEBytesPerRow[k],
      mode_lib->vba.DCCEnable[k],
      mode_lib->vba.dpte_row_height[k],
      mode_lib->vba.meta_row_height[k],
      mode_lib->vba.qual_row_bw[k],
      &mode_lib->vba.DestinationLinesToRequestVMInImmediateFlip[k],
      &mode_lib->vba.DestinationLinesToRequestRowInImmediateFlip[k],
      &final_flip_bw[k],
      &mode_lib->vba.ImmediateFlipSupportedForPipe[k]);
   }
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    total_dcn_read_bw_with_flip =
      total_dcn_read_bw_with_flip
        + mode_lib->vba.cursor_bw[k]
        + dml_max(
          mode_lib->vba.prefetch_vm_bw[k],
          dml_max(
            mode_lib->vba.prefetch_row_bw[k],
            final_flip_bw[k]
              + dml_max(
                mode_lib->vba.ReadBandwidthPlaneLuma[k]
                  + mode_lib->vba.ReadBandwidthPlaneChroma[k],
                mode_lib->vba.RequiredPrefetchPixDataBWLuma[k])));
   }
   mode_lib->vba.ImmediateFlipSupported = true;
   if (total_dcn_read_bw_with_flip > mode_lib->vba.ReturnBW) {
    mode_lib->vba.ImmediateFlipSupported = false;
   }
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    if (mode_lib->vba.ImmediateFlipSupportedForPipe[k] == false) {
     mode_lib->vba.ImmediateFlipSupported = false;
    }
   }
  } else {
   mode_lib->vba.ImmediateFlipSupported = false;
  }

  for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
   if (mode_lib->vba.ErrorResult[k]) {
    mode_lib->vba.PrefetchModeSupported = false;
    {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug207 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML: CalculatePrefetchSchedule ***failed***. Prefetch schedule violation. Results are NOT valid\n"), .lineno = 2329, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug207.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug207.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug207.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug207.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug207, "[DML]:""DML: CalculatePrefetchSchedule ***failed***. Prefetch schedule violation. Results are NOT valid\n"); } while (0); };

   }
  }

  mode_lib->vba.VStartupLines = mode_lib->vba.VStartupLines + 1;
 } while (!((mode_lib->vba.PrefetchModeSupported
   && (!mode_lib->vba.ImmediateFlipSupport
     || mode_lib->vba.ImmediateFlipSupported))
   || mode_lib->vba.MaximumMaxVStartupLines < mode_lib->vba.VStartupLines));


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.VRatioPrefetchY[k] <= 1) {
   mode_lib->vba.DisplayPipeLineDeliveryTimeLumaPrefetch[k] =
     mode_lib->vba.SwathWidthY[k] * mode_lib->vba.DPPPerPlane[k]
       / mode_lib->vba.HRatio[k]
       / mode_lib->vba.PixelClock[k];
  } else {
   mode_lib->vba.DisplayPipeLineDeliveryTimeLumaPrefetch[k] =
     mode_lib->vba.SwathWidthY[k]
       / mode_lib->vba.PSCL_THROUGHPUT_LUMA[k]
       / mode_lib->vba.DPPCLK[k];
  }
  if (mode_lib->vba.BytePerPixelDETC[k] == 0) {
   mode_lib->vba.DisplayPipeLineDeliveryTimeChromaPrefetch[k] = 0;
  } else {
   if (mode_lib->vba.VRatioPrefetchC[k] <= 1) {
    mode_lib->vba.DisplayPipeLineDeliveryTimeChromaPrefetch[k] =
      mode_lib->vba.SwathWidthY[k]
        * mode_lib->vba.DPPPerPlane[k]
        / mode_lib->vba.HRatio[k]
        / mode_lib->vba.PixelClock[k];
   } else {
    mode_lib->vba.DisplayPipeLineDeliveryTimeChromaPrefetch[k] =
      mode_lib->vba.SwathWidthY[k]
        / mode_lib->vba.PSCL_THROUGHPUT_LUMA[k]
        / mode_lib->vba.DPPCLK[k];
   }
  }
 }


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb] == 0) {
   mode_lib->vba.AllowDRAMClockChangeDuringVBlank[k] = true;
   mode_lib->vba.AllowDRAMSelfRefreshDuringVBlank[k] = true;
   mode_lib->vba.MinTTUVBlank[k] = dml_max(
     mode_lib->vba.DRAMClockChangeWatermark,
     dml_max(
       mode_lib->vba.StutterEnterPlusExitWatermark,
       mode_lib->vba.UrgentWatermark));
  } else if (mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb] == 1) {
   mode_lib->vba.AllowDRAMClockChangeDuringVBlank[k] = false;
   mode_lib->vba.AllowDRAMSelfRefreshDuringVBlank[k] = true;
   mode_lib->vba.MinTTUVBlank[k] = dml_max(
     mode_lib->vba.StutterEnterPlusExitWatermark,
     mode_lib->vba.UrgentWatermark);
  } else {
   mode_lib->vba.AllowDRAMClockChangeDuringVBlank[k] = false;
   mode_lib->vba.AllowDRAMSelfRefreshDuringVBlank[k] = false;
   mode_lib->vba.MinTTUVBlank[k] = mode_lib->vba.UrgentWatermark;
  }
  if (!mode_lib->vba.DynamicMetadataEnable[k])
   mode_lib->vba.MinTTUVBlank[k] = mode_lib->vba.TCalc
     + mode_lib->vba.MinTTUVBlank[k];
 }


 mode_lib->vba.ActiveDPPs = 0;

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  mode_lib->vba.ActiveDPPs = mode_lib->vba.ActiveDPPs + mode_lib->vba.DPPPerPlane[k];
 }

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  double EffectiveLBLatencyHidingY;
  double EffectiveLBLatencyHidingC;
  double DPPOutputBufferLinesY;
  double DPPOutputBufferLinesC;
  double DPPOPPBufferingY;
  double MaxDETBufferingTimeY;
  double ActiveDRAMClockChangeLatencyMarginY;

  mode_lib->vba.LBLatencyHidingSourceLinesY =
    dml_min(
      mode_lib->vba.MaxLineBufferLines,
      (unsigned int) dml_floor(
        (double) mode_lib->vba.LineBufferSize
          / mode_lib->vba.LBBitPerPixel[k]
          / (mode_lib->vba.SwathWidthY[k]
            / dml_max(
              mode_lib->vba.HRatio[k],
              1.0)),
        1)) - (mode_lib->vba.vtaps[k] - 1);

  mode_lib->vba.LBLatencyHidingSourceLinesC =
    dml_min(
      mode_lib->vba.MaxLineBufferLines,
      (unsigned int) dml_floor(
        (double) mode_lib->vba.LineBufferSize
          / mode_lib->vba.LBBitPerPixel[k]
          / (mode_lib->vba.SwathWidthY[k]
            / 2.0
            / dml_max(
              mode_lib->vba.HRatio[k]
                / 2,
              1.0)),
        1))
      - (mode_lib->vba.VTAPsChroma[k] - 1);

  EffectiveLBLatencyHidingY = mode_lib->vba.LBLatencyHidingSourceLinesY
    / mode_lib->vba.VRatio[k]
    * (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]);

  EffectiveLBLatencyHidingC = mode_lib->vba.LBLatencyHidingSourceLinesC
    / (mode_lib->vba.VRatio[k] / 2)
    * (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]);

  if (mode_lib->vba.SwathWidthY[k] > 2 * mode_lib->vba.DPPOutputBufferPixels) {
   DPPOutputBufferLinesY = mode_lib->vba.DPPOutputBufferPixels
     / mode_lib->vba.SwathWidthY[k];
  } else if (mode_lib->vba.SwathWidthY[k] > mode_lib->vba.DPPOutputBufferPixels) {
   DPPOutputBufferLinesY = 0.5;
  } else {
   DPPOutputBufferLinesY = 1;
  }

  if (mode_lib->vba.SwathWidthY[k] / 2 > 2 * mode_lib->vba.DPPOutputBufferPixels) {
   DPPOutputBufferLinesC = mode_lib->vba.DPPOutputBufferPixels
     / (mode_lib->vba.SwathWidthY[k] / 2);
  } else if (mode_lib->vba.SwathWidthY[k] / 2 > mode_lib->vba.DPPOutputBufferPixels) {
   DPPOutputBufferLinesC = 0.5;
  } else {
   DPPOutputBufferLinesC = 1;
  }

  DPPOPPBufferingY = (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
    * (DPPOutputBufferLinesY + mode_lib->vba.OPPOutputBufferLines);
  MaxDETBufferingTimeY = mode_lib->vba.FullDETBufferingTimeY[k]
    + (mode_lib->vba.LinesInDETY[k]
      - mode_lib->vba.LinesInDETYRoundedDownToSwath[k])
      / mode_lib->vba.SwathHeightY[k]
      * (mode_lib->vba.HTotal[k]
        / mode_lib->vba.PixelClock[k]);

  ActiveDRAMClockChangeLatencyMarginY = DPPOPPBufferingY + EffectiveLBLatencyHidingY
    + MaxDETBufferingTimeY - mode_lib->vba.DRAMClockChangeWatermark;

  if (mode_lib->vba.ActiveDPPs > 1) {
   ActiveDRAMClockChangeLatencyMarginY =
     ActiveDRAMClockChangeLatencyMarginY
       - (1 - 1 / (mode_lib->vba.ActiveDPPs - 1))
         * mode_lib->vba.SwathHeightY[k]
         * (mode_lib->vba.HTotal[k]
           / mode_lib->vba.PixelClock[k]);
  }

  if (mode_lib->vba.BytePerPixelDETC[k] > 0) {
   double DPPOPPBufferingC = (mode_lib->vba.HTotal[k]
     / mode_lib->vba.PixelClock[k])
     * (DPPOutputBufferLinesC
       + mode_lib->vba.OPPOutputBufferLines);
   double MaxDETBufferingTimeC =
     mode_lib->vba.FullDETBufferingTimeC[k]
       + (mode_lib->vba.LinesInDETC[k]
         - mode_lib->vba.LinesInDETCRoundedDownToSwath[k])
         / mode_lib->vba.SwathHeightC[k]
         * (mode_lib->vba.HTotal[k]
           / mode_lib->vba.PixelClock[k]);
   double ActiveDRAMClockChangeLatencyMarginC = DPPOPPBufferingC
     + EffectiveLBLatencyHidingC + MaxDETBufferingTimeC
     - mode_lib->vba.DRAMClockChangeWatermark;

   if (mode_lib->vba.ActiveDPPs > 1) {
    ActiveDRAMClockChangeLatencyMarginC =
      ActiveDRAMClockChangeLatencyMarginC
        - (1
          - 1
            / (mode_lib->vba.ActiveDPPs
              - 1))
          * mode_lib->vba.SwathHeightC[k]
          * (mode_lib->vba.HTotal[k]
            / mode_lib->vba.PixelClock[k]);
   }
   mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(
     ActiveDRAMClockChangeLatencyMarginY,
     ActiveDRAMClockChangeLatencyMarginC);
  } else {
   mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] =
     ActiveDRAMClockChangeLatencyMarginY;
  }

  if (mode_lib->vba.WritebackEnable[k]) {
   double WritebackDRAMClockChangeLatencyMargin;

   if (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {
    WritebackDRAMClockChangeLatencyMargin =
      (double) (mode_lib->vba.WritebackInterfaceLumaBufferSize
        + mode_lib->vba.WritebackInterfaceChromaBufferSize)
        / (mode_lib->vba.WritebackDestinationWidth[k]
          * mode_lib->vba.WritebackDestinationHeight[k]
          / (mode_lib->vba.WritebackSourceHeight[k]
            * mode_lib->vba.HTotal[k]
            / mode_lib->vba.PixelClock[k])
          * 4)
        - mode_lib->vba.WritebackDRAMClockChangeWatermark;
   } else if (mode_lib->vba.WritebackPixelFormat[k] == dm_420_10) {
    WritebackDRAMClockChangeLatencyMargin =
      dml_min(
        (double) mode_lib->vba.WritebackInterfaceLumaBufferSize
          * 8.0 / 10,
        2.0
          * mode_lib->vba.WritebackInterfaceChromaBufferSize
          * 8 / 10)
        / (mode_lib->vba.WritebackDestinationWidth[k]
          * mode_lib->vba.WritebackDestinationHeight[k]
          / (mode_lib->vba.WritebackSourceHeight[k]
            * mode_lib->vba.HTotal[k]
            / mode_lib->vba.PixelClock[k]))
        - mode_lib->vba.WritebackDRAMClockChangeWatermark;
   } else {
    WritebackDRAMClockChangeLatencyMargin =
      dml_min(
        (double) mode_lib->vba.WritebackInterfaceLumaBufferSize,
        2.0
          * mode_lib->vba.WritebackInterfaceChromaBufferSize)
        / (mode_lib->vba.WritebackDestinationWidth[k]
          * mode_lib->vba.WritebackDestinationHeight[k]
          / (mode_lib->vba.WritebackSourceHeight[k]
            * mode_lib->vba.HTotal[k]
            / mode_lib->vba.PixelClock[k]))
        - mode_lib->vba.WritebackDRAMClockChangeWatermark;
   }
   mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(
     mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k],
     WritebackDRAMClockChangeLatencyMargin);
  }
 }

 mode_lib->vba.MinActiveDRAMClockChangeMargin = 999999;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k]
    < mode_lib->vba.MinActiveDRAMClockChangeMargin) {
   mode_lib->vba.MinActiveDRAMClockChangeMargin =
     mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k];
  }
 }

 mode_lib->vba.MinActiveDRAMClockChangeLatencySupported =
   mode_lib->vba.MinActiveDRAMClockChangeMargin
     + mode_lib->vba.DRAMClockChangeLatency;

 if (mode_lib->vba.DRAMClockChangeSupportsVActive &&
   mode_lib->vba.MinActiveDRAMClockChangeMargin > 60) {
  mode_lib->vba.DRAMClockChangeWatermark += 25;
  mode_lib->vba.DRAMClockChangeSupport[0][0] = dm_dram_clock_change_vactive;
 } else {
  if (mode_lib->vba.SynchronizedVBlank || mode_lib->vba.NumberOfActivePlanes == 1) {
   mode_lib->vba.DRAMClockChangeSupport[0][0] = dm_dram_clock_change_vblank;
   for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
    if (!mode_lib->vba.AllowDRAMClockChangeDuringVBlank[k]) {
     mode_lib->vba.DRAMClockChangeSupport[0][0] =
       dm_dram_clock_change_unsupported;
    }
   }
  } else {
   mode_lib->vba.DRAMClockChangeSupport[0][0] = dm_dram_clock_change_unsupported;
  }
 }
 for (k = 0; k <= mode_lib->vba.soc.num_states; k++)
  for (j = 0; j < 2; j++)
   mode_lib->vba.DRAMClockChangeSupport[k][j] = mode_lib->vba.DRAMClockChangeSupport[0][0];


 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  if (mode_lib->vba.XFCEnabled[k] == true) {
   double TWait;

   mode_lib->vba.XFCSlaveVUpdateOffset[k] = mode_lib->vba.XFCTSlvVupdateOffset;
   mode_lib->vba.XFCSlaveVupdateWidth[k] = mode_lib->vba.XFCTSlvVupdateWidth;
   mode_lib->vba.XFCSlaveVReadyOffset[k] = mode_lib->vba.XFCTSlvVreadyOffset;
   TWait = CalculateTWait(
     mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb],
     mode_lib->vba.DRAMClockChangeLatency,
     mode_lib->vba.UrgentLatencyPixelDataOnly,
     mode_lib->vba.SREnterPlusExitTime);
   mode_lib->vba.XFCRemoteSurfaceFlipDelay = CalculateRemoteSurfaceFlipDelay(
     mode_lib,
     mode_lib->vba.VRatio[k],
     mode_lib->vba.SwathWidthY[k],
     dml_ceil(mode_lib->vba.BytePerPixelDETY[k], 1),
     mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],
     mode_lib->vba.XFCTSlvVupdateOffset,
     mode_lib->vba.XFCTSlvVupdateWidth,
     mode_lib->vba.XFCTSlvVreadyOffset,
     mode_lib->vba.XFCXBUFLatencyTolerance,
     mode_lib->vba.XFCFillBWOverhead,
     mode_lib->vba.XFCSlvChunkSize,
     mode_lib->vba.XFCBusTransportTime,
     mode_lib->vba.TCalc,
     TWait,
     &mode_lib->vba.SrcActiveDrainRate,
     &mode_lib->vba.TInitXFill,
     &mode_lib->vba.TslvChk);
   mode_lib->vba.XFCRemoteSurfaceFlipLatency[k] =
     dml_floor(
       mode_lib->vba.XFCRemoteSurfaceFlipDelay
         / (mode_lib->vba.HTotal[k]
           / mode_lib->vba.PixelClock[k]),
       1);
   mode_lib->vba.XFCTransferDelay[k] =
     dml_ceil(
       mode_lib->vba.XFCBusTransportTime
         / (mode_lib->vba.HTotal[k]
           / mode_lib->vba.PixelClock[k]),
       1);
   mode_lib->vba.XFCPrechargeDelay[k] =
     dml_ceil(
       (mode_lib->vba.XFCBusTransportTime
         + mode_lib->vba.TInitXFill
         + mode_lib->vba.TslvChk)
         / (mode_lib->vba.HTotal[k]
           / mode_lib->vba.PixelClock[k]),
       1);
   mode_lib->vba.InitFillLevel = mode_lib->vba.XFCXBUFLatencyTolerance
     * mode_lib->vba.SrcActiveDrainRate;
   mode_lib->vba.FinalFillMargin =
     (mode_lib->vba.DestinationLinesToRequestVMInVBlank[k]
       + mode_lib->vba.DestinationLinesToRequestRowInVBlank[k])
       * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k]
       * mode_lib->vba.SrcActiveDrainRate
       + mode_lib->vba.XFCFillConstant;
   mode_lib->vba.FinalFillLevel = mode_lib->vba.XFCRemoteSurfaceFlipDelay
     * mode_lib->vba.SrcActiveDrainRate
     + mode_lib->vba.FinalFillMargin;
   mode_lib->vba.RemainingFillLevel = dml_max(
     0.0,
     mode_lib->vba.FinalFillLevel - mode_lib->vba.InitFillLevel);
   mode_lib->vba.TFinalxFill = mode_lib->vba.RemainingFillLevel
     / (mode_lib->vba.SrcActiveDrainRate
       * mode_lib->vba.XFCFillBWOverhead / 100);
   mode_lib->vba.XFCPrefetchMargin[k] =
     mode_lib->vba.XFCRemoteSurfaceFlipDelay
       + mode_lib->vba.TFinalxFill
       + (mode_lib->vba.DestinationLinesToRequestVMInVBlank[k]
         + mode_lib->vba.DestinationLinesToRequestRowInVBlank[k])
         * mode_lib->vba.HTotal[k]
         / mode_lib->vba.PixelClock[k];
  } else {
   mode_lib->vba.XFCSlaveVUpdateOffset[k] = 0;
   mode_lib->vba.XFCSlaveVupdateWidth[k] = 0;
   mode_lib->vba.XFCSlaveVReadyOffset[k] = 0;
   mode_lib->vba.XFCRemoteSurfaceFlipLatency[k] = 0;
   mode_lib->vba.XFCPrechargeDelay[k] = 0;
   mode_lib->vba.XFCTransferDelay[k] = 0;
   mode_lib->vba.XFCPrefetchMargin[k] = 0;
  }
 }
 {
  unsigned int VStartupMargin = 0;
  bool FirstMainPlane = true;

  for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
   if (mode_lib->vba.BlendingAndTiming[k] == k) {
    unsigned int Margin = (mode_lib->vba.MaxVStartupLines[k] - mode_lib->vba.VStartup[k])
      * mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k];

    if (FirstMainPlane) {
     VStartupMargin = Margin;
     FirstMainPlane = false;
    } else
     VStartupMargin = dml_min(VStartupMargin, Margin);
  }

  if (mode_lib->vba.UseMaximumVStartup) {
   if (mode_lib->vba.VTotal_Max[k] == mode_lib->vba.VTotal[k]) {

    mode_lib->vba.VStartup[k] = mode_lib->vba.MaxVStartupLines[mode_lib->vba.BlendingAndTiming[k]];
   }
  }
 }
}
}

static void dml20_DisplayPipeConfiguration(struct display_mode_lib *mode_lib)
{
 double BytePerPixDETY;
 double BytePerPixDETC;
 double Read256BytesBlockHeightY;
 double Read256BytesBlockHeightC;
 double Read256BytesBlockWidthY;
 double Read256BytesBlockWidthC;
 double MaximumSwathHeightY;
 double MaximumSwathHeightC;
 double MinimumSwathHeightY;
 double MinimumSwathHeightC;
 double SwathWidth;
 double SwathWidthGranularityY;
 double SwathWidthGranularityC;
 double RoundedUpMaxSwathSizeBytesY;
 double RoundedUpMaxSwathSizeBytesC;
 unsigned int j, k;

 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
  bool MainPlaneDoesODMCombine = false;

  if (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {
   BytePerPixDETY = 8;
   BytePerPixDETC = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {
   BytePerPixDETY = 4;
   BytePerPixDETC = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16) {
   BytePerPixDETY = 2;
   BytePerPixDETC = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8) {
   BytePerPixDETY = 1;
   BytePerPixDETC = 0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {
   BytePerPixDETY = 1;
   BytePerPixDETC = 2;
  } else {
   BytePerPixDETY = 4.0 / 3.0;
   BytePerPixDETC = 8.0 / 3.0;
  }

  if ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_32
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_16
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_8)) {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {
    Read256BytesBlockHeightY = 1;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {
    Read256BytesBlockHeightY = 4;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32
     || mode_lib->vba.SourcePixelFormat[k] == dm_444_16) {
    Read256BytesBlockHeightY = 8;
   } else {
    Read256BytesBlockHeightY = 16;
   }
   Read256BytesBlockWidthY = 256 / dml_ceil(BytePerPixDETY, 1)
     / Read256BytesBlockHeightY;
   Read256BytesBlockHeightC = 0;
   Read256BytesBlockWidthC = 0;
  } else {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {
    Read256BytesBlockHeightY = 1;
    Read256BytesBlockHeightC = 1;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {
    Read256BytesBlockHeightY = 16;
    Read256BytesBlockHeightC = 8;
   } else {
    Read256BytesBlockHeightY = 8;
    Read256BytesBlockHeightC = 8;
   }
   Read256BytesBlockWidthY = 256 / dml_ceil(BytePerPixDETY, 1)
     / Read256BytesBlockHeightY;
   Read256BytesBlockWidthC = 256 / dml_ceil(BytePerPixDETC, 2)
     / Read256BytesBlockHeightC;
  }

  if (mode_lib->vba.SourceScan[k] == dm_horz) {
   MaximumSwathHeightY = Read256BytesBlockHeightY;
   MaximumSwathHeightC = Read256BytesBlockHeightC;
  } else {
   MaximumSwathHeightY = Read256BytesBlockWidthY;
   MaximumSwathHeightC = Read256BytesBlockWidthC;
  }

  if ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_32
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_16
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_8)) {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear
     || (mode_lib->vba.SourcePixelFormat[k] == dm_444_64
       && (mode_lib->vba.SurfaceTiling[k]
         == dm_sw_4kb_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_4kb_s_x
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s_t
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s_x
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_var_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_var_s_x)
       && mode_lib->vba.SourceScan[k] == dm_horz)) {
    MinimumSwathHeightY = MaximumSwathHeightY;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8
     && mode_lib->vba.SourceScan[k] != dm_horz) {
    MinimumSwathHeightY = MaximumSwathHeightY;
   } else {
    MinimumSwathHeightY = MaximumSwathHeightY / 2.0;
   }
   MinimumSwathHeightC = MaximumSwathHeightC;
  } else {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {
    MinimumSwathHeightY = MaximumSwathHeightY;
    MinimumSwathHeightC = MaximumSwathHeightC;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8
     && mode_lib->vba.SourceScan[k] == dm_horz) {
    MinimumSwathHeightY = MaximumSwathHeightY / 2.0;
    MinimumSwathHeightC = MaximumSwathHeightC;
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10
     && mode_lib->vba.SourceScan[k] == dm_horz) {
    MinimumSwathHeightC = MaximumSwathHeightC / 2.0;
    MinimumSwathHeightY = MaximumSwathHeightY;
   } else {
    MinimumSwathHeightY = MaximumSwathHeightY;
    MinimumSwathHeightC = MaximumSwathHeightC;
   }
  }

  if (mode_lib->vba.SourceScan[k] == dm_horz) {
   SwathWidth = mode_lib->vba.ViewportWidth[k];
  } else {
   SwathWidth = mode_lib->vba.ViewportHeight[k];
  }

  if (mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {
   MainPlaneDoesODMCombine = true;
  }
  for (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j) {
   if (mode_lib->vba.BlendingAndTiming[k] == j
     && mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {
    MainPlaneDoesODMCombine = true;
   }
  }

  if (MainPlaneDoesODMCombine == true) {
   SwathWidth = dml_min(
     SwathWidth,
     mode_lib->vba.HActive[k] / 2.0 * mode_lib->vba.HRatio[k]);
  } else {
   if (mode_lib->vba.DPPPerPlane[k] == 0)
    SwathWidth = 0;
   else
    SwathWidth = SwathWidth / mode_lib->vba.DPPPerPlane[k];
  }

  SwathWidthGranularityY = 256 / dml_ceil(BytePerPixDETY, 1) / MaximumSwathHeightY;
  RoundedUpMaxSwathSizeBytesY = (dml_ceil(
    (double) (SwathWidth - 1),
    SwathWidthGranularityY) + SwathWidthGranularityY) * BytePerPixDETY
    * MaximumSwathHeightY;
  if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {
   RoundedUpMaxSwathSizeBytesY = dml_ceil(RoundedUpMaxSwathSizeBytesY, 256)
     + 256;
  }
  if (MaximumSwathHeightC > 0) {
   SwathWidthGranularityC = 256.0 / dml_ceil(BytePerPixDETC, 2)
     / MaximumSwathHeightC;
   RoundedUpMaxSwathSizeBytesC = (dml_ceil(
     (double) (SwathWidth / 2.0 - 1),
     SwathWidthGranularityC) + SwathWidthGranularityC)
     * BytePerPixDETC * MaximumSwathHeightC;
   if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {
    RoundedUpMaxSwathSizeBytesC = dml_ceil(
      RoundedUpMaxSwathSizeBytesC,
      256) + 256;
   }
  } else
   RoundedUpMaxSwathSizeBytesC = 0.0;

  if (RoundedUpMaxSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC
    <= mode_lib->vba.DETBufferSizeInKByte * 1024.0 / 2.0) {
   mode_lib->vba.SwathHeightY[k] = MaximumSwathHeightY;
   mode_lib->vba.SwathHeightC[k] = MaximumSwathHeightC;
  } else {
   mode_lib->vba.SwathHeightY[k] = MinimumSwathHeightY;
   mode_lib->vba.SwathHeightC[k] = MinimumSwathHeightC;
  }

  if (mode_lib->vba.SwathHeightC[k] == 0) {
   mode_lib->vba.DETBufferSizeY[k] = mode_lib->vba.DETBufferSizeInKByte * 1024;
   mode_lib->vba.DETBufferSizeC[k] = 0;
  } else if (mode_lib->vba.SwathHeightY[k] <= mode_lib->vba.SwathHeightC[k]) {
   mode_lib->vba.DETBufferSizeY[k] = mode_lib->vba.DETBufferSizeInKByte
     * 1024.0 / 2;
   mode_lib->vba.DETBufferSizeC[k] = mode_lib->vba.DETBufferSizeInKByte
     * 1024.0 / 2;
  } else {
   mode_lib->vba.DETBufferSizeY[k] = mode_lib->vba.DETBufferSizeInKByte
     * 1024.0 * 2 / 3;
   mode_lib->vba.DETBufferSizeC[k] = mode_lib->vba.DETBufferSizeInKByte
     * 1024.0 / 3;
  }
 }
}

static double CalculateTWait(
  unsigned int PrefetchMode,
  double DRAMClockChangeLatency,
  double UrgentLatencyPixelDataOnly,
  double SREnterPlusExitTime)
{
 if (PrefetchMode == 0) {
  return dml_max(
    DRAMClockChangeLatency + UrgentLatencyPixelDataOnly,
    dml_max(SREnterPlusExitTime, UrgentLatencyPixelDataOnly));
 } else if (PrefetchMode == 1) {
  return dml_max(SREnterPlusExitTime, UrgentLatencyPixelDataOnly);
 } else {
  return UrgentLatencyPixelDataOnly;
 }
}

static double CalculateRemoteSurfaceFlipDelay(
  struct display_mode_lib *mode_lib,
  double VRatio,
  double SwathWidth,
  double Bpp,
  double LineTime,
  double XFCTSlvVupdateOffset,
  double XFCTSlvVupdateWidth,
  double XFCTSlvVreadyOffset,
  double XFCXBUFLatencyTolerance,
  double XFCFillBWOverhead,
  double XFCSlvChunkSize,
  double XFCBusTransportTime,
  double TCalc,
  double TWait,
  double *SrcActiveDrainRate,
  double *TInitXFill,
  double *TslvChk)
{
 double TSlvSetup, AvgfillRate, result;

 *SrcActiveDrainRate = VRatio * SwathWidth * Bpp / LineTime;
 TSlvSetup = XFCTSlvVupdateOffset + XFCTSlvVupdateWidth + XFCTSlvVreadyOffset;
 *TInitXFill = XFCXBUFLatencyTolerance / (1 + XFCFillBWOverhead / 100);
 AvgfillRate = *SrcActiveDrainRate * (1 + XFCFillBWOverhead / 100);
 *TslvChk = XFCSlvChunkSize / AvgfillRate;
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug208 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: SrcActiveDrainRate: %f\n"), .lineno = 2968, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug208.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug208.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug208.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug208.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug208, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: SrcActiveDrainRate: %f\n", *SrcActiveDrainRate); } while (0); };


 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug209 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TSlvSetup: %f\n"), .lineno = 2969, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug209.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug209.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug209.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug209.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug209, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TSlvSetup: %f\n", TSlvSetup); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug210 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TInitXFill: %f\n"), .lineno = 2970, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug210.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug210.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug210.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug210.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug210, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TInitXFill: %f\n", *TInitXFill); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug211 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: AvgfillRate: %f\n"), .lineno = 2971, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug211.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug211.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug211.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug211.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug211, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: AvgfillRate: %f\n", AvgfillRate); } while (0); };
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug212 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TslvChk: %f\n"), .lineno = 2972, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug212.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug212.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug212.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug212.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug212, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: TslvChk: %f\n", *TslvChk); } while (0); };
 result = 2 * XFCBusTransportTime + TSlvSetup + TCalc + TWait + *TslvChk + *TInitXFill;
 {do { static struct _ddebug __attribute__((__aligned__(8))) __attribute__((section("__verbose"))) __UNIQUE_ID_ddebug213 = { .modname = "amdgpu", .function = __func__, .filename = "drivers/gpu/drm/amd/amdgpu/../display/dc/dml/dcn20/display_mode_vba_20.c", .format = ("[DML]:""DML::CalculateRemoteSurfaceFlipDelay: RemoteSurfaceFlipDelay: %f\n"), .lineno = 2974, .flags = 0, .key.dd_key_false = ((struct static_key_false){ .key = { .enabled = { 0 }, { .entries = (void *)0UL } }, }) }; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug213.key.dd_key_false), struct static_key_true)) branch = arch_static_branch_jump(&(&__UNIQUE_ID_ddebug213.key.dd_key_false)->key, false); else if (__builtin_types_compatible_p(typeof(*&__UNIQUE_ID_ddebug213.key.dd_key_false), struct static_key_false)) branch = arch_static_branch(&(&__UNIQUE_ID_ddebug213.key.dd_key_false)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) __dynamic_pr_debug(&__UNIQUE_ID_ddebug213, "[DML]:""DML::CalculateRemoteSurfaceFlipDelay: RemoteSurfaceFlipDelay: %f\n", result); } while (0); };
 return result;
}

static double CalculateWriteBackDelay(
  enum source_format_class WritebackPixelFormat,
  double WritebackHRatio,
  double WritebackVRatio,
  unsigned int WritebackLumaHTaps,
  unsigned int WritebackLumaVTaps,
  unsigned int WritebackChromaHTaps,
  unsigned int WritebackChromaVTaps,
  unsigned int WritebackDestinationWidth)
{
 double CalculateWriteBackDelay =
   dml_max(
     dml_ceil(WritebackLumaHTaps / 4.0, 1) / WritebackHRatio,
     WritebackLumaVTaps * dml_ceil(1.0 / WritebackVRatio, 1)
       * dml_ceil(
         WritebackDestinationWidth
           / 4.0,
         1)
       + dml_ceil(1.0 / WritebackVRatio, 1)
         * (dml_ceil(
           WritebackLumaVTaps
             / 4.0,
           1) + 4));

 if (WritebackPixelFormat != dm_444_32) {
  CalculateWriteBackDelay =
    dml_max(
      CalculateWriteBackDelay,
      dml_max(
        dml_ceil(
          WritebackChromaHTaps
            / 2.0,
          1)
          / (2
            * WritebackHRatio),
        WritebackChromaVTaps
          * dml_ceil(
            1
              / (2
                * WritebackVRatio),
            1)
          * dml_ceil(
            WritebackDestinationWidth
              / 2.0
              / 2.0,
            1)
          + dml_ceil(
            1
              / (2
                * WritebackVRatio),
            1)
            * (dml_ceil(
              WritebackChromaVTaps
                / 4.0,
              1)
              + 4)));
 }
 return CalculateWriteBackDelay;
}

static void CalculateActiveRowBandwidth(
  bool GPUVMEnable,
  enum source_format_class SourcePixelFormat,
  double VRatio,
  bool DCCEnable,
  double LineTime,
  unsigned int MetaRowByteLuma,
  unsigned int MetaRowByteChroma,
  unsigned int meta_row_height_luma,
  unsigned int meta_row_height_chroma,
  unsigned int PixelPTEBytesPerRowLuma,
  unsigned int PixelPTEBytesPerRowChroma,
  unsigned int dpte_row_height_luma,
  unsigned int dpte_row_height_chroma,
  double *meta_row_bw,
  double *dpte_row_bw,
  double *qual_row_bw)
{
 if (DCCEnable != true) {
  *meta_row_bw = 0;
 } else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {
  *meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime)
    + VRatio / 2 * MetaRowByteChroma
      / (meta_row_height_chroma * LineTime);
 } else {
  *meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime);
 }

 if (GPUVMEnable != true) {
  *dpte_row_bw = 0;
 } else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {
  *dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime)
    + VRatio / 2 * PixelPTEBytesPerRowChroma
      / (dpte_row_height_chroma * LineTime);
 } else {
  *dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime);
 }

 if ((SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10)) {
  *qual_row_bw = *meta_row_bw + *dpte_row_bw;
 } else {
  *qual_row_bw = 0;
 }
}

static void CalculateFlipSchedule(
  struct display_mode_lib *mode_lib,
  double UrgentExtraLatency,
  double UrgentLatencyPixelDataOnly,
  unsigned int GPUVMMaxPageTableLevels,
  bool GPUVMEnable,
  double BandwidthAvailableForImmediateFlip,
  unsigned int TotImmediateFlipBytes,
  enum source_format_class SourcePixelFormat,
  unsigned int ImmediateFlipBytes,
  double LineTime,
  double VRatio,
  double Tno_bw,
  double PDEAndMetaPTEBytesFrame,
  unsigned int MetaRowByte,
  unsigned int PixelPTEBytesPerRow,
  bool DCCEnable,
  unsigned int dpte_row_height,
  unsigned int meta_row_height,
  double qual_row_bw,
  double *DestinationLinesToRequestVMInImmediateFlip,
  double *DestinationLinesToRequestRowInImmediateFlip,
  double *final_flip_bw,
  bool *ImmediateFlipSupportedForPipe)
{
 double min_row_time = 0.0;

 if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {
  *DestinationLinesToRequestVMInImmediateFlip = 0.0;
  *DestinationLinesToRequestRowInImmediateFlip = 0.0;
  *final_flip_bw = qual_row_bw;
  *ImmediateFlipSupportedForPipe = true;
 } else {
  double TimeForFetchingMetaPTEImmediateFlip;
  double TimeForFetchingRowInVBlankImmediateFlip;

  if (GPUVMEnable == true) {
   mode_lib->vba.ImmediateFlipBW[0] = BandwidthAvailableForImmediateFlip
     * ImmediateFlipBytes / TotImmediateFlipBytes;
   TimeForFetchingMetaPTEImmediateFlip =
     dml_max(
       Tno_bw
         + PDEAndMetaPTEBytesFrame
           / mode_lib->vba.ImmediateFlipBW[0],
       dml_max(
         UrgentExtraLatency
           + UrgentLatencyPixelDataOnly
             * (GPUVMMaxPageTableLevels
               - 1),
         LineTime / 4.0));
  } else {
   TimeForFetchingMetaPTEImmediateFlip = 0;
  }

  *DestinationLinesToRequestVMInImmediateFlip = dml_floor(
    4.0 * (TimeForFetchingMetaPTEImmediateFlip / LineTime + 0.125),
    1) / 4.0;

  if ((GPUVMEnable == true || DCCEnable == true)) {
   mode_lib->vba.ImmediateFlipBW[0] = BandwidthAvailableForImmediateFlip
     * ImmediateFlipBytes / TotImmediateFlipBytes;
   TimeForFetchingRowInVBlankImmediateFlip = dml_max(
     (MetaRowByte + PixelPTEBytesPerRow)
       / mode_lib->vba.ImmediateFlipBW[0],
     dml_max(UrgentLatencyPixelDataOnly, LineTime / 4.0));
  } else {
   TimeForFetchingRowInVBlankImmediateFlip = 0;
  }

  *DestinationLinesToRequestRowInImmediateFlip = dml_floor(
    4.0 * (TimeForFetchingRowInVBlankImmediateFlip / LineTime + 0.125),
    1) / 4.0;

  if (GPUVMEnable == true) {
   *final_flip_bw =
     dml_max(
       PDEAndMetaPTEBytesFrame
         / (*DestinationLinesToRequestVMInImmediateFlip
           * LineTime),
       (MetaRowByte + PixelPTEBytesPerRow)
         / (TimeForFetchingRowInVBlankImmediateFlip
           * LineTime));
  } else if (MetaRowByte + PixelPTEBytesPerRow > 0) {
   *final_flip_bw = (MetaRowByte + PixelPTEBytesPerRow)
     / (TimeForFetchingRowInVBlankImmediateFlip * LineTime);
  } else {
   *final_flip_bw = 0;
  }

  if (GPUVMEnable && !DCCEnable)
   min_row_time = dpte_row_height * LineTime / VRatio;
  else if (!GPUVMEnable && DCCEnable)
   min_row_time = meta_row_height * LineTime / VRatio;
  else
   min_row_time = dml_min(dpte_row_height, meta_row_height) * LineTime
     / VRatio;

  if (*DestinationLinesToRequestVMInImmediateFlip >= 8
    || *DestinationLinesToRequestRowInImmediateFlip >= 16
    || TimeForFetchingMetaPTEImmediateFlip
      + 2 * TimeForFetchingRowInVBlankImmediateFlip
      > min_row_time)
   *ImmediateFlipSupportedForPipe = false;
  else
   *ImmediateFlipSupportedForPipe = true;
 }
}

static unsigned int TruncToValidBPP(
  double DecimalBPP,
  bool DSCEnabled,
  enum output_encoder_class Output,
  enum output_format_class Format,
  unsigned int DSCInputBitPerComponent)
{
 if (Output == dm_hdmi) {
  if (Format == dm_420) {
   if (DecimalBPP >= 18)
    return 18;
   else if (DecimalBPP >= 15)
    return 15;
   else if (DecimalBPP >= 12)
    return 12;
   else
    return 0;
  } else if (Format == dm_444) {
   if (DecimalBPP >= 36)
    return 36;
   else if (DecimalBPP >= 30)
    return 30;
   else if (DecimalBPP >= 24)
    return 24;
   else if (DecimalBPP >= 18)
    return 18;
   else
    return 0;
  } else {
   if (DecimalBPP / 1.5 >= 24)
    return 24;
   else if (DecimalBPP / 1.5 >= 20)
    return 20;
   else if (DecimalBPP / 1.5 >= 16)
    return 16;
   else
    return 0;
  }
 } else {
  if (DSCEnabled) {
   if (Format == dm_420) {
    if (DecimalBPP < 6)
     return 0;
    else if (DecimalBPP >= 1.5 * DSCInputBitPerComponent - 1 / 16)
     return 1.5 * DSCInputBitPerComponent - 1 / 16;
    else
     return dml_floor(16 * DecimalBPP, 1) / 16;
   } else if (Format == dm_n422) {
    if (DecimalBPP < 7)
     return 0;
    else if (DecimalBPP >= 2 * DSCInputBitPerComponent - 1 / 16)
     return 2 * DSCInputBitPerComponent - 1 / 16;
    else
     return dml_floor(16 * DecimalBPP, 1) / 16;
   } else {
    if (DecimalBPP < 8)
     return 0;
    else if (DecimalBPP >= 3 * DSCInputBitPerComponent - 1 / 16)
     return 3 * DSCInputBitPerComponent - 1 / 16;
    else
     return dml_floor(16 * DecimalBPP, 1) / 16;
   }
  } else if (Format == dm_420) {
   if (DecimalBPP >= 18)
    return 18;
   else if (DecimalBPP >= 15)
    return 15;
   else if (DecimalBPP >= 12)
    return 12;
   else
    return 0;
  } else if (Format == dm_s422 || Format == dm_n422) {
   if (DecimalBPP >= 24)
    return 24;
   else if (DecimalBPP >= 20)
    return 20;
   else if (DecimalBPP >= 16)
    return 16;
   else
    return 0;
  } else {
   if (DecimalBPP >= 36)
    return 36;
   else if (DecimalBPP >= 30)
    return 30;
   else if (DecimalBPP >= 24)
    return 24;
   else if (DecimalBPP >= 18)
    return 18;
   else
    return 0;
  }
 }
}

void dml20_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_lib)
{
 struct vba_vars_st *locals = &mode_lib->vba;

 int i;
 unsigned int j, k, m;





 mode_lib->vba.ScaleRatioAndTapsSupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.ScalerEnabled[k] == false
    && ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_32
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_8)
      || mode_lib->vba.HRatio[k] != 1.0
      || mode_lib->vba.htaps[k] != 1.0
      || mode_lib->vba.VRatio[k] != 1.0
      || mode_lib->vba.vtaps[k] != 1.0)) {
   mode_lib->vba.ScaleRatioAndTapsSupport = false;
  } else if (mode_lib->vba.vtaps[k] < 1.0 || mode_lib->vba.vtaps[k] > 8.0
    || mode_lib->vba.htaps[k] < 1.0 || mode_lib->vba.htaps[k] > 8.0
    || (mode_lib->vba.htaps[k] > 1.0
      && (mode_lib->vba.htaps[k] % 2) == 1)
    || mode_lib->vba.HRatio[k] > mode_lib->vba.MaxHSCLRatio
    || mode_lib->vba.VRatio[k] > mode_lib->vba.MaxVSCLRatio
    || mode_lib->vba.HRatio[k] > mode_lib->vba.htaps[k]
    || mode_lib->vba.VRatio[k] > mode_lib->vba.vtaps[k]
    || (mode_lib->vba.SourcePixelFormat[k] != dm_444_64
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_32
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_8
      && (mode_lib->vba.HRatio[k] / 2.0
        > mode_lib->vba.HTAPsChroma[k]
        || mode_lib->vba.VRatio[k] / 2.0
          > mode_lib->vba.VTAPsChroma[k]))) {
   mode_lib->vba.ScaleRatioAndTapsSupport = false;
  }
 }


 mode_lib->vba.SourceFormatPixelAndScanSupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if ((mode_lib->vba.SurfaceTiling[k] == dm_sw_linear
    && mode_lib->vba.SourceScan[k] != dm_horz)
    || ((mode_lib->vba.SurfaceTiling[k] == dm_sw_4kb_d
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_4kb_d_x
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d_t
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d_x
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_var_d
      || mode_lib->vba.SurfaceTiling[k] == dm_sw_var_d_x)
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_64)
    || (mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_r_x
      && (mode_lib->vba.SourcePixelFormat[k] == dm_mono_8
        || mode_lib->vba.SourcePixelFormat[k]
          == dm_420_8
        || mode_lib->vba.SourcePixelFormat[k]
          == dm_420_10))
    || (((mode_lib->vba.SurfaceTiling[k] == dm_sw_gfx7_2d_thin_gl
      || mode_lib->vba.SurfaceTiling[k]
        == dm_sw_gfx7_2d_thin_l_vp)
      && !((mode_lib->vba.SourcePixelFormat[k]
        == dm_444_64
        || mode_lib->vba.SourcePixelFormat[k]
          == dm_444_32)
        && mode_lib->vba.SourceScan[k]
          == dm_horz
        && mode_lib->vba.SupportGFX7CompatibleTilingIn32bppAnd64bpp
          == true
        && mode_lib->vba.DCCEnable[k]
          == false))
      || (mode_lib->vba.DCCEnable[k] == true
        && (mode_lib->vba.SurfaceTiling[k]
          == dm_sw_linear
          || mode_lib->vba.SourcePixelFormat[k]
            == dm_420_8
          || mode_lib->vba.SourcePixelFormat[k]
            == dm_420_10)))) {
   mode_lib->vba.SourceFormatPixelAndScanSupport = false;
  }
 }


 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {
   locals->BytePerPixelInDETY[k] = 8.0;
   locals->BytePerPixelInDETC[k] = 0.0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {
   locals->BytePerPixelInDETY[k] = 4.0;
   locals->BytePerPixelInDETC[k] = 0.0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16
    || mode_lib->vba.SourcePixelFormat[k] == dm_mono_16) {
   locals->BytePerPixelInDETY[k] = 2.0;
   locals->BytePerPixelInDETC[k] = 0.0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_mono_8) {
   locals->BytePerPixelInDETY[k] = 1.0;
   locals->BytePerPixelInDETC[k] = 0.0;
  } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {
   locals->BytePerPixelInDETY[k] = 1.0;
   locals->BytePerPixelInDETC[k] = 2.0;
  } else {
   locals->BytePerPixelInDETY[k] = 4.0 / 3;
   locals->BytePerPixelInDETC[k] = 8.0 / 3;
  }
  if (mode_lib->vba.SourceScan[k] == dm_horz) {
   locals->SwathWidthYSingleDPP[k] = mode_lib->vba.ViewportWidth[k];
  } else {
   locals->SwathWidthYSingleDPP[k] = mode_lib->vba.ViewportHeight[k];
  }
 }
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  locals->ReadBandwidthLuma[k] = locals->SwathWidthYSingleDPP[k] * dml_ceil(locals->BytePerPixelInDETY[k], 1.0)
    / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k];
  locals->ReadBandwidthChroma[k] = locals->SwathWidthYSingleDPP[k] / 2 * dml_ceil(locals->BytePerPixelInDETC[k], 2.0)
    / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k] / 2.0;
  locals->ReadBandwidth[k] = locals->ReadBandwidthLuma[k] + locals->ReadBandwidthChroma[k];
 }
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true
    && mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {
   locals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]
     * mode_lib->vba.WritebackDestinationHeight[k]
     / (mode_lib->vba.WritebackSourceHeight[k]
       * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k]) * 4.0;
  } else if (mode_lib->vba.WritebackEnable[k] == true
    && mode_lib->vba.WritebackPixelFormat[k] == dm_420_10) {
   locals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]
     * mode_lib->vba.WritebackDestinationHeight[k]
     / (mode_lib->vba.WritebackSourceHeight[k]
       * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k]) * 3.0;
  } else if (mode_lib->vba.WritebackEnable[k] == true) {
   locals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]
     * mode_lib->vba.WritebackDestinationHeight[k]
     / (mode_lib->vba.WritebackSourceHeight[k]
       * mode_lib->vba.HTotal[k]
       / mode_lib->vba.PixelClock[k]) * 1.5;
  } else {
   locals->WriteBandwidth[k] = 0.0;
  }
 }
 mode_lib->vba.DCCEnabledInAnyPlane = false;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.DCCEnable[k] == true) {
   mode_lib->vba.DCCEnabledInAnyPlane = true;
  }
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  locals->FabricAndDRAMBandwidthPerState[i] = dml_min(
    mode_lib->vba.DRAMSpeedPerState[i] * mode_lib->vba.NumberOfChannels
      * mode_lib->vba.DRAMChannelWidth,
    mode_lib->vba.FabricClockPerState[i]
      * mode_lib->vba.FabricDatapathToDCNDataReturn) / 1000;
  locals->ReturnBWToDCNPerState = dml_min(locals->ReturnBusWidth * locals->DCFCLKPerState[i],
    locals->FabricAndDRAMBandwidthPerState[i] * 1000)
    * locals->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly / 100;

  locals->ReturnBWPerState[i][0] = locals->ReturnBWToDCNPerState;

  if (locals->DCCEnabledInAnyPlane == true && locals->ReturnBWToDCNPerState > locals->DCFCLKPerState[i] * locals->ReturnBusWidth / 4) {
   locals->ReturnBWPerState[i][0] = dml_min(locals->ReturnBWPerState[i][0],
     locals->ReturnBWToDCNPerState * 4 * (1 - locals->UrgentLatency /
     ((locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024
     / (locals->ReturnBWToDCNPerState - locals->DCFCLKPerState[i]
     * locals->ReturnBusWidth / 4) + locals->UrgentLatency)));
  }
  locals->CriticalPoint = 2 * locals->ReturnBusWidth * locals->DCFCLKPerState[i] *
    locals->UrgentLatency / (locals->ReturnBWToDCNPerState * locals->UrgentLatency
    + (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024);

  if (locals->DCCEnabledInAnyPlane && locals->CriticalPoint > 1 && locals->CriticalPoint < 4) {
   locals->ReturnBWPerState[i][0] = dml_min(locals->ReturnBWPerState[i][0],
    4 * locals->ReturnBWToDCNPerState *
    (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024
    * locals->ReturnBusWidth * locals->DCFCLKPerState[i] * locals->UrgentLatency /
    dml_pow((locals->ReturnBWToDCNPerState * locals->UrgentLatency
    + (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024), 2));
  }

  locals->ReturnBWToDCNPerState = dml_min(locals->ReturnBusWidth *
    locals->DCFCLKPerState[i], locals->FabricAndDRAMBandwidthPerState[i] * 1000);

  if (locals->DCCEnabledInAnyPlane == true && locals->ReturnBWToDCNPerState > locals->DCFCLKPerState[i] * locals->ReturnBusWidth / 4) {
   locals->ReturnBWPerState[i][0] = dml_min(locals->ReturnBWPerState[i][0],
     locals->ReturnBWToDCNPerState * 4 * (1 - locals->UrgentLatency /
     ((locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024
     / (locals->ReturnBWToDCNPerState - locals->DCFCLKPerState[i]
     * locals->ReturnBusWidth / 4) + locals->UrgentLatency)));
  }
  locals->CriticalPoint = 2 * locals->ReturnBusWidth * locals->DCFCLKPerState[i] *
    locals->UrgentLatency / (locals->ReturnBWToDCNPerState * locals->UrgentLatency
    + (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024);

  if (locals->DCCEnabledInAnyPlane && locals->CriticalPoint > 1 && locals->CriticalPoint < 4) {
   locals->ReturnBWPerState[i][0] = dml_min(locals->ReturnBWPerState[i][0],
    4 * locals->ReturnBWToDCNPerState *
    (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024
    * locals->ReturnBusWidth * locals->DCFCLKPerState[i] * locals->UrgentLatency /
    dml_pow((locals->ReturnBWToDCNPerState * locals->UrgentLatency
    + (locals->ROBBufferSizeInKByte - locals->PixelChunkSizeInKByte) * 1024), 2));
  }
 }


 mode_lib->vba.WritebackLatencySupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true) {
   if (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {
    if (locals->WriteBandwidth[k]
      > (mode_lib->vba.WritebackInterfaceLumaBufferSize
        + mode_lib->vba.WritebackInterfaceChromaBufferSize)
        / mode_lib->vba.WritebackLatency) {
     mode_lib->vba.WritebackLatencySupport = false;
    }
   } else {
    if (locals->WriteBandwidth[k]
      > 1.5
        * dml_min(
          mode_lib->vba.WritebackInterfaceLumaBufferSize,
          2.0
            * mode_lib->vba.WritebackInterfaceChromaBufferSize)
        / mode_lib->vba.WritebackLatency) {
     mode_lib->vba.WritebackLatencySupport = false;
    }
   }
  }
 }


 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  locals->UrgentRoundTripAndOutOfOrderLatencyPerState[i] =
    (mode_lib->vba.RoundTripPingLatencyCycles + 32.0) / mode_lib->vba.DCFCLKPerState[i]
    + locals->UrgentOutOfOrderReturnPerChannel * mode_lib->vba.NumberOfChannels / locals->ReturnBWPerState[i][0];
  if ((mode_lib->vba.ROBBufferSizeInKByte - mode_lib->vba.PixelChunkSizeInKByte) * 1024.0 / locals->ReturnBWPerState[i][0]
    > locals->UrgentRoundTripAndOutOfOrderLatencyPerState[i]) {
   locals->ROBSupport[i][0] = true;
  } else {
   locals->ROBSupport[i][0] = false;
  }
 }


 mode_lib->vba.TotalNumberOfActiveWriteback = 0;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true) {
   if (mode_lib->vba.ActiveWritebacksPerPlane[k] == 0)
    mode_lib->vba.ActiveWritebacksPerPlane[k] = 1;
   mode_lib->vba.TotalNumberOfActiveWriteback =
     mode_lib->vba.TotalNumberOfActiveWriteback
       + mode_lib->vba.ActiveWritebacksPerPlane[k];
  }
 }
 mode_lib->vba.WritebackModeSupport = true;
 if (mode_lib->vba.TotalNumberOfActiveWriteback > mode_lib->vba.MaxNumWriteback) {
  mode_lib->vba.WritebackModeSupport = false;
 }
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true
    && mode_lib->vba.Writeback10bpc420Supported != true
    && mode_lib->vba.WritebackPixelFormat[k] == dm_420_10) {
   mode_lib->vba.WritebackModeSupport = false;
  }
 }


 mode_lib->vba.WritebackScaleRatioAndTapsSupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true) {
   if (mode_lib->vba.WritebackLumaAndChromaScalingSupported == false
     && (mode_lib->vba.WritebackHRatio[k] != 1.0
       || mode_lib->vba.WritebackVRatio[k] != 1.0)) {
    mode_lib->vba.WritebackScaleRatioAndTapsSupport = false;
   }
   if (mode_lib->vba.WritebackHRatio[k] > mode_lib->vba.WritebackMaxHSCLRatio
     || mode_lib->vba.WritebackVRatio[k]
       > mode_lib->vba.WritebackMaxVSCLRatio
     || mode_lib->vba.WritebackHRatio[k]
       < mode_lib->vba.WritebackMinHSCLRatio
     || mode_lib->vba.WritebackVRatio[k]
       < mode_lib->vba.WritebackMinVSCLRatio
     || mode_lib->vba.WritebackLumaHTaps[k]
       > mode_lib->vba.WritebackMaxHSCLTaps
     || mode_lib->vba.WritebackLumaVTaps[k]
       > mode_lib->vba.WritebackMaxVSCLTaps
     || mode_lib->vba.WritebackHRatio[k]
       > mode_lib->vba.WritebackLumaHTaps[k]
     || mode_lib->vba.WritebackVRatio[k]
       > mode_lib->vba.WritebackLumaVTaps[k]
     || (mode_lib->vba.WritebackLumaHTaps[k] > 2.0
       && ((mode_lib->vba.WritebackLumaHTaps[k] % 2)
         == 1))
     || (mode_lib->vba.WritebackPixelFormat[k] != dm_444_32
       && (mode_lib->vba.WritebackChromaHTaps[k]
         > mode_lib->vba.WritebackMaxHSCLTaps
         || mode_lib->vba.WritebackChromaVTaps[k]
           > mode_lib->vba.WritebackMaxVSCLTaps
         || 2.0
           * mode_lib->vba.WritebackHRatio[k]
           > mode_lib->vba.WritebackChromaHTaps[k]
         || 2.0
           * mode_lib->vba.WritebackVRatio[k]
           > mode_lib->vba.WritebackChromaVTaps[k]
         || (mode_lib->vba.WritebackChromaHTaps[k] > 2.0
          && ((mode_lib->vba.WritebackChromaHTaps[k] % 2) == 1))))) {
    mode_lib->vba.WritebackScaleRatioAndTapsSupport = false;
   }
   if (mode_lib->vba.WritebackVRatio[k] < 1.0) {
    mode_lib->vba.WritebackLumaVExtra =
      dml_max(1.0 - 2.0 / dml_ceil(1.0 / mode_lib->vba.WritebackVRatio[k], 1.0), 0.0);
   } else {
    mode_lib->vba.WritebackLumaVExtra = -1;
   }
   if ((mode_lib->vba.WritebackPixelFormat[k] == dm_444_32
     && mode_lib->vba.WritebackLumaVTaps[k]
       > (mode_lib->vba.WritebackLineBufferLumaBufferSize
         + mode_lib->vba.WritebackLineBufferChromaBufferSize)
         / 3.0
         / mode_lib->vba.WritebackDestinationWidth[k]
         - mode_lib->vba.WritebackLumaVExtra)
     || (mode_lib->vba.WritebackPixelFormat[k] == dm_420_8
       && mode_lib->vba.WritebackLumaVTaps[k]
         > mode_lib->vba.WritebackLineBufferLumaBufferSize
           * 8.0 / 10.0 / mode_lib->vba.WritebackDestinationWidth[k]
           - mode_lib->vba.WritebackLumaVExtra)
     || (mode_lib->vba.WritebackPixelFormat[k] == dm_420_10
       && mode_lib->vba.WritebackLumaVTaps[k]
         > mode_lib->vba.WritebackLineBufferLumaBufferSize
           * 8.0 / 10.0
           / mode_lib->vba.WritebackDestinationWidth[k]
           - mode_lib->vba.WritebackLumaVExtra)) {
    mode_lib->vba.WritebackScaleRatioAndTapsSupport = false;
   }
   if (2.0 * mode_lib->vba.WritebackVRatio[k] < 1) {
    mode_lib->vba.WritebackChromaVExtra = 0.0;
   } else {
    mode_lib->vba.WritebackChromaVExtra = -1;
   }
   if ((mode_lib->vba.WritebackPixelFormat[k] == dm_420_8
     && mode_lib->vba.WritebackChromaVTaps[k]
       > mode_lib->vba.WritebackLineBufferChromaBufferSize
         * 8.0 / 10.0 / mode_lib->vba.WritebackDestinationWidth[k]
         - mode_lib->vba.WritebackChromaVExtra)
     || (mode_lib->vba.WritebackPixelFormat[k] == dm_420_10
       && mode_lib->vba.WritebackChromaVTaps[k]
         > mode_lib->vba.WritebackLineBufferChromaBufferSize
           * 8.0 / 10.0
           / mode_lib->vba.WritebackDestinationWidth[k]
           - mode_lib->vba.WritebackChromaVExtra)) {
    mode_lib->vba.WritebackScaleRatioAndTapsSupport = false;
   }
  }
 }


 mode_lib->vba.WritebackRequiredDISPCLK = 0.0;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.WritebackEnable[k] == true) {
   mode_lib->vba.WritebackRequiredDISPCLK =
     dml_max(
       mode_lib->vba.WritebackRequiredDISPCLK,
       CalculateWriteBackDISPCLK(
         mode_lib->vba.WritebackPixelFormat[k],
         mode_lib->vba.PixelClock[k],
         mode_lib->vba.WritebackHRatio[k],
         mode_lib->vba.WritebackVRatio[k],
         mode_lib->vba.WritebackLumaHTaps[k],
         mode_lib->vba.WritebackLumaVTaps[k],
         mode_lib->vba.WritebackChromaHTaps[k],
         mode_lib->vba.WritebackChromaVTaps[k],
         mode_lib->vba.WritebackDestinationWidth[k],
         mode_lib->vba.HTotal[k],
         mode_lib->vba.WritebackChromaLineBufferWidth));
  }
 }
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.HRatio[k] > 1.0) {
   locals->PSCL_FACTOR[k] = dml_min(
     mode_lib->vba.MaxDCHUBToPSCLThroughput,
     mode_lib->vba.MaxPSCLToLBThroughput
       * mode_lib->vba.HRatio[k]
       / dml_ceil(
         mode_lib->vba.htaps[k]
           / 6.0,
         1.0));
  } else {
   locals->PSCL_FACTOR[k] = dml_min(
     mode_lib->vba.MaxDCHUBToPSCLThroughput,
     mode_lib->vba.MaxPSCLToLBThroughput);
  }
  if (locals->BytePerPixelInDETC[k] == 0.0) {
   locals->PSCL_FACTOR_CHROMA[k] = 0.0;
   locals->MinDPPCLKUsingSingleDPP[k] =
     mode_lib->vba.PixelClock[k]
       * dml_max3(
         mode_lib->vba.vtaps[k] / 6.0
           * dml_min(
             1.0,
             mode_lib->vba.HRatio[k]),
         mode_lib->vba.HRatio[k]
           * mode_lib->vba.VRatio[k]
           / locals->PSCL_FACTOR[k],
         1.0);
   if ((mode_lib->vba.htaps[k] > 6.0 || mode_lib->vba.vtaps[k] > 6.0)
     && locals->MinDPPCLKUsingSingleDPP[k]
       < 2.0 * mode_lib->vba.PixelClock[k]) {
    locals->MinDPPCLKUsingSingleDPP[k] = 2.0
      * mode_lib->vba.PixelClock[k];
   }
  } else {
   if (mode_lib->vba.HRatio[k] / 2.0 > 1.0) {
    locals->PSCL_FACTOR_CHROMA[k] =
      dml_min(
        mode_lib->vba.MaxDCHUBToPSCLThroughput,
        mode_lib->vba.MaxPSCLToLBThroughput
          * mode_lib->vba.HRatio[k]
          / 2.0
          / dml_ceil(
            mode_lib->vba.HTAPsChroma[k]
              / 6.0,
            1.0));
   } else {
    locals->PSCL_FACTOR_CHROMA[k] = dml_min(
      mode_lib->vba.MaxDCHUBToPSCLThroughput,
      mode_lib->vba.MaxPSCLToLBThroughput);
   }
   locals->MinDPPCLKUsingSingleDPP[k] =
     mode_lib->vba.PixelClock[k]
       * dml_max5(
         mode_lib->vba.vtaps[k] / 6.0
           * dml_min(
             1.0,
             mode_lib->vba.HRatio[k]),
         mode_lib->vba.HRatio[k]
           * mode_lib->vba.VRatio[k]
           / locals->PSCL_FACTOR[k],
         mode_lib->vba.VTAPsChroma[k]
           / 6.0
           * dml_min(
             1.0,
             mode_lib->vba.HRatio[k]
               / 2.0),
         mode_lib->vba.HRatio[k]
           * mode_lib->vba.VRatio[k]
           / 4.0
           / locals->PSCL_FACTOR_CHROMA[k],
         1.0);
   if ((mode_lib->vba.htaps[k] > 6.0 || mode_lib->vba.vtaps[k] > 6.0
     || mode_lib->vba.HTAPsChroma[k] > 6.0
     || mode_lib->vba.VTAPsChroma[k] > 6.0)
     && locals->MinDPPCLKUsingSingleDPP[k]
       < 2.0 * mode_lib->vba.PixelClock[k]) {
    locals->MinDPPCLKUsingSingleDPP[k] = 2.0
      * mode_lib->vba.PixelClock[k];
   }
  }
 }
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  Calculate256BBlockSizes(
    mode_lib->vba.SourcePixelFormat[k],
    mode_lib->vba.SurfaceTiling[k],
    dml_ceil(locals->BytePerPixelInDETY[k], 1.0),
    dml_ceil(locals->BytePerPixelInDETC[k], 2.0),
    &locals->Read256BlockHeightY[k],
    &locals->Read256BlockHeightC[k],
    &locals->Read256BlockWidthY[k],
    &locals->Read256BlockWidthC[k]);
  if (mode_lib->vba.SourceScan[k] == dm_horz) {
   locals->MaxSwathHeightY[k] = locals->Read256BlockHeightY[k];
   locals->MaxSwathHeightC[k] = locals->Read256BlockHeightC[k];
  } else {
   locals->MaxSwathHeightY[k] = locals->Read256BlockWidthY[k];
   locals->MaxSwathHeightC[k] = locals->Read256BlockWidthC[k];
  }
  if ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_32
    || mode_lib->vba.SourcePixelFormat[k] == dm_444_16
    || mode_lib->vba.SourcePixelFormat[k] == dm_mono_16
    || mode_lib->vba.SourcePixelFormat[k] == dm_mono_8)) {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear
     || (mode_lib->vba.SourcePixelFormat[k] == dm_444_64
       && (mode_lib->vba.SurfaceTiling[k]
         == dm_sw_4kb_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_4kb_s_x
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s_t
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_64kb_s_x
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_var_s
         || mode_lib->vba.SurfaceTiling[k]
           == dm_sw_var_s_x)
       && mode_lib->vba.SourceScan[k] == dm_horz)) {
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];
   } else {
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k]
      / 2.0;
   }
   locals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];
  } else {
   if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];
    locals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8
     && mode_lib->vba.SourceScan[k] == dm_horz) {
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k]
      / 2.0;
    locals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];
   } else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10
     && mode_lib->vba.SourceScan[k] == dm_horz) {
    locals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k]
      / 2.0;
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];
   } else {
    locals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];
    locals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];
   }
  }
  if (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {
   mode_lib->vba.MaximumSwathWidthSupport = 8192.0;
  } else {
   mode_lib->vba.MaximumSwathWidthSupport = 5120.0;
  }
  mode_lib->vba.MaximumSwathWidthInDETBuffer =
    dml_min(
      mode_lib->vba.MaximumSwathWidthSupport,
      mode_lib->vba.DETBufferSizeInKByte * 1024.0 / 2.0
        / (locals->BytePerPixelInDETY[k]
          * locals->MinSwathHeightY[k]
          + locals->BytePerPixelInDETC[k]
            / 2.0
            * locals->MinSwathHeightC[k]));
  if (locals->BytePerPixelInDETC[k] == 0.0) {
   mode_lib->vba.MaximumSwathWidthInLineBuffer =
     mode_lib->vba.LineBufferSize
       * dml_max(mode_lib->vba.HRatio[k], 1.0)
       / mode_lib->vba.LBBitPerPixel[k]
       / (mode_lib->vba.vtaps[k]
         + dml_max(
           dml_ceil(
             mode_lib->vba.VRatio[k],
             1.0)
             - 2,
           0.0));
  } else {
   mode_lib->vba.MaximumSwathWidthInLineBuffer =
     dml_min(
       mode_lib->vba.LineBufferSize
         * dml_max(
           mode_lib->vba.HRatio[k],
           1.0)
         / mode_lib->vba.LBBitPerPixel[k]
         / (mode_lib->vba.vtaps[k]
           + dml_max(
             dml_ceil(
               mode_lib->vba.VRatio[k],
               1.0)
               - 2,
             0.0)),
       2.0 * mode_lib->vba.LineBufferSize
         * dml_max(
           mode_lib->vba.HRatio[k]
             / 2.0,
           1.0)
         / mode_lib->vba.LBBitPerPixel[k]
         / (mode_lib->vba.VTAPsChroma[k]
           + dml_max(
             dml_ceil(
               mode_lib->vba.VRatio[k]
                 / 2.0,
               1.0)
               - 2,
             0.0)));
  }
  locals->MaximumSwathWidth[k] = dml_min(
    mode_lib->vba.MaximumSwathWidthInDETBuffer,
    mode_lib->vba.MaximumSwathWidthInLineBuffer);
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(
    mode_lib->vba.MaxDispclk[i],
    mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
   mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(
    mode_lib->vba.MaxDppclk[i],
    mode_lib->vba.DISPCLKDPPCLKVCOSpeed);
   locals->RequiredDISPCLK[i][j] = 0.0;
   locals->DISPCLK_DPPCLK_Support[i][j] = true;
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine =
      mode_lib->vba.PixelClock[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)
        * (1.0 + mode_lib->vba.DISPCLKRampingMargin / 100.0);
    if (mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine >= mode_lib->vba.MaxDispclk[i]
      && i == mode_lib->vba.soc.num_states)
     mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine = mode_lib->vba.PixelClock[k]
       * (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);

    mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine = mode_lib->vba.PixelClock[k] / 2
     * (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * (1 + mode_lib->vba.DISPCLKRampingMargin / 100.0);
    if (mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine >= mode_lib->vba.MaxDispclk[i]
      && i == mode_lib->vba.soc.num_states)
     mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine = mode_lib->vba.PixelClock[k] / 2
       * (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);

    locals->ODMCombineEnablePerState[i][k] = false;
    mode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine;
    if (mode_lib->vba.ODMCapability) {
     if (locals->PlaneRequiredDISPCLKWithoutODMCombine > mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity) {
      locals->ODMCombineEnablePerState[i][k] = true;
      mode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine;
     } else if (locals->HActive[k] > 4096 && locals->OutputFormat[k] == dm_420) {
      locals->ODMCombineEnablePerState[i][k] = true;
      mode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine;
     }
    }

    if (locals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) <= mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity
      && locals->SwathWidthYSingleDPP[k] <= locals->MaximumSwathWidth[k]
      && locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {
     locals->NoOfDPP[i][j][k] = 1;
     locals->RequiredDPPCLK[i][j][k] =
      locals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);
    } else {
     locals->NoOfDPP[i][j][k] = 2;
     locals->RequiredDPPCLK[i][j][k] =
      locals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;
    }
    locals->RequiredDISPCLK[i][j] = dml_max(
      locals->RequiredDISPCLK[i][j],
      mode_lib->vba.PlaneRequiredDISPCLK);
    if ((locals->MinDPPCLKUsingSingleDPP[k] / locals->NoOfDPP[i][j][k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)
      > mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity)
      || (mode_lib->vba.PlaneRequiredDISPCLK > mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity)) {
     locals->DISPCLK_DPPCLK_Support[i][j] = false;
    }
   }
   locals->TotalNumberOfActiveDPP[i][j] = 0.0;
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++)
    locals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + locals->NoOfDPP[i][j][k];
   if (j == 1) {
    while (locals->TotalNumberOfActiveDPP[i][j] < mode_lib->vba.MaxNumDPP
      && locals->TotalNumberOfActiveDPP[i][j] < 2 * mode_lib->vba.NumberOfActivePlanes) {
     double BWOfNonSplitPlaneOfMaximumBandwidth;
     unsigned int NumberOfNonSplitPlaneOfMaximumBandwidth;

     BWOfNonSplitPlaneOfMaximumBandwidth = 0;
     NumberOfNonSplitPlaneOfMaximumBandwidth = 0;
     for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {
      if (locals->ReadBandwidth[k] > BWOfNonSplitPlaneOfMaximumBandwidth && locals->NoOfDPP[i][j][k] == 1) {
       BWOfNonSplitPlaneOfMaximumBandwidth = locals->ReadBandwidth[k];
       NumberOfNonSplitPlaneOfMaximumBandwidth = k;
      }
     }
     locals->NoOfDPP[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = 2;
     locals->RequiredDPPCLK[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] =
      locals->MinDPPCLKUsingSingleDPP[NumberOfNonSplitPlaneOfMaximumBandwidth]
       * (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100) / 2;
     locals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + 1;
    }
   }
   if (locals->TotalNumberOfActiveDPP[i][j] > mode_lib->vba.MaxNumDPP) {
    locals->RequiredDISPCLK[i][j] = 0.0;
    locals->DISPCLK_DPPCLK_Support[i][j] = true;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     locals->ODMCombineEnablePerState[i][k] = false;
     if (locals->SwathWidthYSingleDPP[k] <= locals->MaximumSwathWidth[k]) {
      locals->NoOfDPP[i][j][k] = 1;
      locals->RequiredDPPCLK[i][j][k] = locals->MinDPPCLKUsingSingleDPP[k]
       * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);
     } else {
      locals->NoOfDPP[i][j][k] = 2;
      locals->RequiredDPPCLK[i][j][k] = locals->MinDPPCLKUsingSingleDPP[k]
          * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;
     }
     if (i != mode_lib->vba.soc.num_states) {
      mode_lib->vba.PlaneRequiredDISPCLK =
        mode_lib->vba.PixelClock[k]
          * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)
          * (1.0 + mode_lib->vba.DISPCLKRampingMargin / 100.0);
     } else {
      mode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PixelClock[k]
       * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);
     }
     locals->RequiredDISPCLK[i][j] = dml_max(
       locals->RequiredDISPCLK[i][j],
       mode_lib->vba.PlaneRequiredDISPCLK);
     if (locals->MinDPPCLKUsingSingleDPP[k] / locals->NoOfDPP[i][j][k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)
       > mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity
       || mode_lib->vba.PlaneRequiredDISPCLK > mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity)
      locals->DISPCLK_DPPCLK_Support[i][j] = false;
    }
    locals->TotalNumberOfActiveDPP[i][j] = 0.0;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++)
     locals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + locals->NoOfDPP[i][j][k];
   }
   locals->RequiredDISPCLK[i][j] = dml_max(
     locals->RequiredDISPCLK[i][j],
     mode_lib->vba.WritebackRequiredDISPCLK);
   if (mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity
     < mode_lib->vba.WritebackRequiredDISPCLK) {
    locals->DISPCLK_DPPCLK_Support[i][j] = false;
   }
  }
 }


 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  locals->ViewportSizeSupport[i][0] = true;
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   if (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {
    if (dml_min(locals->SwathWidthYSingleDPP[k], dml_round(mode_lib->vba.HActive[k] / 2.0 * mode_lib->vba.HRatio[k]))
      > locals->MaximumSwathWidth[k]) {
     locals->ViewportSizeSupport[i][0] = false;
    }
   } else {
    if (locals->SwathWidthYSingleDPP[k] / 2.0 > locals->MaximumSwathWidth[k]) {
     locals->ViewportSizeSupport[i][0] = false;
    }
   }
  }
 }


 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   if (locals->TotalNumberOfActiveDPP[i][j] <= mode_lib->vba.MaxNumDPP)
    locals->TotalAvailablePipesSupport[i][j] = true;
   else
    locals->TotalAvailablePipesSupport[i][j] = false;
  }
 }


 mode_lib->vba.TotalNumberOfActiveOTG = 0.0;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.BlendingAndTiming[k] == k) {
   mode_lib->vba.TotalNumberOfActiveOTG = mode_lib->vba.TotalNumberOfActiveOTG
     + 1.0;
  }
 }
 if (mode_lib->vba.TotalNumberOfActiveOTG <= mode_lib->vba.MaxNumOTG) {
  mode_lib->vba.NumberOfOTGSupport = true;
 } else {
  mode_lib->vba.NumberOfOTGSupport = false;
 }


 mode_lib->vba.NonsupportedDSCInputBPC = false;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (!(mode_lib->vba.DSCInputBitPerComponent[k] == 12.0
    || mode_lib->vba.DSCInputBitPerComponent[k] == 10.0
    || mode_lib->vba.DSCInputBitPerComponent[k] == 8.0)) {
   mode_lib->vba.NonsupportedDSCInputBPC = true;
  }
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   locals->RequiresDSC[i][k] = 0;
   locals->RequiresFEC[i][k] = 0;
   if (mode_lib->vba.BlendingAndTiming[k] == k) {
    if (mode_lib->vba.Output[k] == dm_hdmi) {
     locals->RequiresDSC[i][k] = 0;
     locals->RequiresFEC[i][k] = 0;
     locals->OutputBppPerState[i][k] = TruncToValidBPP(
       dml_min(600.0, mode_lib->vba.PHYCLKPerState[i]) / mode_lib->vba.PixelClockBackEnd[k] * 24,
       false,
       mode_lib->vba.Output[k],
       mode_lib->vba.OutputFormat[k],
       mode_lib->vba.DSCInputBitPerComponent[k]);
    } else if (mode_lib->vba.Output[k] == dm_dp
      || mode_lib->vba.Output[k] == dm_edp) {
     if (mode_lib->vba.Output[k] == dm_edp) {
      mode_lib->vba.EffectiveFECOverhead = 0.0;
     } else {
      mode_lib->vba.EffectiveFECOverhead =
        mode_lib->vba.FECOverhead;
     }
     if (mode_lib->vba.PHYCLKPerState[i] >= 270.0) {
      mode_lib->vba.Outbpp = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * 270.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
        false,
        mode_lib->vba.Output[k],
        mode_lib->vba.OutputFormat[k],
        mode_lib->vba.DSCInputBitPerComponent[k]);
      mode_lib->vba.OutbppDSC = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 270.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
        true,
        mode_lib->vba.Output[k],
        mode_lib->vba.OutputFormat[k],
        mode_lib->vba.DSCInputBitPerComponent[k]);
      if (mode_lib->vba.DSCEnabled[k] == true) {
       locals->RequiresDSC[i][k] = true;
       if (mode_lib->vba.Output[k] == dm_dp) {
        locals->RequiresFEC[i][k] = true;
       } else {
        locals->RequiresFEC[i][k] = false;
       }
       mode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;
      } else {
       locals->RequiresDSC[i][k] = false;
       locals->RequiresFEC[i][k] = false;
      }
      locals->OutputBppPerState[i][k] = mode_lib->vba.Outbpp;
     }
     if (mode_lib->vba.Outbpp == 0 && mode_lib->vba.PHYCLKPerState[i] >= 540.0) {
      mode_lib->vba.Outbpp = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * 540.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
         false,
         mode_lib->vba.Output[k],
         mode_lib->vba.OutputFormat[k],
         mode_lib->vba.DSCInputBitPerComponent[k]);
      mode_lib->vba.OutbppDSC = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 540.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
        true,
        mode_lib->vba.Output[k],
        mode_lib->vba.OutputFormat[k],
        mode_lib->vba.DSCInputBitPerComponent[k]);
      if (mode_lib->vba.DSCEnabled[k] == true) {
       locals->RequiresDSC[i][k] = true;
       if (mode_lib->vba.Output[k] == dm_dp) {
        locals->RequiresFEC[i][k] = true;
       } else {
        locals->RequiresFEC[i][k] = false;
       }
       mode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;
      } else {
       locals->RequiresDSC[i][k] = false;
       locals->RequiresFEC[i][k] = false;
      }
      locals->OutputBppPerState[i][k] = mode_lib->vba.Outbpp;
     }
     if (mode_lib->vba.Outbpp == 0
       && mode_lib->vba.PHYCLKPerState[i]
         >= 810.0) {
      mode_lib->vba.Outbpp = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * 810.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
        false,
        mode_lib->vba.Output[k],
        mode_lib->vba.OutputFormat[k],
        mode_lib->vba.DSCInputBitPerComponent[k]);
      mode_lib->vba.OutbppDSC = TruncToValidBPP(
        (1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 810.0
        * mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,
        true,
        mode_lib->vba.Output[k],
        mode_lib->vba.OutputFormat[k],
        mode_lib->vba.DSCInputBitPerComponent[k]);
      if (mode_lib->vba.DSCEnabled[k] == true || mode_lib->vba.Outbpp == 0) {
       locals->RequiresDSC[i][k] = true;
       if (mode_lib->vba.Output[k] == dm_dp) {
        locals->RequiresFEC[i][k] = true;
       } else {
        locals->RequiresFEC[i][k] = false;
       }
       mode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;
      } else {
       locals->RequiresDSC[i][k] = false;
       locals->RequiresFEC[i][k] = false;
      }
      locals->OutputBppPerState[i][k] =
        mode_lib->vba.Outbpp;
     }
    }
   } else {
    locals->OutputBppPerState[i][k] = 0xffffffff;
   }
  }
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  locals->DIOSupport[i] = true;
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   if (locals->OutputBppPerState[i][k] == 0
     || (mode_lib->vba.OutputFormat[k] == dm_420
       && mode_lib->vba.Interlace[k] == true
       && mode_lib->vba.ProgressiveToInterlaceUnitInOPP == true)) {
    locals->DIOSupport[i] = false;
   }
  }
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   locals->DSCCLKRequiredMoreThanSupported[i] = false;
   if (mode_lib->vba.BlendingAndTiming[k] == k) {
    if ((mode_lib->vba.Output[k] == dm_dp
      || mode_lib->vba.Output[k] == dm_edp)) {
     if (mode_lib->vba.OutputFormat[k] == dm_420
       || mode_lib->vba.OutputFormat[k]
         == dm_n422) {
      mode_lib->vba.DSCFormatFactor = 2;
     } else {
      mode_lib->vba.DSCFormatFactor = 1;
     }
     if (locals->RequiresDSC[i][k] == true) {
      if (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {
       if (mode_lib->vba.PixelClockBackEnd[k] / 6.0 / mode_lib->vba.DSCFormatFactor
         > (1.0 - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * mode_lib->vba.MaxDSCCLK[i]) {
        locals->DSCCLKRequiredMoreThanSupported[i] =
          true;
       }
      } else {
       if (mode_lib->vba.PixelClockBackEnd[k] / 3.0 / mode_lib->vba.DSCFormatFactor
         > (1.0 - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * mode_lib->vba.MaxDSCCLK[i]) {
        locals->DSCCLKRequiredMoreThanSupported[i] =
          true;
       }
      }
     }
    }
   }
  }
 }
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  locals->NotEnoughDSCUnits[i] = false;
  mode_lib->vba.TotalDSCUnitsRequired = 0.0;
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   if (locals->RequiresDSC[i][k] == true) {
    if (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {
     mode_lib->vba.TotalDSCUnitsRequired =
       mode_lib->vba.TotalDSCUnitsRequired + 2.0;
    } else {
     mode_lib->vba.TotalDSCUnitsRequired =
       mode_lib->vba.TotalDSCUnitsRequired + 1.0;
    }
   }
  }
  if (mode_lib->vba.TotalDSCUnitsRequired > mode_lib->vba.NumberOfDSC) {
   locals->NotEnoughDSCUnits[i] = true;
  }
 }


 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   if (mode_lib->vba.BlendingAndTiming[k] != k) {
    mode_lib->vba.slices = 0;
   } else if (locals->RequiresDSC[i][k] == 0
     || locals->RequiresDSC[i][k] == false) {
    mode_lib->vba.slices = 0;
   } else if (mode_lib->vba.PixelClockBackEnd[k] > 3200.0) {
    mode_lib->vba.slices = dml_ceil(
      mode_lib->vba.PixelClockBackEnd[k] / 400.0,
      4.0);
   } else if (mode_lib->vba.PixelClockBackEnd[k] > 1360.0) {
    mode_lib->vba.slices = 8.0;
   } else if (mode_lib->vba.PixelClockBackEnd[k] > 680.0) {
    mode_lib->vba.slices = 4.0;
   } else if (mode_lib->vba.PixelClockBackEnd[k] > 340.0) {
    mode_lib->vba.slices = 2.0;
   } else {
    mode_lib->vba.slices = 1.0;
   }
   if (locals->OutputBppPerState[i][k] == 0xffffffff
     || locals->OutputBppPerState[i][k] == 0) {
    mode_lib->vba.bpp = 0.0;
   } else {
    mode_lib->vba.bpp = locals->OutputBppPerState[i][k];
   }
   if (locals->RequiresDSC[i][k] == true && mode_lib->vba.bpp != 0.0) {
    if (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {
     locals->DSCDelayPerState[i][k] =
       dscceComputeDelay(
         mode_lib->vba.DSCInputBitPerComponent[k],
         mode_lib->vba.bpp,
         dml_ceil(
           mode_lib->vba.HActive[k]
             / mode_lib->vba.slices,
           1.0),
         mode_lib->vba.slices,
         mode_lib->vba.OutputFormat[k])
         + dscComputeDelay(
           mode_lib->vba.OutputFormat[k]);
    } else {
     locals->DSCDelayPerState[i][k] =
       2.0 * (dscceComputeDelay(
           mode_lib->vba.DSCInputBitPerComponent[k],
           mode_lib->vba.bpp,
           dml_ceil(mode_lib->vba.HActive[k] / mode_lib->vba.slices, 1.0),
           mode_lib->vba.slices / 2,
           mode_lib->vba.OutputFormat[k])
         + dscComputeDelay(mode_lib->vba.OutputFormat[k]));
    }
    locals->DSCDelayPerState[i][k] =
      locals->DSCDelayPerState[i][k] * mode_lib->vba.PixelClock[k] / mode_lib->vba.PixelClockBackEnd[k];
   } else {
    locals->DSCDelayPerState[i][k] = 0.0;
   }
  }
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   for (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {
    for (j = 0; j <= mode_lib->vba.NumberOfActivePlanes - 1; j++) {
     if (mode_lib->vba.BlendingAndTiming[k] == m && locals->RequiresDSC[i][m] == true)
      locals->DSCDelayPerState[i][k] = locals->DSCDelayPerState[i][m];
    }
   }
  }
 }


 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    if (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1)
     locals->SwathWidthYPerState[i][j][k] = dml_min(locals->SwathWidthYSingleDPP[k], dml_round(locals->HActive[k] / 2 * locals->HRatio[k]));
    else
     locals->SwathWidthYPerState[i][j][k] = locals->SwathWidthYSingleDPP[k] / locals->NoOfDPP[i][j][k];
    locals->SwathWidthGranularityY = 256 / dml_ceil(locals->BytePerPixelInDETY[k], 1) / locals->MaxSwathHeightY[k];
    locals->RoundedUpMaxSwathSizeBytesY = (dml_ceil(locals->SwathWidthYPerState[i][j][k] - 1, locals->SwathWidthGranularityY)
      + locals->SwathWidthGranularityY) * locals->BytePerPixelInDETY[k] * locals->MaxSwathHeightY[k];
    if (locals->SourcePixelFormat[k] == dm_420_10) {
     locals->RoundedUpMaxSwathSizeBytesY = dml_ceil(locals->RoundedUpMaxSwathSizeBytesY, 256) + 256;
    }
    if (locals->MaxSwathHeightC[k] > 0) {
     locals->SwathWidthGranularityC = 256 / dml_ceil(locals->BytePerPixelInDETC[k], 2) / locals->MaxSwathHeightC[k];

     locals->RoundedUpMaxSwathSizeBytesC = (dml_ceil(locals->SwathWidthYPerState[i][j][k] / 2 - 1, locals->SwathWidthGranularityC)
     + locals->SwathWidthGranularityC) * locals->BytePerPixelInDETC[k] * locals->MaxSwathHeightC[k];
    }
    if (locals->SourcePixelFormat[k] == dm_420_10) {
     locals->RoundedUpMaxSwathSizeBytesC = dml_ceil(locals->RoundedUpMaxSwathSizeBytesC, 256) + 256;
    } else {
     locals->RoundedUpMaxSwathSizeBytesC = 0;
    }

    if (locals->RoundedUpMaxSwathSizeBytesY + locals->RoundedUpMaxSwathSizeBytesC <= locals->DETBufferSizeInKByte * 1024 / 2) {
     locals->SwathHeightYPerState[i][j][k] = locals->MaxSwathHeightY[k];
     locals->SwathHeightCPerState[i][j][k] = locals->MaxSwathHeightC[k];
    } else {
     locals->SwathHeightYPerState[i][j][k] = locals->MinSwathHeightY[k];
     locals->SwathHeightCPerState[i][j][k] = locals->MinSwathHeightC[k];
    }

    if (locals->BytePerPixelInDETC[k] == 0) {
     locals->LinesInDETLuma = locals->DETBufferSizeInKByte * 1024 / locals->BytePerPixelInDETY[k] / locals->SwathWidthYPerState[i][j][k];
     locals->LinesInDETChroma = 0;
    } else if (locals->SwathHeightYPerState[i][j][k] <= locals->SwathHeightCPerState[i][j][k]) {
     locals->LinesInDETLuma = locals->DETBufferSizeInKByte * 1024 / 2 / locals->BytePerPixelInDETY[k] /
       locals->SwathWidthYPerState[i][j][k];
     locals->LinesInDETChroma = locals->DETBufferSizeInKByte * 1024 / 2 / locals->BytePerPixelInDETC[k] / (locals->SwathWidthYPerState[i][j][k] / 2);
    } else {
     locals->LinesInDETLuma = locals->DETBufferSizeInKByte * 1024 * 2 / 3 / locals->BytePerPixelInDETY[k] / locals->SwathWidthYPerState[i][j][k];
     locals->LinesInDETChroma = locals->DETBufferSizeInKByte * 1024 / 3 / locals->BytePerPixelInDETY[k] / (locals->SwathWidthYPerState[i][j][k] / 2);
    }

    locals->EffectiveLBLatencyHidingSourceLinesLuma = dml_min(locals->MaxLineBufferLines,
     dml_floor(locals->LineBufferSize / locals->LBBitPerPixel[k] / (locals->SwathWidthYPerState[i][j][k]
     / dml_max(locals->HRatio[k], 1)), 1)) - (locals->vtaps[k] - 1);

    locals->EffectiveLBLatencyHidingSourceLinesChroma = dml_min(locals->MaxLineBufferLines,
      dml_floor(locals->LineBufferSize / locals->LBBitPerPixel[k]
      / (locals->SwathWidthYPerState[i][j][k] / 2
      / dml_max(locals->HRatio[k] / 2, 1)), 1)) - (locals->VTAPsChroma[k] - 1);

    locals->EffectiveDETLBLinesLuma = dml_floor(locals->LinesInDETLuma + dml_min(
      locals->LinesInDETLuma * locals->RequiredDISPCLK[i][j] * locals->BytePerPixelInDETY[k] *
      locals->PSCL_FACTOR[k] / locals->ReturnBWPerState[i][0],
      locals->EffectiveLBLatencyHidingSourceLinesLuma),
      locals->SwathHeightYPerState[i][j][k]);

    locals->EffectiveDETLBLinesChroma = dml_floor(locals->LinesInDETChroma + dml_min(
      locals->LinesInDETChroma * locals->RequiredDISPCLK[i][j] * locals->BytePerPixelInDETC[k] *
      locals->PSCL_FACTOR_CHROMA[k] / locals->ReturnBWPerState[i][0],
      locals->EffectiveLBLatencyHidingSourceLinesChroma),
      locals->SwathHeightCPerState[i][j][k]);

    if (locals->BytePerPixelInDETC[k] == 0) {
     locals->UrgentLatencySupportUsPerState[i][j][k] = locals->EffectiveDETLBLinesLuma * (locals->HTotal[k] / locals->PixelClock[k])
       / locals->VRatio[k] - locals->EffectiveDETLBLinesLuma * locals->SwathWidthYPerState[i][j][k] *
        dml_ceil(locals->BytePerPixelInDETY[k], 1) / (locals->ReturnBWPerState[i][0] / locals->NoOfDPP[i][j][k]);
    } else {
     locals->UrgentLatencySupportUsPerState[i][j][k] = dml_min(
      locals->EffectiveDETLBLinesLuma * (locals->HTotal[k] / locals->PixelClock[k])
      / locals->VRatio[k] - locals->EffectiveDETLBLinesLuma * locals->SwathWidthYPerState[i][j][k] *
      dml_ceil(locals->BytePerPixelInDETY[k], 1) / (locals->ReturnBWPerState[i][0] / locals->NoOfDPP[i][j][k]),
       locals->EffectiveDETLBLinesChroma * (locals->HTotal[k] / locals->PixelClock[k]) / (locals->VRatio[k] / 2) -
       locals->EffectiveDETLBLinesChroma * locals->SwathWidthYPerState[i][j][k] / 2 *
       dml_ceil(locals->BytePerPixelInDETC[k], 2) / (locals->ReturnBWPerState[i][0] / locals->NoOfDPP[i][j][k]));
    }
   }
  }
 }

 for (i = 0; i <= locals->soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   locals->UrgentLatencySupport[i][j] = true;
   for (k = 0; k < locals->NumberOfActivePlanes; k++) {
    if (locals->UrgentLatencySupportUsPerState[i][j][k] < locals->UrgentLatency)
     locals->UrgentLatencySupport[i][j] = false;
   }
  }
 }



 for (i = 0; i <= locals->soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   locals->TotalNumberOfDCCActiveDPP[i][j] = 0;
   for (k = 0; k < locals->NumberOfActivePlanes; k++) {
    if (locals->DCCEnable[k] == true) {
     locals->TotalNumberOfDCCActiveDPP[i][j] =
      locals->TotalNumberOfDCCActiveDPP[i][j] + locals->NoOfDPP[i][j][k];
    }
   }
  }
 }

 CalculateMinAndMaxPrefetchMode(locals->AllowDRAMSelfRefreshOrDRAMClockChangeInVblank, &locals->MinPrefetchMode, &locals->MaxPrefetchMode);

 for (i = 0; i <= locals->soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   for (k = 0; k < locals->NumberOfActivePlanes; k++) {
    locals->NoOfDPPThisState[k] = locals->NoOfDPP[i][j][k];
    locals->RequiredDPPCLKThisState[k] = locals->RequiredDPPCLK[i][j][k];
    locals->SwathHeightYThisState[k] = locals->SwathHeightYPerState[i][j][k];
    locals->SwathHeightCThisState[k] = locals->SwathHeightCPerState[i][j][k];
    locals->SwathWidthYThisState[k] = locals->SwathWidthYPerState[i][j][k];
    mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] = dml_max(
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
      mode_lib->vba.PixelClock[k] / 16.0);
    if (mode_lib->vba.BytePerPixelInDETC[k] == 0.0) {
     if (mode_lib->vba.VRatio[k] <= 1.0) {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETY[k],
              1.0)
            / 64.0
            * mode_lib->vba.HRatio[k]
            * mode_lib->vba.PixelClock[k]
            / mode_lib->vba.NoOfDPP[i][j][k]);
     } else {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETY[k],
              1.0)
            / 64.0
            * mode_lib->vba.PSCL_FACTOR[k]
            * mode_lib->vba.RequiredDPPCLK[i][j][k]);
     }
    } else {
     if (mode_lib->vba.VRatio[k] <= 1.0) {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETY[k],
              1.0)
            / 32.0
            * mode_lib->vba.HRatio[k]
            * mode_lib->vba.PixelClock[k]
            / mode_lib->vba.NoOfDPP[i][j][k]);
     } else {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETY[k],
              1.0)
            / 32.0
            * mode_lib->vba.PSCL_FACTOR[k]
            * mode_lib->vba.RequiredDPPCLK[i][j][k]);
     }
     if (mode_lib->vba.VRatio[k] / 2.0 <= 1.0) {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETC[k],
              2.0)
            / 32.0
            * mode_lib->vba.HRatio[k]
            / 2.0
            * mode_lib->vba.PixelClock[k]
            / mode_lib->vba.NoOfDPP[i][j][k]);
     } else {
      mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0] =
        dml_max(
          mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
          1.1
            * dml_ceil(
              mode_lib->vba.BytePerPixelInDETC[k],
              2.0)
            / 32.0
            * mode_lib->vba.PSCL_FACTOR_CHROMA[k]
            * mode_lib->vba.RequiredDPPCLK[i][j][k]);
     }
    }
   }
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    mode_lib->vba.PDEAndMetaPTEBytesPerFrameY = CalculateVMAndRowBytes(
      mode_lib,
      mode_lib->vba.DCCEnable[k],
      mode_lib->vba.Read256BlockHeightY[k],
      mode_lib->vba.Read256BlockWidthY[k],
      mode_lib->vba.SourcePixelFormat[k],
      mode_lib->vba.SurfaceTiling[k],
      dml_ceil(mode_lib->vba.BytePerPixelInDETY[k], 1.0),
      mode_lib->vba.SourceScan[k],
      mode_lib->vba.ViewportWidth[k],
      mode_lib->vba.ViewportHeight[k],
      mode_lib->vba.SwathWidthYPerState[i][j][k],
      mode_lib->vba.GPUVMEnable,
      mode_lib->vba.VMMPageSize,
      mode_lib->vba.PTEBufferSizeInRequestsLuma,
      mode_lib->vba.PDEProcessingBufIn64KBReqs,
      mode_lib->vba.PitchY[k],
      mode_lib->vba.DCCMetaPitchY[k],
      &mode_lib->vba.MacroTileWidthY[k],
      &mode_lib->vba.MetaRowBytesY,
      &mode_lib->vba.DPTEBytesPerRowY,
      &mode_lib->vba.PTEBufferSizeNotExceededY[i][j][k],
      &mode_lib->vba.dpte_row_height[k],
      &mode_lib->vba.meta_row_height[k]);
    mode_lib->vba.PrefetchLinesY[0][0][k] = CalculatePrefetchSourceLines(
      mode_lib,
      mode_lib->vba.VRatio[k],
      mode_lib->vba.vtaps[k],
      mode_lib->vba.Interlace[k],
      mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
      mode_lib->vba.SwathHeightYPerState[i][j][k],
      mode_lib->vba.ViewportYStartY[k],
      &mode_lib->vba.PrefillY[k],
      &mode_lib->vba.MaxNumSwY[k]);
    if ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_32
      && mode_lib->vba.SourcePixelFormat[k] != dm_444_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_16
      && mode_lib->vba.SourcePixelFormat[k] != dm_mono_8)) {
     mode_lib->vba.PDEAndMetaPTEBytesPerFrameC = CalculateVMAndRowBytes(
       mode_lib,
       mode_lib->vba.DCCEnable[k],
       mode_lib->vba.Read256BlockHeightY[k],
       mode_lib->vba.Read256BlockWidthY[k],
       mode_lib->vba.SourcePixelFormat[k],
       mode_lib->vba.SurfaceTiling[k],
       dml_ceil(mode_lib->vba.BytePerPixelInDETC[k], 2.0),
       mode_lib->vba.SourceScan[k],
       mode_lib->vba.ViewportWidth[k] / 2.0,
       mode_lib->vba.ViewportHeight[k] / 2.0,
       mode_lib->vba.SwathWidthYPerState[i][j][k] / 2.0,
       mode_lib->vba.GPUVMEnable,
       mode_lib->vba.VMMPageSize,
       mode_lib->vba.PTEBufferSizeInRequestsLuma,
       mode_lib->vba.PDEProcessingBufIn64KBReqs,
       mode_lib->vba.PitchC[k],
       0.0,
       &mode_lib->vba.MacroTileWidthC[k],
       &mode_lib->vba.MetaRowBytesC,
       &mode_lib->vba.DPTEBytesPerRowC,
       &mode_lib->vba.PTEBufferSizeNotExceededC[i][j][k],
       &mode_lib->vba.dpte_row_height_chroma[k],
       &mode_lib->vba.meta_row_height_chroma[k]);
     mode_lib->vba.PrefetchLinesC[0][0][k] = CalculatePrefetchSourceLines(
       mode_lib,
       mode_lib->vba.VRatio[k] / 2.0,
       mode_lib->vba.VTAPsChroma[k],
       mode_lib->vba.Interlace[k],
       mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
       mode_lib->vba.SwathHeightCPerState[i][j][k],
       mode_lib->vba.ViewportYStartC[k],
       &mode_lib->vba.PrefillC[k],
       &mode_lib->vba.MaxNumSwC[k]);
    } else {
     mode_lib->vba.PDEAndMetaPTEBytesPerFrameC = 0.0;
     mode_lib->vba.MetaRowBytesC = 0.0;
     mode_lib->vba.DPTEBytesPerRowC = 0.0;
     locals->PrefetchLinesC[0][0][k] = 0.0;
     locals->PTEBufferSizeNotExceededC[i][j][k] = true;
     locals->PTEBufferSizeInRequestsForLuma = mode_lib->vba.PTEBufferSizeInRequestsLuma + mode_lib->vba.PTEBufferSizeInRequestsChroma;
    }
    locals->PDEAndMetaPTEBytesPerFrame[0][0][k] =
      mode_lib->vba.PDEAndMetaPTEBytesPerFrameY + mode_lib->vba.PDEAndMetaPTEBytesPerFrameC;
    locals->MetaRowBytes[0][0][k] = mode_lib->vba.MetaRowBytesY + mode_lib->vba.MetaRowBytesC;
    locals->DPTEBytesPerRow[0][0][k] = mode_lib->vba.DPTEBytesPerRowY + mode_lib->vba.DPTEBytesPerRowC;

    CalculateActiveRowBandwidth(
      mode_lib->vba.GPUVMEnable,
      mode_lib->vba.SourcePixelFormat[k],
      mode_lib->vba.VRatio[k],
      mode_lib->vba.DCCEnable[k],
      mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],
      mode_lib->vba.MetaRowBytesY,
      mode_lib->vba.MetaRowBytesC,
      mode_lib->vba.meta_row_height[k],
      mode_lib->vba.meta_row_height_chroma[k],
      mode_lib->vba.DPTEBytesPerRowY,
      mode_lib->vba.DPTEBytesPerRowC,
      mode_lib->vba.dpte_row_height[k],
      mode_lib->vba.dpte_row_height_chroma[k],
      &mode_lib->vba.meta_row_bw[k],
      &mode_lib->vba.dpte_row_bw[k],
      &mode_lib->vba.qual_row_bw[k]);
   }
   mode_lib->vba.ExtraLatency =
     mode_lib->vba.UrgentRoundTripAndOutOfOrderLatencyPerState[i]
       + (mode_lib->vba.TotalNumberOfActiveDPP[i][j]
         * mode_lib->vba.PixelChunkSizeInKByte
         + mode_lib->vba.TotalNumberOfDCCActiveDPP[i][j]
           * mode_lib->vba.MetaChunkSize)
         * 1024.0
         / mode_lib->vba.ReturnBWPerState[i][0];
   if (mode_lib->vba.GPUVMEnable == true) {
    mode_lib->vba.ExtraLatency = mode_lib->vba.ExtraLatency
      + mode_lib->vba.TotalNumberOfActiveDPP[i][j]
        * mode_lib->vba.PTEGroupSize
        / mode_lib->vba.ReturnBWPerState[i][0];
   }
   mode_lib->vba.TimeCalc = 24.0 / mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0];

   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    if (mode_lib->vba.BlendingAndTiming[k] == k) {
     if (mode_lib->vba.WritebackEnable[k] == true) {
      locals->WritebackDelay[i][k] = mode_lib->vba.WritebackLatency
        + CalculateWriteBackDelay(
          mode_lib->vba.WritebackPixelFormat[k],
          mode_lib->vba.WritebackHRatio[k],
          mode_lib->vba.WritebackVRatio[k],
          mode_lib->vba.WritebackLumaHTaps[k],
          mode_lib->vba.WritebackLumaVTaps[k],
          mode_lib->vba.WritebackChromaHTaps[k],
          mode_lib->vba.WritebackChromaVTaps[k],
          mode_lib->vba.WritebackDestinationWidth[k]) / locals->RequiredDISPCLK[i][j];
     } else {
      locals->WritebackDelay[i][k] = 0.0;
     }
     for (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {
      if (mode_lib->vba.BlendingAndTiming[m] == k
        && mode_lib->vba.WritebackEnable[m]
          == true) {
       locals->WritebackDelay[i][k] = dml_max(locals->WritebackDelay[i][k],
           mode_lib->vba.WritebackLatency + CalculateWriteBackDelay(
             mode_lib->vba.WritebackPixelFormat[m],
             mode_lib->vba.WritebackHRatio[m],
             mode_lib->vba.WritebackVRatio[m],
             mode_lib->vba.WritebackLumaHTaps[m],
             mode_lib->vba.WritebackLumaVTaps[m],
             mode_lib->vba.WritebackChromaHTaps[m],
             mode_lib->vba.WritebackChromaVTaps[m],
             mode_lib->vba.WritebackDestinationWidth[m]) / locals->RequiredDISPCLK[i][j]);
      }
     }
    }
   }
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    for (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {
     if (mode_lib->vba.BlendingAndTiming[k] == m) {
      locals->WritebackDelay[i][k] = locals->WritebackDelay[i][m];
     }
    }
   }
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    for (m = 0; m < locals->NumberOfCursors[k]; m++)
     locals->cursor_bw[k] = locals->NumberOfCursors[k] * locals->CursorWidth[k][m] * locals->CursorBPP[k][m]
      / 8 / (locals->HTotal[k] / locals->PixelClock[k]) * locals->VRatio[k];
   }

   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    locals->MaximumVStartup[0][0][k] = mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k]
     - dml_max(1.0, dml_ceil(locals->WritebackDelay[i][k] / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]), 1.0));
   }

   mode_lib->vba.NextPrefetchMode = mode_lib->vba.MinPrefetchMode;
   do {
    mode_lib->vba.PrefetchMode[i][j] = mode_lib->vba.NextPrefetchMode;
    mode_lib->vba.NextPrefetchMode = mode_lib->vba.NextPrefetchMode + 1;

    mode_lib->vba.TWait = CalculateTWait(
      mode_lib->vba.PrefetchMode[i][j],
      mode_lib->vba.DRAMClockChangeLatency,
      mode_lib->vba.UrgentLatency,
      mode_lib->vba.SREnterPlusExitTime);
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {

     if (mode_lib->vba.XFCEnabled[k] == true) {
      mode_lib->vba.XFCRemoteSurfaceFlipDelay =
        CalculateRemoteSurfaceFlipDelay(
          mode_lib,
          mode_lib->vba.VRatio[k],
          locals->SwathWidthYPerState[i][j][k],
          dml_ceil(locals->BytePerPixelInDETY[k], 1.0),
          mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],
          mode_lib->vba.XFCTSlvVupdateOffset,
          mode_lib->vba.XFCTSlvVupdateWidth,
          mode_lib->vba.XFCTSlvVreadyOffset,
          mode_lib->vba.XFCXBUFLatencyTolerance,
          mode_lib->vba.XFCFillBWOverhead,
          mode_lib->vba.XFCSlvChunkSize,
          mode_lib->vba.XFCBusTransportTime,
          mode_lib->vba.TimeCalc,
          mode_lib->vba.TWait,
          &mode_lib->vba.SrcActiveDrainRate,
          &mode_lib->vba.TInitXFill,
          &mode_lib->vba.TslvChk);
     } else {
      mode_lib->vba.XFCRemoteSurfaceFlipDelay = 0.0;
     }
     mode_lib->vba.IsErrorResult[i][j][k] =
       CalculatePrefetchSchedule(
         mode_lib,
         mode_lib->vba.RequiredDPPCLK[i][j][k],
         mode_lib->vba.RequiredDISPCLK[i][j],
         mode_lib->vba.PixelClock[k],
         mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],
         mode_lib->vba.DSCDelayPerState[i][k],
         mode_lib->vba.NoOfDPP[i][j][k],
         mode_lib->vba.ScalerEnabled[k],
         mode_lib->vba.NumberOfCursors[k],
         mode_lib->vba.DPPCLKDelaySubtotal,
         mode_lib->vba.DPPCLKDelaySCL,
         mode_lib->vba.DPPCLKDelaySCLLBOnly,
         mode_lib->vba.DPPCLKDelayCNVCFormater,
         mode_lib->vba.DPPCLKDelayCNVCCursor,
         mode_lib->vba.DISPCLKDelaySubtotal,
         mode_lib->vba.SwathWidthYPerState[i][j][k]
           / mode_lib->vba.HRatio[k],
         mode_lib->vba.OutputFormat[k],
         mode_lib->vba.VTotal[k]
           - mode_lib->vba.VActive[k],
         mode_lib->vba.HTotal[k],
         mode_lib->vba.MaxInterDCNTileRepeaters,
         mode_lib->vba.MaximumVStartup[0][0][k],
         mode_lib->vba.GPUVMMaxPageTableLevels,
         mode_lib->vba.GPUVMEnable,
         mode_lib->vba.DynamicMetadataEnable[k],
         mode_lib->vba.DynamicMetadataLinesBeforeActiveRequired[k],
         mode_lib->vba.DynamicMetadataTransmittedBytes[k],
         mode_lib->vba.DCCEnable[k],
         mode_lib->vba.UrgentLatencyPixelDataOnly,
         mode_lib->vba.ExtraLatency,
         mode_lib->vba.TimeCalc,
         mode_lib->vba.PDEAndMetaPTEBytesPerFrame[0][0][k],
         mode_lib->vba.MetaRowBytes[0][0][k],
         mode_lib->vba.DPTEBytesPerRow[0][0][k],
         mode_lib->vba.PrefetchLinesY[0][0][k],
         mode_lib->vba.SwathWidthYPerState[i][j][k],
         mode_lib->vba.BytePerPixelInDETY[k],
         mode_lib->vba.PrefillY[k],
         mode_lib->vba.MaxNumSwY[k],
         mode_lib->vba.PrefetchLinesC[0][0][k],
         mode_lib->vba.BytePerPixelInDETC[k],
         mode_lib->vba.PrefillC[k],
         mode_lib->vba.MaxNumSwC[k],
         mode_lib->vba.SwathHeightYPerState[i][j][k],
         mode_lib->vba.SwathHeightCPerState[i][j][k],
         mode_lib->vba.TWait,
         mode_lib->vba.XFCEnabled[k],
         mode_lib->vba.XFCRemoteSurfaceFlipDelay,
         mode_lib->vba.Interlace[k],
         mode_lib->vba.ProgressiveToInterlaceUnitInOPP,
         mode_lib->vba.DSTXAfterScaler,
         mode_lib->vba.DSTYAfterScaler,
         &mode_lib->vba.LineTimesForPrefetch[k],
         &mode_lib->vba.PrefetchBW[k],
         &mode_lib->vba.LinesForMetaPTE[k],
         &mode_lib->vba.LinesForMetaAndDPTERow[k],
         &mode_lib->vba.VRatioPreY[i][j][k],
         &mode_lib->vba.VRatioPreC[i][j][k],
         &mode_lib->vba.RequiredPrefetchPixelDataBWLuma[i][j][k],
         &mode_lib->vba.VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,
         &mode_lib->vba.Tno_bw[k],
         &mode_lib->vba.VUpdateOffsetPix[k],
         &mode_lib->vba.VUpdateWidthPix[k],
         &mode_lib->vba.VReadyOffsetPix[k]);
    }
    mode_lib->vba.MaximumReadBandwidthWithoutPrefetch = 0.0;
    mode_lib->vba.MaximumReadBandwidthWithPrefetch = 0.0;
    locals->prefetch_vm_bw_valid = true;
    locals->prefetch_row_bw_valid = true;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     if (locals->PDEAndMetaPTEBytesPerFrame[0][0][k] == 0)
      locals->prefetch_vm_bw[k] = 0;
     else if (locals->LinesForMetaPTE[k] > 0)
      locals->prefetch_vm_bw[k] = locals->PDEAndMetaPTEBytesPerFrame[0][0][k]
       / (locals->LinesForMetaPTE[k] * locals->HTotal[k] / locals->PixelClock[k]);
     else {
      locals->prefetch_vm_bw[k] = 0;
      locals->prefetch_vm_bw_valid = false;
     }
     if (locals->MetaRowBytes[0][0][k] + locals->DPTEBytesPerRow[0][0][k] == 0)
      locals->prefetch_row_bw[k] = 0;
     else if (locals->LinesForMetaAndDPTERow[k] > 0)
      locals->prefetch_row_bw[k] = (locals->MetaRowBytes[0][0][k] + locals->DPTEBytesPerRow[0][0][k])
       / (locals->LinesForMetaAndDPTERow[k] * locals->HTotal[k] / locals->PixelClock[k]);
     else {
      locals->prefetch_row_bw[k] = 0;
      locals->prefetch_row_bw_valid = false;
     }

     mode_lib->vba.MaximumReadBandwidthWithoutPrefetch = mode_lib->vba.MaximumReadBandwidthWithPrefetch
       + mode_lib->vba.cursor_bw[k] + mode_lib->vba.ReadBandwidth[k] + mode_lib->vba.meta_row_bw[k] + mode_lib->vba.dpte_row_bw[k];
     mode_lib->vba.MaximumReadBandwidthWithPrefetch =
       mode_lib->vba.MaximumReadBandwidthWithPrefetch
         + mode_lib->vba.cursor_bw[k]
         + dml_max3(
           mode_lib->vba.prefetch_vm_bw[k],
           mode_lib->vba.prefetch_row_bw[k],
           dml_max(mode_lib->vba.ReadBandwidth[k],
           mode_lib->vba.RequiredPrefetchPixelDataBWLuma[i][j][k])
           + mode_lib->vba.meta_row_bw[k] + mode_lib->vba.dpte_row_bw[k]);
    }
    locals->BandwidthWithoutPrefetchSupported[i][0] = true;
    if (mode_lib->vba.MaximumReadBandwidthWithoutPrefetch > locals->ReturnBWPerState[i][0]) {
     locals->BandwidthWithoutPrefetchSupported[i][0] = false;
    }

    locals->PrefetchSupported[i][j] = true;
    if (mode_lib->vba.MaximumReadBandwidthWithPrefetch > locals->ReturnBWPerState[i][0]) {
     locals->PrefetchSupported[i][j] = false;
    }
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     if (locals->LineTimesForPrefetch[k] < 2.0
       || locals->LinesForMetaPTE[k] >= 8.0
       || locals->LinesForMetaAndDPTERow[k] >= 16.0
       || mode_lib->vba.IsErrorResult[i][j][k] == true) {
      locals->PrefetchSupported[i][j] = false;
     }
    }
    locals->VRatioInPrefetchSupported[i][j] = true;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     if (locals->VRatioPreY[i][j][k] > 4.0
       || locals->VRatioPreC[i][j][k] > 4.0
       || mode_lib->vba.IsErrorResult[i][j][k] == true) {
      locals->VRatioInPrefetchSupported[i][j] = false;
     }
    }
   } while ((locals->PrefetchSupported[i][j] != true || locals->VRatioInPrefetchSupported[i][j] != true)
     && mode_lib->vba.NextPrefetchMode < mode_lib->vba.MaxPrefetchMode);

   if (mode_lib->vba.PrefetchSupported[i][j] == true
     && mode_lib->vba.VRatioInPrefetchSupported[i][j] == true) {
    mode_lib->vba.BandwidthAvailableForImmediateFlip =
      mode_lib->vba.ReturnBWPerState[i][0];
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     mode_lib->vba.BandwidthAvailableForImmediateFlip =
       mode_lib->vba.BandwidthAvailableForImmediateFlip
         - mode_lib->vba.cursor_bw[k]
         - dml_max(
           mode_lib->vba.ReadBandwidth[k] + mode_lib->vba.qual_row_bw[k],
           mode_lib->vba.PrefetchBW[k]);
    }
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     mode_lib->vba.ImmediateFlipBytes[k] = 0.0;
     if ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8
       && mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {
      mode_lib->vba.ImmediateFlipBytes[k] =
        mode_lib->vba.PDEAndMetaPTEBytesPerFrame[0][0][k]
          + mode_lib->vba.MetaRowBytes[0][0][k]
          + mode_lib->vba.DPTEBytesPerRow[0][0][k];
     }
    }
    mode_lib->vba.TotImmediateFlipBytes = 0.0;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     if ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8
       && mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {
      mode_lib->vba.TotImmediateFlipBytes =
        mode_lib->vba.TotImmediateFlipBytes
          + mode_lib->vba.ImmediateFlipBytes[k];
     }
    }

    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     CalculateFlipSchedule(
       mode_lib,
       mode_lib->vba.ExtraLatency,
       mode_lib->vba.UrgentLatencyPixelDataOnly,
       mode_lib->vba.GPUVMMaxPageTableLevels,
       mode_lib->vba.GPUVMEnable,
       mode_lib->vba.BandwidthAvailableForImmediateFlip,
       mode_lib->vba.TotImmediateFlipBytes,
       mode_lib->vba.SourcePixelFormat[k],
       mode_lib->vba.ImmediateFlipBytes[k],
       mode_lib->vba.HTotal[k]
         / mode_lib->vba.PixelClock[k],
       mode_lib->vba.VRatio[k],
       mode_lib->vba.Tno_bw[k],
       mode_lib->vba.PDEAndMetaPTEBytesPerFrame[0][0][k],
       mode_lib->vba.MetaRowBytes[0][0][k],
       mode_lib->vba.DPTEBytesPerRow[0][0][k],
       mode_lib->vba.DCCEnable[k],
       mode_lib->vba.dpte_row_height[k],
       mode_lib->vba.meta_row_height[k],
       mode_lib->vba.qual_row_bw[k],
       &mode_lib->vba.DestinationLinesToRequestVMInImmediateFlip[k],
       &mode_lib->vba.DestinationLinesToRequestRowInImmediateFlip[k],
       &mode_lib->vba.final_flip_bw[k],
       &mode_lib->vba.ImmediateFlipSupportedForPipe[k]);
    }
    mode_lib->vba.total_dcn_read_bw_with_flip = 0.0;
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     mode_lib->vba.total_dcn_read_bw_with_flip =
       mode_lib->vba.total_dcn_read_bw_with_flip
         + mode_lib->vba.cursor_bw[k]
         + dml_max3(
           mode_lib->vba.prefetch_vm_bw[k],
           mode_lib->vba.prefetch_row_bw[k],
           mode_lib->vba.final_flip_bw[k]
             + dml_max(
               mode_lib->vba.ReadBandwidth[k],
               mode_lib->vba.RequiredPrefetchPixelDataBWLuma[i][j][k]));
    }
    mode_lib->vba.ImmediateFlipSupportedForState[i][j] = true;
    if (mode_lib->vba.total_dcn_read_bw_with_flip
      > mode_lib->vba.ReturnBWPerState[i][0]) {
     mode_lib->vba.ImmediateFlipSupportedForState[i][j] = false;
    }
    for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
     if (mode_lib->vba.ImmediateFlipSupportedForPipe[k] == false) {
      mode_lib->vba.ImmediateFlipSupportedForState[i][j] = false;
     }
    }
   } else {
    mode_lib->vba.ImmediateFlipSupportedForState[i][j] = false;
   }
  }
 }


 mode_lib->vba.MaxTotalVActiveRDBandwidth = 0;
 for (k = 0; k < mode_lib->vba.NumberOfActivePlanes; k++)
  mode_lib->vba.MaxTotalVActiveRDBandwidth = mode_lib->vba.MaxTotalVActiveRDBandwidth + mode_lib->vba.ReadBandwidth[k];
 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  mode_lib->vba.MaxTotalVerticalActiveAvailableBandwidth[i][0] = dml_min(mode_lib->vba.ReturnBusWidth *
    mode_lib->vba.DCFCLKPerState[i], mode_lib->vba.FabricAndDRAMBandwidthPerState[i] * 1000) *
    mode_lib->vba.MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation / 100;
  if (mode_lib->vba.MaxTotalVActiveRDBandwidth <= mode_lib->vba.MaxTotalVerticalActiveAvailableBandwidth[i][0])
   mode_lib->vba.TotalVerticalActiveBandwidthSupport[i][0] = true;
  else
   mode_lib->vba.TotalVerticalActiveBandwidthSupport[i][0] = false;
 }



 for (i = 0; i <= mode_lib->vba.soc.num_states; i++) {
  for (j = 0; j < 2; j++) {
   locals->PTEBufferSizeNotExceeded[i][j] = true;
   for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
    if (locals->PTEBufferSizeNotExceededY[i][j][k] == false
      || locals->PTEBufferSizeNotExceededC[i][j][k] == false) {
     locals->PTEBufferSizeNotExceeded[i][j] = false;
    }
   }
  }
 }

 mode_lib->vba.CursorSupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  for (j = 0; j < 2; j++) {
   if (mode_lib->vba.CursorWidth[k][j] > 0.0) {
    if (dml_floor(
      dml_floor(
        mode_lib->vba.CursorBufferSize
          - mode_lib->vba.CursorChunkSize,
        mode_lib->vba.CursorChunkSize) * 1024.0
        / (mode_lib->vba.CursorWidth[k][j]
          * mode_lib->vba.CursorBPP[k][j]
          / 8.0),
      1.0)
      * (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])
      / mode_lib->vba.VRatio[k] < mode_lib->vba.UrgentLatencyPixelDataOnly
      || (mode_lib->vba.CursorBPP[k][j] == 64.0
        && mode_lib->vba.Cursor64BppSupport == false)) {
     mode_lib->vba.CursorSupport = false;
    }
   }
  }
 }


 mode_lib->vba.PitchSupport = true;
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  locals->AlignedYPitch[k] = dml_ceil(
    dml_max(mode_lib->vba.PitchY[k], mode_lib->vba.ViewportWidth[k]),
    locals->MacroTileWidthY[k]);
  if (locals->AlignedYPitch[k] > mode_lib->vba.PitchY[k]) {
   mode_lib->vba.PitchSupport = false;
  }
  if (mode_lib->vba.DCCEnable[k] == true) {
   locals->AlignedDCCMetaPitch[k] = dml_ceil(
     dml_max(
       mode_lib->vba.DCCMetaPitchY[k],
       mode_lib->vba.ViewportWidth[k]),
     64.0 * locals->Read256BlockWidthY[k]);
  } else {
   locals->AlignedDCCMetaPitch[k] = mode_lib->vba.DCCMetaPitchY[k];
  }
  if (locals->AlignedDCCMetaPitch[k] > mode_lib->vba.DCCMetaPitchY[k]) {
   mode_lib->vba.PitchSupport = false;
  }
  if (mode_lib->vba.SourcePixelFormat[k] != dm_444_64
    && mode_lib->vba.SourcePixelFormat[k] != dm_444_32
    && mode_lib->vba.SourcePixelFormat[k] != dm_444_16
    && mode_lib->vba.SourcePixelFormat[k] != dm_mono_16
    && mode_lib->vba.SourcePixelFormat[k] != dm_mono_8) {
   locals->AlignedCPitch[k] = dml_ceil(
     dml_max(
       mode_lib->vba.PitchC[k],
       mode_lib->vba.ViewportWidth[k] / 2.0),
     locals->MacroTileWidthC[k]);
  } else {
   locals->AlignedCPitch[k] = mode_lib->vba.PitchC[k];
  }
  if (locals->AlignedCPitch[k] > mode_lib->vba.PitchC[k]) {
   mode_lib->vba.PitchSupport = false;
  }
 }


 for (i = mode_lib->vba.soc.num_states; i >= 0; i--) {
  for (j = 0; j < 2; j++) {
   enum dm_validation_status status = DML_VALIDATION_OK;

   if (mode_lib->vba.ScaleRatioAndTapsSupport != true) {
    status = DML_FAIL_SCALE_RATIO_TAP;
   } else if (mode_lib->vba.SourceFormatPixelAndScanSupport != true) {
    status = DML_FAIL_SOURCE_PIXEL_FORMAT;
   } else if (locals->ViewportSizeSupport[i][0] != true) {
    status = DML_FAIL_VIEWPORT_SIZE;
   } else if (locals->DIOSupport[i] != true) {
    status = DML_FAIL_DIO_SUPPORT;
   } else if (locals->NotEnoughDSCUnits[i] != false) {
    status = DML_FAIL_NOT_ENOUGH_DSC;
   } else if (locals->DSCCLKRequiredMoreThanSupported[i] != false) {
    status = DML_FAIL_DSC_CLK_REQUIRED;
   } else if (locals->UrgentLatencySupport[i][j] != true) {
    status = DML_FAIL_URGENT_LATENCY;
   } else if (locals->ROBSupport[i][0] != true) {
    status = DML_FAIL_REORDERING_BUFFER;
   } else if (locals->DISPCLK_DPPCLK_Support[i][j] != true) {
    status = DML_FAIL_DISPCLK_DPPCLK;
   } else if (locals->TotalAvailablePipesSupport[i][j] != true) {
    status = DML_FAIL_TOTAL_AVAILABLE_PIPES;
   } else if (mode_lib->vba.NumberOfOTGSupport != true) {
    status = DML_FAIL_NUM_OTG;
   } else if (mode_lib->vba.WritebackModeSupport != true) {
    status = DML_FAIL_WRITEBACK_MODE;
   } else if (mode_lib->vba.WritebackLatencySupport != true) {
    status = DML_FAIL_WRITEBACK_LATENCY;
   } else if (mode_lib->vba.WritebackScaleRatioAndTapsSupport != true) {
    status = DML_FAIL_WRITEBACK_SCALE_RATIO_TAP;
   } else if (mode_lib->vba.CursorSupport != true) {
    status = DML_FAIL_CURSOR_SUPPORT;
   } else if (mode_lib->vba.PitchSupport != true) {
    status = DML_FAIL_PITCH_SUPPORT;
   } else if (locals->PrefetchSupported[i][j] != true) {
    status = DML_FAIL_PREFETCH_SUPPORT;
   } else if (locals->TotalVerticalActiveBandwidthSupport[i][0] != true) {
    status = DML_FAIL_TOTAL_V_ACTIVE_BW;
   } else if (locals->VRatioInPrefetchSupported[i][j] != true) {
    status = DML_FAIL_V_RATIO_PREFETCH;
   } else if (locals->PTEBufferSizeNotExceeded[i][j] != true) {
    status = DML_FAIL_PTE_BUFFER_SIZE;
   } else if (mode_lib->vba.NonsupportedDSCInputBPC != false) {
    status = DML_FAIL_DSC_INPUT_BPC;
   }

   if (status == DML_VALIDATION_OK) {
    locals->ModeSupport[i][j] = true;
   } else {
    locals->ModeSupport[i][j] = false;
   }
   locals->ValidationStatus[i] = status;
  }
 }
 {
  unsigned int MaximumMPCCombine = 0;
  mode_lib->vba.VoltageLevel = mode_lib->vba.soc.num_states + 1;
  for (i = mode_lib->vba.VoltageOverrideLevel; i <= mode_lib->vba.soc.num_states; i++) {
   if (locals->ModeSupport[i][0] == true || locals->ModeSupport[i][1] == true) {
    mode_lib->vba.VoltageLevel = i;
    if (locals->ModeSupport[i][1] == true && (locals->ModeSupport[i][0] == false
      || mode_lib->vba.WhenToDoMPCCombine == dm_mpc_always_when_possible)) {
     MaximumMPCCombine = 1;
    } else {
     MaximumMPCCombine = 0;
    }
    break;
   }
  }
  mode_lib->vba.ImmediateFlipSupport =
   locals->ImmediateFlipSupportedForState[mode_lib->vba.VoltageLevel][MaximumMPCCombine];
  for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
   mode_lib->vba.DPPPerPlane[k] = locals->NoOfDPP[mode_lib->vba.VoltageLevel][MaximumMPCCombine][k];
   locals->DPPCLK[k] = locals->RequiredDPPCLK[mode_lib->vba.VoltageLevel][MaximumMPCCombine][k];
  }
  mode_lib->vba.DISPCLK = locals->RequiredDISPCLK[mode_lib->vba.VoltageLevel][MaximumMPCCombine];
  mode_lib->vba.maxMpcComb = MaximumMPCCombine;
 }
 mode_lib->vba.DCFCLK = mode_lib->vba.DCFCLKPerState[mode_lib->vba.VoltageLevel];
 mode_lib->vba.DRAMSpeed = mode_lib->vba.DRAMSpeedPerState[mode_lib->vba.VoltageLevel];
 mode_lib->vba.FabricClock = mode_lib->vba.FabricClockPerState[mode_lib->vba.VoltageLevel];
 mode_lib->vba.SOCCLK = mode_lib->vba.SOCCLKPerState[mode_lib->vba.VoltageLevel];
 mode_lib->vba.ReturnBW = locals->ReturnBWPerState[mode_lib->vba.VoltageLevel][0];
 mode_lib->vba.FabricAndDRAMBandwidth = locals->FabricAndDRAMBandwidthPerState[mode_lib->vba.VoltageLevel];
 for (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {
  if (mode_lib->vba.BlendingAndTiming[k] == k) {
   mode_lib->vba.ODMCombineEnabled[k] =
     locals->ODMCombineEnablePerState[mode_lib->vba.VoltageLevel][k];
  } else {
   mode_lib->vba.ODMCombineEnabled[k] = 0;
  }
  mode_lib->vba.DSCEnabled[k] =
    locals->RequiresDSC[mode_lib->vba.VoltageLevel][k];
  mode_lib->vba.OutputBpp[k] =
    locals->OutputBppPerState[mode_lib->vba.VoltageLevel][k];
 }
}
