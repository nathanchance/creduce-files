# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 340 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/include/linux/kconfig.h" 1




# 1 "./include/generated/autoconf.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/kconfig.h" 2
# 2 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 1
# 59 "/home/nathan/src/linux-next/include/linux/compiler_types.h"
# 1 "/home/nathan/src/linux-next/include/linux/compiler_attributes.h" 1
# 60 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/compiler-clang.h" 1
# 64 "/home/nathan/src/linux-next/include/linux/compiler_types.h" 2
# 85 "/home/nathan/src/linux-next/include/linux/compiler_types.h"
struct ftrace_branch_data {
 const char *func;
 const char *file;
 unsigned line;
 union {
  struct {
   unsigned long correct;
   unsigned long incorrect;
  };
  struct {
   unsigned long miss;
   unsigned long hit;
  };
  unsigned long miss_hit[2];
 };
};

struct ftrace_likely_data {
 struct ftrace_branch_data data;
 unsigned long constant;
};
# 3 "<built-in>" 2
# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c" 2
# 14 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c"
# 1 "/home/nathan/src/linux-next/include/linux/module.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/module.h"
# 1 "/home/nathan/src/linux-next/include/linux/list.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/types.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h" 1
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h" 1
# 12 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitsperlong.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/bitsperlong.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/bitsperlong.h" 2
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/bitsperlong.h" 2
# 13 "/home/nathan/src/linux-next/include/uapi/asm-generic/int-ll64.h" 2







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 12 "/home/nathan/src/linux-next/include/asm-generic/int-ll64.h" 2




typedef __s8 s8;
typedef __u8 u8;
typedef __s16 s16;
typedef __u16 u16;
typedef __s32 s32;
typedef __u32 u32;
typedef __s64 s64;
typedef __u64 u64;
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/types.h" 2





typedef struct {
 __u32 u[4];
} __attribute__((aligned(16))) __vector128;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h" 2
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/types.h"
typedef __vector128 vector128;

typedef struct {
 unsigned long entry;
 unsigned long toc;
 unsigned long env;
} func_descr_t;
# 6 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 2








# 1 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/stddef.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/stddef.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/stddef.h" 2




enum {
 false = 0,
 true = 1
};
# 6 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 2
# 25 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h"
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h"
typedef unsigned long __kernel_old_dev_t;
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h" 1
# 15 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;



typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;
# 72 "/home/nathan/src/linux-next/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 25 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/posix_types.h" 2
# 37 "/home/nathan/src/linux-next/include/uapi/linux/posix_types.h" 2
# 15 "/home/nathan/src/linux-next/include/uapi/linux/types.h" 2
# 29 "/home/nathan/src/linux-next/include/uapi/linux/types.h"
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 52 "/home/nathan/src/linux-next/include/uapi/linux/types.h"
typedef unsigned __poll_t;
# 7 "/home/nathan/src/linux-next/include/linux/types.h" 2






typedef u32 __kernel_dev_t;

typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef unsigned short umode_t;
typedef u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;

typedef unsigned long uintptr_t;
# 46 "/home/nathan/src/linux-next/include/linux/types.h"
typedef __kernel_loff_t loff_t;
# 55 "/home/nathan/src/linux-next/include/linux/types.h"
typedef __kernel_size_t size_t;




typedef __kernel_ssize_t ssize_t;




typedef __kernel_ptrdiff_t ptrdiff_t;




typedef __kernel_old_time_t time_t;




typedef __kernel_clock_t clock_t;




typedef __kernel_caddr_t caddr_t;



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;




typedef u8 u_int8_t;
typedef s8 int8_t;
typedef u16 u_int16_t;
typedef s16 int16_t;
typedef u32 u_int32_t;
typedef s32 int32_t;



typedef u8 uint8_t;
typedef u16 uint16_t;
typedef u32 uint32_t;


typedef u64 uint64_t;
typedef u64 u_int64_t;
typedef s64 int64_t;
# 130 "/home/nathan/src/linux-next/include/linux/types.h"
typedef u64 sector_t;
typedef u64 blkcnt_t;
# 148 "/home/nathan/src/linux-next/include/linux/types.h"
typedef u64 dma_addr_t;




typedef unsigned int gfp_t;
typedef unsigned int slab_flags_t;
typedef unsigned int fmode_t;


typedef u64 phys_addr_t;




typedef phys_addr_t resource_size_t;





typedef unsigned long irq_hw_number_t;

typedef struct {
 int counter;
} atomic_t;


typedef struct {
 s64 counter;
} atomic64_t;


struct list_head {
 struct list_head *next, *prev;
};

struct hlist_head {
 struct hlist_node *first;
};

struct hlist_node {
 struct hlist_node *next, **pprev;
};

struct ustat {
 __kernel_daddr_t f_tfree;
 __kernel_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];
};
# 219 "/home/nathan/src/linux-next/include/linux/types.h"
struct callback_head {
 struct callback_head *next;
 void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));


typedef void (*rcu_callback_t)(struct callback_head *head);
typedef void (*call_rcu_func_t)(struct callback_head *head, rcu_callback_t func);

typedef void (*swap_func_t)(void *a, void *b, int size);

typedef int (*cmp_r_func_t)(const void *a, const void *b, const void *priv);
typedef int (*cmp_func_t)(const void *a, const void *b);
# 6 "/home/nathan/src/linux-next/include/linux/list.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/poison.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/const.h" 1



# 1 "/home/nathan/src/linux-next/include/uapi/linux/const.h" 1
# 5 "/home/nathan/src/linux-next/include/linux/const.h" 2
# 9 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kernel.h" 1





# 1 "/home/nathan/cbl/git/tc-build-master/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 1 3
# 14 "/home/nathan/cbl/git/tc-build-master/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 3
typedef __builtin_va_list va_list;
# 32 "/home/nathan/cbl/git/tc-build-master/build/llvm/stage1/lib/clang/11.0.0/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 7 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/limits.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/limits.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/limits.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/linkage.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/stringify.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/export.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/export.h"
extern struct module __this_module;
# 72 "/home/nathan/src/linux-next/include/linux/export.h"
struct kernel_symbol {
 unsigned long value;
 const char *name;
 const char *namespace;
};
# 8 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/linkage.h" 1
# 9 "/home/nathan/src/linux-next/include/linux/linkage.h" 2
# 9 "/home/nathan/src/linux-next/include/linux/kernel.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/compiler.h" 1
# 196 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__))
void __read_once_size(const volatile void *p, void *res, int size)
{
 ({ switch (size) { case 1: *(__u8 *)res = *(volatile __u8 *)p; break; case 2: *(__u16 *)res = *(volatile __u16 *)p; break; case 4: *(__u32 *)res = *(volatile __u32 *)p; break; case 8: *(__u64 *)res = *(volatile __u64 *)p; break; default: __asm__ __volatile__("" : : : "memory"); __builtin_memcpy((void *)res, (const void *)p, size); __asm__ __volatile__("" : : : "memory"); } });
}
# 214 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__))
void __read_once_size_nocheck(const volatile void *p, void *res, int size)
{
 ({ switch (size) { case 1: *(__u8 *)res = *(volatile __u8 *)p; break; case 2: *(__u16 *)res = *(volatile __u16 *)p; break; case 4: *(__u32 *)res = *(volatile __u32 *)p; break; case 8: *(__u64 *)res = *(volatile __u64 *)p; break; default: __asm__ __volatile__("" : : : "memory"); __builtin_memcpy((void *)res, (const void *)p, size); __asm__ __volatile__("" : : : "memory"); } });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __write_once_size(volatile void *p, void *res, int size)
{
 switch (size) {
 case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
 case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
 case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
 case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
 default:
  __asm__ __volatile__("" : : : "memory");
  __builtin_memcpy((void *)p, (const void *)res, size);
  __asm__ __volatile__("" : : : "memory");
 }
}
# 256 "/home/nathan/src/linux-next/include/linux/compiler.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-const.h" 1
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 2
# 100 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/barrier.h" 1
# 16 "/home/nathan/src/linux-next/include/asm-generic/barrier.h"
# 1 "/home/nathan/src/linux-next/include/linux/compiler.h" 1
# 17 "/home/nathan/src/linux-next/include/asm-generic/barrier.h" 2
# 101 "/home/nathan/src/linux-next/arch/powerpc/include/asm/barrier.h" 2
# 257 "/home/nathan/src/linux-next/include/linux/compiler.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kasan-checks.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/kasan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __kasan_check_read(const volatile void *p, unsigned int size)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __kasan_check_write(const volatile void *p, unsigned int size)
{
 return true;
}
# 34 "/home/nathan/src/linux-next/include/linux/kasan-checks.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_check_read(const volatile void *p, unsigned int size)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_check_write(const volatile void *p, unsigned int size)
{
 return true;
}
# 258 "/home/nathan/src/linux-next/include/linux/compiler.h" 2
# 277 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__))
unsigned long read_word_at_a_time(const void *addr)
{
 kasan_check_read(addr, 1);
 return *(unsigned long *)addr;
}
# 308 "/home/nathan/src/linux-next/include/linux/compiler.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *offset_to_ptr(const int *off)
{
 return (void *)((unsigned long)off + *off);
}
# 12 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/bitops.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/bits.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/bitops.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/bitops.h"
extern unsigned int __sw_hweight8(unsigned int w);
extern unsigned int __sw_hweight16(unsigned int w);
extern unsigned int __sw_hweight32(unsigned int w);
extern unsigned long __sw_hweight64(__u64 w);






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 1
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-compat.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ppc-opcode.h" 1
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-compat.h" 2
# 43 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/synch.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/feature-fixups.h" 1
# 239 "/home/nathan/src/linux-next/arch/powerpc/include/asm/feature-fixups.h"
extern long stf_barrier_fallback;
extern long __start___stf_entry_barrier_fixup, __stop___stf_entry_barrier_fixup;
extern long __start___stf_exit_barrier_fixup, __stop___stf_exit_barrier_fixup;
extern long __start___rfi_flush_fixup, __stop___rfi_flush_fixup;
extern long __start___barrier_nospec_fixup, __stop___barrier_nospec_fixup;
extern long __start__btb_flush_fixup, __stop__btb_flush_fixup;

void apply_feature_fixups(void);
void setup_feature_keys(void);
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/synch.h" 2



extern unsigned int __start___lwsync_fixup, __stop___lwsync_fixup;
extern void do_lwsync_fixups(unsigned long value, void *fixup_start,
        void *fixup_end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eieio(void)
{
 __asm__ __volatile__ ("eieio" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void isync(void)
{
 __asm__ __volatile__ ("isync" : : : "memory");
}
# 44 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/asm-405.h" 1
# 45 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 84 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "or" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bits_unlock(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "lwsync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void change_bits(unsigned long mask, volatile unsigned long *_p) { unsigned long old; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "xor" " " "%0,%0,%2\n" "stdcx." " " "%0,0,%3\n" "bne- 1b\n" : "=&r" (old), "+m" (*p) : "r" (mask), "r" (p) : "cc", "memory"); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_set_bit(int nr, volatile unsigned long *addr)
{
 set_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_clear_bit(int nr, volatile unsigned long *addr)
{
 clear_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_clear_bit_unlock(int nr, volatile unsigned long *addr)
{
 clear_bits_unlock(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_change_bit(int nr, volatile unsigned long *addr)
{
 change_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64));
}
# 132 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_set_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "or" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_set_bits_lock( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n" "or" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_clear_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "andc" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long test_and_change_bits( unsigned long mask, volatile unsigned long *_p) { unsigned long old, t; unsigned long *p = (unsigned long *)_p; __asm__ __volatile__ ( "\n" "sync" " " "\n" "1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n" "xor" " " "%1,%0,%2\n" "stdcx." " " "%1,0,%3\n" "bne- 1b\n" "\n" "sync" " " "\n" : "=&r" (old), "=&r" (t) : "r" (mask), "r" (p) : "cc", "memory"); return (old & mask); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_set_bit(unsigned long nr,
     volatile unsigned long *addr)
{
 return test_and_set_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_set_bit_lock(unsigned long nr,
          volatile unsigned long *addr)
{
 return test_and_set_bits_lock(((((1UL))) << ((nr) % 64)),
    addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_clear_bit(unsigned long nr,
       volatile unsigned long *addr)
{
 return test_and_clear_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_test_and_change_bit(unsigned long nr,
        volatile unsigned long *addr)
{
 return test_and_change_bits(((((1UL))) << ((nr) % 64)), addr + ((nr) / 64)) != 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
clear_bit_unlock_return_word(int nr, volatile unsigned long *addr)
{
 unsigned long old, t;
 unsigned long *p = (unsigned long *)addr + ((nr) / 64);
 unsigned long mask = ((((1UL))) << ((nr) % 64));

 __asm__ __volatile__ (
 "lwsync" " " "\n"
"1:" ".long 0x7c0000a8 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%3) & 0x1f) << 11) | (((0) & 0x1) << 0)" " " "\n"
 "andc %1,%0,%2\n"

 "stdcx." " " "%1,0,%3\n"
 "bne- 1b\n"
 : "=&r" (old), "=&r" (t)
 : "r" (mask), "r" (p)
 : "cc", "memory");

 return old;
}
# 197 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h" 1
# 16 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p |= mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p &= ~mask;
}
# 41 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __change_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);

 *p ^= mask;
}
# 58 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_set_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old | mask;
 return (old & mask) != 0;
}
# 77 "/home/nathan/src/linux-next/include/asm-generic/bitops/non-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_clear_bit(int nr, volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old & ~mask;
 return (old & mask) != 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_change_bit(int nr,
         volatile unsigned long *addr)
{
 unsigned long mask = ((((1UL))) << ((nr) % 64));
 unsigned long *p = ((unsigned long *)addr) + ((nr) / 64);
 unsigned long old = *p;

 *p = old ^ mask;
 return (old & mask) != 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_bit(int nr, const volatile unsigned long *addr)
{
 return 1UL & (addr[((nr) / 64)] >> (nr & (64 -1)));
}
# 198 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch___clear_bit_unlock(int nr, volatile unsigned long *addr)
{
 __asm__ __volatile__("lwsync" " " "\n" "" ::: "memory");
 __clear_bit(nr, addr);
}








# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/ffz.h" 1
# 212 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__ffs.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__ffs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __ffs(unsigned long word)
{
 return __builtin_ctzl(word);
}
# 214 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-ffs.h" 1
# 13 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-ffs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int ffs(int x)
{
 return __builtin_ffs(x);
}
# 216 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fls(unsigned int x)
{
 return 32 - __builtin_clz(x);
}


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__fls.h" 1
# 11 "/home/nathan/src/linux-next/include/asm-generic/bitops/builtin-__fls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __fls(unsigned long word)
{
 return (sizeof(word) * 8) - 1 - __builtin_clzl(word);
}
# 227 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fls64(__u64 x)
{
 return 64 - __builtin_clzll(x);
}


unsigned int __arch_hweight8(unsigned int w);
unsigned int __arch_hweight16(unsigned int w);
unsigned int __arch_hweight32(unsigned int w);
unsigned long __arch_hweight64(__u64 w);

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/const_hweight.h" 1
# 239 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2




# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h" 1
# 15 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(const unsigned long *addr, unsigned long
  size, unsigned long offset);
# 30 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_and_bit(const unsigned long *addr1,
  const unsigned long *addr2, unsigned long size,
  unsigned long offset);
# 45 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_zero_bit(const unsigned long *addr, unsigned
  long size, unsigned long offset);
# 93 "/home/nathan/src/linux-next/include/asm-generic/bitops/find.h"
extern unsigned long find_next_clump8(unsigned long *clump,
          const unsigned long *addr,
          unsigned long size, unsigned long offset);
# 244 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h" 1
# 26 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 arch_set_bit(nr, addr);
}
# 39 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 arch_clear_bit(nr, addr);
}
# 55 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void change_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 arch_change_bit(nr, addr);
}
# 68 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_set_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_set_bit(nr, addr);
}
# 81 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_clear_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_clear_bit(nr, addr);
}
# 94 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_change_bit(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_change_bit(nr, addr);
}
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h" 1
# 23 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit_unlock(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 arch_clear_bit_unlock(nr, addr);
}
# 38 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit_unlock(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 arch___clear_bit_unlock(nr, addr);
}
# 53 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_set_bit_lock(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 return arch_test_and_set_bit_lock(nr, addr);
}
# 71 "/home/nathan/src/linux-next/include/asm-generic/bitops/instrumented-lock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
clear_bit_unlock_is_negative_byte(long nr, volatile unsigned long *addr)
{
 kasan_check_write(addr + ((nr) / 64), sizeof(long));
 return (clear_bit_unlock_return_word(nr, addr) & ((((1UL))) << ((7) % 64)));
}
# 248 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2


# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h" 1
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h"
# 1 "/home/nathan/src/linux-next/include/linux/byteorder/big_endian.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/big_endian.h" 1
# 13 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/big_endian.h"
# 1 "/home/nathan/src/linux-next/include/linux/swab.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/swab.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/swab.h" 1






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/swab.h" 1
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/swab.h" 2
# 9 "/home/nathan/src/linux-next/include/uapi/linux/swab.h" 2
# 48 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u16 __fswab16(__u16 val)
{



 return ((__u16)( (((__u16)(val) & (__u16)0x00ffU) << 8) | (((__u16)(val) & (__u16)0xff00U) >> 8)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswab32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x000000ffUL) << 24) | (((__u32)(val) & (__u32)0x0000ff00UL) << 8) | (((__u32)(val) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(val) & (__u32)0xff000000UL) >> 24)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u64 __fswab64(__u64 val)
{







 return ((__u64)( (((__u64)(val) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(val) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(val) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(val) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(val) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(val) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(val) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(val) & (__u64)0xff00000000000000ULL) >> 56)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswahw32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x0000ffffUL) << 16) | (((__u32)(val) & (__u32)0xffff0000UL) >> 16)));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) __u32 __fswahb32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(val) & (__u32)0xff00ff00UL) >> 8)));

}
# 136 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __swab(const unsigned long y)
{

 return (__builtin_constant_p((__u64)(y)) ? ((__u64)( (((__u64)(y) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(y) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(y) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(y) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(y) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(y) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(y) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(y) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(y));



}
# 171 "/home/nathan/src/linux-next/include/uapi/linux/swab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __swab16p(const __u16 *p)
{



 return (__builtin_constant_p((__u16)(*p)) ? ((__u16)( (((__u16)(*p) & (__u16)0x00ffU) << 8) | (((__u16)(*p) & (__u16)0xff00U) >> 8))) : __fswab16(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __swab32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x000000ffUL) << 24) | (((__u32)(*p) & (__u32)0x0000ff00UL) << 8) | (((__u32)(*p) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(*p) & (__u32)0xff000000UL) >> 24))) : __fswab32(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __swab64p(const __u64 *p)
{



 return (__builtin_constant_p((__u64)(*p)) ? ((__u64)( (((__u64)(*p) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(*p) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(*p) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(*p) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(*p) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(*p) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(*p) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(*p) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(*p));

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 __swahw32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x0000ffffUL) << 16) | (((__u32)(*p) & (__u32)0xffff0000UL) >> 16))) : __fswahw32(*p));

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 __swahb32p(const __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(*p) & (__u32)0xff00ff00UL) >> 8))) : __fswahb32(*p));

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swab16s(__u16 *p)
{



 *p = __swab16p(p);

}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __swab32s(__u32 *p)
{



 *p = __swab32p(p);

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __swab64s(__u64 *p)
{



 *p = __swab64p(p);

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swahw32s(__u32 *p)
{



 *p = __swahw32p(p);

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __swahb32s(__u32 *p)
{



 *p = __swahb32p(p);

}
# 6 "/home/nathan/src/linux-next/include/linux/swab.h" 2
# 14 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/big_endian.h" 2
# 44 "/home/nathan/src/linux-next/include/uapi/linux/byteorder/big_endian.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le64 __cpu_to_le64p(const __u64 *p)
{
 return ( __le64)__swab64p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __le64_to_cpup(const __le64 *p)
{
 return __swab64p((__u64 *)p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le32 __cpu_to_le32p(const __u32 *p)
{
 return ( __le32)__swab32p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __le32_to_cpup(const __le32 *p)
{
 return __swab32p((__u32 *)p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __le16 __cpu_to_le16p(const __u16 *p)
{
 return ( __le16)__swab16p(p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __le16_to_cpup(const __le16 *p)
{
 return __swab16p((__u16 *)p);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be64 __cpu_to_be64p(const __u64 *p)
{
 return ( __be64)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u64 __be64_to_cpup(const __be64 *p)
{
 return ( __u64)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be32 __cpu_to_be32p(const __u32 *p)
{
 return ( __be32)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u32 __be32_to_cpup(const __be32 *p)
{
 return ( __u32)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __be16 __cpu_to_be16p(const __u16 *p)
{
 return ( __be16)*p;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __u16 __be16_to_cpup(const __be16 *p)
{
 return ( __u16)*p;
}
# 6 "/home/nathan/src/linux-next/include/linux/byteorder/big_endian.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/byteorder/generic.h" 1
# 144 "/home/nathan/src/linux-next/include/linux/byteorder/generic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le16_add_cpu(__le16 *var, u16 val)
{
 *var = (( __le16)(__builtin_constant_p((__u16)(((__builtin_constant_p((__u16)(( __u16)(__le16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__le16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(*var))) + val))) ? ((__u16)( (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__le16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__le16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(*var))) + val)) & (__u16)0x00ffU) << 8) | (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__le16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__le16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(*var))) + val)) & (__u16)0xff00U) >> 8))) : __fswab16(((__builtin_constant_p((__u16)(( __u16)(__le16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__le16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(*var))) + val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le32_add_cpu(__le32 *var, u32 val)
{
 *var = (( __le32)(__builtin_constant_p((__u32)(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val))) ? ((__u32)( (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val)) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val)) & (__u32)0xff000000UL) >> 24))) : __fswab32(((__builtin_constant_p((__u32)(( __u32)(__le32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(*var))) + val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le64_add_cpu(__le64 *var, u64 val)
{
 *var = (( __le64)(__builtin_constant_p((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val))) ? ((__u64)( (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((__builtin_constant_p((__u64)(( __u64)(__le64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(*var))) + val))));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void le32_to_cpu_array(u32 *buf, unsigned int words)
{
 while (words--) {
  __swab32s((buf));
  buf++;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_to_le32_array(u32 *buf, unsigned int words)
{
 while (words--) {
  __swab32s((buf));
  buf++;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be16_add_cpu(__be16 *var, u16 val)
{
 *var = (( __be16)(__u16)((( __u16)(__be16)(*var)) + val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be32_add_cpu(__be32 *var, u32 val)
{
 *var = (( __be32)(__u32)((( __u32)(__be32)(*var)) + val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be64_add_cpu(__be64 *var, u64 val)
{
 *var = (( __be64)(__u64)((( __u64)(__be64)(*var)) + val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)
{
 int i;

 for (i = 0; i < len; i++)
  dst[i] = (( __be32)(__u32)(src[i]));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)
{
 int i;

 for (i = 0; i < len; i++)
  dst[i] = (( __u32)(__be32)(src[i]));
}
# 12 "/home/nathan/src/linux-next/include/linux/byteorder/big_endian.h" 2
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/byteorder.h" 2
# 7 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h" 2
# 35 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h"
extern unsigned long find_next_zero_bit_le(const void *addr,
  unsigned long size, unsigned long offset);



extern unsigned long find_next_bit_le(const void *addr,
  unsigned long size, unsigned long offset);
# 53 "/home/nathan/src/linux-next/include/asm-generic/bitops/le.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_bit_le(int nr, const void *addr)
{
 return test_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bit_le(int nr, void *addr)
{
 set_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bit_le(int nr, void *addr)
{
 clear_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_bit_le(int nr, void *addr)
{
 __set_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __clear_bit_le(int nr, void *addr)
{
 __clear_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_bit_le(int nr, void *addr)
{
 return test_and_set_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_bit_le(int nr, void *addr)
{
 return test_and_clear_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_set_bit_le(int nr, void *addr)
{
 return __test_and_set_bit(nr ^ ((64 -1) & ~0x7), addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __test_and_clear_bit_le(int nr, void *addr)
{
 return __test_and_clear_bit(nr ^ ((64 -1) & ~0x7), addr);
}
# 251 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2



# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/ext2-atomic-setbit.h" 1
# 255 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h" 1
# 13 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sched_find_first_bit(const unsigned long *b)
{

 if (b[0])
  return __ffs(b[0]);
 return __ffs(b[1]) + 64;
# 30 "/home/nathan/src/linux-next/include/asm-generic/bitops/sched.h"
}
# 257 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bitops.h" 2
# 30 "/home/nathan/src/linux-next/include/linux/bitops.h" 2
# 65 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_bitmask_order(unsigned int count)
{
 int order;

 order = fls(count);
 return order;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long hweight_long(unsigned long w)
{
 return sizeof(w) == 4 ? (__builtin_constant_p(w) ? ((((unsigned int) ((!!((w) & (1ULL << 0))) + (!!((w) & (1ULL << 1))) + (!!((w) & (1ULL << 2))) + (!!((w) & (1ULL << 3))) + (!!((w) & (1ULL << 4))) + (!!((w) & (1ULL << 5))) + (!!((w) & (1ULL << 6))) + (!!((w) & (1ULL << 7))))) + ((unsigned int) ((!!(((w) >> 8) & (1ULL << 0))) + (!!(((w) >> 8) & (1ULL << 1))) + (!!(((w) >> 8) & (1ULL << 2))) + (!!(((w) >> 8) & (1ULL << 3))) + (!!(((w) >> 8) & (1ULL << 4))) + (!!(((w) >> 8) & (1ULL << 5))) + (!!(((w) >> 8) & (1ULL << 6))) + (!!(((w) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!(((w) >> 16) & (1ULL << 0))) + (!!(((w) >> 16) & (1ULL << 1))) + (!!(((w) >> 16) & (1ULL << 2))) + (!!(((w) >> 16) & (1ULL << 3))) + (!!(((w) >> 16) & (1ULL << 4))) + (!!(((w) >> 16) & (1ULL << 5))) + (!!(((w) >> 16) & (1ULL << 6))) + (!!(((w) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!((((w) >> 16) >> 8) & (1ULL << 0))) + (!!((((w) >> 16) >> 8) & (1ULL << 1))) + (!!((((w) >> 16) >> 8) & (1ULL << 2))) + (!!((((w) >> 16) >> 8) & (1ULL << 3))) + (!!((((w) >> 16) >> 8) & (1ULL << 4))) + (!!((((w) >> 16) >> 8) & (1ULL << 5))) + (!!((((w) >> 16) >> 8) & (1ULL << 6))) + (!!((((w) >> 16) >> 8) & (1ULL << 7))))))) : __arch_hweight32(w)) : (__builtin_constant_p(w) ? (((((unsigned int) ((!!((w) & (1ULL << 0))) + (!!((w) & (1ULL << 1))) + (!!((w) & (1ULL << 2))) + (!!((w) & (1ULL << 3))) + (!!((w) & (1ULL << 4))) + (!!((w) & (1ULL << 5))) + (!!((w) & (1ULL << 6))) + (!!((w) & (1ULL << 7))))) + ((unsigned int) ((!!(((w) >> 8) & (1ULL << 0))) + (!!(((w) >> 8) & (1ULL << 1))) + (!!(((w) >> 8) & (1ULL << 2))) + (!!(((w) >> 8) & (1ULL << 3))) + (!!(((w) >> 8) & (1ULL << 4))) + (!!(((w) >> 8) & (1ULL << 5))) + (!!(((w) >> 8) & (1ULL << 6))) + (!!(((w) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!(((w) >> 16) & (1ULL << 0))) + (!!(((w) >> 16) & (1ULL << 1))) + (!!(((w) >> 16) & (1ULL << 2))) + (!!(((w) >> 16) & (1ULL << 3))) + (!!(((w) >> 16) & (1ULL << 4))) + (!!(((w) >> 16) & (1ULL << 5))) + (!!(((w) >> 16) & (1ULL << 6))) + (!!(((w) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!((((w) >> 16) >> 8) & (1ULL << 0))) + (!!((((w) >> 16) >> 8) & (1ULL << 1))) + (!!((((w) >> 16) >> 8) & (1ULL << 2))) + (!!((((w) >> 16) >> 8) & (1ULL << 3))) + (!!((((w) >> 16) >> 8) & (1ULL << 4))) + (!!((((w) >> 16) >> 8) & (1ULL << 5))) + (!!((((w) >> 16) >> 8) & (1ULL << 6))) + (!!((((w) >> 16) >> 8) & (1ULL << 7))))))) + ((((unsigned int) ((!!(((w) >> 32) & (1ULL << 0))) + (!!(((w) >> 32) & (1ULL << 1))) + (!!(((w) >> 32) & (1ULL << 2))) + (!!(((w) >> 32) & (1ULL << 3))) + (!!(((w) >> 32) & (1ULL << 4))) + (!!(((w) >> 32) & (1ULL << 5))) + (!!(((w) >> 32) & (1ULL << 6))) + (!!(((w) >> 32) & (1ULL << 7))))) + ((unsigned int) ((!!((((w) >> 32) >> 8) & (1ULL << 0))) + (!!((((w) >> 32) >> 8) & (1ULL << 1))) + (!!((((w) >> 32) >> 8) & (1ULL << 2))) + (!!((((w) >> 32) >> 8) & (1ULL << 3))) + (!!((((w) >> 32) >> 8) & (1ULL << 4))) + (!!((((w) >> 32) >> 8) & (1ULL << 5))) + (!!((((w) >> 32) >> 8) & (1ULL << 6))) + (!!((((w) >> 32) >> 8) & (1ULL << 7)))))) + (((unsigned int) ((!!((((w) >> 32) >> 16) & (1ULL << 0))) + (!!((((w) >> 32) >> 16) & (1ULL << 1))) + (!!((((w) >> 32) >> 16) & (1ULL << 2))) + (!!((((w) >> 32) >> 16) & (1ULL << 3))) + (!!((((w) >> 32) >> 16) & (1ULL << 4))) + (!!((((w) >> 32) >> 16) & (1ULL << 5))) + (!!((((w) >> 32) >> 16) & (1ULL << 6))) + (!!((((w) >> 32) >> 16) & (1ULL << 7))))) + ((unsigned int) ((!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 0))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 1))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 2))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 3))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 4))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 5))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 6))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 7)))))))) : __arch_hweight64(w));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 rol64(__u64 word, unsigned int shift)
{
 return (word << (shift & 63)) | (word >> ((-shift) & 63));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 ror64(__u64 word, unsigned int shift)
{
 return (word >> (shift & 63)) | (word << ((-shift) & 63));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 rol32(__u32 word, unsigned int shift)
{
 return (word << (shift & 31)) | (word >> ((-shift) & 31));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 ror32(__u32 word, unsigned int shift)
{
 return (word >> (shift & 31)) | (word << ((-shift) & 31));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u16 rol16(__u16 word, unsigned int shift)
{
 return (word << (shift & 15)) | (word >> ((-shift) & 15));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u16 ror16(__u16 word, unsigned int shift)
{
 return (word >> (shift & 15)) | (word << ((-shift) & 15));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 rol8(__u8 word, unsigned int shift)
{
 return (word << (shift & 7)) | (word >> ((-shift) & 7));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 ror8(__u8 word, unsigned int shift)
{
 return (word >> (shift & 7)) | (word << ((-shift) & 7));
}
# 165 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __s32 sign_extend32(__u32 value, int index)
{
 __u8 shift = 31 - index;
 return (__s32)(value << shift) >> shift;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __s64 sign_extend64(__u64 value, int index)
{
 __u8 shift = 63 - index;
 return (__s64)(value << shift) >> shift;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned fls_long(unsigned long l)
{
 if (sizeof(l) == 4)
  return fls(l);
 return fls64(l);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_count_order(unsigned int count)
{
 int order;

 order = fls(count) - 1;
 if (count & (count - 1))
  order++;
 return order;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_count_order_long(unsigned long l)
{
 if (l == 0UL)
  return -1;
 else if (l & (l - 1UL))
  return (int)fls_long(l);
 else
  return (int)fls_long(l) - 1;
}
# 223 "/home/nathan/src/linux-next/include/linux/bitops.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __ffs64(u64 word)
{






 return __ffs((unsigned long)word);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void assign_bit(long nr, volatile unsigned long *addr,
           bool value)
{
 if (value)
  set_bit(nr, addr);
 else
  clear_bit(nr, addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __assign_bit(long nr, volatile unsigned long *addr,
      bool value)
{
 if (value)
  __set_bit(nr, addr);
 else
  __clear_bit(nr, addr);
}
# 299 "/home/nathan/src/linux-next/include/linux/bitops.h"
extern unsigned long find_last_bit(const unsigned long *addr,
       unsigned long size);
# 13 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/log2.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __ilog2_u32(u32 n)
{
 return fls(n) - 1;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __ilog2_u64(u64 n)
{
 return fls64(n) - 1;
}
# 44 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
bool is_power_of_2(unsigned long n)
{
 return (n != 0 && ((n & (n - 1)) == 0));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
unsigned long __roundup_pow_of_two(unsigned long n)
{
 return 1UL << fls_long(n - 1);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
unsigned long __rounddown_pow_of_two(unsigned long n)
{
 return 1UL << (fls_long(n) - 1);
}
# 197 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__))
int __order_base_2(unsigned long n)
{
 return n > 1 ? ( __builtin_constant_p(n - 1) ? ( __builtin_constant_p(n - 1) ? ( (n - 1) < 2 ? 0 : (n - 1) & (1ULL << 63) ? 63 : (n - 1) & (1ULL << 62) ? 62 : (n - 1) & (1ULL << 61) ? 61 : (n - 1) & (1ULL << 60) ? 60 : (n - 1) & (1ULL << 59) ? 59 : (n - 1) & (1ULL << 58) ? 58 : (n - 1) & (1ULL << 57) ? 57 : (n - 1) & (1ULL << 56) ? 56 : (n - 1) & (1ULL << 55) ? 55 : (n - 1) & (1ULL << 54) ? 54 : (n - 1) & (1ULL << 53) ? 53 : (n - 1) & (1ULL << 52) ? 52 : (n - 1) & (1ULL << 51) ? 51 : (n - 1) & (1ULL << 50) ? 50 : (n - 1) & (1ULL << 49) ? 49 : (n - 1) & (1ULL << 48) ? 48 : (n - 1) & (1ULL << 47) ? 47 : (n - 1) & (1ULL << 46) ? 46 : (n - 1) & (1ULL << 45) ? 45 : (n - 1) & (1ULL << 44) ? 44 : (n - 1) & (1ULL << 43) ? 43 : (n - 1) & (1ULL << 42) ? 42 : (n - 1) & (1ULL << 41) ? 41 : (n - 1) & (1ULL << 40) ? 40 : (n - 1) & (1ULL << 39) ? 39 : (n - 1) & (1ULL << 38) ? 38 : (n - 1) & (1ULL << 37) ? 37 : (n - 1) & (1ULL << 36) ? 36 : (n - 1) & (1ULL << 35) ? 35 : (n - 1) & (1ULL << 34) ? 34 : (n - 1) & (1ULL << 33) ? 33 : (n - 1) & (1ULL << 32) ? 32 : (n - 1) & (1ULL << 31) ? 31 : (n - 1) & (1ULL << 30) ? 30 : (n - 1) & (1ULL << 29) ? 29 : (n - 1) & (1ULL << 28) ? 28 : (n - 1) & (1ULL << 27) ? 27 : (n - 1) & (1ULL << 26) ? 26 : (n - 1) & (1ULL << 25) ? 25 : (n - 1) & (1ULL << 24) ? 24 : (n - 1) & (1ULL << 23) ? 23 : (n - 1) & (1ULL << 22) ? 22 : (n - 1) & (1ULL << 21) ? 21 : (n - 1) & (1ULL << 20) ? 20 : (n - 1) & (1ULL << 19) ? 19 : (n - 1) & (1ULL << 18) ? 18 : (n - 1) & (1ULL << 17) ? 17 : (n - 1) & (1ULL << 16) ? 16 : (n - 1) & (1ULL << 15) ? 15 : (n - 1) & (1ULL << 14) ? 14 : (n - 1) & (1ULL << 13) ? 13 : (n - 1) & (1ULL << 12) ? 12 : (n - 1) & (1ULL << 11) ? 11 : (n - 1) & (1ULL << 10) ? 10 : (n - 1) & (1ULL << 9) ? 9 : (n - 1) & (1ULL << 8) ? 8 : (n - 1) & (1ULL << 7) ? 7 : (n - 1) & (1ULL << 6) ? 6 : (n - 1) & (1ULL << 5) ? 5 : (n - 1) & (1ULL << 4) ? 4 : (n - 1) & (1ULL << 3) ? 3 : (n - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof(n - 1) <= 4) ? __ilog2_u32(n - 1) : __ilog2_u64(n - 1) ) + 1 : 0;
}
# 224 "/home/nathan/src/linux-next/include/linux/log2.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((const))
int __bits_per(unsigned long n)
{
 if (n < 2)
  return 1;
 if (is_power_of_2(n))
  return ( __builtin_constant_p(n) ? ( ((n) == 0 || (n) == 1) ? 0 : ( __builtin_constant_p((n) - 1) ? ( __builtin_constant_p((n) - 1) ? ( ((n) - 1) < 2 ? 0 : ((n) - 1) & (1ULL << 63) ? 63 : ((n) - 1) & (1ULL << 62) ? 62 : ((n) - 1) & (1ULL << 61) ? 61 : ((n) - 1) & (1ULL << 60) ? 60 : ((n) - 1) & (1ULL << 59) ? 59 : ((n) - 1) & (1ULL << 58) ? 58 : ((n) - 1) & (1ULL << 57) ? 57 : ((n) - 1) & (1ULL << 56) ? 56 : ((n) - 1) & (1ULL << 55) ? 55 : ((n) - 1) & (1ULL << 54) ? 54 : ((n) - 1) & (1ULL << 53) ? 53 : ((n) - 1) & (1ULL << 52) ? 52 : ((n) - 1) & (1ULL << 51) ? 51 : ((n) - 1) & (1ULL << 50) ? 50 : ((n) - 1) & (1ULL << 49) ? 49 : ((n) - 1) & (1ULL << 48) ? 48 : ((n) - 1) & (1ULL << 47) ? 47 : ((n) - 1) & (1ULL << 46) ? 46 : ((n) - 1) & (1ULL << 45) ? 45 : ((n) - 1) & (1ULL << 44) ? 44 : ((n) - 1) & (1ULL << 43) ? 43 : ((n) - 1) & (1ULL << 42) ? 42 : ((n) - 1) & (1ULL << 41) ? 41 : ((n) - 1) & (1ULL << 40) ? 40 : ((n) - 1) & (1ULL << 39) ? 39 : ((n) - 1) & (1ULL << 38) ? 38 : ((n) - 1) & (1ULL << 37) ? 37 : ((n) - 1) & (1ULL << 36) ? 36 : ((n) - 1) & (1ULL << 35) ? 35 : ((n) - 1) & (1ULL << 34) ? 34 : ((n) - 1) & (1ULL << 33) ? 33 : ((n) - 1) & (1ULL << 32) ? 32 : ((n) - 1) & (1ULL << 31) ? 31 : ((n) - 1) & (1ULL << 30) ? 30 : ((n) - 1) & (1ULL << 29) ? 29 : ((n) - 1) & (1ULL << 28) ? 28 : ((n) - 1) & (1ULL << 27) ? 27 : ((n) - 1) & (1ULL << 26) ? 26 : ((n) - 1) & (1ULL << 25) ? 25 : ((n) - 1) & (1ULL << 24) ? 24 : ((n) - 1) & (1ULL << 23) ? 23 : ((n) - 1) & (1ULL << 22) ? 22 : ((n) - 1) & (1ULL << 21) ? 21 : ((n) - 1) & (1ULL << 20) ? 20 : ((n) - 1) & (1ULL << 19) ? 19 : ((n) - 1) & (1ULL << 18) ? 18 : ((n) - 1) & (1ULL << 17) ? 17 : ((n) - 1) & (1ULL << 16) ? 16 : ((n) - 1) & (1ULL << 15) ? 15 : ((n) - 1) & (1ULL << 14) ? 14 : ((n) - 1) & (1ULL << 13) ? 13 : ((n) - 1) & (1ULL << 12) ? 12 : ((n) - 1) & (1ULL << 11) ? 11 : ((n) - 1) & (1ULL << 10) ? 10 : ((n) - 1) & (1ULL << 9) ? 9 : ((n) - 1) & (1ULL << 8) ? 8 : ((n) - 1) & (1ULL << 7) ? 7 : ((n) - 1) & (1ULL << 6) ? 6 : ((n) - 1) & (1ULL << 5) ? 5 : ((n) - 1) & (1ULL << 4) ? 4 : ((n) - 1) & (1ULL << 3) ? 3 : ((n) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((n) - 1) <= 4) ? __ilog2_u32((n) - 1) : __ilog2_u64((n) - 1) ) + 1) : __order_base_2(n) ) + 1;
 return ( __builtin_constant_p(n) ? ( ((n) == 0 || (n) == 1) ? 0 : ( __builtin_constant_p((n) - 1) ? ( __builtin_constant_p((n) - 1) ? ( ((n) - 1) < 2 ? 0 : ((n) - 1) & (1ULL << 63) ? 63 : ((n) - 1) & (1ULL << 62) ? 62 : ((n) - 1) & (1ULL << 61) ? 61 : ((n) - 1) & (1ULL << 60) ? 60 : ((n) - 1) & (1ULL << 59) ? 59 : ((n) - 1) & (1ULL << 58) ? 58 : ((n) - 1) & (1ULL << 57) ? 57 : ((n) - 1) & (1ULL << 56) ? 56 : ((n) - 1) & (1ULL << 55) ? 55 : ((n) - 1) & (1ULL << 54) ? 54 : ((n) - 1) & (1ULL << 53) ? 53 : ((n) - 1) & (1ULL << 52) ? 52 : ((n) - 1) & (1ULL << 51) ? 51 : ((n) - 1) & (1ULL << 50) ? 50 : ((n) - 1) & (1ULL << 49) ? 49 : ((n) - 1) & (1ULL << 48) ? 48 : ((n) - 1) & (1ULL << 47) ? 47 : ((n) - 1) & (1ULL << 46) ? 46 : ((n) - 1) & (1ULL << 45) ? 45 : ((n) - 1) & (1ULL << 44) ? 44 : ((n) - 1) & (1ULL << 43) ? 43 : ((n) - 1) & (1ULL << 42) ? 42 : ((n) - 1) & (1ULL << 41) ? 41 : ((n) - 1) & (1ULL << 40) ? 40 : ((n) - 1) & (1ULL << 39) ? 39 : ((n) - 1) & (1ULL << 38) ? 38 : ((n) - 1) & (1ULL << 37) ? 37 : ((n) - 1) & (1ULL << 36) ? 36 : ((n) - 1) & (1ULL << 35) ? 35 : ((n) - 1) & (1ULL << 34) ? 34 : ((n) - 1) & (1ULL << 33) ? 33 : ((n) - 1) & (1ULL << 32) ? 32 : ((n) - 1) & (1ULL << 31) ? 31 : ((n) - 1) & (1ULL << 30) ? 30 : ((n) - 1) & (1ULL << 29) ? 29 : ((n) - 1) & (1ULL << 28) ? 28 : ((n) - 1) & (1ULL << 27) ? 27 : ((n) - 1) & (1ULL << 26) ? 26 : ((n) - 1) & (1ULL << 25) ? 25 : ((n) - 1) & (1ULL << 24) ? 24 : ((n) - 1) & (1ULL << 23) ? 23 : ((n) - 1) & (1ULL << 22) ? 22 : ((n) - 1) & (1ULL << 21) ? 21 : ((n) - 1) & (1ULL << 20) ? 20 : ((n) - 1) & (1ULL << 19) ? 19 : ((n) - 1) & (1ULL << 18) ? 18 : ((n) - 1) & (1ULL << 17) ? 17 : ((n) - 1) & (1ULL << 16) ? 16 : ((n) - 1) & (1ULL << 15) ? 15 : ((n) - 1) & (1ULL << 14) ? 14 : ((n) - 1) & (1ULL << 13) ? 13 : ((n) - 1) & (1ULL << 12) ? 12 : ((n) - 1) & (1ULL << 11) ? 11 : ((n) - 1) & (1ULL << 10) ? 10 : ((n) - 1) & (1ULL << 9) ? 9 : ((n) - 1) & (1ULL << 8) ? 8 : ((n) - 1) & (1ULL << 7) ? 7 : ((n) - 1) & (1ULL << 6) ? 6 : ((n) - 1) & (1ULL << 5) ? 5 : ((n) - 1) & (1ULL << 4) ? 4 : ((n) - 1) & (1ULL << 3) ? 3 : ((n) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((n) - 1) <= 4) ? __ilog2_u32((n) - 1) : __ilog2_u64((n) - 1) ) + 1) : __order_base_2(n) );
}
# 14 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/typecheck.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/printk.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/init.h" 1
# 116 "/home/nathan/src/linux-next/include/linux/init.h"
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
# 127 "/home/nathan/src/linux-next/include/linux/init.h"
typedef initcall_t initcall_entry_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) initcall_t initcall_from_entry(initcall_entry_t *entry)
{
 return *entry;
}


extern initcall_entry_t __con_initcall_start[], __con_initcall_end[];


typedef void (*ctor_fn_t)(void);

struct file_system_type;


extern int do_one_initcall(initcall_t fn);
extern char __attribute__((__section__(".init.data"))) boot_command_line[];
extern char *saved_command_line;
extern unsigned int reset_devices;


void setup_arch(char **);
void prepare_namespace(void);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) init_rootfs(void);
extern struct file_system_type rootfs_fs_type;
# 161 "/home/nathan/src/linux-next/include/linux/init.h"
extern void (*late_time_init)(void);

extern bool initcall_debug;
# 7 "/home/nathan/src/linux-next/include/linux/printk.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kern_levels.h" 1
# 8 "/home/nathan/src/linux-next/include/linux/printk.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/cache.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kernel.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/sysinfo.h" 1







struct sysinfo {
 __kernel_long_t uptime;
 __kernel_ulong_t loads[3];
 __kernel_ulong_t totalram;
 __kernel_ulong_t freeram;
 __kernel_ulong_t sharedram;
 __kernel_ulong_t bufferram;
 __kernel_ulong_t totalswap;
 __kernel_ulong_t freeswap;
 __u16 procs;
 __u16 pad;
 __kernel_ulong_t totalhigh;
 __kernel_ulong_t freehigh;
 __u32 mem_unit;
 char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];
};
# 6 "/home/nathan/src/linux-next/include/uapi/linux/kernel.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/cache.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h" 1
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h"
struct ppc_cache_info {
 u32 size;
 u32 line_size;
 u32 block_size;
 u32 log_block_size;
 u32 blocks_per_page;
 u32 sets;
 u32 assoc;
};

struct ppc64_caches {
 struct ppc_cache_info l1d;
 struct ppc_cache_info l1i;
 struct ppc_cache_info l2;
 struct ppc_cache_info l3;
};

extern struct ppc64_caches ppc64_caches;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_dcache_shift(void)
{
 return ppc64_caches.l1d.log_block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_dcache_bytes(void)
{
 return ppc64_caches.l1d.block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_icache_shift(void)
{
 return ppc64_caches.l1i.log_block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l1_icache_bytes(void)
{
 return ppc64_caches.l1i.block_size;
}
# 114 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbz(void *addr)
{
 __asm__ __volatile__ ("dcbz 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbi(void *addr)
{
 __asm__ __volatile__ ("dcbi 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbf(void *addr)
{
 __asm__ __volatile__ ("dcbf 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dcbst(void *addr)
{
 __asm__ __volatile__ ("dcbst 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void icbi(void *addr)
{
 asm volatile ("icbi 0, %0" : : "r"(addr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iccci(void *addr)
{
 asm volatile ("iccci 0, %0" : : "r"(addr) : "memory");
}
# 7 "/home/nathan/src/linux-next/include/linux/cache.h" 2
# 10 "/home/nathan/src/linux-next/include/linux/printk.h" 2

extern const char linux_banner[];
extern const char linux_proc_banner[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int printk_get_level(const char *buffer)
{
 if (buffer[0] == '\001' && buffer[1]) {
  switch (buffer[1]) {
  case '0' ... '7':
  case 'c':
   return buffer[1];
  }
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *printk_skip_level(const char *buffer)
{
 if (printk_get_level(buffer))
  return buffer + 2;

 return buffer;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *printk_skip_headers(const char *buffer)
{
 while (printk_get_level(buffer))
  buffer = printk_skip_level(buffer);

 return buffer;
}
# 62 "/home/nathan/src/linux-next/include/linux/printk.h"
extern int console_printk[];






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void console_silent(void)
{
 (console_printk[0]) = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void console_verbose(void)
{
 if ((console_printk[0]))
  (console_printk[0]) = 15;
}



extern char devkmsg_log_str[];
struct ctl_table;

extern int suppress_printk;

struct va_format {
 const char *fmt;
 va_list *va;
};
# 142 "/home/nathan/src/linux-next/include/linux/printk.h"
extern __attribute__((__format__(printf, 1, 2)))
void early_printk(const char *fmt, ...);






extern void printk_nmi_enter(void);
extern void printk_nmi_exit(void);
extern void printk_nmi_direct_enter(void);
extern void printk_nmi_direct_exit(void);
# 162 "/home/nathan/src/linux-next/include/linux/printk.h"
           __attribute__((__format__(printf, 5, 0)))
int vprintk_emit(int facility, int level,
   const char *dict, size_t dictlen,
   const char *fmt, va_list args);

           __attribute__((__format__(printf, 1, 0)))
int vprintk(const char *fmt, va_list args);

           __attribute__((__format__(printf, 1, 2))) __attribute__((__cold__))
int printk(const char *fmt, ...);




__attribute__((__format__(printf, 1, 2))) __attribute__((__cold__)) int printk_deferred(const char *fmt, ...);






extern int __printk_ratelimit(const char *func);

extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
       unsigned int interval_msec);

extern int printk_delay_msec;
extern int dmesg_restrict;

extern int
devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void *buf,
     size_t *lenp, loff_t *ppos);

extern void wake_up_klogd(void);

char *log_buf_addr_get(void);
u32 log_buf_len_get(void);
void log_buf_vmcoreinfo_setup(void);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) setup_log_buf(int early);
__attribute__((__format__(printf, 1, 2))) void dump_stack_set_arch_desc(const char *fmt, ...);
void dump_stack_print_info(const char *log_lvl);
void show_regs_print_info(const char *log_lvl);
extern void dump_stack(void) __attribute__((__cold__));
extern void printk_safe_init(void);
extern void printk_safe_flush(void);
extern void printk_safe_flush_on_panic(void);
# 285 "/home/nathan/src/linux-next/include/linux/printk.h"
extern int kptr_restrict;
# 476 "/home/nathan/src/linux-next/include/linux/printk.h"
extern const struct file_operations kmsg_fops;

enum {
 DUMP_PREFIX_NONE,
 DUMP_PREFIX_ADDRESS,
 DUMP_PREFIX_OFFSET
};
extern int hex_dump_to_buffer(const void *buf, size_t len, int rowsize,
         int groupsize, char *linebuf, size_t linebuflen,
         bool ascii);

extern void print_hex_dump(const char *level, const char *prefix_str,
      int prefix_type, int rowsize, int groupsize,
      const void *buf, size_t len, bool ascii);
# 514 "/home/nathan/src/linux-next/include/linux/printk.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void print_hex_dump_debug(const char *prefix_str, int prefix_type,
     int rowsize, int groupsize,
     const void *buf, size_t len, bool ascii)
{
}
# 16 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/build_bug.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/kernel.h" 2

# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/div64.h" 1
# 2 "./arch/powerpc/include/generated/asm/div64.h" 2
# 19 "/home/nathan/src/linux-next/include/linux/kernel.h" 2

# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/kernel.h" 2
# 191 "/home/nathan/src/linux-next/include/linux/kernel.h"
struct completion;
struct pt_regs;
struct user;
# 247 "/home/nathan/src/linux-next/include/linux/kernel.h"
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ___might_sleep(const char *file, int line,
       int preempt_offset) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __might_sleep(const char *file, int line,
       int preempt_offset) { }
# 297 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 reciprocal_scale(u32 val, u32 ep_ro)
{
 return (u32)(((u64) val * ep_ro) >> 32);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void might_fault(void) { }


extern struct atomic_notifier_head panic_notifier_list;
extern long (*panic_blink)(int state);
__attribute__((__format__(printf, 1, 2)))
void panic(const char *fmt, ...) __attribute__((__noreturn__)) __attribute__((__cold__));
void nmi_panic(struct pt_regs *regs, const char *msg);
extern void oops_enter(void);
extern void oops_exit(void);
void print_oops_end_marker(void);
extern int oops_may_print(void);
void do_exit(long error_code) __attribute__((__noreturn__));
void complete_and_exit(struct completion *, long) __attribute__((__noreturn__));


int __attribute__((__warn_unused_result__)) _kstrtoul(const char *s, unsigned int base, unsigned long *res);
int __attribute__((__warn_unused_result__)) _kstrtol(const char *s, unsigned int base, long *res);

int __attribute__((__warn_unused_result__)) kstrtoull(const char *s, unsigned int base, unsigned long long *res);
int __attribute__((__warn_unused_result__)) kstrtoll(const char *s, unsigned int base, long long *res);
# 344 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtoul(const char *s, unsigned int base, unsigned long *res)
{




 if (sizeof(unsigned long) == sizeof(unsigned long long) &&
     __alignof__(unsigned long) == __alignof__(unsigned long long))
  return kstrtoull(s, base, (unsigned long long *)res);
 else
  return _kstrtoul(s, base, res);
}
# 372 "/home/nathan/src/linux-next/include/linux/kernel.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtol(const char *s, unsigned int base, long *res)
{




 if (sizeof(long) == sizeof(long long) &&
     __alignof__(long) == __alignof__(long long))
  return kstrtoll(s, base, (long long *)res);
 else
  return _kstrtol(s, base, res);
}

int __attribute__((__warn_unused_result__)) kstrtouint(const char *s, unsigned int base, unsigned int *res);
int __attribute__((__warn_unused_result__)) kstrtoint(const char *s, unsigned int base, int *res);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou64(const char *s, unsigned int base, u64 *res)
{
 return kstrtoull(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos64(const char *s, unsigned int base, s64 *res)
{
 return kstrtoll(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou32(const char *s, unsigned int base, u32 *res)
{
 return kstrtouint(s, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos32(const char *s, unsigned int base, s32 *res)
{
 return kstrtoint(s, base, res);
}

int __attribute__((__warn_unused_result__)) kstrtou16(const char *s, unsigned int base, u16 *res);
int __attribute__((__warn_unused_result__)) kstrtos16(const char *s, unsigned int base, s16 *res);
int __attribute__((__warn_unused_result__)) kstrtou8(const char *s, unsigned int base, u8 *res);
int __attribute__((__warn_unused_result__)) kstrtos8(const char *s, unsigned int base, s8 *res);
int __attribute__((__warn_unused_result__)) kstrtobool(const char *s, bool *res);

int __attribute__((__warn_unused_result__)) kstrtoull_from_user(const char *s, size_t count, unsigned int base, unsigned long long *res);
int __attribute__((__warn_unused_result__)) kstrtoll_from_user(const char *s, size_t count, unsigned int base, long long *res);
int __attribute__((__warn_unused_result__)) kstrtoul_from_user(const char *s, size_t count, unsigned int base, unsigned long *res);
int __attribute__((__warn_unused_result__)) kstrtol_from_user(const char *s, size_t count, unsigned int base, long *res);
int __attribute__((__warn_unused_result__)) kstrtouint_from_user(const char *s, size_t count, unsigned int base, unsigned int *res);
int __attribute__((__warn_unused_result__)) kstrtoint_from_user(const char *s, size_t count, unsigned int base, int *res);
int __attribute__((__warn_unused_result__)) kstrtou16_from_user(const char *s, size_t count, unsigned int base, u16 *res);
int __attribute__((__warn_unused_result__)) kstrtos16_from_user(const char *s, size_t count, unsigned int base, s16 *res);
int __attribute__((__warn_unused_result__)) kstrtou8_from_user(const char *s, size_t count, unsigned int base, u8 *res);
int __attribute__((__warn_unused_result__)) kstrtos8_from_user(const char *s, size_t count, unsigned int base, s8 *res);
int __attribute__((__warn_unused_result__)) kstrtobool_from_user(const char *s, size_t count, bool *res);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou64_from_user(const char *s, size_t count, unsigned int base, u64 *res)
{
 return kstrtoull_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos64_from_user(const char *s, size_t count, unsigned int base, s64 *res)
{
 return kstrtoll_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtou32_from_user(const char *s, size_t count, unsigned int base, u32 *res)
{
 return kstrtouint_from_user(s, count, base, res);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kstrtos32_from_user(const char *s, size_t count, unsigned int base, s32 *res)
{
 return kstrtoint_from_user(s, count, base, res);
}
# 459 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern unsigned long simple_strtoul(const char *,char **,unsigned int);
extern long simple_strtol(const char *,char **,unsigned int);
extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
extern long long simple_strtoll(const char *,char **,unsigned int);

extern int num_to_str(char *buf, int size,
        unsigned long long num, unsigned int width);



extern __attribute__((__format__(printf, 2, 3))) int sprintf(char *buf, const char * fmt, ...);
extern __attribute__((__format__(printf, 2, 0))) int vsprintf(char *buf, const char *, va_list);
extern __attribute__((__format__(printf, 3, 4)))
int snprintf(char *buf, size_t size, const char *fmt, ...);
extern __attribute__((__format__(printf, 3, 0)))
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 3, 4)))
int scnprintf(char *buf, size_t size, const char *fmt, ...);
extern __attribute__((__format__(printf, 3, 0)))
int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 2, 3))) __attribute__((__malloc__))
char *kasprintf(gfp_t gfp, const char *fmt, ...);
extern __attribute__((__format__(printf, 2, 0))) __attribute__((__malloc__))
char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);
extern __attribute__((__format__(printf, 2, 0)))
const char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);

extern __attribute__((__format__(scanf, 2, 3)))
int sscanf(const char *, const char *, ...);
extern __attribute__((__format__(scanf, 2, 0)))
int vsscanf(const char *, const char *, va_list);

extern int get_option(char **str, int *pint);
extern char *get_options(const char *str, int nints, int *ints);
extern unsigned long long memparse(const char *ptr, char **retptr);
extern bool parse_option_str(const char *str, const char *option);
extern char *next_arg(char *args, char **param, char **val);

extern int core_kernel_text(unsigned long addr);
extern int init_kernel_text(unsigned long addr);
extern int core_kernel_data(unsigned long addr);
extern int __kernel_text_address(unsigned long addr);
extern int kernel_text_address(unsigned long addr);
extern int func_ptr_is_kernel_text(void *ptr);

u64 int_pow(u64 base, unsigned int exp);
unsigned long int_sqrt(unsigned long);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 int_sqrt64(u64 x)
{
 return (u32)int_sqrt(x);
}


extern void bust_spinlocks(int yes);
extern int oops_in_progress;
extern int panic_timeout;
extern unsigned long panic_print;
extern int panic_on_oops;
extern int panic_on_unrecovered_nmi;
extern int panic_on_io_nmi;
extern int panic_on_warn;
extern int sysctl_panic_on_rcu_stall;
extern int sysctl_panic_on_stackoverflow;

extern bool crash_kexec_post_notifiers;






extern atomic_t panic_cpu;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_arch_panic_timeout(int timeout, int arch_default_timeout)
{
 if (panic_timeout == arch_default_timeout)
  panic_timeout = timeout;
}
extern const char *print_tainted(void);
enum lockdep_ok {
 LOCKDEP_STILL_OK,
 LOCKDEP_NOW_UNRELIABLE
};
extern void add_taint(unsigned flag, enum lockdep_ok);
extern int test_taint(unsigned flag);
extern unsigned long get_taint(void);
extern int root_mountflags;

extern bool early_boot_irqs_disabled;





extern enum system_states {
 SYSTEM_BOOTING,
 SYSTEM_SCHEDULING,
 SYSTEM_RUNNING,
 SYSTEM_HALT,
 SYSTEM_POWER_OFF,
 SYSTEM_RESTART,
 SYSTEM_SUSPEND,
} system_state;
# 593 "/home/nathan/src/linux-next/include/linux/kernel.h"
struct taint_flag {
 char c_true;
 char c_false;
 bool module;
};

extern const struct taint_flag taint_flags[18];

extern const char hex_asc[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *hex_byte_pack(char *buf, u8 byte)
{
 *buf++ = hex_asc[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc[((byte) & 0x0f)];
 return buf;
}

extern const char hex_asc_upper[];



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *hex_byte_pack_upper(char *buf, u8 byte)
{
 *buf++ = hex_asc_upper[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc_upper[((byte) & 0x0f)];
 return buf;
}

extern int hex_to_bin(char ch);
extern int __attribute__((__warn_unused_result__)) hex2bin(u8 *dst, const char *src, size_t count);
extern char *bin2hex(char *dst, const void *src, size_t count);

bool mac_pton(const char *s, u8 *mac);
# 649 "/home/nathan/src/linux-next/include/linux/kernel.h"
enum ftrace_dump_mode {
 DUMP_NONE,
 DUMP_ALL,
 DUMP_ORIG,
};


void tracing_on(void);
void tracing_off(void);
int tracing_is_on(void);
void tracing_snapshot(void);
void tracing_snapshot_alloc(void);

extern void tracing_start(void);
extern void tracing_stop(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__format__(printf, 1, 2)))
void ____trace_printk_check_format(const char *fmt, ...)
{
}
# 728 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern __attribute__((__format__(printf, 2, 3)))
int __trace_bprintk(unsigned long ip, const char *fmt, ...);

extern __attribute__((__format__(printf, 2, 3)))
int __trace_printk(unsigned long ip, const char *fmt, ...);
# 769 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern int __trace_bputs(unsigned long ip, const char *str);
extern int __trace_puts(unsigned long ip, const char *str, int size);

extern void trace_dump_stack(int skip);
# 791 "/home/nathan/src/linux-next/include/linux/kernel.h"
extern __attribute__((__format__(printf, 2, 0))) int
__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);

extern __attribute__((__format__(printf, 2, 0))) int
__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);

extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);
# 10 "/home/nathan/src/linux-next/include/linux/list.h" 2
# 33 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_LIST_HEAD(struct list_head *list)
{
 ({ union { typeof(list->next) __val; char __c[1]; } __u = { .__val = ( typeof(list->next)) (list) }; __write_once_size(&(list->next), __u.__c, sizeof(list->next)); __u.__val; });
 list->prev = list;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __list_add_valid(struct list_head *new,
    struct list_head *prev,
    struct list_head *next)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __list_del_entry_valid(struct list_head *entry)
{
 return true;
}
# 63 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_add(struct list_head *new,
         struct list_head *prev,
         struct list_head *next)
{
 if (!__list_add_valid(new, prev, next))
  return;

 next->prev = new;
 new->next = next;
 new->prev = prev;
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (new) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });
}
# 84 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add(struct list_head *new, struct list_head *head)
{
 __list_add(new, head, head->next);
}
# 98 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_tail(struct list_head *new, struct list_head *head)
{
 __list_add(new, head->prev, head);
}
# 110 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del(struct list_head * prev, struct list_head * next)
{
 next->prev = prev;
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (next) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });
}
# 124 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del_clearprev(struct list_head *entry)
{
 __list_del(entry->prev, entry->next);
 entry->prev = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_del_entry(struct list_head *entry)
{
 if (!__list_del_entry_valid(entry))
  return;

 __list_del(entry->prev, entry->next);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del(struct list_head *entry)
{
 __list_del_entry(entry);
 entry->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 entry->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 158 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace(struct list_head *old,
    struct list_head *new)
{
 new->next = old->next;
 new->next->prev = new;
 new->prev = old->prev;
 new->prev->next = new;
}
# 174 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace_init(struct list_head *old,
         struct list_head *new)
{
 list_replace(old, new);
 INIT_LIST_HEAD(old);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_swap(struct list_head *entry1,
        struct list_head *entry2)
{
 struct list_head *pos = entry2->prev;

 list_del(entry2);
 list_replace(entry1, entry2);
 if (pos == entry1)
  pos = entry2;
 list_add(entry1, pos);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del_init(struct list_head *entry)
{
 __list_del_entry(entry);
 INIT_LIST_HEAD(entry);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_move(struct list_head *list, struct list_head *head)
{
 __list_del_entry(list);
 list_add(list, head);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_move_tail(struct list_head *list,
      struct list_head *head)
{
 __list_del_entry(list);
 list_add_tail(list, head);
}
# 240 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_bulk_move_tail(struct list_head *head,
           struct list_head *first,
           struct list_head *last)
{
 first->prev->next = last->next;
 last->next->prev = first->prev;

 head->prev->next = first;
 first->prev = head->prev;

 last->next = head;
 head->prev = last;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_first(const struct list_head *list,
     const struct list_head *head)
{
 return list->prev == head;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_last(const struct list_head *list,
    const struct list_head *head)
{
 return list->next == head;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_empty(const struct list_head *head)
{
 return ({ union { typeof(head->next) __val; char __c[1]; } __u; if (1) __read_once_size(&(head->next), __u.__c, sizeof(head->next)); else __read_once_size_nocheck(&(head->next), __u.__c, sizeof(head->next)); do { } while (0); __u.__val; }) == head;
}
# 298 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_empty_careful(const struct list_head *head)
{
 struct list_head *next = head->next;
 return (next == head) && (next == head->prev);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_rotate_left(struct list_head *head)
{
 struct list_head *first;

 if (!list_empty(head)) {
  first = head->next;
  list_move_tail(first, head);
 }
}
# 325 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_rotate_to_front(struct list_head *list,
     struct list_head *head)
{





 list_move_tail(head, list);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int list_is_singular(const struct list_head *head)
{
 return !list_empty(head) && (head->next == head->prev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 struct list_head *new_first = entry->next;
 list->next = head->next;
 list->next->prev = list;
 list->prev = entry;
 entry->next = list;
 head->next = new_first;
 new_first->prev = head;
}
# 371 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 if (list_empty(head))
  return;
 if (list_is_singular(head) &&
  (head->next != entry && head != entry))
  return;
 if (entry == head)
  INIT_LIST_HEAD(list);
 else
  __list_cut_position(list, head, entry);
}
# 399 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_cut_before(struct list_head *list,
       struct list_head *head,
       struct list_head *entry)
{
 if (head->next == entry) {
  INIT_LIST_HEAD(list);
  return;
 }
 list->next = head->next;
 list->next->prev = list;
 list->prev = entry->prev;
 list->prev->next = list;
 head->next = entry;
 entry->prev = head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_splice(const struct list_head *list,
     struct list_head *prev,
     struct list_head *next)
{
 struct list_head *first = list->next;
 struct list_head *last = list->prev;

 first->prev = prev;
 prev->next = first;

 last->next = next;
 next->prev = last;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice(const struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, head, head->next);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail(struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, head->prev, head);
}
# 460 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_init(struct list_head *list,
        struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, head, head->next);
  INIT_LIST_HEAD(list);
 }
}
# 477 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail_init(struct list_head *list,
      struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, head->prev, head);
  INIT_LIST_HEAD(list);
 }
}
# 765 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_HLIST_NODE(struct hlist_node *h)
{
 h->next = ((void *)0);
 h->pprev = ((void *)0);
}
# 779 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_unhashed(const struct hlist_node *h)
{
 return !h->pprev;
}
# 792 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_unhashed_lockless(const struct hlist_node *h)
{
 return !({ union { typeof(h->pprev) __val; char __c[1]; } __u; if (1) __read_once_size(&(h->pprev), __u.__c, sizeof(h->pprev)); else __read_once_size_nocheck(&(h->pprev), __u.__c, sizeof(h->pprev)); do { } while (0); __u.__val; });
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_empty(const struct hlist_head *h)
{
 return !({ union { typeof(h->first) __val; char __c[1]; } __u; if (1) __read_once_size(&(h->first), __u.__c, sizeof(h->first)); else __read_once_size_nocheck(&(h->first), __u.__c, sizeof(h->first)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hlist_del(struct hlist_node *n)
{
 struct hlist_node *next = n->next;
 struct hlist_node **pprev = n->pprev;

 ({ union { typeof(*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*pprev)) (next) }; __write_once_size(&(*pprev), __u.__c, sizeof(*pprev)); __u.__val; });
 if (next)
  ({ union { typeof(next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(next->pprev)) (pprev) }; __write_once_size(&(next->pprev), __u.__c, sizeof(next->pprev)); __u.__val; });
}
# 823 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del(struct hlist_node *n)
{
 __hlist_del(n);
 n->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_init(struct hlist_node *n)
{
 if (!hlist_unhashed(n)) {
  __hlist_del(n);
  INIT_HLIST_NODE(n);
 }
}
# 852 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
 struct hlist_node *first = h->first;
 ({ union { typeof(n->next) __val; char __c[1]; } __u = { .__val = ( typeof(n->next)) (first) }; __write_once_size(&(n->next), __u.__c, sizeof(n->next)); __u.__val; });
 if (first)
  ({ union { typeof(first->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(first->pprev)) (&n->next) }; __write_once_size(&(first->pprev), __u.__c, sizeof(first->pprev)); __u.__val; });
 ({ union { typeof(h->first) __val; char __c[1]; } __u = { .__val = ( typeof(h->first)) (n) }; __write_once_size(&(h->first), __u.__c, sizeof(h->first)); __u.__val; });
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&h->first) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_before(struct hlist_node *n,
        struct hlist_node *next)
{
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (next->pprev) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 ({ union { typeof(n->next) __val; char __c[1]; } __u = { .__val = ( typeof(n->next)) (next) }; __write_once_size(&(n->next), __u.__c, sizeof(n->next)); __u.__val; });
 ({ union { typeof(next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(next->pprev)) (&n->next) }; __write_once_size(&(next->pprev), __u.__c, sizeof(next->pprev)); __u.__val; });
 ({ union { typeof(*(n->pprev)) __val; char __c[1]; } __u = { .__val = ( typeof(*(n->pprev))) (n) }; __write_once_size(&(*(n->pprev)), __u.__c, sizeof(*(n->pprev))); __u.__val; });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_behind(struct hlist_node *n,
        struct hlist_node *prev)
{
 ({ union { typeof(n->next) __val; char __c[1]; } __u = { .__val = ( typeof(n->next)) (prev->next) }; __write_once_size(&(n->next), __u.__c, sizeof(n->next)); __u.__val; });
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (n) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&prev->next) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });

 if (n->next)
  ({ union { typeof(n->next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->next->pprev)) (&n->next) }; __write_once_size(&(n->next->pprev), __u.__c, sizeof(n->next->pprev)); __u.__val; });
}
# 900 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_fake(struct hlist_node *n)
{
 n->pprev = &n->next;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_fake(struct hlist_node *h)
{
 return h->pprev == &h->next;
}
# 922 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
hlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)
{
 return !n->next && n->pprev == &h->first;
}
# 936 "/home/nathan/src/linux-next/include/linux/list.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_move_list(struct hlist_head *old,
       struct hlist_head *new)
{
 new->first = old->first;
 if (new->first)
  new->first->pprev = &new->first;
 old->first = ((void *)0);
}
# 13 "/home/nathan/src/linux-next/include/linux/module.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/stat.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/stat.h" 1
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/stat.h"
struct stat {
 unsigned long st_dev;
 ino_t st_ino;

 unsigned long st_nlink;
 mode_t st_mode;




 uid_t st_uid;
 gid_t st_gid;
 unsigned long st_rdev;
 long st_size;
 unsigned long st_blksize;
 unsigned long st_blocks;
 unsigned long st_atime;
 unsigned long st_atime_nsec;
 unsigned long st_mtime;
 unsigned long st_mtime_nsec;
 unsigned long st_ctime;
 unsigned long st_ctime_nsec;
 unsigned long __unused4;
 unsigned long __unused5;

 unsigned long __unused6;

};


struct stat64 {
 unsigned long long st_dev;
 unsigned long long st_ino;
 unsigned int st_mode;
 unsigned int st_nlink;
 unsigned int st_uid;
 unsigned int st_gid;
 unsigned long long st_rdev;
 unsigned short __pad2;
 long long st_size;
 int st_blksize;
 long long st_blocks;
 int st_atime;
 unsigned int st_atime_nsec;
 int st_mtime;
 unsigned int st_mtime_nsec;
 int st_ctime;
 unsigned int st_ctime_nsec;
 unsigned int __unused4;
 unsigned int __unused5;
};
# 7 "/home/nathan/src/linux-next/include/linux/stat.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/stat.h" 1
# 56 "/home/nathan/src/linux-next/include/uapi/linux/stat.h"
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/home/nathan/src/linux-next/include/uapi/linux/stat.h"
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 8 "/home/nathan/src/linux-next/include/linux/stat.h" 2
# 19 "/home/nathan/src/linux-next/include/linux/stat.h"
# 1 "/home/nathan/src/linux-next/include/linux/time.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/seqlock.h" 1
# 36 "/home/nathan/src/linux-next/include/linux/seqlock.h"
# 1 "/home/nathan/src/linux-next/include/linux/spinlock.h" 1
# 51 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/include/linux/preempt.h" 1
# 78 "/home/nathan/src/linux-next/include/linux/preempt.h"
# 1 "./arch/powerpc/include/generated/asm/preempt.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/preempt.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/thread_info.h"
# 1 "/home/nathan/src/linux-next/include/linux/bug.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h" 1
# 109 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/bug.h" 1
# 24 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
struct bug_entry {

 unsigned long bug_addr;





 const char *file;



 unsigned short line;

 unsigned short flags;
};
# 89 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
extern __attribute__((__format__(printf, 1, 2))) void __warn_printk(const char *fmt, ...);
# 105 "/home/nathan/src/linux-next/include/asm-generic/bug.h"
struct warn_args;
struct pt_regs;

void __warn(const char *file, int line, void *caller, unsigned taint,
     struct pt_regs *regs, struct warn_args *args);
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/asm/bug.h" 2



struct pt_regs;
extern int do_page_fault(struct pt_regs *, unsigned long, unsigned long);
extern void bad_page_fault(struct pt_regs *, unsigned long, int);
extern void _exception(int, struct pt_regs *, int, unsigned long);
extern void _exception_pkey(struct pt_regs *, unsigned long, int);
extern void die(const char *, struct pt_regs *, long);
extern bool die_will_crash(void);
extern void panic_flush_kmsg_start(void);
extern void panic_flush_kmsg_end(void);
# 6 "/home/nathan/src/linux-next/include/linux/bug.h" 2



enum bug_trap_type {
 BUG_TRAP_TYPE_NONE = 0,
 BUG_TRAP_TYPE_WARN = 1,
 BUG_TRAP_TYPE_BUG = 2,
};

struct pt_regs;
# 34 "/home/nathan/src/linux-next/include/linux/bug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_warning_bug(const struct bug_entry *bug)
{
 return bug->flags & (1 << 0);
}

struct bug_entry *find_bug(unsigned long bugaddr);

enum bug_trap_type report_bug(unsigned long bug_addr, struct pt_regs *regs);


int is_valid_bugaddr(unsigned long addr);

void generic_bug_clear_once(void);
# 70 "/home/nathan/src/linux-next/include/linux/bug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool check_data_corruption(bool v) { return v; }
# 13 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/restart_block.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/restart_block.h"
# 1 "/home/nathan/src/linux-next/include/linux/time64.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/math64.h" 1





# 1 "./arch/powerpc/include/generated/asm/div64.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/math64.h" 2
# 24 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 38 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 52 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}
# 65 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div64_u64(u64 dividend, u64 divisor)
{
 return dividend / divisor;
}
# 77 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div64_s64(s64 dividend, s64 divisor)
{
 return dividend / divisor;
}
# 123 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 div_u64(u64 dividend, u32 divisor)
{
 u32 remainder;
 return div_u64_rem(dividend, divisor, &remainder);
}
# 136 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 div_s64(s64 dividend, s32 divisor)
{
 s32 remainder;
 return div_s64_rem(dividend, divisor, &remainder);
}


u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32
__iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
 u32 ret = 0;

 while (dividend >= divisor) {


  asm("" : "+rm"(dividend));

  dividend -= divisor;
  ret++;
 }

 *remainder = dividend;

 return ret;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u32_u32(u32 a, u32 b)
{
 return (u64)a * b;
}
# 193 "/home/nathan/src/linux-next/include/linux/math64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
 u32 ah, al;
 u64 ret;

 al = a;
 ah = a >> 32;

 ret = mul_u32_u32(al, mul) >> shift;
 if (ah)
  ret += mul_u32_u32(ah, mul) << (32 - shift);

 return ret;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u64_shr(u64 a, u64 b, unsigned int shift)
{
 union {
  u64 ll;
  struct {

   u32 high, low;



  } l;
 } rl, rm, rn, rh, a0, b0;
 u64 c;

 a0.ll = a;
 b0.ll = b;

 rl.ll = mul_u32_u32(a0.l.low, b0.l.low);
 rm.ll = mul_u32_u32(a0.l.low, b0.l.high);
 rn.ll = mul_u32_u32(a0.l.high, b0.l.low);
 rh.ll = mul_u32_u32(a0.l.high, b0.l.high);






 rl.l.high = c = (u64)rl.l.high + rm.l.low + rn.l.low;
 rh.l.low = c = (c >> 32) + rm.l.high + rn.l.high + rh.l.low;
 rh.l.high = (c >> 32) + rh.l.high;





 if (shift == 0)
  return rl.ll;
 if (shift < 64)
  return (rl.ll >> shift) | (rh.ll << (64 - shift));
 return rh.ll >> (shift & 63);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 mul_u64_u32_div(u64 a, u32 mul, u32 divisor)
{
 union {
  u64 ll;
  struct {

   u32 high, low;



  } l;
 } u, rl, rh;

 u.ll = a;
 rl.ll = mul_u32_u32(u.l.low, mul);
 rh.ll = mul_u32_u32(u.l.high, mul) + rl.l.high;


 rl.l.high = ({ uint32_t __base = (divisor); uint32_t __rem; __rem = ((uint64_t)(rh.ll)) % __base; (rh.ll) = ((uint64_t)(rh.ll)) / __base; __rem; });


 ({ uint32_t __base = (divisor); uint32_t __rem; __rem = ((uint64_t)(rl.ll)) % __base; (rl.ll) = ((uint64_t)(rl.ll)) / __base; __rem; });

 rl.l.high = rh.l.low;
 return rl.ll;
}
# 6 "/home/nathan/src/linux-next/include/linux/time64.h" 2

typedef __s64 time64_t;
typedef __u64 timeu64_t;


# 1 "/home/nathan/src/linux-next/include/uapi/linux/time.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/time_types.h" 1






struct __kernel_timespec {
 __kernel_time64_t tv_sec;
 long long tv_nsec;
};

struct __kernel_itimerspec {
 struct __kernel_timespec it_interval;
 struct __kernel_timespec it_value;
};
# 25 "/home/nathan/src/linux-next/include/uapi/linux/time_types.h"
struct __kernel_old_timeval {
 __kernel_long_t tv_sec;
 __kernel_long_t tv_usec;
};


struct __kernel_old_timespec {
 __kernel_old_time_t tv_sec;
 long tv_nsec;
};

struct __kernel_old_itimerval {
 struct __kernel_old_timeval it_interval;
 struct __kernel_old_timeval it_value;
};

struct __kernel_sock_timeval {
 __s64 tv_sec;
 __s64 tv_usec;
};
# 7 "/home/nathan/src/linux-next/include/uapi/linux/time.h" 2



struct timespec {
 __kernel_old_time_t tv_sec;
 long tv_nsec;
};


struct timeval {
 __kernel_old_time_t tv_sec;
 __kernel_suseconds_t tv_usec;
};

struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 34 "/home/nathan/src/linux-next/include/uapi/linux/time.h"
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 11 "/home/nathan/src/linux-next/include/linux/time64.h" 2

struct timespec64 {
 time64_t tv_sec;
 long tv_nsec;
};

struct itimerspec64 {
 struct timespec64 it_interval;
 struct timespec64 it_value;
};
# 49 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec64_equal(const struct timespec64 *a,
       const struct timespec64 *b)
{
 return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec64_compare(const struct timespec64 *lhs, const struct timespec64 *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_nsec - rhs->tv_nsec;
}

extern void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec64 timespec64_add(struct timespec64 lhs,
      struct timespec64 rhs)
{
 struct timespec64 ts_delta;
 set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
    lhs.tv_nsec + rhs.tv_nsec);
 return ts_delta;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec64 timespec64_sub(struct timespec64 lhs,
      struct timespec64 rhs)
{
 struct timespec64 ts_delta;
 set_normalized_timespec64(&ts_delta, lhs.tv_sec - rhs.tv_sec,
    lhs.tv_nsec - rhs.tv_nsec);
 return ts_delta;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid(const struct timespec64 *ts)
{

 if (ts->tv_sec < 0)
  return false;

 if ((unsigned long)ts->tv_nsec >= 1000000000L)
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid_strict(const struct timespec64 *ts)
{
 if (!timespec64_valid(ts))
  return false;

 if ((unsigned long long)ts->tv_sec >= (((s64)~((u64)1 << 63)) / 1000000000L))
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec64_valid_settod(const struct timespec64 *ts)
{
 if (!timespec64_valid(ts))
  return false;

 if ((unsigned long long)ts->tv_sec >= ((((s64)~((u64)1 << 63)) / 1000000000L) - (30LL * 365 * 24 *3600)))
  return false;
 return true;
}
# 133 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 timespec64_to_ns(const struct timespec64 *ts)
{
 return ((s64) ts->tv_sec * 1000000000L) + ts->tv_nsec;
}







extern struct timespec64 ns_to_timespec64(const s64 nsec);
# 154 "/home/nathan/src/linux-next/include/linux/time64.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void timespec64_add_ns(struct timespec64 *a, u64 ns)
{
 a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, 1000000000L, &ns);
 a->tv_nsec = ns;
}





extern struct timespec64 timespec64_add_safe(const struct timespec64 lhs,
      const struct timespec64 rhs);
# 11 "/home/nathan/src/linux-next/include/linux/restart_block.h" 2

struct timespec;
struct old_timespec32;
struct pollfd;

enum timespec_type {
 TT_NONE = 0,
 TT_NATIVE = 1,
 TT_COMPAT = 2,
};




struct restart_block {
 long (*fn)(struct restart_block *);
 union {

  struct {
   u32 *uaddr;
   u32 val;
   u32 flags;
   u32 bitset;
   u64 time;
   u32 *uaddr2;
  } futex;

  struct {
   clockid_t clockid;
   enum timespec_type type;
   union {
    struct __kernel_timespec *rmtp;
    struct old_timespec32 *compat_rmtp;
   };
   u64 expires;
  } nanosleep;

  struct {
   struct pollfd *ufds;
   int nfds;
   int has_timeout;
   unsigned long tv_sec;
   unsigned long tv_nsec;
  } poll;
 };
};

extern long do_no_restart_syscall(struct restart_block *parm);
# 14 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/current.h" 1








struct task_struct;




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 1
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
# 1 "/home/nathan/src/linux-next/include/linux/string.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/string.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/string.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/string.h" 2

extern char *strndup_user(const char *, long);
extern void *memdup_user(const void *, size_t);
extern void *vmemdup_user(const void *, size_t);
extern void *memdup_user_nul(const void *, size_t);





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h"
extern char * strcpy(char *,const char *);
extern char * strncpy(char *,const char *, __kernel_size_t);
extern __kernel_size_t strlen(const char *);
extern int strcmp(const char *,const char *);
extern int strncmp(const char *, const char *, __kernel_size_t);
extern char * strcat(char *, const char *);
extern void * memset(void *,int,__kernel_size_t);
extern void * memcpy(void *,const void *,__kernel_size_t);
extern void * memmove(void *,const void *,__kernel_size_t);
extern int memcmp(const void *,const void *,__kernel_size_t);
extern void * memchr(const void *,int,__kernel_size_t);
extern void * memcpy_flushcache(void *,const void *,__kernel_size_t);

void *__memset(void *s, int c, __kernel_size_t count);
void *__memcpy(void *to, const void *from, __kernel_size_t n);
void *__memmove(void *to, const void *from, __kernel_size_t n);
# 58 "/home/nathan/src/linux-next/arch/powerpc/include/asm/string.h"
extern int memcpy_mcsafe(void *dst, const void *src, __kernel_size_t sz);
extern void *__memset16(uint16_t *, uint16_t v, __kernel_size_t);
extern void *__memset32(uint32_t *, uint32_t v, __kernel_size_t);
extern void *__memset64(uint64_t *, uint64_t v, __kernel_size_t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset16(uint16_t *p, uint16_t v, __kernel_size_t n)
{
 return __memset16(p, v, n * 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset32(uint32_t *p, uint32_t v, __kernel_size_t n)
{
 return __memset32(p, v, n * 4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset64(uint64_t *p, uint64_t v, __kernel_size_t n)
{
 return __memset64(p, v, n * 8);
}
# 21 "/home/nathan/src/linux-next/include/linux/string.h" 2


extern char * strcpy(char *,const char *);





size_t strlcpy(char *, const char *, size_t);


ssize_t strscpy(char *, const char *, size_t);



ssize_t strscpy_pad(char *dest, const char *src, size_t count);


extern char * strcat(char *, const char *);


extern char * strncat(char *, const char *, __kernel_size_t);


extern size_t strlcat(char *, const char *, __kernel_size_t);


extern int strcmp(const char *,const char *);





extern int strcasecmp(const char *s1, const char *s2);


extern int strncasecmp(const char *s1, const char *s2, size_t n);


extern char * strchr(const char *,int);


extern char * strchrnul(const char *,int);

extern char * strnchrnul(const char *, size_t, int);

extern char * strnchr(const char *, size_t, int);


extern char * strrchr(const char *,int);

extern char * __attribute__((__warn_unused_result__)) skip_spaces(const char *);

extern char *strim(char *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) char *strstrip(char *str)
{
 return strim(str);
}


extern char * strstr(const char *, const char *);


extern char * strnstr(const char *, const char *, size_t);


extern __kernel_size_t strlen(const char *);


extern __kernel_size_t strnlen(const char *,__kernel_size_t);


extern char * strpbrk(const char *,const char *);


extern char * strsep(char **,const char *);


extern __kernel_size_t strspn(const char *,const char *);


extern __kernel_size_t strcspn(const char *,const char *);
# 122 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset_l(unsigned long *p, unsigned long v,
  __kernel_size_t n)
{
 if (64 == 32)
  return memset32((uint32_t *)p, v, n);
 else
  return memset64((uint64_t *)p, v, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *memset_p(void **p, void *v, __kernel_size_t n)
{
 if (64 == 32)
  return memset32((uint32_t *)p, (uintptr_t)v, n);
 else
  return memset64((uint64_t *)p, (uintptr_t)v, n);
}

extern void **__memcat_p(void **a, void **b);
# 153 "/home/nathan/src/linux-next/include/linux/string.h"
extern void * memscan(void *,int,__kernel_size_t);





extern int bcmp(const void *,const void *,__kernel_size_t);
# 178 "/home/nathan/src/linux-next/include/linux/string.h"
void *memchr_inv(const void *s, int c, size_t n);
char *strreplace(char *s, char old, char new);

extern void kfree_const(const void *x);

extern char *kstrdup(const char *s, gfp_t gfp) __attribute__((__malloc__));
extern const char *kstrdup_const(const char *s, gfp_t gfp);
extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
extern char *kmemdup_nul(const char *s, size_t len, gfp_t gfp);

extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
extern void argv_free(char **argv);

extern bool sysfs_streq(const char *s1, const char *s2);
extern int kstrtobool(const char *s, bool *res);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int strtobool(const char *s, bool *res)
{
 return kstrtobool(s, res);
}

int match_string(const char * const *array, size_t n, const char *string);
int __sysfs_match_string(const char * const *array, size_t n, const char *s);
# 212 "/home/nathan/src/linux-next/include/linux/string.h"
int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);
int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __attribute__((__format__(printf, 3, 4)));


extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
           const void *from, size_t available);

int ptr_to_hashval(const void *ptr, unsigned long *hashval_out);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool strstarts(const char *str, const char *prefix)
{
 return strncmp(str, prefix, strlen(prefix)) == 0;
}

size_t memweight(const void *ptr, size_t bytes);
# 248 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memzero_explicit(void *s, size_t count)
{
 memset(s, 0, count);
 __asm__ __volatile__("" : : : "memory");
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kbasename(const char *path)
{
 const char *tail = strrchr(path, '/');
 return tail ? tail + 1 : path;
}




void fortify_panic(const char *name) __attribute__((__noreturn__)) __attribute__((__cold__));
void __read_overflow(void) ;
void __read_overflow2(void) ;
void __read_overflow3(void) ;
void __write_overflow(void) ;
# 478 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcpy_and_pad(void *dest, size_t dest_len,
      const void *src, size_t count, int pad)
{
 if (dest_len > count) {
  memcpy(dest, src, count);
  memset(dest + count, pad, dest_len - count);
 } else
  memcpy(dest, src, dest_len);
}
# 503 "/home/nathan/src/linux-next/include/linux/string.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) size_t str_has_prefix(const char *str, const char *prefix)
{
 size_t len = strlen(prefix);
 return strncmp(str, prefix, len) == 0 ? len : 0;
}
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 1
# 44 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
# 1 "/home/nathan/src/linux-next/include/linux/threads.h" 1
# 45 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock_types.h" 1








typedef struct {
 volatile unsigned int slock;
} arch_spinlock_t;



typedef struct {
 volatile signed int lock;
} arch_rwlock_t;
# 14 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/lockdep.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct task_struct;
struct lockdep_map;


extern int prove_locking;
extern int lock_stat;
# 413 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_init_task(struct task_struct *task)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_off(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_on(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_set_selftest_task(struct task_struct *task)
{
}
# 458 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct lock_class_key { };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_register_key(struct lock_class_key *key)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_unregister_key(struct lock_class_key *key)
{
}




struct lockdep_map { };
# 484 "/home/nathan/src/linux-next/include/linux/lockdep.h"
struct pin_cookie { };
# 494 "/home/nathan/src/linux-next/include/linux/lockdep.h"
enum xhlock_context_t {
 XHLOCK_HARD,
 XHLOCK_SOFT,
 XHLOCK_CTX_NR,
};
# 508 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_invariant_state(bool force) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_free_task(struct task_struct *task) {}
# 570 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void print_irqtrace_events(struct task_struct *curr)
{
}
# 668 "/home/nathan/src/linux-next/include/linux/lockdep.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
lockdep_rcu_suspicious(const char *file, const int line, const char *s)
{
}
# 19 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2

typedef struct raw_spinlock {
 arch_spinlock_t raw_lock;







} raw_spinlock_t;
# 61 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
typedef struct spinlock {
 union {
  struct raw_spinlock rlock;
# 72 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
 };
} spinlock_t;
# 83 "/home/nathan/src/linux-next/include/linux/spinlock_types.h"
# 1 "/home/nathan/src/linux-next/include/linux/rwlock_types.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/rwlock_types.h"
typedef struct {
 arch_rwlock_t raw_lock;







} rwlock_t;
# 84 "/home/nathan/src/linux-next/include/linux/spinlock_types.h" 2
# 46 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 1
# 131 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cputable.h" 1






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/cputable.h" 1
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cputable.h" 2







struct cpu_spec;

typedef void (*cpu_setup_t)(unsigned long offset, struct cpu_spec* spec);
typedef void (*cpu_restore_t)(void);

enum powerpc_oprofile_type {
 PPC_OPROFILE_INVALID = 0,
 PPC_OPROFILE_RS64 = 1,
 PPC_OPROFILE_POWER4 = 2,
 PPC_OPROFILE_G4 = 3,
 PPC_OPROFILE_FSL_EMB = 4,
 PPC_OPROFILE_CELL = 5,
 PPC_OPROFILE_PA6T = 6,
};

enum powerpc_pmc_type {
 PPC_PMC_DEFAULT = 0,
 PPC_PMC_IBM = 1,
 PPC_PMC_PA6T = 2,
 PPC_PMC_G4 = 3,
};

struct pt_regs;

extern int machine_check_generic(struct pt_regs *regs);
extern int machine_check_4xx(struct pt_regs *regs);
extern int machine_check_440A(struct pt_regs *regs);
extern int machine_check_e500mc(struct pt_regs *regs);
extern int machine_check_e500(struct pt_regs *regs);
extern int machine_check_e200(struct pt_regs *regs);
extern int machine_check_47x(struct pt_regs *regs);
int machine_check_8xx(struct pt_regs *regs);
int machine_check_83xx(struct pt_regs *regs);

extern void cpu_down_flush_e500v2(void);
extern void cpu_down_flush_e500mc(void);
extern void cpu_down_flush_e5500(void);
extern void cpu_down_flush_e6500(void);


struct cpu_spec {

 unsigned int pvr_mask;
 unsigned int pvr_value;

 char *cpu_name;
 unsigned long cpu_features;
 unsigned int cpu_user_features;
 unsigned int cpu_user_features2;
 unsigned int mmu_features;


 unsigned int icache_bsize;
 unsigned int dcache_bsize;


 void (*cpu_down_flush)(void);


 unsigned int num_pmcs;
 enum powerpc_pmc_type pmc_type;




 cpu_setup_t cpu_setup;

 cpu_restore_t cpu_restore;


 char *oprofile_cpu_type;


 enum powerpc_oprofile_type oprofile_type;


 unsigned long oprofile_mmcra_sihv;
 unsigned long oprofile_mmcra_sipr;


 unsigned long oprofile_mmcra_clear;


 char *platform;




 int (*machine_check)(struct pt_regs *regs);





 long (*machine_check_early)(struct pt_regs *regs);
};

extern struct cpu_spec *cur_cpu_spec;

extern unsigned int __start___ftr_fixup, __stop___ftr_fixup;

extern void set_cur_cpu_spec(struct cpu_spec *s);
extern struct cpu_spec *identify_cpu(unsigned long offset, unsigned int pvr);
extern void identify_cpu_name(unsigned int pvr);
extern void do_feature_fixups(unsigned long value, void *fixup_start,
         void *fixup_end);

extern const char *powerpc_base_platform;


extern void cpu_feature_keys_init(void);
# 132 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 1
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
extern unsigned int hpage_shift;
# 87 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
extern phys_addr_t memstart_addr;
extern phys_addr_t kernstart_addr;
# 252 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h" 1
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
typedef unsigned long pte_basic_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_page(void *addr)
{
 unsigned long iterations;
 unsigned long onex, twox, fourx, eightx;

 iterations = ppc64_caches.l1d.blocks_per_page / 8;






 onex = ppc64_caches.l1d.block_size;
 twox = onex << 1;
 fourx = onex << 2;
 eightx = onex << 3;

 asm volatile(
 "mtctr	%1	# clear_page\n	.balign	16\n1:	dcbz	0,%0\n	dcbz	%3,%0\n	dcbz	%4,%0\n	dcbz	%5,%0\n	dcbz	%6,%0\n	dcbz	%7,%0\n	dcbz	%8,%0\n	dcbz	%9,%0\n	add	%0,%0,%10\n	bdnz+	1b"
# 73 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
 : "=&r" (addr)
 : "r" (iterations), "0" (addr), "b" (onex), "b" (twox),
  "b" (twox+onex), "b" (fourx), "b" (fourx+onex),
  "b" (twox+fourx), "b" (eightx-onex), "r" (eightx)
 : "ctr", "memory");
}

extern void copy_page(void *to, void *from);


extern u64 ppc64_pft_size;
# 107 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/getorder.h" 1
# 29 "/home/nathan/src/linux-next/include/asm-generic/getorder.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__const__)) int get_order(unsigned long size)
{
 if (__builtin_constant_p(size)) {
  if (!size)
   return 64 - 16;

  if (size < (1UL << 16))
   return 0;

  return ( __builtin_constant_p((size) - 1) ? ( __builtin_constant_p((size) - 1) ? ( ((size) - 1) < 2 ? 0 : ((size) - 1) & (1ULL << 63) ? 63 : ((size) - 1) & (1ULL << 62) ? 62 : ((size) - 1) & (1ULL << 61) ? 61 : ((size) - 1) & (1ULL << 60) ? 60 : ((size) - 1) & (1ULL << 59) ? 59 : ((size) - 1) & (1ULL << 58) ? 58 : ((size) - 1) & (1ULL << 57) ? 57 : ((size) - 1) & (1ULL << 56) ? 56 : ((size) - 1) & (1ULL << 55) ? 55 : ((size) - 1) & (1ULL << 54) ? 54 : ((size) - 1) & (1ULL << 53) ? 53 : ((size) - 1) & (1ULL << 52) ? 52 : ((size) - 1) & (1ULL << 51) ? 51 : ((size) - 1) & (1ULL << 50) ? 50 : ((size) - 1) & (1ULL << 49) ? 49 : ((size) - 1) & (1ULL << 48) ? 48 : ((size) - 1) & (1ULL << 47) ? 47 : ((size) - 1) & (1ULL << 46) ? 46 : ((size) - 1) & (1ULL << 45) ? 45 : ((size) - 1) & (1ULL << 44) ? 44 : ((size) - 1) & (1ULL << 43) ? 43 : ((size) - 1) & (1ULL << 42) ? 42 : ((size) - 1) & (1ULL << 41) ? 41 : ((size) - 1) & (1ULL << 40) ? 40 : ((size) - 1) & (1ULL << 39) ? 39 : ((size) - 1) & (1ULL << 38) ? 38 : ((size) - 1) & (1ULL << 37) ? 37 : ((size) - 1) & (1ULL << 36) ? 36 : ((size) - 1) & (1ULL << 35) ? 35 : ((size) - 1) & (1ULL << 34) ? 34 : ((size) - 1) & (1ULL << 33) ? 33 : ((size) - 1) & (1ULL << 32) ? 32 : ((size) - 1) & (1ULL << 31) ? 31 : ((size) - 1) & (1ULL << 30) ? 30 : ((size) - 1) & (1ULL << 29) ? 29 : ((size) - 1) & (1ULL << 28) ? 28 : ((size) - 1) & (1ULL << 27) ? 27 : ((size) - 1) & (1ULL << 26) ? 26 : ((size) - 1) & (1ULL << 25) ? 25 : ((size) - 1) & (1ULL << 24) ? 24 : ((size) - 1) & (1ULL << 23) ? 23 : ((size) - 1) & (1ULL << 22) ? 22 : ((size) - 1) & (1ULL << 21) ? 21 : ((size) - 1) & (1ULL << 20) ? 20 : ((size) - 1) & (1ULL << 19) ? 19 : ((size) - 1) & (1ULL << 18) ? 18 : ((size) - 1) & (1ULL << 17) ? 17 : ((size) - 1) & (1ULL << 16) ? 16 : ((size) - 1) & (1ULL << 15) ? 15 : ((size) - 1) & (1ULL << 14) ? 14 : ((size) - 1) & (1ULL << 13) ? 13 : ((size) - 1) & (1ULL << 12) ? 12 : ((size) - 1) & (1ULL << 11) ? 11 : ((size) - 1) & (1ULL << 10) ? 10 : ((size) - 1) & (1ULL << 9) ? 9 : ((size) - 1) & (1ULL << 8) ? 8 : ((size) - 1) & (1ULL << 7) ? 7 : ((size) - 1) & (1ULL << 6) ? 6 : ((size) - 1) & (1ULL << 5) ? 5 : ((size) - 1) & (1ULL << 4) ? 4 : ((size) - 1) & (1ULL << 3) ? 3 : ((size) - 1) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((size) - 1) <= 4) ? __ilog2_u32((size) - 1) : __ilog2_u64((size) - 1) ) - 16 + 1;
 }

 size--;
 size >>= 16;



 return fls64(size);

}
# 108 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page_64.h" 2
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 304 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable-be-types.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h" 1
# 83 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u8_local(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u8_relaxed(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u16_local(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __xchg_u16_relaxed(volatile void *p, u32 val) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; val <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	andc	%1,%0,%5\n" "	or	%1,%1,%4\n" "	stwcx.	%1,0,%3\n" "	bne-	1b\n" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (val), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u32_local(volatile void *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2 \n"

"	stwcx.	%3,0,%2 \n	bne-	1b"

 : "=&r" (prev), "+m" (*(volatile unsigned int *)p)
 : "r" (p), "r" (val)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u32_relaxed(u32 *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2\n"

"	stwcx.	%3,0,%2\n"
"	bne-	1b"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (val)
 : "cc");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u64_local(volatile void *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2 \n"

"	stdcx.	%3,0,%2 \n	bne-	1b"

 : "=&r" (prev), "+m" (*(volatile unsigned long *)p)
 : "r" (p), "r" (val)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_u64_relaxed(u64 *p, unsigned long val)
{
 unsigned long prev;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2\n"

"	stdcx.	%3,0,%2\n"
"	bne-	1b"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (val)
 : "cc");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_local(void *ptr, unsigned long x, unsigned int size)
{
 switch (size) {
 case 1:
  return __xchg_u8_local(ptr, x);
 case 2:
  return __xchg_u16_local(ptr, x);
 case 4:
  return __xchg_u32_local(ptr, x);

 case 8:
  return __xchg_u64_local(ptr, x);

 }
 do { extern void __compiletime_assert_173(void) ; if (!(!(1))) __compiletime_assert_173(); } while (0);
 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__xchg_relaxed(void *ptr, unsigned long x, unsigned int size)
{
 switch (size) {
 case 1:
  return __xchg_u8_relaxed(ptr, x);
 case 2:
  return __xchg_u16_relaxed(ptr, x);
 case 4:
  return __xchg_u32_relaxed(ptr, x);

 case 8:
  return __xchg_u64_relaxed(ptr, x);

 }
 do { extern void __compiletime_assert_192(void) ; if (!(!(1))) __compiletime_assert_192(); } while (0);
 return x;
}
# 213 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "\n" "sync" " " "\n" "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "sync" " " "\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_local(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_acquire(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u8_relaxed(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u8) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u8)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "\n" "sync" " " "\n" "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "sync" " " "\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_local(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_acquire(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "memory"); return prev >> bitoff; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __cmpxchg_u16_relaxed(volatile void *p, u32 old, u32 new) { unsigned int prev, prev_mask, tmp, bitoff, off; off = (unsigned long)p % sizeof(u32); bitoff = ((sizeof(u32) - sizeof(u16) - off) * 8); p -= off; old <<= bitoff; new <<= bitoff; prev_mask = (u32)(u16)-1 << bitoff; __asm__ __volatile__( "1:	lwarx   %0,0,%3\n" "	and	%1,%0,%6\n" "	cmpw	0,%1,%4\n" "	bne-	2f\n" "	andc	%1,%0,%6\n" "	or	%1,%1,%5\n" "	stwcx.  %1,0,%3\n" "	bne-    1b\n" "\n" "2:" : "=&r" (prev), "=&r" (tmp), "+m" (*(u32*)p) : "r" (p), "r" (old), "r" (new), "r" (prev_mask) : "cc", "cc"); return prev >> bitoff; };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)
{
 unsigned int prev;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%2		# __cmpxchg_u32\n	cmpw	0,%0,%3\n	bne-	2f\n"



"	stwcx.	%4,0,%2\n	bne-	1b"

 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_local(volatile unsigned int *p, unsigned long old,
   unsigned long new)
{
 unsigned int prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32\n	cmpw	0,%0,%3\n	bne-	2f\n"



"	stwcx.	%4,0,%2\n	bne-	1b"

 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_relaxed(u32 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32_relaxed\n"
"	cmpw	0,%0,%3\n"
"	bne-	2f\n"

"	stwcx.	%4,0,%2\n"
"	bne-	1b\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc");

 return prev;
}
# 295 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cmpxchg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u32_acquire(u32 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	lwarx	%0,0,%2		# __cmpxchg_u32_acquire\n"
"	cmpw	0,%0,%3\n"
"	bne-	2f\n"

"	stwcx.	%4,0,%2\n"
"	bne-	1b\n"
 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
 "\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%2		# __cmpxchg_u64\n	cmpd	0,%0,%3\n	bne-	2f\n	stdcx.	%4,0,%2\n	bne-	1b"




 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_local(volatile unsigned long *p, unsigned long old,
   unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64\n	cmpd	0,%0,%3\n	bne-	2f\n	stdcx.	%4,0,%2\n	bne-	1b"




 "\n2:"

 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_relaxed(u64 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64_relaxed\n"
"	cmpd	0,%0,%3\n"
"	bne-	2f\n"
"	stdcx.	%4,0,%2\n"
"	bne-	1b\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc");

 return prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_u64_acquire(u64 *p, unsigned long old, unsigned long new)
{
 unsigned long prev;

 __asm__ __volatile__ (
"1:	ldarx	%0,0,%2		# __cmpxchg_u64_acquire\n"
"	cmpd	0,%0,%3\n"
"	bne-	2f\n"
"	stdcx.	%4,0,%2\n"
"	bne-	1b\n"
 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
 "\n"
"2:"
 : "=&r" (prev), "+m" (*p)
 : "r" (p), "r" (old), "r" (new)
 : "cc", "memory");

 return prev;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg(volatile void *ptr, unsigned long old, unsigned long new,
   unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8(ptr, old, new);
 case 2:
  return __cmpxchg_u16(ptr, old, new);
 case 4:
  return __cmpxchg_u32(ptr, old, new);

 case 8:
  return __cmpxchg_u64(ptr, old, new);

 }
 do { extern void __compiletime_assert_418(void) ; if (!(!(1))) __compiletime_assert_418(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_local(void *ptr, unsigned long old, unsigned long new,
   unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_local(ptr, old, new);
 case 2:
  return __cmpxchg_u16_local(ptr, old, new);
 case 4:
  return __cmpxchg_u32_local(ptr, old, new);

 case 8:
  return __cmpxchg_u64_local(ptr, old, new);

 }
 do { extern void __compiletime_assert_438(void) ; if (!(!(1))) __compiletime_assert_438(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_relaxed(void *ptr, unsigned long old, unsigned long new,
    unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_relaxed(ptr, old, new);
 case 2:
  return __cmpxchg_u16_relaxed(ptr, old, new);
 case 4:
  return __cmpxchg_u32_relaxed(ptr, old, new);

 case 8:
  return __cmpxchg_u64_relaxed(ptr, old, new);

 }
 do { extern void __compiletime_assert_458(void) ; if (!(!(1))) __compiletime_assert_458(); } while (0);
 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long
__cmpxchg_acquire(void *ptr, unsigned long old, unsigned long new,
    unsigned int size)
{
 switch (size) {
 case 1:
  return __cmpxchg_u8_acquire(ptr, old, new);
 case 2:
  return __cmpxchg_u16_acquire(ptr, old, new);
 case 4:
  return __cmpxchg_u32_acquire(ptr, old, new);

 case 8:
  return __cmpxchg_u64_acquire(ptr, old, new);

 }
 do { extern void __compiletime_assert_478(void) ; if (!(!(1))) __compiletime_assert_478(); } while (0);
 return old;
}
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable-be-types.h" 2


typedef struct { __be64 pte; } pte_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_val(pte_t x)
{
 return (( __u64)(__be64)(x.pte));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pte_raw(pte_t x)
{
 return x.pte;
}



typedef struct { __be64 pmd; } pmd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pmd_val(pmd_t x)
{
 return (( __u64)(__be64)(x.pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pmd_raw(pmd_t x)
{
 return x.pmd;
}


typedef struct { __be64 pud; } pud_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pud_val(pud_t x)
{
 return (( __u64)(__be64)(x.pud));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pud_raw(pud_t x)
{
 return x.pud;
}




typedef struct { __be64 pgd; } pgd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pgd_val(pgd_t x)
{
 return (( __u64)(__be64)(x.pgd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 pgd_raw(pgd_t x)
{
 return x.pgd;
}


typedef struct { unsigned long pgprot; } pgprot_t;
# 76 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable-be-types.h"
typedef struct { pte_t pte; unsigned long hidx; } real_pte_t;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_xchg(pte_t *ptep, pte_t old, pte_t new)
{
 unsigned long *p = (unsigned long *)ptep;
 __be64 prev;


 prev = ( __be64)__cmpxchg_u64(p, ( unsigned long)pte_raw(old),
          ( unsigned long)pte_raw(new));

 return pte_raw(old) == prev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_xchg(pmd_t *pmdp, pmd_t old, pmd_t new)
{
 unsigned long *p = (unsigned long *)pmdp;
 __be64 prev;

 prev = ( __be64)__cmpxchg_u64(p, ( unsigned long)pmd_raw(old),
          ( unsigned long)pmd_raw(new));

 return pmd_raw(old) == prev;
}

typedef struct { __be64 pdbe; } hugepd_t;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpd_val(hugepd_t x)
{
 return (( __u64)(__be64)(x.pdbe));
}
# 305 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 315 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h"
struct page;
extern void clear_user_page(void *page, unsigned long vaddr, struct page *pg);
extern void copy_user_page(void *to, void *from, unsigned long vaddr,
  struct page *p);
extern int devmem_is_allowed(unsigned long pfn);


void arch_free_page(struct page *page, int order);



struct vm_area_struct;

extern unsigned long kernstart_virt_addr;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long kaslr_offset(void)
{
 return kernstart_virt_addr - 0xc000000000000000UL;
}


# 1 "/home/nathan/src/linux-next/include/asm-generic/memory_model.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/pfn.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/pfn.h"
typedef struct {
 u64 val;
} pfn_t;
# 6 "/home/nathan/src/linux-next/include/asm-generic/memory_model.h" 2
# 336 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/slice.h" 1
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h" 2






struct mm_struct;
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/slice.h"
unsigned long slice_get_unmapped_area(unsigned long addr, unsigned long len,
          unsigned long flags, unsigned int psize,
          int topdown);

unsigned int get_slice_psize(struct mm_struct *mm, unsigned long addr);

void slice_set_range_psize(struct mm_struct *mm, unsigned long start,
      unsigned long len, unsigned int psize);

void slice_init_new_context_exec(struct mm_struct *mm);
void slice_setup_new_exec(void);
# 338 "/home/nathan/src/linux-next/arch/powerpc/include/asm/page.h" 2
# 133 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2

typedef pte_t *pgtable_t;






enum {
 MMU_FTRS_POSSIBLE =

  0x00000001UL |
# 168 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
  0x02000000UL | 0x04000000UL | 0x08000000UL |
  0x10000000UL | 0x20000000UL |
  0x40000000UL | 0x00008000UL |
  0x00004000UL | 0x00002000UL |


  0x00000040UL |

  0x80000000UL |


  0,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_mmu_has_feature(unsigned long feature)
{
 return !!(MMU_FTRS_POSSIBLE & cur_cpu_spec->mmu_features & feature);
}



# 1 "/home/nathan/src/linux-next/include/linux/jump_label.h" 1
# 79 "/home/nathan/src/linux-next/include/linux/jump_label.h"
extern bool static_key_initialized;







struct static_key {
 atomic_t enabled;
# 102 "/home/nathan/src/linux-next/include/linux/jump_label.h"
 union {
  unsigned long type;
  struct jump_entry *entries;
  struct static_key_mod *next;
 };
};
# 117 "/home/nathan/src/linux-next/include/linux/jump_label.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/jump_label.h" 1
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool arch_static_branch(struct static_key *key, bool branch)
{
 asm goto("1:\n\t" "nop # arch_static_branch\n\t" ".pushsection __jump_table,  \"aw\"\n\t" ".8byte" " " "1b, %l[l_yes], %c0\n\t" ".popsection \n\t" : : "i" (&((char *)key)[branch]) : : l_yes);






 return false;
l_yes:
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool arch_static_branch_jump(struct static_key *key, bool branch)
{
 asm goto("1:\n\t" "b %l[l_yes] # arch_static_branch_jump\n\t" ".pushsection __jump_table,  \"aw\"\n\t" ".8byte" " " "1b, %l[l_yes], %c0\n\t" ".popsection \n\t" : : "i" (&((char *)key)[branch]) : : l_yes);






 return false;
l_yes:
 return true;
}


typedef u64 jump_label_t;




struct jump_entry {
 jump_label_t code;
 jump_label_t target;
 jump_label_t key;
};
# 118 "/home/nathan/src/linux-next/include/linux/jump_label.h" 2
# 147 "/home/nathan/src/linux-next/include/linux/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long jump_entry_code(const struct jump_entry *entry)
{
 return entry->code;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long jump_entry_target(const struct jump_entry *entry)
{
 return entry->target;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct static_key *jump_entry_key(const struct jump_entry *entry)
{
 return (struct static_key *)((unsigned long)entry->key & ~3UL);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool jump_entry_is_branch(const struct jump_entry *entry)
{
 return (unsigned long)entry->key & 1UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool jump_entry_is_init(const struct jump_entry *entry)
{
 return (unsigned long)entry->key & 2UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void jump_entry_set_init(struct jump_entry *entry)
{
 entry->key |= 2;
}






enum jump_label_type {
 JUMP_LABEL_NOP = 0,
 JUMP_LABEL_JMP,
};

struct module;
# 198 "/home/nathan/src/linux-next/include/linux/jump_label.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool static_key_false(struct static_key *key)
{
 return arch_static_branch(key, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool static_key_true(struct static_key *key)
{
 return !arch_static_branch(key, true);
}

extern struct jump_entry __start___jump_table[];
extern struct jump_entry __stop___jump_table[];

extern void jump_label_init(void);
extern void jump_label_lock(void);
extern void jump_label_unlock(void);
extern void arch_jump_label_transform(struct jump_entry *entry,
          enum jump_label_type type);
extern void arch_jump_label_transform_static(struct jump_entry *entry,
          enum jump_label_type type);
extern bool arch_jump_label_transform_queue(struct jump_entry *entry,
         enum jump_label_type type);
extern void arch_jump_label_transform_apply(void);
extern int jump_label_text_reserved(void *start, void *end);
extern void static_key_slow_inc(struct static_key *key);
extern void static_key_slow_dec(struct static_key *key);
extern void static_key_slow_inc_cpuslocked(struct static_key *key);
extern void static_key_slow_dec_cpuslocked(struct static_key *key);
extern void jump_label_apply_nops(struct module *mod);
extern int static_key_count(struct static_key *key);
extern void static_key_enable(struct static_key *key);
extern void static_key_disable(struct static_key *key);
extern void static_key_enable_cpuslocked(struct static_key *key);
extern void static_key_disable_cpuslocked(struct static_key *key);
# 346 "/home/nathan/src/linux-next/include/linux/jump_label.h"
struct static_key_true {
 struct static_key key;
};

struct static_key_false {
 struct static_key key;
};
# 385 "/home/nathan/src/linux-next/include/linux/jump_label.h"
extern bool ____wrong_branch_error(void);
# 189 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2



extern struct static_key_true mmu_feature_keys[32];

extern void mmu_feature_keys_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool mmu_has_feature(unsigned long feature)
{
 int i;
# 212 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
 if (!(MMU_FTRS_POSSIBLE & feature))
  return false;

 i = __builtin_ctzl(feature);
 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&mmu_feature_keys[i]), struct static_key_true)) branch = !arch_static_branch(&(&mmu_feature_keys[i])->key, true); else if (__builtin_types_compatible_p(typeof(*&mmu_feature_keys[i]), struct static_key_false)) branch = !arch_static_branch_jump(&(&mmu_feature_keys[i])->key, true); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 1); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmu_clear_feature(unsigned long feature)
{
 int i;

 i = __builtin_ctzl(feature);
 cur_cpu_spec->mmu_features &= ~feature;
 static_key_disable(&(&mmu_feature_keys[i])->key);
}
# 245 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
extern unsigned int __start___mmu_ftr_fixup, __stop___mmu_ftr_fixup;





extern u64 ppc64_rma_size;


extern void mmu_cleanup_all(void);
extern void radix__mmu_cleanup_all(void);


extern void mmu_partition_table_init(void);
extern void mmu_partition_table_set_entry(unsigned int lpid, unsigned long dw0,
       unsigned long dw1, bool flush);


struct mm_struct;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void assert_pte_locked(struct mm_struct *mm, unsigned long addr)
{
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_enabled(void)
{
 return mmu_has_feature(0x00000040UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_radix_enabled(void)
{
 return early_mmu_has_feature(0x00000040UL);
}
# 295 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
extern u16 get_mm_addr_key(struct mm_struct *mm, unsigned long address);
# 309 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool strict_kernel_rwx_enabled(void)
{
 return false;
}
# 356 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
struct mmu_psize_def {
 unsigned int shift;
 int penc[16];
 unsigned int tlbiel;
 unsigned long avpnm;
 union {
  unsigned long sllp;
  unsigned long ap;
 };
};
extern struct mmu_psize_def mmu_psize_defs[16];
# 46 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 1




# 1 "/home/nathan/src/linux-next/include/asm-generic/5level-fixup.h" 1
# 24 "/home/nathan/src/linux-next/include/asm-generic/5level-fixup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_none(pgd_t p4d)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_bad(pgd_t p4d)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_present(pgd_t p4d)
{
 return 1;
}
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/mmdebug.h" 1







struct page;
struct vm_area_struct;
struct mm_struct;

extern void dump_page(struct page *page, const char *reason);
extern void __dump_page(struct page *page, const char *reason);
void dump_vma(const struct vm_area_struct *vma);
void dump_mm(const struct mm_struct *mm);
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 185 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
extern unsigned long __pte_index_size;
extern unsigned long __pmd_index_size;
extern unsigned long __pud_index_size;
extern unsigned long __pgd_index_size;
extern unsigned long __pud_cache_index;
# 201 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
extern unsigned long __pte_table_size;
extern unsigned long __pmd_table_size;
extern unsigned long __pud_table_size;
extern unsigned long __pgd_table_size;





extern unsigned long __pmd_val_bits;
extern unsigned long __pud_val_bits;
extern unsigned long __pgd_val_bits;




extern unsigned long __pte_frag_nr;

extern unsigned long __pte_frag_size_shift;



extern unsigned long __pmd_frag_nr;

extern unsigned long __pmd_frag_size_shift;
# 259 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
enum pgtable_index {
 PTE_INDEX = 0,
 PMD_INDEX,
 PUD_INDEX,
 PGD_INDEX,



 HTLB_16M_INDEX,
 HTLB_16G_INDEX,
};

extern unsigned long __vmalloc_start;
extern unsigned long __vmalloc_end;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ioremap_max_order(void)
{
 if (radix_enabled())
  return ((16 + __pte_index_size) + __pmd_index_size);
 return 7 + 16;
}


extern unsigned long __kernel_virt_start;
extern unsigned long __kernel_io_start;
extern unsigned long __kernel_io_end;




extern struct page *vmemmap;
extern unsigned long pci_io_base;



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h" 1
# 70 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno-base.h" 1
# 6 "/home/nathan/src/linux-next/include/uapi/asm-generic/errno.h" 2
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/errno.h" 2
# 71 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h" 2








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) real_pte_t __real_pte(pte_t pte, pte_t *ptep, int offset)
{
 real_pte_t rpte;
 unsigned long *hidxp;

 rpte.pte = pte;






 __asm__ __volatile__ ("lwsync" " " : : :"memory");

 hidxp = (unsigned long *)(ptep + offset);
 rpte.hidx = *hidxp;
 return rpte;
}
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __rpte_to_hidx(real_pte_t rpte, unsigned long index)
{
 return ((((rpte.hidx >> (index << 2)) & 0xfUL) + 0xfUL) & 0xfUL);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_set_hidx(pte_t *ptep, real_pte_t rpte,
      unsigned int subpg_index,
      unsigned long hidx, int offset)
{
 unsigned long *hidxp = (unsigned long *)(ptep + offset);

 rpte.hidx &= ~(0xfUL << (subpg_index << 2));
 *hidxp = rpte.hidx | (((hidx + 0x1UL) & 0xfUL) << (subpg_index << 2));






 __asm__ __volatile__ ("lwsync" " " : : :"memory");


 return 0x0UL;
}


extern bool __rpte_sub_valid(real_pte_t rpte, unsigned long index);
# 160 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
extern int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
      unsigned long pfn, unsigned long size, pgprot_t);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__remap_4k_pfn(struct vm_area_struct *vma, unsigned long addr,
     unsigned long pfn, pgprot_t prot)
{
 if (pfn > ((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) >> 16)) {
  ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("remap_4k_pfn called with wrong pfn value\n"); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/hash-64k.h"), "i" (166), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });
  return -22;
 }
 return remap_pfn_range(vma, addr, pfn, (1UL << 16),
          ((pgprot_t) { (((prot).pgprot) | 0x02000) }));
}
# 189 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *get_hpte_slot_array(pmd_t *pmdp)
{






 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return *(char **)(pmdp + (1 << __pmd_index_size));


}
# 214 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int hpte_valid(unsigned char *hpte_slot_array, int index)
{
 return hpte_slot_array[index] & 0x1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int hpte_hash_index(unsigned char *hpte_slot_array,
        int index)
{
 return hpte_slot_array[index] >> 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_hpte_slot_valid(unsigned char *hpte_slot_array,
     unsigned int index, unsigned int hidx)
{
 hpte_slot_array[index] = (hidx << 1) | 0x1;
}
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pmd_trans_huge(pmd_t pmd)
{
 return !!((pmd_val(pmd) & (0x4000000000000000UL | 0x02000)) ==
    (0x4000000000000000UL | 0x02000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 return (((pmd_raw(pmd_a) ^ pmd_raw(pmd_b)) & ~(( __be64)(__u64)((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t hash__pmd_mkhuge(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__u64)(pmd_val(pmd) | (0x4000000000000000UL | 0x02000))) });
}

extern unsigned long hash__pmd_hugepage_update(struct mm_struct *mm,
        unsigned long addr, pmd_t *pmdp,
        unsigned long clr, unsigned long set);
extern pmd_t hash__pmdp_collapse_flush(struct vm_area_struct *vma,
       unsigned long address, pmd_t *pmdp);
extern void hash__pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
      pgtable_t pgtable);
extern pgtable_t hash__pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
extern pmd_t hash__pmdp_huge_get_and_clear(struct mm_struct *mm,
           unsigned long addr, pmd_t *pmdp);
extern int hash__has_transparent_hugepage(void);
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h" 2
# 115 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_region_id(unsigned long ea)
{
 int region_id;
 int id = (ea >> 60UL);

 if (id == 0)
  return 0;

 if (id != (0xc000000000000000UL >> 60))
  return (((((unsigned long)((0xc008000000000000UL + (1UL << 49)) + (1UL << 49)) - 0xc008000000000000UL) >> 49) + 2) + 1);

 if (ea < 0xc008000000000000UL)
  return 1;

 do { extern void __compiletime_assert_129(void) ; if (!(!(((((unsigned long)0xc008000000000000UL - 0xc008000000000000UL) >> 49) + 2) != 2))) __compiletime_assert_129(); } while (0);

 region_id = ((((unsigned long)ea - 0xc008000000000000UL) >> 49) + 2);
 return region_id;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pgd_bad(pgd_t pgd)
{
 return (pgd_val(pgd) == 0);
}





extern void hpte_need_flush(struct mm_struct *mm, unsigned long addr,
       pte_t *ptep, unsigned long pte, int huge);
extern unsigned long htab_convert_pte_flags(unsigned long pteflags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hash__pte_update(struct mm_struct *mm,
      unsigned long addr,
      pte_t *ptep, unsigned long clr,
      unsigned long set,
      int huge)
{
 __be64 old_be, tmp_be;
 unsigned long old;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%3		# pte_update\n	and.	%1,%0,%6\n	bne-	1b \n	andc	%1,%0,%4 \n	or	%1,%1,%7\n	stdcx.	%1,0,%3 \n	bne-	1b"






 : "=&r" (old_be), "=&r" (tmp_be), "=m" (*ptep)
 : "r" (ptep), "r" ((( __be64)(__u64)(clr))), "m" (*ptep),
   "r" ((( __be64)(__u64)(0x0100000000000000UL))), "r" ((( __be64)(__u64)(set)))
 : "cc" );

 if (!huge)
  assert_pte_locked(mm, addr);

 old = (( __u64)(__be64)(old_be));
 if (old & 0x0080000000000000UL)
  hpte_need_flush(mm, addr, ptep, old, huge);

 return old;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__ptep_set_access_flags(pte_t *ptep, pte_t entry)
{
 __be64 old, tmp, val, mask;

 mask = (( __be64)(__u64)(0x00080 | 0x00100 | 0x00004 | 0x00002 | 0x00001 | 0x00200));


 val = pte_raw(entry) & mask;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%4\n		and.	%1,%0,%6\n		bne-	1b \n		or	%0,%3,%0\n		stdcx.	%0,0,%4\n		bne-	1b"





 :"=&r" (old), "=&r" (tmp), "=m" (*ptep)
 :"r" (val), "r" (ptep), "m" (*ptep), "r" ((( __be64)(__u64)(0x0100000000000000UL)))
 :"cc");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pte_same(pte_t pte_a, pte_t pte_b)
{
 return (((pte_raw(pte_a) ^ pte_raw(pte_b)) & ~(( __be64)(__u64)((0x0100000000000000UL | 0x0080000000000000UL | 0x01000)))) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hash__pte_none(pte_t pte)
{
 return (pte_val(pte) & ~(0x0100000000000000UL | 0x0080000000000000UL | 0x01000)) == 0;
}

unsigned long pte_get_hash_gslot(unsigned long vpn, unsigned long shift,
  int ssize, real_pte_t rpte, unsigned int subpg_index);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__set_pte_at(struct mm_struct *mm, unsigned long addr,
      pte_t *ptep, pte_t pte, int percpu)
{




 *ptep = pte;
}


extern void hpte_do_hugepage_flush(struct mm_struct *mm, unsigned long addr,
       pmd_t *pmdp, unsigned long old_pmd);
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/hash.h"
int hash__map_kernel_page(unsigned long ea, unsigned long pa, pgprot_t prot);
extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) hash__vmemmap_create_mapping(unsigned long start,
           unsigned long page_size,
           unsigned long phys);
extern void hash__vmemmap_remove_mapping(unsigned long start,
         unsigned long page_size);

int hash__create_section_mapping(unsigned long start, unsigned long end, int nid);
int hash__remove_section_mapping(unsigned long start, unsigned long end);
# 296 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix-64k.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h" 1




struct vm_area_struct;
struct mm_struct;
struct mmu_gather;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mmu_get_ap(int psize)
{
 return mmu_psize_defs[psize].ap;
}


extern void radix__tlbiel_all(unsigned int action);
extern void radix__flush_tlb_lpid_page(unsigned int lpid,
     unsigned long addr,
     unsigned long page_size);
extern void radix__flush_pwc_lpid(unsigned int lpid);
extern void radix__flush_all_lpid(unsigned int lpid);
extern void radix__flush_all_lpid_guest(unsigned int lpid);
# 44 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h"
extern void radix__flush_hugetlb_tlb_range(struct vm_area_struct *vma,
        unsigned long start, unsigned long end);
extern void radix__flush_tlb_range_psize(struct mm_struct *mm, unsigned long start,
      unsigned long end, int psize);
extern void radix__flush_pmd_tlb_range(struct vm_area_struct *vma,
           unsigned long start, unsigned long end);
extern void radix__flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
       unsigned long end);
extern void radix__flush_tlb_kernel_range(unsigned long start, unsigned long end);

extern void radix__local_flush_tlb_mm(struct mm_struct *mm);
extern void radix__local_flush_all_mm(struct mm_struct *mm);
extern void radix__local_flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr);
extern void radix__local_flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,
           int psize);
extern void radix__tlb_flush(struct mmu_gather *tlb);

extern void radix__flush_tlb_mm(struct mm_struct *mm);
extern void radix__flush_all_mm(struct mm_struct *mm);
extern void radix__flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr);
extern void radix__flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,
     int psize);






extern void radix__flush_tlb_pwc(struct mmu_gather *tlb, unsigned long addr);
extern void radix__flush_tlb_collapsed_pmd(struct mm_struct *mm, unsigned long addr);
extern void radix__flush_tlb_all(void);
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool early_cpu_has_feature(unsigned long feature)
{
 return !!((((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) & ~0x0000000000002000UL & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) | 0x0000000004000000UL | 0x00000002UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL)) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) & (0x00000080UL | 0x00000040UL | 0x00000020UL | 0x00000100UL | 0x00000001UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000008000000000UL | 0x0000000000008000UL | 0x0000000000010000UL)) & feature) ||
    (((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) | 0x0000000004000000UL | 0x00000002UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL)) & cur_cpu_spec->cpu_features & feature));
}






extern struct static_key_true cpu_feature_keys[64];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool cpu_has_feature(unsigned long feature)
{
 int i;
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpu_has_feature.h"
 if (((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) & ~0x0000000000002000UL & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) | 0x0000000004000000UL | 0x00000002UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL)) & (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) & ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) & (0x00000080UL | 0x00000040UL | 0x00000020UL | 0x00000100UL | 0x00000001UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000008000000000UL | 0x0000000000008000UL | 0x0000000000010000UL)) & feature)
  return true;

 if (!(((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x00000008UL | 0x0000000000040000UL | 0x0000000010000000UL | 0x0000000080000000UL | 0x0000000000002000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000020000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000002000000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000040000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x0000004000000000UL | 0x0000010000000000UL | 0x0000000400000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | 0x0000020000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000008000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000400000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x00000002UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x0000000000200000UL | 0x0000000000800000UL | 0x0000000010000000UL | 0x0000000020000000UL | 0x0000010000000000UL) | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x00000002UL | 0x0000000000400000UL | 0x0000000000001000UL | 0x0000010000000000UL) | 0x0000000004000000UL | 0x00000002UL | (0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0002000000000000UL | 0x0000080000000000UL) | ((0x00000080UL | (0x00000100UL | 0x00000020UL) | 0x0000000000080000UL | 0x0000000000008000UL | 0x0000000000040000UL | 0x0000000000100000UL | 0x00000001UL | 0x0000000000400000UL | 0x0000000001000000UL | 0x0000000000001000UL | 0x0000000002000000UL | 0x0000000008000000UL | 0x0000000080000000UL | 0x0000000100000000UL | 0x0000000200000000UL | 0x0000002000000000UL | 0x0000000000002000UL | 0x0000000800000000UL | 0x00000004UL | 0x0000004000000000UL | 0x0000000000010000UL | 0x0000001000000000UL | 0x0000000000020000UL | 0x0000000400000000UL | 0x0000400000000000UL | 0x0001000000000000UL | 0x0000800000000000UL) | 0x0000080000000000UL | 0x0000100000000000UL | 0x0000200000000000UL)) & feature))
  return false;

 i = __builtin_ctzl(feature);
 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&cpu_feature_keys[i]), struct static_key_true)) branch = !arch_static_branch(&(&cpu_feature_keys[i])->key, true); else if (__builtin_types_compatible_p(typeof(*&cpu_feature_keys[i]), struct static_key_false)) branch = !arch_static_branch_jump(&(&cpu_feature_keys[i])->key, true); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 1); });
}
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h" 2
# 124 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
extern void radix__ptep_set_access_flags(struct vm_area_struct *vma, pte_t *ptep,
      pte_t entry, unsigned long address,
      int psize);

extern void radix__ptep_modify_prot_commit(struct vm_area_struct *vma,
        unsigned long addr, pte_t *ptep,
        pte_t old_pte, pte_t pte);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __radix_pte_update(pte_t *ptep, unsigned long clr,
            unsigned long set)
{
 __be64 old_be, tmp_be;

 __asm__ __volatile__(
 "1:	ldarx	%0,0,%3		# pte_update\n"
 "	andc	%1,%0,%5	\n"
 "	or	%1,%1,%4	\n"
 "	stdcx.	%1,0,%3		\n"
 "	bne-	1b"
 : "=&r" (old_be), "=&r" (tmp_be), "=m" (*ptep)
 : "r" (ptep), "r" ((( __be64)(__u64)(set))), "r" ((( __be64)(__u64)(clr)))
 : "cc" );

 return (( __u64)(__be64)(old_be));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long radix__pte_update(struct mm_struct *mm,
     unsigned long addr,
     pte_t *ptep, unsigned long clr,
     unsigned long set,
     int huge)
{
 unsigned long old_pte;

 old_pte = __radix_pte_update(ptep, clr, set);
 if (!huge)
  assert_pte_locked(mm, addr);

 return old_pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t radix__ptep_get_and_clear_full(struct mm_struct *mm,
         unsigned long addr,
         pte_t *ptep, int full)
{
 unsigned long old_pte;

 if (full) {
  old_pte = pte_val(*ptep);
  *ptep = ((pte_t) { (( __be64)(__u64)(0)) });
 } else
  old_pte = radix__pte_update(mm, addr, ptep, ~0ul, 0, 0);

 return ((pte_t) { (( __be64)(__u64)(old_pte)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pte_same(pte_t pte_a, pte_t pte_b)
{
 return ((pte_raw(pte_a) ^ pte_raw(pte_b)) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pte_none(pte_t pte)
{
 return (pte_val(pte) & ~(0x00080 | 0x00100)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void radix__set_pte_at(struct mm_struct *mm, unsigned long addr,
     pte_t *ptep, pte_t pte, int percpu)
{
 *ptep = pte;
# 212 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/radix.h"
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_bad(pmd_t pmd)
{
 return !!(pmd_val(pmd) & 0x60000000000000e0UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 return ((pmd_raw(pmd_a) ^ pmd_raw(pmd_b)) == 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pud_bad(pud_t pud)
{
 return !!(pud_val(pud) & 0x60000000000000e0UL);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pgd_bad(pgd_t pgd)
{
 return !!(pgd_val(pgd) & 0x60000000000000e0UL);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__pmd_trans_huge(pmd_t pmd)
{
 return (pmd_val(pmd) & (0x4000000000000000UL | 0x00800)) == 0x4000000000000000UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t radix__pmd_mkhuge(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__u64)(pmd_val(pmd) | 0x4000000000000000UL)) });
}

extern unsigned long radix__pmd_hugepage_update(struct mm_struct *mm, unsigned long addr,
       pmd_t *pmdp, unsigned long clr,
       unsigned long set);
extern pmd_t radix__pmdp_collapse_flush(struct vm_area_struct *vma,
      unsigned long address, pmd_t *pmdp);
extern void radix__pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
     pgtable_t pgtable);
extern pgtable_t radix__pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
extern pmd_t radix__pmdp_huge_get_and_clear(struct mm_struct *mm,
          unsigned long addr, pmd_t *pmdp);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix__has_transparent_hugepage(void)
{

 if (mmu_psize_defs[7].shift == (16 + __pte_index_size))
  return 1;
 return 0;
}


extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) radix__vmemmap_create_mapping(unsigned long start,
          unsigned long page_size,
          unsigned long phys);
extern void radix__vmemmap_remove_mapping(unsigned long start,
        unsigned long page_size);

extern int radix__map_kernel_page(unsigned long ea, unsigned long pa,
     pgprot_t flags, unsigned int psz);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long radix__get_tree_size(void)
{
 unsigned long rts_field;







 rts_field = (0x5UL << 5);
 rts_field |= (0x2UL << 61);

 return rts_field;
}


int radix__create_section_mapping(unsigned long start, unsigned long end, int nid);
int radix__remove_section_mapping(unsigned long start, unsigned long end);
# 297 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable-64k.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable-64k.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_huge(pmd_t pmd)
{



 return !!(pmd_raw(pmd) & (( __be64)(__u64)(0x4000000000000000UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_huge(pud_t pud)
{



 return !!(pud_raw(pud) & (( __be64)(__u64)(0x4000000000000000UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_huge(pgd_t pgd)
{



 return !!(pgd_raw(pgd) & (( __be64)(__u64)(0x4000000000000000UL)));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hugepd_ok(hugepd_t hpd)
{
 return 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_hugepd_cache_index(int index)
{
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable-64k.h"), "i" (59), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int remap_4k_pfn(struct vm_area_struct *vma, unsigned long addr,
          unsigned long pfn, pgprot_t prot)
{
 if (radix_enabled())
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/pgtable-64k.h"), "i" (68), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 return hash__remap_4k_pfn(vma, addr, pfn, prot);
}
# 300 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h" 2
# 353 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_update(struct mm_struct *mm, unsigned long addr,
           pte_t *ptep, unsigned long clr,
           unsigned long set, int huge)
{
 if (radix_enabled())
  return radix__pte_update(mm, addr, ptep, clr, set, huge);
 return hash__pte_update(mm, addr, ptep, clr, set, huge);
}
# 371 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ptep_test_and_clear_young(struct mm_struct *mm,
           unsigned long addr, pte_t *ptep)
{
 unsigned long old;

 if ((pte_raw(*ptep) & (( __be64)(__u64)(0x00100 | 0x0080000000000000UL))) == 0)
  return 0;
 old = pte_update(mm, addr, ptep, 0x00100, 0, 0);
 return (old & 0x00100) != 0;
}
# 390 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __pte_write(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00002)));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_savedwrite(pte_t pte)
{







 return !(pte_raw(pte) & (( __be64)(__u64)((0x00004 | 0x00002 | 0x00001) | 0x00008)));
}
# 416 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_write(pte_t pte)
{
 return __pte_write(pte) || pte_savedwrite(pte);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_read(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00004)));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr,
          pte_t *ptep)
{
 if (__pte_write(*ptep))
  pte_update(mm, addr, ptep, 0x00002, 0, 0);
 else if (__builtin_expect(!!(pte_savedwrite(*ptep)), 0))
  pte_update(mm, addr, ptep, 0, 0x00008, 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void huge_ptep_set_wrprotect(struct mm_struct *mm,
        unsigned long addr, pte_t *ptep)
{




 if (__pte_write(*ptep))
  pte_update(mm, addr, ptep, 0x00002, 0, 1);
 else if (__builtin_expect(!!(pte_savedwrite(*ptep)), 0))
  pte_update(mm, addr, ptep, 0, 0x00008, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t ptep_get_and_clear(struct mm_struct *mm,
           unsigned long addr, pte_t *ptep)
{
 unsigned long old = pte_update(mm, addr, ptep, ~0UL, 0, 0);
 return ((pte_t) { (( __be64)(__u64)(old)) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t ptep_get_and_clear_full(struct mm_struct *mm,
         unsigned long addr,
         pte_t *ptep, int full)
{
 if (full && radix_enabled()) {




  return radix__ptep_get_and_clear_full(mm, addr, ptep, full);
 }
 return ptep_get_and_clear(mm, addr, ptep);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_clear(struct mm_struct *mm, unsigned long addr,
        pte_t * ptep)
{
 pte_update(mm, addr, ptep, ~0UL, 0, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00080)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_young(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00100)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_special(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00400)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_exec(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00001)));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_soft_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x00200)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mksoft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00200))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_clear_soft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00200))) });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_protnone(pte_t pte)
{
 return (pte_raw(pte) & (( __be64)(__u64)(0x8000000000000000UL | 0x4000000000000000UL | (0x00004 | 0x00002 | 0x00001)))) ==
  (( __be64)(__u64)(0x8000000000000000UL | 0x4000000000000000UL));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mk_savedwrite(pte_t pte)
{





 ((void)(sizeof(( long)((pte_raw(pte) & (( __be64)(__u64)(0x8000000000000000UL | (0x00004 | 0x00002 | 0x00001) | 0x00008))) != (( __be64)(__u64)(0x8000000000000000UL | 0x00008))))));

 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00008))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_clear_savedwrite(pte_t pte)
{



 ((void)(sizeof(( long)(!pte_protnone(pte)))));
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00008))) });
}
# 556 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_present(pte_t pte)
{






 return !!(pte_raw(pte) & (( __be64)(__u64)(0x8000000000000000UL | 0x2000000000000000UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_hw_valid(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0x8000000000000000UL)));
}


extern bool arch_pte_access_permitted(u64 pte, bool write, bool execute);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_user(pte_t pte)
{
 return !(pte_raw(pte) & (( __be64)(__u64)(0x00008)));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_access_permitted(pte_t pte, bool write)
{




 if (!pte_present(pte) || !pte_user(pte) || !pte_read(pte))
  return false;

 if (write && !pte_write(pte))
  return false;

 return arch_pte_access_permitted(pte_val(pte), write, 0);
}
# 609 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pfn_pte(unsigned long pfn, pgprot_t pgprot)
{
 ((void)(sizeof(( long)(pfn >> (64 - 16)))));
 ((void)(sizeof(( long)((pfn << 16) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1))))))));

 return ((pte_t) { (( __be64)(__u64)(((pte_basic_t)pfn << 16) | ((pgprot).pgprot))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pte_pfn(pte_t pte)
{
 return (pte_val(pte) & (((1UL << 53) - 1) & ((~((1 << 16) - 1))))) >> 16;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_wrprotect(pte_t pte)
{
 if (__builtin_expect(!!(pte_savedwrite(pte)), 0))
  return pte_clear_savedwrite(pte);
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00002))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_exprotect(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00001))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkclean(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00080))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkold(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00100))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkexec(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00001))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkpte(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x4000000000000000UL))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkwrite(pte_t pte)
{



 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)((0x00004 | 0x00002)))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkdirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00080 | 0x00200))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkyoung(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00100))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkspecial(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00400))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkhuge(pte_t pte)
{
 return pte;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkdevmap(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00400 | 0x00800))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkprivileged(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0x00008))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_mkuser(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0x00008))) });
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_devmap(pte_t pte)
{
 u64 mask = (( __be64)(__u64)(0x00800 | 0x4000000000000000UL));

 return (pte_raw(pte) & mask) == mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_modify(pte_t pte, pgprot_t newprot)
{

 return ((pte_t) { ((pte_raw(pte) & (( __be64)(__u64)(((((1UL << 53) - 1) & ((~((1 << 16) - 1)))) | (0x0100000000000000UL | 0x0080000000000000UL | 0x01000) | 0x00080 | 0x00100 | 0x00400 | 0x4000000000000000UL | 0x00200 | 0x00800)))) | (( __be64)(__u64)(((newprot).pgprot)))) });

}
# 754 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_swp_mksoft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) | (( __be64)(__u64)(0UL))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_swp_soft_dirty(pte_t pte)
{
 return !!(pte_raw(pte) & (( __be64)(__u64)(0UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pte_swp_clear_soft_dirty(pte_t pte)
{
 return ((pte_t) { (pte_raw(pte) & (( __be64)(__u64)(~0UL))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool check_pte_access(unsigned long access, unsigned long ptev)
{



 if (access & ~ptev)
  return false;



 if ((access & 0x00008) != (ptev & 0x00008))
  return false;

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ptep_set_access_flags(struct vm_area_struct *vma,
        pte_t *ptep, pte_t entry,
        unsigned long address,
        int psize)
{
 if (radix_enabled())
  return radix__ptep_set_access_flags(vma, ptep, entry,
          address, psize);
 return hash__ptep_set_access_flags(ptep, entry);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_same(pte_t pte_a, pte_t pte_b)
{
 if (radix_enabled())
  return radix__pte_same(pte_a, pte_b);
 return hash__pte_same(pte_a, pte_b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_none(pte_t pte)
{
 if (radix_enabled())
  return radix__pte_none(pte);
 return hash__pte_none(pte);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __set_pte_at(struct mm_struct *mm, unsigned long addr,
    pte_t *ptep, pte_t pte, int percpu)
{
 if (radix_enabled())
  return radix__set_pte_at(mm, addr, ptep, pte, percpu);
 return hash__set_pte_at(mm, addr, ptep, pte, percpu);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_noncached(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030)) | 0x00020) });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_noncached_wc(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030)) | 0x00030) });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_cached(pgprot_t prot)
{
 return ((pgprot_t) { ((((prot).pgprot) & ~(0x00010 | 0x00020 | 0x00030))) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_writecombine(pgprot_t prot)
{
 return pgprot_noncached_wc(prot);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pte_ci(pte_t pte)
{
 __be64 pte_v = pte_raw(pte);

 if (((pte_v & (( __be64)(__u64)((0x00010 | 0x00020 | 0x00030)))) == (( __be64)(__u64)(0x00030))) ||
     ((pte_v & (( __be64)(__u64)((0x00010 | 0x00020 | 0x00030)))) == (( __be64)(__u64)(0x00020))))
  return true;
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pmd_clear(pmd_t *pmdp)
{
 *pmdp = ((pmd_t) { (( __be64)(__u64)(0)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none(pmd_t pmd)
{
 return !pmd_raw(pmd);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_present(pmd_t pmd)
{






 if (pmd_raw(pmd) & (( __be64)(__u64)(0x8000000000000000UL | 0x2000000000000000UL)))
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_is_serializing(pmd_t pmd)
{
# 897 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
 if ((pmd_raw(pmd) & (( __be64)(__u64)(0x8000000000000000UL | 0x2000000000000000UL))) ==
      (( __be64)(__u64)(0x2000000000000000UL)))
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_bad(pmd_t pmd)
{
 if (radix_enabled())
  return radix__pmd_bad(pmd);
 return (pmd_val(pmd) & (__pte_table_size-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pud_clear(pud_t *pudp)
{
 *pudp = ((pud_t) { (( __be64)(__u64)(0)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none(pud_t pud)
{
 return !pud_raw(pud);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_present(pud_t pud)
{
 return !!(pud_raw(pud) & (( __be64)(__u64)(0x8000000000000000UL)));
}

extern struct page *pud_page(pud_t pud);
extern struct page *pmd_page(pmd_t pmd);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pud_pte(pud_t pud)
{
 return ((pte_t) { (pud_raw(pud)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pte_pud(pte_t pte)
{
 return ((pud_t) { (pte_raw(pte)) });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_bad(pud_t pud)
{
 if (radix_enabled())
  return radix__pud_bad(pud);
 return (pud_val(pud) & (__pmd_table_size-1));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pud_access_permitted(pud_t pud, bool write)
{
 return pte_access_permitted(pud_pte(pud), write);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgd_clear(pgd_t *pgdp)
{
 *pgdp = ((pgd_t) { (( __be64)(__u64)(0)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_none(pgd_t pgd)
{
 return !pgd_raw(pgd);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_present(pgd_t pgd)
{
 return !!(pgd_raw(pgd) & (( __be64)(__u64)(0x8000000000000000UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pgd_pte(pgd_t pgd)
{
 return ((pte_t) { (pgd_raw(pgd)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgd_t pte_pgd(pte_t pte)
{
 return ((pgd_t) { (pte_raw(pte)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_bad(pgd_t pgd)
{
 if (radix_enabled())
  return radix__pgd_bad(pgd);
 return hash__pgd_bad(pgd);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgd_access_permitted(pgd_t pgd, bool write)
{
 return pte_access_permitted(pgd_pte(pgd), write);
}

extern struct page *pgd_page(pgd_t pgd);
# 1022 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_unmap(pte_t *pte) { }
# 1037 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int map_kernel_page(unsigned long ea, unsigned long pa, pgprot_t prot)
{
 if (radix_enabled()) {




  return radix__map_kernel_page(ea, pa, prot, (1UL << 16));
 }
 return hash__map_kernel_page(ea, pa, prot);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) vmemmap_create_mapping(unsigned long start,
         unsigned long page_size,
         unsigned long phys)
{
 if (radix_enabled())
  return radix__vmemmap_create_mapping(start, page_size, phys);
 return hash__vmemmap_create_mapping(start, page_size, phys);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vmemmap_remove_mapping(unsigned long start,
       unsigned long page_size)
{
 if (radix_enabled())
  return radix__vmemmap_remove_mapping(start, page_size);
 return hash__vmemmap_remove_mapping(start, page_size);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t pmd_pte(pmd_t pmd)
{
 return ((pte_t) { (pmd_raw(pmd)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pte_pmd(pte_t pte)
{
 return ((pmd_t) { (pte_raw(pte)) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t *pmdp_ptep(pmd_t *pmd)
{
 return (pte_t *)pmd;
}
# 1107 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_protnone(pmd_t pmd)
{
 return pte_protnone(pmd_pte(pmd));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_access_permitted(pmd_t pmd, bool write)
{
# 1130 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
 if (pmd_is_serializing(pmd))
  return false;

 return pte_access_permitted(pmd_pte(pmd), write);
}


extern pmd_t pfn_pmd(unsigned long pfn, pgprot_t pgprot);
extern pmd_t mk_pmd(struct page *page, pgprot_t pgprot);
extern pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot);
extern void set_pmd_at(struct mm_struct *mm, unsigned long addr,
         pmd_t *pmdp, pmd_t pmd);
extern void update_mmu_cache_pmd(struct vm_area_struct *vma, unsigned long addr,
     pmd_t *pmd);
extern int hash__has_transparent_hugepage(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int has_transparent_hugepage(void)
{
 if (radix_enabled())
  return radix__has_transparent_hugepage();
 return hash__has_transparent_hugepage();
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
pmd_hugepage_update(struct mm_struct *mm, unsigned long addr, pmd_t *pmdp,
      unsigned long clr, unsigned long set)
{
 if (radix_enabled())
  return radix__pmd_hugepage_update(mm, addr, pmdp, clr, set);
 return hash__pmd_hugepage_update(mm, addr, pmdp, clr, set);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_large(pmd_t pmd)
{
 return !!(pmd_raw(pmd) & (( __be64)(__u64)(0x4000000000000000UL)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_mknotpresent(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__u64)(pmd_val(pmd) & ~0x8000000000000000UL)) });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __pmdp_test_and_clear_young(struct mm_struct *mm,
           unsigned long addr, pmd_t *pmdp)
{
 unsigned long old;

 if ((pmd_raw(*pmdp) & (( __be64)(__u64)(0x00100 | 0x0080000000000000UL))) == 0)
  return 0;
 old = pmd_hugepage_update(mm, addr, pmdp, 0x00100, 0);
 return ((old & 0x00100) != 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pmdp_set_wrprotect(struct mm_struct *mm, unsigned long addr,
          pmd_t *pmdp)
{
 if (__pte_write(pmd_pte((*pmdp))))
  pmd_hugepage_update(mm, addr, pmdp, 0x00002, 0);
 else if (__builtin_expect(!!(pte_savedwrite(pmd_pte(*pmdp))), 0))
  pmd_hugepage_update(mm, addr, pmdp, 0, 0x00008);
}
# 1211 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_trans_huge(pmd_t pmd)
{
 if (!pmd_present(pmd))
  return false;

 if (radix_enabled())
  return radix__pmd_trans_huge(pmd);
 return hash__pmd_trans_huge(pmd);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
 if (radix_enabled())
  return radix__pmd_same(pmd_a, pmd_b);
 return hash__pmd_same(pmd_a, pmd_b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_mkhuge(pmd_t pmd)
{
 if (radix_enabled())
  return radix__pmd_mkhuge(pmd);
 return hash__pmd_mkhuge(pmd);
}


extern int pmdp_set_access_flags(struct vm_area_struct *vma,
     unsigned long address, pmd_t *pmdp,
     pmd_t entry, int dirty);


extern int pmdp_test_and_clear_young(struct vm_area_struct *vma,
         unsigned long address, pmd_t *pmdp);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmdp_huge_get_and_clear(struct mm_struct *mm,
         unsigned long addr, pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pmdp_huge_get_and_clear(mm, addr, pmdp);
 return hash__pmdp_huge_get_and_clear(mm, addr, pmdp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmdp_collapse_flush(struct vm_area_struct *vma,
     unsigned long address, pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pmdp_collapse_flush(vma, address, pmdp);
 return hash__pmdp_collapse_flush(vma, address, pmdp);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgtable_trans_huge_deposit(struct mm_struct *mm,
           pmd_t *pmdp, pgtable_t pgtable)
{
 if (radix_enabled())
  return radix__pgtable_trans_huge_deposit(mm, pmdp, pgtable);
 return hash__pgtable_trans_huge_deposit(mm, pmdp, pgtable);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm,
          pmd_t *pmdp)
{
 if (radix_enabled())
  return radix__pgtable_trans_huge_withdraw(mm, pmdp);
 return hash__pgtable_trans_huge_withdraw(mm, pmdp);
}


extern pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,
        pmd_t *pmdp);


struct spinlock;
extern int pmd_move_must_withdraw(struct spinlock *new_pmd_ptl,
      struct spinlock *old_pmd_ptl,
      struct vm_area_struct *vma);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_needs_pgtable_deposit(void)
{
 if (radix_enabled())
  return false;
 return true;
}
extern void serialize_against_pte_lookup(struct mm_struct *mm);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_mkdevmap(pmd_t pmd)
{
 return ((pmd_t) { (( __be64)(__u64)(pmd_val(pmd) | (0x4000000000000000UL | 0x00800))) });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_devmap(pmd_t pmd)
{
 return pte_devmap(pmd_pte(pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_devmap(pud_t pud)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_devmap(pgd_t pgd)
{
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_pfn(pud_t pud)
{





 do { extern void __compiletime_assert_1332(void) ; if (!(!(1))) __compiletime_assert_1332(); } while (0);
 return 0;
}

pte_t ptep_modify_prot_start(struct vm_area_struct *, unsigned long, pte_t *);
void ptep_modify_prot_commit(struct vm_area_struct *, unsigned long,
        pte_t *, pte_t, pte_t);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_pte_rw_upgrade(unsigned long old_val, unsigned long new_val)
{
 if (!(old_val & 0x00004))
  return false;

 if ((!(old_val & 0x00002)) && (new_val & 0x00002))
  return true;

 return false;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pmd_is_leaf(pmd_t pmd)
{
 return !!(pmd_raw(pmd) & (( __be64)(__u64)(0x4000000000000000UL)));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pud_is_leaf(pud_t pud)
{
 return !!(pud_raw(pud) & (( __be64)(__u64)(0x4000000000000000UL)));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgd_is_leaf(pgd_t pgd)
{
 return !!(pgd_raw(pgd) & (( __be64)(__u64)(0x4000000000000000UL)));
}
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/task_size_64.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h" 2
# 135 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
struct mmu_hash_ops {
 void (*hpte_invalidate)(unsigned long slot,
        unsigned long vpn,
        int bpsize, int apsize,
        int ssize, int local);
 long (*hpte_updatepp)(unsigned long slot,
      unsigned long newpp,
      unsigned long vpn,
      int bpsize, int apsize,
      int ssize, unsigned long flags);
 void (*hpte_updateboltedpp)(unsigned long newpp,
            unsigned long ea,
            int psize, int ssize);
 long (*hpte_insert)(unsigned long hpte_group,
           unsigned long vpn,
           unsigned long prpn,
           unsigned long rflags,
           unsigned long vflags,
           int psize, int apsize,
           int ssize);
 long (*hpte_remove)(unsigned long hpte_group);
 int (*hpte_removebolted)(unsigned long ea,
          int psize, int ssize);
 void (*flush_hash_range)(unsigned long number, int local);
 void (*hugepage_invalidate)(unsigned long vsid,
            unsigned long addr,
            unsigned char *hpte_slot_array,
            int psize, int ssize, int local);
 int (*resize_hpt)(unsigned long shift);







 void (*hpte_clear_all)(void);
};
extern struct mmu_hash_ops mmu_hash_ops;

struct hash_pte {
 __be64 v;
 __be64 r;
};

extern struct hash_pte *htab_address;
extern unsigned long htab_size_bytes;
extern unsigned long htab_hash_mask;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int shift_to_mmu_psize(unsigned int shift)
{
 int psize;

 for (psize = 0; psize < 16; ++psize)
  if (mmu_psize_defs[psize].shift == shift)
   return psize;
 return -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int mmu_psize_to_shift(unsigned int mmu_psize)
{
 if (mmu_psize_defs[mmu_psize].shift)
  return mmu_psize_defs[mmu_psize].shift;
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu-hash.h"), "i" (199), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ap_to_shift(unsigned long ap)
{
 int psize;

 for (psize = 0; psize < 16; psize++) {
  if (mmu_psize_defs[psize].ap == ap)
   return mmu_psize_defs[psize].shift;
 }

 return -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_sllp_encoding(int psize)
{
 unsigned long sllp;

 sllp = ((mmu_psize_defs[psize].sllp & 0x0000000000000100UL) >> 6) |
  ((mmu_psize_defs[psize].sllp & 0x0000000000000030UL) >> 4);
 return sllp;
}
# 253 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int slb_vsid_shift(int ssize)
{
 if (ssize == 0)
  return 12;
 return 24;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int segment_shift(int ssize)
{
 if (ssize == 0)
  return 28;
 return 40;
}
# 274 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
extern u8 hpte_page_sizes[1 << 8];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __hpte_page_size(unsigned long h, unsigned long l,
          bool is_base_size)
{
 unsigned int i, lp;

 if (!(h & 0x0000000000000004UL))
  return 1ul << 12;


 lp = (l >> 12) & ((1 << 8) - 1);
 i = hpte_page_sizes[lp];
 if (!i)
  return 0;
 if (!is_base_size)
  i >>= 4;
 return 1ul << mmu_psize_defs[i & 0xf].shift;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_page_size(unsigned long h, unsigned long l)
{
 return __hpte_page_size(h, l, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_base_page_size(unsigned long h, unsigned long l)
{
 return __hpte_page_size(h, l, 1);
}




extern int mmu_kernel_ssize;
extern int mmu_highuser_ssize;
extern u16 mmu_slb_size;
extern unsigned long tce_alloc_start, tce_alloc_end;







extern int mmu_ci_restrictions;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_avpn(unsigned long vpn, int psize,
          int ssize)
{
 unsigned long v;
# 337 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
 v = (vpn >> (23 - 12)) & ~(mmu_psize_defs[psize].avpnm);
 v <<= 7;
 v |= ((unsigned long) ssize) << 62;
 return v;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_old_to_new_v(unsigned long v)
{

 return v & 0x000fffffffffffffUL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_old_to_new_r(unsigned long v, unsigned long r)
{

 return (r & ~(3ull << 58)) |
  (((v) >> 62) << 58);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_new_to_old_v(unsigned long v, unsigned long r)
{

 return (v & 0x000fffffffffffffUL) |
  ((r & (3ull << 58)) <<
   (62 - 58));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_new_to_old_r(unsigned long r)
{

 return r & ~(3ull << 58);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_get_old_v(struct hash_pte *hptep)
{
 unsigned long hpte_v;

 hpte_v = (( __u64)(__be64)(hptep->v));
 if (cpu_has_feature(0x0000000000020000UL))
  hpte_v = hpte_new_to_old_v(hpte_v, (( __u64)(__be64)(hptep->r)));
 return hpte_v;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_v(unsigned long vpn, int base_psize,
       int actual_psize, int ssize)
{
 unsigned long v;
 v = hpte_encode_avpn(vpn, base_psize, ssize);
 if (actual_psize != 0)
  v |= 0x0000000000000004UL;
 return v;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpte_encode_r(unsigned long pa, int base_psize,
       int actual_psize)
{

 if (actual_psize == 0)
  return pa & 0x0ffffffffffff000UL;
 else {
  unsigned int penc = mmu_psize_defs[base_psize].penc[actual_psize];
  unsigned int shift = mmu_psize_defs[actual_psize].shift;
  return (pa & ~((1ul << shift) - 1)) | (penc << 12);
 }
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpt_vpn(unsigned long ea,
        unsigned long vsid, int ssize)
{
 unsigned long mask;
 int s_shift = segment_shift(ssize);

 mask = (1ul << (s_shift - 12)) - 1;
 return (vsid << (s_shift - 12)) | ((ea >> 12) & mask);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long hpt_hash(unsigned long vpn,
         unsigned int shift, int ssize)
{
 unsigned long mask;
 unsigned long hash, vsid;


 if (ssize == 0) {
  mask = (1ul << (28 - 12)) - 1;
  hash = (vpn >> (28 - 12)) ^
   ((vpn & mask) >> (shift - 12));
 } else {
  mask = (1ul << (40 - 12)) - 1;
  vsid = vpn >> (40 - 12);
  hash = vsid ^ (vsid << 25) ^
   ((vpn & mask) >> (shift - 12)) ;
 }
 return hash & 0x7fffffffffUL;
}




extern int __hash_page_4K(unsigned long ea, unsigned long access,
     unsigned long vsid, pte_t *ptep, unsigned long trap,
     unsigned long flags, int ssize, int subpage_prot);
extern int __hash_page_64K(unsigned long ea, unsigned long access,
      unsigned long vsid, pte_t *ptep, unsigned long trap,
      unsigned long flags, int ssize);
struct mm_struct;
unsigned int hash_page_do_lazy_icache(unsigned int pp, pte_t pte, int trap);
extern int hash_page_mm(struct mm_struct *mm, unsigned long ea,
   unsigned long access, unsigned long trap,
   unsigned long flags);
extern int hash_page(unsigned long ea, unsigned long access, unsigned long trap,
       unsigned long dsisr);
int __hash_page_huge(unsigned long ea, unsigned long access, unsigned long vsid,
       pte_t *ptep, unsigned long trap, unsigned long flags,
       int ssize, unsigned int shift, unsigned int mmu_psize);

extern int __hash_page_thp(unsigned long ea, unsigned long access,
      unsigned long vsid, pmd_t *pmdp, unsigned long trap,
      unsigned long flags, int ssize, unsigned int psize);
# 486 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
extern void hash_failure_debug(unsigned long ea, unsigned long access,
          unsigned long vsid, unsigned long trap,
          int ssize, int psize, int lpsize,
          unsigned long pte);
extern int htab_bolt_mapping(unsigned long vstart, unsigned long vend,
        unsigned long pstart, unsigned long prot,
        int psize, int ssize);
int htab_remove_mapping(unsigned long vstart, unsigned long vend,
   int psize, int ssize);
extern void pseries_add_gpage(u64 addr, u64 page_size, unsigned long number_of_pages);
extern void demote_segment_4k(struct mm_struct *mm, unsigned long addr);

extern void hash__setup_new_exec(void);


void hpte_init_pseries(void);




extern void hpte_init_native(void);

struct slb_entry {
 u64 esid;
 u64 vsid;
};

extern void slb_initialize(void);
void slb_flush_and_restore_bolted(void);
void slb_flush_all_realmode(void);
void __slb_restore_bolted_realmode(void);
void slb_restore_bolted_realmode(void);
void slb_save_contents(struct slb_entry *slb_ptr);
void slb_dump_contents(struct slb_entry *slb_ptr);

extern void slb_vmalloc_update(void);
extern void slb_set_size(u16 size);
# 688 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void subpage_prot_free(struct mm_struct *mm) {}







struct slice_mask {
 u64 low_slices;
 unsigned long high_slices[(((((1UL << (8 + 10 + 10 + 8 + 16)) >> 40)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
};

struct hash_mm_context {
 u16 user_psize;


 unsigned char low_slices_psize[(64 / 8)];
 unsigned char high_slices_psize[((1UL << (8 + 10 + 10 + 8 + 16)) >> 41)];
 unsigned long slb_addr_limit;

 struct slice_mask mask_64k;

 struct slice_mask mask_4k;

 struct slice_mask mask_16m;
 struct slice_mask mask_16g;





};
# 742 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vsid_scramble(unsigned long protovsid,
      unsigned long vsid_multiplier, int vsid_bits)
{
 unsigned long vsid;
 unsigned long vsid_modulus = ((1UL << vsid_bits) - 1);



 vsid = protovsid * vsid_multiplier;
 vsid = (vsid >> vsid_bits) + (vsid & vsid_modulus);
 return (vsid + ((vsid + 1) >> vsid_bits)) & vsid_modulus;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int user_segment_size(unsigned long addr)
{

 if (addr >= (1UL << 40))
  return mmu_highuser_ssize;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_vsid(unsigned long context, unsigned long ea,
         int ssize)
{
 unsigned long va_bits = 68;
 unsigned long vsid_bits;
 unsigned long protovsid;




 if ((ea & (~(0xcUL << 60))) >= (1UL << (8 + 10 + 10 + 8 + 16)))
  return 0;

 if (!mmu_has_feature(0x00002000UL))
  va_bits = 65;

 if (ssize == 0) {
  vsid_bits = va_bits - 28;
  protovsid = (context << (68 - (28 + 19))) |
   ((ea >> 28) & ((1 << (68 - (28 + 19))) - 1));
  return vsid_scramble(protovsid, 12538073UL, vsid_bits);
 }

 vsid_bits = va_bits - 40;
 protovsid = (context << (68 - (40 + 19))) |
  ((ea >> 40) & ((1 << (68 - (40 + 19))) - 1));
 return vsid_scramble(protovsid, 12538073UL, vsid_bits);
}
# 811 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu-hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kernel_context(unsigned long ea)
{
 unsigned long region_id = get_region_id(ea);
 unsigned long ctx;




 if (region_id == 1) {



  ctx = 1 + ((ea & (~(0xcUL << 60))) >> 49);
 } else
  ctx = region_id + (1UL << (51 - 49)) - 1;
 return ctx;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kernel_vsid(unsigned long ea, int ssize)
{
 unsigned long context;

 if (!((ea) >= 0xc000000000000000UL))
  return 0;

 context = get_kernel_context(ea);
 return get_vsid(context, ea, ssize);
}

unsigned htab_shift_for_mem_size(unsigned long mem_size);
# 47 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h" 2





struct prtb_entry {
 __be64 prtb0;
 __be64 prtb1;
};
extern struct prtb_entry *process_tb;

struct patb_entry {
 __be64 patb0;
 __be64 patb1;
};
extern struct patb_entry *partition_tb;
# 80 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
extern unsigned int mmu_pid_bits;


extern unsigned int mmu_base_pid;
# 93 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
typedef unsigned long mm_context_id_t;
struct spinlock;




typedef struct {
 union {
# 109 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
  mm_context_id_t id;
  mm_context_id_t extended_id[(0x0010000000000000UL)/(0x0002000000000000UL)];
 };


 atomic_t active_cpus;


 atomic_t copros;

 struct hash_mm_context *hash_context;

 unsigned long vdso_base;



 void *pte_frag;
 void *pmd_frag;

 struct list_head iommu_group_mem_list;
# 137 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
 u32 pkey_allocation_map;
 s16 execute_only_pkey;

} mm_context_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 mm_ctx_user_psize(mm_context_t *ctx)
{
 return ctx->hash_context->user_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_ctx_set_user_psize(mm_context_t *ctx, u16 user_psize)
{
 ctx->hash_context->user_psize = user_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *mm_ctx_low_slices(mm_context_t *ctx)
{
 return ctx->hash_context->low_slices_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *mm_ctx_high_slices(mm_context_t *ctx)
{
 return ctx->hash_context->high_slices_psize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long mm_ctx_slb_addr_limit(mm_context_t *ctx)
{
 return ctx->hash_context->slb_addr_limit;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_ctx_set_slb_addr_limit(mm_context_t *ctx, unsigned long limit)
{
 ctx->hash_context->slb_addr_limit = limit;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct slice_mask *slice_mask_for_size(mm_context_t *ctx, int psize)
{

 if (psize == 2)
  return &ctx->hash_context->mask_64k;


 if (psize == 10)
  return &ctx->hash_context->mask_16m;
 if (psize == 14)
  return &ctx->hash_context->mask_16g;

 do { if (__builtin_constant_p(psize != 0)) { if (psize != 0) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (184), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (184), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(psize != 0))); } } while (0);

 return &ctx->hash_context->mask_4k;
}
# 199 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/mmu.h"
extern int mmu_linear_psize;
extern int mmu_virtual_psize;
extern int mmu_vmalloc_psize;
extern int mmu_vmemmap_psize;
extern int mmu_io_psize;


void mmu_early_init_devtree(void);
void hash__early_init_devtree(void);
void radix__early_init_devtree(void);
extern void hash__early_init_mmu(void);
extern void radix__early_init_mmu(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void early_init_mmu(void)
{
 if (radix_enabled())
  return radix__early_init_mmu();
 return hash__early_init_mmu();
}
extern void hash__early_init_mmu_secondary(void);
extern void radix__early_init_mmu_secondary(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void early_init_mmu_secondary(void)
{
 if (radix_enabled())
  return radix__early_init_mmu_secondary();
 return hash__early_init_mmu_secondary();
}

extern void hash__setup_initial_memory_limit(phys_addr_t first_memblock_base,
      phys_addr_t first_memblock_size);
extern void radix__setup_initial_memory_limit(phys_addr_t first_memblock_base,
      phys_addr_t first_memblock_size);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void setup_initial_memory_limit(phys_addr_t first_memblock_base,
           phys_addr_t first_memblock_size)
{
 if (early_radix_enabled())
  return radix__setup_initial_memory_limit(first_memblock_base,
         first_memblock_size);
 return hash__setup_initial_memory_limit(first_memblock_base,
        first_memblock_size);
}


extern void radix_init_pseries(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_user_context(mm_context_t *ctx, unsigned long ea)
{
 int index = ea >> 49;

 if (__builtin_expect(!!(index < (sizeof(ctx->extended_id) / sizeof((ctx->extended_id)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((ctx->extended_id)), typeof(&(ctx->extended_id)[0])))); }))))), 1))
  return ctx->extended_id[index];


 ({ int __ret_warn_on = !!(1); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (254), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/mmu.h"), "i" (254), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_user_vsid(mm_context_t *ctx,
       unsigned long ea, int ssize)
{
 unsigned long context = get_user_context(ctx, ea);

 return get_vsid(context, ea, ssize);
}
# 357 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmu.h" 2
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/firmware.h" 1
# 58 "/home/nathan/src/linux-next/arch/powerpc/include/asm/firmware.h"
enum {

 FW_FEATURE_PSERIES_POSSIBLE = 0x0000000000000001UL | 0x0000000000000002UL |
  0x0000000000000004UL | 0x0000000000000008UL | 0x0000000000000010UL |
  0x0000000000000020UL | 0x0000000000000040UL | 0x0000000000000080UL |
  0x0000000000000100UL | 0x0000000000000200UL | 0x0000000000000400UL |
  0x0000000000000800UL | 0x0000000000001000UL | 0x0000000000002000UL |
  0x0000000000004000UL | 0x0000000000008000UL | 0x0000000000010000UL |
  0x0000000000020000UL | 0x0000000000040000UL |
  0x0000000000080000UL | 0x0000008000000000UL |
  0x0000000000100000UL | 0x0000000000400000UL |
  0x0000000002000000UL | 0x0000000004000000UL | 0x0000000008000000UL |
  0x0000000040000000UL | 0x0000000080000000UL |
  0x0000000100000000UL | 0x0000000200000000UL |
  0x0000000001000000UL | 0x0000000400000000UL |
  0x0000000800000000UL | 0x0000001000000000UL |
  0x0000002000000000UL | 0x0000004000000000UL,
 FW_FEATURE_PSERIES_ALWAYS = 0,
 FW_FEATURE_POWERNV_POSSIBLE = 0x0000000010000000UL | 0x0000004000000000UL,
 FW_FEATURE_POWERNV_ALWAYS = 0,
 FW_FEATURE_PS3_POSSIBLE = 0x0000000000400000UL | 0x0000000000800000UL,
 FW_FEATURE_PS3_ALWAYS = 0x0000000000400000UL | 0x0000000000800000UL,
 FW_FEATURE_NATIVE_POSSIBLE = 0,
 FW_FEATURE_NATIVE_ALWAYS = 0,
 FW_FEATURE_POSSIBLE =

  FW_FEATURE_PSERIES_POSSIBLE |


  FW_FEATURE_POWERNV_POSSIBLE |


  FW_FEATURE_PS3_POSSIBLE |


  FW_FEATURE_NATIVE_ALWAYS |

  0,
 FW_FEATURE_ALWAYS =

  FW_FEATURE_PSERIES_ALWAYS &


  FW_FEATURE_POWERNV_ALWAYS &


  FW_FEATURE_PS3_ALWAYS &


  FW_FEATURE_NATIVE_ALWAYS &

  FW_FEATURE_POSSIBLE,





};




extern unsigned long powerpc_firmware_features;





extern void system_reset_fwnmi(void);
extern void machine_check_fwnmi(void);


extern int fwnmi_active;

extern unsigned int __start___fw_ftr_fixup, __stop___fw_ftr_fixup;


void pseries_probe_fw_features(void);
# 49 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h" 2
# 62 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
struct lppaca {


 __be32 desc;
 __be16 size;
 u8 reserved1[3];
 u8 __old_status;
 u8 reserved3[14];
 volatile __be32 dyn_hw_node_id;
 volatile __be32 dyn_hw_proc_id;
 u8 reserved4[56];
 volatile u8 vphn_assoc_counts[8];

 u8 reserved5[32];



 u8 reserved6[48];
 u8 cede_latency_hint;
 u8 ebb_regs_in_use;
 u8 reserved7[6];
 u8 dtl_enable_mask;
 u8 donate_dedicated_cpu;
 u8 fpregs_in_use;
 u8 pmcregs_in_use;
 u8 reserved8[28];
 __be64 wait_state_cycles;
 u8 reserved9[28];
 __be16 slb_count;
 u8 idle;
 u8 vmxregs_in_use;
# 104 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
 volatile __be32 yield_count;
 volatile __be32 dispersion_count;
 volatile __be64 cmo_faults;
 volatile __be64 cmo_fault_time;
 u8 reserved10[104];



 __be32 page_ins;
 u8 reserved11[148];
 volatile __be64 dtl_idx;
 u8 reserved12[96];
} __attribute__((__aligned__((1 << 7))));
# 127 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lppaca_shared_proc(struct lppaca *l)
{
 if (!((FW_FEATURE_ALWAYS & (0x0000000000100000UL)) || (FW_FEATURE_POSSIBLE & powerpc_firmware_features & (0x0000000000100000UL))))
  return false;
 return !!(l->__old_status & 2);
}






struct slb_shadow {
 __be32 persistent;
 __be32 buffer_length;
 __be64 reserved;
 struct {
  __be64 esid;
  __be64 vsid;
 } save_area[2];
} __attribute__((__aligned__((1 << 7))));




struct dtl_entry {
 u8 dispatch_reason;
 u8 preempt_reason;
 __be16 processor_id;
 __be32 enqueue_to_dispatch_time;
 __be32 ready_to_enqueue_time;
 __be32 waiting_to_ready_time;
 __be64 timebase;
 __be64 fault_addr;
 __be64 srr0;
 __be64 srr1;
};
# 179 "/home/nathan/src/linux-next/arch/powerpc/include/asm/lppaca.h"
extern struct kmem_cache *dtl_cache;
extern rwlock_t dtl_access_lock;







extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);

extern void register_dtl_buffer(int cpu);
extern void alloc_dtl_buffers(unsigned long *time_limit);
extern long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/exception-64s.h" 1
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h" 1
# 66 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
struct kvmppc_vcore;


struct kvm_split_mode {
 unsigned long rpr;
 unsigned long pmmar;
 unsigned long ldbar;
 u8 subcore_size;
 u8 do_nap;
 u8 napped[8];
 struct kvmppc_vcore *vc[4];

 unsigned long lpcr_req;
 unsigned long lpidr_req;
 unsigned long host_lpcr;
 u32 do_set;
 u32 do_restore;
 union {
  u32 allphases;
  u8 phase[4];
 } lpcr_sync;
};
# 96 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
struct kvmppc_host_state {
 ulong host_r1;
 ulong host_r2;
 ulong host_msr;
 ulong vmhandler;
 ulong scratch0;
 ulong scratch1;
 ulong scratch2;
 u8 in_guest;
 u8 restore_hid5;
 u8 napping;


 u8 hwthread_req;
 u8 hwthread_state;
 u8 host_ipi;
 u8 ptid;
 u8 tid;
 u8 fake_suspend;
 struct kvm_vcpu *kvm_vcpu;
 struct kvmppc_vcore *kvm_vcore;
 void *xics_phys;
 void *xive_tima_phys;
 void *xive_tima_virt;
 u32 saved_xirr;
 u64 dabr;
 u64 host_mmcr[7];
 u32 host_pmc[8];
 u64 host_purr;
 u64 host_spurr;
 u64 host_dscr;
 u64 dec_expires;
 struct kvm_split_mode *kvm_split_mode;


 u64 cfar;
 u64 ppr;
 u64 host_fscr;

};

struct kvmppc_book3s_shadow_vcpu {
 bool in_use;
 ulong gpr[14];
 u32 cr;
 ulong xer;
 ulong ctr;
 ulong lr;
 ulong pc;

 ulong shadow_srr1;
 ulong fault_dar;
 u32 fault_dsisr;
 u32 last_inst;
# 158 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kvm_book3s_asm.h"
 u8 slb_max;
 struct {
  u64 esid;
  u64 vsid;
 } slb[64];
 u64 shadow_fscr;

};
# 27 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/accounting.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/accounting.h"
struct cpu_accounting_data {

 unsigned long utime;
 unsigned long stime;

 unsigned long utime_scaled;
 unsigned long stime_scaled;

 unsigned long gtime;
 unsigned long hardirq_time;
 unsigned long softirq_time;
 unsigned long steal_time;
 unsigned long idle_time;

 unsigned long starttime;
 unsigned long starttime_user;

 unsigned long startspurr;
 unsigned long utime_sspurr;

};
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hmi.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hmi.h"
struct sibling_subcore_state {
 unsigned long flags;
 u8 in_guest[4];
};

extern void wait_for_subcore_guest_exit(void);
extern void wait_for_tb_resync(void);





struct pt_regs;
extern long hmi_handle_debugtrig(struct pt_regs *regs);
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpuidle.h" 1
# 74 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cpuidle.h"
struct pnv_idle_states_t {
 char name[16];
 u32 latency_ns;
 u32 residency_ns;
 u64 psscr_val;
 u64 psscr_mask;
 u32 flags;
 bool valid;
};

extern struct pnv_idle_states_t *pnv_idle_states;
extern int nr_pnv_idle_states;

unsigned long pnv_cpu_offline(unsigned int cpu);
int validate_psscr_val_mask(u64 *psscr_val, u64 *psscr_mask, u32 flags);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void report_invalid_psscr_val(u64 psscr_val, int err)
{
 switch (err) {
 case -1:
  printk("\001" "4" "Invalid psscr 0x%016llx : ESL,EC bits unequal", psscr_val);

  break;
 case -2:
  printk("\001" "4" "Invalid psscr 0x%016llx : ESL cleared for deep stop-state", psscr_val);

 }
}
# 31 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h" 1
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_read(const atomic_t *v)
{
 int t;

 __asm__ __volatile__("lwz%U1%X1 %0,%1" : "=r"(t) : "m"(v->counter));

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_set(atomic_t *v, int i)
{
 __asm__ __volatile__("stw%U0%X0 %1,%0" : "=m"(v->counter) : "r"(i));
}
# 99 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_add(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "add" "\n" "add" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_add_return_relaxed(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "add" "_return_relaxed\n" "add" " %0,%2,%0\n" "	stwcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_add_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "add" "_relaxed\n" "add" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_sub(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "sub" "\n" "subf" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_sub_return_relaxed(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "sub" "_return_relaxed\n" "subf" " %0,%2,%0\n" "	stwcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_sub_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "sub" "_relaxed\n" "subf" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 113 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_and(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "and" "\n" "and" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_and_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "and" "_relaxed\n" "and" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_or(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "or" "\n" "or" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_or_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "or" "_relaxed\n" "or" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_xor(int a, atomic_t *v) { int t; __asm__ __volatile__( "1:	lwarx	%0,0,%3		# atomic_" "xor" "\n" "xor" " %0,%2,%0\n" "	stwcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_xor_relaxed(int a, atomic_t *v) { int res, t; __asm__ __volatile__( "1:	lwarx	%0,0,%4		# atomic_fetch_" "xor" "_relaxed\n" "xor" " %1,%3,%0\n" "	stwcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 126 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_inc(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_inc\n	addic	%0,%0,1\n"


"	stwcx.	%0,0,%2 \n	bne-	1b"

 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_inc_return_relaxed(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_inc_return_relaxed\n"
"	addic	%0,%0,1\n"

"	stwcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic_dec(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_dec\n	addic	%0,%0,-1\n"

                   "	stwcx.	%0,0,%2\n	bne-	1b"


 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_dec_return_relaxed(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
"1:	lwarx	%0,0,%2		# atomic_dec_return_relaxed\n"
"	addic	%0,%0,-1\n"

"	stwcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}
# 213 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_fetch_add_unless(atomic_t *v, int a, int u)
{
 int t;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%1		# atomic_fetch_add_unless\n	cmpw	0,%0,%3 \n	beq	2f \n	add	%0,%2,%0 \n"




"	stwcx.	%0,0,%1 \n	bne-	1b \n"

 "\n" "sync" " " "\n"
"	subf	%0,%2,%0 \n2:"

 : "=&r" (t)
 : "r" (&v->counter), "r" (a), "r" (u)
 : "cc", "memory");

 return t;
}
# 244 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_inc_not_zero(atomic_t *v)
{
 int t1, t2;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%2		# atomic_inc_not_zero\n	cmpwi	0,%0,0\n	beq-	2f\n	addic	%1,%0,1\n"




"	stwcx.	%1,0,%2\n	bne-	1b\n"

 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (t1), "=&r" (t2)
 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t1;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic_dec_if_positive(atomic_t *v)
{
 int t;

 __asm__ __volatile__(
 "\n" "sync" " " "\n"
"1:	lwarx	%0,0,%1		# atomic_dec_if_positive\n	cmpwi	%0,1\n	addi	%0,%0,-1\n	blt-	2f\n"




"	stwcx.	%0,0,%1\n	bne-	1b"

 "\n" "sync" " " "\n"
 "\n2:" : "=&b" (t)

 : "r" (&v->counter)
 : "cc", "memory");

 return t;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_read(const atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__("ld%U1%X1 %0,%1" : "=r"(t) : "m"(v->counter));

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_set(atomic64_t *v, s64 i)
{
 __asm__ __volatile__("std%U0%X0 %1,%0" : "=m"(v->counter) : "r"(i));
}
# 370 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_add(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "add" "\n" "add" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_add_return_relaxed(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "add" "_return_relaxed\n" "add" " %0,%2,%0\n" "	stdcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_add_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "add" "_relaxed\n" "add" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_sub(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "sub" "\n" "subf" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_sub_return_relaxed(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "sub" "_return_relaxed\n" "subf" " %0,%2,%0\n" "	stdcx.	%0,0,%3\n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return t; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_sub_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "sub" "_relaxed\n" "subf" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 384 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_and(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "and" "\n" "and" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_and_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "and" "_relaxed\n" "and" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_or(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "or" "\n" "or" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_or_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "or" "_relaxed\n" "or" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_xor(s64 a, atomic64_t *v) { s64 t; __asm__ __volatile__( "1:	ldarx	%0,0,%3		# atomic64_" "xor" "\n" "xor" " %0,%2,%0\n" "	stdcx.	%0,0,%3 \n" "	bne-	1b\n" : "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_xor_relaxed(s64 a, atomic64_t *v) { s64 res, t; __asm__ __volatile__( "1:	ldarx	%0,0,%4		# atomic64_fetch_" "xor" "_relaxed\n" "xor" " %1,%3,%0\n" "	stdcx.	%1,0,%4\n" "	bne-	1b\n" : "=&r" (res), "=&r" (t), "+m" (v->counter) : "r" (a), "r" (&v->counter) : "cc"); return res; }
# 397 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_inc(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_inc\n	addic	%0,%0,1\n	stdcx.	%0,0,%2 \n	bne-	1b"



 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_inc_return_relaxed(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_inc_return_relaxed\n"
"	addic	%0,%0,1\n"
"	stdcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void atomic64_dec(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_dec\n	addic	%0,%0,-1\n	stdcx.	%0,0,%2\n	bne-	1b"



 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_dec_return_relaxed(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
"1:	ldarx	%0,0,%2		# atomic64_dec_return_relaxed\n"
"	addic	%0,%0,-1\n"
"	stdcx.	%0,0,%2\n"
"	bne-	1b"
 : "=&r" (t), "+m" (v->counter)
 : "r" (&v->counter)
 : "cc", "xer");

 return t;
}
# 466 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_dec_if_positive(atomic64_t *v)
{
 s64 t;

 __asm__ __volatile__(
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%1		# atomic64_dec_if_positive\n	addic.	%0,%0,-1\n	blt-	2f\n	stdcx.	%0,0,%1\n	bne-	1b"




 "\n" "sync" " " "\n"
 "\n2:" : "=&r" (t)

 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t;
}
# 505 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)
{
 s64 t;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%1		# atomic64_fetch_add_unless\n	cmpd	0,%0,%3 \n	beq	2f \n	add	%0,%2,%0 \n"



"	stdcx.	%0,0,%1 \n	bne-	1b \n"

 "\n" "sync" " " "\n"
"	subf	%0,%2,%0 \n2:"

 : "=&r" (t)
 : "r" (&v->counter), "r" (a), "r" (u)
 : "cc", "memory");

 return t;
}
# 535 "/home/nathan/src/linux-next/arch/powerpc/include/asm/atomic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int atomic64_inc_not_zero(atomic64_t *v)
{
 s64 t1, t2;

 __asm__ __volatile__ (
 "\n" "sync" " " "\n"
"1:	ldarx	%0,0,%2		# atomic64_inc_not_zero\n	cmpdi	0,%0,0\n	beq-	2f\n	addic	%1,%0,1\n	stdcx.	%1,0,%2\n	bne-	1b\n"





 "\n" "sync" " " "\n"
 "\n2:"

 : "=&r" (t1), "=&r" (t2)
 : "r" (&v->counter)
 : "cc", "xer", "memory");

 return t1 != 0;
}
# 32 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/mmiowb_types.h" 1






struct mmiowb_state {
 u16 nesting_count;
 u16 mmiowb_pending;
};
# 34 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h" 2

register struct paca_struct *local_paca asm("r13");
# 54 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
struct task_struct;







struct paca_struct {
# 71 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 struct lppaca *lppaca_ptr;
# 81 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 u16 lock_token;
 u16 paca_index;





 u64 kernel_toc;
 u64 kernelbase;
 u64 kernel_msr;
 void *emergency_sp;
 u64 data_offset;
 s16 hw_cpu_id;
 u8 cpu_start;

 u8 kexec_state;

 struct slb_shadow *slb_shadow_ptr;
 struct dtl_entry *dispatch_log;
 struct dtl_entry *dispatch_log_end;

 u64 dscr_default;






 u64 exgen[10] __attribute__((aligned(0x80)));
 u64 exslb[10];


 u16 vmalloc_sllp;
 u8 slb_cache_ptr;
 u8 stab_rr;



 u32 slb_used_bitmap;
 u32 slb_kern_bitmap;
 u32 slb_cache[8];
# 151 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 mm_context_id_t mm_ctx_id;

 unsigned char mm_ctx_low_slices_psize[64 / 8];
 unsigned char mm_ctx_high_slices_psize[((1UL << (8 + 10 + 10 + 8 + 16)) >> 41)];
 unsigned long mm_ctx_slb_addr_limit;
# 165 "/home/nathan/src/linux-next/arch/powerpc/include/asm/paca.h"
 struct task_struct *__current;
 u64 kstack;
 u64 saved_r1;
 u64 saved_msr;



 u8 irq_soft_mask;
 u8 irq_happened;
 u8 irq_work_pending;

 u8 pmcregs_in_use;

 u64 sprg_vdso;

 u64 tm_scratch;





 unsigned long idle_state;
 union {

  struct {

   u8 thread_idle_state;

   u8 subcore_sibling_mask;
  };


  struct {


   u64 requested_psscr;

   atomic_t dont_stop;

  };
 };




 u64 exnmi[10];
 u64 exmc[10];



 void *nmi_emergency_sp;
 void *mc_emergency_sp;

 u16 in_nmi;





 u16 in_mce;
 u8 hmi_event_available;
 u8 hmi_p9_special_emu;

 u8 ftrace_enabled;


 struct cpu_accounting_data accounting;
 u64 dtl_ridx;
 struct dtl_entry *dtl_curr;






 struct kvmppc_host_state kvm_hstate;





 struct sibling_subcore_state *sibling_subcore_state;







 u64 exrfi[10] __attribute__((__aligned__(0x80)));
 void *rfi_flush_fallback_area;
 u64 l1d_flush_size;


 u8 *mce_data_buf;




 struct slb_entry *mce_faulty_slbs;
 u16 slb_save_cache_ptr;





 struct mmiowb_state mmiowb_state;

} __attribute__((__aligned__((1 << 7))));

extern void copy_mm_to_paca(struct mm_struct *mm);
extern struct paca_struct **paca_ptrs;
extern void initialise_paca(struct paca_struct *new_paca, int cpu);
extern void setup_paca(struct paca_struct *new_paca);
extern void allocate_paca_ptrs(void);
extern void allocate_paca(int cpu);
extern void free_unused_pacas(void);
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/current.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *get_current(void)
{
 struct task_struct *task;


 asm ("ld %0,%1(13)"
 : "=r" (task)
 : "i" (__builtin_offsetof(struct paca_struct, __current)));

 return task;
}
# 22 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2
# 31 "/home/nathan/src/linux-next/include/linux/thread_info.h"
enum {
 BAD_STACK = -1,
 NOT_STACK = 0,
 GOOD_FRAME,
 GOOD_STACK,
};


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h" 1
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 1








# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h" 1
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg_8xx.h" 1
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h" 2
# 1366 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mtmsr_isync(unsigned long val)
{
 asm volatile("mtmsrd" " %0; " "971:" " " "isync" "; " "972: .pushsection __ftr_alt_97,\"a\"; .align 2; 973:" " " "nop" "; " "974: .popsection; .pushsection __ftr_fixup,\"a\"; .align 3; 975: .8byte ((%1)); .8byte (0); .8byte 971b-975b; .8byte 972b-975b; .8byte 973b-975b; .8byte 974b-975b; .ifgt (974b- 973b)-(972b- 971b); .error \"Feature section else case larger than body\"; .endif; .popsection;" " " : :
   "r" (val), "i" (0x0000000000008000UL) : "memory");
}
# 1383 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wrtee(unsigned long val)
{
 if (__builtin_constant_p(val))
  asm volatile("wrteei %0" : : "i" ((val & (1UL<<(15))) ? 1 : 0) : "memory");
 else
  asm volatile("wrtee %0" : : "r" (val) : "memory");
}

extern unsigned long msr_check_and_set(unsigned long bits);
extern bool strict_msr_control;
extern void __msr_check_and_clear(unsigned long bits);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void msr_check_and_clear(unsigned long bits)
{
 if (strict_msr_control)
  __msr_check_and_clear(bits);
}
# 1451 "/home/nathan/src/linux-next/arch/powerpc/include/asm/reg.h"
extern unsigned long current_stack_pointer(void);

extern unsigned long scom970_read(unsigned int address);
extern void scom970_write(unsigned int address, unsigned long value);

struct pt_regs;

extern void ppc_save_regs(struct pt_regs *regs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_power8_hid0(unsigned long hid0)
{





 asm volatile("sync; mtspr %0,%1; isync":: "i"(0x3F0), "r"(hid0));
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 39 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h" 1
# 33 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct user_pt_regs



{
 unsigned long gpr[32];
 unsigned long nip;
 unsigned long msr;
 unsigned long orig_gpr3;
 unsigned long ctr;
 unsigned long link;
 unsigned long xer;
 unsigned long ccr;

 unsigned long softe;




 unsigned long trap;


 unsigned long dar;
 unsigned long dsisr;
 unsigned long result;
};
# 205 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct ppc_debug_info {
 __u32 version;
 __u32 num_instruction_bps;
 __u32 num_data_bps;
 __u32 num_condition_regs;
 __u32 data_bp_alignment;
 __u32 sizeof_condition;
 __u64 features;
};
# 228 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ptrace.h"
struct ppc_hw_breakpoint {
 __u32 version;
 __u32 trigger_type;
 __u32 addr_mode;
 __u32 condition_mode;
 __u64 addr;
 __u64 addr2;
 __u64 condition_value;
};
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 2



struct pt_regs
{
 union {
  struct user_pt_regs user_regs;
  struct {
   unsigned long gpr[32];
   unsigned long nip;
   unsigned long msr;
   unsigned long orig_gpr3;
   unsigned long ctr;
   unsigned long link;
   unsigned long xer;
   unsigned long ccr;

   unsigned long softe;



   unsigned long trap;
   unsigned long dar;
   unsigned long dsisr;
   unsigned long result;
  };
 };

 union {
  struct {

   unsigned long ppr;


   unsigned long kuap;

  };
  unsigned long __pad[2];
 };
};
# 114 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long instruction_pointer(struct pt_regs *regs)
{
 return regs->nip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void instruction_pointer_set(struct pt_regs *regs,
  unsigned long val)
{
 regs->nip = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long user_stack_pointer(struct pt_regs *regs)
{
 return regs->gpr[1];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long frame_pointer(struct pt_regs *regs)
{
 return 0;
}


extern unsigned long profile_pc(struct pt_regs *regs);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_syscall_success(struct pt_regs *regs)
{
 return !(regs->ccr & 0x10000000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long regs_return_value(struct pt_regs *regs)
{
 if (is_syscall_success(regs))
  return regs->gpr[3];
 else
  return -regs->gpr[3];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void regs_set_return_value(struct pt_regs *regs, unsigned long rc)
{
 regs->gpr[3] = rc;
}
# 171 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
struct task_struct;
extern int ptrace_get_reg(struct task_struct *task, int regno,
     unsigned long *data);
extern int ptrace_put_reg(struct task_struct *task, int regno,
     unsigned long data);
# 218 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
# 1 "/home/nathan/src/linux-next/include/linux/thread_info.h" 1
# 219 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h" 2
extern int regs_query_register_offset(const char *name);
extern const char *regs_query_register_name(unsigned int offset);
# 232 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long regs_get_register(struct pt_regs *regs,
      unsigned int offset)
{
 if (__builtin_expect(!!(offset > (__builtin_offsetof(struct pt_regs, dsisr))), 0))
  return 0;
 return *(unsigned long *)((unsigned long)regs + offset);
}
# 249 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool regs_within_kernel_stack(struct pt_regs *regs,
      unsigned long addr)
{
 return ((addr & ~((1 << 14) - 1)) ==
  (((regs)->gpr[1]) & ~((1 << 14) - 1)));
}
# 265 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ptrace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
            unsigned int n)
{
 unsigned long *addr = (unsigned long *)((regs)->gpr[1]);
 addr += n;
 if (regs_within_kernel_stack(regs, (unsigned long)addr))
  return *addr;
 else
  return 0;
}
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
struct arch_hw_breakpoint {
 unsigned long address;
 u16 type;
 u16 len;
 u16 hw_len;
};
# 47 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
# 1 "/home/nathan/src/linux-next/include/linux/kdebug.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kdebug.h" 1






enum die_val {
 DIE_OOPS = 1,
 DIE_IABR_MATCH,
 DIE_DABR_MATCH,
 DIE_BPT,
 DIE_SSTEP,
};
# 6 "/home/nathan/src/linux-next/include/linux/kdebug.h" 2

struct notifier_block;

struct die_args {
 struct pt_regs *regs;
 const char *str;
 long err;
 int trapnr;
 int signr;
};

int register_die_notifier(struct notifier_block *nb);
int unregister_die_notifier(struct notifier_block *nb);

int notify_die(enum die_val val, const char *str,
        struct pt_regs *regs, long err, int trap, int sig);
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 1
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h" 2

struct pt_regs;



extern int (*__debugger)(struct pt_regs *regs);
extern int (*__debugger_ipi)(struct pt_regs *regs);
extern int (*__debugger_bpt)(struct pt_regs *regs);
extern int (*__debugger_sstep)(struct pt_regs *regs);
extern int (*__debugger_iabr_match)(struct pt_regs *regs);
extern int (*__debugger_break_match)(struct pt_regs *regs);
extern int (*__debugger_fault_handler)(struct pt_regs *regs);
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger), 0)) return __debugger(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_ipi(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_ipi), 0)) return __debugger_ipi(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_bpt(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_bpt), 0)) return __debugger_bpt(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_sstep(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_sstep), 0)) return __debugger_sstep(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_iabr_match(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_iabr_match), 0)) return __debugger_iabr_match(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_break_match(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_break_match), 0)) return __debugger_break_match(regs); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int debugger_fault_handler(struct pt_regs *regs) { if (__builtin_expect(!!(__debugger_fault_handler), 0)) return __debugger_fault_handler(regs); return 0; }
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/debug.h"
void __set_breakpoint(struct arch_hw_breakpoint *brk);
bool ppc_breakpoint_available(void);





extern void do_break(struct pt_regs *regs, unsigned long address,
       unsigned long error_code);
# 50 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h" 2

struct perf_event_attr;
struct perf_event;
struct pmu;
struct perf_sample_data;
struct task_struct;

extern int hw_breakpoint_slots(int type);
extern int arch_bp_generic_fields(int type, int *gen_bp_type);
extern int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw);
extern int hw_breakpoint_arch_parse(struct perf_event *bp,
        const struct perf_event_attr *attr,
        struct arch_hw_breakpoint *hw);
extern int hw_breakpoint_exceptions_notify(struct notifier_block *unused,
      unsigned long val, void *data);
int arch_install_hw_breakpoint(struct perf_event *bp);
void arch_uninstall_hw_breakpoint(struct perf_event *bp);
void arch_unregister_hw_breakpoint(struct perf_event *bp);
void hw_breakpoint_pmu_read(struct perf_event *bp);
extern void flush_ptrace_hw_breakpoint(struct task_struct *tsk);

extern struct pmu perf_ops_bp;
extern void ptrace_triggered(struct perf_event *bp,
   struct perf_sample_data *data, struct pt_regs *regs);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hw_breakpoint_disable(void)
{
 struct arch_hw_breakpoint brk;

 brk.address = 0;
 brk.type = 0;
 brk.len = 0;
 brk.hw_len = 0;
 if (ppc_breakpoint_available())
  __set_breakpoint(&brk);
}
extern void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs);
int hw_breakpoint_handler(struct die_args *args);
# 97 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_breakpoint.h"
extern bool dawr_force_enable;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dawr_enabled(void)
{
 return dawr_force_enable;
}
int set_dawr(struct arch_hw_breakpoint *brk);
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h" 2
# 82 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
struct task_struct;
void start_thread(struct pt_regs *regs, unsigned long fdptr, unsigned long sp);
void release_thread(struct task_struct *);

typedef struct {
 unsigned long seg;
} mm_segment_t;





struct thread_fp_state {
 u64 fpr[32][2] __attribute__((aligned(16)));
 u64 fpscr;
};


struct thread_vr_state {
 vector128 vr[32] __attribute__((aligned(16)));
 vector128 vscr __attribute__((aligned(16)));
};

struct debug_reg {
# 142 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
};

struct thread_struct {
 unsigned long ksp;


 unsigned long ksp_vsid;

 struct pt_regs *regs;
 mm_segment_t addr_limit;
# 173 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 struct debug_reg debug;
 struct thread_fp_state fp_state;
 struct thread_fp_state *fp_save_area;
 int fpexc_mode;
 unsigned int align_ctl;

 struct perf_event *ptrace_bps[1];




 struct perf_event *last_hit_ubp;

 struct arch_hw_breakpoint hw_brk;
 unsigned long trap_nr;
 u8 load_slb;
 u8 load_fp;

 u8 load_vec;
 struct thread_vr_state vr_state;
 struct thread_vr_state *vr_save_area;
 unsigned long vrsave;
 int used_vr;



 int used_vsr;
# 210 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 u8 load_tm;
 u64 tm_tfhar;
 u64 tm_texasr;
 u64 tm_tfiar;
 struct pt_regs ckpt_regs;

 unsigned long tm_tar;
 unsigned long tm_ppr;
 unsigned long tm_dscr;
# 229 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 struct thread_fp_state ckfp_state;
 struct thread_vr_state ckvr_state;
 unsigned long ckvrsave;


 unsigned long amr;
 unsigned long iamr;
 unsigned long uamor;
# 245 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 unsigned long dscr;
 unsigned long fscr;
# 256 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
 int dscr_inherit;
 unsigned long tidr;


 unsigned long tar;
 unsigned long ebbrr;
 unsigned long ebbhr;
 unsigned long bescr;
 unsigned long siar;
 unsigned long sdar;
 unsigned long sier;
 unsigned long mmcr2;
 unsigned mmcr0;

 unsigned used_ebb;
 unsigned int used_vas;

};
# 309 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
unsigned long get_wchan(struct task_struct *p);
# 318 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
extern int get_fpexc_mode(struct task_struct *tsk, unsigned long adr);
extern int set_fpexc_mode(struct task_struct *tsk, unsigned int val);




extern int get_endian(struct task_struct *tsk, unsigned long adr);
extern int set_endian(struct task_struct *tsk, unsigned int val);




extern int get_unalign_ctl(struct task_struct *tsk, unsigned long adr);
extern int set_unalign_ctl(struct task_struct *tsk, unsigned int val);

extern void load_fp_state(struct thread_fp_state *fp);
extern void store_fp_state(struct thread_fp_state *fp);
extern void load_vr_state(struct thread_vr_state *vr);
extern void store_vr_state(struct thread_vr_state *vr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __unpack_fe01(unsigned long msr_bits)
{
 return ((msr_bits & (1UL<<(11))) >> 10) | ((msr_bits & (1UL<<(8))) >> 8);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __pack_fe01(unsigned int fpmode)
{
 return ((fpmode << 10) & (1UL<<(11))) | ((fpmode << 8) & (1UL<<(8)));
}
# 373 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
int validate_sp(unsigned long sp, struct task_struct *p,
                       unsigned long nbytes);
# 383 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prefetch(const void *x)
{
 if (__builtin_expect(!!(!x), 0))
  return;

 __asm__ __volatile__ ("dcbt 0,%0" : : "r" (x));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prefetchw(const void *x)
{
 if (__builtin_expect(!!(!x), 0))
  return;

 __asm__ __volatile__ ("dcbtst 0,%0" : : "r" (x));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_clean_sp(unsigned long sp, int is_32)
{
 if (is_32)
  return sp & 0x0ffffffffUL;
 return sp;
}
# 418 "/home/nathan/src/linux-next/arch/powerpc/include/asm/processor.h"
extern unsigned long isa300_idle_stop_noloss(unsigned long psscr_val);
extern unsigned long isa300_idle_stop_mayloss(unsigned long psscr_val);
extern unsigned long isa206_idle_insn_mayloss(unsigned long type);

extern void power4_idle_nap(void);


extern unsigned long cpuidle_disable;
enum idle_boot_override {IDLE_NO_OVERRIDE = 0, IDLE_POWERSAVE_OFF};

extern int powersave_nap;

extern void power7_idle_type(unsigned long type);
extern void power9_idle_type(unsigned long stop_psscr_val,
         unsigned long stop_psscr_mask);

extern void flush_instruction_cache(void);
extern void hard_reset_now(void);
extern void poweroff_now(void);
extern int fix_alignment(struct pt_regs *);
extern void cvt_fd(float *from, double *to);
extern void cvt_df(double *from, float *to);
extern void _nmask_and_or_msr(unsigned long nmask, unsigned long or_val);
# 41 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h" 2







struct thread_info {
 int preempt_count;

 unsigned long local_flags;






 unsigned char slb_preload_nr;
 unsigned char slb_preload_tail;
 u32 slb_preload_esid[16U];


 unsigned long flags __attribute__((__aligned__((1 << 7))));
};
# 78 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);


void arch_setup_new_exec(void);
# 159 "/home/nathan/src/linux-next/arch/powerpc/include/asm/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_thread_local_flags(unsigned int flags)
{
 struct thread_info *ti = ((struct thread_info *)get_current());
 return (ti->local_flags & flags) != 0;
}
# 39 "/home/nathan/src/linux-next/include/linux/thread_info.h" 2
# 53 "/home/nathan/src/linux-next/include/linux/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_ti_thread_flag(struct thread_info *ti, int flag)
{
 set_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_ti_thread_flag(struct thread_info *ti, int flag,
      bool value)
{
 if (value)
  set_ti_thread_flag(ti, flag);
 else
  clear_ti_thread_flag(ti, flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_set_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_bit(flag, (unsigned long *)&ti->flags);
}
# 103 "/home/nathan/src/linux-next/include/linux/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_within_stack_frames(const void * const stack,
        const void * const stackend,
        const void *obj, unsigned long len)
{
 return 0;
}
# 122 "/home/nathan/src/linux-next/include/linux/thread_info.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void check_object_size(const void *ptr, unsigned long n,
         bool to_user)
{ }


extern void
__bad_copy_from(void);
extern void
__bad_copy_to(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_overflow(int size, unsigned long count)
{
 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("Buffer overflow detected (%d < %lu)!\n", size, count); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/thread_info.h"), "i" (134), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) bool
check_copy_size(const void *addr, size_t bytes, bool is_source)
{
 int sz = -1;
 if (__builtin_expect(!!(sz >= 0 && sz < bytes), 0)) {
  if (!__builtin_constant_p(bytes))
   copy_overflow(sz, bytes);
  else if (is_source)
   __bad_copy_from();
  else
   __bad_copy_to();
  return false;
 }
 if (({ int __ret_warn_on = !!(bytes > ((int)(~0U >> 1))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/thread_info.h"), "i" (150), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return false;
 check_object_size(addr, bytes, is_source);
 return true;
}
# 6 "/home/nathan/src/linux-next/include/asm-generic/preempt.h" 2



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int preempt_count(void)
{
 return ({ union { typeof(((struct thread_info *)get_current())->preempt_count) __val; char __c[1]; } __u; if (1) __read_once_size(&(((struct thread_info *)get_current())->preempt_count), __u.__c, sizeof(((struct thread_info *)get_current())->preempt_count)); else __read_once_size_nocheck(&(((struct thread_info *)get_current())->preempt_count), __u.__c, sizeof(((struct thread_info *)get_current())->preempt_count)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) volatile int *preempt_count_ptr(void)
{
 return &((struct thread_info *)get_current())->preempt_count;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void preempt_count_set(int pc)
{
 *preempt_count_ptr() = pc;
}
# 35 "/home/nathan/src/linux-next/include/asm-generic/preempt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void set_preempt_need_resched(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void clear_preempt_need_resched(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool test_preempt_need_resched(void)
{
 return false;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __preempt_count_add(int val)
{
 *preempt_count_ptr() += val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __preempt_count_sub(int val)
{
 *preempt_count_ptr() -= val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool __preempt_count_dec_and_test(void)
{





 return !--*preempt_count_ptr() && test_ti_thread_flag(((struct thread_info *)get_current()), 2);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool should_resched(int preempt_offset)
{
 return __builtin_expect(!!(preempt_count() == preempt_offset && test_ti_thread_flag(((struct thread_info *)get_current()), 2)), 0);

}
# 2 "./arch/powerpc/include/generated/asm/preempt.h" 2
# 79 "/home/nathan/src/linux-next/include/linux/preempt.h" 2
# 277 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_notifier;
# 293 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_ops {
 void (*sched_in)(struct preempt_notifier *notifier, int cpu);
 void (*sched_out)(struct preempt_notifier *notifier,
     struct task_struct *next);
};
# 306 "/home/nathan/src/linux-next/include/linux/preempt.h"
struct preempt_notifier {
 struct hlist_node link;
 struct preempt_ops *ops;
};

void preempt_notifier_inc(void);
void preempt_notifier_dec(void);
void preempt_notifier_register(struct preempt_notifier *notifier);
void preempt_notifier_unregister(struct preempt_notifier *notifier);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void preempt_notifier_init(struct preempt_notifier *notifier,
         struct preempt_ops *ops)
{
 INIT_HLIST_NODE(&notifier->link);
 notifier->ops = ops;
}
# 52 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/irqflags.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/irqflags.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
# 1 "/home/nathan/src/linux-next/include/linux/errno.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/errno.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/errno.h" 2
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h" 2
# 54 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
extern void replay_system_reset(void);
extern void __replay_interrupt(unsigned int vector);

extern void timer_interrupt(struct pt_regs *);
extern void timer_broadcast_interrupt(void);
extern void performance_monitor_exception(struct pt_regs *regs);
extern void WatchdogException(struct pt_regs *regs);
extern void unknown_exception(struct pt_regs *regs);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_return(void)
{
 unsigned long flags;

 asm volatile(
  "lbz %0,%1(13)"
  : "=r" (flags)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)));

 return flags;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void irq_soft_mask_set(unsigned long mask)
{
# 103 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
 asm volatile(
  "stb %0,%1(13)"
  :
  : "r" (mask),
    "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask))
  : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_set_return(unsigned long mask)
{
 unsigned long flags;





 asm volatile(
  "lbz %0,%1(13); stb %2,%1(13)"
  : "=&r" (flags)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)),
    "r" (mask)
  : "memory");

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) unsigned long irq_soft_mask_or_return(unsigned long mask)
{
 unsigned long flags, tmp;

 asm volatile(
  "lbz %0,%2(13); or %1,%0,%3; stb %1,%2(13)"
  : "=&r" (flags), "=r" (tmp)
  : "i" (__builtin_offsetof(struct paca_struct, irq_soft_mask)),
    "r" (mask)
  : "memory");





 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long arch_local_save_flags(void)
{
 return irq_soft_mask_return();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_local_irq_disable(void)
{
 irq_soft_mask_set(1);
}

extern void arch_local_irq_restore(unsigned long);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_local_irq_enable(void)
{
 arch_local_irq_restore(0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long arch_local_irq_save(void)
{
 return irq_soft_mask_set_return(1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irqs_disabled_flags(unsigned long flags)
{
 return flags & 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irqs_disabled(void)
{
 return arch_irqs_disabled_flags(arch_local_save_flags());
}
# 249 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lazy_irq_pending(void)
{
 return !!(local_paca->irq_happened & ~0x01);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void may_hard_irq_enable(void)
{
 if (!(local_paca->irq_happened & (0x04|0x40))) {
  local_paca->irq_happened &= ~0x01;
  asm volatile("mtmsrd %0," "1" : : "r" ((1UL<<(15))|(1UL<<(1))) : "memory");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_irq_disabled_regs(struct pt_regs *regs)
{
 return (regs->softe & 1);
}

extern bool prep_irq_for_idle(void);
extern bool prep_irq_for_idle_irqsoff(void);
extern void irq_set_pending_from_srr1(unsigned long srr1);



extern void force_external_irq_replay(void);
# 357 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hw_irq.h"
struct irq_chip;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irqflags.h" 2
# 17 "/home/nathan/src/linux-next/include/linux/irqflags.h" 2








  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void trace_softirqs_on(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void trace_softirqs_off(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_hardirqs_on(unsigned long ip) { }
  static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_hardirqs_off(unsigned long ip) { }
# 55 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/bottom_half.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/bottom_half.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
{
 __preempt_count_add(cnt);
 __asm__ __volatile__("" : : : "memory");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_disable(void)
{
 __local_bh_disable_ip(({ __label__ __here; __here: (unsigned long)&&__here; }), (2 * (1UL << (0 + 8))));
}

extern void _local_bh_enable(void);
extern void __local_bh_enable_ip(unsigned long ip, unsigned int cnt);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_enable_ip(unsigned long ip)
{
 __local_bh_enable_ip(ip, (2 * (1UL << (0 + 8))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_bh_enable(void)
{
 __local_bh_enable_ip(({ __label__ __here; __here: (unsigned long)&&__here; }), (2 * (1UL << (0 + 8))));
}
# 59 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/mmiowb.h" 1
# 35 "/home/nathan/src/linux-next/include/asm-generic/mmiowb.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_set_pending(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);
 ms->mmiowb_pending = ms->nesting_count;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_spin_lock(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);
 ms->nesting_count++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mmiowb_spin_unlock(void)
{
 struct mmiowb_state *ms = (&local_paca->mmiowb_state);

 if (__builtin_expect(!!(ms->mmiowb_pending), 0)) {
  ms->mmiowb_pending = 0;
  __asm__ __volatile__ ("sync" : : : "memory");
 }

 ms->nesting_count--;
}
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmiowb.h" 2
# 61 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2
# 89 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h" 1
# 403 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall_norets(unsigned long opcode, ...);
# 416 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall(unsigned long opcode, unsigned long *retbuf, ...);
# 430 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall_raw(unsigned long opcode, unsigned long *retbuf, ...);
# 441 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hvcall.h"
long plpar_hcall9(unsigned long opcode, unsigned long *retbuf, ...);
long plpar_hcall9_raw(unsigned long opcode, unsigned long *retbuf, ...);

struct hvcall_mpp_data {
 unsigned long entitled_mem;
 unsigned long mapped_mem;
 unsigned short group_num;
 unsigned short pool_num;
 unsigned char mem_weight;
 unsigned char unallocated_mem_weight;
 unsigned long unallocated_entitlement;
 unsigned long pool_size;
 signed long loan_request;
 unsigned long backing_mem;
};

int h_get_mpp(struct hvcall_mpp_data *);

struct hvcall_mpp_x_data {
 unsigned long coalesced_bytes;
 unsigned long pool_coalesced_bytes;
 unsigned long pool_purr_cycles;
 unsigned long pool_spurr_cycles;
 unsigned long reserved[3];
};

int h_get_mpp_x(struct hvcall_mpp_x_data *mpp_x_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int get_longbusy_msecs(int longbusy_rc)
{
 switch (longbusy_rc) {
 case 9900:
  return 1;
 case 9901:
  return 10;
 case 9902:
  return 100;
 case 9903:
  return 1000;
 case 9904:
  return 10000;
 case 9905:
  return 100000;
 default:
  return 1;
 }
}

struct h_cpu_char_result {
 u64 character;
 u64 behaviour;
};


struct hv_guest_state {
 u64 version;
 u32 lpid;
 u32 vcpu_token;

 u64 lpcr;
 u64 pcr;
 u64 amor;
 u64 dpdes;
 u64 hfscr;
 s64 tb_offset;
 u64 dawr0;
 u64 dawrx0;
 u64 ciabr;
 u64 hdec_expiry;
 u64 purr;
 u64 spurr;
 u64 ic;
 u64 vtb;
 u64 hdar;
 u64 hdsisr;
 u64 heir;
 u64 asdr;

 u64 srr0;
 u64 srr1;
 u64 sprg[4];
 u64 pidr;
 u64 cfar;
 u64 ppr;
};
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h" 2
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
extern struct static_key_false shared_processor;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vcpu_is_preempted(int cpu)
{
 if (!({ bool branch; if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_true)) branch = arch_static_branch_jump(&(&shared_processor)->key, false); else if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_false)) branch = arch_static_branch(&(&shared_processor)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }))
  return false;
 return !!((( __u32)(__be32)((*paca_ptrs[cpu]->lppaca_ptr).yield_count)) & 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int arch_spin_value_unlocked(arch_spinlock_t lock)
{
 return lock.slock == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_spin_is_locked(arch_spinlock_t *lock)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 return !arch_spin_value_unlocked(*lock);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __arch_spin_trylock(arch_spinlock_t *lock)
{
 unsigned long tmp, token;

 token = (*(u32 *)(&local_paca->lock_token));
 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%2) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n	cmpwi		0,%0,0\n	bne-		2f\n	stwcx.		%1,0,%2\n	bne-		1b\n"




 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:"
 : "=&r" (tmp)
 : "r" (token), "r" (&lock->slock)
 : "cr0", "memory");

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_spin_trylock(arch_spinlock_t *lock)
{
 return __arch_spin_trylock(lock) == 0;
}
# 107 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
void splpar_spin_yield(arch_spinlock_t *lock);
void splpar_rw_yield(arch_rwlock_t *lock);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_shared_processor(void)
{

 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_true)) branch = arch_static_branch_jump(&(&shared_processor)->key, false); else if (__builtin_types_compatible_p(typeof(*&shared_processor), struct static_key_false)) branch = arch_static_branch(&(&shared_processor)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); });



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void spin_yield(arch_spinlock_t *lock)
{
 if (is_shared_processor())
  splpar_spin_yield(lock);
 else
  __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rw_yield(arch_rwlock_t *lock)
{
 if (is_shared_processor())
  splpar_rw_yield(lock);
 else
  __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_spin_lock(arch_spinlock_t *lock)
{
 while (1) {
  if (__builtin_expect(!!(__arch_spin_trylock(lock) == 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_spin_yield(lock);
  } while (__builtin_expect(!!(lock->slock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void arch_spin_lock_flags(arch_spinlock_t *lock, unsigned long flags)
{
 unsigned long flags_dis;

 while (1) {
  if (__builtin_expect(!!(__arch_spin_trylock(lock) == 0), 1))
   break;
  do { ({ unsigned long __dummy; typeof(flags_dis) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags_dis = arch_local_save_flags(); } while (0);
  do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_spin_yield(lock);
  } while (__builtin_expect(!!(lock->slock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
  do { do { ({ unsigned long __dummy; typeof(flags_dis) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags_dis); } while (0); } while (0);
 }
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_spin_unlock(arch_spinlock_t *lock)
{
 __asm__ __volatile__("# arch_spin_unlock\n\t"
    "lwsync" " " "\n": : :"memory");
 lock->slock = 0;
}
# 204 "/home/nathan/src/linux-next/arch/powerpc/include/asm/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __arch_read_trylock(arch_rwlock_t *rw)
{
 long tmp;

 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%1) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n"
 "extsw	%0,%0\n"
"	addic.		%0,%0,1\n	ble-		2f\n"


"	stwcx.		%0,0,%1\n	bne-		1b\n"

 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:" : "=&r" (tmp)
 : "r" (&rw->lock)
 : "cr0", "xer", "memory");

 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __arch_write_trylock(arch_rwlock_t *rw)
{
 long tmp, token;

 token = (*(u32 *)(&local_paca->lock_token));
 __asm__ __volatile__(
"1:	" ".long 0x7c000028 | (((%0) & 0x1f) << 21) | (((0) & 0x1f) << 16) | (((%2) & 0x1f) << 11) | (((1) & 0x1) << 0)" " " "\n	cmpwi		0,%0,0\n	bne-		2f\n"



"	stwcx.		%1,0,%2\n	bne-		1b\n"

 "\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " "
"2:" : "=&r" (tmp)
 : "r" (token), "r" (&rw->lock)
 : "cr0", "memory");

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_read_lock(arch_rwlock_t *rw)
{
 while (1) {
  if (__builtin_expect(!!(__arch_read_trylock(rw) > 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_rw_yield(rw);
  } while (__builtin_expect(!!(rw->lock < 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_write_lock(arch_rwlock_t *rw)
{
 while (1) {
  if (__builtin_expect(!!(__arch_write_trylock(rw) == 0), 1))
   break;
  do {
   asm volatile("or 1,1,1	     # low priority");
   if (is_shared_processor())
    splpar_rw_yield(rw);
  } while (__builtin_expect(!!(rw->lock != 0), 0));
  asm volatile("or 2,2,2	     # medium priority");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_read_trylock(arch_rwlock_t *rw)
{
 return __arch_read_trylock(rw) > 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_write_trylock(arch_rwlock_t *rw)
{
 return __arch_write_trylock(rw) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_read_unlock(arch_rwlock_t *rw)
{
 long tmp;

 __asm__ __volatile__(
 "# read_unlock\n\t"
 "lwsync" " " "\n"
"1:	lwarx		%0,0,%1\n	addic		%0,%0,-1\n"


"	stwcx.		%0,0,%1\n	bne-		1b"

 : "=&r"(tmp)
 : "r"(&rw->lock)
 : "cr0", "xer", "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_write_unlock(arch_rwlock_t *rw)
{
 __asm__ __volatile__("# write_unlock\n\t"
    "lwsync" " " "\n": : :"memory");
 rw->lock = 0;
}
# 90 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2
# 178 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_raw_spin_lock(raw_spinlock_t *lock)
{
 (void)0;
 arch_spin_lock(&lock->raw_lock);
 mmiowb_spin_lock();
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
do_raw_spin_lock_flags(raw_spinlock_t *lock, unsigned long *flags)
{
 (void)0;
 arch_spin_lock_flags(&lock->raw_lock, *flags);
 mmiowb_spin_lock();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int do_raw_spin_trylock(raw_spinlock_t *lock)
{
 int ret = arch_spin_trylock(&(lock)->raw_lock);

 if (ret)
  mmiowb_spin_lock();

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_raw_spin_unlock(raw_spinlock_t *lock)
{
 mmiowb_spin_unlock();
 arch_spin_unlock(&lock->raw_lock);
 (void)0;
}
# 310 "/home/nathan/src/linux-next/include/linux/spinlock.h"
# 1 "/home/nathan/src/linux-next/include/linux/rwlock.h" 1
# 311 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
int in_lock_functions(unsigned long addr);



void __attribute__((section(".spinlock.text"))) _raw_spin_lock(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)
                        ;
void __attribute__((section(".spinlock.text")))
_raw_spin_lock_nest_lock(raw_spinlock_t *lock, struct lockdep_map *map)
                        ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_bh(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_lock_irq(raw_spinlock_t *lock)
                        ;

unsigned long __attribute__((section(".spinlock.text"))) _raw_spin_lock_irqsave(raw_spinlock_t *lock)
                        ;
unsigned long __attribute__((section(".spinlock.text")))
_raw_spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass)
                        ;
int __attribute__((section(".spinlock.text"))) _raw_spin_trylock(raw_spinlock_t *lock);
int __attribute__((section(".spinlock.text"))) _raw_spin_trylock_bh(raw_spinlock_t *lock);
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock_bh(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_spin_unlock_irq(raw_spinlock_t *lock) ;
void __attribute__((section(".spinlock.text")))
_raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)
                        ;
# 86 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_spin_trylock(raw_spinlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (do_raw_spin_trylock(lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}
# 104 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
# 119 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h"
 do_raw_spin_lock_flags(lock, &flags);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock_irq(raw_spinlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do_raw_spin_lock(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock_bh(raw_spinlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do_raw_spin_lock(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_lock(raw_spinlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do_raw_spin_lock(lock);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,
         unsigned long flags)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_irq(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_spin_unlock_bh(raw_spinlock_t *lock)
{
 do { } while (0);
 do_raw_spin_unlock(lock);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_spin_trylock_bh(raw_spinlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 if (do_raw_spin_trylock(lock)) {
  do { } while (0);
  return 1;
 }
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 return 0;
}


# 1 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
void __attribute__((section(".spinlock.text"))) _raw_read_lock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_lock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_lock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_lock_irq(rwlock_t *lock) ;
unsigned long __attribute__((section(".spinlock.text"))) _raw_read_lock_irqsave(rwlock_t *lock)
                       ;
unsigned long __attribute__((section(".spinlock.text"))) _raw_write_lock_irqsave(rwlock_t *lock)
                       ;
int __attribute__((section(".spinlock.text"))) _raw_read_trylock(rwlock_t *lock);
int __attribute__((section(".spinlock.text"))) _raw_write_trylock(rwlock_t *lock);
void __attribute__((section(".spinlock.text"))) _raw_read_unlock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_unlock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock_bh(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_read_unlock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text"))) _raw_write_unlock_irq(rwlock_t *lock) ;
void __attribute__((section(".spinlock.text")))
_raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
                       ;
void __attribute__((section(".spinlock.text")))
_raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
                       ;
# 117 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_read_trylock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (arch_read_trylock(&(lock)->raw_lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __raw_write_trylock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 if (arch_write_trylock(&(lock)->raw_lock)) {
  do { } while (0);
  return 1;
 }
 __asm__ __volatile__("" : : : "memory");
 return 0;
}
# 146 "/home/nathan/src/linux-next/include/linux/rwlock_api_smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_read_lock_irqsave(rwlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&((lock))->raw_lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock_irq(rwlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_lock_bh(rwlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do {(void)0; arch_read_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_write_lock_irqsave(rwlock_t *lock)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&((lock))->raw_lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock_irq(rwlock_t *lock)
{
 do { arch_local_irq_disable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock_bh(rwlock_t *lock)
{
 __local_bh_disable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_lock(rwlock_t *lock)
{
 __asm__ __volatile__("" : : : "memory");
 do { } while (0);
 do {(void)0; arch_write_lock(&(lock)->raw_lock); } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock_irq(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_read_unlock_bh(rwlock_t *lock)
{
 do { } while (0);
 do {arch_read_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_irqrestore(rwlock_t *lock,
          unsigned long flags)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_irq(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 do { arch_local_irq_enable(); } while (0);
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_write_unlock_bh(rwlock_t *lock)
{
 do { } while (0);
 do {arch_write_unlock(&(lock)->raw_lock); (void)0; } while (0);
 __local_bh_enable_ip((unsigned long)__builtin_return_address(0), ((2 * (1UL << (0 + 8))) + 0));
}
# 191 "/home/nathan/src/linux-next/include/linux/spinlock_api_smp.h" 2
# 317 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
 return &lock->rlock;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock(spinlock_t *lock)
{
 _raw_spin_lock(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock_bh(spinlock_t *lock)
{
 _raw_spin_lock_bh(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock(spinlock_t *lock)
{
 return (_raw_spin_trylock(&lock->rlock));
}
# 361 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_lock_irq(spinlock_t *lock)
{
 _raw_spin_lock_irq(&lock->rlock);
}
# 376 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock(spinlock_t *lock)
{
 __raw_spin_unlock(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_bh(spinlock_t *lock)
{
 _raw_spin_unlock_bh(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_irq(spinlock_t *lock)
{
 __raw_spin_unlock_irq(&lock->rlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
 do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); _raw_spin_unlock_irqrestore(&lock->rlock, flags); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock_bh(spinlock_t *lock)
{
 return (_raw_spin_trylock_bh(&lock->rlock));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_trylock_irq(spinlock_t *lock)
{
 return ({ do { arch_local_irq_disable(); } while (0); (_raw_spin_trylock(&lock->rlock)) ? 1 : ({ do { arch_local_irq_enable(); } while (0); 0; }); });
}
# 429 "/home/nathan/src/linux-next/include/linux/spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_is_locked(spinlock_t *lock)
{
 return arch_spin_is_locked(&(&lock->rlock)->raw_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int spin_is_contended(spinlock_t *lock)
{
 return (((void)(&lock->rlock), 0));
}








# 1 "/home/nathan/src/linux-next/include/linux/atomic.h" 1
# 74 "/home/nathan/src/linux-next/include/linux/atomic.h"
# 1 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h" 1
# 79 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_read_acquire(const atomic_t *v)
{
 return ({ typeof(*&(v)->counter) ___p1 = ({ union { typeof(*&(v)->counter) __val; char __c[1]; } __u; if (1) __read_once_size(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); else __read_once_size_nocheck(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); do { } while (0); __u.__val; }); do { extern void __compiletime_assert_82(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_82(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_set_release(atomic_t *v, int i)
{
 do { do { extern void __compiletime_assert_91(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_91(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(v)->counter) __val; char __c[1]; } __u = { .__val = ( typeof(*&(v)->counter)) (i) }; __write_once_size(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); __u.__val; }); } while (0);
}
# 103 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_add_return_acquire(int i, atomic_t *v)
{
 int ret = atomic_add_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_add_return_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_add_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_add_return(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_add_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 145 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_add_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_add_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_add_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_add_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_add(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_add_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 187 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_sub_return_acquire(int i, atomic_t *v)
{
 int ret = atomic_sub_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_sub_return_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_sub_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_sub_return(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_sub_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 229 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_sub_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_sub_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_sub_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_sub_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_sub(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_sub_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 319 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_inc_return_acquire(atomic_t *v)
{
 int ret = atomic_inc_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_inc_return_release(atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_inc_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_inc_return(atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_inc_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 362 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_inc(atomic_t *v)
{
 return atomic_fetch_add(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_inc_acquire(atomic_t *v)
{
 return atomic_fetch_add_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_inc_release(atomic_t *v)
{
 return atomic_fetch_add_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_inc_relaxed(atomic_t *v)
{
 return atomic_fetch_add_relaxed(1, v);
}
# 490 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_dec_return_acquire(atomic_t *v)
{
 int ret = atomic_dec_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_dec_return_release(atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_dec_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_dec_return(atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_dec_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 533 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_dec(atomic_t *v)
{
 return atomic_fetch_sub(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_dec_acquire(atomic_t *v)
{
 return atomic_fetch_sub_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_dec_release(atomic_t *v)
{
 return atomic_fetch_sub_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_dec_relaxed(atomic_t *v)
{
 return atomic_fetch_sub_relaxed(1, v);
}
# 613 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_and_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_and_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_and_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_and_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_and(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_and_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_andnot(int i, atomic_t *v)
{
 atomic_and(~i, v);
}
# 665 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_andnot(int i, atomic_t *v)
{
 return atomic_fetch_and(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_andnot_acquire(int i, atomic_t *v)
{
 return atomic_fetch_and_acquire(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_andnot_release(int i, atomic_t *v)
{
 return atomic_fetch_and_release(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_andnot_relaxed(int i, atomic_t *v)
{
 return atomic_fetch_and_relaxed(~i, v);
}
# 745 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_or_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_or_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_or_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_or_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_or(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_or_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 787 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_xor_acquire(int i, atomic_t *v)
{
 int ret = atomic_fetch_xor_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_xor_release(int i, atomic_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic_fetch_xor_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_fetch_xor(int i, atomic_t *v)
{
 int ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic_fetch_xor_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 829 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_xchg_acquire(atomic_t *v, int i)
{
 int ret = ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_xchg_release(atomic_t *v, int i)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}
# 882 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
atomic_cmpxchg_release(atomic_t *v, int old, int new)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}
# 914 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_try_cmpxchg(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = (({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_try_cmpxchg_acquire(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_try_cmpxchg_release(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = atomic_cmpxchg_release(v, o, new);
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_try_cmpxchg_relaxed(atomic_t *v, int *old, int new)
{
 int r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}
# 1013 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_sub_and_test(int i, atomic_t *v)
{
 return atomic_sub_return(i, v) == 0;
}
# 1030 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_dec_and_test(atomic_t *v)
{
 return atomic_dec_return(v) == 0;
}
# 1047 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_inc_and_test(atomic_t *v)
{
 return atomic_inc_return(v) == 0;
}
# 1065 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_add_negative(int i, atomic_t *v)
{
 return atomic_add_return(i, v) < 0;
}
# 1108 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_add_unless(atomic_t *v, int a, int u)
{
 return atomic_fetch_add_unless(v, a, u) != u;
}
# 1133 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_inc_unless_negative(atomic_t *v)
{
 int c = atomic_read(v);

 do {
  if (__builtin_expect(!!(c < 0), 0))
   return false;
 } while (!atomic_try_cmpxchg(v, &c, c + 1));

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_dec_unless_positive(atomic_t *v)
{
 int c = atomic_read(v);

 do {
  if (__builtin_expect(!!(c > 0), 0))
   return false;
 } while (!atomic_try_cmpxchg(v, &c, c - 1));

 return true;
}
# 1189 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_read_acquire(const atomic64_t *v)
{
 return ({ typeof(*&(v)->counter) ___p1 = ({ union { typeof(*&(v)->counter) __val; char __c[1]; } __u; if (1) __read_once_size(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); else __read_once_size_nocheck(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); do { } while (0); __u.__val; }); do { extern void __compiletime_assert_1192(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_1192(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic64_set_release(atomic64_t *v, s64 i)
{
 do { do { extern void __compiletime_assert_1201(void) ; if (!((sizeof(*&(v)->counter) == sizeof(char) || sizeof(*&(v)->counter) == sizeof(short) || sizeof(*&(v)->counter) == sizeof(int) || sizeof(*&(v)->counter) == sizeof(long)))) __compiletime_assert_1201(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(v)->counter) __val; char __c[1]; } __u = { .__val = ( typeof(*&(v)->counter)) (i) }; __write_once_size(&(*&(v)->counter), __u.__c, sizeof(*&(v)->counter)); __u.__val; }); } while (0);
}
# 1213 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_add_return_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_add_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_add_return_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_add_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_add_return(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_add_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1255 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_add_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_add_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_add_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_add_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_add(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_add_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1297 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_sub_return_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_sub_return_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_sub_return_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_sub_return_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_sub_return(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_sub_return_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1339 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_sub_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_sub_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_sub_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_sub_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_sub(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_sub_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1429 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_inc_return_acquire(atomic64_t *v)
{
 s64 ret = atomic64_inc_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_inc_return_release(atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_inc_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_inc_return(atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_inc_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1472 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_inc(atomic64_t *v)
{
 return atomic64_fetch_add(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_inc_acquire(atomic64_t *v)
{
 return atomic64_fetch_add_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_inc_release(atomic64_t *v)
{
 return atomic64_fetch_add_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_inc_relaxed(atomic64_t *v)
{
 return atomic64_fetch_add_relaxed(1, v);
}
# 1600 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_dec_return_acquire(atomic64_t *v)
{
 s64 ret = atomic64_dec_return_relaxed(v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_dec_return_release(atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_dec_return_relaxed(v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_dec_return(atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_dec_return_relaxed(v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1643 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_dec(atomic64_t *v)
{
 return atomic64_fetch_sub(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_dec_acquire(atomic64_t *v)
{
 return atomic64_fetch_sub_acquire(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_dec_release(atomic64_t *v)
{
 return atomic64_fetch_sub_release(1, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_dec_relaxed(atomic64_t *v)
{
 return atomic64_fetch_sub_relaxed(1, v);
}
# 1723 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_and_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_and_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_and_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_and_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_and(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_and_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic64_andnot(s64 i, atomic64_t *v)
{
 atomic64_and(~i, v);
}
# 1775 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_andnot(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_andnot_acquire(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_acquire(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_andnot_release(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_release(~i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_andnot_relaxed(s64 i, atomic64_t *v)
{
 return atomic64_fetch_and_relaxed(~i, v);
}
# 1855 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_or_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_or_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_or_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_or_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_or(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_or_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1897 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_xor_acquire(s64 i, atomic64_t *v)
{
 s64 ret = atomic64_fetch_xor_relaxed(i, v);
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_xor_release(s64 i, atomic64_t *v)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return atomic64_fetch_xor_relaxed(i, v);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_fetch_xor(s64 i, atomic64_t *v)
{
 s64 ret;
 __asm__ __volatile__ ("sync" : : : "memory");
 ret = atomic64_fetch_xor_relaxed(i, v);
 __asm__ __volatile__ ("sync" : : : "memory");
 return ret;
}
# 1939 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_xchg_acquire(atomic64_t *v, s64 i)
{
 s64 ret = ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
 __asm__ __volatile__("\n" "971:; isync; 972: .pushsection __lwsync_fixup,\"a\"; .align 2; 973: .8byte 971b-973b; .popsection;;" " " "" : : : "memory");
 return ret;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_xchg_release(atomic64_t *v, s64 i)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}
# 1992 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64
atomic64_cmpxchg_release(atomic64_t *v, s64 old, s64 new)
{
 __asm__ __volatile__("lwsync" " " "\n" "" : : : "memory");
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}
# 2024 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_try_cmpxchg(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = (({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_try_cmpxchg_acquire(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_try_cmpxchg_release(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = atomic64_cmpxchg_release(v, o, new);
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_try_cmpxchg_relaxed(atomic64_t *v, s64 *old, s64 new)
{
 s64 r, o = *old;
 r = ({ __typeof__(*(&((v)->counter))) _o_ = ((o)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
 if (__builtin_expect(!!(r != o), 0))
  *old = r;
 return __builtin_expect(!!(r == o), 1);
}
# 2123 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_sub_and_test(s64 i, atomic64_t *v)
{
 return atomic64_sub_return(i, v) == 0;
}
# 2140 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_dec_and_test(atomic64_t *v)
{
 return atomic64_dec_return(v) == 0;
}
# 2157 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_inc_and_test(atomic64_t *v)
{
 return atomic64_inc_return(v) == 0;
}
# 2175 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_add_negative(s64 i, atomic64_t *v)
{
 return atomic64_add_return(i, v) < 0;
}
# 2218 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_add_unless(atomic64_t *v, s64 a, s64 u)
{
 return atomic64_fetch_add_unless(v, a, u) != u;
}
# 2243 "/home/nathan/src/linux-next/include/linux/atomic-fallback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_inc_unless_negative(atomic64_t *v)
{
 s64 c = atomic64_read(v);

 do {
  if (__builtin_expect(!!(c < 0), 0))
   return false;
 } while (!atomic64_try_cmpxchg(v, &c, c + 1));

 return true;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic64_dec_unless_positive(atomic64_t *v)
{
 s64 c = atomic64_read(v);

 do {
  if (__builtin_expect(!!(c > 0), 0))
   return false;
 } while (!atomic64_try_cmpxchg(v, &c, c - 1));

 return true;
}
# 75 "/home/nathan/src/linux-next/include/linux/atomic.h" 2

# 1 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h" 1
# 12 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
# 25 "/home/nathan/src/linux-next/include/asm-generic/atomic-long.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_read(const atomic_long_t *v)
{
 return atomic64_read(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_read_acquire(const atomic_long_t *v)
{
 return atomic64_read_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_set(atomic_long_t *v, long i)
{
 atomic64_set(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_set_release(atomic_long_t *v, long i)
{
 atomic64_set_release(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_add(long i, atomic_long_t *v)
{
 atomic64_add(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_add_return(long i, atomic_long_t *v)
{
 return atomic64_add_return(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_add_return_acquire(long i, atomic_long_t *v)
{
 return atomic64_add_return_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_add_return_release(long i, atomic_long_t *v)
{
 return atomic64_add_return_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_add_return_relaxed(long i, atomic_long_t *v)
{
 return atomic64_add_return_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_add(long i, atomic_long_t *v)
{
 return atomic64_fetch_add(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_add_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_add_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_sub(long i, atomic_long_t *v)
{
 atomic64_sub(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_sub_return(long i, atomic_long_t *v)
{
 return atomic64_sub_return(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_sub_return_acquire(long i, atomic_long_t *v)
{
 return atomic64_sub_return_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_sub_return_release(long i, atomic_long_t *v)
{
 return atomic64_sub_return_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
{
 return atomic64_sub_return_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_sub(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_sub_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_sub_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_inc(atomic_long_t *v)
{
 atomic64_inc(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_inc_return(atomic_long_t *v)
{
 return atomic64_inc_return(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_inc_return_acquire(atomic_long_t *v)
{
 return atomic64_inc_return_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_inc_return_release(atomic_long_t *v)
{
 return atomic64_inc_return_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_inc_return_relaxed(atomic_long_t *v)
{
 return atomic64_inc_return_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_inc(atomic_long_t *v)
{
 return atomic64_fetch_inc(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_inc_acquire(atomic_long_t *v)
{
 return atomic64_fetch_inc_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_inc_release(atomic_long_t *v)
{
 return atomic64_fetch_inc_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_inc_relaxed(atomic_long_t *v)
{
 return atomic64_fetch_inc_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_dec(atomic_long_t *v)
{
 atomic64_dec(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_dec_return(atomic_long_t *v)
{
 return atomic64_dec_return(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_dec_return_acquire(atomic_long_t *v)
{
 return atomic64_dec_return_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_dec_return_release(atomic_long_t *v)
{
 return atomic64_dec_return_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_dec_return_relaxed(atomic_long_t *v)
{
 return atomic64_dec_return_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_dec(atomic_long_t *v)
{
 return atomic64_fetch_dec(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_dec_acquire(atomic_long_t *v)
{
 return atomic64_fetch_dec_acquire(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_dec_release(atomic_long_t *v)
{
 return atomic64_fetch_dec_release(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_dec_relaxed(atomic_long_t *v)
{
 return atomic64_fetch_dec_relaxed(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_and(long i, atomic_long_t *v)
{
 atomic64_and(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_and(long i, atomic_long_t *v)
{
 return atomic64_fetch_and(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_and_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_and_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_and_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_and_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_andnot(long i, atomic_long_t *v)
{
 atomic64_andnot(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_andnot(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_andnot_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_andnot_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_andnot_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_or(long i, atomic_long_t *v)
{
 atomic64_or(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_or(long i, atomic_long_t *v)
{
 return atomic64_fetch_or(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_or_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_or_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_or_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_or_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
atomic_long_xor(long i, atomic_long_t *v)
{
 atomic64_xor(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_xor(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_xor_acquire(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_acquire(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_xor_release(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_release(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_xor_relaxed(long i, atomic_long_t *v)
{
 return atomic64_fetch_xor_relaxed(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_xchg(atomic_long_t *v, long i)
{
 return (({ typeof(({ __typeof__(*(&((v)->counter))) _x_ = (i); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&((v)->counter))) _x_ = (i); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_xchg_acquire(atomic_long_t *v, long i)
{
 return atomic64_xchg_acquire(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_xchg_release(atomic_long_t *v, long i)
{
 return atomic64_xchg_release(v, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_xchg_relaxed(atomic_long_t *v, long i)
{
 return ({ __typeof__(*(&((v)->counter))) _x_ = ((i)); (__typeof__(*(&((v)->counter)))) __xchg_relaxed((&((v)->counter)), (unsigned long)_x_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_cmpxchg(atomic_long_t *v, long old, long new)
{
 return (({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_cmpxchg_acquire(atomic_long_t *v, long old, long new)
{
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_acquire((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_cmpxchg_release(atomic_long_t *v, long old, long new)
{
 return atomic64_cmpxchg_release(v, old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_cmpxchg_relaxed(atomic_long_t *v, long old, long new)
{
 return ({ __typeof__(*(&((v)->counter))) _o_ = ((old)); __typeof__(*(&((v)->counter))) _n_ = ((new)); (__typeof__(*(&((v)->counter)))) __cmpxchg_relaxed((&((v)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((v)->counter)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_try_cmpxchg_acquire(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_acquire(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_try_cmpxchg_release(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_release(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_try_cmpxchg_relaxed(atomic_long_t *v, long *old, long new)
{
 return atomic64_try_cmpxchg_relaxed(v, (s64 *)old, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_sub_and_test(long i, atomic_long_t *v)
{
 return atomic64_sub_and_test(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_dec_and_test(atomic_long_t *v)
{
 return atomic64_dec_and_test(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_inc_and_test(atomic_long_t *v)
{
 return atomic64_inc_and_test(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_add_negative(long i, atomic_long_t *v)
{
 return atomic64_add_negative(i, v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u)
{
 return atomic64_fetch_add_unless(v, a, u);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_add_unless(atomic_long_t *v, long a, long u)
{
 return atomic64_add_unless(v, a, u);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_inc_not_zero(atomic_long_t *v)
{
 return atomic64_inc_not_zero((v));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_inc_unless_negative(atomic_long_t *v)
{
 return atomic64_inc_unless_negative(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
atomic_long_dec_unless_positive(atomic_long_t *v)
{
 return atomic64_dec_unless_positive(v);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
atomic_long_dec_if_positive(atomic_long_t *v)
{
 return atomic64_dec_if_positive(v);
}
# 77 "/home/nathan/src/linux-next/include/linux/atomic.h" 2
# 446 "/home/nathan/src/linux-next/include/linux/spinlock.h" 2








extern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);



extern int _atomic_dec_and_lock_irqsave(atomic_t *atomic, spinlock_t *lock,
     unsigned long *flags);



int __alloc_bucket_spinlocks(spinlock_t **locks, unsigned int *lock_mask,
        size_t max_size, unsigned int cpu_mult,
        gfp_t gfp, const char *name,
        struct lock_class_key *key);
# 478 "/home/nathan/src/linux-next/include/linux/spinlock.h"
void free_bucket_spinlocks(spinlock_t *locks);
# 37 "/home/nathan/src/linux-next/include/linux/seqlock.h" 2
# 48 "/home/nathan/src/linux-next/include/linux/seqlock.h"
typedef struct seqcount {
 unsigned sequence;



} seqcount_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __seqcount_init(seqcount_t *s, const char *name,
       struct lock_class_key *key)
{



 do { (void)(name); (void)(key); } while (0);
 s->sequence = 0;
}
# 108 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned __read_seqcount_begin(const seqcount_t *s)
{
 unsigned ret;

repeat:
 ret = ({ union { typeof(s->sequence) __val; char __c[1]; } __u; if (1) __read_once_size(&(s->sequence), __u.__c, sizeof(s->sequence)); else __read_once_size_nocheck(&(s->sequence), __u.__c, sizeof(s->sequence)); do { } while (0); __u.__val; });
 if (__builtin_expect(!!(ret & 1), 0)) {
  do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
  goto repeat;
 }
 return ret;
}
# 130 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_read_seqcount(const seqcount_t *s)
{
 unsigned ret = ({ union { typeof(s->sequence) __val; char __c[1]; } __u; if (1) __read_once_size(&(s->sequence), __u.__c, sizeof(s->sequence)); else __read_once_size_nocheck(&(s->sequence), __u.__c, sizeof(s->sequence)); do { } while (0); __u.__val; });
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return ret;
}
# 146 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_read_seqcount_begin(const seqcount_t *s)
{
 unsigned ret = __read_seqcount_begin(s);
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return ret;
}
# 162 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqcount_begin(const seqcount_t *s)
{
                                  ;
 return raw_read_seqcount_begin(s);
}
# 182 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned raw_seqcount_begin(const seqcount_t *s)
{
 unsigned ret = ({ union { typeof(s->sequence) __val; char __c[1]; } __u; if (1) __read_once_size(&(s->sequence), __u.__c, sizeof(s->sequence)); else __read_once_size_nocheck(&(s->sequence), __u.__c, sizeof(s->sequence)); do { } while (0); __u.__val; });
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return ret & ~1;
}
# 203 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __read_seqcount_retry(const seqcount_t *s, unsigned start)
{
 return __builtin_expect(!!(s->sequence != start), 0);
}
# 218 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int read_seqcount_retry(const seqcount_t *s, unsigned start)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 return __read_seqcount_retry(s, start);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_begin(seqcount_t *s)
{
 s->sequence++;
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_end(seqcount_t *s)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 s->sequence++;
}
# 272 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_barrier(seqcount_t *s)
{
 s->sequence++;
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 s->sequence++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int raw_read_seqcount_latch(seqcount_t *s)
{

 int seq = ({ union { typeof(s->sequence) __val; char __c[1]; } __u; if (1) __read_once_size(&(s->sequence), __u.__c, sizeof(s->sequence)); else __read_once_size_nocheck(&(s->sequence), __u.__c, sizeof(s->sequence)); do { } while (0); __u.__val; });
 return seq;
}
# 363 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void raw_write_seqcount_latch(seqcount_t *s)
{
       __asm__ __volatile__ ("lwsync" " " : : :"memory");
       s->sequence++;
       __asm__ __volatile__ ("lwsync" " " : : :"memory");
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_begin_nested(seqcount_t *s, int subclass)
{
 raw_write_seqcount_begin(s);
 do { } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_begin(seqcount_t *s)
{
 write_seqcount_begin_nested(s, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_end(seqcount_t *s)
{
 do { } while (0);
 raw_write_seqcount_end(s);
}
# 398 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqcount_invalidate(seqcount_t *s)
{
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 s->sequence+=2;
}

typedef struct {
 struct seqcount seqcount;
 spinlock_t lock;
} seqlock_t;
# 431 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqbegin(const seqlock_t *sl)
{
 return read_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned read_seqretry(const seqlock_t *sl, unsigned start)
{
 return read_seqcount_retry(&sl->seqcount, start);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock(seqlock_t *sl)
{
 spin_lock(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock_bh(seqlock_t *sl)
{
 spin_lock_bh(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock_bh(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_seqlock_irq(seqlock_t *sl)
{
 spin_lock_irq(&sl->lock);
 write_seqcount_begin(&sl->seqcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_sequnlock_irq(seqlock_t *sl)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __write_seqlock_irqsave(seqlock_t *sl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(spinlock_check(&sl->lock)); } while (0); } while (0);
 write_seqcount_begin(&sl->seqcount);
 return flags;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
write_sequnlock_irqrestore(seqlock_t *sl, unsigned long flags)
{
 write_seqcount_end(&sl->seqcount);
 spin_unlock_irqrestore(&sl->lock, flags);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl(seqlock_t *sl)
{
 spin_lock(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl(seqlock_t *sl)
{
 spin_unlock(&sl->lock);
}
# 526 "/home/nathan/src/linux-next/include/linux/seqlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqbegin_or_lock(seqlock_t *lock, int *seq)
{
 if (!(*seq & 1))
  *seq = read_seqbegin(lock);
 else
  read_seqlock_excl(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int need_seqretry(seqlock_t *lock, int seq)
{
 return !(seq & 1) && read_seqretry(lock, seq);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void done_seqretry(seqlock_t *lock, int seq)
{
 if (seq & 1)
  read_sequnlock_excl(lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl_bh(seqlock_t *sl)
{
 spin_lock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl_bh(seqlock_t *sl)
{
 spin_unlock_bh(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_seqlock_excl_irq(seqlock_t *sl)
{
 spin_lock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void read_sequnlock_excl_irq(seqlock_t *sl)
{
 spin_unlock_irq(&sl->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __read_seqlock_excl_irqsave(seqlock_t *sl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(spinlock_check(&sl->lock)); } while (0); } while (0);
 return flags;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
read_sequnlock_excl_irqrestore(seqlock_t *sl, unsigned long flags)
{
 spin_unlock_irqrestore(&sl->lock, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
read_seqbegin_or_lock_irqsave(seqlock_t *lock, int *seq)
{
 unsigned long flags = 0;

 if (!(*seq & 1))
  *seq = read_seqbegin(lock);
 else
  do { flags = __read_seqlock_excl_irqsave(lock); } while (0);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
done_seqretry_irqrestore(seqlock_t *lock, int seq, unsigned long flags)
{
 if (seq & 1)
  read_sequnlock_excl_irqrestore(lock, flags);
}
# 7 "/home/nathan/src/linux-next/include/linux/time.h" 2



extern struct timezone sys_tz;

int get_timespec64(struct timespec64 *ts,
  const struct __kernel_timespec *uts);
int put_timespec64(const struct timespec64 *ts,
  struct __kernel_timespec *uts);
int get_itimerspec64(struct itimerspec64 *it,
   const struct __kernel_itimerspec *uit);
int put_itimerspec64(const struct itimerspec64 *it,
   struct __kernel_itimerspec *uit);

extern time64_t mktime64(const unsigned int year, const unsigned int mon,
   const unsigned int day, const unsigned int hour,
   const unsigned int min, const unsigned int sec);
# 39 "/home/nathan/src/linux-next/include/linux/time.h"
extern void clear_itimer(void);




extern long do_utimes(int dfd, const char *filename, struct timespec64 *times, int flags);





struct tm {




 int tm_sec;

 int tm_min;

 int tm_hour;

 int tm_mday;

 int tm_mon;

 long tm_year;

 int tm_wday;

 int tm_yday;
};

void time64_to_tm(time64_t totalsecs, int offset, struct tm *result);


# 1 "/home/nathan/src/linux-next/include/linux/time32.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/time32.h"
# 1 "/home/nathan/src/linux-next/include/linux/timex.h" 1
# 56 "/home/nathan/src/linux-next/include/linux/timex.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/timex.h" 1
# 56 "/home/nathan/src/linux-next/include/uapi/linux/timex.h"
# 1 "/home/nathan/src/linux-next/include/linux/time.h" 1
# 57 "/home/nathan/src/linux-next/include/uapi/linux/timex.h" 2
# 97 "/home/nathan/src/linux-next/include/uapi/linux/timex.h"
struct __kernel_timex_timeval {
 __kernel_time64_t tv_sec;
 long long tv_usec;
};

struct __kernel_timex {
 unsigned int modes;
 int :32;
 long long offset;
 long long freq;
 long long maxerror;
 long long esterror;
 int status;
 int :32;
 long long constant;
 long long precision;
 long long tolerance;


 struct __kernel_timex_timeval time;
 long long tick;

 long long ppsfreq;
 long long jitter;
 int shift;
 int :32;
 long long stabil;
 long long jitcnt;
 long long calcnt;
 long long errcnt;
 long long stbcnt;

 int tai;

 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32;
};
# 57 "/home/nathan/src/linux-next/include/linux/timex.h" 2






# 1 "/home/nathan/src/linux-next/include/uapi/linux/param.h" 1




# 1 "./arch/powerpc/include/generated/uapi/asm/param.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/param.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/param.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/param.h" 2
# 2 "./arch/powerpc/include/generated/uapi/asm/param.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/param.h" 2
# 64 "/home/nathan/src/linux-next/include/linux/timex.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/timex.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/timex.h"
typedef unsigned long cycles_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) cycles_t get_cycles(void)
{
 if (0)
  return 0;

 return ({unsigned long rval; asm volatile( "90:	mfspr %0, %2;\n" "971:" " " "97:	cmpwi %0,0;\n" "	beq- 90b;\n" "; " "972: .pushsection __ftr_alt_97,\"a\"; .align 2; 973:" " " "" "; " "974: .popsection; .pushsection __ftr_fixup,\"a\"; .align 3; 975: .8byte ((%1)); .8byte ((%1)); .8byte 971b-975b; .8byte 972b-975b; .8byte 973b-975b; .8byte 974b-975b; .ifgt (974b- 973b)-(972b- 971b); .error \"Feature section else case larger than body\"; .endif; .popsection;" " " : "=r" (rval) : "i" (0x0000000000800000UL), "i" (0x10C) : "cr0"); rval;});
}
# 66 "/home/nathan/src/linux-next/include/linux/timex.h" 2
# 139 "/home/nathan/src/linux-next/include/linux/timex.h"
extern unsigned long tick_usec;
extern unsigned long tick_nsec;
# 154 "/home/nathan/src/linux-next/include/linux/timex.h"
extern int do_adjtimex(struct __kernel_timex *);
extern int do_clock_adjtime(const clockid_t which_clock, struct __kernel_timex * ktx);

extern void hardpps(const struct timespec64 *, const struct timespec64 *);

int read_current_timer(unsigned long *timer_val);
void ntp_notify_cmos_timer(void);
# 14 "/home/nathan/src/linux-next/include/linux/time32.h" 2



typedef s32 old_time32_t;

struct old_timespec32 {
 old_time32_t tv_sec;
 s32 tv_nsec;
};

struct old_timeval32 {
 old_time32_t tv_sec;
 s32 tv_usec;
};

struct old_itimerspec32 {
 struct old_timespec32 it_interval;
 struct old_timespec32 it_value;
};

struct old_utimbuf32 {
 old_time32_t actime;
 old_time32_t modtime;
};

struct old_timex32 {
 u32 modes;
 s32 offset;
 s32 freq;
 s32 maxerror;
 s32 esterror;
 s32 status;
 s32 constant;
 s32 precision;
 s32 tolerance;
 struct old_timeval32 time;
 s32 tick;
 s32 ppsfreq;
 s32 jitter;
 s32 shift;
 s32 stabil;
 s32 jitcnt;
 s32 calcnt;
 s32 errcnt;
 s32 stbcnt;
 s32 tai;

 s32:32; s32:32; s32:32; s32:32;
 s32:32; s32:32; s32:32; s32:32;
 s32:32; s32:32; s32:32;
};

extern int get_old_timespec32(struct timespec64 *, const void *);
extern int put_old_timespec32(const struct timespec64 *, void *);
extern int get_old_itimerspec32(struct itimerspec64 *its,
   const struct old_itimerspec32 *uits);
extern int put_old_itimerspec32(const struct itimerspec64 *its,
   struct old_itimerspec32 *uits);
struct __kernel_timex;
int get_old_timex32(struct __kernel_timex *, const struct old_timex32 *);
int put_old_timex32(struct old_timex32 *, const struct __kernel_timex *);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec timespec64_to_timespec(const struct timespec64 ts64)
{
 return *(const struct timespec *)&ts64;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct timespec64 timespec_to_timespec64(const struct timespec ts)
{
 return *(const struct timespec64 *)&ts;
}
# 109 "/home/nathan/src/linux-next/include/linux/time32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec_equal(const struct timespec *a,
     const struct timespec *b)
{
 return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timespec_compare(const struct timespec *lhs, const struct timespec *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_nsec - rhs->tv_nsec;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timespec_valid(const struct timespec *ts)
{

 if (ts->tv_sec < 0)
  return false;

 if ((unsigned long)ts->tv_nsec >= 1000000000L)
  return false;
 return true;
}
# 150 "/home/nathan/src/linux-next/include/linux/time32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 timespec_to_ns(const struct timespec *ts)
{
 return ((s64) ts->tv_sec * 1000000000L) + ts->tv_nsec;
}







extern struct timespec ns_to_timespec(const s64 nsec);
# 171 "/home/nathan/src/linux-next/include/linux/time32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void timespec_add_ns(struct timespec *a, u64 ns)
{
 a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, 1000000000L, &ns);
 a->tv_nsec = ns;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long mktime(const unsigned int year,
   const unsigned int mon, const unsigned int day,
   const unsigned int hour, const unsigned int min,
   const unsigned int sec)
{
 return mktime64(year, mon, day, hour, min, sec);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timeval_valid(const struct timeval *tv)
{

 if (tv->tv_sec < 0)
  return false;


 if (tv->tv_usec < 0 || tv->tv_usec >= 1000000L)
  return false;

 return true;
}
# 205 "/home/nathan/src/linux-next/include/linux/time32.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 timeval_to_ns(const struct timeval *tv)
{
 return ((s64) tv->tv_sec * 1000000000L) +
  tv->tv_usec * 1000L;
}







extern struct timeval ns_to_timeval(const s64 nsec);
extern struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec);
# 75 "/home/nathan/src/linux-next/include/linux/time.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool itimerspec64_valid(const struct itimerspec64 *its)
{
 if (!timespec64_valid(&(its->it_interval)) ||
  !timespec64_valid(&(its->it_value)))
  return false;

 return true;
}
# 114 "/home/nathan/src/linux-next/include/linux/time.h"
struct timens_offset {
 s64 sec;
 u64 nsec;
};
# 20 "/home/nathan/src/linux-next/include/linux/stat.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/uidgid.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/uidgid.h"
# 1 "/home/nathan/src/linux-next/include/linux/highuid.h" 1
# 35 "/home/nathan/src/linux-next/include/linux/highuid.h"
extern int overflowuid;
extern int overflowgid;

extern void __bad_uid(void);
extern void __bad_gid(void);
# 82 "/home/nathan/src/linux-next/include/linux/highuid.h"
extern int fs_overflowuid;
extern int fs_overflowgid;
# 17 "/home/nathan/src/linux-next/include/linux/uidgid.h" 2

struct user_namespace;
extern struct user_namespace init_user_ns;

typedef struct {
 uid_t val;
} kuid_t;


typedef struct {
 gid_t val;
} kgid_t;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t __kuid_val(kuid_t uid)
{
 return uid.val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t __kgid_val(kgid_t gid)
{
 return gid.val;
}
# 61 "/home/nathan/src/linux-next/include/linux/uidgid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_eq(kuid_t left, kuid_t right)
{
 return __kuid_val(left) == __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_eq(kgid_t left, kgid_t right)
{
 return __kgid_val(left) == __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_gt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) > __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_gt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) > __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_gte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) >= __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_gte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) >= __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_lt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) < __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_lt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) < __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_lte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) <= __kuid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_lte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) <= __kgid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uid_valid(kuid_t uid)
{
 return __kuid_val(uid) != (uid_t) -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gid_valid(kgid_t gid)
{
 return __kgid_val(gid) != (gid_t) -1;
}
# 143 "/home/nathan/src/linux-next/include/linux/uidgid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kuid_t make_kuid(struct user_namespace *from, uid_t uid)
{
 return (kuid_t){ uid };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kgid_t make_kgid(struct user_namespace *from, gid_t gid)
{
 return (kgid_t){ gid };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t from_kuid(struct user_namespace *to, kuid_t kuid)
{
 return __kuid_val(kuid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t from_kgid(struct user_namespace *to, kgid_t kgid)
{
 return __kgid_val(kgid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t from_kuid_munged(struct user_namespace *to, kuid_t kuid)
{
 uid_t uid = from_kuid(to, kuid);
 if (uid == (uid_t)-1)
  uid = overflowuid;
 return uid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t from_kgid_munged(struct user_namespace *to, kgid_t kgid)
{
 gid_t gid = from_kgid(to, kgid);
 if (gid == (gid_t)-1)
  gid = overflowgid;
 return gid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
{
 return uid_valid(uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
{
 return gid_valid(gid);
}
# 21 "/home/nathan/src/linux-next/include/linux/stat.h" 2



struct kstat {
 u32 result_mask;
 umode_t mode;
 unsigned int nlink;
 uint32_t blksize;
 u64 attributes;
 u64 attributes_mask;
# 39 "/home/nathan/src/linux-next/include/linux/stat.h"
 u64 ino;
 dev_t dev;
 dev_t rdev;
 kuid_t uid;
 kgid_t gid;
 loff_t size;
 struct timespec64 atime;
 struct timespec64 mtime;
 struct timespec64 ctime;
 struct timespec64 btime;
 u64 blocks;
};
# 14 "/home/nathan/src/linux-next/include/linux/module.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/kmod.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/umh.h" 1



# 1 "/home/nathan/src/linux-next/include/linux/gfp.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/mmzone.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/mmzone.h"
# 1 "/home/nathan/src/linux-next/include/linux/wait.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/wait.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/wait.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/wait.h" 2

typedef struct wait_queue_entry wait_queue_entry_t;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);
int default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);
# 27 "/home/nathan/src/linux-next/include/linux/wait.h"
struct wait_queue_entry {
 unsigned int flags;
 void *private;
 wait_queue_func_t func;
 struct list_head entry;
};

struct wait_queue_head {
 spinlock_t lock;
 struct list_head head;
};
typedef struct wait_queue_head wait_queue_head_t;

struct task_struct;
# 61 "/home/nathan/src/linux-next/include/linux/wait.h"
extern void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *);
# 79 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struct task_struct *p)
{
 wq_entry->flags = 0;
 wq_entry->private = p;
 wq_entry->func = default_wake_function;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
init_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t func)
{
 wq_entry->flags = 0;
 wq_entry->private = ((void *)0);
 wq_entry->func = func;
}
# 124 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int waitqueue_active(struct wait_queue_head *wq_head)
{
 return !list_empty(&wq_head->head);
}
# 137 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wq_has_single_sleeper(struct wait_queue_head *wq_head)
{
 return list_is_singular(&wq_head->head);
}
# 150 "/home/nathan/src/linux-next/include/linux/wait.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wq_has_sleeper(struct wait_queue_head *wq_head)
{







 __asm__ __volatile__ ("sync" : : : "memory");
 return waitqueue_active(wq_head);
}

extern void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
extern void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
extern void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_add(&wq_entry->entry, &wq_head->head);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 wq_entry->flags |= 0x01;
 __add_wait_queue(wq_head, wq_entry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_add_tail(&wq_entry->entry, &wq_head->head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__add_wait_queue_entry_tail_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 wq_entry->flags |= 0x01;
 __add_wait_queue_entry_tail(wq_head, wq_entry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
{
 list_del(&wq_entry->entry);
}

void __wake_up(struct wait_queue_head *wq_head, unsigned int mode, int nr, void *key);
void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,
  unsigned int mode, void *key, wait_queue_entry_t *bookmark);
void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);
void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr);
void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode);
# 248 "/home/nathan/src/linux-next/include/linux/wait.h"
extern void init_wait_entry(struct wait_queue_entry *wq_entry, int flags);
# 732 "/home/nathan/src/linux-next/include/linux/wait.h"
extern int do_wait_intr(wait_queue_head_t *, wait_queue_entry_t *);
extern int do_wait_intr_irq(wait_queue_head_t *, wait_queue_entry_t *);
# 1126 "/home/nathan/src/linux-next/include/linux/wait.h"
void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout);
int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
# 11 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/numa.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/nodemask.h" 1
# 95 "/home/nathan/src/linux-next/include/linux/nodemask.h"
# 1 "/home/nathan/src/linux-next/include/linux/bitmap.h" 1
# 115 "/home/nathan/src/linux-next/include/linux/bitmap.h"
extern unsigned long *bitmap_alloc(unsigned int nbits, gfp_t flags);
extern unsigned long *bitmap_zalloc(unsigned int nbits, gfp_t flags);
extern void bitmap_free(const unsigned long *bitmap);





extern int __bitmap_empty(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_full(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_equal(const unsigned long *bitmap1,
     const unsigned long *bitmap2, unsigned int nbits);
extern bool __attribute__((__pure__)) __bitmap_or_equal(const unsigned long *src1,
         const unsigned long *src2,
         const unsigned long *src3,
         unsigned int nbits);
extern void __bitmap_complement(unsigned long *dst, const unsigned long *src,
   unsigned int nbits);
extern void __bitmap_shift_right(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits);
extern void __bitmap_shift_left(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits);
extern void bitmap_cut(unsigned long *dst, const unsigned long *src,
         unsigned int first, unsigned int cut,
         unsigned int nbits);
extern int __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_replace(unsigned long *dst,
   const unsigned long *old, const unsigned long *new,
   const unsigned long *mask, unsigned int nbits);
extern int __bitmap_intersects(const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_subset(const unsigned long *bitmap1,
   const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);
extern void __bitmap_set(unsigned long *map, unsigned int start, int len);
extern void __bitmap_clear(unsigned long *map, unsigned int start, int len);

extern unsigned long bitmap_find_next_zero_area_off(unsigned long *map,
          unsigned long size,
          unsigned long start,
          unsigned int nr,
          unsigned long align_mask,
          unsigned long align_offset);
# 178 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
bitmap_find_next_zero_area(unsigned long *map,
      unsigned long size,
      unsigned long start,
      unsigned int nr,
      unsigned long align_mask)
{
 return bitmap_find_next_zero_area_off(map, size, start, nr,
           align_mask, 0);
}

extern int bitmap_parse(const char *buf, unsigned int buflen,
   unsigned long *dst, int nbits);
extern int bitmap_parse_user(const char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern int bitmap_parselist(const char *buf, unsigned long *maskp,
   int nmaskbits);
extern int bitmap_parselist_user(const char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern void bitmap_remap(unsigned long *dst, const unsigned long *src,
  const unsigned long *old, const unsigned long *new, unsigned int nbits);
extern int bitmap_bitremap(int oldbit,
  const unsigned long *old, const unsigned long *new, int bits);
extern void bitmap_onto(unsigned long *dst, const unsigned long *orig,
  const unsigned long *relmap, unsigned int bits);
extern void bitmap_fold(unsigned long *dst, const unsigned long *orig,
  unsigned int sz, unsigned int nbits);
extern int bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order);
extern void bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order);
extern int bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order);


extern void bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits);



extern unsigned int bitmap_ord_to_pos(const unsigned long *bitmap, unsigned int ord, unsigned int nbits);
extern int bitmap_print_to_pagebuf(bool list, char *buf,
       const unsigned long *maskp, int nmaskbits);
# 229 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memset(dst, 0, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_fill(unsigned long *dst, unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memset(dst, 0xff, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_copy(unsigned long *dst, const unsigned long *src,
   unsigned int nbits)
{
 unsigned int len = (((nbits) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(unsigned long);
 memcpy(dst, src, len);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_copy_clear_tail(unsigned long *dst,
  const unsigned long *src, unsigned int nbits)
{
 bitmap_copy(dst, src, nbits);
 if (nbits % 64)
  dst[nbits / 64] &= (~0UL >> (-(nbits) & (64 - 1)));
}






extern void bitmap_from_arr32(unsigned long *bitmap, const u32 *buf,
       unsigned int nbits);
extern void bitmap_to_arr32(u32 *buf, const unsigned long *bitmap,
       unsigned int nbits);
# 277 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_and(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return (*dst = *src1 & *src2 & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 return __bitmap_and(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_or(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = *src1 | *src2;
 else
  __bitmap_or(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_xor(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = *src1 ^ *src2;
 else
  __bitmap_xor(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_andnot(unsigned long *dst, const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return (*dst = *src1 & ~(*src2) & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 return __bitmap_andnot(dst, src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_complement(unsigned long *dst, const unsigned long *src,
   unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = ~(*src);
 else
  __bitmap_complement(dst, src, nbits);
}
# 327 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_equal(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return !((*src1 ^ *src2) & (~0UL >> (-(nbits) & (64 - 1))));
 if (__builtin_constant_p(nbits & ((8 * sizeof(unsigned long)) - 1)) &&
     (((nbits) & ((typeof(nbits))((8 * sizeof(unsigned long))) - 1)) == 0))
  return !memcmp(src1, src2, nbits / 8);
 return __bitmap_equal(src1, src2, nbits);
}
# 347 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bitmap_or_equal(const unsigned long *src1,
       const unsigned long *src2,
       const unsigned long *src3,
       unsigned int nbits)
{
 if (!(__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return __bitmap_or_equal(src1, src2, src3, nbits);

 return !(((*src1 | *src2) ^ *src3) & (~0UL >> (-(nbits) & (64 - 1))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_intersects(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ((*src1 & *src2) & (~0UL >> (-(nbits) & (64 - 1)))) != 0;
 else
  return __bitmap_intersects(src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_subset(const unsigned long *src1,
   const unsigned long *src2, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! ((*src1 & ~(*src2)) & (~0UL >> (-(nbits) & (64 - 1))));
 else
  return __bitmap_subset(src1, src2, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_empty(const unsigned long *src, unsigned nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! (*src & (~0UL >> (-(nbits) & (64 - 1))));

 return find_next_bit((src), (nbits), 0) == nbits;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bitmap_full(const unsigned long *src, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return ! (~(*src) & (~0UL >> (-(nbits) & (64 - 1))));

 return find_next_zero_bit((src), (nbits), 0) == nbits;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int bitmap_weight(const unsigned long *src, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  return hweight_long(*src & (~0UL >> (-(nbits) & (64 - 1))));
 return __bitmap_weight(src, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void bitmap_set(unsigned long *map, unsigned int start,
  unsigned int nbits)
{
 if (__builtin_constant_p(nbits) && nbits == 1)
  __set_bit(start, map);
 else if (__builtin_constant_p(start & ((8 * sizeof(unsigned long)) - 1)) &&
   (((start) & ((typeof(start))((8 * sizeof(unsigned long))) - 1)) == 0) &&
   __builtin_constant_p(nbits & ((8 * sizeof(unsigned long)) - 1)) &&
   (((nbits) & ((typeof(nbits))((8 * sizeof(unsigned long))) - 1)) == 0))
  memset((char *)map + start / 8, 0xff, nbits / 8);
 else
  __bitmap_set(map, start, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void bitmap_clear(unsigned long *map, unsigned int start,
  unsigned int nbits)
{
 if (__builtin_constant_p(nbits) && nbits == 1)
  __clear_bit(start, map);
 else if (__builtin_constant_p(start & ((8 * sizeof(unsigned long)) - 1)) &&
   (((start) & ((typeof(start))((8 * sizeof(unsigned long))) - 1)) == 0) &&
   __builtin_constant_p(nbits & ((8 * sizeof(unsigned long)) - 1)) &&
   (((nbits) & ((typeof(nbits))((8 * sizeof(unsigned long))) - 1)) == 0))
  memset((char *)map + start / 8, 0, nbits / 8);
 else
  __bitmap_clear(map, start, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_shift_right(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*src & (~0UL >> (-(nbits) & (64 - 1)))) >> shift;
 else
  __bitmap_shift_right(dst, src, shift, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_shift_left(unsigned long *dst, const unsigned long *src,
    unsigned int shift, unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*src << shift) & (~0UL >> (-(nbits) & (64 - 1)));
 else
  __bitmap_shift_left(dst, src, shift, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_replace(unsigned long *dst,
      const unsigned long *old,
      const unsigned long *new,
      const unsigned long *mask,
      unsigned int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64 && (nbits) > 0))
  *dst = (*old & ~(*mask)) | (*new & *mask);
 else
  __bitmap_replace(dst, old, new, mask, nbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_next_clear_region(unsigned long *bitmap,
         unsigned int *rs, unsigned int *re,
         unsigned int end)
{
 *rs = find_next_zero_bit(bitmap, end, *rs);
 *re = find_next_bit(bitmap, end, *rs + 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_next_set_region(unsigned long *bitmap,
       unsigned int *rs, unsigned int *re,
       unsigned int end)
{
 *rs = find_next_bit(bitmap, end, *rs);
 *re = find_next_zero_bit(bitmap, end, *rs + 1);
}
# 535 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_from_u64(unsigned long *dst, u64 mask)
{
 dst[0] = mask & (~0UL);

 if (sizeof(mask) > sizeof(unsigned long))
  dst[1] = mask >> 32;
}
# 551 "/home/nathan/src/linux-next/include/linux/bitmap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long bitmap_get_value8(const unsigned long *map,
           unsigned long start)
{
 const size_t index = ((start) / 64);
 const unsigned long offset = start % 64;

 return (map[index] >> offset) & 0xFF;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bitmap_set_value8(unsigned long *map, unsigned long value,
         unsigned long start)
{
 const size_t index = ((start) / 64);
 const unsigned long offset = start % 64;

 map[index] &= ~(0xFFUL << offset);
 map[index] |= value << offset;
}
# 96 "/home/nathan/src/linux-next/include/linux/nodemask.h" 2


typedef struct { unsigned long bits[((((1 << 8)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))]; } nodemask_t;
extern nodemask_t _unused_nodemask_arg_;
# 109 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __nodemask_pr_numnodes(const nodemask_t *m)
{
 return m ? (1 << 8) : 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const unsigned long *__nodemask_pr_bits(const nodemask_t *m)
{
 return m ? m->bits : ((void *)0);
}
# 128 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __node_set(int node, volatile nodemask_t *dstp)
{
 set_bit(node, dstp->bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __node_clear(int node, volatile nodemask_t *dstp)
{
 clear_bit(node, dstp->bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_setall(nodemask_t *dstp, unsigned int nbits)
{
 bitmap_fill(dstp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_clear(nodemask_t *dstp, unsigned int nbits)
{
 bitmap_zero(dstp->bits, nbits);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __node_test_and_set(int node, nodemask_t *addr)
{
 return test_and_set_bit(node, addr->bits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_and(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_or(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_xor(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_andnot(nodemask_t *dstp, const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_complement(nodemask_t *dstp,
     const nodemask_t *srcp, unsigned int nbits)
{
 bitmap_complement(dstp->bits, srcp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_equal(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_equal(src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_intersects(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_intersects(src1p->bits, src2p->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_subset(const nodemask_t *src1p,
     const nodemask_t *src2p, unsigned int nbits)
{
 return bitmap_subset(src1p->bits, src2p->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_empty(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_empty(srcp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_full(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_full(srcp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodes_weight(const nodemask_t *srcp, unsigned int nbits)
{
 return bitmap_weight(srcp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_shift_right(nodemask_t *dstp,
     const nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_right(dstp->bits, srcp->bits, n, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_shift_left(nodemask_t *dstp,
     const nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __first_node(const nodemask_t *srcp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) ? ((int)((1 << 8))) : ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x0 = ((int)((1 << 8))); typeof((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))) __UNIQUE_ID___y1 = ((int)(find_next_bit((srcp->bits), ((1 << 8)), 0))); ((__UNIQUE_ID___x0) < (__UNIQUE_ID___y1) ? (__UNIQUE_ID___x0) : (__UNIQUE_ID___y1)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __next_node(int n, const nodemask_t *srcp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) ? ((int)((1 << 8))) : ((int)(find_next_bit(srcp->bits, (1 << 8), n+1)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x2 = ((int)((1 << 8))); typeof((int)(find_next_bit(srcp->bits, (1 << 8), n+1))) __UNIQUE_ID___y3 = ((int)(find_next_bit(srcp->bits, (1 << 8), n+1))); ((__UNIQUE_ID___x2) < (__UNIQUE_ID___y3) ? (__UNIQUE_ID___x2) : (__UNIQUE_ID___y3)); }));
}






int __next_node_in(int node, const nodemask_t *srcp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_nodemask_of_node(nodemask_t *mask, int node)
{
 __nodes_clear(&(*mask), (1 << 8));
 __node_set((node), &(*mask));
}
# 299 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __first_unset_node(const nodemask_t *maskp)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)((1 << 8))) *)1 == (typeof((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)((1 << 8))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) * 0l)) : (int *)8))))), (((int)((1 << 8))) < ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) ? ((int)((1 << 8))) : ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0)))), ({ typeof((int)((1 << 8))) __UNIQUE_ID___x4 = ((int)((1 << 8))); typeof((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))) __UNIQUE_ID___y5 = ((int)(find_next_zero_bit((maskp->bits), ((1 << 8)), 0))); ((__UNIQUE_ID___x4) < (__UNIQUE_ID___y5) ? (__UNIQUE_ID___x4) : (__UNIQUE_ID___y5)); }));

}
# 333 "/home/nathan/src/linux-next/include/linux/nodemask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodemask_parse_user(const char *buf, int len,
     nodemask_t *dstp, int nbits)
{
 return bitmap_parse_user(buf, len, dstp->bits, nbits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nodelist_parse(const char *buf, nodemask_t *dstp, int nbits)
{
 return bitmap_parselist(buf, dstp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __node_remap(int oldbit,
  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
{
 return bitmap_bitremap(oldbit, oldp->bits, newp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_remap(nodemask_t *dstp, const nodemask_t *srcp,
  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
{
 bitmap_remap(dstp->bits, srcp->bits, oldp->bits, newp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_onto(nodemask_t *dstp, const nodemask_t *origp,
  const nodemask_t *relmapp, int nbits)
{
 bitmap_onto(dstp->bits, origp->bits, relmapp->bits, nbits);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nodes_fold(nodemask_t *dstp, const nodemask_t *origp,
  int sz, int nbits)
{
 bitmap_fold(dstp->bits, origp->bits, sz, nbits);
}
# 391 "/home/nathan/src/linux-next/include/linux/nodemask.h"
enum node_states {
 N_POSSIBLE,
 N_ONLINE,
 N_NORMAL_MEMORY,



 N_HIGH_MEMORY = N_NORMAL_MEMORY,

 N_MEMORY,
 N_CPU,
 NR_NODE_STATES
};






extern nodemask_t node_states[NR_NODE_STATES];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int node_state(int node, enum node_states state)
{
 return test_bit((node), (node_states[state]).bits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_state(int node, enum node_states state)
{
 __node_set(node, &node_states[state]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_clear_state(int node, enum node_states state)
{
 __node_clear(node, &node_states[state]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int num_node_state(enum node_states state)
{
 return __nodes_weight(&(node_states[state]), (1 << 8));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int next_online_node(int nid)
{
 return __next_node((nid), &(node_states[N_ONLINE]));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int next_memory_node(int nid)
{
 return __next_node((nid), &(node_states[N_MEMORY]));
}

extern unsigned int nr_node_ids;
extern unsigned int nr_online_nodes;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_online(int nid)
{
 node_set_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_set_offline(int nid)
{
 node_clear_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}
# 497 "/home/nathan/src/linux-next/include/linux/nodemask.h"
extern int node_random(const nodemask_t *maskp);
# 531 "/home/nathan/src/linux-next/include/linux/nodemask.h"
struct nodemask_scratch {
 nodemask_t mask1;
 nodemask_t mask2;
};
# 18 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h"
enum pageblock_bits {
 PB_migrate,
 PB_migrate_end = PB_migrate + 3 - 1,

 PB_migrate_skip,





 NR_PAGEBLOCK_BITS
};






extern unsigned int pageblock_order;
# 55 "/home/nathan/src/linux-next/include/linux/pageblock-flags.h"
struct page;

unsigned long get_pfnblock_flags_mask(struct page *page,
    unsigned long pfn,
    unsigned long end_bitidx,
    unsigned long mask);

void set_pfnblock_flags_mask(struct page *page,
    unsigned long flags,
    unsigned long pfn,
    unsigned long end_bitidx,
    unsigned long mask);
# 19 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 1





# 1 "./include/generated/bounds.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 2
# 28 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sparsemem.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sparsemem.h"
extern int create_section_mapping(unsigned long start, unsigned long end, int nid);
extern int remove_section_mapping(unsigned long start, unsigned long end);


extern int resize_hpt_for_hotplug(unsigned long new_mem_size);





extern int hot_add_scn_to_nid(unsigned long scn_addr);
# 29 "/home/nathan/src/linux-next/include/linux/page-flags-layout.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/mm_types.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/mm_types_task.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/mm_types_task.h"
# 1 "/home/nathan/src/linux-next/include/linux/cpumask.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/cpumask.h"
typedef struct cpumask { unsigned long bits[(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))]; } cpumask_t;
# 39 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern unsigned int nr_cpu_ids;
# 90 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern struct cpumask __cpu_possible_mask;
extern struct cpumask __cpu_online_mask;
extern struct cpumask __cpu_present_mask;
extern struct cpumask __cpu_active_mask;





extern atomic_t __num_online_cpus;
# 110 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int num_online_cpus(void)
{
 return atomic_read(&__num_online_cpus);
}
# 132 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern cpumask_t cpus_booted_once_mask;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)
{



}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_check(unsigned int cpu)
{
 cpu_max_bits_warn(cpu, ((unsigned int)2048));
 return cpu;
}
# 212 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_first(const struct cpumask *srcp)
{
 return find_next_bit((((srcp)->bits)), (((unsigned int)2048)), 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_last(const struct cpumask *srcp)
{
 return find_last_bit(((srcp)->bits), ((unsigned int)2048));
}

unsigned int cpumask_next(int n, const struct cpumask *srcp);
# 237 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
{

 if (n != -1)
  cpumask_check(n);
 return find_next_zero_bit(((srcp)->bits), ((unsigned int)2048), n+1);
}

int cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);
int cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
unsigned int cpumask_local_spread(unsigned int i, int node);
# 273 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);
# 325 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
 set_bit(cpumask_check(cpu), ((dstp)->bits));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
 __set_bit(cpumask_check(cpu), ((dstp)->bits));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
 clear_bit(cpumask_check(cpu), ((dstp)->bits));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
 __clear_bit(cpumask_check(cpu), ((dstp)->bits));
}
# 358 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)
{
 return test_bit(cpumask_check(cpu), (((cpumask))->bits));
}
# 372 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_set_bit(cpumask_check(cpu), ((cpumask)->bits));
}
# 386 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_clear_bit(cpumask_check(cpu), ((cpumask)->bits));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_setall(struct cpumask *dstp)
{
 bitmap_fill(((dstp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_clear(struct cpumask *dstp)
{
 bitmap_zero(((dstp)->bits), ((unsigned int)2048));
}
# 417 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_and(struct cpumask *dstp,
          const struct cpumask *src1p,
          const struct cpumask *src2p)
{
 return bitmap_and(((dstp)->bits), ((src1p)->bits),
           ((src2p)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,
         const struct cpumask *src2p)
{
 bitmap_or(((dstp)->bits), ((src1p)->bits),
          ((src2p)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_xor(struct cpumask *dstp,
          const struct cpumask *src1p,
          const struct cpumask *src2p)
{
 bitmap_xor(((dstp)->bits), ((src1p)->bits),
           ((src2p)->bits), ((unsigned int)2048));
}
# 460 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_andnot(struct cpumask *dstp,
      const struct cpumask *src1p,
      const struct cpumask *src2p)
{
 return bitmap_andnot(((dstp)->bits), ((src1p)->bits),
       ((src2p)->bits), ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_complement(struct cpumask *dstp,
          const struct cpumask *srcp)
{
 bitmap_complement(((dstp)->bits), ((srcp)->bits),
           ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_equal(const struct cpumask *src1p,
    const struct cpumask *src2p)
{
 return bitmap_equal(((src1p)->bits), ((src2p)->bits),
       ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_or_equal(const struct cpumask *src1p,
        const struct cpumask *src2p,
        const struct cpumask *src3p)
{
 return bitmap_or_equal(((src1p)->bits), ((src2p)->bits),
          ((src3p)->bits), ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_intersects(const struct cpumask *src1p,
         const struct cpumask *src2p)
{
 return bitmap_intersects(((src1p)->bits), ((src2p)->bits),
            ((unsigned int)2048));
}
# 525 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_subset(const struct cpumask *src1p,
     const struct cpumask *src2p)
{
 return bitmap_subset(((src1p)->bits), ((src2p)->bits),
        ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_empty(const struct cpumask *srcp)
{
 return bitmap_empty(((srcp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_full(const struct cpumask *srcp)
{
 return bitmap_full(((srcp)->bits), ((unsigned int)2048));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_weight(const struct cpumask *srcp)
{
 return bitmap_weight(((srcp)->bits), ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_shift_right(struct cpumask *dstp,
           const struct cpumask *srcp, int n)
{
 bitmap_shift_right(((dstp)->bits), ((srcp)->bits), n,
            ((unsigned int)2048));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_shift_left(struct cpumask *dstp,
          const struct cpumask *srcp, int n)
{
 bitmap_shift_left(((dstp)->bits), ((srcp)->bits), n,
           ((unsigned int)2048));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpumask_copy(struct cpumask *dstp,
    const struct cpumask *srcp)
{
 bitmap_copy(((dstp)->bits), ((srcp)->bits), ((unsigned int)2048));
}
# 636 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parse_user(const char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parse_user(buf, len, ((dstp)->bits), ((unsigned int)2048));
}
# 650 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parselist_user(const char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parselist_user(buf, len, ((dstp)->bits),
         ((unsigned int)2048));
}
# 664 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpumask_parse(const char *buf, struct cpumask *dstp)
{
 return bitmap_parse(buf, (~0U), ((dstp)->bits), ((unsigned int)2048));
}
# 676 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpulist_parse(const char *buf, struct cpumask *dstp)
{
 return bitmap_parselist(buf, ((dstp)->bits), ((unsigned int)2048));
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int cpumask_size(void)
{
 return (((((unsigned int)2048)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8))) * sizeof(long);
}
# 749 "/home/nathan/src/linux-next/include/linux/cpumask.h"
typedef struct cpumask cpumask_var_t[1];




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 cpumask_clear(*mask);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 cpumask_clear(*mask);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_cpumask_var(cpumask_var_t mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_bootmem_cpumask_var(cpumask_var_t mask)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpumask_available(cpumask_var_t mask)
{
 return true;
}




extern const unsigned long cpu_all_bits[(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
# 809 "/home/nathan/src/linux-next/include/linux/cpumask.h"
void init_cpu_present(const struct cpumask *src);
void init_cpu_possible(const struct cpumask *src);
void init_cpu_online(const struct cpumask *src);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reset_cpu_possible_mask(void)
{
 bitmap_zero(((&__cpu_possible_mask)->bits), 2048);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_possible(unsigned int cpu, bool possible)
{
 if (possible)
  cpumask_set_cpu(cpu, &__cpu_possible_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_possible_mask);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_present(unsigned int cpu, bool present)
{
 if (present)
  cpumask_set_cpu(cpu, &__cpu_present_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_present_mask);
}

void set_cpu_online(unsigned int cpu, bool online);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
set_cpu_active(unsigned int cpu, bool active)
{
 if (active)
  cpumask_set_cpu(cpu, &__cpu_active_mask);
 else
  cpumask_clear_cpu(cpu, &__cpu_active_mask);
}
# 862 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __check_is_bitmap(const unsigned long *bitmap)
{
 return 1;
}
# 874 "/home/nathan/src/linux-next/include/linux/cpumask.h"
extern const unsigned long
 cpu_bit_bitmap[64 +1][(((2048) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *get_cpu_mask(unsigned int cpu)
{
 const unsigned long *p = cpu_bit_bitmap[1 + cpu % 64];
 p -= cpu / 64;
 return ((struct cpumask *)(1 ? (p) : (void *)sizeof(__check_is_bitmap(p))));
}
# 911 "/home/nathan/src/linux-next/include/linux/cpumask.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t
cpumap_print_to_pagebuf(bool list, char *buf, const struct cpumask *mask)
{
 return bitmap_print_to_pagebuf(list, buf, ((mask)->bits),
          nr_cpu_ids);
}
# 15 "/home/nathan/src/linux-next/include/linux/mm_types_task.h" 2
# 34 "/home/nathan/src/linux-next/include/linux/mm_types_task.h"
struct vmacache {
 u64 seqnum;
 struct vm_area_struct *vmas[(1U << 2)];
};





enum {
 MM_FILEPAGES,
 MM_ANONPAGES,
 MM_SWAPENTS,
 MM_SHMEMPAGES,
 NR_MM_COUNTERS
};




struct task_rss_stat {
 int events;
 int count[NR_MM_COUNTERS];
};


struct mm_rss_stat {
 atomic_long_t count[NR_MM_COUNTERS];
};

struct page_frag {
 struct page *page;

 __u32 offset;
 __u32 size;




};


struct tlbflush_unmap_batch {
# 97 "/home/nathan/src/linux-next/include/linux/mm_types_task.h"
};
# 6 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/auxvec.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/auxvec.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/auxvec.h" 1
# 6 "/home/nathan/src/linux-next/include/uapi/linux/auxvec.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/auxvec.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/rbtree.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/rbtree.h"
# 1 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 1
# 38 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
void call_rcu(struct callback_head *head, rcu_callback_t func);
void rcu_barrier_tasks(void);
void synchronize_rcu(void);
# 57 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __rcu_read_lock(void)
{
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __rcu_read_unlock(void)
{
 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_preempt_depth(void)
{
 return 0;
}




void rcu_init(void);
extern int rcu_scheduler_active __attribute__((__section__(".data..read_mostly")));
void rcu_sched_clock_irq(int user);
void rcu_report_dead(unsigned int cpu);
void rcutree_migrate_callbacks(int cpu);


void rcu_sysrq_start(void);
void rcu_sysrq_end(void);
# 93 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_user_enter(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_user_exit(void) { }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_init_nohz(void) { }
# 148 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_tasks_rcu_start(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_tasks_rcu_finish(void) { }
# 171 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
# 1 "/home/nathan/src/linux-next/include/linux/rcutree.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/rcutree.h"
void rcu_softirq_qs(void);
void rcu_note_context_switch(bool preempt);
int rcu_needs_cpu(u64 basem, u64 *nextevt);
void rcu_cpu_stall_reset(void);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_virt_note_context_switch(int cpu)
{
 rcu_note_context_switch(false);
}

void synchronize_rcu_expedited(void);
void kfree_call_rcu(struct callback_head *head, rcu_callback_t func);

void rcu_barrier(void);
bool rcu_eqs_special_set(int cpu);
void rcu_momentary_dyntick_idle(void);
void kfree_rcu_scheduler_running(void);
unsigned long get_state_synchronize_rcu(void);
void cond_synchronize_rcu(unsigned long oldstate);

void rcu_idle_enter(void);
void rcu_idle_exit(void);
void rcu_irq_enter(void);
void rcu_irq_exit(void);
void rcu_irq_enter_irqson(void);
void rcu_irq_exit_irqson(void);

void exit_rcu(void);

void rcu_scheduler_starting(void);
extern int rcu_scheduler_active __attribute__((__section__(".data..read_mostly")));
void rcu_end_inkernel_boot(void);
bool rcu_is_watching(void);

void rcu_all_qs(void);



int rcutree_prepare_cpu(unsigned int cpu);
int rcutree_online_cpu(unsigned int cpu);
int rcutree_offline_cpu(unsigned int cpu);
int rcutree_dead_cpu(unsigned int cpu);
int rcutree_dying_cpu(unsigned int cpu);
void rcu_cpu_starting(unsigned int cpu);
# 172 "/home/nathan/src/linux-next/include/linux/rcupdate.h" 2
# 192 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_rcu_head(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_rcu_head(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_rcu_head_on_stack(struct callback_head *head) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_rcu_head_on_stack(struct callback_head *head) { }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rcu_lockdep_current_cpu_online(void) { return true; }
# 231 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_held(void)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_bh_held(void)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_sched_held(void)
{
 return !0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rcu_read_lock_any_held(void)
{
 return !0;
}
# 597 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void rcu_read_lock(void)
{
 __rcu_read_lock();
 (void)0;
 do { } while (0);
 do { } while (0);

}
# 649 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock(void)
{
 do { } while (0);

 (void)0;
 __rcu_read_unlock();
 do { } while (0);
}
# 670 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_bh(void)
{
 local_bh_disable();
 (void)0;
 do { } while (0);
 do { } while (0);

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_bh(void)
{
 do { } while (0);

 do { } while (0);
 (void)0;
 local_bh_enable();
}
# 705 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_sched(void)
{
 __asm__ __volatile__("" : : : "memory");
 (void)0;
 do { } while (0);
 do { } while (0);

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void rcu_read_lock_sched_notrace(void)
{
 __asm__ __volatile__("" : : : "memory");
 (void)0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_sched(void)
{
 do { } while (0);

 do { } while (0);
 (void)0;
 __asm__ __volatile__("" : : : "memory");
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void rcu_read_unlock_sched_notrace(void)
{
 (void)0;
 __asm__ __volatile__("" : : : "memory");
}
# 870 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcu_head_init(struct callback_head *rhp)
{
 rhp->func = (rcu_callback_t)~0L;
}
# 888 "/home/nathan/src/linux-next/include/linux/rcupdate.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
rcu_head_after_call_rcu(struct callback_head *rhp, rcu_callback_t f)
{
 rcu_callback_t func = ({ union { typeof(rhp->func) __val; char __c[1]; } __u; if (1) __read_once_size(&(rhp->func), __u.__c, sizeof(rhp->func)); else __read_once_size_nocheck(&(rhp->func), __u.__c, sizeof(rhp->func)); do { } while (0); __u.__val; });

 if (func == f)
  return true;
 ({ int __ret_warn_on = !!(func != (rcu_callback_t)~0L); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rcupdate.h"), "i" (895), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return false;
}


extern int rcu_expedited;
extern int rcu_normal;
# 23 "/home/nathan/src/linux-next/include/linux/rbtree.h" 2

struct rb_node {
 unsigned long __rb_parent_color;
 struct rb_node *rb_right;
 struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));


struct rb_root {
 struct rb_node *rb_node;
};
# 49 "/home/nathan/src/linux-next/include/linux/rbtree.h"
extern void rb_insert_color(struct rb_node *, struct rb_root *);
extern void rb_erase(struct rb_node *, struct rb_root *);



extern struct rb_node *rb_next(const struct rb_node *);
extern struct rb_node *rb_prev(const struct rb_node *);
extern struct rb_node *rb_first(const struct rb_root *);
extern struct rb_node *rb_last(const struct rb_root *);


extern struct rb_node *rb_first_postorder(const struct rb_root *);
extern struct rb_node *rb_next_postorder(const struct rb_node *);


extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,
       struct rb_root *root);
extern void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new,
    struct rb_root *root);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_link_node(struct rb_node *node, struct rb_node *parent,
    struct rb_node **rb_link)
{
 node->__rb_parent_color = (unsigned long)parent;
 node->rb_left = node->rb_right = ((void *)0);

 *rb_link = node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_link_node_rcu(struct rb_node *node, struct rb_node *parent,
        struct rb_node **rb_link)
{
 node->__rb_parent_color = (unsigned long)parent;
 node->rb_left = node->rb_right = ((void *)0);

 do { uintptr_t _r_a_p__v = (uintptr_t)(node); ; if (__builtin_constant_p(node) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*rb_link)) __val; char __c[1]; } __u = { .__val = ( typeof((*rb_link))) ((typeof(*rb_link))(_r_a_p__v)) }; __write_once_size(&((*rb_link)), __u.__c, sizeof((*rb_link))); __u.__val; }); else do { do { extern void __compiletime_assert_84(void) ; if (!((sizeof(*&*rb_link) == sizeof(char) || sizeof(*&*rb_link) == sizeof(short) || sizeof(*&*rb_link) == sizeof(int) || sizeof(*&*rb_link) == sizeof(long)))) __compiletime_assert_84(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*rb_link) __val; char __c[1]; } __u = { .__val = ( typeof(*&*rb_link)) ((typeof(*((typeof(*rb_link))_r_a_p__v)) *)((typeof(*rb_link))_r_a_p__v)) }; __write_once_size(&(*&*rb_link), __u.__c, sizeof(*&*rb_link)); __u.__val; }); } while (0); } while (0);
}
# 125 "/home/nathan/src/linux-next/include/linux/rbtree.h"
struct rb_root_cached {
 struct rb_root rb_root;
 struct rb_node *rb_leftmost;
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_insert_color_cached(struct rb_node *node,
       struct rb_root_cached *root,
       bool leftmost)
{
 if (leftmost)
  root->rb_leftmost = node;
 rb_insert_color(node, &root->rb_root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_erase_cached(struct rb_node *node,
       struct rb_root_cached *root)
{
 if (root->rb_leftmost == node)
  root->rb_leftmost = rb_next(node);
 rb_erase(node, &root->rb_root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rb_replace_node_cached(struct rb_node *victim,
       struct rb_node *new,
       struct rb_root_cached *root)
{
 if (root->rb_leftmost == victim)
  root->rb_leftmost = new;
 rb_replace_node(victim, new, &root->rb_root);
}
# 11 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rwsem.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/rwsem.h"
# 1 "/home/nathan/src/linux-next/include/linux/err.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/err.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__)) ERR_PTR(long error)
{
 return (void *) error;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long __attribute__((__warn_unused_result__)) PTR_ERR( const void *ptr)
{
 return (long) ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) IS_ERR( const void *ptr)
{
 return __builtin_expect(!!((unsigned long)(void *)((unsigned long)ptr) >= (unsigned long)-4095), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) IS_ERR_OR_NULL( const void *ptr)
{
 return __builtin_expect(!!(!ptr), 0) || __builtin_expect(!!((unsigned long)(void *)((unsigned long)ptr) >= (unsigned long)-4095), 0);
}
# 51 "/home/nathan/src/linux-next/include/linux/err.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__)) ERR_CAST( const void *ptr)
{

 return (void *) ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) PTR_ERR_OR_ZERO( const void *ptr)
{
 if (IS_ERR(ptr))
  return PTR_ERR(ptr);
 else
  return 0;
}
# 19 "/home/nathan/src/linux-next/include/linux/rwsem.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/osq_lock.h" 1








struct optimistic_spin_node {
 struct optimistic_spin_node *next, *prev;
 int locked;
 int cpu;
};

struct optimistic_spin_queue {




 atomic_t tail;
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void osq_lock_init(struct optimistic_spin_queue *lock)
{
 atomic_set(&lock->tail, (0));
}

extern bool osq_lock(struct optimistic_spin_queue *lock);
extern void osq_unlock(struct optimistic_spin_queue *lock);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool osq_is_locked(struct optimistic_spin_queue *lock)
{
 return atomic_read(&lock->tail) != (0);
}
# 21 "/home/nathan/src/linux-next/include/linux/rwsem.h" 2
# 35 "/home/nathan/src/linux-next/include/linux/rwsem.h"
struct rw_semaphore {
 atomic_long_t count;





 atomic_long_t owner;

 struct optimistic_spin_queue osq;

 raw_spinlock_t wait_lock;
 struct list_head wait_list;






};
# 63 "/home/nathan/src/linux-next/include/linux/rwsem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rwsem_is_locked(struct rw_semaphore *sem)
{
 return atomic_long_read(&sem->count) != 0;
}
# 103 "/home/nathan/src/linux-next/include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore *sem, const char *name,
    struct lock_class_key *key);
# 119 "/home/nathan/src/linux-next/include/linux/rwsem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rwsem_is_contended(struct rw_semaphore *sem)
{
 return !list_empty(&sem->wait_list);
}




extern void down_read(struct rw_semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_read_killable(struct rw_semaphore *sem);




extern int down_read_trylock(struct rw_semaphore *sem);




extern void down_write(struct rw_semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_write_killable(struct rw_semaphore *sem);




extern int down_write_trylock(struct rw_semaphore *sem);




extern void up_read(struct rw_semaphore *sem);




extern void up_write(struct rw_semaphore *sem);




extern void downgrade_write(struct rw_semaphore *sem);
# 12 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/completion.h" 1
# 26 "/home/nathan/src/linux-next/include/linux/completion.h"
struct completion {
 unsigned int done;
 wait_queue_head_t wait;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void complete_acquire(struct completion *x) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void complete_release(struct completion *x) {}
# 85 "/home/nathan/src/linux-next/include/linux/completion.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __init_completion(struct completion *x)
{
 x->done = 0;
 do { static struct lock_class_key __key; __init_waitqueue_head((&x->wait), "&x->wait", &__key); } while (0);
}
# 98 "/home/nathan/src/linux-next/include/linux/completion.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reinit_completion(struct completion *x)
{
 x->done = 0;
}

extern void wait_for_completion(struct completion *);
extern void wait_for_completion_io(struct completion *);
extern int wait_for_completion_interruptible(struct completion *x);
extern int wait_for_completion_killable(struct completion *x);
extern unsigned long wait_for_completion_timeout(struct completion *x,
         unsigned long timeout);
extern unsigned long wait_for_completion_io_timeout(struct completion *x,
          unsigned long timeout);
extern long wait_for_completion_interruptible_timeout(
 struct completion *x, unsigned long timeout);
extern long wait_for_completion_killable_timeout(
 struct completion *x, unsigned long timeout);
extern bool try_wait_for_completion(struct completion *x);
extern bool completion_done(struct completion *x);

extern void complete(struct completion *);
extern void complete_all(struct completion *);
# 13 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/uprobes.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/uprobes.h"
struct vm_area_struct;
struct mm_struct;
struct inode;
struct notifier_block;
struct page;






enum uprobe_filter_ctx {
 UPROBE_FILTER_REGISTER,
 UPROBE_FILTER_UNREGISTER,
 UPROBE_FILTER_MMAP,
};

struct uprobe_consumer {
 int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
 int (*ret_handler)(struct uprobe_consumer *self,
    unsigned long func,
    struct pt_regs *regs);
 bool (*filter)(struct uprobe_consumer *self,
    enum uprobe_filter_ctx ctx,
    struct mm_struct *mm);

 struct uprobe_consumer *next;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h"
# 1 "/home/nathan/src/linux-next/include/linux/notifier.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/notifier.h"
# 1 "/home/nathan/src/linux-next/include/linux/mutex.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/mutex.h"
# 1 "/home/nathan/src/linux-next/include/linux/debug_locks.h" 1








struct task_struct;

extern int debug_locks __attribute__((__section__(".data..read_mostly")));
extern int debug_locks_silent __attribute__((__section__(".data..read_mostly")));


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __debug_locks_off(void)
{
 return ({ typeof(({ __typeof__(*(&debug_locks)) _x_ = (0); (__typeof__(*(&debug_locks))) __xchg_relaxed((&debug_locks), (unsigned long)_x_, sizeof(*(&debug_locks))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&debug_locks)) _x_ = (0); (__typeof__(*(&debug_locks))) __xchg_relaxed((&debug_locks), (unsigned long)_x_, sizeof(*(&debug_locks))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
}




extern int debug_locks_off(void);
# 49 "/home/nathan/src/linux-next/include/linux/debug_locks.h"
struct task_struct;







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_show_all_locks(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_show_held_locks(struct task_struct *task)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_locks_freed(const void *from, unsigned long len)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_locks_held(void)
{
}
# 22 "/home/nathan/src/linux-next/include/linux/mutex.h" 2

struct ww_acquire_ctx;
# 53 "/home/nathan/src/linux-next/include/linux/mutex.h"
struct mutex {
 atomic_long_t owner;
 spinlock_t wait_lock;

 struct optimistic_spin_queue osq;

 struct list_head wait_list;

 void *magic;




};





struct mutex_waiter {
 struct list_head list;
 struct task_struct *task;
 struct ww_acquire_ctx *ww_ctx;

 void *magic;

};






extern void mutex_destroy(struct mutex *lock);
# 128 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock, const char *name,
    struct lock_class_key *key);







extern bool mutex_is_locked(struct mutex *lock);
# 165 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern void mutex_lock(struct mutex *lock);
extern int __attribute__((__warn_unused_result__)) mutex_lock_interruptible(struct mutex *lock);
extern int __attribute__((__warn_unused_result__)) mutex_lock_killable(struct mutex *lock);
extern void mutex_lock_io(struct mutex *lock);
# 183 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern int mutex_trylock(struct mutex *lock);
extern void mutex_unlock(struct mutex *lock);

extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);





enum mutex_trylock_recursive_enum {
 MUTEX_TRYLOCK_FAILED = 0,
 MUTEX_TRYLOCK_SUCCESS = 1,
 MUTEX_TRYLOCK_RECURSIVE,
};
# 210 "/home/nathan/src/linux-next/include/linux/mutex.h"
extern __attribute__((__warn_unused_result__)) enum mutex_trylock_recursive_enum
mutex_trylock_recursive(struct mutex *lock);
# 15 "/home/nathan/src/linux-next/include/linux/notifier.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/srcu.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/srcu.h"
# 1 "/home/nathan/src/linux-next/include/linux/workqueue.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/timer.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/ktime.h" 1
# 25 "/home/nathan/src/linux-next/include/linux/ktime.h"
# 1 "/home/nathan/src/linux-next/include/linux/jiffies.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/jiffies.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/param.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/jiffies.h" 2
# 1 "./include/generated/timeconst.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/jiffies.h" 2
# 60 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern int register_refined_jiffies(long clock_tick_rate);
# 80 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern u64 __attribute__((__aligned__((1 << 7)), __section__(".data..cacheline_aligned"))) jiffies_64;
extern unsigned long volatile __attribute__((__aligned__((1 << 7)), __section__(".data..cacheline_aligned"))) jiffies;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_jiffies_64(void)
{
 return (u64)jiffies;
}
# 190 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern unsigned long preset_lpj;
# 291 "/home/nathan/src/linux-next/include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(const unsigned long j);
extern unsigned int jiffies_to_usecs(const unsigned long j);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 jiffies_to_nsecs(const unsigned long j)
{
 return (u64)jiffies_to_usecs(j) * 1000L;
}

extern u64 jiffies64_to_nsecs(u64 j);
extern u64 jiffies64_to_msecs(u64 j);

extern unsigned long __msecs_to_jiffies(const unsigned int m);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long _msecs_to_jiffies(const unsigned int m)
{
 return (m + (1000L / 100) - 1) / (1000L / 100);
}
# 364 "/home/nathan/src/linux-next/include/linux/jiffies.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long msecs_to_jiffies(const unsigned int m)
{
 if (__builtin_constant_p(m)) {
  if ((int)m < 0)
   return ((((long)(~0UL >> 1)) >> 1)-1);
  return _msecs_to_jiffies(m);
 } else {
  return __msecs_to_jiffies(m);
 }
}

extern unsigned long __usecs_to_jiffies(const unsigned int u);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long _usecs_to_jiffies(const unsigned int u)
{
 return (u + (1000000L / 100) - 1) / (1000000L / 100);
}
# 411 "/home/nathan/src/linux-next/include/linux/jiffies.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long usecs_to_jiffies(const unsigned int u)
{
 if (__builtin_constant_p(u)) {
  if (u > jiffies_to_usecs(((((long)(~0UL >> 1)) >> 1)-1)))
   return ((((long)(~0UL >> 1)) >> 1)-1);
  return _usecs_to_jiffies(u);
 } else {
  return __usecs_to_jiffies(u);
 }
}

extern unsigned long timespec64_to_jiffies(const struct timespec64 *value);
extern void jiffies_to_timespec64(const unsigned long jiffies,
      struct timespec64 *value);
extern clock_t jiffies_to_clock_t(unsigned long x);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clock_t jiffies_delta_to_clock_t(long delta)
{
 return jiffies_to_clock_t(__builtin_choose_expr(((!!(sizeof((typeof(0L) *)1 == (typeof(delta) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(0L) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(delta) * 0l)) : (int *)8))))), ((0L) > (delta) ? (0L) : (delta)), ({ typeof(0L) __UNIQUE_ID___x6 = (0L); typeof(delta) __UNIQUE_ID___y7 = (delta); ((__UNIQUE_ID___x6) > (__UNIQUE_ID___y7) ? (__UNIQUE_ID___x6) : (__UNIQUE_ID___y7)); })));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int jiffies_delta_to_msecs(long delta)
{
 return jiffies_to_msecs(__builtin_choose_expr(((!!(sizeof((typeof(0L) *)1 == (typeof(delta) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(0L) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(delta) * 0l)) : (int *)8))))), ((0L) > (delta) ? (0L) : (delta)), ({ typeof(0L) __UNIQUE_ID___x8 = (0L); typeof(delta) __UNIQUE_ID___y9 = (delta); ((__UNIQUE_ID___x8) > (__UNIQUE_ID___y9) ? (__UNIQUE_ID___x8) : (__UNIQUE_ID___y9)); })));
}

extern unsigned long clock_t_to_jiffies(unsigned long x);
extern u64 jiffies_64_to_clock_t(u64 x);
extern u64 nsec_to_clock_t(u64 x);
extern u64 nsecs_to_jiffies64(u64 n);
extern unsigned long nsecs_to_jiffies(u64 n);
# 26 "/home/nathan/src/linux-next/include/linux/ktime.h" 2


typedef s64 ktime_t;
# 37 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_set(const s64 secs, const unsigned long nsecs)
{
 if (__builtin_expect(!!(secs >= (((s64)~((u64)1 << 63)) / 1000000000L)), 0))
  return ((s64)~((u64)1 << 63));

 return secs * 1000000000L + (s64)nsecs;
}
# 70 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t timespec_to_ktime(struct timespec ts)
{
 return ktime_set(ts.tv_sec, ts.tv_nsec);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t timespec64_to_ktime(struct timespec64 ts)
{
 return ktime_set(ts.tv_sec, ts.tv_nsec);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t timeval_to_ktime(struct timeval tv)
{
 return ktime_set(tv.tv_sec, tv.tv_usec * 1000L);
}
# 97 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_ns(const ktime_t kt)
{
 return kt;
}
# 112 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ktime_compare(const ktime_t cmp1, const ktime_t cmp2)
{
 if (cmp1 < cmp2)
  return -1;
 if (cmp1 > cmp2)
  return 1;
 return 0;
}
# 128 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ktime_after(const ktime_t cmp1, const ktime_t cmp2)
{
 return ktime_compare(cmp1, cmp2) > 0;
}
# 140 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ktime_before(const ktime_t cmp1, const ktime_t cmp2)
{
 return ktime_compare(cmp1, cmp2) < 0;
}
# 165 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_divns(const ktime_t kt, s64 div)
{




 ({ int __ret_warn_on = !!(div < 0); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/ktime.h"), "i" (171), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/ktime.h"), "i" (171), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return kt / div;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_us(const ktime_t kt)
{
 return ktime_divns(kt, 1000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_to_ms(const ktime_t kt)
{
 return ktime_divns(kt, 1000000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_us_delta(const ktime_t later, const ktime_t earlier)
{
       return ktime_to_us(((later) - (earlier)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 ktime_ms_delta(const ktime_t later, const ktime_t earlier)
{
 return ktime_to_ms(((later) - (earlier)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
 return ((kt) + (usec * 1000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_add_ms(const ktime_t kt, const u64 msec)
{
 return ((kt) + (msec * 1000000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_sub_us(const ktime_t kt, const u64 usec)
{
 return ((kt) - (usec * 1000L));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_sub_ms(const ktime_t kt, const u64 msec)
{
 return ((kt) - (msec * 1000000L));
}

extern ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs);
# 226 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool ktime_to_timespec_cond(const ktime_t kt,
             struct timespec *ts)
{
 if (kt) {
  *ts = ns_to_timespec((kt));
  return true;
 } else {
  return false;
 }
}
# 245 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool ktime_to_timespec64_cond(const ktime_t kt,
             struct timespec64 *ts)
{
 if (kt) {
  *ts = ns_to_timespec64((kt));
  return true;
 } else {
  return false;
 }
}
# 265 "/home/nathan/src/linux-next/include/linux/ktime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ns_to_ktime(u64 ns)
{
 return ns;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ms_to_ktime(u64 ms)
{
 return ms * 1000000L;
}


# 1 "/home/nathan/src/linux-next/include/linux/timekeeping.h" 1








void timekeeping_init(void);
extern int timekeeping_suspended;


extern void update_process_times(int user);
extern void xtime_update(unsigned long ticks);




extern int do_settimeofday64(const struct timespec64 *ts);
extern int do_sys_settimeofday64(const struct timespec64 *tv,
     const struct timezone *tz);
# 41 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
extern void ktime_get_raw_ts64(struct timespec64 *ts);
extern void ktime_get_ts64(struct timespec64 *ts);
extern void ktime_get_real_ts64(struct timespec64 *tv);
extern void ktime_get_coarse_ts64(struct timespec64 *ts);
extern void ktime_get_coarse_real_ts64(struct timespec64 *ts);

void getboottime64(struct timespec64 *ts);




extern time64_t ktime_get_seconds(void);
extern time64_t __ktime_get_real_seconds(void);
extern time64_t ktime_get_real_seconds(void);





enum tk_offsets {
 TK_OFFS_REAL,
 TK_OFFS_BOOT,
 TK_OFFS_TAI,
 TK_OFFS_MAX,
};

extern ktime_t ktime_get(void);
extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
extern ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs);
extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
extern ktime_t ktime_get_raw(void);
extern u32 ktime_get_resolution_ns(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_real(void)
{
 return ktime_get_with_offset(TK_OFFS_REAL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_real(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_REAL);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_boottime(void)
{
 return ktime_get_with_offset(TK_OFFS_BOOT);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_boottime(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_BOOT);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_clocktai(void)
{
 return ktime_get_with_offset(TK_OFFS_TAI);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse_clocktai(void)
{
 return ktime_get_coarse_with_offset(TK_OFFS_TAI);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_get_coarse(void)
{
 struct timespec64 ts;

 ktime_get_coarse_ts64(&ts);
 return timespec64_to_ktime(ts);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_ns(void)
{
 return ktime_to_ns(ktime_get_coarse());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_real_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_real());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_boottime_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_boottime());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_coarse_clocktai_ns(void)
{
 return ktime_to_ns(ktime_get_coarse_clocktai());
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t ktime_mono_to_real(ktime_t mono)
{
 return ktime_mono_to_any(mono, TK_OFFS_REAL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_ns(void)
{
 return ktime_to_ns(ktime_get());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_real_ns(void)
{
 return ktime_to_ns(ktime_get_real());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_boottime_ns(void)
{
 return ktime_to_ns(ktime_get_boottime());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_clocktai_ns(void)
{
 return ktime_to_ns(ktime_get_clocktai());
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ktime_get_raw_ns(void)
{
 return ktime_to_ns(ktime_get_raw());
}

extern u64 ktime_get_mono_fast_ns(void);
extern u64 ktime_get_raw_fast_ns(void);
extern u64 ktime_get_boot_fast_ns(void);
extern u64 ktime_get_real_fast_ns(void);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_boottime_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_boottime()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_coarse_boottime_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_coarse_boottime()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) time64_t ktime_get_boottime_seconds(void)
{
 return ktime_divns(ktime_get_coarse_boottime(), 1000000000L);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_clocktai_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_clocktai()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_coarse_clocktai_ts64(struct timespec64 *ts)
{
 *ts = ns_to_timespec64((ktime_get_coarse_clocktai()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) time64_t ktime_get_clocktai_seconds(void)
{
 return ktime_divns(ktime_get_coarse_clocktai(), 1000000000L);
}




extern bool timekeeping_rtc_skipsuspend(void);
extern bool timekeeping_rtc_skipresume(void);

extern void timekeeping_inject_sleeptime64(const struct timespec64 *delta);
# 234 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_time_snapshot {
 u64 cycles;
 ktime_t real;
 ktime_t raw;
 unsigned int clock_was_set_seq;
 u8 cs_was_changed_seq;
};
# 249 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_device_crosststamp {
 ktime_t device;
 ktime_t sys_realtime;
 ktime_t sys_monoraw;
};
# 262 "/home/nathan/src/linux-next/include/linux/timekeeping.h"
struct system_counterval_t {
 u64 cycles;
 struct clocksource *cs;
};




extern int get_device_system_crosststamp(
   int (*get_time_fn)(ktime_t *device_time,
    struct system_counterval_t *system_counterval,
    void *ctx),
   void *ctx,
   struct system_time_snapshot *history,
   struct system_device_crosststamp *xtstamp);




extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);




extern int persistent_clock_is_local;

extern void read_persistent_clock64(struct timespec64 *ts);
void read_persistent_wall_and_boot_offset(struct timespec64 *wall_clock,
       struct timespec64 *boot_offset);
extern int update_persistent_clock64(struct timespec64 now);
# 276 "/home/nathan/src/linux-next/include/linux/ktime.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/timekeeping32.h" 1








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_seconds(void)
{
 return ktime_get_real_seconds();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void getnstimeofday(struct timespec *ts)
{
 struct timespec64 ts64;

 ktime_get_real_ts64(&ts64);
 *ts = timespec64_to_timespec(ts64);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ktime_get_ts(struct timespec *ts)
{
 struct timespec64 ts64;

 ktime_get_ts64(&ts64);
 *ts = timespec64_to_timespec(ts64);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void getrawmonotonic(struct timespec *ts)
{
 struct timespec64 ts64;

 ktime_get_raw_ts64(&ts64);
 *ts = timespec64_to_timespec(ts64);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void getboottime(struct timespec *ts)
{
 struct timespec64 ts64;

 getboottime64(&ts64);
 *ts = timespec64_to_timespec(ts64);
}
# 277 "/home/nathan/src/linux-next/include/linux/ktime.h" 2
# 7 "/home/nathan/src/linux-next/include/linux/timer.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/debugobjects.h" 1







enum debug_obj_state {
 ODEBUG_STATE_NONE,
 ODEBUG_STATE_INIT,
 ODEBUG_STATE_INACTIVE,
 ODEBUG_STATE_ACTIVE,
 ODEBUG_STATE_DESTROYED,
 ODEBUG_STATE_NOTAVAILABLE,
 ODEBUG_STATE_MAX,
};

struct debug_obj_descr;
# 28 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
struct debug_obj {
 struct hlist_node node;
 enum debug_obj_state state;
 unsigned int astate;
 void *object;
 struct debug_obj_descr *descr;
};
# 55 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
struct debug_obj_descr {
 const char *name;
 void *(*debug_hint)(void *addr);
 bool (*is_static_object)(void *addr);
 bool (*fixup_init)(void *addr, enum debug_obj_state state);
 bool (*fixup_activate)(void *addr, enum debug_obj_state state);
 bool (*fixup_destroy)(void *addr, enum debug_obj_state state);
 bool (*fixup_free)(void *addr, enum debug_obj_state state);
 bool (*fixup_assert_init)(void *addr, enum debug_obj_state state);
};
# 88 "/home/nathan/src/linux-next/include/linux/debugobjects.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_init (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
debug_object_activate (void *addr, struct debug_obj_descr *descr) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_deactivate(void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_destroy (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_free (void *addr, struct debug_obj_descr *descr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_object_assert_init(void *addr, struct debug_obj_descr *descr) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_objects_early_init(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_objects_mem_init(void) { }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
debug_check_no_obj_freed(const void *address, unsigned long size) { }
# 9 "/home/nathan/src/linux-next/include/linux/timer.h" 2


struct timer_list {




 struct hlist_node entry;
 unsigned long expires;
 void (*function)(struct timer_list *);
 u32 flags;




};
# 90 "/home/nathan/src/linux-next/include/linux/timer.h"
void init_timer_key(struct timer_list *timer,
      void (*func)(struct timer_list *), unsigned int flags,
      const char *name, struct lock_class_key *key);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_timer_on_stack_key(struct timer_list *timer,
        void (*func)(struct timer_list *),
        unsigned int flags,
        const char *name,
        struct lock_class_key *key)
{
 init_timer_key(timer, func, flags, name, key);
}
# 149 "/home/nathan/src/linux-next/include/linux/timer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_timer_on_stack(struct timer_list *timer) { }
# 165 "/home/nathan/src/linux-next/include/linux/timer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int timer_pending(const struct timer_list * timer)
{
 return timer->entry.pprev != ((void *)0);
}

extern void add_timer_on(struct timer_list *timer, int cpu);
extern int del_timer(struct timer_list * timer);
extern int mod_timer(struct timer_list *timer, unsigned long expires);
extern int mod_timer_pending(struct timer_list *timer, unsigned long expires);
extern int timer_reduce(struct timer_list *timer, unsigned long expires);







extern void add_timer(struct timer_list *timer);

extern int try_to_del_timer_sync(struct timer_list *timer);


  extern int del_timer_sync(struct timer_list *timer);






extern void init_timers(void);
extern void run_local_timers(void);
struct hrtimer;
extern enum hrtimer_restart it_real_fn(struct hrtimer *);


struct ctl_table;

extern unsigned int sysctl_timer_migration;
int timer_migration_handler(struct ctl_table *table, int write,
       void *buffer, size_t *lenp,
       loff_t *ppos);


unsigned long __round_jiffies(unsigned long j, int cpu);
unsigned long __round_jiffies_relative(unsigned long j, int cpu);
unsigned long round_jiffies(unsigned long j);
unsigned long round_jiffies_relative(unsigned long j);

unsigned long __round_jiffies_up(unsigned long j, int cpu);
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu);
unsigned long round_jiffies_up(unsigned long j);
unsigned long round_jiffies_up_relative(unsigned long j);


int timers_prepare_cpu(unsigned int cpu);
int timers_dead_cpu(unsigned int cpu);
# 10 "/home/nathan/src/linux-next/include/linux/workqueue.h" 2








struct workqueue_struct;

struct work_struct;
typedef void (*work_func_t)(struct work_struct *work);
void delayed_work_timer_fn(struct timer_list *t);







enum {
 WORK_STRUCT_PENDING_BIT = 0,
 WORK_STRUCT_DELAYED_BIT = 1,
 WORK_STRUCT_PWQ_BIT = 2,
 WORK_STRUCT_LINKED_BIT = 3,




 WORK_STRUCT_COLOR_SHIFT = 4,


 WORK_STRUCT_COLOR_BITS = 4,

 WORK_STRUCT_PENDING = 1 << WORK_STRUCT_PENDING_BIT,
 WORK_STRUCT_DELAYED = 1 << WORK_STRUCT_DELAYED_BIT,
 WORK_STRUCT_PWQ = 1 << WORK_STRUCT_PWQ_BIT,
 WORK_STRUCT_LINKED = 1 << WORK_STRUCT_LINKED_BIT,



 WORK_STRUCT_STATIC = 0,






 WORK_NR_COLORS = (1 << WORK_STRUCT_COLOR_BITS) - 1,
 WORK_NO_COLOR = WORK_NR_COLORS,


 WORK_CPU_UNBOUND = 2048,






 WORK_STRUCT_FLAG_BITS = WORK_STRUCT_COLOR_SHIFT +
      WORK_STRUCT_COLOR_BITS,


 WORK_OFFQ_FLAG_BASE = WORK_STRUCT_COLOR_SHIFT,

 __WORK_OFFQ_CANCELING = WORK_OFFQ_FLAG_BASE,
 WORK_OFFQ_CANCELING = (1 << __WORK_OFFQ_CANCELING),






 WORK_OFFQ_FLAG_BITS = 1,
 WORK_OFFQ_POOL_SHIFT = WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS,
 WORK_OFFQ_LEFT = 64 - WORK_OFFQ_POOL_SHIFT,
 WORK_OFFQ_POOL_BITS = WORK_OFFQ_LEFT <= 31 ? WORK_OFFQ_LEFT : 31,
 WORK_OFFQ_POOL_NONE = (1LU << WORK_OFFQ_POOL_BITS) - 1,


 WORK_STRUCT_FLAG_MASK = (1UL << WORK_STRUCT_FLAG_BITS) - 1,
 WORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,
 WORK_STRUCT_NO_POOL = (unsigned long)WORK_OFFQ_POOL_NONE << WORK_OFFQ_POOL_SHIFT,


 WORK_BUSY_PENDING = 1 << 0,
 WORK_BUSY_RUNNING = 1 << 1,


 WORKER_DESC_LEN = 24,
};

struct work_struct {
 atomic_long_t data;
 struct list_head entry;
 work_func_t func;



};





struct delayed_work {
 struct work_struct work;
 struct timer_list timer;


 struct workqueue_struct *wq;
 int cpu;
};

struct rcu_work {
 struct work_struct work;
 struct callback_head rcu;


 struct workqueue_struct *wq;
};






struct workqueue_attrs {



 int nice;




 cpumask_var_t cpumask;
# 155 "/home/nathan/src/linux-next/include/linux/workqueue.h"
 bool no_numa;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct delayed_work *to_delayed_work(struct work_struct *work)
{
 return ({ void *__mptr = (void *)(work); do { extern void __compiletime_assert_160(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(work)), typeof(((struct delayed_work *)0)->work)) && !__builtin_types_compatible_p(typeof(*(work)), typeof(void))))) __compiletime_assert_160(); } while (0); ((struct delayed_work *)(__mptr - __builtin_offsetof(struct delayed_work, work))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rcu_work *to_rcu_work(struct work_struct *work)
{
 return ({ void *__mptr = (void *)(work); do { extern void __compiletime_assert_165(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(work)), typeof(((struct rcu_work *)0)->work)) && !__builtin_types_compatible_p(typeof(*(work)), typeof(void))))) __compiletime_assert_165(); } while (0); ((struct rcu_work *)(__mptr - __builtin_offsetof(struct rcu_work, work))); });
}

struct execute_work {
 struct work_struct work;
};
# 215 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __init_work(struct work_struct *work, int onstack) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_work_on_stack(struct work_struct *work) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_delayed_work_on_stack(struct delayed_work *work) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int work_static(struct work_struct *work) { return 0; }
# 308 "/home/nathan/src/linux-next/include/linux/workqueue.h"
enum {
 WQ_UNBOUND = 1 << 1,
 WQ_FREEZABLE = 1 << 2,
 WQ_MEM_RECLAIM = 1 << 3,
 WQ_HIGHPRI = 1 << 4,
 WQ_CPU_INTENSIVE = 1 << 5,
 WQ_SYSFS = 1 << 6,
# 341 "/home/nathan/src/linux-next/include/linux/workqueue.h"
 WQ_POWER_EFFICIENT = 1 << 7,

 __WQ_DRAINING = 1 << 16,
 __WQ_ORDERED = 1 << 17,
 __WQ_LEGACY = 1 << 18,
 __WQ_ORDERED_EXPLICIT = 1 << 19,

 WQ_MAX_ACTIVE = 512,
 WQ_MAX_UNBOUND_PER_CPU = 4,
 WQ_DFL_ACTIVE = WQ_MAX_ACTIVE / 2,
};
# 385 "/home/nathan/src/linux-next/include/linux/workqueue.h"
extern struct workqueue_struct *system_wq;
extern struct workqueue_struct *system_highpri_wq;
extern struct workqueue_struct *system_long_wq;
extern struct workqueue_struct *system_unbound_wq;
extern struct workqueue_struct *system_freezable_wq;
extern struct workqueue_struct *system_power_efficient_wq;
extern struct workqueue_struct *system_freezable_power_efficient_wq;
# 407 "/home/nathan/src/linux-next/include/linux/workqueue.h"
struct workqueue_struct *alloc_workqueue(const char *fmt,
      unsigned int flags,
      int max_active, ...);
# 436 "/home/nathan/src/linux-next/include/linux/workqueue.h"
extern void destroy_workqueue(struct workqueue_struct *wq);

struct workqueue_attrs *alloc_workqueue_attrs(void);
void free_workqueue_attrs(struct workqueue_attrs *attrs);
int apply_workqueue_attrs(struct workqueue_struct *wq,
     const struct workqueue_attrs *attrs);
int workqueue_set_unbound_cpumask(cpumask_var_t cpumask);

extern bool queue_work_on(int cpu, struct workqueue_struct *wq,
   struct work_struct *work);
extern bool queue_work_node(int node, struct workqueue_struct *wq,
       struct work_struct *work);
extern bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *work, unsigned long delay);
extern bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *dwork, unsigned long delay);
extern bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork);

extern void flush_workqueue(struct workqueue_struct *wq);
extern void drain_workqueue(struct workqueue_struct *wq);

extern int schedule_on_each_cpu(work_func_t func);

int execute_in_process_context(work_func_t fn, struct execute_work *);

extern bool flush_work(struct work_struct *work);
extern bool cancel_work_sync(struct work_struct *work);

extern bool flush_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work_sync(struct delayed_work *dwork);

extern bool flush_rcu_work(struct rcu_work *rwork);

extern void workqueue_set_max_active(struct workqueue_struct *wq,
         int max_active);
extern struct work_struct *current_work(void);
extern bool current_is_workqueue_rescuer(void);
extern bool workqueue_congested(int cpu, struct workqueue_struct *wq);
extern unsigned int work_busy(struct work_struct *work);
extern __attribute__((__format__(printf, 1, 2))) void set_worker_desc(const char *fmt, ...);
extern void print_worker_info(const char *log_lvl, struct task_struct *task);
extern void show_workqueue_state(void);
extern void wq_worker_comm(char *buf, size_t size, struct task_struct *task);
# 491 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool queue_work(struct workqueue_struct *wq,
         struct work_struct *work)
{
 return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
# 505 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool queue_delayed_work(struct workqueue_struct *wq,
          struct delayed_work *dwork,
          unsigned long delay)
{
 return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
# 520 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mod_delayed_work(struct workqueue_struct *wq,
        struct delayed_work *dwork,
        unsigned long delay)
{
 return mod_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
# 534 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_work_on(int cpu, struct work_struct *work)
{
 return queue_work_on(cpu, system_wq, work);
}
# 550 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_work(struct work_struct *work)
{
 return queue_work(system_wq, work);
}
# 579 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_scheduled_work(void)
{
 flush_workqueue(system_wq);
}
# 593 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork,
         unsigned long delay)
{
 return queue_delayed_work_on(cpu, system_wq, dwork, delay);
}
# 607 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool schedule_delayed_work(struct delayed_work *dwork,
      unsigned long delay)
{
 return queue_delayed_work(system_wq, dwork, delay);
}
# 623 "/home/nathan/src/linux-next/include/linux/workqueue.h"
long work_on_cpu(int cpu, long (*fn)(void *), void *arg);
long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg);



extern void freeze_workqueues_begin(void);
extern bool freeze_workqueues_busy(void);
extern void thaw_workqueues(void);



int workqueue_sysfs_register(struct workqueue_struct *wq);
# 643 "/home/nathan/src/linux-next/include/linux/workqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wq_watchdog_touch(int cpu) { }



int workqueue_prepare_cpu(unsigned int cpu);
int workqueue_online_cpu(unsigned int cpu);
int workqueue_offline_cpu(unsigned int cpu);


int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) workqueue_init_early(void);
int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) workqueue_init(void);
# 22 "/home/nathan/src/linux-next/include/linux/srcu.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h"
struct rcu_cblist {
 struct callback_head *head;
 struct callback_head **tail;
 long len;
};
# 66 "/home/nathan/src/linux-next/include/linux/rcu_segcblist.h"
struct rcu_segcblist {
 struct callback_head *head;
 struct callback_head **tails[4];
 unsigned long gp_seq[4];



 long len;

 u8 enabled;
 u8 offloaded;
};
# 23 "/home/nathan/src/linux-next/include/linux/srcu.h" 2

struct srcu_struct;
# 41 "/home/nathan/src/linux-next/include/linux/srcu.h"
int init_srcu_struct(struct srcu_struct *ssp);








# 1 "/home/nathan/src/linux-next/include/linux/srcutree.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/srcutree.h"
# 1 "/home/nathan/src/linux-next/include/linux/rcu_node_tree.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/srcutree.h" 2


struct srcu_node;
struct srcu_struct;





struct srcu_data {

 unsigned long srcu_lock_count[2];
 unsigned long srcu_unlock_count[2];


 spinlock_t lock __attribute__((__aligned__(1 << (7))));
 struct rcu_segcblist srcu_cblist;
 unsigned long srcu_gp_seq_needed;
 unsigned long srcu_gp_seq_needed_exp;
 bool srcu_cblist_invoking;
 struct timer_list delay_work;
 struct work_struct work;
 struct callback_head srcu_barrier_head;
 struct srcu_node *mynode;
 unsigned long grpmask;

 int cpu;
 struct srcu_struct *ssp;
};




struct srcu_node {
 spinlock_t lock;
 unsigned long srcu_have_cbs[4];


 unsigned long srcu_data_have_cbs[4];

 unsigned long srcu_gp_seq_needed_exp;
 struct srcu_node *srcu_parent;
 int grplo;
 int grphi;
};




struct srcu_struct {
 struct srcu_node node[(1 + (((2048) + (((16) * 64)) - 1) / (((16) * 64))) + (((2048) + ((16)) - 1) / ((16))))];
 struct srcu_node *level[3 + 1];

 struct mutex srcu_cb_mutex;
 spinlock_t lock;
 struct mutex srcu_gp_mutex;
 unsigned int srcu_idx;
 unsigned long srcu_gp_seq;
 unsigned long srcu_gp_seq_needed;
 unsigned long srcu_gp_seq_needed_exp;
 unsigned long srcu_last_gp_end;
 struct srcu_data *sda;
 unsigned long srcu_barrier_seq;
 struct mutex srcu_barrier_mutex;
 struct completion srcu_barrier_completion;

 atomic_t srcu_barrier_cpu_cnt;


 struct delayed_work work;



};
# 137 "/home/nathan/src/linux-next/include/linux/srcutree.h"
void synchronize_srcu_expedited(struct srcu_struct *ssp);
void srcu_barrier(struct srcu_struct *ssp);
void srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf);
# 50 "/home/nathan/src/linux-next/include/linux/srcu.h" 2







void call_srcu(struct srcu_struct *ssp, struct callback_head *head,
  void (*func)(struct callback_head *head));
void cleanup_srcu_struct(struct srcu_struct *ssp);
int __srcu_read_lock(struct srcu_struct *ssp) ;
void __srcu_read_unlock(struct srcu_struct *ssp, int idx) ;
void synchronize_srcu(struct srcu_struct *ssp);
# 91 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int srcu_read_lock_held(const struct srcu_struct *ssp)
{
 return 1;
}
# 150 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int srcu_read_lock(struct srcu_struct *ssp)
{
 int retval;

 retval = __srcu_read_lock(ssp);
 do { } while (0);
 return retval;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) int
srcu_read_lock_notrace(struct srcu_struct *ssp)
{
 int retval;

 retval = __srcu_read_lock(ssp);
 return retval;
}
# 176 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void srcu_read_unlock(struct srcu_struct *ssp, int idx)

{
 ({ int __ret_warn_on = !!(idx & ~0x1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/srcu.h"), "i" (179), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 do { } while (0);
 __srcu_read_unlock(ssp, idx);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__no_instrument_function__)) void
srcu_read_unlock_notrace(struct srcu_struct *ssp, int idx)
{
 __srcu_read_unlock(ssp, idx);
}
# 200 "/home/nathan/src/linux-next/include/linux/srcu.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void smp_mb__after_srcu_read_unlock(void)
{

}
# 17 "/home/nathan/src/linux-next/include/linux/notifier.h" 2
# 49 "/home/nathan/src/linux-next/include/linux/notifier.h"
struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *nb,
   unsigned long action, void *data);

struct notifier_block {
 notifier_fn_t notifier_call;
 struct notifier_block *next;
 int priority;
};

struct atomic_notifier_head {
 spinlock_t lock;
 struct notifier_block *head;
};

struct blocking_notifier_head {
 struct rw_semaphore rwsem;
 struct notifier_block *head;
};

struct raw_notifier_head {
 struct notifier_block *head;
};

struct srcu_notifier_head {
 struct mutex mutex;
 struct srcu_struct srcu;
 struct notifier_block *head;
};
# 93 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
# 144 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_register(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,
  unsigned long val, void *v);
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
  unsigned long val, void *v);
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int raw_notifier_call_chain(struct raw_notifier_head *nh,
  unsigned long val, void *v);
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
  unsigned long val, void *v);
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
# 190 "/home/nathan/src/linux-next/include/linux/notifier.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notifier_from_errno(int err)
{
 if (err)
  return 0x8000 | (0x0001 - err);

 return 0x0001;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int notifier_to_errno(int ret)
{
 ret &= ~0x8000;
 return ret > 0x0001 ? 0x0001 - ret : 0;
}
# 234 "/home/nathan/src/linux-next/include/linux/notifier.h"
extern struct blocking_notifier_head reboot_notifier_list;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
typedef u32 ppc_opcode_t;
# 35 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void enable_single_step(struct pt_regs *regs)
{
 regs->msr |= ((1UL<<(10)));
# 50 "/home/nathan/src/linux-next/arch/powerpc/include/asm/probes.h"
}
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h" 2

typedef ppc_opcode_t uprobe_opcode_t;
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uprobes.h"
struct arch_uprobe {
 union {
  u32 insn;
  u32 ixol;
 };
};

struct arch_uprobe_task {
 unsigned long saved_trap_nr;
};
# 50 "/home/nathan/src/linux-next/include/linux/uprobes.h" 2

enum uprobe_task_state {
 UTASK_RUNNING,
 UTASK_SSTEP,
 UTASK_SSTEP_ACK,
 UTASK_SSTEP_TRAPPED,
};




struct uprobe_task {
 enum uprobe_task_state state;

 union {
  struct {
   struct arch_uprobe_task autask;
   unsigned long vaddr;
  };

  struct {
   struct callback_head dup_xol_work;
   unsigned long dup_xol_addr;
  };
 };

 struct uprobe *active_uprobe;
 unsigned long xol_vaddr;

 struct return_instance *return_instances;
 unsigned int depth;
};

struct return_instance {
 struct uprobe *uprobe;
 unsigned long func;
 unsigned long stack;
 unsigned long orig_ret_vaddr;
 bool chained;

 struct return_instance *next;
};

enum rp_check {
 RP_CHECK_CALL,
 RP_CHECK_CHAIN_CALL,
 RP_CHECK_RET,
};

struct xol_area;

struct uprobes_state {
 struct xol_area *xol_area;
};

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) uprobes_init(void);
extern int set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
extern int set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
extern bool is_swbp_insn(uprobe_opcode_t *insn);
extern bool is_trap_insn(uprobe_opcode_t *insn);
extern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);
extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
extern int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
extern int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc);
extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
extern int uprobe_mmap(struct vm_area_struct *vma);
extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
extern void uprobe_start_dup_mmap(void);
extern void uprobe_end_dup_mmap(void);
extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
extern void uprobe_free_utask(struct task_struct *t);
extern void uprobe_copy_process(struct task_struct *t, unsigned long flags);
extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
extern void uprobe_notify_resume(struct pt_regs *regs);
extern bool uprobe_deny_signal(void);
extern bool arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
extern void uprobe_clear_state(struct mm_struct *mm);
extern int arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);
extern int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern int arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
extern int arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
extern bool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx, struct pt_regs *regs);
extern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
      void *src, unsigned long len);
# 15 "/home/nathan/src/linux-next/include/linux/mm_types.h" 2
# 26 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct address_space;
struct mem_cgroup;
# 68 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct page {
 unsigned long flags;







 union {
  struct {





   struct list_head lru;

   struct address_space *mapping;
   unsigned long index;






   unsigned long private;
  };
  struct {




   dma_addr_t dma_addr;
  };
  struct {
   union {
    struct list_head slab_list;
    struct {
     struct page *next;

     int pages;
     int pobjects;




    };
   };
   struct kmem_cache *slab_cache;

   void *freelist;
   union {
    void *s_mem;
    unsigned long counters;
    struct {
     unsigned inuse:16;
     unsigned objects:15;
     unsigned frozen:1;
    };
   };
  };
  struct {
   unsigned long compound_head;


   unsigned char compound_dtor;
   unsigned char compound_order;
   atomic_t compound_mapcount;
  };
  struct {
   unsigned long _compound_pad_1;
   unsigned long _compound_pad_2;

   struct list_head deferred_list;
  };
  struct {
   unsigned long _pt_pad_1;
   pgtable_t pmd_huge_pte;
   unsigned long _pt_pad_2;
   union {
    struct mm_struct *pt_mm;
    atomic_t pt_frag_refcount;
   };



   spinlock_t ptl;

  };
  struct {

   struct dev_pagemap *pgmap;
   void *zone_device_data;
# 172 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  };


  struct callback_head callback_head;
 };

 union {




  atomic_t _mapcount;







  unsigned int page_type;

  unsigned int active;
  int units;
 };


 atomic_t _refcount;


 struct mem_cgroup *mem_cgroup;
# 222 "/home/nathan/src/linux-next/include/linux/mm_types.h"
} ;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) atomic_t *compound_mapcount_ptr(struct page *page)
{
 return &page[1].compound_mapcount;
}
# 240 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct page_frag_cache {
 void * va;




 __u32 offset;




 unsigned int pagecnt_bias;
 bool pfmemalloc;
};

typedef unsigned long vm_flags_t;






struct vm_region {
 struct rb_node vm_rb;
 vm_flags_t vm_flags;
 unsigned long vm_start;
 unsigned long vm_end;
 unsigned long vm_top;
 unsigned long vm_pgoff;
 struct file *vm_file;

 int vm_usage;
 bool vm_icache_flushed : 1;

};
# 283 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct vm_userfaultfd_ctx {};
# 292 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct vm_area_struct {


 unsigned long vm_start;
 unsigned long vm_end;



 struct vm_area_struct *vm_next, *vm_prev;

 struct rb_node vm_rb;







 unsigned long rb_subtree_gap;



 struct mm_struct *vm_mm;





 pgprot_t vm_page_prot;
 unsigned long vm_flags;





 struct {
  struct rb_node rb;
  unsigned long rb_subtree_last;
 } shared;







 struct list_head anon_vma_chain;

 struct anon_vma *anon_vma;


 const struct vm_operations_struct *vm_ops;


 unsigned long vm_pgoff;

 struct file * vm_file;
 void * vm_private_data;


 atomic_long_t swap_readahead_info;





 struct mempolicy *vm_policy;

 struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
} ;

struct core_thread {
 struct task_struct *task;
 struct core_thread *next;
};

struct core_state {
 atomic_t nr_threads;
 struct core_thread dumper;
 struct completion startup;
};

struct kioctx_table;
struct mm_struct {
 struct {
  struct vm_area_struct *mmap;
  struct rb_root mm_rb;
  u64 vmacache_seqnum;

  unsigned long (*get_unmapped_area) (struct file *filp,
    unsigned long addr, unsigned long len,
    unsigned long pgoff, unsigned long flags);

  unsigned long mmap_base;
  unsigned long mmap_legacy_base;





  unsigned long task_size;
  unsigned long highest_vm_end;
  pgd_t * pgd;
# 403 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t membarrier_state;
# 415 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t mm_users;
# 424 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  atomic_t mm_count;


  atomic_long_t pgtables_bytes;

  int map_count;

  spinlock_t page_table_lock;


  struct rw_semaphore mmap_sem;

  struct list_head mmlist;






  unsigned long hiwater_rss;
  unsigned long hiwater_vm;

  unsigned long total_vm;
  unsigned long locked_vm;
  atomic64_t pinned_vm;
  unsigned long data_vm;
  unsigned long exec_vm;
  unsigned long stack_vm;
  unsigned long def_flags;

  spinlock_t arg_lock;
  unsigned long start_code, end_code, start_data, end_data;
  unsigned long start_brk, brk, start_stack;
  unsigned long arg_start, arg_end, env_start, env_end;

  unsigned long saved_auxv[(2*(14 + 20 + 1))];





  struct mm_rss_stat rss_stat;

  struct linux_binfmt *binfmt;


  mm_context_t context;

  unsigned long flags;

  struct core_state *core_state;


  spinlock_t ioctx_lock;
  struct kioctx_table *ioctx_table;
# 491 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  struct task_struct *owner;

  struct user_namespace *user_ns;


  struct file *exe_file;

  struct mmu_notifier_subscriptions *notifier_subscriptions;
# 509 "/home/nathan/src/linux-next/include/linux/mm_types.h"
  unsigned long numa_next_scan;


  unsigned long numa_scan_offset;


  int numa_scan_seq;






  atomic_t tlb_flush_pending;




  struct uprobes_state uprobes_state;

  atomic_long_t hugetlb_usage;

  struct work_struct async_put_work;
 } ;





 unsigned long cpu_bitmap[];
};

extern struct mm_struct init_mm;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_init_cpumask(struct mm_struct *mm)
{
 unsigned long cpu_bitmap = (unsigned long)mm;

 cpu_bitmap += __builtin_offsetof(struct mm_struct, cpu_bitmap);
 cpumask_clear((struct cpumask *)cpu_bitmap);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) cpumask_t *mm_cpumask(struct mm_struct *mm)
{
 return (struct cpumask *)&mm->cpu_bitmap;
}

struct mmu_gather;
extern void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,
    unsigned long start, unsigned long end);
extern void tlb_finish_mmu(struct mmu_gather *tlb,
    unsigned long start, unsigned long end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_tlb_flush_pending(struct mm_struct *mm)
{
 atomic_set(&mm->tlb_flush_pending, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_tlb_flush_pending(struct mm_struct *mm)
{
 atomic_inc(&mm->tlb_flush_pending);
# 608 "/home/nathan/src/linux-next/include/linux/mm_types.h"
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_tlb_flush_pending(struct mm_struct *mm)
{
# 620 "/home/nathan/src/linux-next/include/linux/mm_types.h"
 atomic_dec(&mm->tlb_flush_pending);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mm_tlb_flush_pending(struct mm_struct *mm)
{
# 633 "/home/nathan/src/linux-next/include/linux/mm_types.h"
 return atomic_read(&mm->tlb_flush_pending);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mm_tlb_flush_nested(struct mm_struct *mm)
{







 return atomic_read(&mm->tlb_flush_pending) > 1;
}

struct vm_fault;






typedef unsigned int vm_fault_t;
# 682 "/home/nathan/src/linux-next/include/linux/mm_types.h"
enum vm_fault_reason {
 VM_FAULT_OOM = ( vm_fault_t)0x000001,
 VM_FAULT_SIGBUS = ( vm_fault_t)0x000002,
 VM_FAULT_MAJOR = ( vm_fault_t)0x000004,
 VM_FAULT_WRITE = ( vm_fault_t)0x000008,
 VM_FAULT_HWPOISON = ( vm_fault_t)0x000010,
 VM_FAULT_HWPOISON_LARGE = ( vm_fault_t)0x000020,
 VM_FAULT_SIGSEGV = ( vm_fault_t)0x000040,
 VM_FAULT_NOPAGE = ( vm_fault_t)0x000100,
 VM_FAULT_LOCKED = ( vm_fault_t)0x000200,
 VM_FAULT_RETRY = ( vm_fault_t)0x000400,
 VM_FAULT_FALLBACK = ( vm_fault_t)0x000800,
 VM_FAULT_DONE_COW = ( vm_fault_t)0x001000,
 VM_FAULT_NEEDDSYNC = ( vm_fault_t)0x002000,
 VM_FAULT_HINDEX_MASK = ( vm_fault_t)0x0f0000,
};
# 722 "/home/nathan/src/linux-next/include/linux/mm_types.h"
struct vm_special_mapping {
 const char *name;







 struct page **pages;





 vm_fault_t (*fault)(const struct vm_special_mapping *sm,
    struct vm_area_struct *vma,
    struct vm_fault *vmf);

 int (*mremap)(const struct vm_special_mapping *sm,
       struct vm_area_struct *new_vma);
};

enum tlb_flush_reason {
 TLB_FLUSH_ON_TASK_SWITCH,
 TLB_REMOTE_SHOOTDOWN,
 TLB_LOCAL_SHOOTDOWN,
 TLB_LOCAL_MM_SHOOTDOWN,
 TLB_REMOTE_SEND_IPI,
 NR_TLB_FLUSH_REASONS,
};





typedef struct {
 unsigned long val;
} swp_entry_t;
# 22 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/page-flags.h" 1
# 99 "/home/nathan/src/linux-next/include/linux/page-flags.h"
enum pageflags {
 PG_locked,
 PG_referenced,
 PG_uptodate,
 PG_dirty,
 PG_lru,
 PG_active,
 PG_workingset,
 PG_waiters,
 PG_error,
 PG_slab,
 PG_owner_priv_1,
 PG_arch_1,
 PG_reserved,
 PG_private,
 PG_private_2,
 PG_writeback,
 PG_head,
 PG_mappedtodisk,
 PG_reclaim,
 PG_swapbacked,
 PG_unevictable,

 PG_mlocked,
# 134 "/home/nathan/src/linux-next/include/linux/page-flags.h"
 __NR_PAGEFLAGS,


 PG_checked = PG_owner_priv_1,


 PG_swapcache = PG_owner_priv_1,





 PG_fscache = PG_private_2,



 PG_pinned = PG_owner_priv_1,

 PG_savepinned = PG_dirty,

 PG_foreign = PG_owner_priv_1,

 PG_xen_remapped = PG_owner_priv_1,


 PG_slob_free = PG_private,


 PG_double_map = PG_private_2,


 PG_isolated = PG_reclaim,
};



struct page;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *compound_head(struct page *page)
{
 unsigned long head = ({ union { typeof(page->compound_head) __val; char __c[1]; } __u; if (1) __read_once_size(&(page->compound_head), __u.__c, sizeof(page->compound_head)); else __read_once_size_nocheck(&(page->compound_head), __u.__c, sizeof(page->compound_head)); do { } while (0); __u.__val; });

 if (__builtin_expect(!!(head & 1), 0))
  return (struct page *) (head - 1);
 return page;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageTail(struct page *page)
{
 return ({ union { typeof(page->compound_head) __val; char __c[1]; } __u; if (1) __read_once_size(&(page->compound_head), __u.__c, sizeof(page->compound_head)); else __read_once_size_nocheck(&(page->compound_head), __u.__c, sizeof(page->compound_head)); do { } while (0); __u.__val; }) & 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageCompound(struct page *page)
{
 return test_bit(PG_head, &page->flags) || PageTail(page);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PagePoisoned(const struct page *page)
{
 return page->flags == -1l;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_init_poison(struct page *page, size_t size)
{
}
# 312 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageLocked(struct page *page) { return test_bit(PG_locked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageLocked(struct page *page) { __set_bit(PG_locked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageLocked(struct page *page) { __clear_bit(PG_locked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWaiters(struct page *page) { return test_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageWaiters(struct page *page) { set_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageWaiters(struct page *page) { clear_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageWaiters(struct page *page) { __clear_bit(PG_waiters, &({ ((void)(sizeof(( long)(PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageError(struct page *page) { return test_bit(PG_error, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageError(struct page *page) { set_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageError(struct page *page) { clear_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageError(struct page *page) { return test_and_clear_bit(PG_error, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReferenced(struct page *page) { return test_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReferenced(struct page *page) { set_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReferenced(struct page *page) { clear_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReferenced(struct page *page) { return test_and_clear_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageReferenced(struct page *page) { __set_bit(PG_referenced, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageDirty(struct page *page) { return test_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageDirty(struct page *page) { set_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageDirty(struct page *page) { clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageDirty(struct page *page) { return test_and_set_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageDirty(struct page *page) { return test_and_clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageDirty(struct page *page) { __clear_bit(PG_dirty, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageLRU(struct page *page) { return test_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageLRU(struct page *page) { set_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageLRU(struct page *page) { clear_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageLRU(struct page *page) { __clear_bit(PG_lru, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageActive(struct page *page) { return test_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageActive(struct page *page) { set_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageActive(struct page *page) { clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageActive(struct page *page) { __clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageActive(struct page *page) { return test_and_clear_bit(PG_active, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWorkingset(struct page *page) { return test_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageWorkingset(struct page *page) { set_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageWorkingset(struct page *page) { clear_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageWorkingset(struct page *page) { return test_and_clear_bit(PG_workingset, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSlab(struct page *page) { return test_bit(PG_slab, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSlab(struct page *page) { __set_bit(PG_slab, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSlab(struct page *page) { __clear_bit(PG_slab, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSlobFree(struct page *page) { return test_bit(PG_slob_free, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSlobFree(struct page *page) { __set_bit(PG_slob_free, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSlobFree(struct page *page) { __clear_bit(PG_slob_free, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageChecked(struct page *page) { return test_bit(PG_checked, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageChecked(struct page *page) { set_bit(PG_checked, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageChecked(struct page *page) { clear_bit(PG_checked, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePinned(struct page *page) { return test_bit(PG_pinned, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePinned(struct page *page) { set_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePinned(struct page *page) { clear_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPagePinned(struct page *page) { return test_and_set_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPagePinned(struct page *page) { return test_and_clear_bit(PG_pinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSavePinned(struct page *page) { return test_bit(PG_savepinned, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSavePinned(struct page *page) { set_bit(PG_savepinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSavePinned(struct page *page) { clear_bit(PG_savepinned, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageForeign(struct page *page) { return test_bit(PG_foreign, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageForeign(struct page *page) { set_bit(PG_foreign, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageForeign(struct page *page) { clear_bit(PG_foreign, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageXenRemapped(struct page *page) { return test_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageXenRemapped(struct page *page) { set_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageXenRemapped(struct page *page) { clear_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageXenRemapped(struct page *page) { return test_and_clear_bit(PG_xen_remapped, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReserved(struct page *page) { return test_bit(PG_reserved, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReserved(struct page *page) { set_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReserved(struct page *page) { clear_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageReserved(struct page *page) { __clear_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageReserved(struct page *page) { __set_bit(PG_reserved, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSwapBacked(struct page *page) { return test_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSwapBacked(struct page *page) { set_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSwapBacked(struct page *page) { clear_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageSwapBacked(struct page *page) { __clear_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageSwapBacked(struct page *page) { __set_bit(PG_swapbacked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePrivate(struct page *page) { return test_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePrivate(struct page *page) { set_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePrivate(struct page *page) { clear_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPagePrivate(struct page *page) { __set_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPagePrivate(struct page *page) { __clear_bit(PG_private, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PagePrivate2(struct page *page) { return test_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPagePrivate2(struct page *page) { set_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPagePrivate2(struct page *page) { clear_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPagePrivate2(struct page *page) { return test_and_set_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPagePrivate2(struct page *page) { return test_and_clear_bit(PG_private_2, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageOwnerPriv1(struct page *page) { return test_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageOwnerPriv1(struct page *page) { set_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageOwnerPriv1(struct page *page) { clear_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageOwnerPriv1(struct page *page) { return test_and_clear_bit(PG_owner_priv_1, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageWriteback(struct page *page) { return test_bit(PG_writeback, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageWriteback(struct page *page) { return test_and_set_bit(PG_writeback, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageWriteback(struct page *page) { return test_and_clear_bit(PG_writeback, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMappedToDisk(struct page *page) { return test_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageMappedToDisk(struct page *page) { set_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageMappedToDisk(struct page *page) { clear_bit(PG_mappedtodisk, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReclaim(struct page *page) { return test_bit(PG_reclaim, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReclaim(struct page *page) { set_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReclaim(struct page *page) { clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReclaim(struct page *page) { return test_and_clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageReadahead(struct page *page) { return test_bit(PG_reclaim, &({ ((void)(sizeof(( long)(0 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageReadahead(struct page *page) { set_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageReadahead(struct page *page) { clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageReadahead(struct page *page) { return test_and_clear_bit(PG_reclaim, &({ ((void)(sizeof(( long)(1 && PageCompound(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; }); })->flags); }
# 376 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageHighMem(const struct page *page) { return 0; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageHighMem(struct page *page) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageHighMem(struct page *page) { }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageSwapCache(struct page *page)
{



 return PageSwapBacked(page) && test_bit(PG_swapcache, &page->flags);

}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageSwapCache(struct page *page) { set_bit(PG_swapcache, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageSwapCache(struct page *page) { clear_bit(PG_swapcache, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageUnevictable(struct page *page) { return test_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageUnevictable(struct page *page) { set_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageUnevictable(struct page *page) { clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageUnevictable(struct page *page) { __clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageUnevictable(struct page *page) { return test_and_clear_bit(PG_unevictable, &({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); })->flags); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMlocked(struct page *page) { return test_bit(PG_mlocked, &({ ((void)(sizeof(( long)(0 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageMlocked(struct page *page) { set_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageMlocked(struct page *page) { clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageMlocked(struct page *page) { __clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
 static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestSetPageMlocked(struct page *page) { return test_and_set_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int TestClearPageMlocked(struct page *page) { return test_and_clear_bit(PG_mlocked, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }
# 410 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageUncached(const struct page *page) { return 0; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageUncached(struct page *page) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageUncached(struct page *page) { }
# 419 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageHWPoison(const struct page *page) { return 0; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageHWPoison(struct page *page) { } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageHWPoison(struct page *page) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool set_hwpoison_free_buddy_page(struct page *page)
{
 return 0;
}
# 456 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageMappingFlags(struct page *page)
{
 return ((unsigned long)page->mapping & (0x1 | 0x2)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageAnon(struct page *page)
{
 page = compound_head(page);
 return ((unsigned long)page->mapping & 0x1) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int __PageMovable(struct page *page)
{
 return ((unsigned long)page->mapping & (0x1 | 0x2)) ==
    0x2;
}
# 480 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageKsm(struct page *page)
{
 page = compound_head(page);
 return ((unsigned long)page->mapping & (0x1 | 0x2)) ==
    (0x1 | 0x2);
}




u64 stable_page_flags(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageUptodate(struct page *page)
{
 int ret;
 page = compound_head(page);
 ret = test_bit(PG_uptodate, &(page)->flags);
# 505 "/home/nathan/src/linux-next/include/linux/page-flags.h"
 if (ret)
  __asm__ __volatile__ ("lwsync" " " : : :"memory");

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageUptodate(struct page *page)
{
 ((void)(sizeof(( long)(PageTail(page)))));
 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 __set_bit(PG_uptodate, &page->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void SetPageUptodate(struct page *page)
{
 ((void)(sizeof(( long)(PageTail(page)))));





 __asm__ __volatile__ ("lwsync" " " : : :"memory");
 set_bit(PG_uptodate, &page->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageUptodate(struct page *page) { clear_bit(PG_uptodate, &({ ((void)(sizeof(( long)(1 && PageTail(page))))); ({ ((void)(sizeof(( long)(PagePoisoned(compound_head(page)))))); compound_head(page); }); })->flags); }

int test_clear_page_writeback(struct page *page);
int __test_set_page_writeback(struct page *page, bool keep_write);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_writeback(struct page *page)
{
 __test_set_page_writeback(page, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_writeback_keepwrite(struct page *page)
{
 __test_set_page_writeback(page, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageHead(struct page *page) { return test_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageHead(struct page *page) { __set_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageHead(struct page *page) { __clear_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void ClearPageHead(struct page *page) { clear_bit(PG_head, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void set_compound_head(struct page *page, struct page *head)
{
 ({ union { typeof(page->compound_head) __val; char __c[1]; } __u = { .__val = ( typeof(page->compound_head)) ((unsigned long)head + 1) }; __write_once_size(&(page->compound_head), __u.__c, sizeof(page->compound_head)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void clear_compound_head(struct page *page)
{
 ({ union { typeof(page->compound_head) __val; char __c[1]; } __u = { .__val = ( typeof(page->compound_head)) (0) }; __write_once_size(&(page->compound_head), __u.__c, sizeof(page->compound_head)); __u.__val; });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageCompound(struct page *page)
{
 do { if (__builtin_constant_p(!PageHead(page))) { if (!PageHead(page)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (565), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/page-flags.h"), "i" (565), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!PageHead(page)))); } } while (0);
 ClearPageHead(page);
}





int PageHuge(struct page *page);
int PageHeadHuge(struct page *page);
bool page_huge_active(struct page *page);
# 596 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransHuge(struct page *page)
{
 ((void)(sizeof(( long)(PageTail(page)))));
 return PageHead(page);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransCompound(struct page *page)
{
 return PageCompound(page);
}
# 633 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransCompoundMap(struct page *page)
{
 struct page *head;

 if (!PageTransCompound(page))
  return 0;

 if (PageAnon(page))
  return atomic_read(&page->_mapcount) < 0;

 head = compound_head(page);

 return atomic_read(&page->_mapcount) ==
        atomic_read(compound_mapcount_ptr(head));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageTransTail(struct page *page)
{
 return PageTail(page);
}
# 672 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageDoubleMap(struct page *page)
{
 return PageHead(page) && test_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageDoubleMap(struct page *page)
{
 ((void)(sizeof(( long)(!PageHead(page)))));
 set_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageDoubleMap(struct page *page)
{
 ((void)(sizeof(( long)(!PageHead(page)))));
 clear_bit(PG_double_map, &page[1].flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int TestSetPageDoubleMap(struct page *page)
{
 ((void)(sizeof(( long)(!PageHead(page)))));
 return test_and_set_bit(PG_double_map, &page[1].flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int TestClearPageDoubleMap(struct page *page)
{
 ((void)(sizeof(( long)(!PageHead(page)))));
 return test_and_clear_bit(PG_double_map, &page[1].flags);
}
# 731 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_has_type(struct page *page)
{
 return (int)page->page_type < -128;
}
# 756 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageBuddy(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000080)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageBuddy(struct page *page) { ((void)(sizeof(( long)(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000))))); page->page_type &= ~0x00000080; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageBuddy(struct page *page) { ((void)(sizeof(( long)(!PageBuddy(page))))); page->page_type |= 0x00000080; }
# 765 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageOffline(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000100)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageOffline(struct page *page) { ((void)(sizeof(( long)(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000))))); page->page_type &= ~0x00000100; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageOffline(struct page *page) { ((void)(sizeof(( long)(!PageOffline(page))))); page->page_type |= 0x00000100; }





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageKmemcg(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000200)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageKmemcg(struct page *page) { ((void)(sizeof(( long)(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000))))); page->page_type &= ~0x00000200; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageKmemcg(struct page *page) { ((void)(sizeof(( long)(!PageKmemcg(page))))); page->page_type |= 0x00000200; }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageTable(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000400)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageTable(struct page *page) { ((void)(sizeof(( long)(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000))))); page->page_type &= ~0x00000400; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageTable(struct page *page) { ((void)(sizeof(( long)(!PageTable(page))))); page->page_type |= 0x00000400; }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageGuard(struct page *page) { return ((page->page_type & (0xf0000000 | 0x00000800)) == 0xf0000000); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageGuard(struct page *page) { ((void)(sizeof(( long)(!((page->page_type & (0xf0000000 | 0)) == 0xf0000000))))); page->page_type &= ~0x00000800; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageGuard(struct page *page) { ((void)(sizeof(( long)(!PageGuard(page))))); page->page_type |= 0x00000800; }

extern bool is_free_buddy_page(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int PageIsolated(struct page *page) { return test_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __SetPageIsolated(struct page *page) { __set_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __ClearPageIsolated(struct page *page) { __clear_bit(PG_isolated, &({ ((void)(sizeof(( long)(PagePoisoned(page))))); page; })->flags); };





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int PageSlabPfmemalloc(struct page *page)
{
 ((void)(sizeof(( long)(!PageSlab(page)))));
 return PageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void SetPageSlabPfmemalloc(struct page *page)
{
 ((void)(sizeof(( long)(!PageSlab(page)))));
 SetPageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ClearPageSlabPfmemalloc(struct page *page)
{
 ((void)(sizeof(( long)(!PageSlab(page)))));
 __ClearPageActive(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ClearPageSlabPfmemalloc(struct page *page)
{
 ((void)(sizeof(( long)(!PageSlab(page)))));
 ClearPageActive(page);
}
# 852 "/home/nathan/src/linux-next/include/linux/page-flags.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_has_private(struct page *page)
{
 return !!(page->flags & (1UL << PG_private | 1UL << PG_private_2));
}
# 23 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2
# 41 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum migratetype {
 MIGRATE_UNMOVABLE,
 MIGRATE_MOVABLE,
 MIGRATE_RECLAIMABLE,
 MIGRATE_PCPTYPES,
 MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
# 61 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 MIGRATE_CMA,


 MIGRATE_ISOLATE,

 MIGRATE_TYPES
};


extern const char * const migratetype_names[MIGRATE_TYPES];
# 80 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_migrate_movable(int mt)
{
 return __builtin_expect(!!((mt) == MIGRATE_CMA), 0) || mt == MIGRATE_MOVABLE;
}





extern int page_group_by_mobility_disabled;
# 98 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct free_area {
 struct list_head free_list[MIGRATE_TYPES];
 unsigned long nr_free;
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_to_free_area(struct page *page, struct free_area *area,
        int migratetype)
{
 list_add(&page->lru, &area->free_list[migratetype]);
 area->nr_free++;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_to_free_area_tail(struct page *page, struct free_area *area,
      int migratetype)
{
 list_add_tail(&page->lru, &area->free_list[migratetype]);
 area->nr_free++;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_to_free_area_random(struct page *page,
  struct free_area *area, int migratetype)
{
 add_to_free_area(page, area, migratetype);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void move_to_free_area(struct page *page, struct free_area *area,
        int migratetype)
{
 list_move(&page->lru, &area->free_list[migratetype]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *get_page_from_free_area(struct free_area *area,
         int migratetype)
{
 return ({ struct list_head *head__ = (&area->free_list[migratetype]); struct list_head *pos__ = ({ union { typeof(head__->next) __val; char __c[1]; } __u; if (1) __read_once_size(&(head__->next), __u.__c, sizeof(head__->next)); else __read_once_size_nocheck(&(head__->next), __u.__c, sizeof(head__->next)); do { } while (0); __u.__val; }); pos__ != head__ ? ({ void *__mptr = (void *)(pos__); do { extern void __compiletime_assert_142(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(pos__)), typeof(((struct page *)0)->lru)) && !__builtin_types_compatible_p(typeof(*(pos__)), typeof(void))))) __compiletime_assert_142(); } while (0); ((struct page *)(__mptr - __builtin_offsetof(struct page, lru))); }) : ((void *)0); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void del_page_from_free_area(struct page *page,
  struct free_area *area)
{
 list_del(&page->lru);
 __ClearPageBuddy(page);
 ((page)->private = (0));
 area->nr_free--;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool free_area_empty(struct free_area *area, int migratetype)
{
 return list_empty(&area->free_list[migratetype]);
}

struct pglist_data;
# 168 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct zone_padding {
 char x[0];
} __attribute__((__aligned__(1 << (7))));






enum numa_stat_item {
 NUMA_HIT,
 NUMA_MISS,
 NUMA_FOREIGN,
 NUMA_INTERLEAVE_HIT,
 NUMA_LOCAL,
 NUMA_OTHER,
 NR_VM_NUMA_STAT_ITEMS
};




enum zone_stat_item {

 NR_FREE_PAGES,
 NR_ZONE_LRU_BASE,
 NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,
 NR_ZONE_ACTIVE_ANON,
 NR_ZONE_INACTIVE_FILE,
 NR_ZONE_ACTIVE_FILE,
 NR_ZONE_UNEVICTABLE,
 NR_ZONE_WRITE_PENDING,
 NR_MLOCK,
 NR_PAGETABLE,
 NR_KERNEL_STACK_KB,

 NR_BOUNCE,



 NR_FREE_CMA_PAGES,
 NR_VM_ZONE_STAT_ITEMS };

enum node_stat_item {
 NR_LRU_BASE,
 NR_INACTIVE_ANON = NR_LRU_BASE,
 NR_ACTIVE_ANON,
 NR_INACTIVE_FILE,
 NR_ACTIVE_FILE,
 NR_UNEVICTABLE,
 NR_SLAB_RECLAIMABLE,
 NR_SLAB_UNRECLAIMABLE,
 NR_ISOLATED_ANON,
 NR_ISOLATED_FILE,
 WORKINGSET_NODES,
 WORKINGSET_REFAULT,
 WORKINGSET_ACTIVATE,
 WORKINGSET_RESTORE,
 WORKINGSET_NODERECLAIM,
 NR_ANON_MAPPED,
 NR_FILE_MAPPED,

 NR_FILE_PAGES,
 NR_FILE_DIRTY,
 NR_WRITEBACK,
 NR_WRITEBACK_TEMP,
 NR_SHMEM,
 NR_SHMEM_THPS,
 NR_SHMEM_PMDMAPPED,
 NR_FILE_THPS,
 NR_FILE_PMDMAPPED,
 NR_ANON_THPS,
 NR_UNSTABLE_NFS,
 NR_VMSCAN_WRITE,
 NR_VMSCAN_IMMEDIATE,
 NR_DIRTIED,
 NR_WRITTEN,
 NR_KERNEL_MISC_RECLAIMABLE,
 NR_VM_NODE_STAT_ITEMS
};
# 262 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum lru_list {
 LRU_INACTIVE_ANON = 0,
 LRU_ACTIVE_ANON = 0 + 1,
 LRU_INACTIVE_FILE = 0 + 2,
 LRU_ACTIVE_FILE = 0 + 2 + 1,
 LRU_UNEVICTABLE,
 NR_LRU_LISTS
};





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_file_lru(enum lru_list lru)
{
 return (lru == LRU_INACTIVE_FILE || lru == LRU_ACTIVE_FILE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_active_lru(enum lru_list lru)
{
 return (lru == LRU_ACTIVE_ANON || lru == LRU_ACTIVE_FILE);
}

struct zone_reclaim_stat {
# 294 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned long recent_rotated[2];
 unsigned long recent_scanned[2];
};

enum lruvec_flags {
 LRUVEC_CONGESTED,


};

struct lruvec {
 struct list_head lists[NR_LRU_LISTS];
 struct zone_reclaim_stat reclaim_stat;

 atomic_long_t inactive_age;

 unsigned long refaults;

 unsigned long flags;

 struct pglist_data *pgdat;

};
# 326 "/home/nathan/src/linux-next/include/linux/mmzone.h"
typedef unsigned isolate_mode_t;

enum zone_watermarks {
 WMARK_MIN,
 WMARK_LOW,
 WMARK_HIGH,
 NR_WMARK
};






struct per_cpu_pages {
 int count;
 int high;
 int batch;


 struct list_head lists[MIGRATE_PCPTYPES];
};

struct per_cpu_pageset {
 struct per_cpu_pages pcp;

 s8 expire;
 u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];


 s8 stat_threshold;
 s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];

};

struct per_cpu_nodestat {
 s8 stat_threshold;
 s8 vm_node_stat_diff[NR_VM_NODE_STAT_ITEMS];
};



enum zone_type {
# 410 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 ZONE_NORMAL,
# 422 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 ZONE_MOVABLE,



 __MAX_NR_ZONES

};



struct zone {



 unsigned long _watermark[NR_WMARK];
 unsigned long watermark_boost;

 unsigned long nr_reserved_highatomic;
# 450 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 long lowmem_reserve[2];


 int node;

 struct pglist_data *zone_pgdat;
 struct per_cpu_pageset *pageset;
# 467 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned long zone_start_pfn;
# 504 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 atomic_long_t managed_pages;
 unsigned long spanned_pages;
 unsigned long present_pages;

 const char *name;







 unsigned long nr_isolate_pageblock;




 seqlock_t span_seqlock;


 int initialized;


 struct zone_padding _pad1_;


 struct free_area free_area[9];


 unsigned long flags;


 spinlock_t lock;


 struct zone_padding _pad2_;






 unsigned long percpu_drift_mark;



 unsigned long compact_cached_free_pfn;

 unsigned long compact_cached_migrate_pfn[2];
 unsigned long compact_init_migrate_pfn;
 unsigned long compact_init_free_pfn;
# 563 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned int compact_considered;
 unsigned int compact_defer_shift;
 int compact_order_failed;




 bool compact_blockskip_flush;


 bool contiguous;

 struct zone_padding _pad3_;

 atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
 atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];
} __attribute__((__aligned__(1 << (7))));

enum pgdat_flags {
 PGDAT_DIRTY,



 PGDAT_WRITEBACK,


 PGDAT_RECLAIM_LOCKED,
};

enum zone_flags {
 ZONE_BOOSTED_WATERMARK,


};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_managed_pages(struct zone *zone)
{
 return (unsigned long)atomic_long_read(&zone->managed_pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_end_pfn(const struct zone *zone)
{
 return zone->zone_start_pfn + zone->spanned_pages;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_spans_pfn(const struct zone *zone, unsigned long pfn)
{
 return zone->zone_start_pfn <= pfn && pfn < zone_end_pfn(zone);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_is_initialized(struct zone *zone)
{
 return zone->initialized;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_is_empty(struct zone *zone)
{
 return zone->spanned_pages == 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool zone_intersects(struct zone *zone,
  unsigned long start_pfn, unsigned long nr_pages)
{
 if (zone_is_empty(zone))
  return false;
 if (start_pfn >= zone_end_pfn(zone) ||
     start_pfn + nr_pages <= zone->zone_start_pfn)
  return false;

 return true;
}
# 649 "/home/nathan/src/linux-next/include/linux/mmzone.h"
enum {
 ZONELIST_FALLBACK,





 ZONELIST_NOFALLBACK,

 MAX_ZONELISTS
};





struct zoneref {
 struct zone *zone;
 int zone_idx;
};
# 684 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct zonelist {
 struct zoneref _zonerefs[((1 << 8) * 2) + 1];
};



extern struct page *mem_map;



struct deferred_split {
 spinlock_t split_queue_lock;
 struct list_head split_queue;
 unsigned long split_queue_len;
};
# 709 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct bootmem_data;
typedef struct pglist_data {
 struct zone node_zones[2];
 struct zonelist node_zonelists[MAX_ZONELISTS];
 int nr_zones;
# 731 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 spinlock_t node_size_lock;

 unsigned long node_start_pfn;
 unsigned long node_present_pages;
 unsigned long node_spanned_pages;

 int node_id;
 wait_queue_head_t kswapd_wait;
 wait_queue_head_t pfmemalloc_wait;
 struct task_struct *kswapd;

 int kswapd_order;
 enum zone_type kswapd_classzone_idx;

 int kswapd_failures;


 int kcompactd_max_order;
 enum zone_type kcompactd_classzone_idx;
 wait_queue_head_t kcompactd_wait;
 struct task_struct *kcompactd;





 unsigned long totalreserve_pages;





 unsigned long min_unmapped_pages;
 unsigned long min_slab_pages;



 struct zone_padding _pad1_;
 spinlock_t lru_lock;
# 780 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 struct deferred_split deferred_split_queue;
# 790 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 struct lruvec __lruvec;

 unsigned long flags;

 struct zone_padding _pad2_;


 struct per_cpu_nodestat *per_cpu_nodestats;
 atomic_long_t vm_stat[NR_VM_NODE_STAT_ITEMS];
} pg_data_t;
# 813 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pgdat_end_pfn(pg_data_t *pgdat)
{
 return pgdat->node_start_pfn + pgdat->node_spanned_pages;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgdat_is_empty(pg_data_t *pgdat)
{
 return !pgdat->node_start_pfn && !pgdat->node_spanned_pages;
}


# 1 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/mmzone.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h" 2




struct page;
struct zone;
struct pglist_data;
struct mem_section;
struct memory_block;
struct resource;
struct vmem_altmap;
# 40 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
enum {
 MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
 SECTION_INFO = MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE,
 MIX_SECTION_INFO,
 NODE_INFO,
 MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = NODE_INFO,
};


enum {
 MMOP_OFFLINE = -1,
 MMOP_ONLINE_KEEP,
 MMOP_ONLINE_KERNEL,
 MMOP_ONLINE_MOVABLE,
};






struct mhp_restrictions {
 unsigned long flags;
 struct vmem_altmap *altmap;
};
# 73 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned zone_span_seqbegin(struct zone *zone)
{
 return read_seqbegin(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zone_span_seqretry(struct zone *zone, unsigned iv)
{
 return read_seqretry(&zone->span_seqlock, iv);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_span_writelock(struct zone *zone)
{
 write_seqlock(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_span_writeunlock(struct zone *zone)
{
 write_sequnlock(&zone->span_seqlock);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_seqlock_init(struct zone *zone)
{
 do { __seqcount_init(&(&zone->span_seqlock)->seqcount, ((void *)0), ((void *)0)); do { spinlock_check(&(&zone->span_seqlock)->lock); do { *(&(&(&zone->span_seqlock)->lock)->rlock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0); } while (0); } while (0);
}
extern int zone_grow_free_lists(struct zone *zone, unsigned long new_nr_pages);
extern int zone_grow_waitqueues(struct zone *zone, unsigned long nr_pages);
extern int add_one_highpage(struct page *page, int pfn, int bad_ppro);

extern int online_pages(unsigned long pfn, unsigned long nr_pages,
   int online_type, int nid);
extern struct zone *test_pages_in_a_zone(unsigned long start_pfn,
      unsigned long end_pfn);
extern unsigned long __offline_isolated_pages(unsigned long start_pfn,
      unsigned long end_pfn);

typedef void (*online_page_callback_t)(struct page *page, unsigned int order);

extern void generic_online_page(struct page *page, unsigned int order);
extern int set_online_page_callback(online_page_callback_t callback);
extern int restore_online_page_callback(online_page_callback_t callback);

extern int try_online_node(int nid);

extern int arch_add_memory(int nid, u64 start, u64 size,
   struct mhp_restrictions *restrictions);
extern u64 max_mem_size;

extern bool memhp_auto_online;

extern bool movable_node_enabled;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool movable_node_is_enabled(void)
{
 return movable_node_enabled;
}

extern void arch_remove_memory(int nid, u64 start, u64 size,
          struct vmem_altmap *altmap);
extern void __remove_pages(unsigned long start_pfn, unsigned long nr_pages,
      struct vmem_altmap *altmap);


extern int __add_pages(int nid, unsigned long start_pfn, unsigned long nr_pages,
         struct mhp_restrictions *restrictions);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int add_pages(int nid, unsigned long start_pfn,
  unsigned long nr_pages, struct mhp_restrictions *restrictions)
{
 return __add_pages(nid, start_pfn, nr_pages, restrictions);
}






extern int memory_add_physaddr_to_nid(u64 start);
# 190 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern pg_data_t *node_data[];
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_refresh_nodedata(int nid, pg_data_t *pgdat)
{
 node_data[nid] = pgdat;
}
# 214 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) register_page_bootmem_info_node(struct pglist_data *pgdat);





extern void put_page_bootmem(struct page *page);
extern void get_page_bootmem(unsigned long ingo, struct page *page,
        unsigned long type);

void get_online_mems(void);
void put_online_mems(void);

void mem_hotplug_begin(void);
void mem_hotplug_done(void);
# 283 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_lock(struct pglist_data *pgdat, unsigned long *flags)
{
 do { do { ({ unsigned long __dummy; typeof(*flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); *flags = _raw_spin_lock_irqsave(spinlock_check(&pgdat->node_size_lock)); } while (0); } while (0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_unlock(struct pglist_data *pgdat, unsigned long *flags)
{
 spin_unlock_irqrestore(&pgdat->node_size_lock, *flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void pgdat_resize_init(struct pglist_data *pgdat)
{
 do { spinlock_check(&pgdat->node_size_lock); do { *(&(&pgdat->node_size_lock)->rlock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0); } while (0);
}
# 309 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern bool is_mem_section_removable(unsigned long pfn, unsigned long nr_pages);
extern void try_offline_node(int nid);
extern int offline_pages(unsigned long start_pfn, unsigned long nr_pages);
extern int remove_memory(int nid, u64 start, u64 size);
extern void __remove_memory(int nid, u64 start, u64 size);
# 337 "/home/nathan/src/linux-next/include/linux/memory_hotplug.h"
extern void set_zone_contiguous(struct zone *zone);
extern void clear_zone_contiguous(struct zone *zone);

extern void __attribute__((__section__(".ref.text"))) __attribute__((__noinline__)) free_area_init_core_hotplug(int nid);
extern int __add_memory(int nid, u64 start, u64 size);
extern int add_memory(int nid, u64 start, u64 size);
extern int add_memory_resource(int nid, struct resource *resource);
extern void move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,
  unsigned long nr_pages, struct vmem_altmap *altmap);
extern void remove_pfn_range_from_zone(struct zone *zone,
           unsigned long start_pfn,
           unsigned long nr_pages);
extern bool is_memblock_offlined(struct memory_block *mem);
extern int sparse_add_section(int nid, unsigned long pfn,
  unsigned long nr_pages, struct vmem_altmap *altmap);
extern void sparse_remove_section(struct mem_section *ms,
  unsigned long pfn, unsigned long nr_pages,
  unsigned long map_offset, struct vmem_altmap *altmap);
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map,
       unsigned long pnum);
extern bool allow_online_pfn_range(int nid, unsigned long pfn, unsigned long nr_pages,
  int online_type);
extern struct zone *zone_for_pfn_range(int online_type, int nid, unsigned start_pfn,
  unsigned long nr_pages);
# 824 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2

void build_all_zonelists(pg_data_t *pgdat);
void wakeup_kswapd(struct zone *zone, gfp_t gfp_mask, int order,
     enum zone_type classzone_idx);
bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,
    int classzone_idx, unsigned int alloc_flags,
    long free_pages);
bool zone_watermark_ok(struct zone *z, unsigned int order,
  unsigned long mark, int classzone_idx,
  unsigned int alloc_flags);
bool zone_watermark_ok_safe(struct zone *z, unsigned int order,
  unsigned long mark, int classzone_idx);
enum memmap_context {
 MEMMAP_EARLY,
 MEMMAP_HOTPLUG,
};
extern void init_currently_empty_zone(struct zone *zone, unsigned long start_pfn,
         unsigned long size);

extern void lruvec_init(struct lruvec *lruvec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pglist_data *lruvec_pgdat(struct lruvec *lruvec)
{

 return lruvec->pgdat;



}

extern unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx);


void memory_present(int nid, unsigned long start, unsigned long end);





void memblocks_present(void);





int local_memory_node(int node_id);
# 885 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool managed_zone(struct zone *zone)
{
 return zone_managed_pages(zone);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool populated_zone(struct zone *zone)
{
 return zone->present_pages;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zone_to_nid(struct zone *zone)
{
 return zone->node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_set_nid(struct zone *zone, int nid)
{
 zone->node = nid;
}
# 915 "/home/nathan/src/linux-next/include/linux/mmzone.h"
extern int movable_zone;
# 928 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_highmem_idx(enum zone_type idx)
{




 return 0;

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_highmem(struct zone *zone)
{



 return 0;

}


struct ctl_table;
int min_free_kbytes_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int watermark_boost_factor_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int watermark_scale_factor_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
extern int sysctl_lowmem_reserve_ratio[2];
int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int percpu_pagelist_fraction_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);
int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);

extern int numa_zonelist_order_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);
extern char numa_zonelist_order[];
# 984 "/home/nathan/src/linux-next/include/linux/mmzone.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h"
extern struct pglist_data *node_data[];
# 33 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mmzone.h"
extern int numa_cpu_lookup_table[];
extern cpumask_var_t node_to_cpumask_map[];

extern unsigned long max_pfn;
u64 memory_hotplug_max(void);
# 985 "/home/nathan/src/linux-next/include/linux/mmzone.h" 2



extern struct pglist_data *first_online_pgdat(void);
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat);
extern struct zone *next_zone(struct zone *zone);
# 1020 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zone *zonelist_zone(struct zoneref *zoneref)
{
 return zoneref->zone;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zonelist_zone_idx(struct zoneref *zoneref)
{
 return zoneref->zone_idx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int zonelist_node_idx(struct zoneref *zoneref)
{
 return zone_to_nid(zoneref->zone);
}

struct zoneref *__next_zones_zonelist(struct zoneref *z,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes);
# 1051 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) struct zoneref *next_zones_zonelist(struct zoneref *z,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes)
{
 if (__builtin_expect(!!(!nodes && zonelist_zone_idx(z) <= highest_zoneidx), 1))
  return z;
 return __next_zones_zonelist(z, highest_zoneidx, nodes);
}
# 1076 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zoneref *first_zones_zonelist(struct zonelist *zonelist,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes)
{
 return next_zones_zonelist(zonelist->_zonerefs,
       highest_zoneidx, nodes);
}
# 1160 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long pfn_to_section_nr(unsigned long pfn)
{
 return pfn >> (24 - 16);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long section_nr_to_pfn(unsigned long sec)
{
 return sec << (24 - 16);
}
# 1187 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct mem_section_usage {
 unsigned long subsection_map[((((1UL << (24 - 21))) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];

 unsigned long pageblock_flags[0];
};

void subsection_map_init(unsigned long pfn, unsigned long nr_pages);

struct page;
struct page_ext;
struct mem_section {
# 1210 "/home/nathan/src/linux-next/include/linux/mmzone.h"
 unsigned long section_mem_map;

 struct mem_section_usage *usage;
# 1225 "/home/nathan/src/linux-next/include/linux/mmzone.h"
};
# 1238 "/home/nathan/src/linux-next/include/linux/mmzone.h"
extern struct mem_section **mem_section;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long *section_to_usemap(struct mem_section *ms)
{
 return ms->usage->pageblock_flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_section *__nr_to_section(unsigned long nr)
{

 if (!mem_section)
  return ((void *)0);

 if (!mem_section[((nr) / ((1UL << 16) / sizeof (struct mem_section)))])
  return ((void *)0);
 return &mem_section[((nr) / ((1UL << 16) / sizeof (struct mem_section)))][nr & (((1UL << 16) / sizeof (struct mem_section)) - 1)];
}
extern unsigned long __section_nr(struct mem_section *ms);
extern size_t mem_section_usage_size(void);
# 1282 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *__section_mem_map_addr(struct mem_section *section)
{
 unsigned long map = section->section_mem_map;
 map &= (~((1UL<<4)-1));
 return (struct page *)map;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int present_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<0)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int present_section_nr(unsigned long nr)
{
 return present_section(__nr_to_section(nr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int early_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<3)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_section_nr(unsigned long nr)
{
 return valid_section(__nr_to_section(nr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int online_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<2)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int online_section_nr(unsigned long nr)
{
 return online_section(__nr_to_section(nr));
}


void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn);

void offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_section *__pfn_to_section(unsigned long pfn)
{
 return __nr_to_section(pfn_to_section_nr(pfn));
}

extern unsigned long __highest_present_section_nr;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int subsection_map_index(unsigned long pfn)
{
 return (pfn & ~((~((1UL << (24 - 16))-1)))) / (1UL << (21 - 16));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_section_valid(struct mem_section *ms, unsigned long pfn)
{
 int idx = subsection_map_index(pfn);

 return test_bit(idx, ms->usage->subsection_map);
}
# 1358 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_valid(unsigned long pfn)
{
 struct mem_section *ms;

 if (pfn_to_section_nr(pfn) >= (1UL << (51 - 24)))
  return 0;
 ms = __nr_to_section(pfn_to_section_nr(pfn));
 if (!valid_section(ms))
  return 0;




 return early_section(ms) || pfn_section_valid(ms, pfn);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pfn_present(unsigned long pfn)
{
 if (pfn_to_section_nr(pfn) >= (1UL << (51 - 24)))
  return 0;
 return present_section(__nr_to_section(pfn_to_section_nr(pfn)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long next_present_section_nr(unsigned long section_nr)
{
 while (++section_nr <= __highest_present_section_nr) {
  if (present_section_nr(section_nr))
   return section_nr;
 }

 return -1;
}
# 1408 "/home/nathan/src/linux-next/include/linux/mmzone.h"
void sparse_init(void);
# 1421 "/home/nathan/src/linux-next/include/linux/mmzone.h"
struct mminit_pfnnid_cache {
 unsigned long last_start;
 unsigned long last_end;
 int last_nid;
};





void memory_present(int nid, unsigned long start, unsigned long end);
# 1469 "/home/nathan/src/linux-next/include/linux/mmzone.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool memmap_valid_within(unsigned long pfn,
     struct page *page, struct zone *zone)
{
 return true;
}
# 7 "/home/nathan/src/linux-next/include/linux/gfp.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/topology.h" 1
# 30 "/home/nathan/src/linux-next/include/linux/topology.h"
# 1 "/home/nathan/src/linux-next/include/linux/arch_topology.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/percpu.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/smp.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/smp.h"
# 1 "/home/nathan/src/linux-next/include/linux/llist.h" 1
# 54 "/home/nathan/src/linux-next/include/linux/llist.h"
struct llist_head {
 struct llist_node *first;
};

struct llist_node {
 struct llist_node *next;
};
# 69 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_llist_head(struct llist_head *list)
{
 list->first = ((void *)0);
}
# 187 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool llist_empty(const struct llist_head *head)
{
 return ({ union { typeof(head->first) __val; char __c[1]; } __u; if (1) __read_once_size(&(head->first), __u.__c, sizeof(head->first)); else __read_once_size_nocheck(&(head->first), __u.__c, sizeof(head->first)); do { } while (0); __u.__val; }) == ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct llist_node *llist_next(struct llist_node *node)
{
 return node->next;
}

extern bool llist_add_batch(struct llist_node *new_first,
       struct llist_node *new_last,
       struct llist_head *head);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool llist_add(struct llist_node *new, struct llist_head *head)
{
 return llist_add_batch(new, new, head);
}
# 220 "/home/nathan/src/linux-next/include/linux/llist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct llist_node *llist_del_all(struct llist_head *head)
{
 return ({ typeof(({ __typeof__(*(&head->first)) _x_ = (((void *)0)); (__typeof__(*(&head->first))) __xchg_relaxed((&head->first), (unsigned long)_x_, sizeof(*(&head->first))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&head->first)) _x_ = (((void *)0)); (__typeof__(*(&head->first))) __xchg_relaxed((&head->first), (unsigned long)_x_, sizeof(*(&head->first))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
}

extern struct llist_node *llist_del_first(struct llist_head *head);

struct llist_node *llist_reverse_order(struct llist_node *head);
# 16 "/home/nathan/src/linux-next/include/linux/smp.h" 2

typedef void (*smp_call_func_t)(void *info);
typedef bool (*smp_cond_func_t)(int cpu, void *info);
struct __call_single_data {
 struct llist_node llist;
 smp_call_func_t func;
 void *info;
 unsigned int flags;
};


typedef struct __call_single_data call_single_data_t
 __attribute__((__aligned__(sizeof(struct __call_single_data))));


extern unsigned int total_cpus;

int smp_call_function_single(int cpuid, smp_call_func_t func, void *info,
        int wait);




void on_each_cpu(smp_call_func_t func, void *info, int wait);





void on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,
  void *info, bool wait);






void on_each_cpu_cond(smp_cond_func_t cond_func, smp_call_func_t func,
        void *info, bool wait);

void on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,
      void *info, bool wait, const struct cpumask *mask);

int smp_call_function_single_async(int cpu, call_single_data_t *csd);








# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 1
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
# 1 "/home/nathan/src/linux-next/include/linux/irqreturn.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/irqreturn.h"
enum irqreturn {
 IRQ_NONE = (0 << 0),
 IRQ_HANDLED = (1 << 0),
 IRQ_WAKE_THREAD = (1 << 1),
};

typedef enum irqreturn irqreturn_t;
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 2






# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/percpu.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/percpu-defs.h" 1
# 308 "/home/nathan/src/linux-next/include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __this_cpu_preempt_check(const char *op) { }
# 8 "/home/nathan/src/linux-next/include/asm-generic/percpu.h" 2
# 19 "/home/nathan/src/linux-next/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[2048];
# 48 "/home/nathan/src/linux-next/include/asm-generic/percpu.h"
extern void setup_per_cpu_areas(void);
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/percpu.h" 2
# 27 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h" 2

extern int boot_cpuid;
extern int spinning_secondaries;
extern u32 *cpu_to_phys_id;

extern void cpu_die(void);
extern int cpu_to_chip_id(int cpu);



struct smp_ops_t {
 void (*message_pass)(int cpu, int msg);

 void (*cause_ipi)(int cpu);

 int (*cause_nmi_ipi)(int cpu);
 void (*probe)(void);
 int (*kick_cpu)(int nr);
 int (*prepare_cpu)(int nr);
 void (*setup_cpu)(int nr);
 void (*bringup_done)(void);
 void (*take_timebase)(void);
 void (*give_timebase)(void);
 int (*cpu_disable)(void);
 void (*cpu_die)(unsigned int nr);
 int (*cpu_bootable)(unsigned int nr);
};

extern int smp_send_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us);
extern int smp_send_safe_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us);
extern void smp_send_debugger_break(void);
extern void start_secondary_resume(void);
extern void smp_generic_give_timebase(void);
extern void smp_generic_take_timebase(void);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned int) cpu_pvr;


int generic_cpu_disable(void);
void generic_cpu_die(unsigned int cpu);
void generic_set_cpu_dead(unsigned int cpu);
void generic_set_cpu_up(unsigned int cpu);
int generic_check_cpu_restart(unsigned int cpu);
int is_cpu_dead(unsigned int cpu);
# 111 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_sibling_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_l2_cache_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_core_map;
extern __attribute__((section(".data..percpu" ""))) __typeof__(cpumask_var_t) cpu_smallcore_map;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_sibling_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_sibling_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map)))); (typeof((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_core_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_core_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_core_map)))) *)((&(cpu_core_map)))); (typeof((typeof(*((&(cpu_core_map)))) *)((&(cpu_core_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_l2_cache_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_l2_cache_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_l2_cache_map)))) *)((&(cpu_l2_cache_map)))); (typeof((typeof(*((&(cpu_l2_cache_map)))) *)((&(cpu_l2_cache_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *cpu_smallcore_mask(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_smallcore_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_smallcore_map)))) *)((&(cpu_smallcore_map)))); (typeof((typeof(*((&(cpu_smallcore_map)))) *)((&(cpu_smallcore_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

extern int cpu_to_core_id(int cpu);
# 153 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern int smp_handle_nmi_ipi(struct pt_regs *regs);





extern int smp_request_message_ipi(int virq, int message);
extern const char *smp_ipi_name[];


extern void smp_muxed_ipi_message_pass(int cpu, int msg);
extern void smp_muxed_ipi_set_message(int cpu, int msg);
extern irqreturn_t smp_ipi_demux(void);
extern irqreturn_t smp_ipi_demux_relaxed(void);

void smp_init_pSeries(void);
void smp_init_cell(void);
void smp_setup_cpu_maps(void);

extern int __cpu_disable(void);
extern void __cpu_die(unsigned int cpu);
# 194 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_hard_smp_processor_id(int cpu)
{
 return paca_ptrs[cpu]->hw_cpu_id;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_hard_smp_processor_id(int cpu, int phys)
{
 paca_ptrs[cpu]->hw_cpu_id = phys;
}
# 220 "/home/nathan/src/linux-next/arch/powerpc/include/asm/smp.h"
extern void smp_release_cpus(void);




extern int smt_enabled_at_boot;

extern void smp_mpic_probe(void);
extern void smp_mpic_setup_cpu(int cpu);
extern int smp_generic_kick_cpu(int nr);
extern int smp_generic_cpu_bootable(unsigned int nr);


extern void smp_generic_give_timebase(void);
extern void smp_generic_take_timebase(void);

extern struct smp_ops_t *smp_ops;

extern void arch_send_call_function_single_ipi(int cpu);
extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);





extern void generic_secondary_smp_init(void);
extern void generic_secondary_thread_init(void);
extern unsigned long __secondary_hold_spinloop;
extern unsigned long __secondary_hold_acknowledge;
extern char __secondary_hold;
extern unsigned int booting_thread_hwid;

extern void __early_start(void);
# 68 "/home/nathan/src/linux-next/include/linux/smp.h" 2
# 77 "/home/nathan/src/linux-next/include/linux/smp.h"
extern void smp_send_stop(void);




extern void smp_send_reschedule(int cpu);





extern void smp_prepare_cpus(unsigned int max_cpus);




extern int __cpu_up(unsigned int cpunum, struct task_struct *tidle);




extern void smp_cpus_done(unsigned int max_cpus);




void smp_call_function(smp_call_func_t func, void *info, int wait);
void smp_call_function_many(const struct cpumask *mask,
       smp_call_func_t func, void *info, bool wait);

int smp_call_function_any(const struct cpumask *mask,
     smp_call_func_t func, void *info, int wait);

void kick_all_cpus_sync(void);
void wake_up_all_idle_cpus(void);




void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) call_function_init(void);
void generic_smp_call_function_single_interrupt(void);







void smp_prepare_boot_cpu(void);

extern unsigned int setup_max_cpus;
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) setup_nr_cpu_ids(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) smp_init(void);

extern int __boot_cpu_id;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_boot_cpu_id(void)
{
 return __boot_cpu_id;
}
# 228 "/home/nathan/src/linux-next/include/linux/smp.h"
extern void arch_disable_smp_support(void);

extern void arch_enable_nonboot_cpus_begin(void);
extern void arch_enable_nonboot_cpus_end(void);

void smp_setup_processor_id(void);

int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par,
      bool phys);


int smpcfd_prepare_cpu(unsigned int cpu);
int smpcfd_dead_cpu(unsigned int cpu);
int smpcfd_dying_cpu(unsigned int cpu);
# 8 "/home/nathan/src/linux-next/include/linux/percpu.h" 2
# 65 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern void *pcpu_base_addr;
extern const unsigned long *pcpu_unit_offsets;

struct pcpu_group_info {
 int nr_units;
 unsigned long base_offset;
 unsigned int *cpu_map;

};

struct pcpu_alloc_info {
 size_t static_size;
 size_t reserved_size;
 size_t dyn_size;
 size_t unit_size;
 size_t atom_size;
 size_t alloc_size;
 size_t __ai_size;
 int nr_groups;
 struct pcpu_group_info groups[];
};

enum pcpu_fc {
 PCPU_FC_AUTO,
 PCPU_FC_EMBED,
 PCPU_FC_PAGE,

 PCPU_FC_NR,
};
extern const char * const pcpu_fc_names[PCPU_FC_NR];

extern enum pcpu_fc pcpu_chosen_fc;

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int cpu, size_t size,
         size_t align);
typedef void (*pcpu_fc_free_fn_t)(void *ptr, size_t size);
typedef void (*pcpu_fc_populate_pte_fn_t)(unsigned long addr);
typedef int (pcpu_fc_cpu_distance_fn_t)(unsigned int from, unsigned int to);

extern struct pcpu_alloc_info * __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_alloc_alloc_info(int nr_groups,
            int nr_units);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_free_alloc_info(struct pcpu_alloc_info *ai);

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,
      void *base_addr);


extern int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,
    size_t atom_size,
    pcpu_fc_cpu_distance_fn_t cpu_distance_fn,
    pcpu_fc_alloc_fn_t alloc_fn,
    pcpu_fc_free_fn_t free_fn);
# 126 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern void *__alloc_reserved_percpu(size_t size, size_t align);
extern bool __is_kernel_percpu_address(unsigned long addr, unsigned long *can_addr);
extern bool is_kernel_percpu_address(unsigned long addr);





extern void *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp);
extern void *__alloc_percpu(size_t size, size_t align);
extern void free_percpu(void *__pdata);
extern phys_addr_t per_cpu_ptr_to_phys(void *addr);
# 146 "/home/nathan/src/linux-next/include/linux/percpu.h"
extern unsigned long pcpu_nr_pages(void);
# 10 "/home/nathan/src/linux-next/include/linux/arch_topology.h" 2

void topology_normalize_cpu_scale(void);
int topology_update_cpu_topology(void);

struct device_node;
bool topology_parse_cpu_capacity(struct device_node *cpu_node, int cpu);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) cpu_scale;

struct sched_domain;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
unsigned long topology_get_cpu_scale(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(cpu_scale)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_scale)))) *)((&(cpu_scale)))); (typeof((typeof(*((&(cpu_scale)))) *)((&(cpu_scale))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

void topology_set_cpu_scale(unsigned int cpu, unsigned long capacity);

extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) freq_scale;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
unsigned long topology_get_freq_scale(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(freq_scale)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(freq_scale)))) *)((&(freq_scale)))); (typeof((typeof(*((&(freq_scale)))) *)((&(freq_scale))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}

struct cpu_topology {
 int thread_id;
 int core_id;
 int package_id;
 int llc_id;
 cpumask_t thread_sibling;
 cpumask_t core_sibling;
 cpumask_t llc_sibling;
};
# 31 "/home/nathan/src/linux-next/include/linux/topology.h" 2





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h" 1






struct device;
struct device_node;
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
struct pci_bus;

extern int pcibus_to_node(struct pci_bus *bus);
# 38 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
extern int cpu_distance(__be32 *cpu1_assoc, __be32 *cpu2_assoc);
extern int __node_distance(int, int);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) dump_numa_cpu_topology(void);

extern int sysfs_add_device_to_node(struct device *dev, int nid);
extern void sysfs_remove_device_from_node(struct device *dev, int nid);
extern int numa_update_cpu_topology(bool cpus_locked);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_numa_cpu_lookup_table(unsigned int cpu, int node)
{
 numa_cpu_lookup_table[cpu] = node;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int early_cpu_to_node(int cpu)
{
 int nid;

 nid = numa_cpu_lookup_table[cpu];





 return (nid < 0) ? 0 : nid;
}
# 96 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
extern int start_topology_update(void);
extern int stop_topology_update(void);
extern int prrn_is_enabled(void);
extern int find_and_online_cpu_nid(int cpu);
extern int timed_topology_update(int nsecs);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) shared_proc_topology_init(void);
# 129 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/topology.h" 1
# 130 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h" 2
# 142 "/home/nathan/src/linux-next/arch/powerpc/include/asm/topology.h"
int dlpar_cpu_readd(int cpu);
# 37 "/home/nathan/src/linux-next/include/linux/topology.h" 2
# 46 "/home/nathan/src/linux-next/include/linux/topology.h"
int arch_update_cpu_topology(void);
# 75 "/home/nathan/src/linux-next/include/linux/topology.h"
extern int __attribute__((__section__(".data..read_mostly"))) node_reclaim_distance;






extern __attribute__((section(".data..percpu" ""))) __typeof__(int) numa_node;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int numa_node_id(void)
{
 return ({ typeof(numa_node) pscr_ret__; do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(numa_node)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpu_to_node(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(numa_node)))) *)((&(numa_node)))); (typeof((typeof(*((&(numa_node)))) *)((&(numa_node))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_numa_node(int node)
{
 do { do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(numa_node)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(numa_node))) *)(&(numa_node))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_cpu_numa_node(int cpu, int node)
{
 (*({ do { const void *__vpp_verify = (typeof((&(numa_node)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(numa_node)))) *)((&(numa_node)))); (typeof((typeof(*((&(numa_node)))) *)((&(numa_node))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })) = node;
}
# 132 "/home/nathan/src/linux-next/include/linux/topology.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(int) _numa_mem_;
extern int _node_numa_mem_[(1 << 8)];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_numa_mem(int node)
{
 do { do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(_numa_mem_)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }) = node; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 _node_numa_mem_[numa_node_id()] = node;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int node_to_mem_node(int node)
{
 return _node_numa_mem_[node];
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int numa_mem_id(void)
{
 return ({ typeof(_numa_mem_) pscr_ret__; do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(_numa_mem_)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_))); (typeof((typeof(*(&(_numa_mem_))) *)(&(_numa_mem_)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpu_to_mem(int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_)))); (typeof((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_cpu_numa_mem(int cpu, int node)
{
 (*({ do { const void *__vpp_verify = (typeof((&(_numa_mem_)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_)))); (typeof((typeof(*((&(_numa_mem_)))) *)((&(_numa_mem_))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })) = node;
 _node_numa_mem_[cpu_to_node(cpu)] = node;
}
# 219 "/home/nathan/src/linux-next/include/linux/topology.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *cpu_smt_mask(int cpu)
{
 return ((*({ do { const void *__vpp_verify = (typeof((&(cpu_sibling_map)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map)))); (typeof((typeof(*((&(cpu_sibling_map)))) *)((&(cpu_sibling_map))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cpumask *cpu_cpu_mask(int cpu)
{
 return ((cpu_to_node(cpu)) == -1 ? ((struct cpumask *)(1 ? (cpu_all_bits) : (void *)sizeof(__check_is_bitmap(cpu_all_bits)))) : node_to_cpumask_map[cpu_to_node(cpu)]);
}
# 10 "/home/nathan/src/linux-next/include/linux/gfp.h" 2

struct vm_area_struct;
# 308 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gfpflags_to_migratetype(const gfp_t gfp_flags)
{
 ((void)(sizeof(( long)((gfp_flags & ((( gfp_t)0x10u)|(( gfp_t)0x08u))) == ((( gfp_t)0x10u)|(( gfp_t)0x08u))))));
 do { extern void __compiletime_assert_311(void) ; if (!(!((1UL << 3) != 0x08u))) __compiletime_assert_311(); } while (0);
 do { extern void __compiletime_assert_312(void) ; if (!(!((0x08u >> 3) != MIGRATE_MOVABLE))) __compiletime_assert_312(); } while (0);

 if (__builtin_expect(!!(page_group_by_mobility_disabled), 0))
  return MIGRATE_UNMOVABLE;


 return (gfp_flags & ((( gfp_t)0x10u)|(( gfp_t)0x08u))) >> 3;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gfpflags_allow_blocking(const gfp_t gfp_flags)
{
 return !!(gfp_flags & (( gfp_t)0x400u));
}
# 345 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool gfpflags_normal_context(const gfp_t gfp_flags)
{
 return (gfp_flags & ((( gfp_t)0x400u) | (( gfp_t)0x20000u))) ==
  (( gfp_t)0x400u);
}
# 441 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum zone_type gfp_zone(gfp_t flags)
{
 enum zone_type z;
 int bit = ( int) (flags & ((( gfp_t)0x01u)|(( gfp_t)0x02u)|(( gfp_t)0x04u)|(( gfp_t)0x08u)));

 z = (( (ZONE_NORMAL << 0 * 1) | (ZONE_NORMAL << 0x01u * 1) | (ZONE_NORMAL << 0x02u * 1) | (ZONE_NORMAL << 0x04u * 1) | (ZONE_NORMAL << 0x08u * 1) | (ZONE_NORMAL << (0x08u | 0x01u) * 1) | (ZONE_MOVABLE << (0x08u | 0x02u) * 1) | (ZONE_NORMAL << (0x08u | 0x04u) * 1)) >> (bit * 1)) &
      ((1 << 1) - 1);
 ((void)(sizeof(( long)((( 1 << (0x01u | 0x02u) | 1 << (0x01u | 0x04u) | 1 << (0x04u | 0x02u) | 1 << (0x01u | 0x04u | 0x02u) | 1 << (0x08u | 0x02u | 0x01u) | 1 << (0x08u | 0x04u | 0x01u) | 1 << (0x08u | 0x04u | 0x02u) | 1 << (0x08u | 0x04u | 0x01u | 0x02u) ) >> bit) & 1))));
 return z;
}
# 459 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gfp_zonelist(gfp_t flags)
{

 if (__builtin_expect(!!(flags & (( gfp_t)0x200000u)), 0))
  return ZONELIST_NOFALLBACK;

 return ZONELIST_FALLBACK;
}
# 477 "/home/nathan/src/linux-next/include/linux/gfp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zonelist *node_zonelist(int nid, gfp_t flags)
{
 return (node_data[nid])->node_zonelists + gfp_zonelist(flags);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_alloc_page(struct page *page, int order) { }


struct page *
__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,
       nodemask_t *nodemask);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)
{
 return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, ((void *)0));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
 ((void)(sizeof(( long)(nid < 0 || nid >= (1 << 8)))));
 ((void)(sizeof(( long)((gfp_mask & (( gfp_t)0x200000u)) && !node_state((nid), N_ONLINE)))));

 return __alloc_pages(gfp_mask, order, nid);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
      unsigned int order)
{
 if (nid == (-1))
  nid = numa_mem_id();

 return __alloc_pages_node(nid, gfp_mask, order);
}


extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
 return alloc_pages_current(gfp_mask, order);
}
extern struct page *alloc_pages_vma(gfp_t gfp_mask, int order,
   struct vm_area_struct *vma, unsigned long addr,
   int node, bool hugepage);
# 553 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
extern unsigned long get_zeroed_page(gfp_t gfp_mask);

void *alloc_pages_exact(size_t size, gfp_t gfp_mask);
void free_pages_exact(void *virt, size_t size);
void * __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);







extern void __free_pages(struct page *page, unsigned int order);
extern void free_pages(unsigned long addr, unsigned int order);
extern void free_unref_page(struct page *page);
extern void free_unref_page_list(struct list_head *list);

struct page_frag_cache;
extern void __page_frag_cache_drain(struct page *page, unsigned int count);
extern void *page_frag_alloc(struct page_frag_cache *nc,
        unsigned int fragsz, gfp_t gfp_mask);
extern void page_frag_free(void *addr);




void page_alloc_init(void);
void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
void drain_all_pages(struct zone *zone);
void drain_local_pages(struct zone *zone);

void page_alloc_init_late(void);
# 594 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern gfp_t gfp_allowed_mask;


bool gfp_pfmemalloc_allowed(gfp_t gfp_mask);

extern void pm_restrict_gfp_mask(void);
extern void pm_restore_gfp_mask(void);


extern bool pm_suspended_storage(void);
# 613 "/home/nathan/src/linux-next/include/linux/gfp.h"
extern int alloc_contig_range(unsigned long start, unsigned long end,
         unsigned migratetype, gfp_t gfp_mask);
extern struct page *alloc_contig_pages(unsigned long nr_pages, gfp_t gfp_mask,
           int nid, nodemask_t *nodemask);

void free_contig_range(unsigned long pfn, unsigned int nr_pages);



extern void init_cma_reserved_pageblock(struct page *page);
# 5 "/home/nathan/src/linux-next/include/linux/umh.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/sysctl.h" 1
# 30 "/home/nathan/src/linux-next/include/linux/sysctl.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/sysctl.h" 1
# 35 "/home/nathan/src/linux-next/include/uapi/linux/sysctl.h"
struct __sysctl_args {
 int *name;
 int nlen;
 void *oldval;
 size_t *oldlenp;
 void *newval;
 size_t newlen;
 unsigned long __unused[4];
};





enum
{
 CTL_KERN=1,
 CTL_VM=2,
 CTL_NET=3,
 CTL_PROC=4,
 CTL_FS=5,
 CTL_DEBUG=6,
 CTL_DEV=7,
 CTL_BUS=8,
 CTL_ABI=9,
 CTL_CPU=10,
 CTL_ARLAN=254,
 CTL_S390DBF=5677,
 CTL_SUNRPC=7249,
 CTL_PM=9899,
 CTL_FRV=9898,
};


enum
{
 CTL_BUS_ISA=1
};


enum
{
 INOTIFY_MAX_USER_INSTANCES=1,
 INOTIFY_MAX_USER_WATCHES=2,
 INOTIFY_MAX_QUEUED_EVENTS=3
};


enum
{
 KERN_OSTYPE=1,
 KERN_OSRELEASE=2,
 KERN_OSREV=3,
 KERN_VERSION=4,
 KERN_SECUREMASK=5,
 KERN_PROF=6,
 KERN_NODENAME=7,
 KERN_DOMAINNAME=8,

 KERN_PANIC=15,
 KERN_REALROOTDEV=16,

 KERN_SPARC_REBOOT=21,
 KERN_CTLALTDEL=22,
 KERN_PRINTK=23,
 KERN_NAMETRANS=24,
 KERN_PPC_HTABRECLAIM=25,
 KERN_PPC_ZEROPAGED=26,
 KERN_PPC_POWERSAVE_NAP=27,
 KERN_MODPROBE=28,
 KERN_SG_BIG_BUFF=29,
 KERN_ACCT=30,
 KERN_PPC_L2CR=31,

 KERN_RTSIGNR=32,
 KERN_RTSIGMAX=33,

 KERN_SHMMAX=34,
 KERN_MSGMAX=35,
 KERN_MSGMNB=36,
 KERN_MSGPOOL=37,
 KERN_SYSRQ=38,
 KERN_MAX_THREADS=39,
  KERN_RANDOM=40,
  KERN_SHMALL=41,
  KERN_MSGMNI=42,
  KERN_SEM=43,
  KERN_SPARC_STOP_A=44,
  KERN_SHMMNI=45,
 KERN_OVERFLOWUID=46,
 KERN_OVERFLOWGID=47,
 KERN_SHMPATH=48,
 KERN_HOTPLUG=49,
 KERN_IEEE_EMULATION_WARNINGS=50,
 KERN_S390_USER_DEBUG_LOGGING=51,
 KERN_CORE_USES_PID=52,
 KERN_TAINTED=53,
 KERN_CADPID=54,
 KERN_PIDMAX=55,
   KERN_CORE_PATTERN=56,
 KERN_PANIC_ON_OOPS=57,
 KERN_HPPA_PWRSW=58,
 KERN_HPPA_UNALIGNED=59,
 KERN_PRINTK_RATELIMIT=60,
 KERN_PRINTK_RATELIMIT_BURST=61,
 KERN_PTY=62,
 KERN_NGROUPS_MAX=63,
 KERN_SPARC_SCONS_PWROFF=64,
 KERN_HZ_TIMER=65,
 KERN_UNKNOWN_NMI_PANIC=66,
 KERN_BOOTLOADER_TYPE=67,
 KERN_RANDOMIZE=68,
 KERN_SETUID_DUMPABLE=69,
 KERN_SPIN_RETRY=70,
 KERN_ACPI_VIDEO_FLAGS=71,
 KERN_IA64_UNALIGNED=72,
 KERN_COMPAT_LOG=73,
 KERN_MAX_LOCK_DEPTH=74,
 KERN_NMI_WATCHDOG=75,
 KERN_PANIC_ON_NMI=76,
 KERN_PANIC_ON_WARN=77,
 KERN_PANIC_PRINT=78,
};




enum
{
 VM_UNUSED1=1,
 VM_UNUSED2=2,
 VM_UNUSED3=3,
 VM_UNUSED4=4,
 VM_OVERCOMMIT_MEMORY=5,
 VM_UNUSED5=6,
 VM_UNUSED7=7,
 VM_UNUSED8=8,
 VM_UNUSED9=9,
 VM_PAGE_CLUSTER=10,
 VM_DIRTY_BACKGROUND=11,
 VM_DIRTY_RATIO=12,
 VM_DIRTY_WB_CS=13,
 VM_DIRTY_EXPIRE_CS=14,
 VM_NR_PDFLUSH_THREADS=15,
 VM_OVERCOMMIT_RATIO=16,
 VM_PAGEBUF=17,
 VM_HUGETLB_PAGES=18,
 VM_SWAPPINESS=19,
 VM_LOWMEM_RESERVE_RATIO=20,
 VM_MIN_FREE_KBYTES=21,
 VM_MAX_MAP_COUNT=22,
 VM_LAPTOP_MODE=23,
 VM_BLOCK_DUMP=24,
 VM_HUGETLB_GROUP=25,
 VM_VFS_CACHE_PRESSURE=26,
 VM_LEGACY_VA_LAYOUT=27,
 VM_SWAP_TOKEN_TIMEOUT=28,
 VM_DROP_PAGECACHE=29,
 VM_PERCPU_PAGELIST_FRACTION=30,
 VM_ZONE_RECLAIM_MODE=31,
 VM_MIN_UNMAPPED=32,
 VM_PANIC_ON_OOM=33,
 VM_VDSO_ENABLED=34,
 VM_MIN_SLAB=35,
};



enum
{
 NET_CORE=1,
 NET_ETHER=2,
 NET_802=3,
 NET_UNIX=4,
 NET_IPV4=5,
 NET_IPX=6,
 NET_ATALK=7,
 NET_NETROM=8,
 NET_AX25=9,
 NET_BRIDGE=10,
 NET_ROSE=11,
 NET_IPV6=12,
 NET_X25=13,
 NET_TR=14,
 NET_DECNET=15,
 NET_ECONET=16,
 NET_SCTP=17,
 NET_LLC=18,
 NET_NETFILTER=19,
 NET_DCCP=20,
 NET_IRDA=412,
};


enum
{
 RANDOM_POOLSIZE=1,
 RANDOM_ENTROPY_COUNT=2,
 RANDOM_READ_THRESH=3,
 RANDOM_WRITE_THRESH=4,
 RANDOM_BOOT_ID=5,
 RANDOM_UUID=6
};


enum
{
 PTY_MAX=1,
 PTY_NR=2
};


enum
{
 BUS_ISA_MEM_BASE=1,
 BUS_ISA_PORT_BASE=2,
 BUS_ISA_PORT_SHIFT=3
};


enum
{
 NET_CORE_WMEM_MAX=1,
 NET_CORE_RMEM_MAX=2,
 NET_CORE_WMEM_DEFAULT=3,
 NET_CORE_RMEM_DEFAULT=4,

 NET_CORE_MAX_BACKLOG=6,
 NET_CORE_FASTROUTE=7,
 NET_CORE_MSG_COST=8,
 NET_CORE_MSG_BURST=9,
 NET_CORE_OPTMEM_MAX=10,
 NET_CORE_HOT_LIST_LENGTH=11,
 NET_CORE_DIVERT_VERSION=12,
 NET_CORE_NO_CONG_THRESH=13,
 NET_CORE_NO_CONG=14,
 NET_CORE_LO_CONG=15,
 NET_CORE_MOD_CONG=16,
 NET_CORE_DEV_WEIGHT=17,
 NET_CORE_SOMAXCONN=18,
 NET_CORE_BUDGET=19,
 NET_CORE_AEVENT_ETIME=20,
 NET_CORE_AEVENT_RSEQTH=21,
 NET_CORE_WARNINGS=22,
};







enum
{
 NET_UNIX_DESTROY_DELAY=1,
 NET_UNIX_DELETE_DELAY=2,
 NET_UNIX_MAX_DGRAM_QLEN=3,
};


enum
{
 NET_NF_CONNTRACK_MAX=1,
 NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
 NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
 NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
 NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
 NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
 NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
 NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
 NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
 NET_NF_CONNTRACK_UDP_TIMEOUT=10,
 NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
 NET_NF_CONNTRACK_ICMP_TIMEOUT=12,
 NET_NF_CONNTRACK_GENERIC_TIMEOUT=13,
 NET_NF_CONNTRACK_BUCKETS=14,
 NET_NF_CONNTRACK_LOG_INVALID=15,
 NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
 NET_NF_CONNTRACK_TCP_LOOSE=17,
 NET_NF_CONNTRACK_TCP_BE_LIBERAL=18,
 NET_NF_CONNTRACK_TCP_MAX_RETRANS=19,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
 NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
 NET_NF_CONNTRACK_COUNT=27,
 NET_NF_CONNTRACK_ICMPV6_TIMEOUT=28,
 NET_NF_CONNTRACK_FRAG6_TIMEOUT=29,
 NET_NF_CONNTRACK_FRAG6_LOW_THRESH=30,
 NET_NF_CONNTRACK_FRAG6_HIGH_THRESH=31,
 NET_NF_CONNTRACK_CHECKSUM=32,
};


enum
{

 NET_IPV4_FORWARD=8,
 NET_IPV4_DYNADDR=9,

 NET_IPV4_CONF=16,
 NET_IPV4_NEIGH=17,
 NET_IPV4_ROUTE=18,
 NET_IPV4_FIB_HASH=19,
 NET_IPV4_NETFILTER=20,

 NET_IPV4_TCP_TIMESTAMPS=33,
 NET_IPV4_TCP_WINDOW_SCALING=34,
 NET_IPV4_TCP_SACK=35,
 NET_IPV4_TCP_RETRANS_COLLAPSE=36,
 NET_IPV4_DEFAULT_TTL=37,
 NET_IPV4_AUTOCONFIG=38,
 NET_IPV4_NO_PMTU_DISC=39,
 NET_IPV4_TCP_SYN_RETRIES=40,
 NET_IPV4_IPFRAG_HIGH_THRESH=41,
 NET_IPV4_IPFRAG_LOW_THRESH=42,
 NET_IPV4_IPFRAG_TIME=43,
 NET_IPV4_TCP_MAX_KA_PROBES=44,
 NET_IPV4_TCP_KEEPALIVE_TIME=45,
 NET_IPV4_TCP_KEEPALIVE_PROBES=46,
 NET_IPV4_TCP_RETRIES1=47,
 NET_IPV4_TCP_RETRIES2=48,
 NET_IPV4_TCP_FIN_TIMEOUT=49,
 NET_IPV4_IP_MASQ_DEBUG=50,
 NET_TCP_SYNCOOKIES=51,
 NET_TCP_STDURG=52,
 NET_TCP_RFC1337=53,
 NET_TCP_SYN_TAILDROP=54,
 NET_TCP_MAX_SYN_BACKLOG=55,
 NET_IPV4_LOCAL_PORT_RANGE=56,
 NET_IPV4_ICMP_ECHO_IGNORE_ALL=57,
 NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS=58,
 NET_IPV4_ICMP_SOURCEQUENCH_RATE=59,
 NET_IPV4_ICMP_DESTUNREACH_RATE=60,
 NET_IPV4_ICMP_TIMEEXCEED_RATE=61,
 NET_IPV4_ICMP_PARAMPROB_RATE=62,
 NET_IPV4_ICMP_ECHOREPLY_RATE=63,
 NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES=64,
 NET_IPV4_IGMP_MAX_MEMBERSHIPS=65,
 NET_TCP_TW_RECYCLE=66,
 NET_IPV4_ALWAYS_DEFRAG=67,
 NET_IPV4_TCP_KEEPALIVE_INTVL=68,
 NET_IPV4_INET_PEER_THRESHOLD=69,
 NET_IPV4_INET_PEER_MINTTL=70,
 NET_IPV4_INET_PEER_MAXTTL=71,
 NET_IPV4_INET_PEER_GC_MINTIME=72,
 NET_IPV4_INET_PEER_GC_MAXTIME=73,
 NET_TCP_ORPHAN_RETRIES=74,
 NET_TCP_ABORT_ON_OVERFLOW=75,
 NET_TCP_SYNACK_RETRIES=76,
 NET_TCP_MAX_ORPHANS=77,
 NET_TCP_MAX_TW_BUCKETS=78,
 NET_TCP_FACK=79,
 NET_TCP_REORDERING=80,
 NET_TCP_ECN=81,
 NET_TCP_DSACK=82,
 NET_TCP_MEM=83,
 NET_TCP_WMEM=84,
 NET_TCP_RMEM=85,
 NET_TCP_APP_WIN=86,
 NET_TCP_ADV_WIN_SCALE=87,
 NET_IPV4_NONLOCAL_BIND=88,
 NET_IPV4_ICMP_RATELIMIT=89,
 NET_IPV4_ICMP_RATEMASK=90,
 NET_TCP_TW_REUSE=91,
 NET_TCP_FRTO=92,
 NET_TCP_LOW_LATENCY=93,
 NET_IPV4_IPFRAG_SECRET_INTERVAL=94,
 NET_IPV4_IGMP_MAX_MSF=96,
 NET_TCP_NO_METRICS_SAVE=97,
 NET_TCP_DEFAULT_WIN_SCALE=105,
 NET_TCP_MODERATE_RCVBUF=106,
 NET_TCP_TSO_WIN_DIVISOR=107,
 NET_TCP_BIC_BETA=108,
 NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR=109,
 NET_TCP_CONG_CONTROL=110,
 NET_TCP_ABC=111,
 NET_IPV4_IPFRAG_MAX_DIST=112,
  NET_TCP_MTU_PROBING=113,
 NET_TCP_BASE_MSS=114,
 NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS=115,
 NET_TCP_DMA_COPYBREAK=116,
 NET_TCP_SLOW_START_AFTER_IDLE=117,
 NET_CIPSOV4_CACHE_ENABLE=118,
 NET_CIPSOV4_CACHE_BUCKET_SIZE=119,
 NET_CIPSOV4_RBM_OPTFMT=120,
 NET_CIPSOV4_RBM_STRICTVALID=121,
 NET_TCP_AVAIL_CONG_CONTROL=122,
 NET_TCP_ALLOWED_CONG_CONTROL=123,
 NET_TCP_MAX_SSTHRESH=124,
 NET_TCP_FRTO_RESPONSE=125,
};

enum {
 NET_IPV4_ROUTE_FLUSH=1,
 NET_IPV4_ROUTE_MIN_DELAY=2,
 NET_IPV4_ROUTE_MAX_DELAY=3,
 NET_IPV4_ROUTE_GC_THRESH=4,
 NET_IPV4_ROUTE_MAX_SIZE=5,
 NET_IPV4_ROUTE_GC_MIN_INTERVAL=6,
 NET_IPV4_ROUTE_GC_TIMEOUT=7,
 NET_IPV4_ROUTE_GC_INTERVAL=8,
 NET_IPV4_ROUTE_REDIRECT_LOAD=9,
 NET_IPV4_ROUTE_REDIRECT_NUMBER=10,
 NET_IPV4_ROUTE_REDIRECT_SILENCE=11,
 NET_IPV4_ROUTE_ERROR_COST=12,
 NET_IPV4_ROUTE_ERROR_BURST=13,
 NET_IPV4_ROUTE_GC_ELASTICITY=14,
 NET_IPV4_ROUTE_MTU_EXPIRES=15,
 NET_IPV4_ROUTE_MIN_PMTU=16,
 NET_IPV4_ROUTE_MIN_ADVMSS=17,
 NET_IPV4_ROUTE_SECRET_INTERVAL=18,
 NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS=19,
};

enum
{
 NET_PROTO_CONF_ALL=-2,
 NET_PROTO_CONF_DEFAULT=-3


};

enum
{
 NET_IPV4_CONF_FORWARDING=1,
 NET_IPV4_CONF_MC_FORWARDING=2,
 NET_IPV4_CONF_PROXY_ARP=3,
 NET_IPV4_CONF_ACCEPT_REDIRECTS=4,
 NET_IPV4_CONF_SECURE_REDIRECTS=5,
 NET_IPV4_CONF_SEND_REDIRECTS=6,
 NET_IPV4_CONF_SHARED_MEDIA=7,
 NET_IPV4_CONF_RP_FILTER=8,
 NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE=9,
 NET_IPV4_CONF_BOOTP_RELAY=10,
 NET_IPV4_CONF_LOG_MARTIANS=11,
 NET_IPV4_CONF_TAG=12,
 NET_IPV4_CONF_ARPFILTER=13,
 NET_IPV4_CONF_MEDIUM_ID=14,
 NET_IPV4_CONF_NOXFRM=15,
 NET_IPV4_CONF_NOPOLICY=16,
 NET_IPV4_CONF_FORCE_IGMP_VERSION=17,
 NET_IPV4_CONF_ARP_ANNOUNCE=18,
 NET_IPV4_CONF_ARP_IGNORE=19,
 NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
 NET_IPV4_CONF_ARP_ACCEPT=21,
 NET_IPV4_CONF_ARP_NOTIFY=22,
};


enum
{
 NET_IPV4_NF_CONNTRACK_MAX=1,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
 NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT=10,
 NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
 NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT=12,
 NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT=13,
 NET_IPV4_NF_CONNTRACK_BUCKETS=14,
 NET_IPV4_NF_CONNTRACK_LOG_INVALID=15,
 NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
 NET_IPV4_NF_CONNTRACK_TCP_LOOSE=17,
 NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL=18,
 NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS=19,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
 NET_IPV4_NF_CONNTRACK_COUNT=27,
 NET_IPV4_NF_CONNTRACK_CHECKSUM=28,
};


enum {
 NET_IPV6_CONF=16,
 NET_IPV6_NEIGH=17,
 NET_IPV6_ROUTE=18,
 NET_IPV6_ICMP=19,
 NET_IPV6_BINDV6ONLY=20,
 NET_IPV6_IP6FRAG_HIGH_THRESH=21,
 NET_IPV6_IP6FRAG_LOW_THRESH=22,
 NET_IPV6_IP6FRAG_TIME=23,
 NET_IPV6_IP6FRAG_SECRET_INTERVAL=24,
 NET_IPV6_MLD_MAX_MSF=25,
};

enum {
 NET_IPV6_ROUTE_FLUSH=1,
 NET_IPV6_ROUTE_GC_THRESH=2,
 NET_IPV6_ROUTE_MAX_SIZE=3,
 NET_IPV6_ROUTE_GC_MIN_INTERVAL=4,
 NET_IPV6_ROUTE_GC_TIMEOUT=5,
 NET_IPV6_ROUTE_GC_INTERVAL=6,
 NET_IPV6_ROUTE_GC_ELASTICITY=7,
 NET_IPV6_ROUTE_MTU_EXPIRES=8,
 NET_IPV6_ROUTE_MIN_ADVMSS=9,
 NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS=10
};

enum {
 NET_IPV6_FORWARDING=1,
 NET_IPV6_HOP_LIMIT=2,
 NET_IPV6_MTU=3,
 NET_IPV6_ACCEPT_RA=4,
 NET_IPV6_ACCEPT_REDIRECTS=5,
 NET_IPV6_AUTOCONF=6,
 NET_IPV6_DAD_TRANSMITS=7,
 NET_IPV6_RTR_SOLICITS=8,
 NET_IPV6_RTR_SOLICIT_INTERVAL=9,
 NET_IPV6_RTR_SOLICIT_DELAY=10,
 NET_IPV6_USE_TEMPADDR=11,
 NET_IPV6_TEMP_VALID_LFT=12,
 NET_IPV6_TEMP_PREFERED_LFT=13,
 NET_IPV6_REGEN_MAX_RETRY=14,
 NET_IPV6_MAX_DESYNC_FACTOR=15,
 NET_IPV6_MAX_ADDRESSES=16,
 NET_IPV6_FORCE_MLD_VERSION=17,
 NET_IPV6_ACCEPT_RA_DEFRTR=18,
 NET_IPV6_ACCEPT_RA_PINFO=19,
 NET_IPV6_ACCEPT_RA_RTR_PREF=20,
 NET_IPV6_RTR_PROBE_INTERVAL=21,
 NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
 NET_IPV6_PROXY_NDP=23,
 NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
 NET_IPV6_ACCEPT_RA_FROM_LOCAL=26,
 NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN=27,
 __NET_IPV6_MAX
};


enum {
 NET_IPV6_ICMP_RATELIMIT = 1,
 NET_IPV6_ICMP_ECHO_IGNORE_ALL = 2
};


enum {
 NET_NEIGH_MCAST_SOLICIT=1,
 NET_NEIGH_UCAST_SOLICIT=2,
 NET_NEIGH_APP_SOLICIT=3,
 NET_NEIGH_RETRANS_TIME=4,
 NET_NEIGH_REACHABLE_TIME=5,
 NET_NEIGH_DELAY_PROBE_TIME=6,
 NET_NEIGH_GC_STALE_TIME=7,
 NET_NEIGH_UNRES_QLEN=8,
 NET_NEIGH_PROXY_QLEN=9,
 NET_NEIGH_ANYCAST_DELAY=10,
 NET_NEIGH_PROXY_DELAY=11,
 NET_NEIGH_LOCKTIME=12,
 NET_NEIGH_GC_INTERVAL=13,
 NET_NEIGH_GC_THRESH1=14,
 NET_NEIGH_GC_THRESH2=15,
 NET_NEIGH_GC_THRESH3=16,
 NET_NEIGH_RETRANS_TIME_MS=17,
 NET_NEIGH_REACHABLE_TIME_MS=18,
};


enum {
 NET_DCCP_DEFAULT=1,
};


enum {
 NET_IPX_PPROP_BROADCASTING=1,
 NET_IPX_FORWARDING=2
};


enum {
 NET_LLC2=1,
 NET_LLC_STATION=2,
};


enum {
 NET_LLC2_TIMEOUT=1,
};


enum {
 NET_LLC_STATION_ACK_TIMEOUT=1,
};


enum {
 NET_LLC2_ACK_TIMEOUT=1,
 NET_LLC2_P_TIMEOUT=2,
 NET_LLC2_REJ_TIMEOUT=3,
 NET_LLC2_BUSY_TIMEOUT=4,
};


enum {
 NET_ATALK_AARP_EXPIRY_TIME=1,
 NET_ATALK_AARP_TICK_TIME=2,
 NET_ATALK_AARP_RETRANSMIT_LIMIT=3,
 NET_ATALK_AARP_RESOLVE_TIME=4
};



enum {
 NET_NETROM_DEFAULT_PATH_QUALITY=1,
 NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER=2,
 NET_NETROM_NETWORK_TTL_INITIALISER=3,
 NET_NETROM_TRANSPORT_TIMEOUT=4,
 NET_NETROM_TRANSPORT_MAXIMUM_TRIES=5,
 NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY=6,
 NET_NETROM_TRANSPORT_BUSY_DELAY=7,
 NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE=8,
 NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT=9,
 NET_NETROM_ROUTING_CONTROL=10,
 NET_NETROM_LINK_FAILS_COUNT=11,
 NET_NETROM_RESET=12
};


enum {
 NET_AX25_IP_DEFAULT_MODE=1,
 NET_AX25_DEFAULT_MODE=2,
 NET_AX25_BACKOFF_TYPE=3,
 NET_AX25_CONNECT_MODE=4,
 NET_AX25_STANDARD_WINDOW=5,
 NET_AX25_EXTENDED_WINDOW=6,
 NET_AX25_T1_TIMEOUT=7,
 NET_AX25_T2_TIMEOUT=8,
 NET_AX25_T3_TIMEOUT=9,
 NET_AX25_IDLE_TIMEOUT=10,
 NET_AX25_N2=11,
 NET_AX25_PACLEN=12,
 NET_AX25_PROTOCOL=13,
 NET_AX25_DAMA_SLAVE_TIMEOUT=14
};


enum {
 NET_ROSE_RESTART_REQUEST_TIMEOUT=1,
 NET_ROSE_CALL_REQUEST_TIMEOUT=2,
 NET_ROSE_RESET_REQUEST_TIMEOUT=3,
 NET_ROSE_CLEAR_REQUEST_TIMEOUT=4,
 NET_ROSE_ACK_HOLD_BACK_TIMEOUT=5,
 NET_ROSE_ROUTING_CONTROL=6,
 NET_ROSE_LINK_FAIL_TIMEOUT=7,
 NET_ROSE_MAX_VCS=8,
 NET_ROSE_WINDOW_SIZE=9,
 NET_ROSE_NO_ACTIVITY_TIMEOUT=10
};


enum {
 NET_X25_RESTART_REQUEST_TIMEOUT=1,
 NET_X25_CALL_REQUEST_TIMEOUT=2,
 NET_X25_RESET_REQUEST_TIMEOUT=3,
 NET_X25_CLEAR_REQUEST_TIMEOUT=4,
 NET_X25_ACK_HOLD_BACK_TIMEOUT=5,
 NET_X25_FORWARD=6
};


enum
{
 NET_TR_RIF_TIMEOUT=1
};


enum {
 NET_DECNET_NODE_TYPE = 1,
 NET_DECNET_NODE_ADDRESS = 2,
 NET_DECNET_NODE_NAME = 3,
 NET_DECNET_DEFAULT_DEVICE = 4,
 NET_DECNET_TIME_WAIT = 5,
 NET_DECNET_DN_COUNT = 6,
 NET_DECNET_DI_COUNT = 7,
 NET_DECNET_DR_COUNT = 8,
 NET_DECNET_DST_GC_INTERVAL = 9,
 NET_DECNET_CONF = 10,
 NET_DECNET_NO_FC_MAX_CWND = 11,
 NET_DECNET_MEM = 12,
 NET_DECNET_RMEM = 13,
 NET_DECNET_WMEM = 14,
 NET_DECNET_DEBUG_LEVEL = 255
};


enum {
 NET_DECNET_CONF_LOOPBACK = -2,
 NET_DECNET_CONF_DDCMP = -3,
 NET_DECNET_CONF_PPP = -4,
 NET_DECNET_CONF_X25 = -5,
 NET_DECNET_CONF_GRE = -6,
 NET_DECNET_CONF_ETHER = -7


};


enum {
 NET_DECNET_CONF_DEV_PRIORITY = 1,
 NET_DECNET_CONF_DEV_T1 = 2,
 NET_DECNET_CONF_DEV_T2 = 3,
 NET_DECNET_CONF_DEV_T3 = 4,
 NET_DECNET_CONF_DEV_FORWARDING = 5,
 NET_DECNET_CONF_DEV_BLKSIZE = 6,
 NET_DECNET_CONF_DEV_STATE = 7
};


enum {
 NET_SCTP_RTO_INITIAL = 1,
 NET_SCTP_RTO_MIN = 2,
 NET_SCTP_RTO_MAX = 3,
 NET_SCTP_RTO_ALPHA = 4,
 NET_SCTP_RTO_BETA = 5,
 NET_SCTP_VALID_COOKIE_LIFE = 6,
 NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
 NET_SCTP_PATH_MAX_RETRANS = 8,
 NET_SCTP_MAX_INIT_RETRANSMITS = 9,
 NET_SCTP_HB_INTERVAL = 10,
 NET_SCTP_PRESERVE_ENABLE = 11,
 NET_SCTP_MAX_BURST = 12,
 NET_SCTP_ADDIP_ENABLE = 13,
 NET_SCTP_PRSCTP_ENABLE = 14,
 NET_SCTP_SNDBUF_POLICY = 15,
 NET_SCTP_SACK_TIMEOUT = 16,
 NET_SCTP_RCVBUF_POLICY = 17,
};


enum {
 NET_BRIDGE_NF_CALL_ARPTABLES = 1,
 NET_BRIDGE_NF_CALL_IPTABLES = 2,
 NET_BRIDGE_NF_CALL_IP6TABLES = 3,
 NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
 NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
};



enum
{
 FS_NRINODE=1,
 FS_STATINODE=2,
 FS_MAXINODE=3,
 FS_NRDQUOT=4,
 FS_MAXDQUOT=5,
 FS_NRFILE=6,
 FS_MAXFILE=7,
 FS_DENTRY=8,
 FS_NRSUPER=9,
 FS_MAXSUPER=10,
 FS_OVERFLOWUID=11,
 FS_OVERFLOWGID=12,
 FS_LEASES=13,
 FS_DIR_NOTIFY=14,
 FS_LEASE_TIME=15,
 FS_DQSTATS=16,
 FS_XFS=17,
 FS_AIO_NR=18,
 FS_AIO_MAX_NR=19,
 FS_INOTIFY=20,
 FS_OCFS2=988,
};


enum {
 FS_DQ_LOOKUPS = 1,
 FS_DQ_DROPS = 2,
 FS_DQ_READS = 3,
 FS_DQ_WRITES = 4,
 FS_DQ_CACHE_HITS = 5,
 FS_DQ_ALLOCATED = 6,
 FS_DQ_FREE = 7,
 FS_DQ_SYNCS = 8,
 FS_DQ_WARNINGS = 9,
};




enum {
 DEV_CDROM=1,
 DEV_HWMON=2,
 DEV_PARPORT=3,
 DEV_RAID=4,
 DEV_MAC_HID=5,
 DEV_SCSI=6,
 DEV_IPMI=7,
};


enum {
 DEV_CDROM_INFO=1,
 DEV_CDROM_AUTOCLOSE=2,
 DEV_CDROM_AUTOEJECT=3,
 DEV_CDROM_DEBUG=4,
 DEV_CDROM_LOCK=5,
 DEV_CDROM_CHECK_MEDIA=6
};


enum {
 DEV_PARPORT_DEFAULT=-3
};


enum {
 DEV_RAID_SPEED_LIMIT_MIN=1,
 DEV_RAID_SPEED_LIMIT_MAX=2
};


enum {
 DEV_PARPORT_DEFAULT_TIMESLICE=1,
 DEV_PARPORT_DEFAULT_SPINTIME=2
};


enum {
 DEV_PARPORT_SPINTIME=1,
 DEV_PARPORT_BASE_ADDR=2,
 DEV_PARPORT_IRQ=3,
 DEV_PARPORT_DMA=4,
 DEV_PARPORT_MODES=5,
 DEV_PARPORT_DEVICES=6,
 DEV_PARPORT_AUTOPROBE=16
};


enum {
 DEV_PARPORT_DEVICES_ACTIVE=-3,
};


enum {
 DEV_PARPORT_DEVICE_TIMESLICE=1,
};


enum {
 DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES=1,
 DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES=2,
 DEV_MAC_HID_MOUSE_BUTTON_EMULATION=3,
 DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE=4,
 DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE=5,
 DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES=6
};


enum {
 DEV_SCSI_LOGGING_LEVEL=1,
};


enum {
 DEV_IPMI_POWEROFF_POWERCYCLE=1,
};


enum
{
 ABI_DEFHANDLER_COFF=1,
 ABI_DEFHANDLER_ELF=2,
 ABI_DEFHANDLER_LCALL7=3,
 ABI_DEFHANDLER_LIBCSO=4,
 ABI_TRACE=5,
 ABI_FAKE_UTSNAME=6,
};
# 31 "/home/nathan/src/linux-next/include/linux/sysctl.h" 2


struct completion;
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;






extern const int sysctl_vals[];

typedef int proc_handler (struct ctl_table *ctl, int write,
     void *buffer, size_t *lenp, loff_t *ppos);

extern int proc_dostring(struct ctl_table *, int,
    void *, size_t *, loff_t *);
extern int proc_dointvec(struct ctl_table *, int,
    void *, size_t *, loff_t *);
extern int proc_douintvec(struct ctl_table *, int,
    void *, size_t *, loff_t *);
extern int proc_dointvec_minmax(struct ctl_table *, int,
    void *, size_t *, loff_t *);
extern int proc_douintvec_minmax(struct ctl_table *table, int write,
     void *buffer, size_t *lenp,
     loff_t *ppos);
extern int proc_dointvec_jiffies(struct ctl_table *, int,
     void *, size_t *, loff_t *);
extern int proc_dointvec_userhz_jiffies(struct ctl_table *, int,
     void *, size_t *, loff_t *);
extern int proc_dointvec_ms_jiffies(struct ctl_table *, int,
        void *, size_t *, loff_t *);
extern int proc_doulongvec_minmax(struct ctl_table *, int,
      void *, size_t *, loff_t *);
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int,
          void *, size_t *, loff_t *);
extern int proc_do_large_bitmap(struct ctl_table *, int,
    void *, size_t *, loff_t *);
extern int proc_do_static_key(struct ctl_table *table, int write,
         void *buffer, size_t *lenp,
         loff_t *ppos);
# 105 "/home/nathan/src/linux-next/include/linux/sysctl.h"
struct ctl_table_poll {
 atomic_t event;
 wait_queue_head_t wait;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *proc_sys_poll_event(struct ctl_table_poll *poll)
{
 return (void *)(unsigned long)atomic_read(&poll->event);
}
# 123 "/home/nathan/src/linux-next/include/linux/sysctl.h"
struct ctl_table {
 const char *procname;
 void *data;
 int maxlen;
 umode_t mode;
 struct ctl_table *child;
 proc_handler *proc_handler;
 struct ctl_table_poll *poll;
 void *extra1;
 void *extra2;
} ;

struct ctl_node {
 struct rb_node node;
 struct ctl_table_header *header;
};



struct ctl_table_header {
 union {
  struct {
   struct ctl_table *ctl_table;
   int used;
   int count;
   int nreg;
  };
  struct callback_head rcu;
 };
 struct completion *unregistering;
 struct ctl_table *ctl_table_arg;
 struct ctl_table_root *root;
 struct ctl_table_set *set;
 struct ctl_dir *parent;
 struct ctl_node *node;
 struct hlist_head inodes;
};

struct ctl_dir {

 struct ctl_table_header header;
 struct rb_root root;
};

struct ctl_table_set {
 int (*is_seen)(struct ctl_table_set *);
 struct ctl_dir dir;
};

struct ctl_table_root {
 struct ctl_table_set default_set;
 struct ctl_table_set *(*lookup)(struct ctl_table_root *root);
 void (*set_ownership)(struct ctl_table_header *head,
         struct ctl_table *table,
         kuid_t *uid, kgid_t *gid);
 int (*permissions)(struct ctl_table_header *head, struct ctl_table *table);
};


struct ctl_path {
 const char *procname;
};



void proc_sys_poll_notify(struct ctl_table_poll *poll);

extern void setup_sysctl_set(struct ctl_table_set *p,
 struct ctl_table_root *root,
 int (*is_seen)(struct ctl_table_set *));
extern void retire_sysctl_set(struct ctl_table_set *set);

struct ctl_table_header *__register_sysctl_table(
 struct ctl_table_set *set,
 const char *path, struct ctl_table *table);
struct ctl_table_header *__register_sysctl_paths(
 struct ctl_table_set *set,
 const struct ctl_path *path, struct ctl_table *table);
struct ctl_table_header *register_sysctl(const char *path, struct ctl_table *table);
struct ctl_table_header *register_sysctl_table(struct ctl_table * table);
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
      struct ctl_table *table);

void unregister_sysctl_table(struct ctl_table_header * table);

extern int sysctl_init(void);

extern struct ctl_table sysctl_mount_point[];
# 241 "/home/nathan/src/linux-next/include/linux/sysctl.h"
int sysctl_max_threads(struct ctl_table *table, int write,
         void *buffer, size_t *lenp, loff_t *ppos);
# 10 "/home/nathan/src/linux-next/include/linux/umh.h" 2

struct cred;
struct file;






struct subprocess_info {
 struct work_struct work;
 struct completion *complete;
 const char *path;
 char **argv;
 char **envp;
 struct file *file;
 int wait;
 int retval;
 pid_t pid;
 int (*init)(struct subprocess_info *info, struct cred *new);
 void (*cleanup)(struct subprocess_info *info);
 void *data;
} ;

extern int
call_usermodehelper(const char *path, char **argv, char **envp, int wait);

extern struct subprocess_info *
call_usermodehelper_setup(const char *path, char **argv, char **envp,
     gfp_t gfp_mask,
     int (*init)(struct subprocess_info *info, struct cred *new),
     void (*cleanup)(struct subprocess_info *), void *data);

struct subprocess_info *call_usermodehelper_setup_file(struct file *file,
     int (*init)(struct subprocess_info *info, struct cred *new),
     void (*cleanup)(struct subprocess_info *), void *data);
struct umh_info {
 const char *cmdline;
 struct file *pipe_to_umh;
 struct file *pipe_from_umh;
 struct list_head list;
 void (*cleanup)(struct umh_info *info);
 pid_t pid;
};
int fork_usermode_blob(void *data, size_t len, struct umh_info *info);

extern int
call_usermodehelper_exec(struct subprocess_info *info, int wait);

extern struct ctl_table usermodehelper_table[];

enum umh_disable_depth {
 UMH_ENABLED = 0,
 UMH_FREEZING,
 UMH_DISABLED,
};

extern int __usermodehelper_disable(enum umh_disable_depth depth);
extern void __usermodehelper_set_disable_depth(enum umh_disable_depth depth);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int usermodehelper_disable(void)
{
 return __usermodehelper_disable(UMH_DISABLED);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void usermodehelper_enable(void)
{
 __usermodehelper_set_disable_depth(UMH_ENABLED);
}

extern int usermodehelper_read_trylock(void);
extern long usermodehelper_read_lock_wait(long timeout);
extern void usermodehelper_read_unlock(void);
# 10 "/home/nathan/src/linux-next/include/linux/kmod.h" 2
# 20 "/home/nathan/src/linux-next/include/linux/kmod.h"
extern char modprobe_path[];


extern __attribute__((__format__(printf, 2, 3)))
int __request_module(bool wait, const char *name, ...);
# 17 "/home/nathan/src/linux-next/include/linux/module.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/elf.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/sched.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/sched.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/sched.h" 1
# 89 "/home/nathan/src/linux-next/include/uapi/linux/sched.h"
struct clone_args {
 __u64 __attribute__((aligned(8))) flags;
 __u64 __attribute__((aligned(8))) pidfd;
 __u64 __attribute__((aligned(8))) child_tid;
 __u64 __attribute__((aligned(8))) parent_tid;
 __u64 __attribute__((aligned(8))) exit_signal;
 __u64 __attribute__((aligned(8))) stack;
 __u64 __attribute__((aligned(8))) stack_size;
 __u64 __attribute__((aligned(8))) tls;
 __u64 __attribute__((aligned(8))) set_tid;
 __u64 __attribute__((aligned(8))) set_tid_size;
};
# 11 "/home/nathan/src/linux-next/include/linux/sched.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/pid.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/rculist.h" 1
# 31 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_LIST_HEAD_RCU(struct list_head *list)
{
 ({ union { typeof(list->next) __val; char __c[1]; } __u = { .__val = ( typeof(list->next)) (list) }; __write_once_size(&(list->next), __u.__c, sizeof(list->next)); __u.__val; });
 ({ union { typeof(list->prev) __val; char __c[1]; } __u = { .__val = ( typeof(list->prev)) (list) }; __write_once_size(&(list->prev), __u.__c, sizeof(list->prev)); __u.__val; });
}
# 77 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_add_rcu(struct list_head *new,
  struct list_head *prev, struct list_head *next)
{
 if (!__list_add_valid(new, prev, next))
  return;

 new->next = next;
 new->prev = prev;
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct list_head **)(&(prev)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct list_head **)(&(prev)->next)))))) ((typeof((*((struct list_head **)(&(prev)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct list_head **)(&(prev)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(prev)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_85(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_85(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct list_head **)(&(prev)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct list_head **)(&(prev)->next))))) ((typeof(*((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct list_head **)(&(prev)->next)))), __u.__c, sizeof(*&(*((struct list_head **)(&(prev)->next))))); __u.__val; }); } while (0); } while (0);
 next->prev = new;
}
# 105 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_rcu(struct list_head *new, struct list_head *head)
{
 __list_add_rcu(new, head, head->next);
}
# 126 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_add_tail_rcu(struct list_head *new,
     struct list_head *head)
{
 __list_add_rcu(new, head->prev, head);
}
# 156 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_del_rcu(struct list_head *entry)
{
 __list_del_entry(entry);
 entry->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 182 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_init_rcu(struct hlist_node *n)
{
 if (!hlist_unhashed(n)) {
  __hlist_del(n);
  ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (((void *)0)) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 }
}
# 198 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_replace_rcu(struct list_head *old,
    struct list_head *new)
{
 new->next = old->next;
 new->prev = old->prev;
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct list_head **)(&(new->prev)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct list_head **)(&(new->prev)->next)))))) ((typeof((*((struct list_head **)(&(new->prev)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct list_head **)(&(new->prev)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(new->prev)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_203(void) ; if (!((sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(new->prev)->next)))) == sizeof(long)))) __compiletime_assert_203(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct list_head **)(&(new->prev)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct list_head **)(&(new->prev)->next))))) ((typeof(*((typeof((*((struct list_head **)(&(new->prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(new->prev)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct list_head **)(&(new->prev)->next)))), __u.__c, sizeof(*&(*((struct list_head **)(&(new->prev)->next))))); __u.__val; }); } while (0); } while (0);
 new->next->prev = new;
 old->prev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 227 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __list_splice_init_rcu(struct list_head *list,
       struct list_head *prev,
       struct list_head *next,
       void (*sync)(void))
{
 struct list_head *first = list->next;
 struct list_head *last = list->prev;







 INIT_LIST_HEAD_RCU(list);
# 250 "/home/nathan/src/linux-next/include/linux/rculist.h"
 sync();
# 260 "/home/nathan/src/linux-next/include/linux/rculist.h"
 last->next = next;
 do { uintptr_t _r_a_p__v = (uintptr_t)(first); ; if (__builtin_constant_p(first) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct list_head **)(&(prev)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct list_head **)(&(prev)->next)))))) ((typeof((*((struct list_head **)(&(prev)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct list_head **)(&(prev)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(prev)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_261(void) ; if (!((sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct list_head **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_261(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct list_head **)(&(prev)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct list_head **)(&(prev)->next))))) ((typeof(*((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct list_head **)(&(prev)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct list_head **)(&(prev)->next)))), __u.__c, sizeof(*&(*((struct list_head **)(&(prev)->next))))); __u.__val; }); } while (0); } while (0);
 first->prev = prev;
 next->prev = last;
}
# 273 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_init_rcu(struct list_head *list,
     struct list_head *head,
     void (*sync)(void))
{
 if (!list_empty(list))
  __list_splice_init_rcu(list, head, head->next, sync);
}
# 288 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void list_splice_tail_init_rcu(struct list_head *list,
          struct list_head *head,
          void (*sync)(void))
{
 if (!list_empty(list))
  __list_splice_init_rcu(list, head->prev, head, sync);
}
# 483 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_del_rcu(struct hlist_node *n)
{
 __hlist_del(n);
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (((void *) 0x122 + (0x5deadbeef0000000UL))) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
}
# 496 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_replace_rcu(struct hlist_node *old,
     struct hlist_node *new)
{
 struct hlist_node *next = old->next;

 new->next = next;
 ({ union { typeof(new->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(new->pprev)) (old->pprev) }; __write_once_size(&(new->pprev), __u.__c, sizeof(new->pprev)); __u.__val; });
 do { uintptr_t _r_a_p__v = (uintptr_t)(new); ; if (__builtin_constant_p(new) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*(struct hlist_node **)new->pprev)) __val; char __c[1]; } __u = { .__val = ( typeof((*(struct hlist_node **)new->pprev))) ((typeof(*(struct hlist_node **)new->pprev))(_r_a_p__v)) }; __write_once_size(&((*(struct hlist_node **)new->pprev)), __u.__c, sizeof((*(struct hlist_node **)new->pprev))); __u.__val; }); else do { do { extern void __compiletime_assert_503(void) ; if (!((sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(char) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(short) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(int) || sizeof(*&*(struct hlist_node **)new->pprev) == sizeof(long)))) __compiletime_assert_503(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*(struct hlist_node **)new->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*&*(struct hlist_node **)new->pprev)) ((typeof(*((typeof(*(struct hlist_node **)new->pprev))_r_a_p__v)) *)((typeof(*(struct hlist_node **)new->pprev))_r_a_p__v)) }; __write_once_size(&(*&*(struct hlist_node **)new->pprev), __u.__c, sizeof(*&*(struct hlist_node **)new->pprev)); __u.__val; }); } while (0); } while (0);
 if (next)
  ({ union { typeof(new->next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(new->next->pprev)) (&new->next) }; __write_once_size(&(new->next->pprev), __u.__c, sizeof(new->next->pprev)); __u.__val; });
 ({ union { typeof(old->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(old->pprev)) (((void *) 0x122 + (0x5deadbeef0000000UL))) }; __write_once_size(&(old->pprev), __u.__c, sizeof(old->pprev)); __u.__val; });
}
# 535 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_head_rcu(struct hlist_node *n,
     struct hlist_head *h)
{
 struct hlist_node *first = h->first;

 n->next = first;
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&h->first) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_node **)(&(h)->first))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_node **)(&(h)->first)))))) ((typeof((*((struct hlist_node **)(&(h)->first)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_node **)(&(h)->first))))), __u.__c, sizeof(((*((struct hlist_node **)(&(h)->first)))))); __u.__val; }); else do { do { extern void __compiletime_assert_542(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(h)->first)))) == sizeof(long)))) __compiletime_assert_542(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_node **)(&(h)->first)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_node **)(&(h)->first))))) ((typeof(*((typeof((*((struct hlist_node **)(&(h)->first)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(h)->first)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_node **)(&(h)->first)))), __u.__c, sizeof(*&(*((struct hlist_node **)(&(h)->first))))); __u.__val; }); } while (0); } while (0);
 if (first)
  ({ union { typeof(first->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(first->pprev)) (&n->next) }; __write_once_size(&(first->pprev), __u.__c, sizeof(first->pprev)); __u.__val; });
}
# 566 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_tail_rcu(struct hlist_node *n,
          struct hlist_head *h)
{
 struct hlist_node *i, *last = ((void *)0);


 for (i = h->first; i; i = i->next)
  last = i;

 if (last) {
  n->next = last->next;
  ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&last->next) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
  do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_node **)(&(last)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_node **)(&(last)->next)))))) ((typeof((*((struct hlist_node **)(&(last)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_node **)(&(last)->next))))), __u.__c, sizeof(((*((struct hlist_node **)(&(last)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_578(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(long)))) __compiletime_assert_578(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_node **)(&(last)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_node **)(&(last)->next))))) ((typeof(*((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_node **)(&(last)->next)))), __u.__c, sizeof(*&(*((struct hlist_node **)(&(last)->next))))); __u.__val; }); } while (0); } while (0);
 } else {
  hlist_add_head_rcu(n, h);
 }
}
# 602 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_before_rcu(struct hlist_node *n,
     struct hlist_node *next)
{
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (next->pprev) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 n->next = next;
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_node **)((n)->pprev))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_node **)((n)->pprev)))))) ((typeof((*((struct hlist_node **)((n)->pprev)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_node **)((n)->pprev))))), __u.__c, sizeof(((*((struct hlist_node **)((n)->pprev)))))); __u.__val; }); else do { do { extern void __compiletime_assert_607(void) ; if (!((sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)((n)->pprev)))) == sizeof(long)))) __compiletime_assert_607(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_node **)((n)->pprev)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_node **)((n)->pprev))))) ((typeof(*((typeof((*((struct hlist_node **)((n)->pprev)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)((n)->pprev)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_node **)((n)->pprev)))), __u.__c, sizeof(*&(*((struct hlist_node **)((n)->pprev))))); __u.__val; }); } while (0); } while (0);
 ({ union { typeof(next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(next->pprev)) (&n->next) }; __write_once_size(&(next->pprev), __u.__c, sizeof(next->pprev)); __u.__val; });
}
# 629 "/home/nathan/src/linux-next/include/linux/rculist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_add_behind_rcu(struct hlist_node *n,
     struct hlist_node *prev)
{
 n->next = prev->next;
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&prev->next) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_node **)(&(prev)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_node **)(&(prev)->next)))))) ((typeof((*((struct hlist_node **)(&(prev)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_node **)(&(prev)->next))))), __u.__c, sizeof(((*((struct hlist_node **)(&(prev)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_634(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(prev)->next)))) == sizeof(long)))) __compiletime_assert_634(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_node **)(&(prev)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_node **)(&(prev)->next))))) ((typeof(*((typeof((*((struct hlist_node **)(&(prev)->next)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(prev)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_node **)(&(prev)->next)))), __u.__c, sizeof(*&(*((struct hlist_node **)(&(prev)->next))))); __u.__val; }); } while (0); } while (0);
 if (n->next)
  ({ union { typeof(n->next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->next->pprev)) (&n->next) }; __write_once_size(&(n->next->pprev), __u.__c, sizeof(n->next->pprev)); __u.__val; });
}
# 6 "/home/nathan/src/linux-next/include/linux/pid.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/refcount.h" 1
# 88 "/home/nathan/src/linux-next/include/linux/refcount.h"
struct mutex;
# 98 "/home/nathan/src/linux-next/include/linux/refcount.h"
typedef struct refcount_struct {
 atomic_t refs;
} refcount_t;





enum refcount_saturation_type {
 REFCOUNT_ADD_NOT_ZERO_OVF,
 REFCOUNT_ADD_OVF,
 REFCOUNT_ADD_UAF,
 REFCOUNT_SUB_UAF,
 REFCOUNT_DEC_LEAK,
};

void refcount_warn_saturate(refcount_t *r, enum refcount_saturation_type t);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_set(refcount_t *r, int n)
{
 atomic_set(&r->refs, n);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int refcount_read(const refcount_t *r)
{
 return atomic_read(&r->refs);
}
# 155 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_add_not_zero(int i, refcount_t *r)
{
 int old = refcount_read(r);

 do {
  if (!old)
   break;
 } while (!atomic_try_cmpxchg_relaxed(&r->refs, &old, old + i));

 if (__builtin_expect(!!(old < 0 || old + i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_NOT_ZERO_OVF);

 return old;
}
# 186 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_add(int i, refcount_t *r)
{
 int old = atomic_fetch_add_relaxed(i, &r->refs);

 if (__builtin_expect(!!(!old), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_UAF);
 else if (__builtin_expect(!!(old < 0 || old + i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_ADD_OVF);
}
# 209 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_inc_not_zero(refcount_t *r)
{
 return refcount_add_not_zero(1, r);
}
# 226 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_inc(refcount_t *r)
{
 refcount_add(1, r);
}
# 251 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_sub_and_test(int i, refcount_t *r)
{
 int old = atomic_fetch_sub_release(i, &r->refs);

 if (old == i) {
  __asm__ __volatile__ ("lwsync" " " : : :"memory");
  return true;
 }

 if (__builtin_expect(!!(old < 0 || old - i < 0), 0))
  refcount_warn_saturate(r, REFCOUNT_SUB_UAF);

 return false;
}
# 279 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool refcount_dec_and_test(refcount_t *r)
{
 return refcount_sub_and_test(1, r);
}
# 294 "/home/nathan/src/linux-next/include/linux/refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refcount_dec(refcount_t *r)
{
 if (__builtin_expect(!!(atomic_fetch_sub_release(1, &r->refs) <= 1), 0))
  refcount_warn_saturate(r, REFCOUNT_DEC_LEAK);
}

extern __attribute__((__warn_unused_result__)) bool refcount_dec_if_one(refcount_t *r);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_not_one(refcount_t *r);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock);
extern __attribute__((__warn_unused_result__)) bool refcount_dec_and_lock_irqsave(refcount_t *r,
             spinlock_t *lock,
             unsigned long *flags);
# 8 "/home/nathan/src/linux-next/include/linux/pid.h" 2

enum pid_type
{
 PIDTYPE_PID,
 PIDTYPE_TGID,
 PIDTYPE_PGID,
 PIDTYPE_SID,
 PIDTYPE_MAX,
};
# 54 "/home/nathan/src/linux-next/include/linux/pid.h"
struct upid {
 int nr;
 struct pid_namespace *ns;
};

struct pid
{
 refcount_t count;
 unsigned int level;

 struct hlist_head tasks[PIDTYPE_MAX];

 wait_queue_head_t wait_pidfd;
 struct callback_head rcu;
 struct upid numbers[1];
};

extern struct pid init_struct_pid;

extern const struct file_operations pidfd_fops;

struct file;

extern struct pid *pidfd_pid(const struct file *file);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *get_pid(struct pid *pid)
{
 if (pid)
  refcount_inc(&pid->count);
 return pid;
}

extern void put_pid(struct pid *pid);
extern struct task_struct *pid_task(struct pid *pid, enum pid_type);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pid_has_task(struct pid *pid, enum pid_type type)
{
 return !hlist_empty(&pid->tasks[type]);
}
extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);

extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);




extern void attach_pid(struct task_struct *task, enum pid_type);
extern void detach_pid(struct task_struct *task, enum pid_type);
extern void change_pid(struct task_struct *task, enum pid_type,
   struct pid *pid);
extern void transfer_pid(struct task_struct *old, struct task_struct *new,
    enum pid_type);

struct pid_namespace;
extern struct pid_namespace init_pid_ns;
# 118 "/home/nathan/src/linux-next/include/linux/pid.h"
extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
extern struct pid *find_vpid(int nr);




extern struct pid *find_get_pid(int nr);
extern struct pid *find_ge_pid(int nr, struct pid_namespace *);

extern struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,
        size_t set_tid_size);
extern void free_pid(struct pid *pid);
extern void disable_pid_allocation(struct pid_namespace *ns);
# 142 "/home/nathan/src/linux-next/include/linux/pid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid_namespace *ns_of_pid(struct pid *pid)
{
 struct pid_namespace *ns = ((void *)0);
 if (pid)
  ns = pid->numbers[pid->level].ns;
 return ns;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_child_reaper(struct pid *pid)
{
 return pid->numbers[pid->level].nr == 1;
}
# 172 "/home/nathan/src/linux-next/include/linux/pid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t pid_nr(struct pid *pid)
{
 pid_t nr = 0;
 if (pid)
  nr = pid->numbers[0].nr;
 return nr;
}

pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
pid_t pid_vnr(struct pid *pid);
# 15 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sem.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/ipc.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhash_head {
 struct rhash_head *next;
};

struct rhlist_head {
 struct rhash_head rhead;
 struct rhlist_head *next;
};

struct bucket_table;






struct rhashtable_compare_arg {
 struct rhashtable *ht;
 const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *data, u32 len, u32 seed);
typedef u32 (*rht_obj_hashfn_t)(const void *data, u32 len, u32 seed);
typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *arg,
          const void *obj);
# 56 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable_params {
 u16 nelem_hint;
 u16 key_len;
 u16 key_offset;
 u16 head_offset;
 unsigned int max_size;
 u16 min_size;
 bool automatic_shrinking;
 rht_hashfn_t hashfn;
 rht_obj_hashfn_t obj_hashfn;
 rht_obj_cmpfn_t obj_cmpfn;
};
# 81 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable {
 struct bucket_table *tbl;
 unsigned int key_len;
 unsigned int max_elems;
 struct rhashtable_params p;
 bool rhlist;
 struct work_struct run_work;
 struct mutex mutex;
 spinlock_t lock;
 atomic_t nelems;
};





struct rhltable {
 struct rhashtable ht;
};






struct rhashtable_walker {
 struct list_head list;
 struct bucket_table *tbl;
};
# 120 "/home/nathan/src/linux-next/include/linux/rhashtable-types.h"
struct rhashtable_iter {
 struct rhashtable *ht;
 struct rhash_head *p;
 struct rhlist_head *list;
 struct rhashtable_walker walker;
 unsigned int slot;
 unsigned int skip;
 bool end_of_table;
};

int rhashtable_init(struct rhashtable *ht,
      const struct rhashtable_params *params);
int rhltable_init(struct rhltable *hlt,
    const struct rhashtable_params *params);
# 8 "/home/nathan/src/linux-next/include/linux/ipc.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h" 1
# 10 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h"
struct ipc_perm
{
 __kernel_key_t key;
 __kernel_uid_t uid;
 __kernel_gid_t gid;
 __kernel_uid_t cuid;
 __kernel_gid_t cgid;
 __kernel_mode_t mode;
 unsigned short seq;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ipcbuf.h" 1
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ipcbuf.h"
struct ipc64_perm
{
 __kernel_key_t key;
 __kernel_uid_t uid;
 __kernel_gid_t gid;
 __kernel_uid_t cuid;
 __kernel_gid_t cgid;
 __kernel_mode_t mode;
 unsigned int seq;
 unsigned int __pad1;
 unsigned long long __unused1;
 unsigned long long __unused2;
};
# 23 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h" 2
# 58 "/home/nathan/src/linux-next/include/uapi/linux/ipc.h"
struct ipc_kludge {
 struct msgbuf *msgp;
 long msgtyp;
};
# 9 "/home/nathan/src/linux-next/include/linux/ipc.h" 2



struct kern_ipc_perm {
 spinlock_t lock;
 bool deleted;
 int id;
 key_t key;
 kuid_t uid;
 kgid_t gid;
 kuid_t cuid;
 kgid_t cgid;
 umode_t mode;
 unsigned long seq;
 void *security;

 struct rhash_head khtnode;

 struct callback_head rcu;
 refcount_t refcount;
} __attribute__((__aligned__((1 << 7)))) ;
# 6 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 2
# 25 "/home/nathan/src/linux-next/include/uapi/linux/sem.h"
struct semid_ds {
 struct ipc_perm sem_perm;
 __kernel_old_time_t sem_otime;
 __kernel_old_time_t sem_ctime;
 struct sem *sem_base;
 struct sem_queue *sem_pending;
 struct sem_queue **sem_pending_last;
 struct sem_undo *undo;
 unsigned short sem_nsems;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/sembuf.h" 1
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/sembuf.h"
struct semid64_ds {
 struct ipc64_perm sem_perm;






 long sem_otime;
 long sem_ctime;

 unsigned long sem_nsems;
 unsigned long __unused3;
 unsigned long __unused4;
};
# 38 "/home/nathan/src/linux-next/include/uapi/linux/sem.h" 2


struct sembuf {
 unsigned short sem_num;
 short sem_op;
 short sem_flg;
};


union semun {
 int val;
 struct semid_ds *buf;
 unsigned short *array;
 struct seminfo *__buf;
 void *__pad;
};

struct seminfo {
 int semmap;
 int semmni;
 int semmns;
 int semmnu;
 int semmsl;
 int semopm;
 int semume;
 int semusz;
 int semvmx;
 int semaem;
};
# 6 "/home/nathan/src/linux-next/include/linux/sem.h" 2

struct task_struct;
struct sem_undo_list;



struct sysv_sem {
 struct sem_undo_list *undo_list;
};

extern int copy_semundo(unsigned long clone_flags, struct task_struct *tsk);
extern void exit_sem(struct task_struct *tsk);
# 16 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/shm.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/hugetlb_encode.h" 1
# 8 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 2
# 28 "/home/nathan/src/linux-next/include/uapi/linux/shm.h"
struct shmid_ds {
 struct ipc_perm shm_perm;
 int shm_segsz;
 __kernel_old_time_t shm_atime;
 __kernel_old_time_t shm_dtime;
 __kernel_old_time_t shm_ctime;
 __kernel_ipc_pid_t shm_cpid;
 __kernel_ipc_pid_t shm_lpid;
 unsigned short shm_nattch;
 unsigned short shm_unused;
 void *shm_unused2;
 void *shm_unused3;
};



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h" 1
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h"
struct shmid64_ds {
 struct ipc64_perm shm_perm;

 long shm_atime;
 long shm_dtime;
 long shm_ctime;
# 37 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/shmbuf.h"
 size_t shm_segsz;
 __kernel_pid_t shm_cpid;
 __kernel_pid_t shm_lpid;
 unsigned long shm_nattch;
 unsigned long __unused5;
 unsigned long __unused6;
};

struct shminfo64 {
 unsigned long shmmax;
 unsigned long shmmin;
 unsigned long shmmni;
 unsigned long shmseg;
 unsigned long shmall;
 unsigned long __unused1;
 unsigned long __unused2;
 unsigned long __unused3;
 unsigned long __unused4;
};
# 44 "/home/nathan/src/linux-next/include/uapi/linux/shm.h" 2
# 93 "/home/nathan/src/linux-next/include/uapi/linux/shm.h"
struct shminfo {
 int shmmax;
 int shmmin;
 int shmmni;
 int shmseg;
 int shmall;
};

struct shm_info {
 int used_ids;
 __kernel_ulong_t shm_tot;
 __kernel_ulong_t shm_rss;
 __kernel_ulong_t shm_swp;
 __kernel_ulong_t swap_attempts;
 __kernel_ulong_t swap_successes;
};
# 8 "/home/nathan/src/linux-next/include/linux/shm.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/shmparam.h" 1
# 9 "/home/nathan/src/linux-next/include/linux/shm.h" 2

struct file;


struct sysv_shm {
 struct list_head shm_clist;
};

long do_shmat(int shmid, char *shmaddr, int shmflg, unsigned long *addr,
       unsigned long shmlba);
bool is_file_shm_hugepages(struct file *file);
void exit_shm(struct task_struct *task);
# 17 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kcov.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h" 1
# 11 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
struct kcov_remote_arg {
 __u32 trace_mode;
 __u32 area_size;
 __u32 num_handles;
 __u64 __attribute__((aligned(8))) common_handle;
 __u64 __attribute__((aligned(8))) handles[0];
};
# 26 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
enum {
# 35 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
 KCOV_TRACE_PC = 0,

 KCOV_TRACE_CMP = 1,
};
# 56 "/home/nathan/src/linux-next/include/uapi/linux/kcov.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 kcov_remote_handle(__u64 subsys, __u64 inst)
{
 if (subsys & ~(0xffull << 56) || inst & ~(0xffffffffull))
  return 0;
 return subsys | inst;
}
# 6 "/home/nathan/src/linux-next/include/linux/kcov.h" 2

struct task_struct;
# 57 "/home/nathan/src/linux-next/include/linux/kcov.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_task_init(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_task_exit(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_prepare_switch(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_finish_switch(struct task_struct *t) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start(u64 handle) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_stop(void) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 kcov_common_handle(void)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start_common(u64 id) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcov_remote_start_usb(u64 id) {}
# 18 "/home/nathan/src/linux-next/include/linux/sched.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/plist.h" 1
# 79 "/home/nathan/src/linux-next/include/linux/plist.h"
struct plist_head {
 struct list_head node_list;
};

struct plist_node {
 int prio;
 struct list_head prio_list;
 struct list_head node_list;
};
# 121 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
plist_head_init(struct plist_head *head)
{
 INIT_LIST_HEAD(&head->node_list);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void plist_node_init(struct plist_node *node, int prio)
{
 node->prio = prio;
 INIT_LIST_HEAD(&node->prio_list);
 INIT_LIST_HEAD(&node->node_list);
}

extern void plist_add(struct plist_node *node, struct plist_head *head);
extern void plist_del(struct plist_node *node, struct plist_head *head);

extern void plist_requeue(struct plist_node *node, struct plist_head *head);
# 210 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int plist_head_empty(const struct plist_head *head)
{
 return list_empty(&head->node_list);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int plist_node_empty(const struct plist_node *node)
{
 return list_empty(&node->node_list);
}
# 280 "/home/nathan/src/linux-next/include/linux/plist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct plist_node *plist_first(const struct plist_head *head)
{
 return ({ void *__mptr = (void *)(head->node_list.next); do { extern void __compiletime_assert_283(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->node_list.next)), typeof(((struct plist_node *)0)->node_list)) && !__builtin_types_compatible_p(typeof(*(head->node_list.next)), typeof(void))))) __compiletime_assert_283(); } while (0); ((struct plist_node *)(__mptr - __builtin_offsetof(struct plist_node, node_list))); });

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct plist_node *plist_last(const struct plist_head *head)
{
 return ({ void *__mptr = (void *)(head->node_list.prev); do { extern void __compiletime_assert_295(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->node_list.prev)), typeof(((struct plist_node *)0)->node_list)) && !__builtin_types_compatible_p(typeof(*(head->node_list.prev)), typeof(void))))) __compiletime_assert_295(); } while (0); ((struct plist_node *)(__mptr - __builtin_offsetof(struct plist_node, node_list))); });

}
# 20 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
# 1 "/home/nathan/src/linux-next/include/linux/hrtimer_defs.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/timerqueue.h" 1








struct timerqueue_node {
 struct rb_node node;
 ktime_t expires;
};

struct timerqueue_head {
 struct rb_root_cached rb_root;
};


extern bool timerqueue_add(struct timerqueue_head *head,
      struct timerqueue_node *node);
extern bool timerqueue_del(struct timerqueue_head *head,
      struct timerqueue_node *node);
extern struct timerqueue_node *timerqueue_iterate_next(
      struct timerqueue_node *node);
# 33 "/home/nathan/src/linux-next/include/linux/timerqueue.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
 struct rb_node *leftmost = (&head->rb_root)->rb_leftmost;

 return ({ void *__mptr = (void *)(leftmost); do { extern void __compiletime_assert_38(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(leftmost)), typeof(((struct timerqueue_node *)0)->node)) && !__builtin_types_compatible_p(typeof(*(leftmost)), typeof(void))))) __compiletime_assert_38(); } while (0); ((struct timerqueue_node *)(__mptr - __builtin_offsetof(struct timerqueue_node, node))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void timerqueue_init(struct timerqueue_node *node)
{
 ((&node->node)->__rb_parent_color = (unsigned long)(&node->node));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timerqueue_node_queued(struct timerqueue_node *node)
{
 return !((&node->node)->__rb_parent_color == (unsigned long)(&node->node));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool timerqueue_node_expires(struct timerqueue_node *node)
{
 return node->expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void timerqueue_init_head(struct timerqueue_head *head)
{
 head->rb_root = (struct rb_root_cached) { {((void *)0), }, ((void *)0) };
}
# 22 "/home/nathan/src/linux-next/include/linux/hrtimer.h" 2

struct hrtimer_clock_base;
struct hrtimer_cpu_base;
# 38 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
enum hrtimer_mode {
 HRTIMER_MODE_ABS = 0x00,
 HRTIMER_MODE_REL = 0x01,
 HRTIMER_MODE_PINNED = 0x02,
 HRTIMER_MODE_SOFT = 0x04,
 HRTIMER_MODE_HARD = 0x08,

 HRTIMER_MODE_ABS_PINNED = HRTIMER_MODE_ABS | HRTIMER_MODE_PINNED,
 HRTIMER_MODE_REL_PINNED = HRTIMER_MODE_REL | HRTIMER_MODE_PINNED,

 HRTIMER_MODE_ABS_SOFT = HRTIMER_MODE_ABS | HRTIMER_MODE_SOFT,
 HRTIMER_MODE_REL_SOFT = HRTIMER_MODE_REL | HRTIMER_MODE_SOFT,

 HRTIMER_MODE_ABS_PINNED_SOFT = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_SOFT,
 HRTIMER_MODE_REL_PINNED_SOFT = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_SOFT,

 HRTIMER_MODE_ABS_HARD = HRTIMER_MODE_ABS | HRTIMER_MODE_HARD,
 HRTIMER_MODE_REL_HARD = HRTIMER_MODE_REL | HRTIMER_MODE_HARD,

 HRTIMER_MODE_ABS_PINNED_HARD = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_HARD,
 HRTIMER_MODE_REL_PINNED_HARD = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_HARD,
};




enum hrtimer_restart {
 HRTIMER_NORESTART,
 HRTIMER_RESTART,
};
# 117 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer {
 struct timerqueue_node node;
 ktime_t _softexpires;
 enum hrtimer_restart (*function)(struct hrtimer *);
 struct hrtimer_clock_base *base;
 u8 state;
 u8 is_rel;
 u8 is_soft;
 u8 is_hard;
};
# 135 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_sleeper {
 struct hrtimer timer;
 struct task_struct *task;
};
# 158 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_clock_base {
 struct hrtimer_cpu_base *cpu_base;
 unsigned int index;
 clockid_t clockid;
 seqcount_t seq;
 struct hrtimer *running;
 struct timerqueue_head active;
 ktime_t (*get_time)(void);
 ktime_t offset;
} __attribute__((__aligned__((1 << 7))));

enum hrtimer_base_type {
 HRTIMER_BASE_MONOTONIC,
 HRTIMER_BASE_REALTIME,
 HRTIMER_BASE_BOOTTIME,
 HRTIMER_BASE_TAI,
 HRTIMER_BASE_MONOTONIC_SOFT,
 HRTIMER_BASE_REALTIME_SOFT,
 HRTIMER_BASE_BOOTTIME_SOFT,
 HRTIMER_BASE_TAI_SOFT,
 HRTIMER_MAX_CLOCK_BASES,
};
# 213 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
 raw_spinlock_t lock;
 unsigned int cpu;
 unsigned int active_bases;
 unsigned int clock_was_set_seq;
 unsigned int hres_active : 1,
     in_hrtirq : 1,
     hang_detected : 1,
     softirq_activated : 1;

 unsigned int nr_events;
 unsigned short nr_retries;
 unsigned short nr_hangs;
 unsigned int max_hang_time;





 ktime_t expires_next;
 struct hrtimer *next_timer;
 ktime_t softirq_expires_next;
 struct hrtimer *softirq_next_timer;
 struct hrtimer_clock_base clock_base[HRTIMER_MAX_CLOCK_BASES];
} __attribute__((__aligned__((1 << 7))));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
 timer->node.expires = time;
 timer->_softexpires = time;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_range(struct hrtimer *timer, ktime_t time, ktime_t delta)
{
 timer->_softexpires = time;
 timer->node.expires = ktime_add_safe(time, delta);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_range_ns(struct hrtimer *timer, ktime_t time, u64 delta)
{
 timer->_softexpires = time;
 timer->node.expires = ktime_add_safe(time, ns_to_ktime(delta));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_set_expires_tv64(struct hrtimer *timer, s64 tv64)
{
 timer->node.expires = tv64;
 timer->_softexpires = tv64;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_add_expires(struct hrtimer *timer, ktime_t time)
{
 timer->node.expires = ktime_add_safe(timer->node.expires, time);
 timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_add_expires_ns(struct hrtimer *timer, u64 ns)
{
 timer->node.expires = ((timer->node.expires) + (ns));
 timer->_softexpires = ((timer->_softexpires) + (ns));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_expires(const struct hrtimer *timer)
{
 return timer->node.expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)
{
 return timer->_softexpires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_expires_tv64(const struct hrtimer *timer)
{
 return timer->node.expires;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_softexpires_tv64(const struct hrtimer *timer)
{
 return timer->_softexpires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 hrtimer_get_expires_ns(const struct hrtimer *timer)
{
 return ktime_to_ns(timer->node.expires);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_expires_remaining(const struct hrtimer *timer)
{
 return ((timer->node.expires) - (timer->base->get_time()));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_cb_get_time(struct hrtimer *timer)
{
 return timer->base->get_time();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hrtimer_is_hres_active(struct hrtimer *timer)
{
 return 1 ?
  timer->base->cpu_base->hres_active : 0;
}


struct clock_event_device;

extern void hrtimer_interrupt(struct clock_event_device *dev);

extern void clock_was_set_delayed(void);

extern unsigned int hrtimer_resolution;
# 332 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t
__hrtimer_expires_remaining_adjusted(const struct hrtimer *timer, ktime_t now)
{
 ktime_t rem = ((timer->node.expires) - (now));





 if (0 && timer->is_rel)
  rem -= hrtimer_resolution;
 return rem;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t
hrtimer_expires_remaining_adjusted(const struct hrtimer *timer)
{
 return __hrtimer_expires_remaining_adjusted(timer,
          timer->base->get_time());
}

extern void clock_was_set(void);

extern void timerfd_clock_was_set(void);



extern void hrtimers_resume(void);

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct tick_device) tick_cpu_device;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_cancel_wait_running(struct hrtimer *timer)
{
 do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
}





extern void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,
    enum hrtimer_mode mode);
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,
     enum hrtimer_mode mode);
# 389 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_init_on_stack(struct hrtimer *timer,
      clockid_t which_clock,
      enum hrtimer_mode mode)
{
 hrtimer_init(timer, which_clock, mode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,
       clockid_t clock_id,
       enum hrtimer_mode mode)
{
 hrtimer_init_sleeper(sl, clock_id, mode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void destroy_hrtimer_on_stack(struct hrtimer *timer) { }



extern void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
       u64 range_ns, const enum hrtimer_mode mode);
# 418 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_start(struct hrtimer *timer, ktime_t tim,
     const enum hrtimer_mode mode)
{
 hrtimer_start_range_ns(timer, tim, 0, mode);
}

extern int hrtimer_cancel(struct hrtimer *timer);
extern int hrtimer_try_to_cancel(struct hrtimer *timer);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_start_expires(struct hrtimer *timer,
      enum hrtimer_mode mode)
{
 u64 delta;
 ktime_t soft, hard;
 soft = hrtimer_get_softexpires(timer);
 hard = hrtimer_get_expires(timer);
 delta = ktime_to_ns(((hard) - (soft)));
 hrtimer_start_range_ns(timer, soft, delta, mode);
}

void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,
       enum hrtimer_mode mode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hrtimer_restart(struct hrtimer *timer)
{
 hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
}


extern ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t hrtimer_get_remaining(const struct hrtimer *timer)
{
 return __hrtimer_get_remaining(timer, false);
}

extern u64 hrtimer_get_next_event(void);
extern u64 hrtimer_next_event_without(const struct hrtimer *exclude);

extern bool hrtimer_active(const struct hrtimer *timer);
# 467 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hrtimer_is_queued(struct hrtimer *timer)
{

 return !!(({ union { typeof(timer->state) __val; char __c[1]; } __u; if (1) __read_once_size(&(timer->state), __u.__c, sizeof(timer->state)); else __read_once_size_nocheck(&(timer->state), __u.__c, sizeof(timer->state)); do { } while (0); __u.__val; }) & 0x01);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hrtimer_callback_running(struct hrtimer *timer)
{
 return timer->base->running == timer;
}


extern u64
hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);
# 502 "/home/nathan/src/linux-next/include/linux/hrtimer.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 hrtimer_forward_now(struct hrtimer *timer,
          ktime_t interval)
{
 return hrtimer_forward(timer, timer->base->get_time(), interval);
}



extern int nanosleep_copyout(struct restart_block *, struct timespec64 *);
extern long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,
         const clockid_t clockid);

extern int schedule_hrtimeout_range(ktime_t *expires, u64 delta,
        const enum hrtimer_mode mode);
extern int schedule_hrtimeout_range_clock(ktime_t *expires,
       u64 delta,
       const enum hrtimer_mode mode,
       clockid_t clock_id);
extern int schedule_hrtimeout(ktime_t *expires, const enum hrtimer_mode mode);


extern void hrtimer_run_queues(void);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) hrtimers_init(void);


extern void sysrq_timer_list_show(void);

int hrtimers_prepare_cpu(unsigned int cpu);

int hrtimers_dead_cpu(unsigned int cpu);
# 21 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/seccomp.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h" 1
# 59 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h"
struct seccomp_data {
 int nr;
 __u32 arch;
 __u64 instruction_pointer;
 __u64 args[6];
};

struct seccomp_notif_sizes {
 __u16 seccomp_notif;
 __u16 seccomp_notif_resp;
 __u16 seccomp_data;
};

struct seccomp_notif {
 __u64 id;
 __u32 pid;
 __u32 flags;
 struct seccomp_data data;
};
# 108 "/home/nathan/src/linux-next/include/uapi/linux/seccomp.h"
struct seccomp_notif_resp {
 __u64 id;
 __s64 val;
 __s32 error;
 __u32 flags;
};
# 6 "/home/nathan/src/linux-next/include/linux/seccomp.h" 2
# 15 "/home/nathan/src/linux-next/include/linux/seccomp.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/unistd.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unistd.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/unistd_64.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/unistd.h" 2
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unistd.h" 2
# 9 "/home/nathan/src/linux-next/include/uapi/linux/unistd.h" 2
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 2



# 1 "/home/nathan/src/linux-next/include/asm-generic/seccomp.h" 1
# 31 "/home/nathan/src/linux-next/include/asm-generic/seccomp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const int *get_compat_mode1_syscalls(void)
{
 static const int mode1_syscalls_32[] = {
  3, 4,
  1, 119,
  0,
 };
 return mode1_syscalls_32;
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/seccomp.h" 2
# 16 "/home/nathan/src/linux-next/include/linux/seccomp.h" 2

struct seccomp_filter;
# 29 "/home/nathan/src/linux-next/include/linux/seccomp.h"
struct seccomp {
 int mode;
 struct seccomp_filter *filter;
};


extern int __secure_computing(const struct seccomp_data *sd);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int secure_computing(void)
{
 if (__builtin_expect(!!(test_ti_thread_flag(((struct thread_info *)get_current()), 10)), 0))
  return __secure_computing(((void *)0));
 return 0;
}




extern long prctl_get_seccomp(void);
extern long prctl_set_seccomp(unsigned long, void *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int seccomp_mode(struct seccomp *s)
{
 return s->mode;
}
# 84 "/home/nathan/src/linux-next/include/linux/seccomp.h"
extern void put_seccomp_filter(struct task_struct *tsk);
extern void get_seccomp_filter(struct task_struct *tsk);
# 103 "/home/nathan/src/linux-next/include/linux/seccomp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long seccomp_get_filter(struct task_struct *task,
          unsigned long n, void *data)
{
 return -22;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long seccomp_get_metadata(struct task_struct *task,
     unsigned long filter_off,
     void *data)
{
 return -22;
}
# 22 "/home/nathan/src/linux-next/include/linux/sched.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/resource.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/resource.h" 1
# 24 "/home/nathan/src/linux-next/include/uapi/linux/resource.h"
struct rusage {
 struct __kernel_old_timeval ru_utime;
 struct __kernel_old_timeval ru_stime;
 __kernel_long_t ru_maxrss;
 __kernel_long_t ru_ixrss;
 __kernel_long_t ru_idrss;
 __kernel_long_t ru_isrss;
 __kernel_long_t ru_minflt;
 __kernel_long_t ru_majflt;
 __kernel_long_t ru_nswap;
 __kernel_long_t ru_inblock;
 __kernel_long_t ru_oublock;
 __kernel_long_t ru_msgsnd;
 __kernel_long_t ru_msgrcv;
 __kernel_long_t ru_nsignals;
 __kernel_long_t ru_nvcsw;
 __kernel_long_t ru_nivcsw;
};

struct rlimit {
 __kernel_ulong_t rlim_cur;
 __kernel_ulong_t rlim_max;
};



struct rlimit64 {
 __u64 rlim_cur;
 __u64 rlim_max;
};
# 78 "/home/nathan/src/linux-next/include/uapi/linux/resource.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/resource.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/resource.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/resource.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/resource.h" 2
# 2 "./arch/powerpc/include/generated/uapi/asm/resource.h" 2
# 79 "/home/nathan/src/linux-next/include/uapi/linux/resource.h" 2
# 6 "/home/nathan/src/linux-next/include/linux/resource.h" 2


struct task_struct;

void getrusage(struct task_struct *p, int who, struct rusage *ru);
int do_prlimit(struct task_struct *tsk, unsigned int resource,
  struct rlimit *new_rlim, struct rlimit *old_rlim);
# 26 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/latencytop.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/latencytop.h"
struct task_struct;
# 46 "/home/nathan/src/linux-next/include/linux/latencytop.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
account_scheduler_latency(struct task_struct *task, int usecs, int inter)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_latency_tracing(struct task_struct *p)
{
}
# 27 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/prio.h" 1
# 48 "/home/nathan/src/linux-next/include/linux/sched/prio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long nice_to_rlimit(long nice)
{
 return (19 - nice + 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long rlimit_to_nice(long prio)
{
 return (19 - prio + 1);
}
# 28 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/types.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/sched/types.h"
struct task_cputime {
 u64 stime;
 u64 utime;
 unsigned long long sum_exec_runtime;
};
# 29 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/signal_types.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/signal_types.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/signal.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h" 1
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
typedef unsigned long old_sigset_t;

typedef struct {
 unsigned long sig[(64 / 64)];
} sigset_t;
# 92 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/signal-defs.h" 1
# 18 "/home/nathan/src/linux-next/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
# 93 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h" 2
# 110 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/signal.h"
typedef struct sigaltstack {
 void *ss_sp;
 int ss_flags;
 size_t ss_size;
} stack_t;
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/signal.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 2
# 1 "./arch/powerpc/include/generated/uapi/asm/siginfo.h" 1
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h" 1







typedef union sigval {
 int sival_int;
 void *sival_ptr;
} sigval_t;
# 32 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
union __sifields {

 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
 } _kill;


 struct {
  __kernel_timer_t _tid;
  int _overrun;
  sigval_t _sigval;
  int _sys_private;
 } _timer;


 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  sigval_t _sigval;
 } _rt;


 struct {
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  int _status;
  __kernel_clock_t _utime;
  __kernel_clock_t _stime;
 } _sigchld;


 struct {
  void *_addr;
# 77 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
  union {




   short _addr_lsb;

   struct {
    char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
    void *_lower;
    void *_upper;
   } _addr_bnd;

   struct {
    char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
    __u32 _pkey;
   } _addr_pkey;
  };
 } _sigfault;


 struct {
  long _band;
  int _fd;
 } _sigpoll;


 struct {
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
 } _sigsys;
};
# 129 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo {
 union {
  struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
  int _si_pad[128/sizeof(int)];
 };
} siginfo_t;
# 320 "/home/nathan/src/linux-next/include/uapi/asm-generic/siginfo.h"
typedef struct sigevent {
 sigval_t sigev_value;
 int sigev_signo;
 int sigev_notify;
 union {
  int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
   int _tid;

  struct {
   void (*_function)(sigval_t);
   void *_attribute;
  } _sigev_thread;
 } _sigev_un;
} sigevent_t;
# 2 "./arch/powerpc/include/generated/uapi/asm/siginfo.h" 2
# 7 "/home/nathan/src/linux-next/include/uapi/linux/signal.h" 2
# 11 "/home/nathan/src/linux-next/include/linux/signal_types.h" 2

typedef struct kernel_siginfo {
 struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
} kernel_siginfo_t;





struct sigqueue {
 struct list_head list;
 int flags;
 kernel_siginfo_t info;
 struct user_struct *user;
};




struct sigpending {
 struct list_head list;
 sigset_t signal;
};

struct sigaction {

 __sighandler_t sa_handler;
 unsigned long sa_flags;





 __sigrestore_t sa_restorer;

 sigset_t sa_mask;
};

struct k_sigaction {
 struct sigaction sa;



};
# 65 "/home/nathan/src/linux-next/include/linux/signal_types.h"
struct ksignal {
 struct k_sigaction ka;
 kernel_siginfo_t info;
 int sig;
};
# 30 "/home/nathan/src/linux-next/include/linux/sched.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h"
struct task_io_accounting {
# 46 "/home/nathan/src/linux-next/include/linux/task_io_accounting.h"
};
# 32 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/posix-timers.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/alarmtimer.h" 1








struct rtc_device;

enum alarmtimer_type {
 ALARM_REALTIME,
 ALARM_BOOTTIME,


 ALARM_NUMTYPE,


 ALARM_REALTIME_FREEZER,
 ALARM_BOOTTIME_FREEZER,
};

enum alarmtimer_restart {
 ALARMTIMER_NORESTART,
 ALARMTIMER_RESTART,
};
# 42 "/home/nathan/src/linux-next/include/linux/alarmtimer.h"
struct alarm {
 struct timerqueue_node node;
 struct hrtimer timer;
 enum alarmtimer_restart (*function)(struct alarm *, ktime_t now);
 enum alarmtimer_type type;
 int state;
 void *data;
};

void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
  enum alarmtimer_restart (*function)(struct alarm *, ktime_t));
void alarm_start(struct alarm *alarm, ktime_t start);
void alarm_start_relative(struct alarm *alarm, ktime_t start);
void alarm_restart(struct alarm *alarm);
int alarm_try_to_cancel(struct alarm *alarm);
int alarm_cancel(struct alarm *alarm);

u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval);
u64 alarm_forward_now(struct alarm *alarm, ktime_t interval);
ktime_t alarm_expires_remaining(const struct alarm *alarm);



struct rtc_device *alarmtimer_get_rtcdev(void);
# 8 "/home/nathan/src/linux-next/include/linux/posix-timers.h" 2


struct kernel_siginfo;
struct task_struct;
# 38 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t make_process_cpuclock(const unsigned int pid,
  const clockid_t clock)
{
 return ((~pid) << 3) | clock;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t make_thread_cpuclock(const unsigned int tid,
  const clockid_t clock)
{
 return make_process_cpuclock(tid, clock | 4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) clockid_t fd_to_clockid(const int fd)
{
 return make_process_cpuclock((unsigned int) fd, 3);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int clockid_to_fd(const clockid_t clk)
{
 return ~(clk >> 3);
}
# 69 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct cpu_timer {
 struct timerqueue_node node;
 struct timerqueue_head *head;
 struct task_struct *task;
 struct list_head elist;
 int firing;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpu_timer_enqueue(struct timerqueue_head *head,
         struct cpu_timer *ctmr)
{
 ctmr->head = head;
 return timerqueue_add(head, &ctmr->node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_timer_dequeue(struct cpu_timer *ctmr)
{
 if (ctmr->head) {
  timerqueue_del(ctmr->head, &ctmr->node);
  ctmr->head = ((void *)0);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 cpu_timer_getexpires(struct cpu_timer *ctmr)
{
 return ctmr->node.expires;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cpu_timer_setexpires(struct cpu_timer *ctmr, u64 exp)
{
 ctmr->node.expires = exp;
}






struct posix_cputimer_base {
 u64 nextevt;
 struct timerqueue_head tqhead;
};
# 122 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct posix_cputimers {
 struct posix_cputimer_base bases[3];
 unsigned int timers_active;
 unsigned int expiry_active;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void posix_cputimers_init(struct posix_cputimers *pct)
{
 memset(pct, 0, sizeof(*pct));
 pct->bases[0].nextevt = ((u64)~0ULL);
 pct->bases[1].nextevt = ((u64)~0ULL);
 pct->bases[2].nextevt = ((u64)~0ULL);
}

void posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void posix_cputimers_rt_watchdog(struct posix_cputimers *pct,
            u64 runtime)
{
 pct->bases[2].nextevt = runtime;
}
# 193 "/home/nathan/src/linux-next/include/linux/posix-timers.h"
struct k_itimer {
 struct list_head list;
 struct hlist_node t_hash;
 spinlock_t it_lock;
 const struct k_clock *kclock;
 clockid_t it_clock;
 timer_t it_id;
 int it_active;
 s64 it_overrun;
 s64 it_overrun_last;
 int it_requeue_pending;
 int it_sigev_notify;
 ktime_t it_interval;
 struct signal_struct *it_signal;
 union {
  struct pid *it_pid;
  struct task_struct *it_process;
 };
 struct sigqueue *sigq;
 union {
  struct {
   struct hrtimer timer;
  } real;
  struct cpu_timer cpu;
  struct {
   struct alarm alarmtimer;
  } alarm;
 } it;
 struct callback_head rcu;
};

void run_posix_cpu_timers(void);
void posix_cpu_timers_exit(struct task_struct *task);
void posix_cpu_timers_exit_group(struct task_struct *task);
void set_process_cpu_timer(struct task_struct *task, unsigned int clock_idx,
      u64 *newval, u64 *oldval);

void update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new);

void posixtimer_rearm(struct kernel_siginfo *info);
# 33 "/home/nathan/src/linux-next/include/linux/sched.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h" 1
# 16 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
enum rseq_cpu_id_state {
 RSEQ_CPU_ID_UNINITIALIZED = -1,
 RSEQ_CPU_ID_REGISTRATION_FAILED = -2,
};

enum rseq_flags {
 RSEQ_FLAG_UNREGISTER = (1 << 0),
};

enum rseq_cs_flags_bit {
 RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
 RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
 RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum rseq_cs_flags {
 RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT),
 RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT),
 RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE =
  (1U << RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT),
};






struct rseq_cs {

 __u32 version;

 __u32 flags;
 __u64 start_ip;

 __u64 post_commit_offset;
 __u64 abort_ip;
} __attribute__((aligned(4 * sizeof(__u64))));







struct rseq {
# 75 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 cpu_id_start;
# 90 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 cpu_id;
# 109 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 union {
  __u64 ptr64;

  __u64 ptr;
# 124 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 } rseq_cs;
# 144 "/home/nathan/src/linux-next/include/uapi/linux/rseq.h"
 __u32 flags;
} __attribute__((aligned(4 * sizeof(__u64))));
# 34 "/home/nathan/src/linux-next/include/linux/sched.h" 2


struct audit_context;
struct backing_dev_info;
struct bio_list;
struct blk_plug;
struct capture_control;
struct cfs_rq;
struct fs_struct;
struct futex_pi_state;
struct io_context;
struct mempolicy;
struct nameidata;
struct nsproxy;
struct perf_event_context;
struct pid_namespace;
struct pipe_inode_info;
struct rcu_node;
struct reclaim_state;
struct robust_list_head;
struct root_domain;
struct rq;
struct sched_attr;
struct sched_param;
struct seq_file;
struct sighand_struct;
struct signal_struct;
struct task_delay_info;
struct task_group;
# 215 "/home/nathan/src/linux-next/include/linux/sched.h"
extern void scheduler_tick(void);



extern long schedule_timeout(long timeout);
extern long schedule_timeout_interruptible(long timeout);
extern long schedule_timeout_killable(long timeout);
extern long schedule_timeout_uninterruptible(long timeout);
extern long schedule_timeout_idle(long timeout);
           void schedule(void);
extern void schedule_preempt_disabled(void);
           void preempt_schedule_irq(void);

extern int __attribute__((__warn_unused_result__)) io_schedule_prepare(void);
extern void io_schedule_finish(int token);
extern long io_schedule_timeout(long timeout);
extern void io_schedule(void);
# 242 "/home/nathan/src/linux-next/include/linux/sched.h"
struct prev_cputime {





};

enum vtime_state {

 VTIME_INACTIVE = 0,

 VTIME_IDLE,

 VTIME_SYS,

 VTIME_USER,

 VTIME_GUEST,
};

struct vtime {
 seqcount_t seqcount;
 unsigned long long starttime;
 enum vtime_state state;
 unsigned int cpu;
 u64 utime;
 u64 stime;
 u64 gtime;
};







enum uclamp_id {
 UCLAMP_MIN = 0,
 UCLAMP_MAX,
 UCLAMP_CNT
};


extern struct root_domain def_root_domain;
extern struct mutex sched_domains_mutex;


struct sched_info {




 unsigned long pcount;


 unsigned long long run_delay;




 unsigned long long last_arrival;


 unsigned long long last_queued;


};
# 325 "/home/nathan/src/linux-next/include/linux/sched.h"
struct load_weight {
 unsigned long weight;
 u32 inv_weight;
};
# 352 "/home/nathan/src/linux-next/include/linux/sched.h"
struct util_est {
 unsigned int enqueued;
 unsigned int ewma;

} __attribute__((__aligned__(sizeof(u64))));
# 401 "/home/nathan/src/linux-next/include/linux/sched.h"
struct sched_avg {
 u64 last_update_time;
 u64 load_sum;
 u64 runnable_load_sum;
 u32 util_sum;
 u32 period_contrib;
 unsigned long load_avg;
 unsigned long runnable_load_avg;
 unsigned long util_avg;
 struct util_est util_est;
} __attribute__((__aligned__((1 << 7))));

struct sched_statistics {
# 447 "/home/nathan/src/linux-next/include/linux/sched.h"
};

struct sched_entity {

 struct load_weight load;
 unsigned long runnable_weight;
 struct rb_node run_node;
 struct list_head group_node;
 unsigned int on_rq;

 u64 exec_start;
 u64 sum_exec_runtime;
 u64 vruntime;
 u64 prev_sum_exec_runtime;

 u64 nr_migrations;

 struct sched_statistics statistics;


 int depth;
 struct sched_entity *parent;

 struct cfs_rq *cfs_rq;

 struct cfs_rq *my_q;
# 482 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct sched_avg avg;

};

struct sched_rt_entity {
 struct list_head run_list;
 unsigned long timeout;
 unsigned long watchdog_stamp;
 unsigned int time_slice;
 unsigned short on_rq;
 unsigned short on_list;

 struct sched_rt_entity *back;







} ;

struct sched_dl_entity {
 struct rb_node rb_node;






 u64 dl_runtime;
 u64 dl_deadline;
 u64 dl_period;
 u64 dl_bw;
 u64 dl_density;






 s64 runtime;
 u64 deadline;
 unsigned int flags;
# 551 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned int dl_throttled : 1;
 unsigned int dl_boosted : 1;
 unsigned int dl_yielded : 1;
 unsigned int dl_non_contending : 1;
 unsigned int dl_overrun : 1;





 struct hrtimer dl_timer;
# 570 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct hrtimer inactive_timer;
};
# 608 "/home/nathan/src/linux-next/include/linux/sched.h"
union rcu_special {
 struct {
  u8 blocked;
  u8 need_qs;
  u8 exp_hint;
  u8 deferred_qs;
 } b;
 u32 s;
};

enum perf_event_task_context {
 perf_invalid_context = -1,
 perf_hw_context = 0,
 perf_sw_context,
 perf_nr_task_contexts,
};

struct wake_q_node {
 struct wake_q_node *next;
};

struct task_struct {





 struct thread_info thread_info;


 volatile long state;







 void *stack;
 refcount_t usage;

 unsigned int flags;
 unsigned int ptrace;


 struct llist_node wake_entry;
 int on_cpu;


 unsigned int cpu;

 unsigned int wakee_flips;
 unsigned long wakee_flip_decay_ts;
 struct task_struct *last_wakee;
# 670 "/home/nathan/src/linux-next/include/linux/sched.h"
 int recent_used_cpu;
 int wake_cpu;

 int on_rq;

 int prio;
 int static_prio;
 int normal_prio;
 unsigned int rt_priority;

 const struct sched_class *sched_class;
 struct sched_entity se;
 struct sched_rt_entity rt;

 struct task_group *sched_task_group;

 struct sched_dl_entity dl;
# 697 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct hlist_head preempt_notifiers;



 unsigned int btrace_seq;


 unsigned int policy;
 int nr_cpus_allowed;
 const cpumask_t *cpus_ptr;
 cpumask_t cpus_mask;
# 724 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct sched_info sched_info;

 struct list_head tasks;

 struct plist_node pushable_tasks;
 struct rb_node pushable_dl_tasks;


 struct mm_struct *mm;
 struct mm_struct *active_mm;


 struct vmacache vmacache;


 struct task_rss_stat rss_stat;

 int exit_state;
 int exit_code;
 int exit_signal;

 int pdeath_signal;

 unsigned long jobctl;


 unsigned int personality;


 unsigned sched_reset_on_fork:1;
 unsigned sched_contributes_to_load:1;
 unsigned sched_migrated:1;
 unsigned sched_remote_wakeup:1;





 unsigned :0;




 unsigned in_execve:1;
 unsigned in_iowait:1;

 unsigned restore_sigmask:1;


 unsigned in_user_fault:1;






 unsigned no_cgroup_migration:1;

 unsigned frozen:1;






 unsigned long atomic_flags;

 struct restart_block restart_block;

 pid_t pid;
 pid_t tgid;
# 807 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct task_struct *real_parent;


 struct task_struct *parent;




 struct list_head children;
 struct list_head sibling;
 struct task_struct *group_leader;







 struct list_head ptraced;
 struct list_head ptrace_entry;


 struct pid *thread_pid;
 struct hlist_node pid_links[PIDTYPE_MAX];
 struct list_head thread_group;
 struct list_head thread_node;

 struct completion *vfork_done;


 int *set_child_tid;


 int *clear_child_tid;

 u64 utime;
 u64 stime;

 u64 utimescaled;
 u64 stimescaled;

 u64 gtime;
 struct prev_cputime prev_cputime;
# 858 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned long nvcsw;
 unsigned long nivcsw;


 u64 start_time;


 u64 start_boottime;


 unsigned long min_flt;
 unsigned long maj_flt;


 struct posix_cputimers posix_cputimers;




 const struct cred *ptracer_cred;


 const struct cred *real_cred;


 const struct cred *cred;



 struct key *cached_requested_key;
# 897 "/home/nathan/src/linux-next/include/linux/sched.h"
 char comm[16];

 struct nameidata *nameidata;


 struct sysv_sem sysvsem;
 struct sysv_shm sysvshm;


 unsigned long last_switch_count;
 unsigned long last_switch_time;


 struct fs_struct *fs;


 struct files_struct *files;


 struct nsproxy *nsproxy;


 struct signal_struct *signal;
 struct sighand_struct *sighand;
 sigset_t blocked;
 sigset_t real_blocked;

 sigset_t saved_sigmask;
 struct sigpending pending;
 unsigned long sas_ss_sp;
 size_t sas_ss_size;
 unsigned int sas_ss_flags;

 struct callback_head *task_works;
# 939 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct seccomp seccomp;


 u32 parent_exec_id;
 u32 self_exec_id;


 spinlock_t alloc_lock;


 raw_spinlock_t pi_lock;

 struct wake_q_node wake_q;



 struct rb_root_cached pi_waiters;

 struct task_struct *pi_top_task;

 struct rt_mutex_waiter *pi_blocked_on;




 struct mutex_waiter *blocked_on;
# 1000 "/home/nathan/src/linux-next/include/linux/sched.h"
 void *journal_info;


 struct bio_list *bio_list;



 struct blk_plug *plug;



 struct reclaim_state *reclaim_state;

 struct backing_dev_info *backing_dev_info;

 struct io_context *io_context;


 struct capture_control *capture_control;


 unsigned long ptrace_message;
 kernel_siginfo_t *last_siginfo;

 struct task_io_accounting ioac;
# 1039 "/home/nathan/src/linux-next/include/linux/sched.h"
 nodemask_t mems_allowed;

 seqcount_t mems_allowed_seq;
 int cpuset_mem_spread_rotor;
 int cpuset_slab_spread_rotor;



 struct css_set *cgroups;

 struct list_head cg_list;






 struct robust_list_head *robust_list;

 struct compat_robust_list_head *compat_robust_list;

 struct list_head pi_state_list;
 struct futex_pi_state *pi_state_cache;
 struct mutex futex_exit_mutex;
 unsigned int futex_state;


 struct perf_event_context *perf_event_ctxp[perf_nr_task_contexts];
 struct mutex perf_event_mutex;
 struct list_head perf_event_list;






 struct mempolicy *mempolicy;
 short il_prev;
 short pref_node_fork;


 int numa_scan_seq;
 unsigned int numa_scan_period;
 unsigned int numa_scan_period_max;
 int numa_preferred_nid;
 unsigned long numa_migrate_retry;

 u64 node_stamp;
 u64 last_task_numa_placement;
 u64 last_sum_exec_runtime;
 struct callback_head numa_work;
# 1099 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct numa_group *numa_group;
# 1115 "/home/nathan/src/linux-next/include/linux/sched.h"
 unsigned long *numa_faults;
 unsigned long total_numa_faults;







 unsigned long numa_faults_locality[3];

 unsigned long numa_pages_migrated;



 struct rseq *rseq;
 u32 rseq_sig;




 unsigned long rseq_event_mask;


 struct tlbflush_unmap_batch tlb_ubc;

 union {
  refcount_t rcu_users;
  struct callback_head rcu;
 };


 struct pipe_inode_info *splice_pipe;

 struct page_frag task_frag;


 struct task_delay_info *delays;
# 1163 "/home/nathan/src/linux-next/include/linux/sched.h"
 int nr_dirtied;
 int nr_dirtied_pause;

 unsigned long dirty_paused_when;
# 1176 "/home/nathan/src/linux-next/include/linux/sched.h"
 u64 timer_slack_ns;
 u64 default_timer_slack_ns;







 int curr_ret_stack;
 int curr_ret_depth;


 struct ftrace_ret_stack *ret_stack;


 unsigned long long ftrace_timestamp;





 atomic_t trace_overrun;


 atomic_t tracing_graph_pause;




 unsigned long trace;


 unsigned long trace_recursion;
# 1235 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct mem_cgroup *memcg_in_oom;
 gfp_t memcg_oom_gfp_mask;
 int memcg_oom_order;


 unsigned int memcg_nr_pages_over_high;


 struct mem_cgroup *active_memcg;







 struct uprobe_task *utask;
# 1260 "/home/nathan/src/linux-next/include/linux/sched.h"
 int pagefault_disabled;

 struct task_struct *oom_reaper_list;






 refcount_t stack_refcount;
# 1291 "/home/nathan/src/linux-next/include/linux/sched.h"
 struct thread_struct thread;







};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_pid(struct task_struct *task)
{
 return task->thread_pid;
}
# 1317 "/home/nathan/src/linux-next/include/linux/sched.h"
pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type, struct pid_namespace *ns);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_nr(struct task_struct *tsk)
{
 return tsk->pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pid_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PID, ((void *)0));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_nr(struct task_struct *tsk)
{
 return tsk->tgid;
}
# 1350 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pid_alive(const struct task_struct *p)
{
 return p->thread_pid != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ((void *)0));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_session_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_SID, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ns);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_tgid_vnr(struct task_struct *tsk)
{
 return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_ppid_nr_ns(const struct task_struct *tsk, struct pid_namespace *ns)
{
 pid_t pid = 0;

 rcu_read_lock();
 if (pid_alive(tsk))
  pid = task_tgid_nr_ns(({ typeof(*(tsk->real_parent)) *________p1 = (typeof(*(tsk->real_parent)) *)({ union { typeof((tsk->real_parent)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tsk->real_parent)), __u.__c, sizeof((tsk->real_parent))); else __read_once_size_nocheck(&((tsk->real_parent)), __u.__c, sizeof((tsk->real_parent))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(tsk->real_parent)) *)(________p1)); }), ns);
 rcu_read_unlock();

 return pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_ppid_nr(const struct task_struct *tsk)
{
 return task_ppid_nr_ns(tsk, &init_pid_ns);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pid_t task_pgrp_nr(struct task_struct *tsk)
{
 return task_pgrp_nr_ns(tsk, &init_pid_ns);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int task_state_index(struct task_struct *tsk)
{
 unsigned int tsk_state = ({ union { typeof(tsk->state) __val; char __c[1]; } __u; if (1) __read_once_size(&(tsk->state), __u.__c, sizeof(tsk->state)); else __read_once_size_nocheck(&(tsk->state), __u.__c, sizeof(tsk->state)); do { } while (0); __u.__val; });
 unsigned int state = (tsk_state | tsk->exit_state) & (0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040);

 do { extern void __compiletime_assert_1417(void) ; if (!(!(((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) == 0 || ((((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) - 1)) != 0)))) __compiletime_assert_1417(); } while (0);

 if (tsk_state == (0x0002 | 0x0400))
  state = ((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1);

 return fls(state);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char task_index_to_char(unsigned int state)
{
 static const char state_char[] = "RSDTtXZPI";

 do { extern void __compiletime_assert_1429(void) ; if (!(!(1 + ( __builtin_constant_p((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ? ( __builtin_constant_p((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ? ( ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) < 2 ? 0 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 63) ? 63 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 62) ? 62 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 61) ? 61 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 60) ? 60 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 59) ? 59 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 58) ? 58 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 57) ? 57 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 56) ? 56 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 55) ? 55 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 54) ? 54 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 53) ? 53 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 52) ? 52 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 51) ? 51 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 50) ? 50 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 49) ? 49 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 48) ? 48 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 47) ? 47 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 46) ? 46 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 45) ? 45 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 44) ? 44 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 43) ? 43 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 42) ? 42 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 41) ? 41 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 40) ? 40 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 39) ? 39 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 38) ? 38 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 37) ? 37 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 36) ? 36 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 35) ? 35 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 34) ? 34 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 33) ? 33 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 32) ? 32 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 31) ? 31 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 30) ? 30 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 29) ? 29 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 28) ? 28 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 27) ? 27 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 26) ? 26 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 25) ? 25 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 24) ? 24 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 23) ? 23 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 22) ? 22 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 21) ? 21 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 20) ? 20 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 19) ? 19 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 18) ? 18 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 17) ? 17 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 16) ? 16 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 15) ? 15 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 14) ? 14 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 13) ? 13 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 12) ? 12 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 11) ? 11 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 10) ? 10 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 9) ? 9 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 8) ? 8 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 7) ? 7 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 6) ? 6 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 5) ? 5 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 4) ? 4 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 3) ? 3 : ((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) <= 4) ? __ilog2_u32((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) : __ilog2_u64((((0x0000 | 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040) + 1) << 1)) ) != sizeof(state_char) - 1))) __compiletime_assert_1429(); } while (0);

 return state_char[state];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char task_state_to_char(struct task_struct *tsk)
{
 return task_index_to_char(task_state_index(tsk));
}
# 1448 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_global_init(struct task_struct *tsk)
{
 return task_tgid_nr(tsk) == 1;
}

extern struct pid *cad_pid;
# 1517 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_percpu_thread(void)
{

 return (get_current()->flags & 0x04000000) &&
  (get_current()->nr_cpus_allowed == 1);



}
# 1549 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_no_new_privs(struct task_struct *p) { return test_bit(0, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_no_new_privs(struct task_struct *p) { set_bit(0, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spread_page(struct task_struct *p) { return test_bit(1, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spread_page(struct task_struct *p) { set_bit(1, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spread_page(struct task_struct *p) { clear_bit(1, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spread_slab(struct task_struct *p) { return test_bit(2, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spread_slab(struct task_struct *p) { set_bit(2, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spread_slab(struct task_struct *p) { clear_bit(2, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_disable(struct task_struct *p) { return test_bit(3, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_disable(struct task_struct *p) { set_bit(3, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ssb_disable(struct task_struct *p) { clear_bit(3, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_noexec(struct task_struct *p) { return test_bit(7, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_noexec(struct task_struct *p) { set_bit(7, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ssb_noexec(struct task_struct *p) { clear_bit(7, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ssb_force_disable(struct task_struct *p) { return test_bit(4, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ssb_force_disable(struct task_struct *p) { set_bit(4, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ib_disable(struct task_struct *p) { return test_bit(5, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ib_disable(struct task_struct *p) { set_bit(5, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_clear_spec_ib_disable(struct task_struct *p) { clear_bit(5, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_spec_ib_force_disable(struct task_struct *p) { return test_bit(6, &p->atomic_flags); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_set_spec_ib_force_disable(struct task_struct *p) { set_bit(6, &p->atomic_flags); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
current_restore_flags(unsigned long orig_flags, unsigned long flags)
{
 get_current()->flags &= ~flags;
 get_current()->flags |= orig_flags & flags;
}

extern int cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);
extern int task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed);

extern void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask);
extern int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask);
# 1602 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int yield_to(struct task_struct *p, bool preempt);
extern void set_user_nice(struct task_struct *p, long nice);
extern int task_prio(const struct task_struct *p);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice(const struct task_struct *p)
{
 return (((p)->static_prio) - (100 + (19 - -20 + 1) / 2));
}

extern int can_nice(const struct task_struct *p, const int nice);
extern int task_curr(const struct task_struct *p);
extern int idle_cpu(int cpu);
extern int available_idle_cpu(int cpu);
extern int sched_setscheduler(struct task_struct *, int, const struct sched_param *);
extern int sched_setscheduler_nocheck(struct task_struct *, int, const struct sched_param *);
extern int sched_setattr(struct task_struct *, const struct sched_attr *);
extern int sched_setattr_nocheck(struct task_struct *, const struct sched_attr *);
extern struct task_struct *idle_task(int cpu);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_idle_task(const struct task_struct *p)
{
 return !!(p->flags & 0x00000002);
}

extern struct task_struct *curr_task(int cpu);
extern void ia64_set_curr_task(int cpu, struct task_struct *p);

void yield(void);

union thread_union {

 struct task_struct task;




 unsigned long stack[(1 << 14)/sizeof(long)];
};





extern unsigned long init_stack[(1 << 14) / sizeof(unsigned long)];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct thread_info *task_thread_info(struct task_struct *task)
{
 return &task->thread_info;
}
# 1679 "/home/nathan/src/linux-next/include/linux/sched.h"
extern struct task_struct *find_task_by_vpid(pid_t nr);
extern struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns);




extern struct task_struct *find_get_task_by_vpid(pid_t nr);

extern int wake_up_state(struct task_struct *tsk, unsigned int state);
extern int wake_up_process(struct task_struct *tsk);
extern void wake_up_new_task(struct task_struct *tsk);


extern void kick_process(struct task_struct *tsk);




extern void __set_task_comm(struct task_struct *tsk, const char *from, bool exec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_task_comm(struct task_struct *tsk, const char *from)
{
 __set_task_comm(tsk, from, false);
}

extern char *__get_task_comm(char *to, size_t len, struct task_struct *tsk);






void scheduler_ipi(void);
extern unsigned long wait_task_inactive(struct task_struct *, long match_state);
# 1725 "/home/nathan/src/linux-next/include/linux/sched.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 set_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 clear_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_tsk_thread_flag(struct task_struct *tsk, int flag,
       bool value)
{
 update_ti_thread_flag(task_thread_info(tsk), flag, value);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_and_set_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_and_clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_and_clear_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
 return test_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_tsk_need_resched(struct task_struct *tsk)
{
 set_tsk_thread_flag(tsk,2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_need_resched(struct task_struct *tsk)
{
 clear_tsk_thread_flag(tsk,2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int test_tsk_need_resched(struct task_struct *tsk)
{
 return __builtin_expect(!!(test_tsk_thread_flag(tsk,2)), 0);
}
# 1778 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int _cond_resched(void);
# 1788 "/home/nathan/src/linux-next/include/linux/sched.h"
extern int __cond_resched_lock(spinlock_t *lock);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cond_resched_rcu(void)
{

 rcu_read_unlock();
 ({ ___might_sleep("include/linux/sched.h", 1799, 0); _cond_resched(); });
 rcu_read_lock();

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int spin_needbreak(spinlock_t *lock)
{



 return 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool need_resched(void)
{
 return __builtin_expect(!!(test_ti_thread_flag(((struct thread_info *)get_current()), 2)), 0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int task_cpu(const struct task_struct *p)
{

 return ({ union { typeof(p->cpu) __val; char __c[1]; } __u; if (1) __read_once_size(&(p->cpu), __u.__c, sizeof(p->cpu)); else __read_once_size_nocheck(&(p->cpu), __u.__c, sizeof(p->cpu)); do { } while (0); __u.__val; });



}

extern void set_task_cpu(struct task_struct *p, unsigned int cpu);
# 1867 "/home/nathan/src/linux-next/include/linux/sched.h"
extern long sched_setaffinity(pid_t pid, const struct cpumask *new_mask);
extern long sched_getaffinity(pid_t pid, struct cpumask *mask);
# 1880 "/home/nathan/src/linux-next/include/linux/sched.h"
enum rseq_event_mask_bits {
 RSEQ_EVENT_PREEMPT_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT,
 RSEQ_EVENT_SIGNAL_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT,
 RSEQ_EVENT_MIGRATE_BIT = RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT,
};

enum rseq_event_mask {
 RSEQ_EVENT_PREEMPT = (1U << RSEQ_EVENT_PREEMPT_BIT),
 RSEQ_EVENT_SIGNAL = (1U << RSEQ_EVENT_SIGNAL_BIT),
 RSEQ_EVENT_MIGRATE = (1U << RSEQ_EVENT_MIGRATE_BIT),
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_set_notify_resume(struct task_struct *t)
{
 if (t->rseq)
  set_tsk_thread_flag(t, 13);
}

void __rseq_handle_notify_resume(struct ksignal *sig, struct pt_regs *regs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_handle_notify_resume(struct ksignal *ksig,
          struct pt_regs *regs)
{
 if (get_current()->rseq)
  __rseq_handle_notify_resume(ksig, regs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_signal_deliver(struct ksignal *ksig,
           struct pt_regs *regs)
{
 __asm__ __volatile__("" : : : "memory");
 __set_bit(RSEQ_EVENT_SIGNAL_BIT, &get_current()->rseq_event_mask);
 __asm__ __volatile__("" : : : "memory");
 rseq_handle_notify_resume(ksig, regs);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_preempt(struct task_struct *t)
{
 __set_bit(RSEQ_EVENT_PREEMPT_BIT, &t->rseq_event_mask);
 rseq_set_notify_resume(t);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_migrate(struct task_struct *t)
{
 __set_bit(RSEQ_EVENT_MIGRATE_BIT, &t->rseq_event_mask);
 rseq_set_notify_resume(t);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_fork(struct task_struct *t, unsigned long clone_flags)
{
 if (clone_flags & 0x00000100) {
  t->rseq = ((void *)0);
  t->rseq_sig = 0;
  t->rseq_event_mask = 0;
 } else {
  t->rseq = get_current()->rseq;
  t->rseq_sig = get_current()->rseq_sig;
  t->rseq_event_mask = get_current()->rseq_event_mask;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_execve(struct task_struct *t)
{
 t->rseq = ((void *)0);
 t->rseq_sig = 0;
 t->rseq_event_mask = 0;
}
# 1982 "/home/nathan/src/linux-next/include/linux/sched.h"
void __exit_umh(struct task_struct *tsk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_umh(struct task_struct *tsk)
{
 if (__builtin_expect(!!(tsk->flags & 0x02000000), 0))
  __exit_umh(tsk);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rseq_syscall(struct pt_regs *regs)
{
}



const struct sched_avg *sched_trace_cfs_rq_avg(struct cfs_rq *cfs_rq);
char *sched_trace_cfs_rq_path(struct cfs_rq *cfs_rq, char *str, int len);
int sched_trace_cfs_rq_cpu(struct cfs_rq *cfs_rq);

const struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq);
const struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq);
const struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq);

int sched_trace_rq_cpu(struct rq *rq);

const struct cpumask *sched_trace_rd_span(struct root_domain *rd);
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h" 1
# 102 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h"
typedef unsigned long elf_greg_t64;
typedef elf_greg_t64 elf_gregset_t64[48];

typedef unsigned int elf_greg_t32;
typedef elf_greg_t32 elf_gregset_t32[48];
typedef elf_gregset_t32 compat_elf_gregset_t;
# 119 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h"
typedef elf_greg_t64 elf_greg_t;
typedef elf_gregset_t64 elf_gregset_t;
# 138 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h"
typedef double elf_fpreg_t;
typedef elf_fpreg_t elf_fpregset_t[33];
# 160 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h"
typedef __vector128 elf_vrreg_t;
typedef elf_vrreg_t elf_vrregset_t[34];

typedef elf_vrreg_t elf_vrregset_t32[33];
typedef elf_fpreg_t elf_vsrreghalf_t32[32];
# 293 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/elf.h"
struct ppc64_opd_entry
{
 unsigned long funcaddr;
 unsigned long r2;
};
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h" 2
# 49 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ppc_elf_core_copy_regs(elf_gregset_t elf_regs,
       struct pt_regs *regs)
{
 int i, nregs = __builtin_choose_expr(((!!(sizeof((typeof(sizeof(*regs) / sizeof(unsigned long)) *)1 == (typeof((size_t)48) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(sizeof(*regs) / sizeof(unsigned long)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((size_t)48) * 0l)) : (int *)8))))), ((sizeof(*regs) / sizeof(unsigned long)) < ((size_t)48) ? (sizeof(*regs) / sizeof(unsigned long)) : ((size_t)48)), ({ typeof(sizeof(*regs) / sizeof(unsigned long)) __UNIQUE_ID___x10 = (sizeof(*regs) / sizeof(unsigned long)); typeof((size_t)48) __UNIQUE_ID___y11 = ((size_t)48); ((__UNIQUE_ID___x10) < (__UNIQUE_ID___y11) ? (__UNIQUE_ID___x10) : (__UNIQUE_ID___y11)); })); for (i = 0; i < nregs; i++) elf_regs[i] = ((unsigned long *) regs)[i]; memset(&elf_regs[i], 0, (48 - i) * sizeof(elf_regs[0]));
}


typedef elf_vrregset_t elf_fpxregset_t;
# 112 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h"
extern int dcache_bsize;
extern int icache_bsize;
extern int ucache_bsize;



struct linux_binprm;
extern int arch_setup_additional_pages(struct linux_binprm *bprm,
           int uses_interp);
# 179 "/home/nathan/src/linux-next/arch/powerpc/include/asm/elf.h"
void relocate(unsigned long final_address);
# 6 "/home/nathan/src/linux-next/include/linux/elf.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/elf.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/elf-em.h" 1
# 7 "/home/nathan/src/linux-next/include/uapi/linux/elf.h" 2


typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;


typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
# 138 "/home/nathan/src/linux-next/include/uapi/linux/elf.h"
typedef struct dynamic{
  Elf32_Sword d_tag;
  union{
    Elf32_Sword d_val;
    Elf32_Addr d_ptr;
  } d_un;
} Elf32_Dyn;

typedef struct {
  Elf64_Sxword d_tag;
  union {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
} Elf64_Dyn;
# 161 "/home/nathan/src/linux-next/include/uapi/linux/elf.h"
typedef struct elf32_rel {
  Elf32_Addr r_offset;
  Elf32_Word r_info;
} Elf32_Rel;

typedef struct elf64_rel {
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
} Elf64_Rel;

typedef struct elf32_rela{
  Elf32_Addr r_offset;
  Elf32_Word r_info;
  Elf32_Sword r_addend;
} Elf32_Rela;

typedef struct elf64_rela {
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
  Elf64_Sxword r_addend;
} Elf64_Rela;

typedef struct elf32_sym{
  Elf32_Word st_name;
  Elf32_Addr st_value;
  Elf32_Word st_size;
  unsigned char st_info;
  unsigned char st_other;
  Elf32_Half st_shndx;
} Elf32_Sym;

typedef struct elf64_sym {
  Elf64_Word st_name;
  unsigned char st_info;
  unsigned char st_other;
  Elf64_Half st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
} Elf64_Sym;




typedef struct elf32_hdr{
  unsigned char e_ident[16];
  Elf32_Half e_type;
  Elf32_Half e_machine;
  Elf32_Word e_version;
  Elf32_Addr e_entry;
  Elf32_Off e_phoff;
  Elf32_Off e_shoff;
  Elf32_Word e_flags;
  Elf32_Half e_ehsize;
  Elf32_Half e_phentsize;
  Elf32_Half e_phnum;
  Elf32_Half e_shentsize;
  Elf32_Half e_shnum;
  Elf32_Half e_shstrndx;
} Elf32_Ehdr;

typedef struct elf64_hdr {
  unsigned char e_ident[16];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
} Elf64_Ehdr;







typedef struct elf32_phdr{
  Elf32_Word p_type;
  Elf32_Off p_offset;
  Elf32_Addr p_vaddr;
  Elf32_Addr p_paddr;
  Elf32_Word p_filesz;
  Elf32_Word p_memsz;
  Elf32_Word p_flags;
  Elf32_Word p_align;
} Elf32_Phdr;

typedef struct elf64_phdr {
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
} Elf64_Phdr;
# 303 "/home/nathan/src/linux-next/include/uapi/linux/elf.h"
typedef struct elf32_shdr {
  Elf32_Word sh_name;
  Elf32_Word sh_type;
  Elf32_Word sh_flags;
  Elf32_Addr sh_addr;
  Elf32_Off sh_offset;
  Elf32_Word sh_size;
  Elf32_Word sh_link;
  Elf32_Word sh_info;
  Elf32_Word sh_addralign;
  Elf32_Word sh_entsize;
} Elf32_Shdr;

typedef struct elf64_shdr {
  Elf64_Word sh_name;
  Elf64_Word sh_type;
  Elf64_Xword sh_flags;
  Elf64_Addr sh_addr;
  Elf64_Off sh_offset;
  Elf64_Xword sh_size;
  Elf64_Word sh_link;
  Elf64_Word sh_info;
  Elf64_Xword sh_addralign;
  Elf64_Xword sh_entsize;
} Elf64_Shdr;
# 433 "/home/nathan/src/linux-next/include/uapi/linux/elf.h"
typedef struct elf32_note {
  Elf32_Word n_namesz;
  Elf32_Word n_descsz;
  Elf32_Word n_type;
} Elf32_Nhdr;


typedef struct elf64_note {
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
} Elf64_Nhdr;
# 7 "/home/nathan/src/linux-next/include/linux/elf.h" 2
# 37 "/home/nathan/src/linux-next/include/linux/elf.h"
extern Elf64_Dyn _DYNAMIC [];
# 49 "/home/nathan/src/linux-next/include/linux/elf.h"
struct file;
struct coredump_params;





extern int elf_coredump_extra_notes_size(void);
extern int elf_coredump_extra_notes_write(struct coredump_params *cprm);
# 19 "/home/nathan/src/linux-next/include/linux/module.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/kobject.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/kobject.h"
# 1 "/home/nathan/src/linux-next/include/linux/sysfs.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/sysfs.h"
# 1 "/home/nathan/src/linux-next/include/linux/kernfs.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/kernfs.h"
# 1 "/home/nathan/src/linux-next/include/linux/idr.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/idr.h"
# 1 "/home/nathan/src/linux-next/include/linux/radix-tree.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
# 1 "/home/nathan/src/linux-next/include/linux/xarray.h" 1
# 52 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_value(unsigned long v)
{
 ({ int __ret_warn_on = !!((long)v < 0); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/xarray.h"), "i" (54), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/xarray.h"), "i" (54), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 return (void *)((v << 1) | 1);
}
# 65 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_value(const void *entry)
{
 return (unsigned long)entry >> 1;
}
# 77 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_value(const void *entry)
{
 return (unsigned long)entry & 1;
}
# 95 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_tag_pointer(void *p, unsigned long tag)
{
 return (void *)((unsigned long)p | tag);
}
# 110 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_untag_pointer(void *entry)
{
 return (void *)((unsigned long)entry & ~3UL);
}
# 125 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int xa_pointer_tag(void *entry)
{
 return (unsigned long)entry & 3UL;
}
# 143 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_internal(unsigned long v)
{
 return (void *)((v << 2) | 2);
}
# 155 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_internal(const void *entry)
{
 return (unsigned long)entry >> 2;
}
# 167 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_internal(const void *entry)
{
 return ((unsigned long)entry & 3) == 2;
}
# 183 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_zero(const void *entry)
{
 return __builtin_expect(!!(entry == xa_mk_internal(257)), 0);
}
# 199 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_err(const void *entry)
{
 return __builtin_expect(!!(xa_is_internal(entry) && entry >= xa_mk_internal(-4095)), 0);

}
# 217 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_err(void *entry)
{

 if (xa_is_err(entry))
  return (long)entry >> 2;
 return 0;
}
# 236 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_limit {
 u32 max;
 u32 min;
};






typedef unsigned xa_mark_t;







enum xa_lock_type {
 XA_LOCK_IRQ = 1,
 XA_LOCK_BH = 2,
};
# 292 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xarray {
 spinlock_t xa_lock;

 gfp_t xa_flags;
 void * xa_head;
};
# 347 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *xa_load(struct xarray *, unsigned long index);
void *xa_store(struct xarray *, unsigned long index, void *entry, gfp_t);
void *xa_erase(struct xarray *, unsigned long index);
void *xa_store_range(struct xarray *, unsigned long first, unsigned long last,
   void *entry, gfp_t);
bool xa_get_mark(struct xarray *, unsigned long index, xa_mark_t);
void xa_set_mark(struct xarray *, unsigned long index, xa_mark_t);
void xa_clear_mark(struct xarray *, unsigned long index, xa_mark_t);
void *xa_find(struct xarray *xa, unsigned long *index,
  unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
void *xa_find_after(struct xarray *xa, unsigned long *index,
  unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
unsigned int xa_extract(struct xarray *, void **dst, unsigned long start,
  unsigned long max, unsigned int n, xa_mark_t);
void xa_destroy(struct xarray *);
# 374 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_init_flags(struct xarray *xa, gfp_t flags)
{
 do { spinlock_check(&xa->xa_lock); do { *(&(&xa->xa_lock)->rlock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0); } while (0);
 xa->xa_flags = flags;
 xa->xa_head = ((void *)0);
}
# 389 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_init(struct xarray *xa)
{
 xa_init_flags(xa, 0);
}
# 401 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_empty(const struct xarray *xa)
{
 return xa->xa_head == ((void *)0);
}
# 414 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_marked(const struct xarray *xa, xa_mark_t mark)
{
 return xa->xa_flags & (( gfp_t)((1U << (23 + 0)) << ( unsigned)(mark)));
}
# 554 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *__xa_erase(struct xarray *, unsigned long index);
void *__xa_store(struct xarray *, unsigned long index, void *entry, gfp_t);
void *__xa_cmpxchg(struct xarray *, unsigned long index, void *old,
  void *entry, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_insert(struct xarray *, unsigned long index,
  void *entry, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_alloc(struct xarray *, u32 *id, void *entry,
  struct xa_limit, gfp_t);
int __attribute__((__warn_unused_result__)) __xa_alloc_cyclic(struct xarray *, u32 *id, void *entry,
  struct xa_limit, u32 *next, gfp_t);
void __xa_set_mark(struct xarray *, unsigned long index, xa_mark_t);
void __xa_clear_mark(struct xarray *, unsigned long index, xa_mark_t);
# 581 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_store_bh(struct xarray *xa, unsigned long index,
  void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_bh(&(xa)->xa_lock);
 curr = __xa_store(xa, index, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return curr;
}
# 607 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_store_irq(struct xarray *xa, unsigned long index,
  void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_irq(&(xa)->xa_lock);
 curr = __xa_store(xa, index, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return curr;
}
# 632 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_erase_bh(struct xarray *xa, unsigned long index)
{
 void *entry;

 spin_lock_bh(&(xa)->xa_lock);
 entry = __xa_erase(xa, index);
 spin_unlock_bh(&(xa)->xa_lock);

 return entry;
}
# 656 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_erase_irq(struct xarray *xa, unsigned long index)
{
 void *entry;

 spin_lock_irq(&(xa)->xa_lock);
 entry = __xa_erase(xa, index);
 spin_unlock_irq(&(xa)->xa_lock);

 return entry;
}
# 682 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock(&(xa)->xa_lock);

 return curr;
}
# 709 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg_bh(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_bh(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return curr;
}
# 736 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_cmpxchg_irq(struct xarray *xa, unsigned long index,
   void *old, void *entry, gfp_t gfp)
{
 void *curr;

 spin_lock_irq(&(xa)->xa_lock);
 curr = __xa_cmpxchg(xa, index, old, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return curr;
}
# 765 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 794 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert_bh(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 823 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_insert_irq(struct xarray *xa,
  unsigned long index, void *entry, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_insert(xa, index, entry, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 852 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) int xa_alloc(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 881 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_alloc_bh(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 910 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) xa_alloc_irq(struct xarray *xa, u32 *id,
  void *entry, struct xa_limit limit, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_alloc(xa, id, entry, limit, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 943 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock(&(xa)->xa_lock);

 return err;
}
# 976 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic_bh(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock_bh(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock_bh(&(xa)->xa_lock);

 return err;
}
# 1009 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xa_alloc_cyclic_irq(struct xarray *xa, u32 *id, void *entry,
  struct xa_limit limit, u32 *next, gfp_t gfp)
{
 int err;

 spin_lock_irq(&(xa)->xa_lock);
 err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
 spin_unlock_irq(&(xa)->xa_lock);

 return err;
}
# 1039 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1057 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve_bh(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg_bh(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1075 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
int xa_reserve_irq(struct xarray *xa, unsigned long index, gfp_t gfp)
{
 return xa_err(xa_cmpxchg_irq(xa, index, ((void *)0), xa_mk_internal(257), gfp));
}
# 1090 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xa_release(struct xarray *xa, unsigned long index)
{
 xa_cmpxchg(xa, index, xa_mk_internal(257), ((void *)0), 0);
}
# 1122 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_node {
 unsigned char shift;
 unsigned char offset;
 unsigned char count;
 unsigned char nr_values;
 struct xa_node *parent;
 struct xarray *array;
 union {
  struct list_head private_list;
  struct callback_head callback_head;
 };
 void *slots[(1UL << (0 ? 4 : 6))];
 union {
  unsigned long tags[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
  unsigned long marks[3][((((1UL << (0 ? 4 : 6))) + (64) - 1) / (64))];
 };
};

void xa_dump(const struct xarray *);
void xa_dump_node(const struct xa_node *);
# 1162 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_head(const struct xarray *xa)
{
 return ({ typeof(*(xa->xa_head)) *________p1 = (typeof(*(xa->xa_head)) *)({ union { typeof((xa->xa_head)) __val; char __c[1]; } __u; if (1) __read_once_size(&((xa->xa_head)), __u.__c, sizeof((xa->xa_head))); else __read_once_size_nocheck(&((xa->xa_head)), __u.__c, sizeof((xa->xa_head))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(xa->xa_head)) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_head_locked(const struct xarray *xa)
{
 return ({ do { } while (0); ; ((typeof(*(xa->xa_head)) *)((xa->xa_head))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_entry(const struct xarray *xa,
    const struct xa_node *node, unsigned int offset)
{
 do { } while (0);
 return ({ typeof(*(node->slots[offset])) *________p1 = (typeof(*(node->slots[offset])) *)({ union { typeof((node->slots[offset])) __val; char __c[1]; } __u; if (1) __read_once_size(&((node->slots[offset])), __u.__c, sizeof((node->slots[offset]))); else __read_once_size_nocheck(&((node->slots[offset])), __u.__c, sizeof((node->slots[offset]))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(node->slots[offset])) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_entry_locked(const struct xarray *xa,
    const struct xa_node *node, unsigned int offset)
{
 do { } while (0);
 return ({ do { } while (0); ; ((typeof(*(node->slots[offset])) *)((node->slots[offset]))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_parent(const struct xarray *xa,
     const struct xa_node *node)
{
 return ({ typeof(*(node->parent)) *________p1 = (typeof(*(node->parent)) *)({ union { typeof((node->parent)) __val; char __c[1]; } __u; if (1) __read_once_size(&((node->parent)), __u.__c, sizeof((node->parent))); else __read_once_size_nocheck(&((node->parent)), __u.__c, sizeof((node->parent))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(node->parent)) *)(________p1)); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_parent_locked(const struct xarray *xa,
     const struct xa_node *node)
{
 return ({ do { } while (0); ; ((typeof(*(node->parent)) *)((node->parent))); });

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_node(const struct xa_node *node)
{
 return (void *)((unsigned long)node | 2);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xa_node *xa_to_node(const void *entry)
{
 return (struct xa_node *)((unsigned long)entry - 2);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_node(const void *entry)
{
 return xa_is_internal(entry) && (unsigned long)entry > 4096;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xa_mk_sibling(unsigned int offset)
{
 return xa_mk_internal(offset);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long xa_to_sibling(const void *entry)
{
 return xa_to_internal(entry);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_sibling(const void *entry)
{
 return 1 && xa_is_internal(entry) &&
  (entry < xa_mk_sibling((1UL << (0 ? 4 : 6)) - 1));
}
# 1259 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_retry(const void *entry)
{
 return __builtin_expect(!!(entry == xa_mk_internal(256)), 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xa_is_advanced(const void *entry)
{
 return xa_is_internal(entry) && (entry <= xa_mk_internal(256));
}
# 1287 "/home/nathan/src/linux-next/include/linux/xarray.h"
typedef void (*xa_update_node_t)(struct xa_node *node);
# 1306 "/home/nathan/src/linux-next/include/linux/xarray.h"
struct xa_state {
 struct xarray *xa;
 unsigned long xa_index;
 unsigned char xa_shift;
 unsigned char xa_sibs;
 unsigned char xa_offset;
 unsigned char xa_pad;
 struct xa_node *xa_node;
 struct xa_node *xa_alloc;
 xa_update_node_t xa_update;
};
# 1385 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xas_error(const struct xa_state *xas)
{
 return xa_err(xas->xa_node);
}
# 1399 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_err(struct xa_state *xas, long err)
{
 xas->xa_node = ((struct xa_node *)(((unsigned long)err << 2) | 2UL));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_invalid(const struct xa_state *xas)
{
 return (unsigned long)xas->xa_node & 3;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_valid(const struct xa_state *xas)
{
 return !xas_invalid(xas);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_is_node(const struct xa_state *xas)
{
 return xas_valid(xas) && xas->xa_node;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_not_node(struct xa_node *node)
{
 return ((unsigned long)node & 3) || !node;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_frozen(struct xa_node *node)
{
 return (unsigned long)node & 2;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_top(struct xa_node *node)
{
 return node <= ((struct xa_node *)3UL);
}
# 1465 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_reset(struct xa_state *xas)
{
 xas->xa_node = ((struct xa_node *)3UL);
}
# 1482 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xas_retry(struct xa_state *xas, const void *entry)
{
 if (xa_is_zero(entry))
  return true;
 if (!xa_is_retry(entry))
  return false;
 xas_reset(xas);
 return true;
}

void *xas_load(struct xa_state *);
void *xas_store(struct xa_state *, void *entry);
void *xas_find(struct xa_state *, unsigned long max);
void *xas_find_conflict(struct xa_state *);

bool xas_get_mark(const struct xa_state *, xa_mark_t);
void xas_set_mark(const struct xa_state *, xa_mark_t);
void xas_clear_mark(const struct xa_state *, xa_mark_t);
void *xas_find_marked(struct xa_state *, unsigned long max, xa_mark_t);
void xas_init_marks(const struct xa_state *);

bool xas_nomem(struct xa_state *, gfp_t);
void xas_pause(struct xa_state *);

void xas_create_range(struct xa_state *);
# 1522 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_reload(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (node)
  return xa_entry(xas->xa, node, xas->xa_offset);
 return xa_head(xas->xa);
}
# 1540 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set(struct xa_state *xas, unsigned long index)
{
 xas->xa_index = index;
 xas->xa_node = ((struct xa_node *)3UL);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_order(struct xa_state *xas, unsigned long index,
     unsigned int order)
{

 xas->xa_index = order < 64 ? (index >> order) << order : 0;
 xas->xa_shift = order - (order % (0 ? 4 : 6));
 xas->xa_sibs = (1 << (order % (0 ? 4 : 6))) - 1;
 xas->xa_node = ((struct xa_node *)3UL);




}
# 1574 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xas_set_update(struct xa_state *xas, xa_update_node_t update)
{
 xas->xa_update = update;
}
# 1590 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next_entry(struct xa_state *xas, unsigned long max)
{
 struct xa_node *node = xas->xa_node;
 void *entry;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset != (xas->xa_index & ((1UL << (0 ? 4 : 6)) - 1))), 0))

  return xas_find(xas, max);

 do {
  if (__builtin_expect(!!(xas->xa_index >= max), 0))
   return xas_find(xas, max);
  if (__builtin_expect(!!(xas->xa_offset == ((1UL << (0 ? 4 : 6)) - 1)), 0))
   return xas_find(xas, max);
  entry = xa_entry(xas->xa, node, xas->xa_offset + 1);
  if (__builtin_expect(!!(xa_is_internal(entry)), 0))
   return xas_find(xas, max);
  xas->xa_offset++;
  xas->xa_index++;
 } while (!entry);

 return entry;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int xas_find_chunk(struct xa_state *xas, bool advance,
  xa_mark_t mark)
{
 unsigned long *addr = xas->xa_node->marks[( unsigned)mark];
 unsigned int offset = xas->xa_offset;

 if (advance)
  offset++;
 if ((1UL << (0 ? 4 : 6)) == 64) {
  if (offset < (1UL << (0 ? 4 : 6))) {
   unsigned long data = *addr & (~0UL << offset);
   if (data)
    return __ffs(data);
  }
  return (1UL << (0 ? 4 : 6));
 }

 return find_next_bit(addr, (1UL << (0 ? 4 : 6)), offset);
}
# 1647 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next_marked(struct xa_state *xas, unsigned long max,
        xa_mark_t mark)
{
 struct xa_node *node = xas->xa_node;
 unsigned int offset;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift), 0))
  return xas_find_marked(xas, max, mark);
 offset = xas_find_chunk(xas, true, mark);
 xas->xa_offset = offset;
 xas->xa_index = (xas->xa_index & ~((1UL << (0 ? 4 : 6)) - 1)) + offset;
 if (xas->xa_index > max)
  return ((void *)0);
 if (offset == (1UL << (0 ? 4 : 6)))
  return xas_find_marked(xas, max, mark);
 return xa_entry(xas->xa, node, offset);
}





enum {
 XA_CHECK_SCHED = 4096,
};
# 1724 "/home/nathan/src/linux-next/include/linux/xarray.h"
void *__xas_next(struct xa_state *);
void *__xas_prev(struct xa_state *);
# 1743 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_prev(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset == 0), 0))

  return __xas_prev(xas);

 xas->xa_index--;
 xas->xa_offset--;
 return xa_entry(xas->xa, node, xas->xa_offset);
}
# 1772 "/home/nathan/src/linux-next/include/linux/xarray.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *xas_next(struct xa_state *xas)
{
 struct xa_node *node = xas->xa_node;

 if (__builtin_expect(!!(xas_not_node(node) || node->shift || xas->xa_offset == ((1UL << (0 ? 4 : 6)) - 1)), 0))

  return __xas_next(xas);

 xas->xa_index++;
 xas->xa_offset++;
 return xa_entry(xas->xa, node, xas->xa_offset);
}
# 19 "/home/nathan/src/linux-next/include/linux/radix-tree.h" 2
# 43 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_tree_is_internal_node(void *ptr)
{
 return ((unsigned long)ptr & 3UL) ==
    2UL;
}
# 74 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool radix_tree_empty(const struct xarray *root)
{
 return root->xa_head == ((void *)0);
}
# 94 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
struct radix_tree_iter {
 unsigned long index;
 unsigned long next_index;
 unsigned long tags;
 struct xa_node *node;
};
# 165 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *radix_tree_deref_slot(void **slot)
{
 return ({ typeof(*(*slot)) *________p1 = (typeof(*(*slot)) *)({ union { typeof((*slot)) __val; char __c[1]; } __u; if (1) __read_once_size(&((*slot)), __u.__c, sizeof((*slot))); else __read_once_size_nocheck(&((*slot)), __u.__c, sizeof((*slot))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(*slot)) *)(________p1)); });
}
# 179 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *radix_tree_deref_slot_protected(void **slot,
       spinlock_t *treelock)
{
 return ({ do { } while (0); ; ((typeof(*(*slot)) *)((*slot))); });
}
# 192 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix_tree_deref_retry(void *arg)
{
 return __builtin_expect(!!(radix_tree_is_internal_node(arg)), 0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int radix_tree_exception(void *arg)
{
 return __builtin_expect(!!((unsigned long)arg & 3UL), 0);
}

int radix_tree_insert(struct xarray *, unsigned long index,
   void *);
void *__radix_tree_lookup(const struct xarray *, unsigned long index,
     struct xa_node **nodep, void ***slotp);
void *radix_tree_lookup(const struct xarray *, unsigned long);
void **radix_tree_lookup_slot(const struct xarray *,
     unsigned long index);
void __radix_tree_replace(struct xarray *, struct xa_node *,
     void **slot, void *entry);
void radix_tree_iter_replace(struct xarray *,
  const struct radix_tree_iter *, void **slot, void *entry);
void radix_tree_replace_slot(struct xarray *,
        void **slot, void *entry);
void radix_tree_iter_delete(struct xarray *,
   struct radix_tree_iter *iter, void **slot);
void *radix_tree_delete_item(struct xarray *, unsigned long, void *);
void *radix_tree_delete(struct xarray *, unsigned long);
unsigned int radix_tree_gang_lookup(const struct xarray *,
   void **results, unsigned long first_index,
   unsigned int max_items);
int radix_tree_preload(gfp_t gfp_mask);
int radix_tree_maybe_preload(gfp_t gfp_mask);
void radix_tree_init(void);
void *radix_tree_tag_set(struct xarray *,
   unsigned long index, unsigned int tag);
void *radix_tree_tag_clear(struct xarray *,
   unsigned long index, unsigned int tag);
int radix_tree_tag_get(const struct xarray *,
   unsigned long index, unsigned int tag);
void radix_tree_iter_tag_clear(struct xarray *,
  const struct radix_tree_iter *iter, unsigned int tag);
unsigned int radix_tree_gang_lookup_tag(const struct xarray *,
  void **results, unsigned long first_index,
  unsigned int max_items, unsigned int tag);
unsigned int radix_tree_gang_lookup_tag_slot(const struct xarray *,
  void ***results, unsigned long first_index,
  unsigned int max_items, unsigned int tag);
int radix_tree_tagged(const struct xarray *, unsigned int tag);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void radix_tree_preload_end(void)
{
 __asm__ __volatile__("" : : : "memory");
}

void **idr_get_free(struct xarray *root,
         struct radix_tree_iter *iter, gfp_t gfp,
         unsigned long max);

enum {
 RADIX_TREE_ITER_TAG_MASK = 0x0f,
 RADIX_TREE_ITER_TAGGED = 0x10,
 RADIX_TREE_ITER_CONTIG = 0x20,
};
# 268 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void **
radix_tree_iter_init(struct radix_tree_iter *iter, unsigned long start)
{
# 279 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
 iter->index = 0;
 iter->next_index = start;
 return ((void *)0);
}
# 297 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
void **radix_tree_next_chunk(const struct xarray *,
        struct radix_tree_iter *iter, unsigned flags);
# 310 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void **
radix_tree_iter_lookup(const struct xarray *root,
   struct radix_tree_iter *iter, unsigned long index)
{
 radix_tree_iter_init(iter, index);
 return radix_tree_next_chunk(root, iter, RADIX_TREE_ITER_CONTIG);
}
# 327 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__))
void **radix_tree_iter_retry(struct radix_tree_iter *iter)
{
 iter->next_index = iter->index;
 iter->tags = 0;
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
__radix_tree_iter_add(struct radix_tree_iter *iter, unsigned long slots)
{
 return iter->index + slots;
}
# 351 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
void **__attribute__((__warn_unused_result__)) radix_tree_iter_resume(void **slot,
     struct radix_tree_iter *iter);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) long
radix_tree_chunk_size(struct radix_tree_iter *iter)
{
 return iter->next_index - iter->index;
}
# 385 "/home/nathan/src/linux-next/include/linux/radix-tree.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void **radix_tree_next_slot(void **slot,
    struct radix_tree_iter *iter, unsigned flags)
{
 if (flags & RADIX_TREE_ITER_TAGGED) {
  iter->tags >>= 1;
  if (__builtin_expect(!!(!iter->tags), 0))
   return ((void *)0);
  if (__builtin_expect(!!(iter->tags & 1ul), 1)) {
   iter->index = __radix_tree_iter_add(iter, 1);
   slot++;
   goto found;
  }
  if (!(flags & RADIX_TREE_ITER_CONTIG)) {
   unsigned offset = __ffs(iter->tags);

   iter->tags >>= offset++;
   iter->index = __radix_tree_iter_add(iter, offset);
   slot += offset;
   goto found;
  }
 } else {
  long count = radix_tree_chunk_size(iter);

  while (--count > 0) {
   slot++;
   iter->index = __radix_tree_iter_add(iter, 1);

   if (__builtin_expect(!!(*slot), 1))
    goto found;
   if (flags & RADIX_TREE_ITER_CONTIG) {

    iter->next_index = 0;
    break;
   }
  }
 }
 return ((void *)0);

 found:
 return slot;
}
# 16 "/home/nathan/src/linux-next/include/linux/idr.h" 2



struct idr {
 struct xarray idr_rt;
 unsigned int idr_base;
 unsigned int idr_next;
};
# 66 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int idr_get_cursor(const struct idr *idr)
{
 return ({ union { typeof(idr->idr_next) __val; char __c[1]; } __u; if (1) __read_once_size(&(idr->idr_next), __u.__c, sizeof(idr->idr_next)); else __read_once_size_nocheck(&(idr->idr_next), __u.__c, sizeof(idr->idr_next)); do { } while (0); __u.__val; });
}
# 79 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_set_cursor(struct idr *idr, unsigned int val)
{
 ({ union { typeof(idr->idr_next) __val; char __c[1]; } __u = { .__val = ( typeof(idr->idr_next)) (val) }; __write_once_size(&(idr->idr_next), __u.__c, sizeof(idr->idr_next)); __u.__val; });
}
# 112 "/home/nathan/src/linux-next/include/linux/idr.h"
void idr_preload(gfp_t gfp_mask);

int idr_alloc(struct idr *, void *ptr, int start, int end, gfp_t);
int __attribute__((__warn_unused_result__)) idr_alloc_u32(struct idr *, void *ptr, u32 *id,
    unsigned long max, gfp_t);
int idr_alloc_cyclic(struct idr *, void *ptr, int start, int end, gfp_t);
void *idr_remove(struct idr *, unsigned long id);
void *idr_find(const struct idr *, unsigned long id);
int idr_for_each(const struct idr *,
   int (*fn)(int id, void *p, void *data), void *data);
void *idr_get_next(struct idr *, int *nextid);
void *idr_get_next_ul(struct idr *, unsigned long *nextid);
void *idr_replace(struct idr *, void *, unsigned long id);
void idr_destroy(struct idr *);
# 135 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_init_base(struct idr *idr, int base)
{
 xa_init_flags(&idr->idr_rt, ((( gfp_t)4) | ( gfp_t) (1 << (((23 + 0)) + 0))));
 idr->idr_base = base;
 idr->idr_next = 0;
}
# 149 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_init(struct idr *idr)
{
 idr_init_base(idr, 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool idr_is_empty(const struct idr *idr)
{
 return radix_tree_empty(&idr->idr_rt) &&
  radix_tree_tagged(&idr->idr_rt, 0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void idr_preload_end(void)
{
 __asm__ __volatile__("" : : : "memory");
}
# 240 "/home/nathan/src/linux-next/include/linux/idr.h"
struct ida_bitmap {
 unsigned long bitmap[(128 / sizeof(long))];
};

struct ida {
 struct xarray xa;
};
# 255 "/home/nathan/src/linux-next/include/linux/idr.h"
int ida_alloc_range(struct ida *, unsigned int min, unsigned int max, gfp_t);
void ida_free(struct ida *, unsigned int id);
void ida_destroy(struct ida *ida);
# 270 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc(struct ida *ida, gfp_t gfp)
{
 return ida_alloc_range(ida, 0, ~0, gfp);
}
# 287 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc_min(struct ida *ida, unsigned int min, gfp_t gfp)
{
 return ida_alloc_range(ida, min, ~0, gfp);
}
# 304 "/home/nathan/src/linux-next/include/linux/idr.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ida_alloc_max(struct ida *ida, unsigned int max, gfp_t gfp)
{
 return ida_alloc_range(ida, 0, max, gfp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ida_init(struct ida *ida)
{
 xa_init_flags(&ida->xa, ((( gfp_t)XA_LOCK_IRQ) | ((( gfp_t)4U) | (( gfp_t)((1U << (23 + 0)) << ( unsigned)((( xa_mark_t)0U)))))));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ida_is_empty(const struct ida *ida)
{
 return xa_empty(&ida->xa);
}
# 14 "/home/nathan/src/linux-next/include/linux/kernfs.h" 2






struct file;
struct dentry;
struct iattr;
struct seq_file;
struct vm_area_struct;
struct super_block;
struct file_system_type;
struct poll_table_struct;
struct fs_context;

struct kernfs_fs_context;
struct kernfs_open_node;
struct kernfs_iattrs;

enum kernfs_node_type {
 KERNFS_DIR = 0x0001,
 KERNFS_FILE = 0x0002,
 KERNFS_LINK = 0x0004,
};




enum kernfs_node_flag {
 KERNFS_ACTIVATED = 0x0010,
 KERNFS_NS = 0x0020,
 KERNFS_HAS_SEQ_SHOW = 0x0040,
 KERNFS_HAS_MMAP = 0x0080,
 KERNFS_LOCKDEP = 0x0100,
 KERNFS_SUICIDAL = 0x0400,
 KERNFS_SUICIDED = 0x0800,
 KERNFS_EMPTY_DIR = 0x1000,
 KERNFS_HAS_RELEASE = 0x2000,
};


enum kernfs_root_flag {






 KERNFS_ROOT_CREATE_DEACTIVATED = 0x0001,
# 74 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 0x0002,





 KERNFS_ROOT_SUPPORT_EXPORTOP = 0x0004,
};


struct kernfs_elem_dir {
 unsigned long subdirs;

 struct rb_root children;





 struct kernfs_root *root;
};

struct kernfs_elem_symlink {
 struct kernfs_node *target_kn;
};

struct kernfs_elem_attr {
 const struct kernfs_ops *ops;
 struct kernfs_open_node *open;
 loff_t size;
 struct kernfs_node *notify_next;
};
# 116 "/home/nathan/src/linux-next/include/linux/kernfs.h"
struct kernfs_node {
 atomic_t count;
 atomic_t active;
# 128 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 struct kernfs_node *parent;
 const char *name;

 struct rb_node rb;

 const void *ns;
 unsigned int hash;
 union {
  struct kernfs_elem_dir dir;
  struct kernfs_elem_symlink symlink;
  struct kernfs_elem_attr attr;
 };

 void *priv;





 u64 id;

 unsigned short flags;
 umode_t mode;
 struct kernfs_iattrs *iattr;
};
# 161 "/home/nathan/src/linux-next/include/linux/kernfs.h"
struct kernfs_syscall_ops {
 int (*show_options)(struct seq_file *sf, struct kernfs_root *root);

 int (*mkdir)(struct kernfs_node *parent, const char *name,
       umode_t mode);
 int (*rmdir)(struct kernfs_node *kn);
 int (*rename)(struct kernfs_node *kn, struct kernfs_node *new_parent,
        const char *new_name);
 int (*show_path)(struct seq_file *sf, struct kernfs_node *kn,
    struct kernfs_root *root);
};

struct kernfs_root {

 struct kernfs_node *kn;
 unsigned int flags;


 struct idr ino_idr;
 u32 last_id_lowbits;
 u32 id_highbits;
 struct kernfs_syscall_ops *syscall_ops;


 struct list_head supers;

 wait_queue_head_t deactivate_waitq;
};

struct kernfs_open_file {

 struct kernfs_node *kn;
 struct file *file;
 struct seq_file *seq_file;
 void *priv;


 struct mutex mutex;
 struct mutex prealloc_mutex;
 int event;
 struct list_head list;
 char *prealloc_buf;

 size_t atomic_write_len;
 bool mmapped:1;
 bool released:1;
 const struct vm_operations_struct *vm_ops;
};

struct kernfs_ops {




 int (*open)(struct kernfs_open_file *of);
 void (*release)(struct kernfs_open_file *of);
# 229 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 int (*seq_show)(struct seq_file *sf, void *v);

 void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
 void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
 void (*seq_stop)(struct seq_file *sf, void *v);

 ssize_t (*read)(struct kernfs_open_file *of, char *buf, size_t bytes,
   loff_t off);
# 245 "/home/nathan/src/linux-next/include/linux/kernfs.h"
 size_t atomic_write_len;






 bool prealloc;
 ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
    loff_t off);

 __poll_t (*poll)(struct kernfs_open_file *of,
    struct poll_table_struct *pt);

 int (*mmap)(struct kernfs_open_file *of, struct vm_area_struct *vma);




};




struct kernfs_fs_context {
 struct kernfs_root *root;
 void *ns_tag;
 unsigned long magic;


 bool new_sb_created;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
{
 return kn->flags & 0x000f;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_id_ino(u64 id)
{

 if (sizeof(ino_t) >= sizeof(u64))
  return id;
 else
  return (u32)id;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 kernfs_id_gen(u64 id)
{

 if (sizeof(ino_t) >= sizeof(u64))
  return 1;
 else
  return id >> 32;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_ino(struct kernfs_node *kn)
{
 return kernfs_id_ino(kn->id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t kernfs_gen(struct kernfs_node *kn)
{
 return kernfs_id_gen(kn->id);
}
# 321 "/home/nathan/src/linux-next/include/linux/kernfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kernfs_enable_ns(struct kernfs_node *kn)
{
 ({ int __ret_warn_on = !!(kernfs_type(kn) != KERNFS_DIR); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kernfs.h"), "i" (323), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 ({ int __ret_warn_on = !!(!(({ union { typeof((&kn->dir.children)->rb_node) __val; char __c[1]; } __u; if (1) __read_once_size(&((&kn->dir.children)->rb_node), __u.__c, sizeof((&kn->dir.children)->rb_node)); else __read_once_size_nocheck(&((&kn->dir.children)->rb_node), __u.__c, sizeof((&kn->dir.children)->rb_node)); do { } while (0); __u.__val; }) == ((void *)0))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kernfs.h"), "i" (324), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 kn->flags |= KERNFS_NS;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kernfs_ns_enabled(struct kernfs_node *kn)
{
 return kn->flags & KERNFS_NS;
}

int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
int kernfs_path_from_node(struct kernfs_node *root_kn, struct kernfs_node *kn,
     char *buf, size_t buflen);
void pr_cont_kernfs_name(struct kernfs_node *kn);
void pr_cont_kernfs_path(struct kernfs_node *kn);
struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
        const char *name, const void *ns);
struct kernfs_node *kernfs_walk_and_get_ns(struct kernfs_node *parent,
        const char *path, const void *ns);
void kernfs_get(struct kernfs_node *kn);
void kernfs_put(struct kernfs_node *kn);

struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry);
struct kernfs_root *kernfs_root_from_sb(struct super_block *sb);
struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);

struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
      struct super_block *sb);
struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
           unsigned int flags, void *priv);
void kernfs_destroy_root(struct kernfs_root *root);

struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
      const char *name, umode_t mode,
      kuid_t uid, kgid_t gid,
      void *priv, const void *ns);
struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,
         const char *name);
struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
      const char *name, umode_t mode,
      kuid_t uid, kgid_t gid,
      loff_t size,
      const struct kernfs_ops *ops,
      void *priv, const void *ns,
      struct lock_class_key *key);
struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
           const char *name,
           struct kernfs_node *target);
void kernfs_activate(struct kernfs_node *kn);
void kernfs_remove(struct kernfs_node *kn);
void kernfs_break_active_protection(struct kernfs_node *kn);
void kernfs_unbreak_active_protection(struct kernfs_node *kn);
bool kernfs_remove_self(struct kernfs_node *kn);
int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
        const void *ns);
int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
       const char *new_name, const void *new_ns);
int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
__poll_t kernfs_generic_poll(struct kernfs_open_file *of,
        struct poll_table_struct *pt);
void kernfs_notify(struct kernfs_node *kn);

int kernfs_xattr_get(struct kernfs_node *kn, const char *name,
       void *value, size_t size);
int kernfs_xattr_set(struct kernfs_node *kn, const char *name,
       const void *value, size_t size, int flags);

const void *kernfs_super_ns(struct super_block *sb);
int kernfs_get_tree(struct fs_context *fc);
void kernfs_free_fs_context(struct fs_context *fc);
void kernfs_kill_sb(struct super_block *sb);

void kernfs_init(void);

struct kernfs_node *kernfs_find_and_get_node_by_id(struct kernfs_root *root,
         u64 id);
# 533 "/home/nathan/src/linux-next/include/linux/kernfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)
{
 return kernfs_path_from_node(kn, ((void *)0), buf, buflen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_find_and_get(struct kernfs_node *kn, const char *name)
{
 return kernfs_find_and_get_ns(kn, name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_walk_and_get(struct kernfs_node *kn, const char *path)
{
 return kernfs_walk_and_get_ns(kn, path, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_dir(struct kernfs_node *parent, const char *name, umode_t mode,
    void *priv)
{
 return kernfs_create_dir_ns(parent, name, mode,
        (kuid_t){ 0 }, (kgid_t){ 0 },
        priv, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
        umode_t mode, kuid_t uid, kgid_t gid,
        loff_t size, const struct kernfs_ops *ops,
        void *priv, const void *ns)
{
 struct lock_class_key *key = ((void *)0);




 return __kernfs_create_file(parent, name, mode, uid, gid,
        size, ops, priv, ns, key);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *
kernfs_create_file(struct kernfs_node *parent, const char *name, umode_t mode,
     loff_t size, const struct kernfs_ops *ops, void *priv)
{
 return kernfs_create_file_ns(parent, name, mode,
         (kuid_t){ 0 }, (kgid_t){ 0 },
         size, ops, priv, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_remove_by_name(struct kernfs_node *parent,
     const char *name)
{
 return kernfs_remove_by_name_ns(parent, name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernfs_rename(struct kernfs_node *kn,
    struct kernfs_node *new_parent,
    const char *new_name)
{
 return kernfs_rename_ns(kn, new_parent, new_name, ((void *)0));
}
# 17 "/home/nathan/src/linux-next/include/linux/sysfs.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/kobject_ns.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/kobject_ns.h"
struct sock;
struct kobject;





enum kobj_ns_type {
 KOBJ_NS_TYPE_NONE = 0,
 KOBJ_NS_TYPE_NET,
 KOBJ_NS_TYPES
};
# 39 "/home/nathan/src/linux-next/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
 enum kobj_ns_type type;
 bool (*current_may_mount)(void);
 void *(*grab_current_ns)(void);
 const void *(*netlink_ns)(struct sock *sk);
 const void *(*initial_ns)(void);
 void (*drop_ns)(void *);
};

int kobj_ns_type_register(const struct kobj_ns_type_operations *ops);
int kobj_ns_type_registered(enum kobj_ns_type type);
const struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent);
const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj);

bool kobj_ns_current_may_mount(enum kobj_ns_type type);
void *kobj_ns_grab_current(enum kobj_ns_type type);
const void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk);
const void *kobj_ns_initial(enum kobj_ns_type type);
void kobj_ns_drop(enum kobj_ns_type type, void *ns);
# 22 "/home/nathan/src/linux-next/include/linux/sysfs.h" 2



struct kobject;
struct module;
struct bin_attribute;
enum kobj_ns_type;

struct attribute {
 const char *name;
 umode_t mode;





};
# 84 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct attribute_group {
 const char *name;
 umode_t (*is_visible)(struct kobject *,
           struct attribute *, int);
 umode_t (*is_bin_visible)(struct kobject *,
        struct bin_attribute *, int);
 struct attribute **attrs;
 struct bin_attribute **bin_attrs;
};
# 158 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct file;
struct vm_area_struct;

struct bin_attribute {
 struct attribute attr;
 size_t size;
 void *private;
 ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
   char *, loff_t, size_t);
 ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,
    char *, loff_t, size_t);
 int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,
      struct vm_area_struct *vma);
};
# 223 "/home/nathan/src/linux-next/include/linux/sysfs.h"
struct sysfs_ops {
 ssize_t (*show)(struct kobject *, struct attribute *, char *);
 ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};



int __attribute__((__warn_unused_result__)) sysfs_create_dir_ns(struct kobject *kobj, const void *ns);
void sysfs_remove_dir(struct kobject *kobj);
int __attribute__((__warn_unused_result__)) sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,
         const void *new_ns);
int __attribute__((__warn_unused_result__)) sysfs_move_dir_ns(struct kobject *kobj,
       struct kobject *new_parent_kobj,
       const void *new_ns);
int __attribute__((__warn_unused_result__)) sysfs_create_mount_point(struct kobject *parent_kobj,
       const char *name);
void sysfs_remove_mount_point(struct kobject *parent_kobj,
         const char *name);

int __attribute__((__warn_unused_result__)) sysfs_create_file_ns(struct kobject *kobj,
          const struct attribute *attr,
          const void *ns);
int __attribute__((__warn_unused_result__)) sysfs_create_files(struct kobject *kobj,
       const struct attribute * const *attr);
int __attribute__((__warn_unused_result__)) sysfs_chmod_file(struct kobject *kobj,
      const struct attribute *attr, umode_t mode);
struct kernfs_node *sysfs_break_active_protection(struct kobject *kobj,
        const struct attribute *attr);
void sysfs_unbreak_active_protection(struct kernfs_node *kn);
void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,
     const void *ns);
bool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr);
void sysfs_remove_files(struct kobject *kobj, const struct attribute * const *attr);

int __attribute__((__warn_unused_result__)) sysfs_create_bin_file(struct kobject *kobj,
           const struct bin_attribute *attr);
void sysfs_remove_bin_file(struct kobject *kobj,
      const struct bin_attribute *attr);

int __attribute__((__warn_unused_result__)) sysfs_create_link(struct kobject *kobj, struct kobject *target,
       const char *name);
int __attribute__((__warn_unused_result__)) sysfs_create_link_nowarn(struct kobject *kobj,
       struct kobject *target,
       const char *name);
void sysfs_remove_link(struct kobject *kobj, const char *name);

int sysfs_rename_link_ns(struct kobject *kobj, struct kobject *target,
    const char *old_name, const char *new_name,
    const void *new_ns);

void sysfs_delete_link(struct kobject *dir, struct kobject *targ,
   const char *name);

int __attribute__((__warn_unused_result__)) sysfs_create_group(struct kobject *kobj,
        const struct attribute_group *grp);
int __attribute__((__warn_unused_result__)) sysfs_create_groups(struct kobject *kobj,
         const struct attribute_group **groups);
int __attribute__((__warn_unused_result__)) sysfs_update_groups(struct kobject *kobj,
         const struct attribute_group **groups);
int sysfs_update_group(struct kobject *kobj,
         const struct attribute_group *grp);
void sysfs_remove_group(struct kobject *kobj,
   const struct attribute_group *grp);
void sysfs_remove_groups(struct kobject *kobj,
    const struct attribute_group **groups);
int sysfs_add_file_to_group(struct kobject *kobj,
   const struct attribute *attr, const char *group);
void sysfs_remove_file_from_group(struct kobject *kobj,
   const struct attribute *attr, const char *group);
int sysfs_merge_group(struct kobject *kobj,
         const struct attribute_group *grp);
void sysfs_unmerge_group(struct kobject *kobj,
         const struct attribute_group *grp);
int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
       struct kobject *target, const char *link_name);
void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
      const char *link_name);
int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
          struct kobject *target_kobj,
          const char *target_name);

void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr);

int __attribute__((__warn_unused_result__)) sysfs_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_enable_ns(struct kernfs_node *kn)
{
 return kernfs_enable_ns(kn);
}
# 527 "/home/nathan/src/linux-next/include/linux/sysfs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) sysfs_create_file(struct kobject *kobj,
       const struct attribute *attr)
{
 return sysfs_create_file_ns(kobj, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_remove_file(struct kobject *kobj,
         const struct attribute *attr)
{
 sysfs_remove_file_ns(kobj, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
        const char *old_name, const char *new_name)
{
 return sysfs_rename_link_ns(kobj, target, old_name, new_name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_notify_dirent(struct kernfs_node *kn)
{
 kernfs_notify(kn);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent,
         const char *name)
{
 return kernfs_find_and_get(parent, name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kernfs_node *sysfs_get(struct kernfs_node *kn)
{
 kernfs_get(kn);
 return kn;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sysfs_put(struct kernfs_node *kn)
{
 kernfs_put(kn);
}
# 21 "/home/nathan/src/linux-next/include/linux/kobject.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/kref.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/kref.h"
struct kref {
 refcount_t refcount;
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kref_init(struct kref *kref)
{
 refcount_set(&kref->refcount, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int kref_read(const struct kref *kref)
{
 return refcount_read(&kref->refcount);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kref_get(struct kref *kref)
{
 refcount_inc(&kref->refcount);
}
# 62 "/home/nathan/src/linux-next/include/linux/kref.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put(struct kref *kref, void (*release)(struct kref *kref))
{
 if (refcount_dec_and_test(&kref->refcount)) {
  release(kref);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put_mutex(struct kref *kref,
     void (*release)(struct kref *kref),
     struct mutex *lock)
{
 if (refcount_dec_and_mutex_lock(&kref->refcount, lock)) {
  release(kref);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kref_put_lock(struct kref *kref,
    void (*release)(struct kref *kref),
    spinlock_t *lock)
{
 if (refcount_dec_and_lock(&kref->refcount, lock)) {
  release(kref);
  return 1;
 }
 return 0;
}
# 109 "/home/nathan/src/linux-next/include/linux/kref.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) kref_get_unless_zero(struct kref *kref)
{
 return refcount_inc_not_zero(&kref->refcount);
}
# 24 "/home/nathan/src/linux-next/include/linux/kobject.h" 2
# 41 "/home/nathan/src/linux-next/include/linux/kobject.h"
extern u64 uevent_seqnum;
# 53 "/home/nathan/src/linux-next/include/linux/kobject.h"
enum kobject_action {
 KOBJ_ADD,
 KOBJ_REMOVE,
 KOBJ_CHANGE,
 KOBJ_MOVE,
 KOBJ_ONLINE,
 KOBJ_OFFLINE,
 KOBJ_BIND,
 KOBJ_UNBIND,
 KOBJ_MAX
};

struct kobject {
 const char *name;
 struct list_head entry;
 struct kobject *parent;
 struct kset *kset;
 struct kobj_type *ktype;
 struct kernfs_node *sd;
 struct kref kref;



 unsigned int state_initialized:1;
 unsigned int state_in_sysfs:1;
 unsigned int state_add_uevent_sent:1;
 unsigned int state_remove_uevent_sent:1;
 unsigned int uevent_suppress:1;
};

extern __attribute__((__format__(printf, 2, 3)))
int kobject_set_name(struct kobject *kobj, const char *name, ...);
extern __attribute__((__format__(printf, 2, 0)))
int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
      va_list vargs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kobject_name(const struct kobject *kobj)
{
 return kobj->name;
}

extern void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
extern __attribute__((__format__(printf, 3, 4))) __attribute__((__warn_unused_result__))
int kobject_add(struct kobject *kobj, struct kobject *parent,
  const char *fmt, ...);
extern __attribute__((__format__(printf, 4, 5))) __attribute__((__warn_unused_result__))
int kobject_init_and_add(struct kobject *kobj,
    struct kobj_type *ktype, struct kobject *parent,
    const char *fmt, ...);

extern void kobject_del(struct kobject *kobj);

extern struct kobject * __attribute__((__warn_unused_result__)) kobject_create(void);
extern struct kobject * __attribute__((__warn_unused_result__)) kobject_create_and_add(const char *name,
      struct kobject *parent);

extern int __attribute__((__warn_unused_result__)) kobject_rename(struct kobject *, const char *new_name);
extern int __attribute__((__warn_unused_result__)) kobject_move(struct kobject *, struct kobject *);

extern struct kobject *kobject_get(struct kobject *kobj);
extern struct kobject * __attribute__((__warn_unused_result__)) kobject_get_unless_zero(
      struct kobject *kobj);
extern void kobject_put(struct kobject *kobj);

extern const void *kobject_namespace(struct kobject *kobj);
extern void kobject_get_ownership(struct kobject *kobj,
      kuid_t *uid, kgid_t *gid);
extern char *kobject_get_path(struct kobject *kobj, gfp_t flag);
# 132 "/home/nathan/src/linux-next/include/linux/kobject.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kobject_has_children(struct kobject *kobj)
{
 ({ int __ret_warn_on = !!(kref_read(&kobj->kref) == 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/kobject.h"), "i" (134), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

 return kobj->sd && kobj->sd->dir.subdirs;
}

struct kobj_type {
 void (*release)(struct kobject *kobj);
 const struct sysfs_ops *sysfs_ops;
 struct attribute **default_attrs;
 const struct attribute_group **default_groups;
 const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
 const void *(*namespace)(struct kobject *kobj);
 void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid);
};

struct kobj_uevent_env {
 char *argv[3];
 char *envp[32];
 int envp_idx;
 char buf[2048];
 int buflen;
};

struct kset_uevent_ops {
 int (* const filter)(struct kset *kset, struct kobject *kobj);
 const char *(* const name)(struct kset *kset, struct kobject *kobj);
 int (* const uevent)(struct kset *kset, struct kobject *kobj,
        struct kobj_uevent_env *env);
};

struct kobj_attribute {
 struct attribute attr;
 ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
   char *buf);
 ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
    const char *buf, size_t count);
};

extern const struct sysfs_ops kobj_sysfs_ops;

struct sock;
# 193 "/home/nathan/src/linux-next/include/linux/kobject.h"
struct kset {
 struct list_head list;
 spinlock_t list_lock;
 struct kobject kobj;
 const struct kset_uevent_ops *uevent_ops;
} ;

extern void kset_init(struct kset *kset);
extern int __attribute__((__warn_unused_result__)) kset_register(struct kset *kset);
extern void kset_unregister(struct kset *kset);
extern struct kset * __attribute__((__warn_unused_result__)) kset_create_and_add(const char *name,
      const struct kset_uevent_ops *u,
      struct kobject *parent_kobj);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kset *to_kset(struct kobject *kobj)
{
 return kobj ? ({ void *__mptr = (void *)(kobj); do { extern void __compiletime_assert_209(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(kobj)), typeof(((struct kset *)0)->kobj)) && !__builtin_types_compatible_p(typeof(*(kobj)), typeof(void))))) __compiletime_assert_209(); } while (0); ((struct kset *)(__mptr - __builtin_offsetof(struct kset, kobj))); }) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kset *kset_get(struct kset *k)
{
 return k ? to_kset(kobject_get(&k->kobj)) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kset_put(struct kset *k)
{
 kobject_put(&k->kobj);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kobj_type *get_ktype(struct kobject *kobj)
{
 return kobj->ktype;
}

extern struct kobject *kset_find_obj(struct kset *, const char *);


extern struct kobject *kernel_kobj;

extern struct kobject *mm_kobj;

extern struct kobject *hypervisor_kobj;

extern struct kobject *power_kobj;

extern struct kobject *firmware_kobj;

int kobject_uevent(struct kobject *kobj, enum kobject_action action);
int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
   char *envp[]);
int kobject_synth_uevent(struct kobject *kobj, const char *buf, size_t count);

__attribute__((__format__(printf, 2, 3)))
int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...);
# 21 "/home/nathan/src/linux-next/include/linux/module.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/moduleparam.h" 1
# 36 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
struct kernel_param;






enum {
 KERNEL_PARAM_OPS_FL_NOARG = (1 << 0)
};

struct kernel_param_ops {

 unsigned int flags;

 int (*set)(const char *val, const struct kernel_param *kp);

 int (*get)(char *buffer, const struct kernel_param *kp);

 void (*free)(void *arg);
};







enum {
 KERNEL_PARAM_FL_UNSAFE = (1 << 0),
 KERNEL_PARAM_FL_HWPARAM = (1 << 1),
};

struct kernel_param {
 const char *name;
 struct module *mod;
 const struct kernel_param_ops *ops;
 const u16 perm;
 s8 level;
 u8 flags;
 union {
  void *arg;
  const struct kparam_string *str;
  const struct kparam_array *arr;
 };
};

extern const struct kernel_param __start___param[], __stop___param[];


struct kparam_string {
 unsigned int maxlen;
 char *string;
};


struct kparam_array
{
 unsigned int max;
 unsigned int elemsize;
 unsigned int *num;
 const struct kernel_param_ops *ops;
 void *elem;
};
# 304 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
extern void kernel_param_lock(struct module *mod);
extern void kernel_param_unlock(struct module *mod);
# 372 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
extern bool parameq(const char *name1, const char *name2);
# 382 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
extern bool parameqn(const char *name1, const char *name2, size_t n);


extern char *parse_args(const char *name,
        char *args,
        const struct kernel_param *params,
        unsigned num,
        s16 level_min,
        s16 level_max,
        void *arg,
        int (*unknown)(char *param, char *val,
         const char *doing, void *arg));



extern void destroy_params(const struct kernel_param *params, unsigned num);
# 411 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
extern const struct kernel_param_ops param_ops_byte;
extern int param_set_byte(const char *val, const struct kernel_param *kp);
extern int param_get_byte(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_short;
extern int param_set_short(const char *val, const struct kernel_param *kp);
extern int param_get_short(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_ushort;
extern int param_set_ushort(const char *val, const struct kernel_param *kp);
extern int param_get_ushort(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_int;
extern int param_set_int(const char *val, const struct kernel_param *kp);
extern int param_get_int(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_uint;
extern int param_set_uint(const char *val, const struct kernel_param *kp);
extern int param_get_uint(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_long;
extern int param_set_long(const char *val, const struct kernel_param *kp);
extern int param_get_long(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_ulong;
extern int param_set_ulong(const char *val, const struct kernel_param *kp);
extern int param_get_ulong(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_ullong;
extern int param_set_ullong(const char *val, const struct kernel_param *kp);
extern int param_get_ullong(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_charp;
extern int param_set_charp(const char *val, const struct kernel_param *kp);
extern int param_get_charp(char *buffer, const struct kernel_param *kp);
extern void param_free_charp(void *arg);



extern const struct kernel_param_ops param_ops_bool;
extern int param_set_bool(const char *val, const struct kernel_param *kp);
extern int param_get_bool(char *buffer, const struct kernel_param *kp);


extern const struct kernel_param_ops param_ops_bool_enable_only;
extern int param_set_bool_enable_only(const char *val,
          const struct kernel_param *kp);



extern const struct kernel_param_ops param_ops_invbool;
extern int param_set_invbool(const char *val, const struct kernel_param *kp);
extern int param_get_invbool(char *buffer, const struct kernel_param *kp);



extern const struct kernel_param_ops param_ops_bint;
extern int param_set_bint(const char *val, const struct kernel_param *kp);
# 519 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
enum hwparam_type {
 hwparam_ioport,
 hwparam_iomem,
 hwparam_ioport_or_iomem,
 hwparam_irq,
 hwparam_dma,
 hwparam_dma_addr,
 hwparam_other,
};
# 580 "/home/nathan/src/linux-next/include/linux/moduleparam.h"
extern const struct kernel_param_ops param_array_ops;

extern const struct kernel_param_ops param_ops_string;
extern int param_set_copystring(const char *val, const struct kernel_param *);
extern int param_get_string(char *buffer, const struct kernel_param *kp);



struct module;


extern int module_param_sysfs_setup(struct module *mod,
        const struct kernel_param *kparam,
        unsigned int num_params);

extern void module_param_sysfs_remove(struct module *mod);
# 22 "/home/nathan/src/linux-next/include/linux/module.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h" 1
# 40 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h"
struct latch_tree_node {
 struct rb_node node[2];
};

struct latch_tree_root {
 seqcount_t seq;
 struct rb_root tree[2];
};
# 64 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h"
struct latch_tree_ops {
 bool (*less)(struct latch_tree_node *a, struct latch_tree_node *b);
 int (*comp)(void *key, struct latch_tree_node *b);
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) struct latch_tree_node *
__lt_from_rb(struct rb_node *node, int idx)
{
 return ({ void *__mptr = (void *)(node); do { extern void __compiletime_assert_72(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node)), typeof(((struct latch_tree_node *)0)->node[idx])) && !__builtin_types_compatible_p(typeof(*(node)), typeof(void))))) __compiletime_assert_72(); } while (0); ((struct latch_tree_node *)(__mptr - __builtin_offsetof(struct latch_tree_node, node[idx]))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
__lt_insert(struct latch_tree_node *ltn, struct latch_tree_root *ltr, int idx,
     bool (*less)(struct latch_tree_node *a, struct latch_tree_node *b))
{
 struct rb_root *root = &ltr->tree[idx];
 struct rb_node **link = &root->rb_node;
 struct rb_node *node = &ltn->node[idx];
 struct rb_node *parent = ((void *)0);
 struct latch_tree_node *ltp;

 while (*link) {
  parent = *link;
  ltp = __lt_from_rb(parent, idx);

  if (less(ltn, ltp))
   link = &parent->rb_left;
  else
   link = &parent->rb_right;
 }

 rb_link_node_rcu(node, parent, link);
 rb_insert_color(node, root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
__lt_erase(struct latch_tree_node *ltn, struct latch_tree_root *ltr, int idx)
{
 rb_erase(&ltn->node[idx], &ltr->tree[idx]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) struct latch_tree_node *
__lt_find(void *key, struct latch_tree_root *ltr, int idx,
   int (*comp)(void *key, struct latch_tree_node *node))
{
 struct rb_node *node = ({ typeof(ltr->tree[idx].rb_node) ________p1 = ({ union { typeof(ltr->tree[idx].rb_node) __val; char __c[1]; } __u; if (1) __read_once_size(&(ltr->tree[idx].rb_node), __u.__c, sizeof(ltr->tree[idx].rb_node)); else __read_once_size_nocheck(&(ltr->tree[idx].rb_node), __u.__c, sizeof(ltr->tree[idx].rb_node)); do { } while (0); __u.__val; }); ((typeof(*ltr->tree[idx].rb_node) *)(________p1)); });
 struct latch_tree_node *ltn;
 int c;

 while (node) {
  ltn = __lt_from_rb(node, idx);
  c = comp(key, ltn);

  if (c < 0)
   node = ({ typeof(node->rb_left) ________p1 = ({ union { typeof(node->rb_left) __val; char __c[1]; } __u; if (1) __read_once_size(&(node->rb_left), __u.__c, sizeof(node->rb_left)); else __read_once_size_nocheck(&(node->rb_left), __u.__c, sizeof(node->rb_left)); do { } while (0); __u.__val; }); ((typeof(*node->rb_left) *)(________p1)); });
  else if (c > 0)
   node = ({ typeof(node->rb_right) ________p1 = ({ union { typeof(node->rb_right) __val; char __c[1]; } __u; if (1) __read_once_size(&(node->rb_right), __u.__c, sizeof(node->rb_right)); else __read_once_size_nocheck(&(node->rb_right), __u.__c, sizeof(node->rb_right)); do { } while (0); __u.__val; }); ((typeof(*node->rb_right) *)(________p1)); });
  else
   return ltn;
 }

 return ((void *)0);
}
# 143 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
latch_tree_insert(struct latch_tree_node *node,
    struct latch_tree_root *root,
    const struct latch_tree_ops *ops)
{
 raw_write_seqcount_latch(&root->seq);
 __lt_insert(node, root, 0, ops->less);
 raw_write_seqcount_latch(&root->seq);
 __lt_insert(node, root, 1, ops->less);
}
# 170 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
latch_tree_erase(struct latch_tree_node *node,
   struct latch_tree_root *root,
   const struct latch_tree_ops *ops)
{
 raw_write_seqcount_latch(&root->seq);
 __lt_erase(node, root, 0);
 raw_write_seqcount_latch(&root->seq);
 __lt_erase(node, root, 1);
}
# 199 "/home/nathan/src/linux-next/include/linux/rbtree_latch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) struct latch_tree_node *
latch_tree_find(void *key, struct latch_tree_root *root,
  const struct latch_tree_ops *ops)
{
 struct latch_tree_node *node;
 unsigned int seq;

 do {
  seq = raw_read_seqcount_latch(&root->seq);
  node = __lt_find(key, root, seq & 1, ops->comp);
 } while (read_seqcount_retry(&root->seq, seq));

 return node;
}
# 25 "/home/nathan/src/linux-next/include/linux/module.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/error-injection.h" 1





# 1 "/home/nathan/src/linux-next/include/asm-generic/error-injection.h" 1





enum {
 EI_ETYPE_NONE,
 EI_ETYPE_NULL,
 EI_ETYPE_ERRNO,
 EI_ETYPE_ERRNO_NULL,
 EI_ETYPE_TRUE,
};

struct error_injection_entry {
 unsigned long addr;
 int etype;
};

struct pt_regs;
# 34 "/home/nathan/src/linux-next/include/asm-generic/error-injection.h"
void override_function_with_return(struct pt_regs *regs);
# 7 "/home/nathan/src/linux-next/include/linux/error-injection.h" 2



extern bool within_error_injection_list(unsigned long addr);
extern int get_injectable_error_type(unsigned long addr);
# 26 "/home/nathan/src/linux-next/include/linux/module.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h"
# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/tracepoint-defs.h" 2

struct trace_print_flags {
 unsigned long mask;
 const char *name;
};

struct trace_print_flags_u64 {
 unsigned long long mask;
 const char *name;
};

struct tracepoint_func {
 void *func;
 void *data;
 int prio;
};

struct tracepoint {
 const char *name;
 struct static_key key;
 int (*regfunc)(void);
 void (*unregfunc)(void);
 struct tracepoint_func *funcs;
};




typedef struct tracepoint * const tracepoint_ptr_t;


struct bpf_raw_event_map {
 struct tracepoint *tp;
 void *bpf_func;
 u32 num_args;
 u32 writable_size;
} __attribute__((__aligned__(32)));
# 27 "/home/nathan/src/linux-next/include/linux/module.h" 2



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/module.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h" 2
# 45 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h"
struct mod_arch_specific {

 unsigned int stubs_section;
 unsigned int toc_section;
 bool toc_fixed;


 unsigned long start_opd;
 unsigned long end_opd;







 unsigned long tramp;






 struct list_head bug_list;
 struct bug_entry *bug_table;
 unsigned int num_bugs;
};
# 80 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h"
 asm(".section .stubs,\"ax\",@nobits; .align 3; .previous");
# 91 "/home/nathan/src/linux-next/arch/powerpc/include/asm/module.h"
 asm(".section .ftrace.tramp,\"ax\",@nobits; .align 3; .previous");



int module_trampoline_target(struct module *mod, unsigned long trampoline,
        unsigned long *target);


int module_finalize_ftrace(struct module *mod, const Elf64_Shdr *sechdrs);
# 31 "/home/nathan/src/linux-next/include/linux/module.h" 2






struct modversion_info {
 unsigned long crc;
 char name[(64 - sizeof(unsigned long))];
};

struct module;
struct exception_table_entry;

struct module_kobject {
 struct kobject kobj;
 struct module *mod;
 struct kobject *drivers_dir;
 struct module_param_attrs *mp;
 struct completion *kobj_completion;
} ;

struct module_attribute {
 struct attribute attr;
 ssize_t (*show)(struct module_attribute *, struct module_kobject *,
   char *);
 ssize_t (*store)(struct module_attribute *, struct module_kobject *,
    const char *, size_t count);
 void (*setup)(struct module *, const char *);
 int (*test)(struct module *);
 void (*free)(struct module *);
};

struct module_version_attribute {
 struct module_attribute mattr;
 const char *module_name;
 const char *version;
} __attribute__ ((__aligned__(sizeof(void *))));

extern ssize_t __modver_version_show(struct module_attribute *,
         struct module_kobject *, char *);

extern struct module_attribute module_uevent;


extern int init_module(void);
extern void cleanup_module(void);
# 291 "/home/nathan/src/linux-next/include/linux/module.h"
struct notifier_block;



extern int modules_disabled;

void *__symbol_get(const char *symbol);
void *__symbol_get_gpl(const char *symbol);



struct module_use {
 struct list_head source_list;
 struct list_head target_list;
 struct module *source, *target;
};

enum module_state {
 MODULE_STATE_LIVE,
 MODULE_STATE_COMING,
 MODULE_STATE_GOING,
 MODULE_STATE_UNFORMED,
};

struct mod_tree_node {
 struct module *mod;
 struct latch_tree_node node;
};

struct module_layout {

 void *base;

 unsigned int size;

 unsigned int text_size;

 unsigned int ro_size;

 unsigned int ro_after_init_size;


 struct mod_tree_node mtn;

};
# 344 "/home/nathan/src/linux-next/include/linux/module.h"
struct mod_kallsyms {
 Elf64_Sym *symtab;
 unsigned int num_symtab;
 char *strtab;
 char *typetab;
};
# 360 "/home/nathan/src/linux-next/include/linux/module.h"
struct module {
 enum module_state state;


 struct list_head list;


 char name[(64 - sizeof(unsigned long))];


 struct module_kobject mkobj;
 struct module_attribute *modinfo_attrs;
 const char *version;
 const char *srcversion;
 struct kobject *holders_dir;


 const struct kernel_symbol *syms;
 const s32 *crcs;
 unsigned int num_syms;



 struct mutex param_lock;

 struct kernel_param *kp;
 unsigned int num_kp;


 unsigned int num_gpl_syms;
 const struct kernel_symbol *gpl_syms;
 const s32 *gpl_crcs;
# 410 "/home/nathan/src/linux-next/include/linux/module.h"
 bool async_probe_requested;


 const struct kernel_symbol *gpl_future_syms;
 const s32 *gpl_future_crcs;
 unsigned int num_gpl_future_syms;


 unsigned int num_exentries;
 struct exception_table_entry *extable;


 int (*init)(void);


 struct module_layout core_layout __attribute__((__aligned__((1 << 7))));
 struct module_layout init_layout;


 struct mod_arch_specific arch;

 unsigned long taints;



 unsigned num_bugs;
 struct list_head bug_list;
 struct bug_entry *bug_table;




 struct mod_kallsyms *kallsyms;
 struct mod_kallsyms core_kallsyms;


 struct module_sect_attrs *sect_attrs;


 struct module_notes_attrs *notes_attrs;




 char *args;



 void *percpu;
 unsigned int percpu_size;



 unsigned int num_tracepoints;
 tracepoint_ptr_t *tracepoints_ptrs;


 unsigned int num_srcu_structs;
 struct srcu_struct **srcu_struct_ptrs;


 unsigned int num_bpf_raw_events;
 struct bpf_raw_event_map *bpf_raw_events;


 struct jump_entry *jump_entries;
 unsigned int num_jump_entries;


 unsigned int num_trace_bprintk_fmt;
 const char **trace_bprintk_fmt_start;


 struct trace_event_call **trace_events;
 unsigned int num_trace_events;
 struct trace_eval_map **trace_evals;
 unsigned int num_trace_evals;


 unsigned int num_ftrace_callsites;
 unsigned long *ftrace_callsites;
# 503 "/home/nathan/src/linux-next/include/linux/module.h"
 struct list_head source_list;

 struct list_head target_list;


 void (*exit)(void);

 atomic_t refcnt;
# 520 "/home/nathan/src/linux-next/include/linux/module.h"
 struct error_injection_entry *ei_funcs;
 unsigned int num_ei_funcs;

} __attribute__((__aligned__((1 << 7)))) ;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long kallsyms_symbol_value(const Elf64_Sym *sym)
{
 return sym->st_value;
}


extern struct mutex module_mutex;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool module_is_live(struct module *mod)
{
 return mod->state != MODULE_STATE_GOING;
}

struct module *__module_text_address(unsigned long addr);
struct module *__module_address(unsigned long addr);
bool is_module_address(unsigned long addr);
bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr);
bool is_module_percpu_address(unsigned long addr);
bool is_module_text_address(unsigned long addr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool within_module_core(unsigned long addr,
          const struct module *mod)
{
 return (unsigned long)mod->core_layout.base <= addr &&
        addr < (unsigned long)mod->core_layout.base + mod->core_layout.size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool within_module_init(unsigned long addr,
          const struct module *mod)
{
 return (unsigned long)mod->init_layout.base <= addr &&
        addr < (unsigned long)mod->init_layout.base + mod->init_layout.size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool within_module(unsigned long addr, const struct module *mod)
{
 return within_module_init(addr, mod) || within_module_core(addr, mod);
}


struct module *find_module(const char *name);

struct symsearch {
 const struct kernel_symbol *start, *stop;
 const s32 *crcs;
 enum {
  NOT_GPL_ONLY,
  GPL_ONLY,
  WILL_BE_GPL_ONLY,
 } licence;
 bool unused;
};






const struct kernel_symbol *find_symbol(const char *name,
     struct module **owner,
     const s32 **crc,
     bool gplok,
     bool warn);






bool each_symbol_section(bool (*fn)(const struct symsearch *arr,
        struct module *owner,
        void *data), void *data);



int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
   char *name, char *module_name, int *exported);


unsigned long module_kallsyms_lookup_name(const char *name);

int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,
          struct module *, unsigned long),
       void *data);

extern void __attribute__((__noreturn__)) __module_put_and_exit(struct module *mod,
   long code);



int module_refcount(struct module *mod);
void __symbol_put(const char *symbol);

void symbol_put_addr(void *addr);



extern void __module_get(struct module *module);



extern bool try_module_get(struct module *module);

extern void module_put(struct module *module);
# 652 "/home/nathan/src/linux-next/include/linux/module.h"
int ref_module(struct module *a, struct module *b);
# 662 "/home/nathan/src/linux-next/include/linux/module.h"
void *dereference_module_function_descriptor(struct module *mod, void *ptr);




const char *module_address_lookup(unsigned long addr,
       unsigned long *symbolsize,
       unsigned long *offset,
       char **modname,
       char *namebuf);
int lookup_module_symbol_name(unsigned long addr, char *symname);
int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name);

int register_module_notifier(struct notifier_block *nb);
int unregister_module_notifier(struct notifier_block *nb);

extern void print_modules(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool module_requested_async_probing(struct module *module)
{
 return module && module->async_probe_requested;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_livepatch_module(struct module *mod)
{
 return false;
}


bool is_module_sig_enforced(void);
void set_module_sig_enforced(void);
# 850 "/home/nathan/src/linux-next/include/linux/module.h"
extern struct kset *module_kset;
extern struct kobj_type module_ktype;
extern int module_sysfs_initialized;
# 865 "/home/nathan/src/linux-next/include/linux/module.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void module_enable_ro(const struct module *mod, bool after_init) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void module_disable_ro(const struct module *mod) { }



void module_bug_finalize(const Elf64_Ehdr *, const Elf64_Shdr *,
    struct module *);
void module_bug_cleanup(struct module *);
# 887 "/home/nathan/src/linux-next/include/linux/module.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool retpoline_module_ok(bool has_retpoline)
{
 return true;
}
# 899 "/home/nathan/src/linux-next/include/linux/module.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool module_sig_ok(struct module *module)
{
 return true;
}
# 15 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c" 2
# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 1
# 17 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
# 1 "/home/nathan/src/linux-next/include/linux/pci.h" 1
# 27 "/home/nathan/src/linux-next/include/linux/pci.h"
# 1 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
# 1 "/home/nathan/src/linux-next/include/linux/uuid.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/uuid.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h" 1
# 23 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h"
typedef struct {
 __u8 b[16];
} guid_t;
# 35 "/home/nathan/src/linux-next/include/uapi/linux/uuid.h"
typedef guid_t uuid_le;
# 12 "/home/nathan/src/linux-next/include/linux/uuid.h" 2




typedef struct {
 __u8 b[16];
} uuid_t;
# 33 "/home/nathan/src/linux-next/include/linux/uuid.h"
extern const guid_t guid_null;
extern const uuid_t uuid_null;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool guid_equal(const guid_t *u1, const guid_t *u2)
{
 return memcmp(u1, u2, sizeof(guid_t)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void guid_copy(guid_t *dst, const guid_t *src)
{
 memcpy(dst, src, sizeof(guid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool guid_is_null(const guid_t *guid)
{
 return guid_equal(guid, &guid_null);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uuid_equal(const uuid_t *u1, const uuid_t *u2)
{
 return memcmp(u1, u2, sizeof(uuid_t)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void uuid_copy(uuid_t *dst, const uuid_t *src)
{
 memcpy(dst, src, sizeof(uuid_t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool uuid_is_null(const uuid_t *uuid)
{
 return uuid_equal(uuid, &uuid_null);
}

void generate_random_uuid(unsigned char uuid[16]);

extern void guid_gen(guid_t *u);
extern void uuid_gen(uuid_t *u);

bool __attribute__((__warn_unused_result__)) uuid_is_valid(const char *uuid);

extern const u8 guid_index[16];
extern const u8 uuid_index[16];

int guid_parse(const char *uuid, guid_t *u);
int uuid_parse(const char *uuid, uuid_t *u);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int uuid_le_cmp(const guid_t u1, const guid_t u2)
{
 return memcmp(&u1, &u2, sizeof(guid_t));
}
# 14 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h" 2
typedef unsigned long kernel_ulong_t;
# 38 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct pci_device_id {
 __u32 vendor, device;
 __u32 subvendor, subdevice;
 __u32 class, class_mask;
 kernel_ulong_t driver_data;
};







struct ieee1394_device_id {
 __u32 match_flags;
 __u32 vendor_id;
 __u32 model_id;
 __u32 specifier_id;
 __u32 version;
 kernel_ulong_t driver_data;
};
# 121 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct usb_device_id {

 __u16 match_flags;


 __u16 idVendor;
 __u16 idProduct;
 __u16 bcdDevice_lo;
 __u16 bcdDevice_hi;


 __u8 bDeviceClass;
 __u8 bDeviceSubClass;
 __u8 bDeviceProtocol;


 __u8 bInterfaceClass;
 __u8 bInterfaceSubClass;
 __u8 bInterfaceProtocol;


 __u8 bInterfaceNumber;


 kernel_ulong_t driver_info
  __attribute__((aligned(sizeof(kernel_ulong_t))));
};
# 166 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct hid_device_id {
 __u16 bus;
 __u16 group;
 __u32 vendor;
 __u32 product;
 kernel_ulong_t driver_data;
};


struct ccw_device_id {
 __u16 match_flags;

 __u16 cu_type;
 __u16 dev_type;
 __u8 cu_model;
 __u8 dev_model;

 kernel_ulong_t driver_info;
};







struct ap_device_id {
 __u16 match_flags;
 __u8 dev_type;
 kernel_ulong_t driver_info;
};





struct css_device_id {
 __u8 match_flags;
 __u8 type;
 kernel_ulong_t driver_data;
};



struct acpi_device_id {
 __u8 id[9];
 kernel_ulong_t driver_data;
 __u32 cls;
 __u32 cls_msk;
};




struct pnp_device_id {
 __u8 id[8];
 kernel_ulong_t driver_data;
};

struct pnp_card_device_id {
 __u8 id[8];
 kernel_ulong_t driver_data;
 struct {
  __u8 id[8];
 } devs[8];
};




struct serio_device_id {
 __u8 type;
 __u8 extra;
 __u8 id;
 __u8 proto;
};

struct hda_device_id {
 __u32 vendor_id;
 __u32 rev_id;
 __u8 api_version;
 const char *name;
 unsigned long driver_data;
};

struct sdw_device_id {
 __u16 mfg_id;
 __u16 part_id;
 kernel_ulong_t driver_data;
};




struct of_device_id {
 char name[32];
 char type[32];
 char compatible[128];
 const void *data;
};


struct vio_device_id {
 char type[32];
 char compat[32];
};



struct pcmcia_device_id {
 __u16 match_flags;

 __u16 manf_id;
 __u16 card_id;

 __u8 func_id;


 __u8 function;


 __u8 device_no;

 __u32 prod_id_hash[4];


 const char * prod_id[4];


 kernel_ulong_t driver_info;
 char * cisfile;
};
# 340 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct input_device_id {

 kernel_ulong_t flags;

 __u16 bustype;
 __u16 vendor;
 __u16 product;
 __u16 version;

 kernel_ulong_t evbit[0x1f / 64 + 1];
 kernel_ulong_t keybit[0x2ff / 64 + 1];
 kernel_ulong_t relbit[0x0f / 64 + 1];
 kernel_ulong_t absbit[0x3f / 64 + 1];
 kernel_ulong_t mscbit[0x07 / 64 + 1];
 kernel_ulong_t ledbit[0x0f / 64 + 1];
 kernel_ulong_t sndbit[0x07 / 64 + 1];
 kernel_ulong_t ffbit[0x7f / 64 + 1];
 kernel_ulong_t swbit[0x0f / 64 + 1];
 kernel_ulong_t propbit[0x1f / 64 + 1];

 kernel_ulong_t driver_info;
};






struct eisa_device_id {
 char sig[8];
 kernel_ulong_t driver_data;
};



struct parisc_device_id {
 __u8 hw_type;
 __u8 hversion_rev;
 __u16 hversion;
 __u32 sversion;
};
# 391 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct sdio_device_id {
 __u8 class;
 __u16 vendor;
 __u16 device;
 kernel_ulong_t driver_data;
};


struct ssb_device_id {
 __u16 vendor;
 __u16 coreid;
 __u8 revision;
 __u8 __pad;
} __attribute__((packed, aligned(2)));
# 413 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct bcma_device_id {
 __u16 manuf;
 __u16 id;
 __u8 rev;
 __u8 class;
} __attribute__((packed,aligned(2)));
# 427 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct virtio_device_id {
 __u32 device;
 __u32 vendor;
};





struct hv_vmbus_device_id {
 uuid_le guid;
 kernel_ulong_t driver_data;
};






struct rpmsg_device_id {
 char name[32];
};






struct i2c_device_id {
 char name[20];
 kernel_ulong_t driver_data;
};






struct pci_epf_device_id {
 char name[20];
 kernel_ulong_t driver_data;
};
# 477 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct i3c_device_id {
 __u8 match_flags;
 __u8 dcr;
 __u16 manuf_id;
 __u16 part_id;
 __u16 extra_info;

 const void *data;
};






struct spi_device_id {
 char name[32];
 kernel_ulong_t driver_data;
};






struct slim_device_id {
 __u16 manf_id, prod_code;
 __u16 dev_index, instance;


 kernel_ulong_t driver_data;
};




struct apr_device_id {
 char name[32];
 __u32 domain_id;
 __u32 svc_id;
 __u32 svc_version;
 kernel_ulong_t driver_data;
};




struct spmi_device_id {
 char name[32];
 kernel_ulong_t driver_data;
};


enum dmi_field {
 DMI_NONE,
 DMI_BIOS_VENDOR,
 DMI_BIOS_VERSION,
 DMI_BIOS_DATE,
 DMI_SYS_VENDOR,
 DMI_PRODUCT_NAME,
 DMI_PRODUCT_VERSION,
 DMI_PRODUCT_SERIAL,
 DMI_PRODUCT_UUID,
 DMI_PRODUCT_SKU,
 DMI_PRODUCT_FAMILY,
 DMI_BOARD_VENDOR,
 DMI_BOARD_NAME,
 DMI_BOARD_VERSION,
 DMI_BOARD_SERIAL,
 DMI_BOARD_ASSET_TAG,
 DMI_CHASSIS_VENDOR,
 DMI_CHASSIS_TYPE,
 DMI_CHASSIS_VERSION,
 DMI_CHASSIS_SERIAL,
 DMI_CHASSIS_ASSET_TAG,
 DMI_STRING_MAX,
 DMI_OEM_STRING,
};

struct dmi_strmatch {
 unsigned char slot:7;
 unsigned char exact_match:1;
 char substr[79];
};

struct dmi_system_id {
 int (*callback)(const struct dmi_system_id *);
 const char *ident;
 struct dmi_strmatch matches[4];
 void *driver_data;
};
# 582 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct platform_device_id {
 char name[20];
 kernel_ulong_t driver_data;
};
# 609 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct mdio_device_id {
 __u32 phy_id;
 __u32 phy_id_mask;
};

struct zorro_device_id {
 __u32 id;
 kernel_ulong_t driver_data;
};






struct isapnp_device_id {
 unsigned short card_vendor, card_device;
 unsigned short vendor, function;
 kernel_ulong_t driver_data;
};
# 638 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct amba_id {
 unsigned int id;
 unsigned int mask;
 void *data;
};





struct mips_cdmm_device_id {
 __u8 type;
};
# 662 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct x86_cpu_id {
 __u16 vendor;
 __u16 family;
 __u16 model;
 __u16 feature;
 kernel_ulong_t driver_data;
};
# 683 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct cpu_feature {
 __u16 feature;
};



struct ipack_device_id {
 __u8 format;
 __u32 vendor;
 __u32 device;
};
# 708 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct mei_cl_device_id {
 char name[32];
 uuid_le uuid;
 __u8 version;
 kernel_ulong_t driver_info;
};
# 729 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct rio_device_id {
 __u16 did, vid;
 __u16 asm_did, asm_vid;
};

struct mcb_device_id {
 __u16 device;
 kernel_ulong_t driver_data;
};

struct ulpi_device_id {
 __u16 vendor;
 __u16 product;
 kernel_ulong_t driver_data;
};
# 753 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct fsl_mc_device_id {
 __u16 vendor;
 const char obj_type[16];
};
# 771 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct tb_service_id {
 __u32 match_flags;
 char protocol_key[8 + 1];
 __u32 protocol_id;
 __u32 protocol_version;
 __u32 protocol_revision;
 kernel_ulong_t driver_data;
};
# 795 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct typec_device_id {
 __u16 svid;
 __u8 mode;
 kernel_ulong_t driver_data;
};






struct tee_client_device_id {
 uuid_t uuid;
};
# 819 "/home/nathan/src/linux-next/include/linux/mod_devicetable.h"
struct wmi_device_id {
 const char guid_string[36 +1];
 const void *context;
};
# 28 "/home/nathan/src/linux-next/include/linux/pci.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/ioport.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/ioport.h"
struct resource {
 resource_size_t start;
 resource_size_t end;
 const char *name;
 unsigned long flags;
 unsigned long desc;
 struct resource *parent, *sibling, *child;
};
# 128 "/home/nathan/src/linux-next/include/linux/ioport.h"
enum {
 IORES_DESC_NONE = 0,
 IORES_DESC_CRASH_KERNEL = 1,
 IORES_DESC_ACPI_TABLES = 2,
 IORES_DESC_ACPI_NV_STORAGE = 3,
 IORES_DESC_PERSISTENT_MEMORY = 4,
 IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
 IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
 IORES_DESC_RESERVED = 7,
 IORES_DESC_SOFT_RESERVED = 8,
};




enum {
 IORES_MAP_SYSTEM_RAM = ((((1UL))) << (0)),
 IORES_MAP_ENCRYPTED = ((((1UL))) << (1)),
};
# 179 "/home/nathan/src/linux-next/include/linux/ioport.h"
extern struct resource ioport_resource;
extern struct resource iomem_resource;

extern struct resource *request_resource_conflict(struct resource *root, struct resource *new);
extern int request_resource(struct resource *root, struct resource *new);
extern int release_resource(struct resource *new);
void release_child_resources(struct resource *new);
extern void reserve_region_with_split(struct resource *root,
        resource_size_t start, resource_size_t end,
        const char *name);
extern struct resource *insert_resource_conflict(struct resource *parent, struct resource *new);
extern int insert_resource(struct resource *parent, struct resource *new);
extern void insert_resource_expand_to_fit(struct resource *root, struct resource *new);
extern int remove_resource(struct resource *old);
extern void arch_remove_reservations(struct resource *avail);
extern int allocate_resource(struct resource *root, struct resource *new,
        resource_size_t size, resource_size_t min,
        resource_size_t max, resource_size_t align,
        resource_size_t (*alignf)(void *,
             const struct resource *,
             resource_size_t,
             resource_size_t),
        void *alignf_data);
struct resource *lookup_resource(struct resource *root, resource_size_t start);
int adjust_resource(struct resource *res, resource_size_t start,
      resource_size_t size);
resource_size_t resource_alignment(struct resource *res);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) resource_size_t resource_size(const struct resource *res)
{
 return res->end - res->start + 1;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long resource_type(const struct resource *res)
{
 return res->flags & 0x00001f00;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long resource_ext_type(const struct resource *res)
{
 return res->flags & 0x01000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool resource_contains(struct resource *r1, struct resource *r2)
{
 if (resource_type(r1) != resource_type(r2))
  return false;
 if (r1->flags & 0x20000000 || r2->flags & 0x20000000)
  return false;
 return r1->start <= r2->start && r1->end >= r2->end;
}
# 238 "/home/nathan/src/linux-next/include/linux/ioport.h"
extern struct resource * __request_region(struct resource *,
     resource_size_t start,
     resource_size_t n,
     const char *name, int flags);





extern void __release_region(struct resource *, resource_size_t,
    resource_size_t);

extern int release_mem_region_adjustable(struct resource *, resource_size_t,
    resource_size_t);



struct device;

extern int devm_request_resource(struct device *dev, struct resource *root,
     struct resource *new);
extern void devm_release_resource(struct device *dev, struct resource *new);






extern struct resource * __devm_request_region(struct device *dev,
    struct resource *parent, resource_size_t start,
    resource_size_t n, const char *name);






extern void __devm_release_region(struct device *dev, struct resource *parent,
      resource_size_t start, resource_size_t n);
extern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);
extern bool iomem_is_exclusive(u64 addr);

extern int
walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
  void *arg, int (*func)(unsigned long, unsigned long, void *));
extern int
walk_mem_res(u64 start, u64 end, void *arg,
      int (*func)(struct resource *, void *));
extern int
walk_system_ram_res(u64 start, u64 end, void *arg,
      int (*func)(struct resource *, void *));
extern int
walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start, u64 end,
      void *arg, int (*func)(struct resource *, void *));


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool resource_overlaps(struct resource *r1, struct resource *r2)
{
       return (r1->start <= r2->end && r1->end >= r2->start);
}

struct resource *devm_request_free_mem_region(struct device *dev,
  struct resource *base, unsigned long size);
struct resource *request_free_mem_region(struct resource *base,
  unsigned long size, const char *name);
# 32 "/home/nathan/src/linux-next/include/linux/pci.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/device.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/device.h"
# 1 "/home/nathan/src/linux-next/include/linux/dev_printk.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/dev_printk.h"
# 1 "/home/nathan/src/linux-next/include/linux/ratelimit.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/ratelimit.h"
struct ratelimit_state {
 raw_spinlock_t lock;

 int interval;
 int burst;
 int printed;
 int missed;
 unsigned long begin;
 unsigned long flags;
};
# 40 "/home/nathan/src/linux-next/include/linux/ratelimit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_state_init(struct ratelimit_state *rs,
     int interval, int burst)
{
 memset(rs, 0, sizeof(*rs));

 do { *(&rs->lock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0);
 rs->interval = interval;
 rs->burst = burst;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_default_init(struct ratelimit_state *rs)
{
 return ratelimit_state_init(rs, (5 * 100),
     10);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ratelimit_state_exit(struct ratelimit_state *rs)
{
 if (!(rs->flags & ((((1UL))) << (0))))
  return;

 if (rs->missed) {
  printk("\001" "4" "%s: %d output lines suppressed due to ratelimiting\n", get_current()->comm, rs->missed);

  rs->missed = 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
ratelimit_set_flags(struct ratelimit_state *rs, unsigned long flags)
{
 rs->flags = flags;
}

extern struct ratelimit_state printk_ratelimit_state;

extern int ___ratelimit(struct ratelimit_state *rs, const char *func);
# 17 "/home/nathan/src/linux-next/include/linux/dev_printk.h" 2





struct device;



__attribute__((__format__(printf, 3, 0))) __attribute__((__cold__))
int dev_vprintk_emit(int level, const struct device *dev,
       const char *fmt, va_list args);
__attribute__((__format__(printf, 3, 4))) __attribute__((__cold__))
int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...);

__attribute__((__format__(printf, 3, 4))) __attribute__((__cold__))
void dev_printk(const char *level, const struct device *dev,
  const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_emerg(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_alert(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_crit(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_err(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_warn(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_notice(const struct device *dev, const char *fmt, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void _dev_info(const struct device *dev, const char *fmt, ...);
# 16 "/home/nathan/src/linux-next/include/linux/device.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/klist.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/klist.h"
struct klist_node;
struct klist {
 spinlock_t k_lock;
 struct list_head k_list;
 void (*get)(struct klist_node *);
 void (*put)(struct klist_node *);
} __attribute__ ((aligned (sizeof(void *))));
# 34 "/home/nathan/src/linux-next/include/linux/klist.h"
extern void klist_init(struct klist *k, void (*get)(struct klist_node *),
         void (*put)(struct klist_node *));

struct klist_node {
 void *n_klist;
 struct list_head n_node;
 struct kref n_ref;
};

extern void klist_add_tail(struct klist_node *n, struct klist *k);
extern void klist_add_head(struct klist_node *n, struct klist *k);
extern void klist_add_behind(struct klist_node *n, struct klist_node *pos);
extern void klist_add_before(struct klist_node *n, struct klist_node *pos);

extern void klist_del(struct klist_node *n);
extern void klist_remove(struct klist_node *n);

extern int klist_node_attached(struct klist_node *n);


struct klist_iter {
 struct klist *i_klist;
 struct klist_node *i_cur;
};


extern void klist_iter_init(struct klist *k, struct klist_iter *i);
extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,
     struct klist_node *n);
extern void klist_iter_exit(struct klist_iter *i);
extern struct klist_node *klist_prev(struct klist_iter *i);
extern struct klist_node *klist_next(struct klist_iter *i);
# 19 "/home/nathan/src/linux-next/include/linux/device.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/pm.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/pm.h"
extern void (*pm_power_off)(void);
extern void (*pm_power_off_prepare)(void);

struct device;

extern void pm_vt_switch_required(struct device *dev, bool required);
extern void pm_vt_switch_unregister(struct device *dev);
# 42 "/home/nathan/src/linux-next/include/linux/pm.h"
struct device;


extern const char power_group_name[];




typedef struct pm_message {
 int event;
} pm_message_t;
# 278 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_ops {
 int (*prepare)(struct device *dev);
 void (*complete)(struct device *dev);
 int (*suspend)(struct device *dev);
 int (*resume)(struct device *dev);
 int (*freeze)(struct device *dev);
 int (*thaw)(struct device *dev);
 int (*poweroff)(struct device *dev);
 int (*restore)(struct device *dev);
 int (*suspend_late)(struct device *dev);
 int (*resume_early)(struct device *dev);
 int (*freeze_late)(struct device *dev);
 int (*thaw_early)(struct device *dev);
 int (*poweroff_late)(struct device *dev);
 int (*restore_early)(struct device *dev);
 int (*suspend_noirq)(struct device *dev);
 int (*resume_noirq)(struct device *dev);
 int (*freeze_noirq)(struct device *dev);
 int (*thaw_noirq)(struct device *dev);
 int (*poweroff_noirq)(struct device *dev);
 int (*restore_noirq)(struct device *dev);
 int (*runtime_suspend)(struct device *dev);
 int (*runtime_resume)(struct device *dev);
 int (*runtime_idle)(struct device *dev);
};
# 496 "/home/nathan/src/linux-next/include/linux/pm.h"
enum rpm_status {
 RPM_ACTIVE = 0,
 RPM_RESUMING,
 RPM_SUSPENDED,
 RPM_SUSPENDING,
};
# 518 "/home/nathan/src/linux-next/include/linux/pm.h"
enum rpm_request {
 RPM_REQ_NONE = 0,
 RPM_REQ_IDLE,
 RPM_REQ_SUSPEND,
 RPM_REQ_AUTOSUSPEND,
 RPM_REQ_RESUME,
};

struct wakeup_source;
struct wake_irq;
struct pm_domain_data;

struct pm_subsys_data {
 spinlock_t lock;
 unsigned int refcount;






};
# 573 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_info {
 pm_message_t power_state;
 unsigned int can_wakeup:1;
 unsigned int async_suspend:1;
 bool in_dpm_list:1;
 bool is_prepared:1;
 bool is_suspended:1;
 bool is_noirq_suspended:1;
 bool is_late_suspended:1;
 bool no_pm:1;
 bool early_init:1;
 bool direct_complete:1;
 u32 driver_flags;
 spinlock_t lock;

 struct list_head entry;
 struct completion completion;
 struct wakeup_source *wakeup;
 bool wakeup_path:1;
 bool syscore:1;
 bool no_pm_callbacks:1;
 unsigned int must_resume:1;
 unsigned int may_skip_resume:1;




 struct hrtimer suspend_timer;
 unsigned long timer_expires;
 struct work_struct work;
 wait_queue_head_t wait_queue;
 struct wake_irq *wakeirq;
 atomic_t usage_count;
 atomic_t child_count;
 unsigned int disable_depth:3;
 unsigned int idle_notification:1;
 unsigned int request_pending:1;
 unsigned int deferred_resume:1;
 unsigned int runtime_auto:1;
 bool ignore_children:1;
 unsigned int no_callbacks:1;
 unsigned int irq_safe:1;
 unsigned int use_autosuspend:1;
 unsigned int timer_autosuspends:1;
 unsigned int memalloc_noio:1;
 unsigned int links_count;
 enum rpm_request request;
 enum rpm_status runtime_status;
 int runtime_error;
 int autosuspend_delay;
 u64 last_busy;
 u64 active_time;
 u64 suspended_time;
 u64 accounting_timestamp;

 struct pm_subsys_data *subsys_data;
 void (*set_latency_tolerance)(struct device *, s32);
 struct dev_pm_qos *qos;
};

extern int dev_pm_get_subsys_data(struct device *dev);
extern void dev_pm_put_subsys_data(struct device *dev);
# 650 "/home/nathan/src/linux-next/include/linux/pm.h"
struct dev_pm_domain {
 struct dev_pm_ops ops;
 int (*start)(struct device *dev);
 void (*detach)(struct device *dev, bool power_off);
 int (*activate)(struct device *dev);
 void (*sync)(struct device *dev);
 void (*dismiss)(struct device *dev);
};
# 714 "/home/nathan/src/linux-next/include/linux/pm.h"
extern void device_pm_lock(void);
extern void dpm_resume_start(pm_message_t state);
extern void dpm_resume_end(pm_message_t state);
extern void dpm_resume_noirq(pm_message_t state);
extern void dpm_resume_early(pm_message_t state);
extern void dpm_resume(pm_message_t state);
extern void dpm_complete(pm_message_t state);

extern void device_pm_unlock(void);
extern int dpm_suspend_end(pm_message_t state);
extern int dpm_suspend_start(pm_message_t state);
extern int dpm_suspend_noirq(pm_message_t state);
extern int dpm_suspend_late(pm_message_t state);
extern int dpm_suspend(pm_message_t state);
extern int dpm_prepare(pm_message_t state);

extern void __suspend_report_result(const char *function, void *fn, int ret);






extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));

extern int pm_generic_prepare(struct device *dev);
extern int pm_generic_suspend_late(struct device *dev);
extern int pm_generic_suspend_noirq(struct device *dev);
extern int pm_generic_suspend(struct device *dev);
extern int pm_generic_resume_early(struct device *dev);
extern int pm_generic_resume_noirq(struct device *dev);
extern int pm_generic_resume(struct device *dev);
extern int pm_generic_freeze_noirq(struct device *dev);
extern int pm_generic_freeze_late(struct device *dev);
extern int pm_generic_freeze(struct device *dev);
extern int pm_generic_thaw_noirq(struct device *dev);
extern int pm_generic_thaw_early(struct device *dev);
extern int pm_generic_thaw(struct device *dev);
extern int pm_generic_restore_noirq(struct device *dev);
extern int pm_generic_restore_early(struct device *dev);
extern int pm_generic_restore(struct device *dev);
extern int pm_generic_poweroff_noirq(struct device *dev);
extern int pm_generic_poweroff_late(struct device *dev);
extern int pm_generic_poweroff(struct device *dev);
extern void pm_generic_complete(struct device *dev);

extern bool dev_pm_may_skip_resume(struct device *dev);
extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
# 808 "/home/nathan/src/linux-next/include/linux/pm.h"
enum dpm_order {
 DPM_ORDER_NONE,
 DPM_ORDER_DEV_AFTER_PARENT,
 DPM_ORDER_PARENT_BEFORE_DEV,
 DPM_ORDER_DEV_LAST,
};
# 25 "/home/nathan/src/linux-next/include/linux/device.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/overflow.h" 1
# 253 "/home/nathan/src/linux-next/include/linux/overflow.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t array_size(size_t a, size_t b)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}
# 275 "/home/nathan/src/linux-next/include/linux/overflow.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t array3_size(size_t a, size_t b, size_t c)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);
 if (({ typeof(bytes) __a = (bytes); typeof(c) __b = (c); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) size_t __ab_c_size(size_t a, size_t b, size_t c)
{
 size_t bytes;

 if (({ typeof(a) __a = (a); typeof(b) __b = (b); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); }))
  return (~(size_t)0);
 if (({ typeof(bytes) __a = (bytes); typeof(c) __b = (c); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_add_overflow(__a, __b, __d); }))
  return (~(size_t)0);

 return bytes;
}
# 29 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device/bus.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/device/bus.h"
struct device_driver;
struct fwnode_handle;
# 82 "/home/nathan/src/linux-next/include/linux/device/bus.h"
struct bus_type {
 const char *name;
 const char *dev_name;
 struct device *dev_root;
 const struct attribute_group **bus_groups;
 const struct attribute_group **dev_groups;
 const struct attribute_group **drv_groups;

 int (*match)(struct device *dev, struct device_driver *drv);
 int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 int (*probe)(struct device *dev);
 void (*sync_state)(struct device *dev);
 int (*remove)(struct device *dev);
 void (*shutdown)(struct device *dev);

 int (*online)(struct device *dev);
 int (*offline)(struct device *dev);

 int (*suspend)(struct device *dev, pm_message_t state);
 int (*resume)(struct device *dev);

 int (*num_vf)(struct device *dev);

 int (*dma_configure)(struct device *dev);

 const struct dev_pm_ops *pm;

 const struct iommu_ops *iommu_ops;

 struct subsys_private *p;
 struct lock_class_key lock_key;

 bool need_parent_lock;
};

extern int __attribute__((__warn_unused_result__)) bus_register(struct bus_type *bus);

extern void bus_unregister(struct bus_type *bus);

extern int __attribute__((__warn_unused_result__)) bus_rescan_devices(struct bus_type *bus);

struct bus_attribute {
 struct attribute attr;
 ssize_t (*show)(struct bus_type *bus, char *buf);
 ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};
# 136 "/home/nathan/src/linux-next/include/linux/device/bus.h"
extern int __attribute__((__warn_unused_result__)) bus_create_file(struct bus_type *,
     struct bus_attribute *);
extern void bus_remove_file(struct bus_type *, struct bus_attribute *);


int device_match_name(struct device *dev, const void *name);
int device_match_of_node(struct device *dev, const void *np);
int device_match_fwnode(struct device *dev, const void *fwnode);
int device_match_devt(struct device *dev, const void *pdevt);
int device_match_acpi_dev(struct device *dev, const void *adev);
int device_match_any(struct device *dev, const void *unused);


struct subsys_dev_iter {
 struct klist_iter ki;
 const struct device_type *type;
};
void subsys_dev_iter_init(struct subsys_dev_iter *iter,
    struct bus_type *subsys,
    struct device *start,
    const struct device_type *type);
struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
void subsys_dev_iter_exit(struct subsys_dev_iter *iter);

int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
       int (*fn)(struct device *dev, void *data));
struct device *bus_find_device(struct bus_type *bus, struct device *start,
          const void *data,
          int (*match)(struct device *dev, const void *data));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *bus_find_device_by_name(struct bus_type *bus,
           struct device *start,
           const char *name)
{
 return bus_find_device(bus, start, name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_of_node(struct bus_type *bus, const struct device_node *np)
{
 return bus_find_device(bus, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_fwnode(struct bus_type *bus, const struct fwnode_handle *fwnode)
{
 return bus_find_device(bus, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *bus_find_device_by_devt(struct bus_type *bus,
           dev_t devt)
{
 return bus_find_device(bus, ((void *)0), &devt, device_match_devt);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_next_device(struct bus_type *bus,struct device *cur)
{
 return bus_find_device(bus, cur, ((void *)0), device_match_any);
}
# 242 "/home/nathan/src/linux-next/include/linux/device/bus.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
bus_find_device_by_acpi_dev(struct bus_type *bus, const void *adev)
{
 return ((void *)0);
}


struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
     struct device *hint);
int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
       void *data, int (*fn)(struct device_driver *, void *));
void bus_sort_breadthfirst(struct bus_type *bus,
      int (*compare)(const struct device *a,
       const struct device *b));






struct notifier_block;

extern int bus_register_notifier(struct bus_type *bus,
     struct notifier_block *nb);
extern int bus_unregister_notifier(struct bus_type *bus,
       struct notifier_block *nb);
# 285 "/home/nathan/src/linux-next/include/linux/device/bus.h"
extern struct kset *bus_get_kset(struct bus_type *bus);
extern struct klist *bus_get_device_klist(struct bus_type *bus);
# 30 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device/class.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct device;
struct fwnode_handle;
# 54 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct class {
 const char *name;
 struct module *owner;

 const struct attribute_group **class_groups;
 const struct attribute_group **dev_groups;
 struct kobject *dev_kobj;

 int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
 char *(*devnode)(struct device *dev, umode_t *mode);

 void (*class_release)(struct class *class);
 void (*dev_release)(struct device *dev);

 int (*shutdown_pre)(struct device *dev);

 const struct kobj_ns_type_operations *ns_type;
 const void *(*namespace)(struct device *dev);

 void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid);

 const struct dev_pm_ops *pm;

 struct subsys_private *p;
};

struct class_dev_iter {
 struct klist_iter ki;
 const struct device_type *type;
};

extern struct kobject *sysfs_dev_block_kobj;
extern struct kobject *sysfs_dev_char_kobj;
extern int __attribute__((__warn_unused_result__)) __class_register(struct class *class,
      struct lock_class_key *key);
extern void class_unregister(struct class *class);
# 99 "/home/nathan/src/linux-next/include/linux/device/class.h"
struct class_compat;
struct class_compat *class_compat_register(const char *name);
void class_compat_unregister(struct class_compat *cls);
int class_compat_create_link(struct class_compat *cls, struct device *dev,
        struct device *device_link);
void class_compat_remove_link(struct class_compat *cls, struct device *dev,
         struct device *device_link);

extern void class_dev_iter_init(struct class_dev_iter *iter,
    struct class *class,
    struct device *start,
    const struct device_type *type);
extern struct device *class_dev_iter_next(struct class_dev_iter *iter);
extern void class_dev_iter_exit(struct class_dev_iter *iter);

extern int class_for_each_device(struct class *class, struct device *start,
     void *data,
     int (*fn)(struct device *dev, void *data));
extern struct device *class_find_device(struct class *class,
     struct device *start, const void *data,
     int (*match)(struct device *, const void *));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *class_find_device_by_name(struct class *class,
             const char *name)
{
 return class_find_device(class, ((void *)0), name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_of_node(struct class *class, const struct device_node *np)
{
 return class_find_device(class, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_fwnode(struct class *class,
       const struct fwnode_handle *fwnode)
{
 return class_find_device(class, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *class_find_device_by_devt(struct class *class,
             dev_t devt)
{
 return class_find_device(class, ((void *)0), &devt, device_match_devt);
}
# 184 "/home/nathan/src/linux-next/include/linux/device/class.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
class_find_device_by_acpi_dev(struct class *class, const void *adev)
{
 return ((void *)0);
}


struct class_attribute {
 struct attribute attr;
 ssize_t (*show)(struct class *class, struct class_attribute *attr,
   char *buf);
 ssize_t (*store)(struct class *class, struct class_attribute *attr,
   const char *buf, size_t count);
};
# 206 "/home/nathan/src/linux-next/include/linux/device/class.h"
extern int __attribute__((__warn_unused_result__)) class_create_file_ns(struct class *class,
          const struct class_attribute *attr,
          const void *ns);
extern void class_remove_file_ns(struct class *class,
     const struct class_attribute *attr,
     const void *ns);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) class_create_file(struct class *class,
     const struct class_attribute *attr)
{
 return class_create_file_ns(class, attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void class_remove_file(struct class *class,
         const struct class_attribute *attr)
{
 return class_remove_file_ns(class, attr, ((void *)0));
}


struct class_attribute_string {
 struct class_attribute attr;
 char *str;
};
# 238 "/home/nathan/src/linux-next/include/linux/device/class.h"
extern ssize_t show_class_attr_string(struct class *class, struct class_attribute *attr,
                        char *buf);

struct class_interface {
 struct list_head node;
 struct class *class;

 int (*add_dev) (struct device *, struct class_interface *);
 void (*remove_dev) (struct device *, struct class_interface *);
};

extern int __attribute__((__warn_unused_result__)) class_interface_register(struct class_interface *);
extern void class_interface_unregister(struct class_interface *);

extern struct class * __attribute__((__warn_unused_result__)) __class_create(struct module *owner,
        const char *name,
        struct lock_class_key *key);
extern void class_destroy(struct class *cls);
# 31 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/device/driver.h" 1
# 44 "/home/nathan/src/linux-next/include/linux/device/driver.h"
enum probe_type {
 PROBE_DEFAULT_STRATEGY,
 PROBE_PREFER_ASYNCHRONOUS,
 PROBE_FORCE_SYNCHRONOUS,
};
# 95 "/home/nathan/src/linux-next/include/linux/device/driver.h"
struct device_driver {
 const char *name;
 struct bus_type *bus;

 struct module *owner;
 const char *mod_name;

 bool suppress_bind_attrs;
 enum probe_type probe_type;

 const struct of_device_id *of_match_table;
 const struct acpi_device_id *acpi_match_table;

 int (*probe) (struct device *dev);
 void (*sync_state)(struct device *dev);
 int (*remove) (struct device *dev);
 void (*shutdown) (struct device *dev);
 int (*suspend) (struct device *dev, pm_message_t state);
 int (*resume) (struct device *dev);
 const struct attribute_group **groups;
 const struct attribute_group **dev_groups;

 const struct dev_pm_ops *pm;
 void (*coredump) (struct device *dev);

 struct driver_private *p;
};


extern int __attribute__((__warn_unused_result__)) driver_register(struct device_driver *drv);
extern void driver_unregister(struct device_driver *drv);

extern struct device_driver *driver_find(const char *name,
      struct bus_type *bus);
extern int driver_probe_done(void);
extern void wait_for_device_probe(void);



struct driver_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device_driver *driver, char *buf);
 ssize_t (*store)(struct device_driver *driver, const char *buf,
    size_t count);
};
# 148 "/home/nathan/src/linux-next/include/linux/device/driver.h"
extern int __attribute__((__warn_unused_result__)) driver_create_file(struct device_driver *driver,
     const struct driver_attribute *attr);
extern void driver_remove_file(struct device_driver *driver,
          const struct driver_attribute *attr);

extern int __attribute__((__warn_unused_result__)) driver_for_each_device(struct device_driver *drv,
            struct device *start,
            void *data,
            int (*fn)(struct device *dev,
        void *));
struct device *driver_find_device(struct device_driver *drv,
      struct device *start, const void *data,
      int (*match)(struct device *dev, const void *data));







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_device_by_name(struct device_driver *drv,
       const char *name)
{
 return driver_find_device(drv, ((void *)0), name, device_match_name);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_of_node(struct device_driver *drv,
         const struct device_node *np)
{
 return driver_find_device(drv, ((void *)0), np, device_match_of_node);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_fwnode(struct device_driver *drv,
        const struct fwnode_handle *fwnode)
{
 return driver_find_device(drv, ((void *)0), fwnode, device_match_fwnode);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_device_by_devt(struct device_driver *drv,
       dev_t devt)
{
 return driver_find_device(drv, ((void *)0), &devt, device_match_devt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *driver_find_next_device(struct device_driver *drv,
           struct device *start)
{
 return driver_find_device(drv, start, ((void *)0), device_match_any);
}
# 232 "/home/nathan/src/linux-next/include/linux/device/driver.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *
driver_find_device_by_acpi_dev(struct device_driver *drv, const void *adev)
{
 return ((void *)0);
}


void driver_deferred_probe_add(struct device *dev);
int driver_deferred_probe_check_state(struct device *dev);
int driver_deferred_probe_check_state_continue(struct device *dev);
void driver_init(void);
# 32 "/home/nathan/src/linux-next/include/linux/device.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/device.h" 1







struct device_node;

struct pci_dn;
struct iommu_table;
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/device.h"
struct dev_archdata {




 bool iommu_bypass : 1;





 dma_addr_t dma_offset;


 struct iommu_table *iommu_table_base;



 void *iommu_domain;


 struct pci_dn *pci_data;


 struct eeh_dev *edev;





 struct cxl_context *cxl_ctx;

};

struct pdev_archdata {
 u64 dma_mask;
};
# 33 "/home/nathan/src/linux-next/include/linux/device.h" 2

struct device;
struct device_private;
struct device_driver;
struct driver_private;
struct module;
struct class;
struct subsys_private;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct iommu_fwspec;
struct dev_pin_info;
struct iommu_param;
# 62 "/home/nathan/src/linux-next/include/linux/device.h"
struct subsys_interface {
 const char *name;
 struct bus_type *subsys;
 struct list_head node;
 int (*add_dev)(struct device *dev, struct subsys_interface *sif);
 void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};

int subsys_interface_register(struct subsys_interface *sif);
void subsys_interface_unregister(struct subsys_interface *sif);

int subsys_system_register(struct bus_type *subsys,
      const struct attribute_group **groups);
int subsys_virtual_register(struct bus_type *subsys,
       const struct attribute_group **groups);
# 87 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_type {
 const char *name;
 const struct attribute_group **groups;
 int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 char *(*devnode)(struct device *dev, umode_t *mode,
    kuid_t *uid, kgid_t *gid);
 void (*release)(struct device *dev);

 const struct dev_pm_ops *pm;
};


struct device_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device *dev, struct device_attribute *attr,
   char *buf);
 ssize_t (*store)(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
};

struct dev_ext_attribute {
 struct device_attribute attr;
 void *var;
};

ssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,
     char *buf);
ssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,
      const char *buf, size_t count);
ssize_t device_show_int(struct device *dev, struct device_attribute *attr,
   char *buf);
ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
   char *buf);
ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
    const char *buf, size_t count);
# 149 "/home/nathan/src/linux-next/include/linux/device.h"
extern int device_create_file(struct device *device,
         const struct device_attribute *entry);
extern void device_remove_file(struct device *dev,
          const struct device_attribute *attr);
extern bool device_remove_file_self(struct device *dev,
        const struct device_attribute *attr);
extern int __attribute__((__warn_unused_result__)) device_create_bin_file(struct device *dev,
     const struct bin_attribute *attr);
extern void device_remove_bin_file(struct device *dev,
       const struct bin_attribute *attr);


typedef void (*dr_release_t)(struct device *dev, void *res);
typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);
# 172 "/home/nathan/src/linux-next/include/linux/device.h"
extern void *devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
          int nid) __attribute__((__malloc__));
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp)
{
 return devres_alloc_node(release, size, gfp, (-1));
}


extern void devres_for_each_res(struct device *dev, dr_release_t release,
    dr_match_t match, void *match_data,
    void (*fn)(struct device *, void *, void *),
    void *data);
extern void devres_free(void *res);
extern void devres_add(struct device *dev, void *res);
extern void *devres_find(struct device *dev, dr_release_t release,
    dr_match_t match, void *match_data);
extern void *devres_get(struct device *dev, void *new_res,
   dr_match_t match, void *match_data);
extern void *devres_remove(struct device *dev, dr_release_t release,
      dr_match_t match, void *match_data);
extern int devres_destroy(struct device *dev, dr_release_t release,
     dr_match_t match, void *match_data);
extern int devres_release(struct device *dev, dr_release_t release,
     dr_match_t match, void *match_data);


extern void * __attribute__((__warn_unused_result__)) devres_open_group(struct device *dev, void *id,
          gfp_t gfp);
extern void devres_close_group(struct device *dev, void *id);
extern void devres_remove_group(struct device *dev, void *id);
extern int devres_release_group(struct device *dev, void *id);


extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) __attribute__((__malloc__));
extern __attribute__((__format__(printf, 3, 0)))
char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
        va_list ap) __attribute__((__malloc__));
extern __attribute__((__format__(printf, 3, 4)))
char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...) __attribute__((__malloc__));
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
 return devm_kmalloc(dev, size, gfp | (( gfp_t)0x100u));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kmalloc_array(struct device *dev,
           size_t n, size_t size, gfp_t flags)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);

 return devm_kmalloc(dev, bytes, flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_kcalloc(struct device *dev,
     size_t n, size_t size, gfp_t flags)
{
 return devm_kmalloc_array(dev, n, size, flags | (( gfp_t)0x100u));
}
extern void devm_kfree(struct device *dev, const void *p);
extern char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp) __attribute__((__malloc__));
extern const char *devm_kstrdup_const(struct device *dev,
          const char *s, gfp_t gfp);
extern void *devm_kmemdup(struct device *dev, const void *src, size_t len,
     gfp_t gfp);

extern unsigned long devm_get_free_pages(struct device *dev,
      gfp_t gfp_mask, unsigned int order);
extern void devm_free_pages(struct device *dev, unsigned long addr);

void *devm_ioremap_resource(struct device *dev,
        const struct resource *res);
void *devm_ioremap_resource_wc(struct device *dev,
           const struct resource *res);

void *devm_of_iomap(struct device *dev,
       struct device_node *node, int index,
       resource_size_t *size);


int devm_add_action(struct device *dev, void (*action)(void *), void *data);
void devm_remove_action(struct device *dev, void (*action)(void *), void *data);
void devm_release_action(struct device *dev, void (*action)(void *), void *data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int devm_add_action_or_reset(struct device *dev,
        void (*action)(void *), void *data)
{
 int ret;

 ret = devm_add_action(dev, action, data);
 if (ret)
  action(data);

 return ret;
}
# 282 "/home/nathan/src/linux-next/include/linux/device.h"
void *__devm_alloc_percpu(struct device *dev, size_t size,
       size_t align);
void devm_free_percpu(struct device *dev, void *pdata);

struct device_dma_parameters {




 unsigned int max_segment_size;
 unsigned long segment_boundary_mask;
};
# 306 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_connection {
 struct fwnode_handle *fwnode;
 const char *endpoint[2];
 const char *id;
 struct list_head list;
};

typedef void *(*devcon_match_fn_t)(struct device_connection *con, int ep,
       void *data);

void *fwnode_connection_find_match(struct fwnode_handle *fwnode,
       const char *con_id, void *data,
       devcon_match_fn_t match);
void *device_connection_find_match(struct device *dev, const char *con_id,
       void *data, devcon_match_fn_t match);

struct device *device_connection_find(struct device *dev, const char *con_id);

void device_connection_add(struct device_connection *con);
void device_connection_remove(struct device_connection *con);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_connections_add(struct device_connection *cons)
{
 struct device_connection *c;

 for (c = cons; c->endpoint[0]; c++)
  device_connection_add(c);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_connections_remove(struct device_connection *cons)
{
 struct device_connection *c;

 for (c = cons; c->endpoint[0]; c++)
  device_connection_remove(c);
}
# 360 "/home/nathan/src/linux-next/include/linux/device.h"
enum device_link_state {
 DL_STATE_NONE = -1,
 DL_STATE_DORMANT = 0,
 DL_STATE_AVAILABLE,
 DL_STATE_CONSUMER_PROBE,
 DL_STATE_ACTIVE,
 DL_STATE_SUPPLIER_UNBIND,
};
# 403 "/home/nathan/src/linux-next/include/linux/device.h"
struct device_link {
 struct device *supplier;
 struct list_head s_node;
 struct device *consumer;
 struct list_head c_node;
 enum device_link_state status;
 u32 flags;
 refcount_t rpm_active;
 struct kref kref;

 struct callback_head callback_head;

 bool supplier_preactivated;
};
# 425 "/home/nathan/src/linux-next/include/linux/device.h"
enum dl_dev_state {
 DL_DEV_NO_DRIVER = 0,
 DL_DEV_PROBING,
 DL_DEV_DRIVER_BOUND,
 DL_DEV_UNBINDING,
};
# 442 "/home/nathan/src/linux-next/include/linux/device.h"
struct dev_links_info {
 struct list_head suppliers;
 struct list_head consumers;
 struct list_head needs_suppliers;
 struct list_head defer_sync;
 bool need_for_probe;
 enum dl_dev_state status;
};
# 537 "/home/nathan/src/linux-next/include/linux/device.h"
struct device {
 struct kobject kobj;
 struct device *parent;

 struct device_private *p;

 const char *init_name;
 const struct device_type *type;

 struct bus_type *bus;
 struct device_driver *driver;

 void *platform_data;

 void *driver_data;




 struct mutex mutex;



 struct dev_links_info links;
 struct dev_pm_info power;
 struct dev_pm_domain *pm_domain;


 struct irq_domain *msi_domain;





 struct list_head msi_list;


 const struct dma_map_ops *dma_ops;
 u64 *dma_mask;
 u64 coherent_dma_mask;




 u64 bus_dma_limit;
 unsigned long dma_pfn_offset;

 struct device_dma_parameters *dma_parms;

 struct list_head dma_pools;


 struct dma_coherent_mem *dma_mem;







 struct dev_archdata archdata;

 struct device_node *of_node;
 struct fwnode_handle *fwnode;


 int numa_node;

 dev_t devt;
 u32 id;

 spinlock_t devres_lock;
 struct list_head devres_head;

 struct class *class;
 const struct attribute_group **groups;

 void (*release)(struct device *dev);
 struct iommu_group *iommu_group;
 struct iommu_fwspec *iommu_fwspec;
 struct iommu_param *iommu_param;

 bool offline_disabled:1;
 bool offline:1;
 bool of_node_reused:1;
 bool state_synced:1;





};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device *kobj_to_dev(struct kobject *kobj)
{
 return ({ void *__mptr = (void *)(kobj); do { extern void __compiletime_assert_632(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(kobj)), typeof(((struct device *)0)->kobj)) && !__builtin_types_compatible_p(typeof(*(kobj)), typeof(void))))) __compiletime_assert_632(); } while (0); ((struct device *)(__mptr - __builtin_offsetof(struct device, kobj))); });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_iommu_mapped(struct device *dev)
{
 return (dev->iommu_group != ((void *)0));
}



# 1 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
struct wake_irq;
# 43 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
struct wakeup_source {
 const char *name;
 int id;
 struct list_head entry;
 spinlock_t lock;
 struct wake_irq *wakeirq;
 struct timer_list timer;
 unsigned long timer_expires;
 ktime_t total_time;
 ktime_t max_time;
 ktime_t last_time;
 ktime_t start_prevent_time;
 ktime_t prevent_sleep_time;
 unsigned long event_count;
 unsigned long active_count;
 unsigned long relax_count;
 unsigned long expire_count;
 unsigned long wakeup_count;
 struct device *dev;
 bool active:1;
 bool autosleep_enabled:1;
};
# 77 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_can_wakeup(struct device *dev)
{
 return dev->power.can_wakeup;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_may_wakeup(struct device *dev)
{
 return dev->power.can_wakeup && !!dev->power.wakeup;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_set_wakeup_path(struct device *dev)
{
 dev->power.wakeup_path = true;
}


extern struct wakeup_source *wakeup_source_create(const char *name);
extern void wakeup_source_destroy(struct wakeup_source *ws);
extern void wakeup_source_add(struct wakeup_source *ws);
extern void wakeup_source_remove(struct wakeup_source *ws);
extern struct wakeup_source *wakeup_source_register(struct device *dev,
          const char *name);
extern void wakeup_source_unregister(struct wakeup_source *ws);
extern int wakeup_sources_read_lock(void);
extern void wakeup_sources_read_unlock(int idx);
extern struct wakeup_source *wakeup_sources_walk_start(void);
extern struct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws);
extern int device_wakeup_enable(struct device *dev);
extern int device_wakeup_disable(struct device *dev);
extern void device_set_wakeup_capable(struct device *dev, bool capable);
extern int device_init_wakeup(struct device *dev, bool val);
extern int device_set_wakeup_enable(struct device *dev, bool enable);
extern void __pm_stay_awake(struct wakeup_source *ws);
extern void pm_stay_awake(struct device *dev);
extern void __pm_relax(struct wakeup_source *ws);
extern void pm_relax(struct device *dev);
extern void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard);
extern void pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard);
# 195 "/home/nathan/src/linux-next/include/linux/pm_wakeup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
{
 return pm_wakeup_ws_event(ws, msec, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pm_wakeup_event(struct device *dev, unsigned int msec)
{
 return pm_wakeup_dev_event(dev, msec, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pm_wakeup_hard_event(struct device *dev)
{
 return pm_wakeup_dev_event(dev, 0, true);
}
# 647 "/home/nathan/src/linux-next/include/linux/device.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *dev_name(const struct device *dev)
{

 if (dev->init_name)
  return dev->init_name;

 return kobject_name(&dev->kobj);
}

extern __attribute__((__format__(printf, 2, 3)))
int dev_set_name(struct device *dev, const char *name, ...);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_to_node(struct device *dev)
{
 return dev->numa_node;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_dev_node(struct device *dev, int node)
{
 dev->numa_node = node;
}
# 679 "/home/nathan/src/linux-next/include/linux/device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *dev_get_msi_domain(const struct device *dev)
{

 return dev->msi_domain;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
{

 dev->msi_domain = d;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dev_get_drvdata(const struct device *dev)
{
 return dev->driver_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_drvdata(struct device *dev, void *data)
{
 dev->driver_data = data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pm_subsys_data *dev_to_psd(struct device *dev)
{
 return dev ? dev->power.subsys_data : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dev_get_uevent_suppress(const struct device *dev)
{
 return dev->kobj.uevent_suppress;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_set_uevent_suppress(struct device *dev, int val)
{
 dev->kobj.uevent_suppress = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_is_registered(struct device *dev)
{
 return dev->kobj.state_in_sysfs;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_enable_async_suspend(struct device *dev)
{
 if (!dev->power.is_prepared)
  dev->power.async_suspend = true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_disable_async_suspend(struct device *dev)
{
 if (!dev->power.is_prepared)
  dev->power.async_suspend = false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_async_suspend_enabled(struct device *dev)
{
 return !!dev->power.async_suspend;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_pm_not_required(struct device *dev)
{
 return dev->power.no_pm;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_set_pm_not_required(struct device *dev)
{
 dev->power.no_pm = true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_pm_syscore_device(struct device *dev, bool val)
{

 dev->power.syscore = val;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_pm_set_driver_flags(struct device *dev, u32 flags)
{
 dev->power.driver_flags = flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_pm_test_driver_flags(struct device *dev, u32 flags)
{
 return !!(dev->power.driver_flags & flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_lock(struct device *dev)
{
 mutex_lock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_lock_interruptible(struct device *dev)
{
 return mutex_lock_interruptible(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_trylock(struct device *dev)
{
 return mutex_trylock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_unlock(struct device *dev)
{
 mutex_unlock(&dev->mutex);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_lock_assert(struct device *dev)
{
 do { (void)(&dev->mutex); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *dev_of_node(struct device *dev)
{
 if (!1 || !dev)
  return ((void *)0);
 return dev->of_node;
}




extern int __attribute__((__warn_unused_result__)) device_register(struct device *dev);
extern void device_unregister(struct device *dev);
extern void device_initialize(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_add(struct device *dev);
extern void device_del(struct device *dev);
extern int device_for_each_child(struct device *dev, void *data,
       int (*fn)(struct device *dev, void *data));
extern int device_for_each_child_reverse(struct device *dev, void *data,
       int (*fn)(struct device *dev, void *data));
extern struct device *device_find_child(struct device *dev, void *data,
    int (*match)(struct device *dev, void *data));
extern struct device *device_find_child_by_name(struct device *parent,
      const char *name);
extern int device_rename(struct device *dev, const char *new_name);
extern int device_move(struct device *dev, struct device *new_parent,
         enum dpm_order dpm_order);
extern const char *device_get_devnode(struct device *dev,
          umode_t *mode, kuid_t *uid, kgid_t *gid,
          const char **tmp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_supports_offline(struct device *dev)
{
 return dev->bus && dev->bus->offline && dev->bus->online;
}

extern void lock_device_hotplug(void);
extern void unlock_device_hotplug(void);
extern int lock_device_hotplug_sysfs(void);
extern int device_offline(struct device *dev);
extern int device_online(struct device *dev);
extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
extern void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
void device_set_of_node_from_dev(struct device *dev, const struct device *dev2);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_num_vf(struct device *dev)
{
 if (dev->bus && dev->bus->num_vf)
  return dev->bus->num_vf(dev);
 return 0;
}




extern struct device *__root_device_register(const char *name,
          struct module *owner);





extern void root_device_unregister(struct device *root);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dev_get_platdata(const struct device *dev)
{
 return dev->platform_data;
}





extern int __attribute__((__warn_unused_result__)) device_bind_driver(struct device *dev);
extern void device_release_driver(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_attach(struct device *dev);
extern int __attribute__((__warn_unused_result__)) driver_attach(struct device_driver *drv);
extern void device_initial_probe(struct device *dev);
extern int __attribute__((__warn_unused_result__)) device_reprobe(struct device *dev);

extern bool device_is_bound(struct device *dev);




extern __attribute__((__format__(printf, 5, 0)))
struct device *device_create_vargs(struct class *cls, struct device *parent,
       dev_t devt, void *drvdata,
       const char *fmt, va_list vargs);
extern __attribute__((__format__(printf, 5, 6)))
struct device *device_create(struct class *cls, struct device *parent,
        dev_t devt, void *drvdata,
        const char *fmt, ...);
extern __attribute__((__format__(printf, 6, 7)))
struct device *device_create_with_groups(struct class *cls,
        struct device *parent, dev_t devt, void *drvdata,
        const struct attribute_group **groups,
        const char *fmt, ...);
extern void device_destroy(struct class *cls, dev_t devt);

extern int __attribute__((__warn_unused_result__)) device_add_groups(struct device *dev,
     const struct attribute_group **groups);
extern void device_remove_groups(struct device *dev,
     const struct attribute_group **groups);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) device_add_group(struct device *dev,
     const struct attribute_group *grp)
{
 const struct attribute_group *groups[] = { grp, ((void *)0) };

 return device_add_groups(dev, groups);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void device_remove_group(struct device *dev,
           const struct attribute_group *grp)
{
 const struct attribute_group *groups[] = { grp, ((void *)0) };

 return device_remove_groups(dev, groups);
}

extern int __attribute__((__warn_unused_result__)) devm_device_add_groups(struct device *dev,
     const struct attribute_group **groups);
extern void devm_device_remove_groups(struct device *dev,
          const struct attribute_group **groups);
extern int __attribute__((__warn_unused_result__)) devm_device_add_group(struct device *dev,
     const struct attribute_group *grp);
extern void devm_device_remove_group(struct device *dev,
         const struct attribute_group *grp);







extern int (*platform_notify)(struct device *dev);

extern int (*platform_notify_remove)(struct device *dev);






extern struct device *get_device(struct device *dev);
extern void put_device(struct device *dev);
extern bool kill_device(struct device *dev);


extern int devtmpfs_mount(void);





extern void device_shutdown(void);


extern const char *dev_driver_string(const struct device *dev);


struct device_link *device_link_add(struct device *consumer,
        struct device *supplier, u32 flags);
void device_link_del(struct device_link *link);
void device_link_remove(void *consumer, struct device *supplier);
void device_links_supplier_sync_state_pause(void);
void device_links_supplier_sync_state_resume(void);
# 38 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/interrupt.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/interrupt.h"
# 1 "/home/nathan/src/linux-next/include/linux/irqnr.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/irqnr.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/irqnr.h" 2


extern int nr_irqs;
extern struct irq_desc *irq_to_desc(unsigned int irq);
unsigned int irq_get_next_irq(unsigned int offset);
# 11 "/home/nathan/src/linux-next/include/linux/interrupt.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/hardirq.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/ftrace_irq.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/ftrace_irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_ftrace_nmi_enter(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_ftrace_nmi_exit(void) { }







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ftrace_nmi_enter(void)
{




 arch_ftrace_nmi_enter();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ftrace_nmi_exit(void)
{
 arch_ftrace_nmi_exit();




}
# 8 "/home/nathan/src/linux-next/include/linux/hardirq.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/vtime.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/context_tracking_state.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 7 "/home/nathan/src/linux-next/include/linux/context_tracking_state.h" 2

struct context_tracking {






 bool active;
 int recursion;
 enum ctx_state {
  CONTEXT_DISABLED = -1,
  CONTEXT_KERNEL = 0,
  CONTEXT_USER,
  CONTEXT_GUEST,
 } state;
};
# 49 "/home/nathan/src/linux-next/include/linux/context_tracking_state.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool context_tracking_in_user(void) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool context_tracking_enabled(void) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool context_tracking_enabled_cpu(int cpu) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool context_tracking_enabled_this_cpu(void) { return false; }
# 6 "/home/nathan/src/linux-next/include/linux/vtime.h" 2

# 1 "./arch/powerpc/include/generated/asm/vtime.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/vtime.h" 1
# 2 "./arch/powerpc/include/generated/asm/vtime.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/vtime.h" 2



struct task_struct;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vtime_accounting_enabled_this_cpu(void) { return true; }
extern void vtime_task_switch(struct task_struct *prev);
# 64 "/home/nathan/src/linux-next/include/linux/vtime.h"
extern void vtime_account_kernel(struct task_struct *tsk);
extern void vtime_account_idle(struct task_struct *tsk);
# 78 "/home/nathan/src/linux-next/include/linux/vtime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_user_enter(struct task_struct *tsk) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_user_exit(struct task_struct *tsk) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_guest_enter(struct task_struct *tsk) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_guest_exit(struct task_struct *tsk) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_init_idle(struct task_struct *tsk, int cpu) { }



extern void vtime_account_irq_enter(struct task_struct *tsk);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vtime_account_irq_exit(struct task_struct *tsk)
{

 vtime_account_kernel(tsk);
}
extern void vtime_flush(struct task_struct *tsk);
# 103 "/home/nathan/src/linux-next/include/linux/vtime.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqtime_account_irq(struct task_struct *tsk) { }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void account_irq_enter_time(struct task_struct *tsk)
{
 vtime_account_irq_enter(tsk);
 irqtime_account_irq(tsk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void account_irq_exit_time(struct task_struct *tsk)
{
 vtime_account_irq_exit(tsk);
 irqtime_account_irq(tsk);
}
# 9 "/home/nathan/src/linux-next/include/linux/hardirq.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hardirq.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/irq.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/irq.h"
# 1 "/home/nathan/src/linux-next/include/linux/irqhandler.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/irqhandler.h"
struct irq_desc;
struct irq_data;
typedef void (*irq_flow_handler_t)(struct irq_desc *desc);
typedef void (*irq_preflow_handler_t)(struct irq_data *data);
# 17 "/home/nathan/src/linux-next/include/linux/irq.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/io.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/io.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 1
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern int check_legacy_ioport(unsigned long base_port);




extern struct pci_dev *isa_bridge_pcidev;
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
# 1 "/home/nathan/src/linux-next/include/linux/mm.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/mm.h"
# 1 "/home/nathan/src/linux-next/include/linux/range.h" 1




struct range {
 u64 start;
 u64 end;
};

int add_range(struct range *range, int az, int nr_range,
  u64 start, u64 end);


int add_range_with_merge(struct range *range, int az, int nr_range,
    u64 start, u64 end);

void subtract_range(struct range *range, int az, u64 start, u64 end);

int clean_sort_range(struct range *range, int az);

void sort_range(struct range *range, int nr_range);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) resource_size_t cap_resource(u64 val)
{
 if (val > ((resource_size_t)~0))
  return ((resource_size_t)~0);

 return val;
}
# 19 "/home/nathan/src/linux-next/include/linux/mm.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h" 1
# 59 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
struct percpu_ref;
typedef void (percpu_ref_func_t)(struct percpu_ref *);


enum {
 __PERCPU_REF_ATOMIC = 1LU << 0,
 __PERCPU_REF_DEAD = 1LU << 1,
 __PERCPU_REF_ATOMIC_DEAD = __PERCPU_REF_ATOMIC | __PERCPU_REF_DEAD,

 __PERCPU_REF_FLAG_BITS = 2,
};


enum {







 PERCPU_REF_INIT_ATOMIC = 1 << 0,






 PERCPU_REF_INIT_DEAD = 1 << 1,




 PERCPU_REF_ALLOW_REINIT = 1 << 2,
};

struct percpu_ref {
 atomic_long_t count;




 unsigned long percpu_count_ptr;
 percpu_ref_func_t *release;
 percpu_ref_func_t *confirm_switch;
 bool force_atomic:1;
 bool allow_reinit:1;
 struct callback_head rcu;
};

int __attribute__((__warn_unused_result__)) percpu_ref_init(struct percpu_ref *ref,
     percpu_ref_func_t *release, unsigned int flags,
     gfp_t gfp);
void percpu_ref_exit(struct percpu_ref *ref);
void percpu_ref_switch_to_atomic(struct percpu_ref *ref,
     percpu_ref_func_t *confirm_switch);
void percpu_ref_switch_to_atomic_sync(struct percpu_ref *ref);
void percpu_ref_switch_to_percpu(struct percpu_ref *ref);
void percpu_ref_kill_and_confirm(struct percpu_ref *ref,
     percpu_ref_func_t *confirm_kill);
void percpu_ref_resurrect(struct percpu_ref *ref);
void percpu_ref_reinit(struct percpu_ref *ref);
# 134 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_kill(struct percpu_ref *ref)
{
 percpu_ref_kill_and_confirm(ref, ((void *)0));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __ref_is_percpu(struct percpu_ref *ref,
       unsigned long **percpu_countp)
{
 unsigned long percpu_ptr;
# 161 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
 percpu_ptr = ({ union { typeof(ref->percpu_count_ptr) __val; char __c[1]; } __u; if (1) __read_once_size(&(ref->percpu_count_ptr), __u.__c, sizeof(ref->percpu_count_ptr)); else __read_once_size_nocheck(&(ref->percpu_count_ptr), __u.__c, sizeof(ref->percpu_count_ptr)); do { } while (0); __u.__val; });







 if (__builtin_expect(!!(percpu_ptr & __PERCPU_REF_ATOMIC_DEAD), 0))
  return false;

 *percpu_countp = (unsigned long *)percpu_ptr;
 return true;
}
# 185 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_get_many(struct percpu_ref *ref, unsigned long nr)
{
 unsigned long *percpu_count;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count))
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 else
  atomic_long_add(nr, &ref->count);

 rcu_read_unlock();
}
# 207 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_get(struct percpu_ref *ref)
{
 percpu_ref_get_many(ref, 1);
}
# 222 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget_many(struct percpu_ref *ref,
       unsigned long nr)
{
 unsigned long *percpu_count;
 bool ret;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count)) {
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += nr; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
  ret = true;
 } else {
  ret = atomic_long_add_unless(&ref->count, nr, 0);
 }

 rcu_read_unlock();

 return ret;
}
# 251 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget(struct percpu_ref *ref)
{
 return percpu_ref_tryget_many(ref, 1);
}
# 271 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_tryget_live(struct percpu_ref *ref)
{
 unsigned long *percpu_count;
 bool ret = false;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count)) {
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
  ret = true;
 } else if (!(ref->percpu_count_ptr & __PERCPU_REF_DEAD)) {
  ret = atomic_long_inc_not_zero(&ref->count);
 }

 rcu_read_unlock();

 return ret;
}
# 300 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_put_many(struct percpu_ref *ref, unsigned long nr)
{
 unsigned long *percpu_count;

 rcu_read_lock();

 if (__ref_is_percpu(ref, &percpu_count))
  do { do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*percpu_count)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*percpu_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*percpu_count))) *)(&(*percpu_count))); (typeof((typeof(*(&(*percpu_count))) *)(&(*percpu_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*percpu_count))(nr); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 else if (__builtin_expect(!!(atomic_long_sub_and_test(nr, &ref->count)), 0))
  ref->release(ref);

 rcu_read_unlock();
}
# 323 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_ref_put(struct percpu_ref *ref)
{
 percpu_ref_put_many(ref, 1);
}
# 337 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_is_dying(struct percpu_ref *ref)
{
 return ref->percpu_count_ptr & __PERCPU_REF_DEAD;
}
# 350 "/home/nathan/src/linux-next/include/linux/percpu-refcount.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_ref_is_zero(struct percpu_ref *ref)
{
 unsigned long *percpu_count;

 if (__ref_is_percpu(ref, &percpu_count))
  return false;
 return !atomic_long_read(&ref->count);
}
# 21 "/home/nathan/src/linux-next/include/linux/mm.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/bit_spinlock.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/bit_spinlock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bit_spin_lock(int bitnum, unsigned long *addr)
{







 __asm__ __volatile__("" : : : "memory");

 while (__builtin_expect(!!(test_and_set_bit_lock(bitnum, addr)), 0)) {
  __asm__ __volatile__("" : : : "memory");
  do {
   do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
  } while (test_bit(bitnum, addr));
  __asm__ __volatile__("" : : : "memory");
 }

 (void)0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bit_spin_trylock(int bitnum, unsigned long *addr)
{
 __asm__ __volatile__("" : : : "memory");

 if (__builtin_expect(!!(test_and_set_bit_lock(bitnum, addr)), 0)) {
  __asm__ __volatile__("" : : : "memory");
  return 0;
 }

 (void)0;
 return 1;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bit_spin_unlock(int bitnum, unsigned long *addr)
{




 clear_bit_unlock(bitnum, addr);

 __asm__ __volatile__("" : : : "memory");
 (void)0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __bit_spin_unlock(int bitnum, unsigned long *addr)
{




 __clear_bit_unlock(bitnum, addr);

 __asm__ __volatile__("" : : : "memory");
 (void)0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bit_spin_is_locked(int bitnum, unsigned long *addr)
{

 return test_bit(bitnum, addr);





}
# 22 "/home/nathan/src/linux-next/include/linux/mm.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/shrinker.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/shrinker.h"
struct shrink_control {
 gfp_t gfp_mask;


 int nid;






 unsigned long nr_to_scan;






 unsigned long nr_scanned;


 struct mem_cgroup *memcg;
};
# 60 "/home/nathan/src/linux-next/include/linux/shrinker.h"
struct shrinker {
 unsigned long (*count_objects)(struct shrinker *,
           struct shrink_control *sc);
 unsigned long (*scan_objects)(struct shrinker *,
          struct shrink_control *sc);

 long batch;
 int seeks;
 unsigned flags;


 struct list_head list;


 int id;


 atomic_long_t *nr_deferred;
};
# 90 "/home/nathan/src/linux-next/include/linux/shrinker.h"
extern int prealloc_shrinker(struct shrinker *shrinker);
extern void register_shrinker_prepared(struct shrinker *shrinker);
extern int register_shrinker(struct shrinker *shrinker);
extern void unregister_shrinker(struct shrinker *shrinker);
extern void free_prealloced_shrinker(struct shrinker *shrinker);
# 23 "/home/nathan/src/linux-next/include/linux/mm.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/page_ext.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/stacktrace.h" 1







struct task_struct;
struct pt_regs;


void stack_trace_print(const unsigned long *trace, unsigned int nr_entries,
         int spaces);
int stack_trace_snprint(char *buf, size_t size, const unsigned long *entries,
   unsigned int nr_entries, int spaces);
unsigned int stack_trace_save(unsigned long *store, unsigned int size,
         unsigned int skipnr);
unsigned int stack_trace_save_tsk(struct task_struct *task,
      unsigned long *store, unsigned int size,
      unsigned int skipnr);
unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
       unsigned int size, unsigned int skipnr);
unsigned int stack_trace_save_user(unsigned long *store, unsigned int size);
# 64 "/home/nathan/src/linux-next/include/linux/stacktrace.h"
struct stack_trace {
 unsigned int nr_entries, max_entries;
 unsigned long *entries;
 int skip;
};

extern void save_stack_trace(struct stack_trace *trace);
extern void save_stack_trace_regs(struct pt_regs *regs,
      struct stack_trace *trace);
extern void save_stack_trace_tsk(struct task_struct *tsk,
    struct stack_trace *trace);
extern int save_stack_trace_tsk_reliable(struct task_struct *tsk,
      struct stack_trace *trace);
extern void save_stack_trace_user(struct stack_trace *trace);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int stack_trace_save_tsk_reliable(struct task_struct *tsk,
      unsigned long *store,
      unsigned int size)
{
 return -38;
}
# 7 "/home/nathan/src/linux-next/include/linux/page_ext.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/stackdepot.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/stackdepot.h"
typedef u32 depot_stack_handle_t;

depot_stack_handle_t stack_depot_save(unsigned long *entries,
          unsigned int nr_entries, gfp_t gfp_flags);

unsigned int stack_depot_fetch(depot_stack_handle_t handle,
          unsigned long **entries);
# 8 "/home/nathan/src/linux-next/include/linux/page_ext.h" 2

struct pglist_data;
struct page_ext_operations {
 size_t offset;
 size_t size;
 bool (*need)(void);
 void (*init)(void);
};
# 64 "/home/nathan/src/linux-next/include/linux/page_ext.h"
struct page_ext;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgdat_page_ext_init(struct pglist_data *pgdat)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page_ext *lookup_page_ext(const struct page *page)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ext_init(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ext_init_flatmem(void)
{
}
# 25 "/home/nathan/src/linux-next/include/linux/mm.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/page_ref.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/page_ref.h"
extern struct tracepoint __tracepoint_page_ref_set;
extern struct tracepoint __tracepoint_page_ref_mod;
extern struct tracepoint __tracepoint_page_ref_mod_and_test;
extern struct tracepoint __tracepoint_page_ref_mod_and_return;
extern struct tracepoint __tracepoint_page_ref_mod_unless;
extern struct tracepoint __tracepoint_page_ref_freeze;
extern struct tracepoint __tracepoint_page_ref_unfreeze;
# 41 "/home/nathan/src/linux-next/include/linux/page_ref.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_set(struct page *page, int v)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_mod(struct page *page, int v)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_mod_and_test(struct page *page, int v, int ret)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_mod_and_return(struct page *page, int v, int ret)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_mod_unless(struct page *page, int v, int u)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_freeze(struct page *page, int v, int ret)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __page_ref_unfreeze(struct page *page, int v)
{
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_count(struct page *page)
{
 return atomic_read(&page->_refcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_count(struct page *page)
{
 return atomic_read(&compound_head(page)->_refcount);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_count(struct page *page, int v)
{
 atomic_set(&page->_refcount, v);
 if (false)
  __page_ref_set(page, v);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_page_count(struct page *page)
{
 set_page_count(page, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ref_add(struct page *page, int nr)
{
 atomic_add(nr, &page->_refcount);
 if (false)
  __page_ref_mod(page, nr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ref_sub(struct page *page, int nr)
{
 atomic_sub(nr, &page->_refcount);
 if (false)
  __page_ref_mod(page, -nr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ref_inc(struct page *page)
{
 atomic_inc(&page->_refcount);
 if (false)
  __page_ref_mod(page, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ref_dec(struct page *page)
{
 atomic_dec(&page->_refcount);
 if (false)
  __page_ref_mod(page, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_sub_and_test(struct page *page, int nr)
{
 int ret = atomic_sub_and_test(nr, &page->_refcount);

 if (false)
  __page_ref_mod_and_test(page, -nr, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_inc_return(struct page *page)
{
 int ret = atomic_inc_return(&page->_refcount);

 if (false)
  __page_ref_mod_and_return(page, 1, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_dec_and_test(struct page *page)
{
 int ret = atomic_dec_and_test(&page->_refcount);

 if (false)
  __page_ref_mod_and_test(page, -1, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_dec_return(struct page *page)
{
 int ret = atomic_dec_return(&page->_refcount);

 if (false)
  __page_ref_mod_and_return(page, -1, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_add_unless(struct page *page, int nr, int u)
{
 int ret = atomic_add_unless(&page->_refcount, nr, u);

 if (false)
  __page_ref_mod_unless(page, nr, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_ref_freeze(struct page *page, int count)
{
 int ret = __builtin_expect(!!((({ __typeof__(*(&((&page->_refcount)->counter))) _o_ = ((count)); __typeof__(*(&((&page->_refcount)->counter))) _n_ = ((0)); (__typeof__(*(&((&page->_refcount)->counter)))) __cmpxchg((&((&page->_refcount)->counter)), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&((&page->_refcount)->counter)))); })) == count), 1);

 if (false)
  __page_ref_freeze(page, count, ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_ref_unfreeze(struct page *page, int count)
{
 ((void)(sizeof(( long)(page_count(page) != 0))));
 ((void)(sizeof(( long)(count == 0))));

 atomic_set_release(&page->_refcount, count);
 if (false)
  __page_ref_unfreeze(page, count);
}
# 27 "/home/nathan/src/linux-next/include/linux/mm.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/memremap.h" 1






struct resource;
struct device;
# 18 "/home/nathan/src/linux-next/include/linux/memremap.h"
struct vmem_altmap {
 const unsigned long base_pfn;
 const unsigned long end_pfn;
 const unsigned long reserve;
 unsigned long free;
 unsigned long align;
 unsigned long alloc;
};
# 59 "/home/nathan/src/linux-next/include/linux/memremap.h"
enum memory_type {

 MEMORY_DEVICE_PRIVATE = 1,
 MEMORY_DEVICE_FS_DAX,
 MEMORY_DEVICE_DEVDAX,
 MEMORY_DEVICE_PCI_P2PDMA,
};

struct dev_pagemap_ops {





 void (*page_free)(struct page *page);




 void (*kill)(struct dev_pagemap *pgmap);




 void (*cleanup)(struct dev_pagemap *pgmap);





 vm_fault_t (*migrate_to_ram)(struct vm_fault *vmf);
};
# 107 "/home/nathan/src/linux-next/include/linux/memremap.h"
struct dev_pagemap {
 struct vmem_altmap altmap;
 struct resource res;
 struct percpu_ref *ref;
 struct percpu_ref internal_ref;
 struct completion done;
 enum memory_type type;
 unsigned int flags;
 const struct dev_pagemap_ops *ops;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vmem_altmap *pgmap_altmap(struct dev_pagemap *pgmap)
{
 if (pgmap->flags & (1 << 0))
  return &pgmap->altmap;
 return ((void *)0);
}
# 136 "/home/nathan/src/linux-next/include/linux/memremap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *devm_memremap_pages(struct device *dev,
  struct dev_pagemap *pgmap)
{





 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/memremap.h"), "i" (144), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return ERR_PTR(-6);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void devm_memunmap_pages(struct device *dev,
  struct dev_pagemap *pgmap)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dev_pagemap *get_dev_pagemap(unsigned long pfn,
  struct dev_pagemap *pgmap)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vmem_altmap_free(struct vmem_altmap *altmap,
  unsigned long nr_pfns)
{
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_dev_pagemap(struct dev_pagemap *pgmap)
{
 if (pgmap)
  percpu_ref_put(pgmap->ref);
}
# 28 "/home/nathan/src/linux-next/include/linux/mm.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/sizes.h" 1
# 30 "/home/nathan/src/linux-next/include/linux/mm.h" 2

struct mempolicy;
struct anon_vma;
struct anon_vma_chain;
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct bdi_writeback;

void init_mm_internals(void);
# 49 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_max_mapnr(unsigned long limit) { }


extern atomic_long_t _totalram_pages;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long totalram_pages(void)
{
 return (unsigned long)atomic_long_read(&_totalram_pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void totalram_pages_inc(void)
{
 atomic_long_inc(&_totalram_pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void totalram_pages_dec(void)
{
 atomic_long_dec(&_totalram_pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void totalram_pages_add(long count)
{
 atomic_long_add(count, &_totalram_pages);
}

extern void * high_memory;
extern int page_cluster;


extern int sysctl_legacy_va_layout;





extern const int mmap_rnd_bits_min;
extern const int mmap_rnd_bits_max;
extern int mmap_rnd_bits __attribute__((__section__(".data..read_mostly")));


extern const int mmap_rnd_compat_bits_min;
extern const int mmap_rnd_compat_bits_max;
extern int mmap_rnd_compat_bits __attribute__((__section__(".data..read_mostly")));




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/tlbflush.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/tlbflush.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-hash.h" 1
# 14 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"
struct ppc64_tlb_batch {
 int active;
 unsigned long index;
 struct mm_struct *mm;
 real_pte_t pte[192];
 unsigned long vpn[192];
 unsigned int psize;
 int ssize;
};
extern __attribute__((section(".data..percpu" ""))) __typeof__(struct ppc64_tlb_batch) ppc64_tlb_batch;

extern void __flush_tlb_pending(struct ppc64_tlb_batch *batch);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_enter_lazy_mmu_mode(void)
{
 struct ppc64_tlb_batch *batch;

 if (radix_enabled())
  return;
 batch = ({ do { const void *__vpp_verify = (typeof((&ppc64_tlb_batch) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch)); (typeof((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch))) (__ptr + ((local_paca->data_offset))); }); });
 batch->active = 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_leave_lazy_mmu_mode(void)
{
 struct ppc64_tlb_batch *batch;

 if (radix_enabled())
  return;
 batch = ({ do { const void *__vpp_verify = (typeof((&ppc64_tlb_batch) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch)); (typeof((typeof(*(&ppc64_tlb_batch)) *)(&ppc64_tlb_batch))) (__ptr + ((local_paca->data_offset))); }); });

 if (batch->index)
  __flush_tlb_pending(batch);
 batch->active = 0;
}



extern void hash__tlbiel_all(unsigned int action);

extern void flush_hash_page(unsigned long vpn, real_pte_t pte, int psize,
       int ssize, unsigned long flags);
extern void flush_hash_range(unsigned long number, int local);
extern void flush_hash_hugepage(unsigned long vsid, unsigned long addr,
    pmd_t *pmdp, unsigned int psize, int ssize,
    unsigned long flags);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_tlb_mm(struct mm_struct *mm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_mm(struct mm_struct *mm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_all_mm(struct mm_struct *mm)
{






 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"), "i" (78), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_all_mm(struct mm_struct *mm)
{






 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/tlbflush-hash.h"), "i" (89), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__local_flush_tlb_page(struct vm_area_struct *vma,
       unsigned long vmaddr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_page(struct vm_area_struct *vma,
        unsigned long vmaddr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_range(struct vm_area_struct *vma,
         unsigned long start, unsigned long end)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash__flush_tlb_kernel_range(unsigned long start,
         unsigned long end)
{
}


struct mmu_gather;
extern void hash__tlb_flush(struct mmu_gather *tlb);

extern void __flush_hash_table_range(struct mm_struct *mm, unsigned long start,
         unsigned long end);
extern void flush_tlb_pmd_range(struct mm_struct *mm, pmd_t *pmd,
    unsigned long addr);
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h" 2



enum {
 TLB_INVAL_SCOPE_GLOBAL = 0,
 TLB_INVAL_SCOPE_LPID = 1,
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlbiel_all(void)
{
# 28 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/tlbflush.h"
 if (early_radix_enabled())
  radix__tlbiel_all(TLB_INVAL_SCOPE_GLOBAL);
 else
  hash__tlbiel_all(TLB_INVAL_SCOPE_GLOBAL);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlbiel_all_lpid(bool radix)
{



 if (radix)
  radix__tlbiel_all(TLB_INVAL_SCOPE_LPID);
 else
  hash__tlbiel_all(TLB_INVAL_SCOPE_LPID);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_pmd_tlb_range(struct vm_area_struct *vma,
           unsigned long start, unsigned long end)
{
 if (radix_enabled())
  return radix__flush_pmd_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_hugetlb_tlb_range(struct vm_area_struct *vma,
        unsigned long start,
        unsigned long end)
{
 if (radix_enabled())
  return radix__flush_hugetlb_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_range(struct vm_area_struct *vma,
       unsigned long start, unsigned long end)
{
 if (radix_enabled())
  return radix__flush_tlb_range(vma, start, end);
 return hash__flush_tlb_range(vma, start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_kernel_range(unsigned long start,
       unsigned long end)
{
 if (radix_enabled())
  return radix__flush_tlb_kernel_range(start, end);
 return hash__flush_tlb_kernel_range(start, end);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_tlb_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__local_flush_tlb_mm(mm);
 return hash__local_flush_tlb_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_tlb_page(struct vm_area_struct *vma,
     unsigned long vmaddr)
{
 if (radix_enabled())
  return radix__local_flush_tlb_page(vma, vmaddr);
 return hash__local_flush_tlb_page(vma, vmaddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_flush_all_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__local_flush_all_mm(mm);
 return hash__local_flush_all_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tlb_flush(struct mmu_gather *tlb)
{
 if (radix_enabled())
  return radix__tlb_flush(tlb);
 return hash__tlb_flush(tlb);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__flush_tlb_mm(mm);
 return hash__flush_tlb_mm(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_page(struct vm_area_struct *vma,
      unsigned long vmaddr)
{
 if (radix_enabled())
  return radix__flush_tlb_page(vma, vmaddr);
 return hash__flush_tlb_page(vma, vmaddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_all_mm(struct mm_struct *mm)
{
 if (radix_enabled())
  return radix__flush_all_mm(mm);
 return hash__flush_all_mm(mm);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_tlb_fix_spurious_fault(struct vm_area_struct *vma,
      unsigned long address)
{

 if (atomic_read(&vma->vm_mm->context.copros) > 0)
  flush_tlb_page(vma, address);
}

extern bool tlbie_capable;
extern bool tlbie_enabled;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cputlb_use_tlbie(void)
{
 return tlbie_enabled;
}
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/tlbflush.h" 2
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/tlbflush.h" 2
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 2

struct mm_struct;





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h"
extern void set_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep,
         pte_t pte);



extern int ptep_set_access_flags(struct vm_area_struct *vma, unsigned long address,
     pte_t *ptep, pte_t entry, int dirty);

struct file;
extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
         unsigned long size, pgprot_t vma_prot);
# 38 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/pgtable.h"
void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep);
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 2
# 52 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pte_pgprot(pte_t pte)
{
 unsigned long pte_flags;

 pte_flags = pte_val(pte) & ~(((1UL << 53) - 1) & ((~((1 << 16) - 1))));
 return ((pgprot_t) { (pte_flags) });
}





extern unsigned long empty_zero_page[];


extern pgd_t swapper_pg_dir[];

extern void paging_init(void);

extern unsigned long ioremap_bot;
# 80 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h" 1
# 102 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
int ptep_clear_flush_young(struct vm_area_struct *vma,
      unsigned long address, pte_t *ptep);




extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
      unsigned long address, pmd_t *pmdp);
# 147 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
         unsigned long address,
         pud_t *pudp)
{
 pud_t pud = *pudp;

 pud_clear(pudp);
 return pud;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmdp_huge_get_and_clear_full(struct mm_struct *mm,
         unsigned long address, pmd_t *pmdp,
         int full)
{
 return pmdp_huge_get_and_clear(mm, address, pmdp);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pud_t pudp_huge_get_and_clear_full(struct mm_struct *mm,
         unsigned long address, pud_t *pudp,
         int full)
{
 return pudp_huge_get_and_clear(mm, address, pudp);
}
# 196 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_clear_not_present_full(struct mm_struct *mm,
           unsigned long address,
           pte_t *ptep,
           int full)
{
 pte_clear(mm, address, ptep);
}



extern pte_t ptep_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pte_t *ptep);



extern pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pmd_t *pmdp);
extern pud_t pudp_huge_clear_flush(struct vm_area_struct *vma,
         unsigned long address,
         pud_t *pudp);
# 279 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pudp_set_wrprotect(struct mm_struct *mm,
          unsigned long address, pud_t *pudp)
{
 do { extern void __compiletime_assert_282(void) ; if (!(!(1))) __compiletime_assert_282(); } while (0);
}
# 318 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t generic_pmdp_establish(struct vm_area_struct *vma,
  unsigned long address, pmd_t *pmdp, pmd_t pmd)
{
 pmd_t old_pmd = *pmdp;
 set_pmd_at(vma->vm_mm, address, pmdp, pmd);
 return old_pmd;
}
# 346 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pte_unused(pte_t pte)
{
 return 0;
}
# 390 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_same(pgd_t p4d_a, pgd_t p4d_b)
{
 return pgd_val(p4d_a) == pgd_val(p4d_b);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_same(pgd_t pgd_a, pgd_t pgd_b)
{
 return pgd_val(pgd_a) == pgd_val(pgd_b);
}
# 450 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_do_swap_page(struct mm_struct *mm,
         struct vm_area_struct *vma,
         unsigned long addr,
         pte_t pte, pte_t oldpte)
{

}
# 468 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_unmap_one(struct mm_struct *mm,
      struct vm_area_struct *vma,
      unsigned long addr,
      pte_t orig_pte)
{
 return 0;
}
# 511 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
{
 if (((oldprot).pgprot) == ((pgprot_noncached(oldprot)).pgprot))
  newprot = pgprot_noncached(newprot);
 if (((oldprot).pgprot) == ((pgprot_writecombine(oldprot)).pgprot))
  newprot = pgprot_writecombine(newprot);
 if (((oldprot).pgprot) == ((pgprot_noncached(oldprot)).pgprot))
  newprot = pgprot_noncached(newprot);
 return newprot;
}
# 560 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
void pgd_clear_bad(pgd_t *);
# 569 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
void pud_clear_bad(pud_t *);




void pmd_clear_bad(pmd_t *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pgd_none_or_clear_bad(pgd_t *pgd)
{
 if (pgd_none(*pgd))
  return 1;
 if (__builtin_expect(!!(pgd_bad(*pgd)), 0)) {
  pgd_clear_bad(pgd);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_none_or_clear_bad(pgd_t *p4d)
{
 if (p4d_none(*p4d))
  return 1;
 if (__builtin_expect(!!(p4d_bad(*p4d)), 0)) {
  do { } while (0);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none_or_clear_bad(pud_t *pud)
{
 if (pud_none(*pud))
  return 1;
 if (__builtin_expect(!!(pud_bad(*pud)), 0)) {
  pud_clear_bad(pud);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none_or_clear_bad(pmd_t *pmd)
{
 if (pmd_none(*pmd))
  return 1;
 if (__builtin_expect(!!(pmd_bad(*pmd)), 0)) {
  pmd_clear_bad(pmd);
  return 1;
 }
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t __ptep_modify_prot_start(struct vm_area_struct *vma,
          unsigned long addr,
          pte_t *ptep)
{





 return ptep_get_and_clear(vma->vm_mm, addr, ptep);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ptep_modify_prot_commit(struct vm_area_struct *vma,
          unsigned long addr,
          pte_t *ptep, pte_t pte)
{




 set_pte_at(vma->vm_mm, addr, ptep, pte);
}
# 816 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int track_pfn_remap(struct vm_area_struct *vma, pgprot_t *prot,
      unsigned long pfn, unsigned long addr,
      unsigned long size)
{
 return 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void track_pfn_insert(struct vm_area_struct *vma, pgprot_t *prot,
        pfn_t pfn)
{
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int track_pfn_copy(struct vm_area_struct *vma)
{
 return 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void untrack_pfn(struct vm_area_struct *vma,
          unsigned long pfn, unsigned long size)
{
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void untrack_pfn_moved(struct vm_area_struct *vma)
{
}
# 880 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_zero_pfn(unsigned long pfn)
{
 extern unsigned long zero_pfn;
 return pfn == zero_pfn;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long my_zero_pfn(unsigned long addr)
{
 extern unsigned long zero_pfn;
 return zero_pfn;
}
# 935 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_trans_huge(pud_t pud)
{
 return 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_none_or_trans_huge_or_dev_or_clear_bad(pud_t *pud)
{
 pud_t pudval = ({ union { typeof(*pud) __val; char __c[1]; } __u; if (1) __read_once_size(&(*pud), __u.__c, sizeof(*pud)); else __read_once_size_nocheck(&(*pud), __u.__c, sizeof(*pud)); do { } while (0); __u.__val; });

 if (pud_none(pudval) || pud_trans_huge(pudval) || pud_devmap(pudval))
  return 1;
 if (__builtin_expect(!!(pud_bad(pudval)), 0)) {
  pud_clear_bad(pud);
  return 1;
 }
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pud_trans_unstable(pud_t *pud)
{




 return 0;

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t pmd_read_atomic(pmd_t *pmdp)
{





 return *pmdp;
}
# 1002 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
{
 pmd_t pmdval = pmd_read_atomic(pmd);
# 1020 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
 __asm__ __volatile__("" : : : "memory");
# 1037 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
 if (pmd_none(pmdval) || pmd_trans_huge(pmdval) ||
  (1 && !pmd_present(pmdval)))
  return 1;
 if (__builtin_expect(!!(pmd_bad(pmdval)), 0)) {
  pmd_clear_bad(pmd);
  return 1;
 }
 return 0;
}
# 1059 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pmd_trans_unstable(pmd_t *pmd)
{

 return pmd_none_or_trans_huge_or_clear_bad(pmd);



}
# 1096 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_set_huge(pgd_t *p4d, phys_addr_t addr, pgprot_t prot)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int p4d_clear_huge(pgd_t *p4d)
{
 return 0;
}


int pud_set_huge(pud_t *pud, phys_addr_t addr, pgprot_t prot);
int pmd_set_huge(pmd_t *pmd, phys_addr_t addr, pgprot_t prot);
int pud_clear_huge(pud_t *pud);
int pmd_clear_huge(pmd_t *pmd);
int p4d_free_pud_page(pgd_t *p4d, unsigned long addr);
int pud_free_pmd_page(pud_t *pud, unsigned long addr);
int pmd_free_pte_page(pmd_t *pmd, unsigned long addr);
# 1171 "/home/nathan/src/linux-next/include/asm-generic/pgtable.h"
struct file;
int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
   unsigned long size, pgprot_t *vma_prot);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_espfix_bsp(void) { }


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pgtable_cache_init(void);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pfn_modify_allowed(unsigned long pfn, pgprot_t prot)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool arch_has_pfn_modify_check(void)
{
 return false;
}
# 81 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h" 2






unsigned long vmalloc_to_phys(void *vmalloc_addr);

void pgtable_cache_add(unsigned int shift);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_initmem_nx(void) { }







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pte_frag_get(mm_context_t *ctx)
{
 return ctx->pte_frag;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pte_frag_set(mm_context_t *ctx, void *p)
{
 ctx->pte_frag = p;
}
# 152 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pgtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_ioremap_addr(const void *x)
{
 unsigned long addr = (unsigned long)x;

 return addr >= ((__kernel_io_start + 0x80000000ul)) && addr < (__kernel_io_end);
}
# 95 "/home/nathan/src/linux-next/include/linux/mm.h" 2
# 145 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __mm_zero_struct_page(struct page *page)
{
 unsigned long *_pp = (void *)page;


 do { extern void __compiletime_assert_150(void) ; if (!(!(sizeof(struct page) & 7))) __compiletime_assert_150(); } while (0);
 do { extern void __compiletime_assert_151(void) ; if (!(!(sizeof(struct page) < 56))) __compiletime_assert_151(); } while (0);
 do { extern void __compiletime_assert_152(void) ; if (!(!(sizeof(struct page) > 80))) __compiletime_assert_152(); } while (0);

 switch (sizeof(struct page)) {
 case 80:
  _pp[9] = 0;
 case 72:
  _pp[8] = 0;
 case 64:
  _pp[7] = 0;
 case 56:
  _pp[6] = 0;
  _pp[5] = 0;
  _pp[4] = 0;
  _pp[3] = 0;
  _pp[2] = 0;
  _pp[1] = 0;
  _pp[0] = 0;
 }
}
# 194 "/home/nathan/src/linux-next/include/linux/mm.h"
extern int sysctl_max_map_count;

extern unsigned long sysctl_user_reserve_kbytes;
extern unsigned long sysctl_admin_reserve_kbytes;

extern int sysctl_overcommit_memory;
extern int sysctl_overcommit_ratio;
extern unsigned long sysctl_overcommit_kbytes;

extern int overcommit_ratio_handler(struct ctl_table *, int, void *,
        size_t *, loff_t *);
extern int overcommit_kbytes_handler(struct ctl_table *, int, void *,
        size_t *, loff_t *);
# 227 "/home/nathan/src/linux-next/include/linux/mm.h"
struct vm_area_struct *vm_area_alloc(struct mm_struct *);
struct vm_area_struct *vm_area_dup(struct vm_area_struct *);
void vm_area_free(struct vm_area_struct *);
# 379 "/home/nathan/src/linux-next/include/linux/mm.h"
extern pgprot_t protection_map[16];
# 412 "/home/nathan/src/linux-next/include/linux/mm.h"
struct vm_fault {
 struct vm_area_struct *vma;
 unsigned int flags;
 gfp_t gfp_mask;
 unsigned long pgoff;
 unsigned long address;
 pmd_t *pmd;

 pud_t *pud;


 pte_t orig_pte;

 struct page *cow_page;
 struct mem_cgroup *memcg;
 struct page *page;





 pte_t *pte;



 spinlock_t *ptl;



 pgtable_t prealloc_pte;






};


enum page_entry_size {
 PE_SIZE_PTE = 0,
 PE_SIZE_PMD,
 PE_SIZE_PUD,
};






struct vm_operations_struct {
 void (*open)(struct vm_area_struct * area);
 void (*close)(struct vm_area_struct * area);
 int (*split)(struct vm_area_struct * area, unsigned long addr);
 int (*mremap)(struct vm_area_struct * area);
 vm_fault_t (*fault)(struct vm_fault *vmf);
 vm_fault_t (*huge_fault)(struct vm_fault *vmf,
   enum page_entry_size pe_size);
 void (*map_pages)(struct vm_fault *vmf,
   unsigned long start_pgoff, unsigned long end_pgoff);
 unsigned long (*pagesize)(struct vm_area_struct * area);



 vm_fault_t (*page_mkwrite)(struct vm_fault *vmf);


 vm_fault_t (*pfn_mkwrite)(struct vm_fault *vmf);




 int (*access)(struct vm_area_struct *vma, unsigned long addr,
        void *buf, int len, int write);




 const char *(*name)(struct vm_area_struct *vma);
# 500 "/home/nathan/src/linux-next/include/linux/mm.h"
 int (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);
# 512 "/home/nathan/src/linux-next/include/linux/mm.h"
 struct mempolicy *(*get_policy)(struct vm_area_struct *vma,
     unsigned long addr);






 struct page *(*find_special_page)(struct vm_area_struct *vma,
       unsigned long addr);
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vma_init(struct vm_area_struct *vma, struct mm_struct *mm)
{
 static const struct vm_operations_struct dummy_vm_ops = {};

 memset(vma, 0, sizeof(*vma));
 vma->vm_mm = mm;
 vma->vm_ops = &dummy_vm_ops;
 INIT_LIST_HEAD(&vma->anon_vma_chain);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vma_set_anonymous(struct vm_area_struct *vma)
{
 vma->vm_ops = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vma_is_anonymous(struct vm_area_struct *vma)
{
 return !vma->vm_ops;
}






bool vma_is_shmem(struct vm_area_struct *vma);




int vma_is_stack_for_current(struct vm_area_struct *vma);




struct mmu_gather;
struct inode;







# 1 "/home/nathan/src/linux-next/include/linux/huge_mm.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/sched/coredump.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/sched/coredump.h"
extern void set_dumpable(struct mm_struct *mm, int value);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __get_dumpable(unsigned long mm_flags)
{
 return mm_flags & ((1 << 2) - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_dumpable(struct mm_struct *mm)
{
 return __get_dumpable(mm->flags);
}
# 6 "/home/nathan/src/linux-next/include/linux/huge_mm.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/fs.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/wait_bit.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
struct wait_bit_key {
 void *flags;
 int bit_nr;
 unsigned long timeout;
};

struct wait_bit_queue_entry {
 struct wait_bit_key key;
 struct wait_queue_entry wq_entry;
};




typedef int wait_bit_action_f(struct wait_bit_key *key, int mode);

void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit);
int __wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
int __wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
void wake_up_bit(void *word, int bit);
int out_of_line_wait_on_bit(void *word, int, wait_bit_action_f *action, unsigned int mode);
int out_of_line_wait_on_bit_timeout(void *word, int, wait_bit_action_f *action, unsigned int mode, unsigned long timeout);
int out_of_line_wait_on_bit_lock(void *word, int, wait_bit_action_f *action, unsigned int mode);
struct wait_queue_head *bit_waitqueue(void *word, int bit);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) wait_bit_init(void);

int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
# 49 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
extern int bit_wait(struct wait_bit_key *key, int mode);
extern int bit_wait_io(struct wait_bit_key *key, int mode);
extern int bit_wait_timeout(struct wait_bit_key *key, int mode);
extern int bit_wait_io_timeout(struct wait_bit_key *key, int mode);
# 70 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit(unsigned long *word, int bit, unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit,
           bit_wait,
           mode);
}
# 95 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_io(unsigned long *word, int bit, unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit,
           bit_wait_io,
           mode);
}
# 121 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_timeout(unsigned long *word, int bit, unsigned mode,
      unsigned long timeout)
{
 do { do { } while (0); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_timeout(word, bit,
            bit_wait_timeout,
            mode, timeout);
}
# 149 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_action(unsigned long *word, int bit, wait_bit_action_f *action,
     unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit(word, bit, action, mode);
}
# 178 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock(unsigned long *word, int bit, unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, bit_wait, mode);
}
# 202 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock_io(unsigned long *word, int bit, unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, bit_wait_io, mode);
}
# 228 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
wait_on_bit_lock_action(unsigned long *word, int bit, wait_bit_action_f *action,
   unsigned mode)
{
 do { do { } while (0); } while (0);
 if (!test_and_set_bit(bit, word))
  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, action, mode);
}

extern void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags);
extern void wake_up_var(void *var);
extern wait_queue_head_t *__var_waitqueue(void *p);
# 330 "/home/nathan/src/linux-next/include/linux/wait_bit.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_and_wake_up_bit(int bit, void *word)
{
 clear_bit_unlock(bit, word);

 __asm__ __volatile__ ("sync" : : : "memory");
 wake_up_bit(word, bit);
}
# 7 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kdev_t.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/kdev_t.h" 1
# 6 "/home/nathan/src/linux-next/include/linux/kdev_t.h" 2
# 24 "/home/nathan/src/linux-next/include/linux/kdev_t.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool old_valid_dev(dev_t dev)
{
 return ((unsigned int) ((dev) >> 20)) < 256 && ((unsigned int) ((dev) & ((1U << 20) - 1))) < 256;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 old_encode_dev(dev_t dev)
{
 return (((unsigned int) ((dev) >> 20)) << 8) | ((unsigned int) ((dev) & ((1U << 20) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t old_decode_dev(u16 val)
{
 return ((((val >> 8) & 255) << 20) | (val & 255));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 new_encode_dev(dev_t dev)
{
 unsigned major = ((unsigned int) ((dev) >> 20));
 unsigned minor = ((unsigned int) ((dev) & ((1U << 20) - 1)));
 return (minor & 0xff) | (major << 8) | ((minor & ~0xff) << 12);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t new_decode_dev(u32 dev)
{
 unsigned major = (dev & 0xfff00) >> 8;
 unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
 return (((major) << 20) | (minor));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 huge_encode_dev(dev_t dev)
{
 return new_encode_dev(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t huge_decode_dev(u64 dev)
{
 return new_decode_dev(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sysv_valid_dev(dev_t dev)
{
 return ((unsigned int) ((dev) >> 20)) < (1<<14) && ((unsigned int) ((dev) & ((1U << 20) - 1))) < (1<<18);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 sysv_encode_dev(dev_t dev)
{
 return ((unsigned int) ((dev) & ((1U << 20) - 1))) | (((unsigned int) ((dev) >> 20)) << 18);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned sysv_major(u32 dev)
{
 return (dev >> 18) & 0x3fff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned sysv_minor(u32 dev)
{
 return dev & 0x3ffff;
}
# 8 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dcache.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/rculist_bl.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/list_bl.h" 1
# 34 "/home/nathan/src/linux-next/include/linux/list_bl.h"
struct hlist_bl_head {
 struct hlist_bl_node *first;
};

struct hlist_bl_node {
 struct hlist_bl_node *next, **pprev;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INIT_HLIST_BL_NODE(struct hlist_bl_node *h)
{
 h->next = ((void *)0);
 h->pprev = ((void *)0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_unhashed(const struct hlist_bl_node *h)
{
 return !h->pprev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h)
{
 return (struct hlist_bl_node *)
  ((unsigned long)h->first & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_set_first(struct hlist_bl_head *h,
     struct hlist_bl_node *n)
{
                                                    ;

                        ;
 h->first = (struct hlist_bl_node *)((unsigned long)n | 1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_empty(const struct hlist_bl_head *h)
{
 return !((unsigned long)({ union { typeof(h->first) __val; char __c[1]; } __u; if (1) __read_once_size(&(h->first), __u.__c, sizeof(h->first)); else __read_once_size_nocheck(&(h->first), __u.__c, sizeof(h->first)); do { } while (0); __u.__val; }) & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_head(struct hlist_bl_node *n,
     struct hlist_bl_head *h)
{
 struct hlist_bl_node *first = hlist_bl_first(h);

 n->next = first;
 if (first)
  first->pprev = &n->next;
 n->pprev = &h->first;
 hlist_bl_set_first(h, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_before(struct hlist_bl_node *n,
           struct hlist_bl_node *next)
{
 struct hlist_bl_node **pprev = next->pprev;

 n->pprev = pprev;
 n->next = next;
 next->pprev = &n->next;


 ({ union { typeof(*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*pprev)) ((struct hlist_bl_node *) ((uintptr_t)n | ((uintptr_t)*pprev & 1UL))) }; __write_once_size(&(*pprev), __u.__c, sizeof(*pprev)); __u.__val; });


}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_behind(struct hlist_bl_node *n,
           struct hlist_bl_node *prev)
{
 n->next = prev->next;
 n->pprev = &prev->next;
 prev->next = n;

 if (n->next)
  n->next->pprev = &n->next;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hlist_bl_del(struct hlist_bl_node *n)
{
 struct hlist_bl_node *next = n->next;
 struct hlist_bl_node **pprev = n->pprev;

                                                    ;


 ({ union { typeof(*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*pprev)) ((struct hlist_bl_node *) ((unsigned long)next | ((unsigned long)*pprev & 1UL))) }; __write_once_size(&(*pprev), __u.__c, sizeof(*pprev)); __u.__val; });



 if (next)
  next->pprev = pprev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del(struct hlist_bl_node *n)
{
 __hlist_bl_del(n);
 n->next = ((void *) 0x100 + (0x5deadbeef0000000UL));
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del_init(struct hlist_bl_node *n)
{
 if (!hlist_bl_unhashed(n)) {
  __hlist_bl_del(n);
  INIT_HLIST_BL_NODE(n);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_lock(struct hlist_bl_head *b)
{
 bit_spin_lock(0, (unsigned long *)b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_unlock(struct hlist_bl_head *b)
{
 __bit_spin_unlock(0, (unsigned long *)b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hlist_bl_is_locked(struct hlist_bl_head *b)
{
 return bit_spin_is_locked(0, (unsigned long *)b);
}
# 9 "/home/nathan/src/linux-next/include/linux/rculist_bl.h" 2


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_set_first_rcu(struct hlist_bl_head *h,
     struct hlist_bl_node *n)
{
                                                    ;

                        ;
 do { uintptr_t _r_a_p__v = (uintptr_t)((struct hlist_bl_node *)((unsigned long)n | 1UL)); ; if (__builtin_constant_p((struct hlist_bl_node *)((unsigned long)n | 1UL)) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((h->first)) __val; char __c[1]; } __u = { .__val = ( typeof((h->first))) ((typeof(h->first))(_r_a_p__v)) }; __write_once_size(&((h->first)), __u.__c, sizeof((h->first))); __u.__val; }); else do { do { extern void __compiletime_assert_18(void) ; if (!((sizeof(*&h->first) == sizeof(char) || sizeof(*&h->first) == sizeof(short) || sizeof(*&h->first) == sizeof(int) || sizeof(*&h->first) == sizeof(long)))) __compiletime_assert_18(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&h->first) __val; char __c[1]; } __u = { .__val = ( typeof(*&h->first)) ((typeof(*((typeof(h->first))_r_a_p__v)) *)((typeof(h->first))_r_a_p__v)) }; __write_once_size(&(*&h->first), __u.__c, sizeof(*&h->first)); __u.__val; }); } while (0); } while (0);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hlist_bl_node *hlist_bl_first_rcu(struct hlist_bl_head *h)
{
 return (struct hlist_bl_node *)
  ((unsigned long)({ typeof(*(h->first)) *________p1 = (typeof(*(h->first)) *)({ union { typeof((h->first)) __val; char __c[1]; } __u; if (1) __read_once_size(&((h->first)), __u.__c, sizeof((h->first))); else __read_once_size_nocheck(&((h->first)), __u.__c, sizeof((h->first))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(h->first)) *)(________p1)); }) & ~1UL);
}
# 46 "/home/nathan/src/linux-next/include/linux/rculist_bl.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_del_rcu(struct hlist_bl_node *n)
{
 __hlist_bl_del(n);
 n->pprev = ((void *) 0x122 + (0x5deadbeef0000000UL));
}
# 71 "/home/nathan/src/linux-next/include/linux/rculist_bl.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_bl_add_head_rcu(struct hlist_bl_node *n,
     struct hlist_bl_head *h)
{
 struct hlist_bl_node *first;


 first = hlist_bl_first(h);

 n->next = first;
 if (first)
  first->pprev = &n->next;
 n->pprev = &h->first;


 hlist_bl_set_first_rcu(h, n);
}
# 9 "/home/nathan/src/linux-next/include/linux/dcache.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/lockref.h" 1
# 25 "/home/nathan/src/linux-next/include/linux/lockref.h"
struct lockref {
 union {

  __u64 __attribute__((aligned(8))) lock_count;

  struct {
   spinlock_t lock;
   int count;
  };
 };
};

extern void lockref_get(struct lockref *);
extern int lockref_put_return(struct lockref *);
extern int lockref_get_not_zero(struct lockref *);
extern int lockref_put_not_zero(struct lockref *);
extern int lockref_get_or_lock(struct lockref *);
extern int lockref_put_or_lock(struct lockref *);

extern void lockref_mark_dead(struct lockref *);
extern int lockref_get_not_dead(struct lockref *);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __lockref_is_dead(const struct lockref *l)
{
 return ((int)l->count < 0);
}
# 14 "/home/nathan/src/linux-next/include/linux/dcache.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/stringhash.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/hash.h" 1
# 60 "/home/nathan/src/linux-next/include/linux/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __hash_32_generic(u32 val)
{
 return val * 0x61C88647;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash_32_generic(u32 val, unsigned int bits)
{

 return __hash_32_generic(val) >> (32 - bits);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32 hash_64_generic(u64 val, unsigned int bits)
{


 return val * 0x61C8864680B583EBull >> (64 - bits);




}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash_ptr(const void *ptr, unsigned int bits)
{
 return hash_64_generic((unsigned long)ptr, bits);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hash32_ptr(const void *ptr)
{
 unsigned long val = (unsigned long)ptr;


 val ^= (val >> 32);

 return (u32)val;
}
# 8 "/home/nathan/src/linux-next/include/linux/stringhash.h" 2
# 42 "/home/nathan/src/linux-next/include/linux/stringhash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
partial_name_hash(unsigned long c, unsigned long prevhash)
{
 return (prevhash + (c << 4) + (c >> 4)) * 11;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int end_name_hash(unsigned long hash)
{
 return hash_64_generic(hash, 32);
}
# 66 "/home/nathan/src/linux-next/include/linux/stringhash.h"
extern unsigned int __attribute__((__pure__)) full_name_hash(const void *salt, const char *, unsigned int);
# 77 "/home/nathan/src/linux-next/include/linux/stringhash.h"
extern u64 __attribute__((__pure__)) hashlen_string(const void *salt, const char *name);
# 15 "/home/nathan/src/linux-next/include/linux/dcache.h" 2


struct path;
struct vfsmount;
# 47 "/home/nathan/src/linux-next/include/linux/dcache.h"
struct qstr {
 union {
  struct {
   u32 len; u32 hash;
  };
  u64 hash_len;
 };
 const unsigned char *name;
};



extern const struct qstr empty_name;
extern const struct qstr slash_name;

struct dentry_stat_t {
 long nr_dentry;
 long nr_unused;
 long age_limit;
 long want_pages;
 long nr_negative;
 long dummy;
};
extern struct dentry_stat_t dentry_stat;
# 89 "/home/nathan/src/linux-next/include/linux/dcache.h"
struct dentry {

 unsigned int d_flags;
 seqcount_t d_seq;
 struct hlist_bl_node d_hash;
 struct dentry *d_parent;
 struct qstr d_name;
 struct inode *d_inode;

 unsigned char d_iname[32];


 struct lockref d_lockref;
 const struct dentry_operations *d_op;
 struct super_block *d_sb;
 unsigned long d_time;
 void *d_fsdata;

 union {
  struct list_head d_lru;
  wait_queue_head_t *d_wait;
 };
 struct list_head d_child;
 struct list_head d_subdirs;



 union {
  struct hlist_node d_alias;
  struct hlist_bl_node d_in_lookup_hash;
   struct callback_head d_rcu;
 } d_u;
} ;







enum dentry_d_lock_class
{
 DENTRY_D_LOCK_NORMAL,
 DENTRY_D_LOCK_NESTED
};

struct dentry_operations {
 int (*d_revalidate)(struct dentry *, unsigned int);
 int (*d_weak_revalidate)(struct dentry *, unsigned int);
 int (*d_hash)(const struct dentry *, struct qstr *);
 int (*d_compare)(const struct dentry *,
   unsigned int, const char *, const struct qstr *);
 int (*d_delete)(const struct dentry *);
 int (*d_init)(struct dentry *);
 void (*d_release)(struct dentry *);
 void (*d_prune)(struct dentry *);
 void (*d_iput)(struct dentry *, struct inode *);
 char *(*d_dname)(struct dentry *, char *, int);
 struct vfsmount *(*d_automount)(struct path *);
 int (*d_manage)(const struct path *, bool);
 struct dentry *(*d_real)(struct dentry *, const struct inode *);
} __attribute__((__aligned__((1 << 7))));
# 221 "/home/nathan/src/linux-next/include/linux/dcache.h"
extern seqlock_t rename_lock;




extern void d_instantiate(struct dentry *, struct inode *);
extern void d_instantiate_new(struct dentry *, struct inode *);
extern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);
extern struct dentry * d_instantiate_anon(struct dentry *, struct inode *);
extern void __d_drop(struct dentry *dentry);
extern void d_drop(struct dentry *dentry);
extern void d_delete(struct dentry *);
extern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op);


extern struct dentry * d_alloc(struct dentry *, const struct qstr *);
extern struct dentry * d_alloc_anon(struct super_block *);
extern struct dentry * d_alloc_parallel(struct dentry *, const struct qstr *,
     wait_queue_head_t *);
extern struct dentry * d_splice_alias(struct inode *, struct dentry *);
extern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);
extern struct dentry * d_exact_alias(struct dentry *, struct inode *);
extern struct dentry *d_find_any_alias(struct inode *inode);
extern struct dentry * d_obtain_alias(struct inode *);
extern struct dentry * d_obtain_root(struct inode *);
extern void shrink_dcache_sb(struct super_block *);
extern void shrink_dcache_parent(struct dentry *);
extern void shrink_dcache_for_umount(struct super_block *);
extern void d_invalidate(struct dentry *);


extern struct dentry * d_make_root(struct inode *);


extern void d_genocide(struct dentry *);

extern void d_tmpfile(struct dentry *, struct inode *);

extern struct dentry *d_find_alias(struct inode *);
extern void d_prune_aliases(struct inode *);


extern int path_has_submounts(const struct path *);




extern void d_rehash(struct dentry *);

extern void d_add(struct dentry *, struct inode *);


extern void d_move(struct dentry *, struct dentry *);
extern void d_exchange(struct dentry *, struct dentry *);
extern struct dentry *d_ancestor(struct dentry *, struct dentry *);


extern struct dentry *d_lookup(const struct dentry *, const struct qstr *);
extern struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);
extern struct dentry *__d_lookup(const struct dentry *, const struct qstr *);
extern struct dentry *__d_lookup_rcu(const struct dentry *parent,
    const struct qstr *name, unsigned *seq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned d_count(const struct dentry *dentry)
{
 return dentry->d_lockref.count;
}




extern __attribute__((__format__(printf, 4, 5)))
char *dynamic_dname(struct dentry *, char *, int, const char *, ...);

extern char *__d_path(const struct path *, const struct path *, char *, int);
extern char *d_absolute_path(const struct path *, char *, int);
extern char *d_path(const struct path *, char *, int);
extern char *dentry_path_raw(struct dentry *, char *, int);
extern char *dentry_path(struct dentry *, char *, int);
# 311 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *dget_dlock(struct dentry *dentry)
{
 if (dentry)
  dentry->d_lockref.count++;
 return dentry;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *dget(struct dentry *dentry)
{
 if (dentry)
  lockref_get(&dentry->d_lockref);
 return dentry;
}

extern struct dentry *dget_parent(struct dentry *dentry);
# 334 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_unhashed(const struct dentry *dentry)
{
 return hlist_bl_unhashed(&dentry->d_hash);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_unlinked(const struct dentry *dentry)
{
 return d_unhashed(dentry) && !((dentry) == (dentry)->d_parent);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cant_mount(const struct dentry *dentry)
{
 return (dentry->d_flags & 0x00000100);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dont_mount(struct dentry *dentry)
{
 spin_lock(&dentry->d_lockref.lock);
 dentry->d_flags |= 0x00000100;
 spin_unlock(&dentry->d_lockref.lock);
}

extern void __d_lookup_done(struct dentry *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int d_in_lookup(const struct dentry *dentry)
{
 return dentry->d_flags & 0x10000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void d_lookup_done(struct dentry *dentry)
{
 if (__builtin_expect(!!(d_in_lookup(dentry)), 0)) {
  spin_lock(&dentry->d_lockref.lock);
  __d_lookup_done(dentry);
  spin_unlock(&dentry->d_lockref.lock);
 }
}

extern void dput(struct dentry *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_managed(const struct dentry *dentry)
{
 return dentry->d_flags & (0x00010000|0x00020000|0x00040000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_mountpoint(const struct dentry *dentry)
{
 return dentry->d_flags & 0x00010000;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned __d_entry_type(const struct dentry *dentry)
{
 return dentry->d_flags & 0x00700000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_miss(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_whiteout(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00100000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_can_lookup(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00200000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_autodir(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00300000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_dir(const struct dentry *dentry)
{
 return d_can_lookup(dentry) || d_is_autodir(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_symlink(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00600000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_reg(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00400000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_special(const struct dentry *dentry)
{
 return __d_entry_type(dentry) == 0x00500000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_file(const struct dentry *dentry)
{
 return d_is_reg(dentry) || d_is_special(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_negative(const struct dentry *dentry)
{

 return d_is_miss(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_flags_negative(unsigned flags)
{
 return (flags & 0x00700000) == 0x00000000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_positive(const struct dentry *dentry)
{
 return !d_is_negative(dentry);
}
# 468 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_really_is_negative(const struct dentry *dentry)
{
 return dentry->d_inode == ((void *)0);
}
# 486 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_really_is_positive(const struct dentry *dentry)
{
 return dentry->d_inode != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int simple_positive(const struct dentry *dentry)
{
 return d_really_is_positive(dentry) && !d_unhashed(dentry);
}

extern void d_set_fallthru(struct dentry *dentry);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool d_is_fallthru(const struct dentry *dentry)
{
 return dentry->d_flags & 0x01000000;
}


extern int sysctl_vfs_cache_pressure;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vfs_pressure_ratio(unsigned long val)
{
 return ( { typeof(val) quot = (val) / (100); typeof(val) rem = (val) % (100); (quot * (sysctl_vfs_cache_pressure)) + ((rem * (sysctl_vfs_cache_pressure)) / (100)); } );
}
# 518 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_inode(const struct dentry *dentry)
{
 return dentry->d_inode;
}
# 530 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_inode_rcu(const struct dentry *dentry)
{
 return ({ union { typeof(dentry->d_inode) __val; char __c[1]; } __u; if (1) __read_once_size(&(dentry->d_inode), __u.__c, sizeof(dentry->d_inode)); else __read_once_size_nocheck(&(dentry->d_inode), __u.__c, sizeof(dentry->d_inode)); do { } while (0); __u.__val; });
}
# 545 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_backing_inode(const struct dentry *upper)
{
 struct inode *inode = upper->d_inode;

 return inode;
}
# 562 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *d_backing_dentry(struct dentry *upper)
{
 return upper;
}
# 577 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *d_real(struct dentry *dentry,
        const struct inode *inode)
{
 if (__builtin_expect(!!(dentry->d_flags & 0x04000000), 0))
  return dentry->d_op->d_real(dentry, inode);
 else
  return dentry;
}
# 593 "/home/nathan/src/linux-next/include/linux/dcache.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *d_real_inode(const struct dentry *dentry)
{

 return d_backing_inode(d_real((struct dentry *) dentry, ((void *)0)));
}

struct name_snapshot {
 struct qstr name;
 unsigned char inline_name[32];
};
void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
void release_dentry_name_snapshot(struct name_snapshot *);
# 9 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/path.h" 1




struct dentry;
struct vfsmount;

struct path {
 struct vfsmount *mnt;
 struct dentry *dentry;
} ;

extern void path_get(const struct path *);
extern void path_put(const struct path *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int path_equal(const struct path *path1, const struct path *path2)
{
 return path1->mnt == path2->mnt && path1->dentry == path2->dentry;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void path_put_init(struct path *path)
{
 path_put(path);
 *path = (struct path) { };
}
# 10 "/home/nathan/src/linux-next/include/linux/fs.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/list_lru.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/list_lru.h"
struct mem_cgroup;


enum lru_status {
 LRU_REMOVED,
 LRU_REMOVED_RETRY,

 LRU_ROTATE,
 LRU_SKIP,
 LRU_RETRY,

};

struct list_lru_one {
 struct list_head list;

 long nr_items;
};

struct list_lru_memcg {
 struct callback_head rcu;

 struct list_lru_one *lru[0];
};

struct list_lru_node {

 spinlock_t lock;

 struct list_lru_one lru;


 struct list_lru_memcg *memcg_lrus;

 long nr_items;
} __attribute__((__aligned__((1 << 7))));

struct list_lru {
 struct list_lru_node *node;

 struct list_head list;
 int shrinker_id;
 bool memcg_aware;

};

void list_lru_destroy(struct list_lru *lru);
int __list_lru_init(struct list_lru *lru, bool memcg_aware,
      struct lock_class_key *key, struct shrinker *shrinker);
# 72 "/home/nathan/src/linux-next/include/linux/list_lru.h"
int memcg_update_all_list_lrus(int num_memcgs);
void memcg_drain_all_list_lrus(int src_idx, struct mem_cgroup *dst_memcg);
# 91 "/home/nathan/src/linux-next/include/linux/list_lru.h"
bool list_lru_add(struct list_lru *lru, struct list_head *item);
# 104 "/home/nathan/src/linux-next/include/linux/list_lru.h"
bool list_lru_del(struct list_lru *lru, struct list_head *item);
# 116 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_count_one(struct list_lru *lru,
     int nid, struct mem_cgroup *memcg);
unsigned long list_lru_count_node(struct list_lru *lru, int nid);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long list_lru_shrink_count(struct list_lru *lru,
        struct shrink_control *sc)
{
 return list_lru_count_one(lru, sc->nid, sc->memcg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long list_lru_count(struct list_lru *lru)
{
 long count = 0;
 int nid;

 for (((nid)) = __first_node(&(node_states[N_NORMAL_MEMORY])); ((nid)) < (1 << 8); ((nid)) = __next_node((((nid))), &((node_states[N_NORMAL_MEMORY]))))
  count += list_lru_count_node(lru, nid);

 return count;
}

void list_lru_isolate(struct list_lru_one *list, struct list_head *item);
void list_lru_isolate_move(struct list_lru_one *list, struct list_head *item,
      struct list_head *head);

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *item,
  struct list_lru_one *list, spinlock_t *lock, void *cb_arg);
# 166 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_walk_one(struct list_lru *lru,
    int nid, struct mem_cgroup *memcg,
    list_lru_walk_cb isolate, void *cb_arg,
    unsigned long *nr_to_walk);
# 183 "/home/nathan/src/linux-next/include/linux/list_lru.h"
unsigned long list_lru_walk_one_irq(struct list_lru *lru,
        int nid, struct mem_cgroup *memcg,
        list_lru_walk_cb isolate, void *cb_arg,
        unsigned long *nr_to_walk);
unsigned long list_lru_walk_node(struct list_lru *lru, int nid,
     list_lru_walk_cb isolate, void *cb_arg,
     unsigned long *nr_to_walk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_shrink_walk(struct list_lru *lru, struct shrink_control *sc,
       list_lru_walk_cb isolate, void *cb_arg)
{
 return list_lru_walk_one(lru, sc->nid, sc->memcg, isolate, cb_arg,
     &sc->nr_to_scan);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_shrink_walk_irq(struct list_lru *lru, struct shrink_control *sc,
    list_lru_walk_cb isolate, void *cb_arg)
{
 return list_lru_walk_one_irq(lru, sc->nid, sc->memcg, isolate, cb_arg,
         &sc->nr_to_scan);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
list_lru_walk(struct list_lru *lru, list_lru_walk_cb isolate,
       void *cb_arg, unsigned long nr_to_walk)
{
 long isolated = 0;
 int nid;

 for (((nid)) = __first_node(&(node_states[N_NORMAL_MEMORY])); ((nid)) < (1 << 8); ((nid)) = __next_node((((nid))), &((node_states[N_NORMAL_MEMORY])))) {
  isolated += list_lru_walk_node(lru, nid, isolate,
            cb_arg, &nr_to_walk);
  if (nr_to_walk <= 0)
   break;
 }
 return isolated;
}
# 14 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 24 "/home/nathan/src/linux-next/include/linux/fs.h"
# 1 "/home/nathan/src/linux-next/include/linux/capability.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/capability.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/capability.h" 1
# 39 "/home/nathan/src/linux-next/include/uapi/linux/capability.h"
typedef struct __user_cap_header_struct {
 __u32 version;
 int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
        __u32 effective;
        __u32 permitted;
        __u32 inheritable;
} *cap_user_data_t;
# 72 "/home/nathan/src/linux-next/include/uapi/linux/capability.h"
struct vfs_cap_data {
 __le32 magic_etc;
 struct {
  __le32 permitted;
  __le32 inheritable;
 } data[2];
};




struct vfs_ns_cap_data {
 __le32 magic_etc;
 struct {
  __le32 permitted;
  __le32 inheritable;
 } data[2];
 __le32 rootid;
};
# 17 "/home/nathan/src/linux-next/include/linux/capability.h" 2





extern int file_caps_enabled;

typedef struct kernel_cap_struct {
 __u32 cap[2];
} kernel_cap_t;


struct cpu_vfs_cap_data {
 __u32 magic_etc;
 kernel_cap_t permitted;
 kernel_cap_t inheritable;
 kuid_t rootid;
};





struct file;
struct inode;
struct dentry;
struct task_struct;
struct user_namespace;

extern const kernel_cap_t __cap_empty_set;
extern const kernel_cap_t __cap_init_eff_set;
# 118 "/home/nathan/src/linux-next/include/linux/capability.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_combine(const kernel_cap_t a,
           const kernel_cap_t b)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] | b.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_intersect(const kernel_cap_t a,
      const kernel_cap_t b)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] & b.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop(const kernel_cap_t a,
        const kernel_cap_t drop)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] &~ drop.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_invert(const kernel_cap_t c)
{
 kernel_cap_t dest;
 do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = ~ c.cap[__capi]; } } while (0);
 return dest;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_isclear(const kernel_cap_t a)
{
 unsigned __capi;
 for (__capi = 0; __capi < 2; ++__capi) {
  if (a.cap[__capi] != 0)
   return false;
 }
 return true;
}
# 166 "/home/nathan/src/linux-next/include/linux/capability.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_issubset(const kernel_cap_t a, const kernel_cap_t set)
{
 kernel_cap_t dest;
 dest = cap_drop(a, set);
 return cap_isclear(dest);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop_fs_set(const kernel_cap_t a)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
 return cap_drop(a, __cap_fs_set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_raise_fs_set(const kernel_cap_t a,
         const kernel_cap_t permitted)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
 return cap_combine(a,
      cap_intersect(permitted, __cap_fs_set));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_drop_nfsd_set(const kernel_cap_t a)
{
 const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
 return cap_drop(a, __cap_fs_set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kernel_cap_t cap_raise_nfsd_set(const kernel_cap_t a,
           const kernel_cap_t permitted)
{
 const kernel_cap_t __cap_nfsd_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
 return cap_combine(a,
      cap_intersect(permitted, __cap_nfsd_set));
}


extern bool has_capability(struct task_struct *t, int cap);
extern bool has_ns_capability(struct task_struct *t,
         struct user_namespace *ns, int cap);
extern bool has_capability_noaudit(struct task_struct *t, int cap);
extern bool has_ns_capability_noaudit(struct task_struct *t,
          struct user_namespace *ns, int cap);
extern bool capable(int cap);
extern bool ns_capable(struct user_namespace *ns, int cap);
extern bool ns_capable_noaudit(struct user_namespace *ns, int cap);
extern bool ns_capable_setid(struct user_namespace *ns, int cap);
# 250 "/home/nathan/src/linux-next/include/linux/capability.h"
extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);
extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
extern bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns);


extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);

extern int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size);
# 25 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/semaphore.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/semaphore.h"
struct semaphore {
 raw_spinlock_t lock;
 unsigned int count;
 struct list_head wait_list;
};
# 31 "/home/nathan/src/linux-next/include/linux/semaphore.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sema_init(struct semaphore *sem, int val)
{
 static struct lock_class_key __key;
 *sem = (struct semaphore) { .lock = (raw_spinlock_t) { .raw_lock = { 0 }, }, .count = val, .wait_list = { &((*sem).wait_list), &((*sem).wait_list) }, };
 do { (void)("semaphore->lock"); (void)(&__key); } while (0);
}

extern void down(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_interruptible(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_killable(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_trylock(struct semaphore *sem);
extern int __attribute__((__warn_unused_result__)) down_timeout(struct semaphore *sem, long jiffies);
extern void up(struct semaphore *sem);
# 26 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/fcntl.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h" 1
# 156 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h"
struct f_owner_ex {
 int type;
 __kernel_pid_t pid;
};
# 196 "/home/nathan/src/linux-next/include/uapi/asm-generic/fcntl.h"
struct flock {
 short l_type;
 short l_whence;
 __kernel_off_t l_start;
 __kernel_off_t l_len;
 __kernel_pid_t l_pid;

};







struct flock64 {
 short l_type;
 short l_whence;
 __kernel_loff_t l_start;
 __kernel_loff_t l_len;
 __kernel_pid_t l_pid;

};
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/fcntl.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/openat2.h" 1
# 19 "/home/nathan/src/linux-next/include/uapi/linux/openat2.h"
struct open_how {
 __u64 flags;
 __u64 mode;
 __u64 resolve;
};
# 7 "/home/nathan/src/linux-next/include/uapi/linux/fcntl.h" 2
# 7 "/home/nathan/src/linux-next/include/linux/fcntl.h" 2
# 27 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/fiemap.h" 1
# 17 "/home/nathan/src/linux-next/include/uapi/linux/fiemap.h"
struct fiemap_extent {
 __u64 fe_logical;

 __u64 fe_physical;

 __u64 fe_length;
 __u64 fe_reserved64[2];
 __u32 fe_flags;
 __u32 fe_reserved[3];
};

struct fiemap {
 __u64 fm_start;

 __u64 fm_length;

 __u32 fm_flags;
 __u32 fm_mapped_extents;
 __u32 fm_extent_count;
 __u32 fm_reserved;
 struct fiemap_extent fm_extents[0];
};
# 28 "/home/nathan/src/linux-next/include/linux/fs.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/migrate_mode.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/migrate_mode.h"
enum migrate_mode {
 MIGRATE_ASYNC,
 MIGRATE_SYNC_LIGHT,
 MIGRATE_SYNC,
 MIGRATE_SYNC_NO_COPY,
};
# 32 "/home/nathan/src/linux-next/include/linux/fs.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/rcuwait.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/rcuwait.h"
struct rcuwait {
 struct task_struct *task;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rcuwait_init(struct rcuwait *w)
{
 w->task = ((void *)0);
}

extern void rcuwait_wake_up(struct rcuwait *w);
# 9 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rcu_sync.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/rcu_sync.h"
struct rcu_sync {
 int gp_state;
 int gp_count;
 wait_queue_head_t gp_wait;

 struct callback_head cb_head;
};
# 32 "/home/nathan/src/linux-next/include/linux/rcu_sync.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rcu_sync_is_idle(struct rcu_sync *rsp)
{
 do { } while (0);

 return !({ union { typeof(rsp->gp_state) __val; char __c[1]; } __u; if (1) __read_once_size(&(rsp->gp_state), __u.__c, sizeof(rsp->gp_state)); else __read_once_size_nocheck(&(rsp->gp_state), __u.__c, sizeof(rsp->gp_state)); do { } while (0); __u.__val; });
}

extern void rcu_sync_init(struct rcu_sync *);
extern void rcu_sync_enter_start(struct rcu_sync *);
extern void rcu_sync_enter(struct rcu_sync *);
extern void rcu_sync_exit(struct rcu_sync *);
extern void rcu_sync_dtor(struct rcu_sync *);
# 10 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h" 2


struct percpu_rw_semaphore {
 struct rcu_sync rss;
 unsigned int *read_count;
 struct rw_semaphore rw_sem;
 struct rcuwait writer;
 int readers_block;
};
# 33 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
extern int __percpu_down_read(struct percpu_rw_semaphore *, int);
extern void __percpu_up_read(struct percpu_rw_semaphore *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_down_read(struct percpu_rw_semaphore *sem)
{
 do { do { } while (0); } while (0);

 do { } while (0);

 __asm__ __volatile__("" : : : "memory");
# 51 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 if (__builtin_expect(!!(!rcu_sync_is_idle(&sem->rss)), 0))
  __percpu_down_read(sem, false);




 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int percpu_down_read_trylock(struct percpu_rw_semaphore *sem)
{
 int ret = 1;

 __asm__ __volatile__("" : : : "memory");



 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 if (__builtin_expect(!!(!rcu_sync_is_idle(&sem->rss)), 0))
  ret = __percpu_down_read(sem, true);
 __asm__ __volatile__("" : : : "memory");





 if (ret)
  do { } while (0);

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_up_read(struct percpu_rw_semaphore *sem)
{
 __asm__ __volatile__("" : : : "memory");



 if (__builtin_expect(!!(rcu_sync_is_idle(&sem->rss)), 1))
  ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*sem->read_count)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(*sem->read_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count))); (typeof((typeof(*(&(*sem->read_count))) *)(&(*sem->read_count)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*sem->read_count))(1); } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 else
  __percpu_up_read(sem);
 __asm__ __volatile__("" : : : "memory");

 do { } while (0);
}

extern void percpu_down_write(struct percpu_rw_semaphore *);
extern void percpu_up_write(struct percpu_rw_semaphore *);

extern int __percpu_init_rwsem(struct percpu_rw_semaphore *,
    const char *, struct lock_class_key *);

extern void percpu_free_rwsem(struct percpu_rw_semaphore *);
# 118 "/home/nathan/src/linux-next/include/linux/percpu-rwsem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_rwsem_release(struct percpu_rw_semaphore *sem,
     bool read, unsigned long ip)
{
 do { } while (0);

 if (!read)
  atomic_long_set(&sem->rw_sem.owner, (-2L));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_rwsem_acquire(struct percpu_rw_semaphore *sem,
     bool read, unsigned long ip)
{
 do { } while (0);

 if (!read)
  atomic_long_set(&sem->rw_sem.owner, (long)get_current());

}
# 35 "/home/nathan/src/linux-next/include/linux/fs.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/delayed_call.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/delayed_call.h"
struct delayed_call {
 void (*fn)(void *);
 void *arg;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_delayed_call(struct delayed_call *call,
  void (*fn)(void *), void *arg)
{
 call->fn = fn;
 call->arg = arg;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void do_delayed_call(struct delayed_call *call)
{
 if (call->fn)
  call->fn(call->arg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_delayed_call(struct delayed_call *call)
{
 call->fn = ((void *)0);
}
# 37 "/home/nathan/src/linux-next/include/linux/fs.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/errseq.h" 1







typedef u32 errseq_t;

errseq_t errseq_set(errseq_t *eseq, int err);
errseq_t errseq_sample(errseq_t *eseq);
int errseq_check(errseq_t *eseq, errseq_t since);
int errseq_check_and_advance(errseq_t *eseq, errseq_t *since);
# 39 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/ioprio.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/sched/rt.h" 1






struct task_struct;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rt_prio(int prio)
{
 if (__builtin_expect(!!(prio < 100), 0))
  return 1;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rt_task(struct task_struct *p)
{
 return rt_prio(p->prio);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_is_realtime(struct task_struct *tsk)
{
 int policy = tsk->policy;

 if (policy == 1 || policy == 2)
  return true;
 if (policy == 6)
  return true;
 return false;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *rt_mutex_get_top_task(struct task_struct *p)
{
 return p->pi_top_task;
}
extern void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task);
extern void rt_mutex_adjust_pi(struct task_struct *p);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tsk_is_pi_blocked(struct task_struct *tsk)
{
 return tsk->pi_blocked_on != ((void *)0);
}
# 58 "/home/nathan/src/linux-next/include/linux/sched/rt.h"
extern void normalize_rt_tasks(void);
# 7 "/home/nathan/src/linux-next/include/linux/ioprio.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/iocontext.h" 1








enum {
 ICQ_EXITED = 1 << 2,
};
# 72 "/home/nathan/src/linux-next/include/linux/iocontext.h"
struct io_cq {
 struct request_queue *q;
 struct io_context *ioc;







 union {
  struct list_head q_node;
  struct kmem_cache *__rcu_icq_cache;
 };
 union {
  struct hlist_node ioc_node;
  struct callback_head __rcu_head;
 };

 unsigned int flags;
};





struct io_context {
 atomic_long_t refcount;
 atomic_t active_ref;
 atomic_t nr_tasks;


 spinlock_t lock;

 unsigned short ioprio;




 int nr_batch_requests;
 unsigned long last_waited;

 struct xarray icq_tree;
 struct io_cq *icq_hint;
 struct hlist_head icq_list;

 struct work_struct release_work;
};
# 129 "/home/nathan/src/linux-next/include/linux/iocontext.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void get_io_context_active(struct io_context *ioc)
{
 ({ int __ret_warn_on = !!(atomic_long_read(&ioc->refcount) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (131), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 ({ int __ret_warn_on = !!(atomic_read(&ioc->active_ref) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (132), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 atomic_long_inc(&ioc->refcount);
 atomic_inc(&ioc->active_ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ioc_task_link(struct io_context *ioc)
{
 get_io_context_active(ioc);

 ({ int __ret_warn_on = !!(atomic_read(&ioc->nr_tasks) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/iocontext.h"), "i" (141), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 atomic_inc(&ioc->nr_tasks);
}

struct task_struct;

void put_io_context(struct io_context *ioc);
void put_io_context_active(struct io_context *ioc);
void exit_io_context(struct task_struct *task);
struct io_context *get_task_io_context(struct task_struct *task,
           gfp_t gfp_flags, int node);
# 8 "/home/nathan/src/linux-next/include/linux/ioprio.h" 2
# 27 "/home/nathan/src/linux-next/include/linux/ioprio.h"
enum {
 IOPRIO_CLASS_NONE,
 IOPRIO_CLASS_RT,
 IOPRIO_CLASS_BE,
 IOPRIO_CLASS_IDLE,
};






enum {
 IOPRIO_WHO_PROCESS = 1,
 IOPRIO_WHO_PGRP,
 IOPRIO_WHO_USER,
};
# 54 "/home/nathan/src/linux-next/include/linux/ioprio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice_ioprio(struct task_struct *task)
{
 return (task_nice(task) + 20) / 5;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int task_nice_ioclass(struct task_struct *task)
{
 if (task->policy == 5)
  return IOPRIO_CLASS_IDLE;
 else if (task_is_realtime(task))
  return IOPRIO_CLASS_RT;
 else
  return IOPRIO_CLASS_BE;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_current_ioprio(void)
{
 struct io_context *ioc = get_current()->io_context;

 if (ioc)
  return ioc->ioprio;
 return (((IOPRIO_CLASS_NONE) << (13)) | 0);
}




extern int ioprio_best(unsigned short aprio, unsigned short bprio);

extern int set_task_ioprio(struct task_struct *task, int ioprio);


extern int ioprio_check_cap(int ioprio);
# 40 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/fs_types.h" 1
# 71 "/home/nathan/src/linux-next/include/linux/fs_types.h"
extern unsigned char fs_ftype_to_dtype(unsigned int filetype);
extern unsigned char fs_umode_to_ftype(umode_t mode);
extern unsigned char fs_umode_to_dtype(umode_t mode);
# 41 "/home/nathan/src/linux-next/include/linux/fs.h" 2




# 1 "/home/nathan/src/linux-next/include/uapi/linux/fs.h" 1
# 14 "/home/nathan/src/linux-next/include/uapi/linux/fs.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/ioctl.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/ioctl.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/ioctl.h" 1
# 6 "/home/nathan/src/linux-next/include/asm-generic/ioctl.h" 2





extern unsigned int __invalid_size_argument_for_IOC;
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/ioctl.h" 2
# 6 "/home/nathan/src/linux-next/include/uapi/linux/ioctl.h" 2
# 15 "/home/nathan/src/linux-next/include/uapi/linux/fs.h" 2
# 54 "/home/nathan/src/linux-next/include/uapi/linux/fs.h"
struct file_clone_range {
 __s64 src_fd;
 __u64 src_offset;
 __u64 src_length;
 __u64 dest_offset;
};

struct fstrim_range {
 __u64 start;
 __u64 len;
 __u64 minlen;
};






struct file_dedupe_range_info {
 __s64 dest_fd;
 __u64 dest_offset;
 __u64 bytes_deduped;






 __s32 status;
 __u32 reserved;
};


struct file_dedupe_range {
 __u64 src_offset;
 __u64 src_length;
 __u16 dest_count;
 __u16 reserved1;
 __u32 reserved2;
 struct file_dedupe_range_info info[0];
};


struct files_stat_struct {
 unsigned long nr_files;
 unsigned long nr_free_files;
 unsigned long max_files;
};

struct inodes_stat_t {
 long nr_inodes;
 long nr_unused;
 long dummy[5];
};







struct fsxattr {
 __u32 fsx_xflags;
 __u32 fsx_extsize;
 __u32 fsx_nextents;
 __u32 fsx_projid;
 __u32 fsx_cowextsize;
 unsigned char fsx_pad[8];
};
# 285 "/home/nathan/src/linux-next/include/uapi/linux/fs.h"
typedef int __kernel_rwf_t;
# 46 "/home/nathan/src/linux-next/include/linux/fs.h" 2

struct backing_dev_info;
struct bdi_writeback;
struct bio;
struct export_operations;
struct hd_geometry;
struct iovec;
struct kiocb;
struct kobject;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct vm_area_struct;
struct vfsmount;
struct cred;
struct swap_info_struct;
struct seq_file;
struct workqueue_struct;
struct iov_iter;
struct fscrypt_info;
struct fscrypt_operations;
struct fsverity_info;
struct fsverity_operations;
struct fs_context;
struct fs_parameter_spec;

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) inode_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) inode_init_early(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) files_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) files_maxfiles_init(void);

extern struct files_stat_struct files_stat;
extern unsigned long get_max_files(void);
extern unsigned int sysctl_nr_open;
extern struct inodes_stat_t inodes_stat;
extern int leases_enable, lease_break_time;
extern int sysctl_protected_symlinks;
extern int sysctl_protected_hardlinks;
extern int sysctl_protected_fifos;
extern int sysctl_protected_regular;

typedef __kernel_rwf_t rwf_t;

struct buffer_head;
typedef int (get_block_t)(struct inode *inode, sector_t iblock,
   struct buffer_head *bh_result, int create);
typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
   ssize_t bytes, void *private);
# 224 "/home/nathan/src/linux-next/include/linux/fs.h"
struct iattr {
 unsigned int ia_valid;
 umode_t ia_mode;
 kuid_t ia_uid;
 kgid_t ia_gid;
 loff_t ia_size;
 struct timespec64 ia_atime;
 struct timespec64 ia_mtime;
 struct timespec64 ia_ctime;






 struct file *ia_file;
};





# 1 "/home/nathan/src/linux-next/include/linux/quota.h" 1
# 40 "/home/nathan/src/linux-next/include/linux/quota.h"
# 1 "/home/nathan/src/linux-next/include/linux/percpu_counter.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
struct percpu_counter {
 raw_spinlock_t lock;
 s64 count;

 struct list_head list;

 s32 *counters;
};

extern int percpu_counter_batch;

int __percpu_counter_init(struct percpu_counter *fbc, s64 amount, gfp_t gfp,
     struct lock_class_key *key);
# 41 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
void percpu_counter_destroy(struct percpu_counter *fbc);
void percpu_counter_set(struct percpu_counter *fbc, s64 amount);
void percpu_counter_add_batch(struct percpu_counter *fbc, s64 amount,
         s32 batch);
s64 __percpu_counter_sum(struct percpu_counter *fbc);
int __percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int percpu_counter_compare(struct percpu_counter *fbc, s64 rhs)
{
 return __percpu_counter_compare(fbc, rhs, percpu_counter_batch);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
 percpu_counter_add_batch(fbc, amount, percpu_counter_batch);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
{
 s64 ret = __percpu_counter_sum(fbc);
 return ret < 0 ? 0 : ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_sum(struct percpu_counter *fbc)
{
 return __percpu_counter_sum(fbc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_read(struct percpu_counter *fbc)
{
 return fbc->count;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 percpu_counter_read_positive(struct percpu_counter *fbc)
{
 s64 ret = fbc->count;

 __asm__ __volatile__("" : : : "memory");
 if (ret >= 0)
  return ret;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool percpu_counter_initialized(struct percpu_counter *fbc)
{
 return (fbc->counters != ((void *)0));
}
# 177 "/home/nathan/src/linux-next/include/linux/percpu_counter.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_inc(struct percpu_counter *fbc)
{
 percpu_counter_add(fbc, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_dec(struct percpu_counter *fbc)
{
 percpu_counter_add(fbc, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
{
 percpu_counter_add(fbc, -amount);
}
# 41 "/home/nathan/src/linux-next/include/linux/quota.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h" 1
# 53 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_disk_quota {
 __s8 d_version;
 __s8 d_flags;
 __u16 d_fieldmask;
 __u32 d_id;
 __u64 d_blk_hardlimit;
 __u64 d_blk_softlimit;
 __u64 d_ino_hardlimit;
 __u64 d_ino_softlimit;
 __u64 d_bcount;
 __u64 d_icount;
 __s32 d_itimer;

 __s32 d_btimer;
 __u16 d_iwarns;
 __u16 d_bwarns;
 __s32 d_padding2;
 __u64 d_rtb_hardlimit;
 __u64 d_rtb_softlimit;
 __u64 d_rtbcount;
 __s32 d_rtbtimer;
 __u16 d_rtbwarns;
 __s16 d_padding3;
 char d_padding4[8];
} fs_disk_quota_t;
# 149 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat {
 __u64 qfs_ino;
 __u64 qfs_nblks;
 __u32 qfs_nextents;
} fs_qfilestat_t;

typedef struct fs_quota_stat {
 __s8 qs_version;
 __u16 qs_flags;
 __s8 qs_pad;
 fs_qfilestat_t qs_uquota;
 fs_qfilestat_t qs_gquota;
 __u32 qs_incoredqs;
 __s32 qs_btimelimit;
 __s32 qs_itimelimit;
 __s32 qs_rtbtimelimit;
 __u16 qs_bwarnlimit;
 __u16 qs_iwarnlimit;
} fs_quota_stat_t;
# 192 "/home/nathan/src/linux-next/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
 __u64 qfs_ino;
 __u64 qfs_nblks;
 __u32 qfs_nextents;
 __u32 qfs_pad;
};

struct fs_quota_statv {
 __s8 qs_version;
 __u8 qs_pad1;
 __u16 qs_flags;
 __u32 qs_incoredqs;
 struct fs_qfilestatv qs_uquota;
 struct fs_qfilestatv qs_gquota;
 struct fs_qfilestatv qs_pquota;
 __s32 qs_btimelimit;
 __s32 qs_itimelimit;
 __s32 qs_rtbtimelimit;
 __u16 qs_bwarnlimit;
 __u16 qs_iwarnlimit;
 __u64 qs_pad2[8];
};
# 43 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dqblk_v1.h" 1
# 44 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dqblk_v2.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/dqblk_qtree.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/dqblk_qtree.h"
struct dquot;
struct kqid;


struct qtree_fmt_operations {
 void (*mem2disk_dqblk)(void *disk, struct dquot *dquot);
 void (*disk2mem_dqblk)(struct dquot *dquot, void *disk);
 int (*is_id)(void *disk, struct dquot *dquot);
};


struct qtree_mem_dqinfo {
 struct super_block *dqi_sb;
 int dqi_type;
 unsigned int dqi_blocks;
 unsigned int dqi_free_blk;
 unsigned int dqi_free_entry;
 unsigned int dqi_blocksize_bits;
 unsigned int dqi_entry_size;
 unsigned int dqi_usable_bs;
 unsigned int dqi_qtree_depth;
 const struct qtree_fmt_operations *dqi_ops;
};

int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qtree_depth(struct qtree_mem_dqinfo *info)
{
 unsigned int epb = info->dqi_usable_bs >> 2;
 unsigned long long entries = epb;
 int i;

 for (i = 1; entries < (1ULL << 32); i++)
  entries *= epb;
 return i;
}
int qtree_get_next_id(struct qtree_mem_dqinfo *info, struct kqid *qid);
# 10 "/home/nathan/src/linux-next/include/linux/dqblk_v2.h" 2
# 45 "/home/nathan/src/linux-next/include/linux/quota.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/projid.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/projid.h"
struct user_namespace;
extern struct user_namespace init_user_ns;

typedef __kernel_uid32_t projid_t;

typedef struct {
 projid_t val;
} kprojid_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) projid_t __kprojid_val(kprojid_t projid)
{
 return projid.val;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_eq(kprojid_t left, kprojid_t right)
{
 return __kprojid_val(left) == __kprojid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_lt(kprojid_t left, kprojid_t right)
{
 return __kprojid_val(left) < __kprojid_val(right);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool projid_valid(kprojid_t projid)
{
 return !projid_eq(projid, (kprojid_t){ -1 });
}
# 65 "/home/nathan/src/linux-next/include/linux/projid.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kprojid_t make_kprojid(struct user_namespace *from, projid_t projid)
{
 return (kprojid_t){ projid };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) projid_t from_kprojid(struct user_namespace *to, kprojid_t kprojid)
{
 return __kprojid_val(kprojid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) projid_t from_kprojid_munged(struct user_namespace *to, kprojid_t kprojid)
{
 projid_t projid = from_kprojid(to, kprojid);
 if (projid == (projid_t)-1)
  projid = 65534;
 return projid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kprojid_has_mapping(struct user_namespace *ns, kprojid_t projid)
{
 return true;
}
# 49 "/home/nathan/src/linux-next/include/linux/quota.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/quota.h" 1
# 90 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 QIF_BLIMITS_B = 0,
 QIF_SPACE_B,
 QIF_ILIMITS_B,
 QIF_INODES_B,
 QIF_BTIME_B,
 QIF_ITIME_B,
};
# 110 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
struct if_dqblk {
 __u64 dqb_bhardlimit;
 __u64 dqb_bsoftlimit;
 __u64 dqb_curspace;
 __u64 dqb_ihardlimit;
 __u64 dqb_isoftlimit;
 __u64 dqb_curinodes;
 __u64 dqb_btime;
 __u64 dqb_itime;
 __u32 dqb_valid;
};

struct if_nextdqblk {
 __u64 dqb_bhardlimit;
 __u64 dqb_bsoftlimit;
 __u64 dqb_curspace;
 __u64 dqb_ihardlimit;
 __u64 dqb_isoftlimit;
 __u64 dqb_curinodes;
 __u64 dqb_btime;
 __u64 dqb_itime;
 __u32 dqb_valid;
 __u32 dqb_id;
};
# 144 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 DQF_ROOT_SQUASH_B = 0,
 DQF_SYS_FILE_B = 16,

 DQF_PRIVATE
};






struct if_dqinfo {
 __u64 dqi_bgrace;
 __u64 dqi_igrace;
 __u32 dqi_flags;
 __u32 dqi_valid;
};
# 178 "/home/nathan/src/linux-next/include/uapi/linux/quota.h"
enum {
 QUOTA_NL_C_UNSPEC,
 QUOTA_NL_C_WARNING,
 __QUOTA_NL_C_MAX,
};


enum {
 QUOTA_NL_A_UNSPEC,
 QUOTA_NL_A_QTYPE,
 QUOTA_NL_A_EXCESS_ID,
 QUOTA_NL_A_WARNING,
 QUOTA_NL_A_DEV_MAJOR,
 QUOTA_NL_A_DEV_MINOR,
 QUOTA_NL_A_CAUSED_ID,
 QUOTA_NL_A_PAD,
 __QUOTA_NL_A_MAX,
};
# 50 "/home/nathan/src/linux-next/include/linux/quota.h" 2




enum quota_type {
 USRQUOTA = 0,
 GRPQUOTA = 1,
 PRJQUOTA = 2,
};






typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;

struct kqid {
 union {
  kuid_t uid;
  kgid_t gid;
  kprojid_t projid;
 };
 enum quota_type type;
};

extern bool qid_eq(struct kqid left, struct kqid right);
extern bool qid_lt(struct kqid left, struct kqid right);
extern qid_t from_kqid(struct user_namespace *to, struct kqid qid);
extern qid_t from_kqid_munged(struct user_namespace *to, struct kqid qid);
extern bool qid_valid(struct kqid qid);
# 97 "/home/nathan/src/linux-next/include/linux/quota.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid(struct user_namespace *from,
        enum quota_type type, qid_t qid)
{
 struct kqid kqid;

 kqid.type = type;
 switch (type) {
 case USRQUOTA:
  kqid.uid = make_kuid(from, qid);
  break;
 case GRPQUOTA:
  kqid.gid = make_kgid(from, qid);
  break;
 case PRJQUOTA:
  kqid.projid = make_kprojid(from, qid);
  break;
 default:
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/quota.h"), "i" (114), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 }
 return kqid;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_invalid(enum quota_type type)
{
 struct kqid kqid;

 kqid.type = type;
 switch (type) {
 case USRQUOTA:
  kqid.uid = (kuid_t){ -1 };
  break;
 case GRPQUOTA:
  kqid.gid = (kgid_t){ -1 };
  break;
 case PRJQUOTA:
  kqid.projid = (kprojid_t){ -1 };
  break;
 default:
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/quota.h"), "i" (141), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 }
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_uid(kuid_t uid)
{
 struct kqid kqid;
 kqid.type = USRQUOTA;
 kqid.uid = uid;
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_gid(kgid_t gid)
{
 struct kqid kqid;
 kqid.type = GRPQUOTA;
 kqid.gid = gid;
 return kqid;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct kqid make_kqid_projid(kprojid_t projid)
{
 struct kqid kqid;
 kqid.type = PRJQUOTA;
 kqid.projid = projid;
 return kqid;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qid_has_mapping(struct user_namespace *ns, struct kqid qid)
{
 return from_kqid(ns, qid) != (qid_t) -1;
}


extern spinlock_t dq_data_lock;
# 205 "/home/nathan/src/linux-next/include/linux/quota.h"
struct mem_dqblk {
 qsize_t dqb_bhardlimit;
 qsize_t dqb_bsoftlimit;
 qsize_t dqb_curspace;
 qsize_t dqb_rsvspace;
 qsize_t dqb_ihardlimit;
 qsize_t dqb_isoftlimit;
 qsize_t dqb_curinodes;
 time64_t dqb_btime;
 time64_t dqb_itime;
};




struct quota_format_type;

struct mem_dqinfo {
 struct quota_format_type *dqi_format;
 int dqi_fmt_id;

 struct list_head dqi_dirty_list;
 unsigned long dqi_flags;
 unsigned int dqi_bgrace;
 unsigned int dqi_igrace;
 qsize_t dqi_max_spc_limit;
 qsize_t dqi_max_ino_limit;
 void *dqi_priv;
};

struct super_block;






enum {
 DQF_INFO_DIRTY_B = DQF_PRIVATE,
};


extern void mark_info_dirty(struct super_block *sb, int type);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int info_dirty(struct mem_dqinfo *info)
{
 return test_bit(DQF_INFO_DIRTY_B, &info->dqi_flags);
}

enum {
 DQST_LOOKUPS,
 DQST_DROPS,
 DQST_READS,
 DQST_WRITES,
 DQST_CACHE_HITS,
 DQST_ALLOC_DQUOTS,
 DQST_FREE_DQUOTS,
 DQST_SYNCS,
 _DQST_DQSTAT_LAST
};

struct dqstats {
 unsigned long stat[_DQST_DQSTAT_LAST];
 struct percpu_counter counter[_DQST_DQSTAT_LAST];
};

extern struct dqstats dqstats;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dqstats_inc(unsigned int type)
{
 percpu_counter_inc(&dqstats.counter[type]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dqstats_dec(unsigned int type)
{
 percpu_counter_dec(&dqstats.counter[type]);
}
# 294 "/home/nathan/src/linux-next/include/linux/quota.h"
struct dquot {
 struct hlist_node dq_hash;
 struct list_head dq_inuse;
 struct list_head dq_free;
 struct list_head dq_dirty;
 struct mutex dq_lock;
 spinlock_t dq_dqb_lock;
 atomic_t dq_count;
 struct super_block *dq_sb;
 struct kqid dq_id;
 loff_t dq_off;
 unsigned long dq_flags;
 struct mem_dqblk dq_dqb;
};


struct quota_format_ops {
 int (*check_quota_file)(struct super_block *sb, int type);
 int (*read_file_info)(struct super_block *sb, int type);
 int (*write_file_info)(struct super_block *sb, int type);
 int (*free_file_info)(struct super_block *sb, int type);
 int (*read_dqblk)(struct dquot *dquot);
 int (*commit_dqblk)(struct dquot *dquot);
 int (*release_dqblk)(struct dquot *dquot);
 int (*get_next_id)(struct super_block *sb, struct kqid *qid);
};


struct dquot_operations {
 int (*write_dquot) (struct dquot *);
 struct dquot *(*alloc_dquot)(struct super_block *, int);
 void (*destroy_dquot)(struct dquot *);
 int (*acquire_dquot) (struct dquot *);
 int (*release_dquot) (struct dquot *);
 int (*mark_dirty) (struct dquot *);
 int (*write_info) (struct super_block *, int);


 qsize_t *(*get_reserved_space) (struct inode *);
 int (*get_projid) (struct inode *, kprojid_t *);

 int (*get_inode_usage) (struct inode *, qsize_t *);

 int (*get_next_id) (struct super_block *sb, struct kqid *qid);
};

struct path;


struct qc_dqblk {
 int d_fieldmask;
 u64 d_spc_hardlimit;
 u64 d_spc_softlimit;
 u64 d_ino_hardlimit;
 u64 d_ino_softlimit;
 u64 d_space;
 u64 d_ino_count;
 s64 d_ino_timer;

 s64 d_spc_timer;
 int d_ino_warns;
 int d_spc_warns;
 u64 d_rt_spc_hardlimit;
 u64 d_rt_spc_softlimit;
 u64 d_rt_space;
 s64 d_rt_spc_timer;
 int d_rt_spc_warns;
};
# 395 "/home/nathan/src/linux-next/include/linux/quota.h"
struct qc_type_state {
 unsigned int flags;
 unsigned int spc_timelimit;

 unsigned int ino_timelimit;
 unsigned int rt_spc_timelimit;
 unsigned int spc_warnlimit;
 unsigned int ino_warnlimit;
 unsigned int rt_spc_warnlimit;
 unsigned long long ino;
 blkcnt_t blocks;
 blkcnt_t nextents;
};

struct qc_state {
 unsigned int s_incoredqs;
 struct qc_type_state s_state[3];
};


struct qc_info {
 int i_fieldmask;
 unsigned int i_flags;
 unsigned int i_spc_timelimit;

 unsigned int i_ino_timelimit;
 unsigned int i_rt_spc_timelimit;
 unsigned int i_spc_warnlimit;
 unsigned int i_ino_warnlimit;
 unsigned int i_rt_spc_warnlimit;
};


struct quotactl_ops {
 int (*quota_on)(struct super_block *, int, int, const struct path *);
 int (*quota_off)(struct super_block *, int);
 int (*quota_enable)(struct super_block *, unsigned int);
 int (*quota_disable)(struct super_block *, unsigned int);
 int (*quota_sync)(struct super_block *, int);
 int (*set_info)(struct super_block *, int, struct qc_info *);
 int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
 int (*get_nextdqblk)(struct super_block *, struct kqid *,
        struct qc_dqblk *);
 int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
 int (*get_state)(struct super_block *, struct qc_state *);
 int (*rm_xquota)(struct super_block *, unsigned int);
};

struct quota_format_type {
 int qf_fmt_id;
 const struct quota_format_ops *qf_ops;
 struct module *qf_owner;
 struct quota_format_type *qf_next;
};
# 463 "/home/nathan/src/linux-next/include/linux/quota.h"
enum {
 _DQUOT_USAGE_ENABLED = 0,
 _DQUOT_LIMITS_ENABLED,
 _DQUOT_SUSPENDED,


 _DQUOT_STATE_FLAGS
};
# 490 "/home/nathan/src/linux-next/include/linux/quota.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dquot_state_flag(unsigned int flags, int type)
{
 return flags << type;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dquot_generic_flag(unsigned int flags, int type)
{
 return (flags >> type) & ((1 << _DQUOT_USAGE_ENABLED * 3) | (1 << _DQUOT_LIMITS_ENABLED * 3) | (1 << _DQUOT_SUSPENDED * 3));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned dquot_state_types(unsigned flags, unsigned flag)
{
 do { extern void __compiletime_assert_503(void) ; if (!(!((flag) == 0 || (((flag) & ((flag) - 1)) != 0)))) __compiletime_assert_503(); } while (0);
 return (flags / flag) & ((1 << 3) - 1);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void quota_send_warning(struct kqid qid, dev_t dev,
          const char warntype)
{
 return;
}


struct quota_info {
 unsigned int flags;
 struct rw_semaphore dqio_sem;
 struct inode *files[3];
 struct mem_dqinfo info[3];
 const struct quota_format_ops *ops[3];
};

int register_quota_format(struct quota_format_type *fmt);
void unregister_quota_format(struct quota_format_type *fmt);

struct quota_module_name {
 int qm_fmt_id;
 char *qm_mod_name;
};
# 246 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 279 "/home/nathan/src/linux-next/include/linux/fs.h"
enum positive_aop_returns {
 AOP_WRITEPAGE_ACTIVATE = 0x80000,
 AOP_TRUNCATED_PAGE = 0x80001,
};
# 292 "/home/nathan/src/linux-next/include/linux/fs.h"
struct page;
struct address_space;
struct writeback_control;





enum rw_hint {
 WRITE_LIFE_NOT_SET = 0,
 WRITE_LIFE_NONE = 1,
 WRITE_LIFE_SHORT = 2,
 WRITE_LIFE_MEDIUM = 3,
 WRITE_LIFE_LONG = 4,
 WRITE_LIFE_EXTREME = 5,
};
# 318 "/home/nathan/src/linux-next/include/linux/fs.h"
struct kiocb {
 struct file *ki_filp;




 loff_t ki_pos;
 void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 void *private;
 int ki_flags;
 u16 ki_hint;
 u16 ki_ioprio;
 unsigned int ki_cookie;


};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_sync_kiocb(struct kiocb *kiocb)
{
 return kiocb->ki_complete == ((void *)0);
}
# 349 "/home/nathan/src/linux-next/include/linux/fs.h"
typedef struct {
 size_t written;
 size_t count;
 union {
  char *buf;
  void *data;
 } arg;
 int error;
} read_descriptor_t;

typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
  unsigned long, unsigned long);

struct address_space_operations {
 int (*writepage)(struct page *page, struct writeback_control *wbc);
 int (*readpage)(struct file *, struct page *);


 int (*writepages)(struct address_space *, struct writeback_control *);


 int (*set_page_dirty)(struct page *page);





 int (*readpages)(struct file *filp, struct address_space *mapping,
   struct list_head *pages, unsigned nr_pages);

 int (*write_begin)(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned flags,
    struct page **pagep, void **fsdata);
 int (*write_end)(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned copied,
    struct page *page, void *fsdata);


 sector_t (*bmap)(struct address_space *, sector_t);
 void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 int (*releasepage) (struct page *, gfp_t);
 void (*freepage)(struct page *);
 ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);




 int (*migratepage) (struct address_space *,
   struct page *, struct page *, enum migrate_mode);
 bool (*isolate_page)(struct page *, isolate_mode_t);
 void (*putback_page)(struct page *);
 int (*launder_page) (struct page *);
 int (*is_partially_uptodate) (struct page *, unsigned long,
     unsigned long);
 void (*is_dirty_writeback) (struct page *, bool *, bool *);
 int (*error_remove_page)(struct address_space *, struct page *);


 int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
    sector_t *span);
 void (*swap_deactivate)(struct file *file);
};

extern const struct address_space_operations empty_aops;





int pagecache_write_begin(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned flags,
    struct page **pagep, void **fsdata);

int pagecache_write_end(struct file *, struct address_space *mapping,
    loff_t pos, unsigned len, unsigned copied,
    struct page *page, void *fsdata);
# 445 "/home/nathan/src/linux-next/include/linux/fs.h"
struct address_space {
 struct inode *host;
 struct xarray i_pages;
 gfp_t gfp_mask;
 atomic_t i_mmap_writable;




 struct rb_root_cached i_mmap;
 struct rw_semaphore i_mmap_rwsem;
 unsigned long nrpages;
 unsigned long nrexceptional;
 unsigned long writeback_index;
 const struct address_space_operations *a_ops;
 unsigned long flags;
 errseq_t wb_err;
 spinlock_t private_lock;
 struct list_head private_list;
 void *private_data;
} __attribute__((aligned(sizeof(long)))) ;





struct request_queue;

struct block_device {
 dev_t bd_dev;
 int bd_openers;
 struct inode * bd_inode;
 struct super_block * bd_super;
 struct mutex bd_mutex;
 void * bd_claiming;
 void * bd_holder;
 int bd_holders;
 bool bd_write_holder;

 struct list_head bd_holder_disks;

 struct block_device * bd_contains;
 unsigned bd_block_size;
 u8 bd_partno;
 struct hd_struct * bd_part;

 unsigned bd_part_count;
 int bd_invalidated;
 struct gendisk * bd_disk;
 struct request_queue * bd_queue;
 struct backing_dev_info *bd_bdi;
 struct list_head bd_list;






 unsigned long bd_private;


 int bd_fsfreeze_count;

 struct mutex bd_fsfreeze_mutex;
} ;
# 519 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)
{
 return xa_marked(&mapping->i_pages, tag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_lock_write(struct address_space *mapping)
{
 down_write(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_unlock_write(struct address_space *mapping)
{
 up_write(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_lock_read(struct address_space *mapping)
{
 down_read(&mapping->i_mmap_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_mmap_unlock_read(struct address_space *mapping)
{
 up_read(&mapping->i_mmap_rwsem);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_mapped(struct address_space *mapping)
{
 return !(({ union { typeof((&mapping->i_mmap.rb_root)->rb_node) __val; char __c[1]; } __u; if (1) __read_once_size(&((&mapping->i_mmap.rb_root)->rb_node), __u.__c, sizeof((&mapping->i_mmap.rb_root)->rb_node)); else __read_once_size_nocheck(&((&mapping->i_mmap.rb_root)->rb_node), __u.__c, sizeof((&mapping->i_mmap.rb_root)->rb_node)); do { } while (0); __u.__val; }) == ((void *)0));
}
# 561 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_writably_mapped(struct address_space *mapping)
{
 return atomic_read(&mapping->i_mmap_writable) > 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_map_writable(struct address_space *mapping)
{
 return atomic_inc_unless_negative(&mapping->i_mmap_writable) ?
  0 : -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_unmap_writable(struct address_space *mapping)
{
 atomic_dec(&mapping->i_mmap_writable);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_deny_writable(struct address_space *mapping)
{
 return atomic_dec_unless_positive(&mapping->i_mmap_writable) ?
  0 : -16;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_allow_writable(struct address_space *mapping)
{
 atomic_inc(&mapping->i_mmap_writable);
}
# 599 "/home/nathan/src/linux-next/include/linux/fs.h"
struct posix_acl;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct posix_acl *
uncached_acl_sentinel(struct task_struct *task)
{
 return (void *)task + 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
is_uncached_acl(struct posix_acl *acl)
{
 return (long)acl & 1;
}







struct fsnotify_mark_connector;






struct inode {
 umode_t i_mode;
 unsigned short i_opflags;
 kuid_t i_uid;
 kgid_t i_gid;
 unsigned int i_flags;


 struct posix_acl *i_acl;
 struct posix_acl *i_default_acl;


 const struct inode_operations *i_op;
 struct super_block *i_sb;
 struct address_space *i_mapping;






 unsigned long i_ino;







 union {
  const unsigned int i_nlink;
  unsigned int __i_nlink;
 };
 dev_t i_rdev;
 loff_t i_size;
 struct timespec64 i_atime;
 struct timespec64 i_mtime;
 struct timespec64 i_ctime;
 spinlock_t i_lock;
 unsigned short i_bytes;
 u8 i_blkbits;
 u8 i_write_hint;
 blkcnt_t i_blocks;






 unsigned long i_state;
 struct rw_semaphore i_rwsem;

 unsigned long dirtied_when;
 unsigned long dirtied_time_when;

 struct hlist_node i_hash;
 struct list_head i_io_list;
# 693 "/home/nathan/src/linux-next/include/linux/fs.h"
 struct list_head i_lru;
 struct list_head i_sb_list;
 struct list_head i_wb_list;
 union {
  struct hlist_head i_dentry;
  struct callback_head i_rcu;
 };
 atomic64_t i_version;
 atomic_t i_count;
 atomic_t i_dio_count;
 atomic_t i_writecount;

 atomic_t i_readcount;

 union {
  const struct file_operations *i_fop;
  void (*free_inode)(struct inode *);
 };
 struct file_lock_context *i_flctx;
 struct address_space i_data;
 struct list_head i_devices;
 union {
  struct pipe_inode_info *i_pipe;
  struct block_device *i_bdev;
  struct cdev *i_cdev;
  char *i_link;
  unsigned i_dir_seq;
 };

 __u32 i_generation;


 __u32 i_fsnotify_mask;
 struct fsnotify_mark_connector *i_fsnotify_marks;
# 737 "/home/nathan/src/linux-next/include/linux/fs.h"
 void *i_private;
} ;

struct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int i_blocksize(const struct inode *node)
{
 return (1 << node->i_blkbits);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_unhashed(struct inode *inode)
{
 return hlist_unhashed(&inode->i_hash);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_fake_hash(struct inode *inode)
{
 hlist_add_fake(&inode->i_hash);
}
# 779 "/home/nathan/src/linux-next/include/linux/fs.h"
enum inode_i_mutex_lock_class
{
 I_MUTEX_NORMAL,
 I_MUTEX_PARENT,
 I_MUTEX_CHILD,
 I_MUTEX_XATTR,
 I_MUTEX_NONDIR2,
 I_MUTEX_PARENT2,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock(struct inode *inode)
{
 down_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_unlock(struct inode *inode)
{
 up_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_shared(struct inode *inode)
{
 down_read(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_unlock_shared(struct inode *inode)
{
 up_read(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_trylock(struct inode *inode)
{
 return down_write_trylock(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_trylock_shared(struct inode *inode)
{
 return down_read_trylock(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_is_locked(struct inode *inode)
{
 return rwsem_is_locked(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_nested(struct inode *inode, unsigned subclass)
{
 down_write(&inode->i_rwsem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_lock_shared_nested(struct inode *inode, unsigned subclass)
{
 down_read(&inode->i_rwsem);
}

void lock_two_nondirectories(struct inode *, struct inode*);
void unlock_two_nondirectories(struct inode *, struct inode*);
# 847 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t i_size_read(const struct inode *inode)
{
# 866 "/home/nathan/src/linux-next/include/linux/fs.h"
 return inode->i_size;

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_size_write(struct inode *inode, loff_t i_size)
{
# 888 "/home/nathan/src/linux-next/include/linux/fs.h"
 inode->i_size = i_size;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned iminor(const struct inode *inode)
{
 return ((unsigned int) ((inode->i_rdev) & ((1U << 20) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned imajor(const struct inode *inode)
{
 return ((unsigned int) ((inode->i_rdev) >> 20));
}

extern struct block_device *I_BDEV(struct inode *inode);

struct fown_struct {
 rwlock_t lock;
 struct pid *pid;
 enum pid_type pid_type;
 kuid_t uid, euid;
 int signum;
};




struct file_ra_state {
 unsigned long start;
 unsigned int size;
 unsigned int async_size;


 unsigned int ra_pages;
 unsigned int mmap_miss;
 loff_t prev_pos;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ra_has_index(struct file_ra_state *ra, unsigned long index)
{
 return (index >= ra->start &&
  index < ra->start + ra->size);
}

struct file {
 union {
  struct llist_node fu_llist;
  struct callback_head fu_rcuhead;
 } f_u;
 struct path f_path;
 struct inode *f_inode;
 const struct file_operations *f_op;





 spinlock_t f_lock;
 enum rw_hint f_write_hint;
 atomic_long_t f_count;
 unsigned int f_flags;
 fmode_t f_mode;
 struct mutex f_pos_lock;
 loff_t f_pos;
 struct fown_struct f_owner;
 const struct cred *f_cred;
 struct file_ra_state f_ra;

 u64 f_version;




 void *private_data;



 struct list_head f_ep_links;
 struct list_head f_tfile_llink;

 struct address_space *f_mapping;
 errseq_t f_wb_err;
}
  __attribute__((aligned(4)));

struct file_handle {
 __u32 handle_bytes;
 int handle_type;

 unsigned char f_handle[0];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct file *get_file(struct file *f)
{
 atomic_long_inc(&f->f_count);
 return f;
}
# 1025 "/home/nathan/src/linux-next/include/linux/fs.h"
typedef void *fl_owner_t;

struct file_lock;

struct file_lock_operations {
 void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 void (*fl_release_private)(struct file_lock *);
};

struct lock_manager_operations {
 fl_owner_t (*lm_get_owner)(fl_owner_t);
 void (*lm_put_owner)(fl_owner_t);
 void (*lm_notify)(struct file_lock *);
 int (*lm_grant)(struct file_lock *, int);
 bool (*lm_break)(struct file_lock *);
 int (*lm_change)(struct file_lock *, int, struct list_head *);
 void (*lm_setup)(struct file_lock *, void **);
};

struct lock_manager {
 struct list_head list;




 bool block_opens;
};

struct net;
void locks_start_grace(struct net *, struct lock_manager *);
void locks_end_grace(struct lock_manager *);
bool locks_in_grace(struct net *);
bool opens_in_grace(struct net *);



# 1 "/home/nathan/src/linux-next/include/linux/nfs_fs_i.h" 1




struct nlm_lockowner;




struct nfs_lock_info {
 u32 state;
 struct nlm_lockowner *owner;
 struct list_head list;
};

struct nfs4_lock_state;
struct nfs4_lock_info {
 struct nfs4_lock_state *owner;
};
# 1061 "/home/nathan/src/linux-next/include/linux/fs.h" 2
# 1079 "/home/nathan/src/linux-next/include/linux/fs.h"
struct file_lock {
 struct file_lock *fl_blocker;
 struct list_head fl_list;
 struct hlist_node fl_link;
 struct list_head fl_blocked_requests;


 struct list_head fl_blocked_member;


 fl_owner_t fl_owner;
 unsigned int fl_flags;
 unsigned char fl_type;
 unsigned int fl_pid;
 int fl_link_cpu;
 wait_queue_head_t fl_wait;
 struct file *fl_file;
 loff_t fl_start;
 loff_t fl_end;

 struct fasync_struct * fl_fasync;

 unsigned long fl_break_time;
 unsigned long fl_downgrade_time;

 const struct file_lock_operations *fl_ops;
 const struct lock_manager_operations *fl_lmops;
 union {
  struct nfs_lock_info nfs_fl;
  struct nfs4_lock_info nfs4_fl;
  struct {
   struct list_head link;
   int state;
   unsigned int debug_id;
  } afs;
 } fl_u;
} ;

struct file_lock_context {
 spinlock_t flc_lock;
 struct list_head flc_flock;
 struct list_head flc_posix;
 struct list_head flc_lease;
};
# 1131 "/home/nathan/src/linux-next/include/linux/fs.h"
extern void send_sigio(struct fown_struct *fown, int fd, int band);




extern int fcntl_getlk(struct file *, unsigned int, struct flock *);
extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
   struct flock *);







extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
extern int fcntl_getlease(struct file *filp);


void locks_free_lock_context(struct inode *inode);
void locks_free_lock(struct file_lock *fl);
extern void locks_init_lock(struct file_lock *);
extern struct file_lock * locks_alloc_lock(void);
extern void locks_copy_lock(struct file_lock *, struct file_lock *);
extern void locks_copy_conflock(struct file_lock *, struct file_lock *);
extern void locks_remove_posix(struct file *, fl_owner_t);
extern void locks_remove_file(struct file *);
extern void locks_release_private(struct file_lock *);
extern void posix_test_lock(struct file *, struct file_lock *);
extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
extern int locks_delete_block(struct file_lock *);
extern int vfs_test_lock(struct file *, struct file_lock *);
extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
extern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);
extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
extern void lease_get_mtime(struct inode *, struct timespec64 *time);
extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
extern int lease_modify(struct file_lock *, int, struct list_head *);

struct notifier_block;
extern int lease_register_notifier(struct notifier_block *);
extern void lease_unregister_notifier(struct notifier_block *);

struct files_struct;
extern void show_fd_locks(struct seq_file *f,
    struct file *filp, struct files_struct *files);
# 1316 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *file_inode(const struct file *f)
{
 return f->f_inode;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *file_dentry(const struct file *file)
{
 return d_real(file->f_path.dentry, file_inode(file));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
{
 return locks_lock_inode_wait(file_inode(filp), fl);
}

struct fasync_struct {
 rwlock_t fa_lock;
 int magic;
 int fa_fd;
 struct fasync_struct *fa_next;
 struct file *fa_file;
 struct callback_head fa_rcu;
};




extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
extern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);
extern int fasync_remove_entry(struct file *, struct fasync_struct **);
extern struct fasync_struct *fasync_alloc(void);
extern void fasync_free(struct fasync_struct *);


extern void kill_fasync(struct fasync_struct **, int, int);

extern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
extern int f_setown(struct file *filp, unsigned long arg, int force);
extern void f_delown(struct file *filp);
extern pid_t f_getown(struct file *filp);
extern int send_sigurg(struct fown_struct *fown);
# 1407 "/home/nathan/src/linux-next/include/linux/fs.h"
enum {
 SB_UNFROZEN = 0,
 SB_FREEZE_WRITE = 1,
 SB_FREEZE_PAGEFAULT = 2,
 SB_FREEZE_FS = 3,

 SB_FREEZE_COMPLETE = 4,
};



struct sb_writers {
 int frozen;
 wait_queue_head_t wait_unfrozen;
 struct percpu_rw_semaphore rw_sem[(SB_FREEZE_COMPLETE - 1)];
};

struct super_block {
 struct list_head s_list;
 dev_t s_dev;
 unsigned char s_blocksize_bits;
 unsigned long s_blocksize;
 loff_t s_maxbytes;
 struct file_system_type *s_type;
 const struct super_operations *s_op;
 const struct dquot_operations *dq_op;
 const struct quotactl_ops *s_qcop;
 const struct export_operations *s_export_op;
 unsigned long s_flags;
 unsigned long s_iflags;
 unsigned long s_magic;
 struct dentry *s_root;
 struct rw_semaphore s_umount;
 int s_count;
 atomic_t s_active;



 const struct xattr_handler **s_xattr;







 struct hlist_bl_head s_roots;
 struct list_head s_mounts;
 struct block_device *s_bdev;
 struct backing_dev_info *s_bdi;
 struct mtd_info *s_mtd;
 struct hlist_node s_instances;
 unsigned int s_quota_types;
 struct quota_info s_dquot;

 struct sb_writers s_writers;






 void *s_fs_info;


 u32 s_time_gran;

 time64_t s_time_min;
 time64_t s_time_max;

 __u32 s_fsnotify_mask;
 struct fsnotify_mark_connector *s_fsnotify_marks;


 char s_id[32];
 uuid_t s_uuid;

 unsigned int s_max_links;
 fmode_t s_mode;





 struct mutex s_vfs_rename_mutex;





 const char *s_subtype;

 const struct dentry_operations *s_d_op;




 int cleancache_poolid;

 struct shrinker s_shrink;


 atomic_long_t s_remove_count;


 atomic_long_t s_fsnotify_inode_refs;


 int s_readonly_remount;


 struct workqueue_struct *s_dio_done_wq;
 struct hlist_head s_pins;






 struct user_namespace *s_user_ns;






 struct list_lru s_dentry_lru;
 struct list_lru s_inode_lru;
 struct callback_head rcu;
 struct work_struct destroy_work;

 struct mutex s_sync_lock;




 int s_stack_depth;


 spinlock_t s_inode_list_lock __attribute__((__aligned__((1 << 7))));
 struct list_head s_inodes;

 spinlock_t s_inode_wblist_lock;
 struct list_head s_inodes_wb;
} ;






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) uid_t i_uid_read(const struct inode *inode)
{
 return from_kuid(inode->i_sb->s_user_ns, inode->i_uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gid_t i_gid_read(const struct inode *inode)
{
 return from_kgid(inode->i_sb->s_user_ns, inode->i_gid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_uid_write(struct inode *inode, uid_t uid)
{
 inode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_gid_write(struct inode *inode, gid_t gid)
{
 inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
}

extern struct timespec64 current_time(struct inode *inode);





void __sb_end_write(struct super_block *sb, int level);
int __sb_start_write(struct super_block *sb, int level, bool wait);
# 1599 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_write(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_WRITE);
}
# 1611 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_pagefault(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_PAGEFAULT);
}
# 1623 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_end_intwrite(struct super_block *sb)
{
 __sb_end_write(sb, SB_FREEZE_FS);
}
# 1647 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_write(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_WRITE, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_start_write_trylock(struct super_block *sb)
{
 return __sb_start_write(sb, SB_FREEZE_WRITE, false);
}
# 1676 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_pagefault(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_PAGEFAULT, true);
}
# 1694 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sb_start_intwrite(struct super_block *sb)
{
 __sb_start_write(sb, SB_FREEZE_FS, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_start_intwrite_trylock(struct super_block *sb)
{
 return __sb_start_write(sb, SB_FREEZE_FS, false);
}


extern bool inode_owner_or_capable(const struct inode *inode);




extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
extern int vfs_symlink(struct inode *, struct dentry *, const char *);
extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
extern int vfs_rmdir(struct inode *, struct dentry *);
extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
extern int vfs_whiteout(struct inode *, struct dentry *);

extern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,
      int open_flag);

int vfs_mkobj(struct dentry *, umode_t,
  int (*f)(struct dentry *, umode_t, void *),
  void *);

extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);


extern long compat_ptr_ioctl(struct file *file, unsigned int cmd,
     unsigned long arg);







extern void inode_init_owner(struct inode *inode, const struct inode *dir,
   umode_t mode);
extern bool may_open_dev(const struct path *path);



struct fiemap_extent_info {
 unsigned int fi_flags;
 unsigned int fi_extents_mapped;
 unsigned int fi_extents_max;
 struct fiemap_extent *fi_extents_start;

};
int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
       u64 phys, u64 len, u32 flags);
int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);







struct dir_context;
typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
    unsigned);

struct dir_context {
 filldir_t actor;
 loff_t pos;
};

struct block_device_operations;
# 1818 "/home/nathan/src/linux-next/include/linux/fs.h"
struct iov_iter;

struct file_operations {
 struct module *owner;
 loff_t (*llseek) (struct file *, loff_t, int);
 ssize_t (*read) (struct file *, char *, size_t, loff_t *);
 ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
 ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 int (*iopoll)(struct kiocb *kiocb, bool spin);
 int (*iterate) (struct file *, struct dir_context *);
 int (*iterate_shared) (struct file *, struct dir_context *);
 __poll_t (*poll) (struct file *, struct poll_table_struct *);
 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 int (*mmap) (struct file *, struct vm_area_struct *);
 unsigned long mmap_supported_flags;
 int (*open) (struct inode *, struct file *);
 int (*flush) (struct file *, fl_owner_t id);
 int (*release) (struct inode *, struct file *);
 int (*fsync) (struct file *, loff_t, loff_t, int datasync);
 int (*fasync) (int, struct file *, int);
 int (*lock) (struct file *, int, struct file_lock *);
 ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
 unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
 int (*check_flags)(int);
 int (*flock) (struct file *, int, struct file_lock *);
 ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 int (*setlease)(struct file *, long, struct file_lock **, void **);
 long (*fallocate)(struct file *file, int mode, loff_t offset,
     loff_t len);
 void (*show_fdinfo)(struct seq_file *m, struct file *f);



 ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
   loff_t, size_t, unsigned int);
 loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
       struct file *file_out, loff_t pos_out,
       loff_t len, unsigned int remap_flags);
 int (*fadvise)(struct file *, loff_t, loff_t, int);
} ;

struct inode_operations {
 struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
 const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);
 int (*permission) (struct inode *, int);
 struct posix_acl * (*get_acl)(struct inode *, int);

 int (*readlink) (struct dentry *, char *,int);

 int (*create) (struct inode *,struct dentry *, umode_t, bool);
 int (*link) (struct dentry *,struct inode *,struct dentry *);
 int (*unlink) (struct inode *,struct dentry *);
 int (*symlink) (struct inode *,struct dentry *,const char *);
 int (*mkdir) (struct inode *,struct dentry *,umode_t);
 int (*rmdir) (struct inode *,struct dentry *);
 int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 int (*rename) (struct inode *, struct dentry *,
   struct inode *, struct dentry *, unsigned int);
 int (*setattr) (struct dentry *, struct iattr *);
 int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);
 ssize_t (*listxattr) (struct dentry *, char *, size_t);
 int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
        u64 len);
 int (*update_time)(struct inode *, struct timespec64 *, int);
 int (*atomic_open)(struct inode *, struct dentry *,
      struct file *, unsigned open_flag,
      umode_t create_mode);
 int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 int (*set_acl)(struct inode *, struct posix_acl *, int);
} __attribute__((__aligned__((1 << 7))));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t call_read_iter(struct file *file, struct kiocb *kio,
         struct iov_iter *iter)
{
 return file->f_op->read_iter(kio, iter);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t call_write_iter(struct file *file, struct kiocb *kio,
          struct iov_iter *iter)
{
 return file->f_op->write_iter(kio, iter);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int call_mmap(struct file *file, struct vm_area_struct *vma)
{
 return file->f_op->mmap(file, vma);
}

ssize_t rw_copy_check_uvector(int type, const struct iovec * uvector,
         unsigned long nr_segs, unsigned long fast_segs,
         struct iovec *fast_pointer,
         struct iovec **ret_pointer);

extern ssize_t __vfs_read(struct file *, char *, size_t, loff_t *);
extern ssize_t vfs_read(struct file *, char *, size_t, loff_t *);
extern ssize_t vfs_write(struct file *, const char *, size_t, loff_t *);
extern ssize_t vfs_readv(struct file *, const struct iovec *,
  unsigned long, loff_t *, rwf_t);
extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
       loff_t, size_t, unsigned int);
extern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,
           struct file *file_out, loff_t pos_out,
           size_t len, unsigned int flags);
extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
      struct file *file_out, loff_t pos_out,
      loff_t *count,
      unsigned int remap_flags);
extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
      struct file *file_out, loff_t pos_out,
      loff_t len, unsigned int remap_flags);
extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
       struct file *file_out, loff_t pos_out,
       loff_t len, unsigned int remap_flags);
extern int vfs_dedupe_file_range(struct file *file,
     struct file_dedupe_range *same);
extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
     struct file *dst_file, loff_t dst_pos,
     loff_t len, unsigned int remap_flags);


struct super_operations {
    struct inode *(*alloc_inode)(struct super_block *sb);
 void (*destroy_inode)(struct inode *);
 void (*free_inode)(struct inode *);

    void (*dirty_inode) (struct inode *, int flags);
 int (*write_inode) (struct inode *, struct writeback_control *wbc);
 int (*drop_inode) (struct inode *);
 void (*evict_inode) (struct inode *);
 void (*put_super) (struct super_block *);
 int (*sync_fs)(struct super_block *sb, int wait);
 int (*freeze_super) (struct super_block *);
 int (*freeze_fs) (struct super_block *);
 int (*thaw_super) (struct super_block *);
 int (*unfreeze_fs) (struct super_block *);
 int (*statfs) (struct dentry *, struct kstatfs *);
 int (*remount_fs) (struct super_block *, int *, char *);
 void (*umount_begin) (struct super_block *);

 int (*show_options)(struct seq_file *, struct dentry *);
 int (*show_devname)(struct seq_file *, struct dentry *);
 int (*show_path)(struct seq_file *, struct dentry *);
 int (*show_stats)(struct seq_file *, struct dentry *);





 int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 long (*nr_cached_objects)(struct super_block *,
      struct shrink_control *);
 long (*free_cached_objects)(struct super_block *,
        struct shrink_control *);
};
# 2016 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & 1; }
# 2046 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool HAS_UNMAPPED_ID(struct inode *inode)
{
 return !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum rw_hint file_write_hint(struct file *file)
{
 if (file->f_write_hint != WRITE_LIFE_NOT_SET)
  return file->f_write_hint;

 return file_inode(file)->i_write_hint;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int iocb_flags(struct file *file);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 ki_hint_validate(enum rw_hint hint)
{
 typeof(((struct kiocb *)0)->ki_hint) max_hint = -1;

 if (hint <= max_hint)
  return hint;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
{
 *kiocb = (struct kiocb) {
  .ki_filp = filp,
  .ki_flags = iocb_flags(filp),
  .ki_hint = ki_hint_validate(file_write_hint(filp)),
  .ki_ioprio = get_current_ioprio(),
 };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,
          struct file *filp)
{
 *kiocb = (struct kiocb) {
  .ki_filp = filp,
  .ki_flags = kiocb_src->ki_flags,
  .ki_hint = kiocb_src->ki_hint,
  .ki_ioprio = kiocb_src->ki_ioprio,
  .ki_pos = kiocb_src->ki_pos,
 };
}
# 2180 "/home/nathan/src/linux-next/include/linux/fs.h"
extern void __mark_inode_dirty(struct inode *, int);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_inode_dirty(struct inode *inode)
{
 __mark_inode_dirty(inode, (((1 << 0) | (1 << 1)) | (1 << 2)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_inode_dirty_sync(struct inode *inode)
{
 __mark_inode_dirty(inode, (1 << 0));
}

extern void inc_nlink(struct inode *inode);
extern void drop_nlink(struct inode *inode);
extern void clear_nlink(struct inode *inode);
extern void set_nlink(struct inode *inode, unsigned int nlink);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_inc_link_count(struct inode *inode)
{
 inc_nlink(inode);
 mark_inode_dirty(inode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dec_link_count(struct inode *inode)
{
 drop_nlink(inode);
 mark_inode_dirty(inode);
}

enum file_time_flags {
 S_ATIME = 1,
 S_MTIME = 2,
 S_CTIME = 4,
 S_VERSION = 8,
};

extern bool atime_needs_update(const struct path *, struct inode *);
extern void touch_atime(const struct path *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_accessed(struct file *file)
{
 if (!(file->f_flags & 01000000))
  touch_atime(&file->f_path);
}

extern int file_modified(struct file *file);

int sync_inode(struct inode *inode, struct writeback_control *wbc);
int sync_inode_metadata(struct inode *inode, int wait);

struct file_system_type {
 const char *name;
 int fs_flags;






 int (*init_fs_context)(struct fs_context *);
 const struct fs_parameter_spec *parameters;
 struct dentry *(*mount) (struct file_system_type *, int,
         const char *, void *);
 void (*kill_sb) (struct super_block *);
 struct module *owner;
 struct file_system_type * next;
 struct hlist_head fs_supers;

 struct lock_class_key s_lock_key;
 struct lock_class_key s_umount_key;
 struct lock_class_key s_vfs_rename_key;
 struct lock_class_key s_writers_key[(SB_FREEZE_COMPLETE - 1)];

 struct lock_class_key i_lock_key;
 struct lock_class_key i_mutex_key;
 struct lock_class_key i_mutex_dir_key;
};




extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 int flags, const char *dev_name, void *data,
 int (*fill_super)(struct super_block *, void *, int));
# 2270 "/home/nathan/src/linux-next/include/linux/fs.h"
extern struct dentry *mount_single(struct file_system_type *fs_type,
 int flags, void *data,
 int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_nodev(struct file_system_type *fs_type,
 int flags, void *data,
 int (*fill_super)(struct super_block *, void *, int));
extern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);
void generic_shutdown_super(struct super_block *sb);

void kill_block_super(struct super_block *sb);






void kill_anon_super(struct super_block *sb);
void kill_litter_super(struct super_block *sb);
void deactivate_super(struct super_block *sb);
void deactivate_locked_super(struct super_block *sb);
int set_anon_super(struct super_block *s, void *data);
int set_anon_super_fc(struct super_block *s, struct fs_context *fc);
int get_anon_bdev(dev_t *);
void free_anon_bdev(dev_t);
struct super_block *sget_fc(struct fs_context *fc,
       int (*test)(struct super_block *, struct fs_context *),
       int (*set)(struct super_block *, struct fs_context *));
struct super_block *sget(struct file_system_type *type,
   int (*test)(struct super_block *,void *),
   int (*set)(struct super_block *,void *),
   int flags, void *data);
# 2319 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);
extern struct vfsmount *kern_mount(struct file_system_type *);
extern void kern_unmount(struct vfsmount *mnt);
extern int may_umount_tree(struct vfsmount *);
extern int may_umount(struct vfsmount *);
extern long do_mount(const char *, const char *,
       const char *, unsigned long, void *);
extern struct vfsmount *collect_mounts(const struct path *);
extern void drop_collected_mounts(struct vfsmount *);
extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
     struct vfsmount *);
extern int vfs_statfs(const struct path *, struct kstatfs *);
extern int user_statfs(const char *, struct kstatfs *);
extern int fd_statfs(int, struct kstatfs *);
extern int freeze_super(struct super_block *super);
extern int thaw_super(struct super_block *super);
extern bool our_mnt(struct vfsmount *mnt);
extern __attribute__((__format__(printf, 2, 3)))
int super_setup_bdi_name(struct super_block *sb, char *fmt, ...);
extern int super_setup_bdi(struct super_block *sb);

extern int current_umask(void);

extern void ihold(struct inode * inode);
extern void iput(struct inode *);
extern int generic_update_time(struct inode *, struct timespec64 *, int);


extern struct kobject *fs_kobj;




extern int locks_mandatory_locked(struct file *);
extern int locks_mandatory_area(struct inode *, struct file *, loff_t, loff_t, unsigned char);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __mandatory_lock(struct inode *ino)
{
 return (ino->i_mode & (0002000 | 00010)) == 0002000;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mandatory_lock(struct inode *ino)
{
 return ((ino)->i_sb->s_flags & (64)) && __mandatory_lock(ino);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_verify_locked(struct file *file)
{
 if (mandatory_lock(file_inode(file)))
  return locks_mandatory_locked(file);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int locks_verify_truncate(struct inode *inode,
        struct file *f,
        loff_t size)
{
 if (!inode->i_flctx || !mandatory_lock(inode))
  return 0;

 if (size < inode->i_size) {
  return locks_mandatory_area(inode, f, size, inode->i_size - 1,
    1);
 } else {
  return locks_mandatory_area(inode, f, inode->i_size, size - 1,
    1);
 }
}
# 2437 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_lease(struct inode *inode, unsigned int mode)
{






 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode, mode, 32);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_deleg(struct inode *inode, unsigned int mode)
{






 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode, mode, 4);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
 int ret;

 ret = break_deleg(inode, 00000001|00004000);
 if (ret == -11 && delegated_inode) {
  *delegated_inode = inode;
  ihold(inode);
 }
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_deleg_wait(struct inode **delegated_inode)
{
 int ret;

 ret = break_deleg(*delegated_inode, 00000001);
 iput(*delegated_inode);
 *delegated_inode = ((void *)0);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int break_layout(struct inode *inode, bool wait)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
  return __break_lease(inode,
    wait ? 00000001 : 00000001 | 00004000,
    2048);
 return 0;
}
# 2527 "/home/nathan/src/linux-next/include/linux/fs.h"
struct audit_names;
struct filename {
 const char *name;
 const char *uptr;
 int refcnt;
 struct audit_names *aname;
 const char iname[];
};
_Static_assert(__builtin_offsetof(struct filename, iname) % sizeof(long) == 0, "offsetof(struct filename, iname) % sizeof(long) == 0");

extern long vfs_truncate(const struct path *, loff_t);
extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
         struct file *filp);
extern int vfs_fallocate(struct file *file, int mode, loff_t offset,
   loff_t len);
extern long do_sys_open(int dfd, const char *filename, int flags,
   umode_t mode);
extern struct file *file_open_name(struct filename *, int, umode_t);
extern struct file *filp_open(const char *, int, umode_t);
extern struct file *file_open_root(struct dentry *, struct vfsmount *,
       const char *, int, umode_t);
extern struct file * dentry_open(const struct path *, int, const struct cred *);
extern struct file * open_with_fake_path(const struct path *, int,
      struct inode*, const struct cred *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct file *file_clone_open(struct file *file)
{
 return dentry_open(&file->f_path, file->f_flags, file->f_cred);
}
extern int filp_close(struct file *, fl_owner_t id);

extern struct filename *getname_flags(const char *, int, int *);
extern struct filename *getname(const char *);
extern struct filename *getname_kernel(const char *);
extern void putname(struct filename *name);

extern int finish_open(struct file *file, struct dentry *dentry,
   int (*open)(struct inode *, struct file *));
extern int finish_no_open(struct file *file, struct dentry *dentry);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) vfs_caches_init_early(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) vfs_caches_init(void);

extern struct kmem_cache *names_cachep;





extern int register_blkdev(unsigned int, const char *);
extern void unregister_blkdev(unsigned int, const char *);
extern void bdev_unhash_inode(dev_t dev);
extern struct block_device *bdget(dev_t);
extern struct block_device *bdgrab(struct block_device *bdev);
extern void bd_set_size(struct block_device *, loff_t size);
extern void bd_forget(struct inode *inode);
extern void bdput(struct block_device *);
extern void invalidate_bdev(struct block_device *);
extern void iterate_bdevs(void (*)(struct block_device *, void *), void *);
extern int sync_blockdev(struct block_device *bdev);
extern void kill_bdev(struct block_device *);
extern struct super_block *freeze_bdev(struct block_device *);
extern void emergency_thaw_all(void);
extern void emergency_thaw_bdev(struct super_block *sb);
extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
extern int fsync_bdev(struct block_device *);

extern struct super_block *blockdev_superblock;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sb_is_blkdev_sb(struct super_block *sb)
{
 return sb == blockdev_superblock;
}
# 2630 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int sync_filesystem(struct super_block *);
extern const struct file_operations def_blk_fops;
extern const struct file_operations def_chr_fops;

extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);
extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
            void *holder);
extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
           void *holder);
extern struct block_device *bd_start_claiming(struct block_device *bdev,
           void *holder);
extern void bd_finish_claiming(struct block_device *bdev,
          struct block_device *whole, void *holder);
extern void bd_abort_claiming(struct block_device *bdev,
         struct block_device *whole, void *holder);
extern void blkdev_put(struct block_device *bdev, fmode_t mode);


extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
extern void bd_unlink_disk_holder(struct block_device *bdev,
      struct gendisk *disk);
# 2675 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
extern int register_chrdev_region(dev_t, unsigned, const char *);
extern int __register_chrdev(unsigned int major, unsigned int baseminor,
        unsigned int count, const char *name,
        const struct file_operations *fops);
extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
    unsigned int count, const char *name);
extern void unregister_chrdev_region(dev_t, unsigned);
extern void chrdev_show(struct seq_file *,off_t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_chrdev(unsigned int major, const char *name,
      const struct file_operations *fops)
{
 return __register_chrdev(major, 0, 256, name, fops);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unregister_chrdev(unsigned int major, const char *name)
{
 __unregister_chrdev(major, 0, 256, name);
}







extern const char *__bdevname(dev_t, char *buffer);
extern const char *bdevname(struct block_device *bdev, char *buffer);
extern struct block_device *lookup_bdev(const char *);
extern void blkdev_show(struct seq_file *,off_t);





extern void init_special_inode(struct inode *, umode_t, dev_t);


extern void make_bad_inode(struct inode *);
extern bool is_bad_inode(struct inode *);


extern int revalidate_disk(struct gendisk *);
extern int check_disk_change(struct block_device *);
extern int __invalidate_device(struct block_device *, bool);
extern int invalidate_partition(struct gendisk *, int);

unsigned long invalidate_mapping_pages(struct address_space *mapping,
     unsigned long start, unsigned long end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void invalidate_remote_inode(struct inode *inode)
{
 if ((((inode->i_mode) & 00170000) == 0100000) || (((inode->i_mode) & 00170000) == 0040000) ||
     (((inode->i_mode) & 00170000) == 0120000))
  invalidate_mapping_pages(inode->i_mapping, 0, -1);
}
extern int invalidate_inode_pages2(struct address_space *mapping);
extern int invalidate_inode_pages2_range(struct address_space *mapping,
      unsigned long start, unsigned long end);
extern int write_inode_now(struct inode *, int);
extern int filemap_fdatawrite(struct address_space *);
extern int filemap_flush(struct address_space *);
extern int filemap_fdatawait_keep_errors(struct address_space *mapping);
extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
       loff_t lend);
extern int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
  loff_t start_byte, loff_t end_byte);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_fdatawait(struct address_space *mapping)
{
 return filemap_fdatawait_range(mapping, 0, ((long long)(~0ULL >> 1)));
}

extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
      loff_t lend);
extern int filemap_write_and_wait_range(struct address_space *mapping,
            loff_t lstart, loff_t lend);
extern int __filemap_fdatawrite_range(struct address_space *mapping,
    loff_t start, loff_t end, int sync_mode);
extern int filemap_fdatawrite_range(struct address_space *mapping,
    loff_t start, loff_t end);
extern int filemap_check_errors(struct address_space *mapping);
extern void __filemap_set_wb_err(struct address_space *mapping, int err);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_write_and_wait(struct address_space *mapping)
{
 return filemap_write_and_wait_range(mapping, 0, ((long long)(~0ULL >> 1)));
}

extern int __attribute__((__warn_unused_result__)) file_fdatawait_range(struct file *file, loff_t lstart,
      loff_t lend);
extern int __attribute__((__warn_unused_result__)) file_check_and_advance_wb_err(struct file *file);
extern int __attribute__((__warn_unused_result__)) file_write_and_wait_range(struct file *file,
      loff_t start, loff_t end);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int file_write_and_wait(struct file *file)
{
 return file_write_and_wait_range(file, 0, ((long long)(~0ULL >> 1)));
}
# 2790 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_set_wb_err(struct address_space *mapping, int err)
{

 if (__builtin_expect(!!(err), 0))
  __filemap_set_wb_err(mapping, err);
}
# 2807 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_check_wb_err(struct address_space *mapping,
     errseq_t since)
{
 return errseq_check(&mapping->wb_err, since);
}
# 2820 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) errseq_t filemap_sample_wb_err(struct address_space *mapping)
{
 return errseq_sample(&mapping->wb_err);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int filemap_nr_thps(struct address_space *mapping)
{



 return 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_nr_thps_inc(struct address_space *mapping)
{



 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2839), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void filemap_nr_thps_dec(struct address_space *mapping)
{



 ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2848), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });

}

extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
      int datasync);
extern int vfs_fsync(struct file *file, int datasync);

extern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,
    unsigned int flags);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)
{
 if (iocb->ki_flags & (1 << 4)) {
  int ret = vfs_fsync_range(iocb->ki_filp,
    iocb->ki_pos - count, iocb->ki_pos - 1,
    (iocb->ki_flags & (1 << 5)) ? 0 : 1);
  if (ret)
   return ret;
 }

 return count;
}

extern void emergency_sync(void);
extern void emergency_remount(void);


extern int bmap(struct inode *inode, sector_t *block);







extern int notify_change(struct dentry *, struct iattr *, struct inode **);
extern int inode_permission(struct inode *, int);
extern int generic_permission(struct inode *, int);
extern int __check_sticky(struct inode *dir, struct inode *inode);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool execute_ok(struct inode *inode)
{
 return (inode->i_mode & (00100|00010|00001)) || (((inode->i_mode) & 00170000) == 0040000);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_start_write(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return;
 __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool file_start_write_trylock(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return true;
 return __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void file_end_write(struct file *file)
{
 if (!(((file_inode(file)->i_mode) & 00170000) == 0100000))
  return;
 __sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);
}
# 2936 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_write_access(struct inode *inode)
{
 return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -26;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int deny_write_access(struct file *file)
{
 struct inode *inode = file_inode(file);
 return atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -26;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_write_access(struct inode * inode)
{
 atomic_dec(&inode->i_writecount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_write_access(struct file *file)
{
 if (file)
  atomic_inc(&file_inode(file)->i_writecount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inode_is_open_for_write(const struct inode *inode)
{
 return atomic_read(&inode->i_writecount) > 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_readcount_dec(struct inode *inode)
{
 do { if (__builtin_constant_p(!atomic_read(&inode->i_readcount))) { if (!atomic_read(&inode->i_readcount)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2962), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/fs.h"), "i" (2962), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!atomic_read(&inode->i_readcount)))); } } while (0);
 atomic_dec(&inode->i_readcount);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void i_readcount_inc(struct inode *inode)
{
 atomic_inc(&inode->i_readcount);
}
# 2979 "/home/nathan/src/linux-next/include/linux/fs.h"
extern int do_pipe_flags(int *, int);
# 2995 "/home/nathan/src/linux-next/include/linux/fs.h"
enum kernel_read_file_id {
 READING_UNKNOWN, READING_FIRMWARE, READING_FIRMWARE_PREALLOC_BUFFER, READING_MODULE, READING_KEXEC_IMAGE, READING_KEXEC_INITRAMFS, READING_POLICY, READING_X509_CERTIFICATE, READING_MAX_ID,
};

static const char * const kernel_read_file_str[] = {
 "unknown", "firmware", "firmware", "kernel-module", "kexec-image", "kexec-initramfs", "security-policy", "x509-certificate", "",
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kernel_read_file_id_str(enum kernel_read_file_id id)
{
 if ((unsigned)id >= READING_MAX_ID)
  return kernel_read_file_str[READING_UNKNOWN];

 return kernel_read_file_str[id];
}

extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
       enum kernel_read_file_id);
extern int kernel_read_file_from_path(const char *, void **, loff_t *, loff_t,
          enum kernel_read_file_id);
extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
        enum kernel_read_file_id);
extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
extern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);
extern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);
extern struct file * open_exec(const char *);


extern bool is_subdir(struct dentry *, struct dentry *);
extern bool path_is_under(const struct path *, const struct path *);

extern char *file_path(struct file *, char *, int);




extern loff_t default_llseek(struct file *file, loff_t offset, int whence);

extern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);

extern int inode_init_always(struct super_block *, struct inode *);
extern void inode_init_once(struct inode *);
extern void address_space_init_once(struct address_space *mapping);
extern struct inode * igrab(struct inode *);
extern ino_t iunique(struct super_block *, ino_t);
extern int inode_needs_sync(struct inode *inode);
extern int generic_delete_inode(struct inode *inode);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int generic_drop_inode(struct inode *inode)
{
 return !inode->i_nlink || inode_unhashed(inode);
}

extern struct inode *ilookup5_nowait(struct super_block *sb,
  unsigned long hashval, int (*test)(struct inode *, void *),
  void *data);
extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
  int (*test)(struct inode *, void *), void *data);
extern struct inode *ilookup(struct super_block *sb, unsigned long ino);

extern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,
  int (*test)(struct inode *, void *),
  int (*set)(struct inode *, void *),
  void *data);
extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
extern struct inode * iget_locked(struct super_block *, unsigned long);
extern struct inode *find_inode_nowait(struct super_block *,
           unsigned long,
           int (*match)(struct inode *,
          unsigned long, void *),
           void *data);
extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
extern int insert_inode_locked(struct inode *);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lockdep_annotate_inode_mutex_key(struct inode *inode) { };

extern void unlock_new_inode(struct inode *);
extern void discard_new_inode(struct inode *);
extern unsigned int get_next_ino(void);
extern void evict_inodes(struct super_block *sb);

extern void __iget(struct inode * inode);
extern void iget_failed(struct inode *);
extern void clear_inode(struct inode *);
extern void __destroy_inode(struct inode *);
extern struct inode *new_inode_pseudo(struct super_block *sb);
extern struct inode *new_inode(struct super_block *sb);
extern void free_inode_nonrcu(struct inode *inode);
extern int should_remove_suid(struct dentry *);
extern int file_remove_privs(struct file *);

extern void __insert_inode_hash(struct inode *, unsigned long hashval);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void insert_inode_hash(struct inode *inode)
{
 __insert_inode_hash(inode, inode->i_ino);
}

extern void __remove_inode_hash(struct inode *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void remove_inode_hash(struct inode *inode)
{
 if (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))
  __remove_inode_hash(inode);
}

extern void inode_sb_list_add(struct inode *inode);


extern int bdev_read_only(struct block_device *);

extern int set_blocksize(struct block_device *, int);
extern int sb_set_blocksize(struct super_block *, int);
extern int sb_min_blocksize(struct super_block *, int);

extern int generic_file_mmap(struct file *, struct vm_area_struct *);
extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
    struct file *file_out, loff_t pos_out,
    loff_t *count, unsigned int remap_flags);
extern int generic_file_rw_checks(struct file *file_in, struct file *file_out);
extern int generic_copy_file_checks(struct file *file_in, loff_t pos_in,
        struct file *file_out, loff_t pos_out,
        size_t *count, unsigned int flags);
extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);
extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);

ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
  rwf_t flags);
ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,
  rwf_t flags);
ssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,
      struct iov_iter *iter);
ssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,
       struct iov_iter *iter);


extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);
extern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);
extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
   int datasync);
extern void block_sync_page(struct page *page);


extern ssize_t generic_file_splice_read(struct file *, loff_t *,
  struct pipe_inode_info *, size_t, unsigned int);
extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
  struct file *, loff_t *, size_t, unsigned int);
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
  struct file *out, loff_t *, size_t len, unsigned int flags);
extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
  loff_t *opos, size_t len, unsigned int flags);


extern void
file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
extern loff_t noop_llseek(struct file *file, loff_t offset, int whence);
extern loff_t no_llseek(struct file *file, loff_t offset, int whence);
extern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);
extern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
  int whence, loff_t maxsize, loff_t eof);
extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
  int whence, loff_t size);
extern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);
extern loff_t no_seek_end_llseek(struct file *, loff_t, int);
extern int generic_file_open(struct inode * inode, struct file * filp);
extern int nonseekable_open(struct inode * inode, struct file * filp);
extern int stream_open(struct inode * inode, struct file * filp);


typedef void (dio_submit_t)(struct bio *bio, struct inode *inode,
       loff_t file_offset);

enum {

 DIO_LOCKING = 0x01,


 DIO_SKIP_HOLES = 0x02,
};

void dio_end_io(struct bio *bio);

ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
        struct block_device *bdev, struct iov_iter *iter,
        get_block_t get_block,
        dio_iodone_t end_io, dio_submit_t submit_io,
        int flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ssize_t blockdev_direct_IO(struct kiocb *iocb,
      struct inode *inode,
      struct iov_iter *iter,
      get_block_t get_block)
{
 return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
   get_block, ((void *)0), ((void *)0), DIO_LOCKING | DIO_SKIP_HOLES);
}


void inode_dio_wait(struct inode *inode);
# 3207 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dio_begin(struct inode *inode)
{
 atomic_inc(&inode->i_dio_count);
}
# 3219 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_dio_end(struct inode *inode)
{
 if (atomic_dec_and_test(&inode->i_dio_count))
  wake_up_bit(&inode->i_state, 9);
}




void dio_warn_stale_pagecache(struct file *filp);

extern void inode_set_flags(struct inode *inode, unsigned int flags,
       unsigned int mask);

extern const struct file_operations generic_ro_fops;



extern int readlink_copy(char *, int, const char *);
extern int page_readlink(struct dentry *, char *, int);
extern const char *page_get_link(struct dentry *, struct inode *,
     struct delayed_call *);
extern void page_put_link(void *);
extern int __page_symlink(struct inode *inode, const char *symname, int len,
  int nofs);
extern int page_symlink(struct inode *inode, const char *symname, int len);
extern const struct inode_operations page_symlink_inode_operations;
extern void kfree_link(void *);
extern void generic_fillattr(struct inode *, struct kstat *);
extern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);
extern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);
void __inode_add_bytes(struct inode *inode, loff_t bytes);
void inode_add_bytes(struct inode *inode, loff_t bytes);
void __inode_sub_bytes(struct inode *inode, loff_t bytes);
void inode_sub_bytes(struct inode *inode, loff_t bytes);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t __inode_get_bytes(struct inode *inode)
{
 return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
}
loff_t inode_get_bytes(struct inode *inode);
void inode_set_bytes(struct inode *inode, loff_t bytes);
const char *simple_get_link(struct dentry *, struct inode *,
       struct delayed_call *);
extern const struct inode_operations simple_symlink_inode_operations;

extern int iterate_dir(struct file *, struct dir_context *);

extern int vfs_statx(int, const char *, int, struct kstat *, u32);
extern int vfs_statx_fd(unsigned int, struct kstat *, u32, unsigned int);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_stat(const char *filename, struct kstat *stat)
{
 return vfs_statx(-100, filename, 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_lstat(const char *name, struct kstat *stat)
{
 return vfs_statx(-100, name, 0x100 | 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_fstatat(int dfd, const char *filename,
         struct kstat *stat, int flags)
{
 return vfs_statx(dfd, filename, flags | 0x800,
    stat, 0x000007ffU);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vfs_fstat(int fd, struct kstat *stat)
{
 return vfs_statx_fd(fd, stat, 0x000007ffU, 0);
}


extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
extern int vfs_readlink(struct dentry *, char *, int);

extern int __generic_block_fiemap(struct inode *inode,
      struct fiemap_extent_info *fieinfo,
      loff_t start, loff_t len,
      get_block_t *get_block);
extern int generic_block_fiemap(struct inode *inode,
    struct fiemap_extent_info *fieinfo, u64 start,
    u64 len, get_block_t *get_block);

extern struct file_system_type *get_filesystem(struct file_system_type *fs);
extern void put_filesystem(struct file_system_type *fs);
extern struct file_system_type *get_fs_type(const char *name);
extern struct super_block *get_super(struct block_device *);
extern struct super_block *get_super_thawed(struct block_device *);
extern struct super_block *get_super_exclusive_thawed(struct block_device *bdev);
extern struct super_block *get_active_super(struct block_device *bdev);
extern void drop_super(struct super_block *sb);
extern void drop_super_exclusive(struct super_block *sb);
extern void iterate_supers(void (*)(struct super_block *, void *), void *);
extern void iterate_supers_type(struct file_system_type *,
           void (*)(struct super_block *, void *), void *);

extern int dcache_dir_open(struct inode *, struct file *);
extern int dcache_dir_close(struct inode *, struct file *);
extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
extern int dcache_readdir(struct file *, struct dir_context *);
extern int simple_setattr(struct dentry *, struct iattr *);
extern int simple_getattr(const struct path *, struct kstat *, u32, unsigned int);
extern int simple_statfs(struct dentry *, struct kstatfs *);
extern int simple_open(struct inode *inode, struct file *file);
extern int simple_link(struct dentry *, struct inode *, struct dentry *);
extern int simple_unlink(struct inode *, struct dentry *);
extern int simple_rmdir(struct inode *, struct dentry *);
extern int simple_rename(struct inode *, struct dentry *,
    struct inode *, struct dentry *, unsigned int);
extern void simple_recursive_removal(struct dentry *,
                              void (*callback)(struct dentry *));
extern int noop_fsync(struct file *, loff_t, loff_t, int);
extern int noop_set_page_dirty(struct page *page);
extern void noop_invalidatepage(struct page *page, unsigned int offset,
  unsigned int length);
extern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);
extern int simple_empty(struct dentry *);
extern int simple_readpage(struct file *file, struct page *page);
extern int simple_write_begin(struct file *file, struct address_space *mapping,
   loff_t pos, unsigned len, unsigned flags,
   struct page **pagep, void **fsdata);
extern int simple_write_end(struct file *file, struct address_space *mapping,
   loff_t pos, unsigned len, unsigned copied,
   struct page *page, void *fsdata);
extern int always_delete_dentry(const struct dentry *);
extern struct inode *alloc_anon_inode(struct super_block *);
extern int simple_nosetlease(struct file *, long, struct file_lock **, void **);
extern const struct dentry_operations simple_dentry_operations;

extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);
extern ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
extern const struct file_operations simple_dir_operations;
extern const struct inode_operations simple_dir_inode_operations;
extern void make_empty_dir_inode(struct inode *inode);
extern bool is_empty_dir_inode(struct inode *inode);
struct tree_descr { const char *name; const struct file_operations *ops; int mode; };
struct dentry *d_alloc_name(struct dentry *, const char *);
extern int simple_fill_super(struct super_block *, unsigned long,
        const struct tree_descr *);
extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
extern void simple_release_fs(struct vfsmount **mount, int *count);

extern ssize_t simple_read_from_buffer(void *to, size_t count,
   loff_t *ppos, const void *from, size_t available);
extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
  const void *from, size_t count);

extern int __generic_file_fsync(struct file *, loff_t, loff_t, int);
extern int generic_file_fsync(struct file *, loff_t, loff_t, int);

extern int generic_check_addressable(unsigned, u64);


extern int buffer_migrate_page(struct address_space *,
    struct page *, struct page *,
    enum migrate_mode);
extern int buffer_migrate_page_norefs(struct address_space *,
    struct page *, struct page *,
    enum migrate_mode);





extern int setattr_prepare(struct dentry *, struct iattr *);
extern int inode_newsize_ok(const struct inode *, loff_t offset);
extern void setattr_copy(struct inode *inode, const struct iattr *attr);

extern int file_update_time(struct file *file);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool io_is_direct(struct file *filp)
{
 return (filp->f_flags & 0400000) || ((filp->f_mapping->host)->i_flags & 8192);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vma_is_dax(struct vm_area_struct *vma)
{
 return vma->vm_file && ((vma->vm_file->f_mapping->host)->i_flags & 8192);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vma_is_fsdax(struct vm_area_struct *vma)
{
 struct inode *inode;

 if (!vma->vm_file)
  return false;
 if (!vma_is_dax(vma))
  return false;
 inode = file_inode(vma->vm_file);
 if ((((inode->i_mode) & 00170000) == 0020000))
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int iocb_flags(struct file *file)
{
 int res = 0;
 if (file->f_flags & 00002000)
  res |= (1 << 1);
 if (io_is_direct(file))
  res |= (1 << 2);
 if ((file->f_flags & 00010000) || (((file->f_mapping->host)->i_sb->s_flags & (16)) || ((file->f_mapping->host)->i_flags & 1)))
  res |= (1 << 4);
 if (file->f_flags & 04000000)
  res |= (1 << 5);
 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)
{
 if (__builtin_expect(!!(flags & ~((( __kernel_rwf_t)0x00000001) | (( __kernel_rwf_t)0x00000002) | (( __kernel_rwf_t)0x00000004) | (( __kernel_rwf_t)0x00000008) | (( __kernel_rwf_t)0x00000010))), 0))
  return -95;

 if (flags & (( __kernel_rwf_t)0x00000008)) {
  if (!(ki->ki_filp->f_mode & (( fmode_t)0x8000000)))
   return -95;
  ki->ki_flags |= (1 << 7);
 }
 if (flags & (( __kernel_rwf_t)0x00000001))
  ki->ki_flags |= (1 << 3);
 if (flags & (( __kernel_rwf_t)0x00000002))
  ki->ki_flags |= (1 << 4);
 if (flags & (( __kernel_rwf_t)0x00000004))
  ki->ki_flags |= ((1 << 4) | (1 << 5));
 if (flags & (( __kernel_rwf_t)0x00000010))
  ki->ki_flags |= (1 << 1);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t parent_ino(struct dentry *dentry)
{
 ino_t res;





 spin_lock(&dentry->d_lockref.lock);
 res = dentry->d_parent->d_inode->i_ino;
 spin_unlock(&dentry->d_lockref.lock);
 return res;
}







struct simple_transaction_argresp {
 ssize_t size;
 char data[0];
};



char *simple_transaction_get(struct file *file, const char *buf,
    size_t size);
ssize_t simple_transaction_read(struct file *file, char *buf,
    size_t size, loff_t *pos);
int simple_transaction_release(struct inode *inode, struct file *file);

void simple_transaction_set(struct file *file, size_t n);
# 3514 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__format__(printf, 1, 2)))
void __simple_attr_check_format(const char *fmt, ...)
{

}

int simple_attr_open(struct inode *inode, struct file *file,
       int (*get)(void *, u64 *), int (*set)(void *, u64),
       const char *fmt);
int simple_attr_release(struct inode *inode, struct file *file);
ssize_t simple_attr_read(struct file *file, char *buf,
    size_t len, loff_t *ppos);
ssize_t simple_attr_write(struct file *file, const char *buf,
     size_t len, loff_t *ppos);

struct ctl_table;
int proc_nr_files(struct ctl_table *table, int write,
    void *buffer, size_t *lenp, loff_t *ppos);
int proc_nr_dentry(struct ctl_table *table, int write,
    void *buffer, size_t *lenp, loff_t *ppos);
int proc_nr_inodes(struct ctl_table *table, int write,
     void *buffer, size_t *lenp, loff_t *ppos);
int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) get_filesystem_list(char *buf);
# 3545 "/home/nathan/src/linux-next/include/linux/fs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_sxid(umode_t mode)
{
 return (mode & 0004000) || ((mode & 0002000) && (mode & 00010));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int check_sticky(struct inode *dir, struct inode *inode)
{
 if (!(dir->i_mode & 0001000))
  return 0;

 return __check_sticky(dir, inode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_has_no_xattr(struct inode *inode)
{
 if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & (1<<28)))
  inode->i_flags |= 4096;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_root_inode(struct inode *inode)
{
 return inode == inode->i_sb->s_root->d_inode;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit(struct dir_context *ctx,
       const char *name, int namelen,
       u64 ino, unsigned type)
{
 return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dot(struct file *file, struct dir_context *ctx)
{
 return ctx->actor(ctx, ".", 1, ctx->pos,
     file->f_path.dentry->d_inode->i_ino, 4) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)
{
 return ctx->actor(ctx, "..", 2, ctx->pos,
     parent_ino(file->f_path.dentry), 4) == 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_emit_dots(struct file *file, struct dir_context *ctx)
{
 if (ctx->pos == 0) {
  if (!dir_emit_dot(file, ctx))
   return false;
  ctx->pos = 1;
 }
 if (ctx->pos == 1) {
  if (!dir_emit_dotdot(file, ctx))
   return false;
  ctx->pos = 2;
 }
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_relax(struct inode *inode)
{
 inode_unlock(inode);
 inode_lock(inode);
 return !((inode)->i_flags & 16);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dir_relax_shared(struct inode *inode)
{
 inode_unlock_shared(inode);
 inode_lock_shared(inode);
 return !((inode)->i_flags & 16);
}

extern bool path_noexec(const struct path *path);
extern void inode_nohighmem(struct inode *inode);


extern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,
         int advice);
extern int generic_fadvise(struct file *file, loff_t offset, loff_t len,
      int advice);


extern struct sock *io_uring_get_socket(struct file *file);







int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
        unsigned int flags);

int vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,
        struct fsxattr *fa);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)
{
 memset(fa, 0, sizeof(*fa));
 fa->fsx_xflags = xflags;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inode_drain_writes(struct inode *inode)
{
 inode_dio_wait(inode);
 return filemap_write_and_wait(inode->i_mapping);
}
# 9 "/home/nathan/src/linux-next/include/linux/huge_mm.h" 2

extern vm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf);
extern int copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,
    pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,
    struct vm_area_struct *vma);
extern void huge_pmd_set_accessed(struct vm_fault *vmf, pmd_t orig_pmd);
extern int copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,
    pud_t *dst_pud, pud_t *src_pud, unsigned long addr,
    struct vm_area_struct *vma);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)
{
}


extern vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd);
extern struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
       unsigned long addr,
       pmd_t *pmd,
       unsigned int flags);
extern bool madvise_free_huge_pmd(struct mmu_gather *tlb,
   struct vm_area_struct *vma,
   pmd_t *pmd, unsigned long addr, unsigned long next);
extern int zap_huge_pmd(struct mmu_gather *tlb,
   struct vm_area_struct *vma,
   pmd_t *pmd, unsigned long addr);
extern int zap_huge_pud(struct mmu_gather *tlb,
   struct vm_area_struct *vma,
   pud_t *pud, unsigned long addr);
extern int mincore_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,
   unsigned long addr, unsigned long end,
   unsigned char *vec);
extern bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,
    unsigned long new_addr, unsigned long old_end,
    pmd_t *old_pmd, pmd_t *new_pmd);
extern int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,
   unsigned long addr, pgprot_t newprot,
   int prot_numa);
vm_fault_t vmf_insert_pfn_pmd(struct vm_fault *vmf, pfn_t pfn, bool write);
vm_fault_t vmf_insert_pfn_pud(struct vm_fault *vmf, pfn_t pfn, bool write);
enum transparent_hugepage_flag {
 TRANSPARENT_HUGEPAGE_FLAG,
 TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,
 TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG,
 TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG,
 TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG,
 TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG,
 TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG,
 TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG,



};

struct kobject;
struct kobj_attribute;

extern ssize_t single_hugepage_flag_store(struct kobject *kobj,
     struct kobj_attribute *attr,
     const char *buf, size_t count,
     enum transparent_hugepage_flag flag);
extern ssize_t single_hugepage_flag_show(struct kobject *kobj,
    struct kobj_attribute *attr, char *buf,
    enum transparent_hugepage_flag flag);
extern struct kobj_attribute shmem_enabled_attr;
# 90 "/home/nathan/src/linux-next/include/linux/huge_mm.h"
extern bool is_vma_temporary_stack(struct vm_area_struct *vma);

extern unsigned long transparent_hugepage_flags;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __transparent_hugepage_enabled(struct vm_area_struct *vma)
{
 if (vma->vm_flags & 0x40000000)
  return false;

 if (is_vma_temporary_stack(vma))
  return false;

 if (test_bit(24, &vma->vm_mm->flags))
  return false;

 if (transparent_hugepage_flags & (1 << TRANSPARENT_HUGEPAGE_FLAG))
  return true;






 if (vma_is_dax(vma))
  return true;

 if (transparent_hugepage_flags &
    (1 << TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG))
  return !!(vma->vm_flags & 0x20000000);

 return false;
}

bool transparent_hugepage_enabled(struct vm_area_struct *vma);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool transhuge_vma_suitable(struct vm_area_struct *vma,
  unsigned long haddr)
{

 if (!vma_is_anonymous(vma)) {
  if (((vma->vm_start >> 16) & ((1<<((16 + __pte_index_size)-16)) - 1)) !=
   (vma->vm_pgoff & ((1<<((16 + __pte_index_size)-16)) - 1)))
   return false;
 }

 if (haddr < vma->vm_start || haddr + ((1UL) << (16 + __pte_index_size)) > vma->vm_end)
  return false;
 return true;
}
# 157 "/home/nathan/src/linux-next/include/linux/huge_mm.h"
extern unsigned long thp_get_unmapped_area(struct file *filp,
  unsigned long addr, unsigned long len, unsigned long pgoff,
  unsigned long flags);

extern void prep_transhuge_page(struct page *page);
extern void free_transhuge_page(struct page *page);
bool is_transparent_hugepage(struct page *page);

bool can_split_huge_page(struct page *page, int *pextra_pins);
int split_huge_page_to_list(struct page *page, struct list_head *list);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int split_huge_page(struct page *page)
{
 return split_huge_page_to_list(page, ((void *)0));
}
void deferred_split_huge_page(struct page *page);

void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,
  unsigned long address, bool freeze, struct page *page);
# 186 "/home/nathan/src/linux-next/include/linux/huge_mm.h"
void split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,
  bool freeze, struct page *page);

void __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,
  unsigned long address);
# 200 "/home/nathan/src/linux-next/include/linux/huge_mm.h"
extern int hugepage_madvise(struct vm_area_struct *vma,
       unsigned long *vm_flags, int advice);
extern void vma_adjust_trans_huge(struct vm_area_struct *vma,
        unsigned long start,
        unsigned long end,
        long adjust_next);
extern spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd,
  struct vm_area_struct *vma);
extern spinlock_t *__pud_trans_huge_lock(pud_t *pud,
  struct vm_area_struct *vma);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_swap_pmd(pmd_t pmd)
{
 return !pmd_none(pmd) && !pmd_present(pmd);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pmd_trans_huge_lock(pmd_t *pmd,
  struct vm_area_struct *vma)
{
 if (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd))
  return __pmd_trans_huge_lock(pmd, vma);
 else
  return ((void *)0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pud_trans_huge_lock(pud_t *pud,
  struct vm_area_struct *vma)
{
 if (pud_trans_huge(*pud) || pud_devmap(*pud))
  return __pud_trans_huge_lock(pud, vma);
 else
  return ((void *)0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hpage_nr_pages(struct page *page)
{
 if (__builtin_expect(!!(PageTransHuge(page)), 0))
  return (1<<((16 + __pte_index_size)-16));
 return 1;
}

struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,
  pmd_t *pmd, int flags, struct dev_pagemap **pgmap);
struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,
  pud_t *pud, int flags, struct dev_pagemap **pgmap);

extern vm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t orig_pmd);

extern struct page *huge_zero_page;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_huge_zero_page(struct page *page)
{
 return ({ union { typeof(huge_zero_page) __val; char __c[1]; } __u; if (1) __read_once_size(&(huge_zero_page), __u.__c, sizeof(huge_zero_page)); else __read_once_size_nocheck(&(huge_zero_page), __u.__c, sizeof(huge_zero_page)); do { } while (0); __u.__val; }) == page;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_huge_zero_pmd(pmd_t pmd)
{
 return is_huge_zero_page(pmd_page(pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_huge_zero_pud(pud_t pud)
{
 return false;
}

struct page *mm_get_huge_zero_page(struct mm_struct *mm);
void mm_put_huge_zero_page(struct mm_struct *mm);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool thp_migration_supported(void)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct list_head *page_deferred_list(struct page *page)
{




 return &page[2].deferred_list;
}
# 568 "/home/nathan/src/linux-next/include/linux/mm.h" 2
# 585 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int put_page_testzero(struct page *page)
{
 ((void)(sizeof(( long)(page_ref_count(page) == 0))));
 return page_ref_dec_and_test(page);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_page_unless_zero(struct page *page)
{
 return page_ref_add_unless(page, 1, 0);
}

extern int page_is_ram(unsigned long pfn);

enum {
 REGION_INTERSECTS,
 REGION_DISJOINT,
 REGION_MIXED,
};

int region_intersects(resource_size_t offset, size_t size, unsigned long flags,
        unsigned long desc);


struct page *vmalloc_to_page(const void *addr);
unsigned long vmalloc_to_pfn(const void *addr);
# 629 "/home/nathan/src/linux-next/include/linux/mm.h"
extern bool is_vmalloc_addr(const void *x);
extern int is_vmalloc_or_module_addr(const void *x);
# 642 "/home/nathan/src/linux-next/include/linux/mm.h"
extern void *kvmalloc_node(size_t size, gfp_t flags, int node);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kvmalloc(size_t size, gfp_t flags)
{
 return kvmalloc_node(size, flags, (-1));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kvzalloc_node(size_t size, gfp_t flags, int node)
{
 return kvmalloc_node(size, flags | (( gfp_t)0x100u), node);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kvzalloc(size_t size, gfp_t flags)
{
 return kvmalloc(size, flags | (( gfp_t)0x100u));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kvmalloc_array(size_t n, size_t size, gfp_t flags)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);

 return kvmalloc(bytes, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kvcalloc(size_t n, size_t size, gfp_t flags)
{
 return kvmalloc_array(n, size, flags | (( gfp_t)0x100u));
}

extern void kvfree(const void *addr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int compound_mapcount(struct page *page)
{
 ((void)(sizeof(( long)(!PageCompound(page)))));
 page = compound_head(page);
 return atomic_read(compound_mapcount_ptr(page)) + 1;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_mapcount_reset(struct page *page)
{
 atomic_set(&(page)->_mapcount, -1);
}

int __page_mapcount(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_mapcount(struct page *page)
{
 ((void)(sizeof(( long)(PageSlab(page)))));

 if (__builtin_expect(!!(PageCompound(page)), 0))
  return __page_mapcount(page);
 return atomic_read(&page->_mapcount) + 1;
}


int total_mapcount(struct page *page);
int page_trans_huge_mapcount(struct page *page, int *total_mapcount);
# 719 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *virt_to_head_page(const void *x)
{
 struct page *page = (vmemmap + ((({ do { } while (0); (unsigned long)(x) & 0x0fffffffffffffffUL; }) >> 16)));

 return compound_head(page);
}

void __put_page(struct page *page);

void put_pages_list(struct list_head *pages);

void split_page(struct page *page, unsigned int order);






typedef void compound_page_dtor(struct page *);


enum compound_dtor_id {
 NULL_COMPOUND_DTOR,
 COMPOUND_PAGE_DTOR,

 HUGETLB_PAGE_DTOR,


 TRANSHUGE_PAGE_DTOR,

 NR_COMPOUND_DTORS,
};
extern compound_page_dtor * const compound_page_dtors[];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_compound_page_dtor(struct page *page,
  enum compound_dtor_id compound_dtor)
{
 ((void)(sizeof(( long)(compound_dtor >= NR_COMPOUND_DTORS))));
 page[1].compound_dtor = compound_dtor;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) compound_page_dtor *get_compound_page_dtor(struct page *page)
{
 ((void)(sizeof(( long)(page[1].compound_dtor >= NR_COMPOUND_DTORS))));
 return compound_page_dtors[page[1].compound_dtor];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int compound_order(struct page *page)
{
 if (!PageHead(page))
  return 0;
 return page[1].compound_order;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_compound_order(struct page *page, unsigned int order)
{
 page[1].compound_order = order;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long compound_nr(struct page *page)
{
 return 1UL << compound_order(page);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long page_size(struct page *page)
{
 return (1UL << 16) << compound_order(page);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int page_shift(struct page *page)
{
 return 16 + compound_order(page);
}

void free_compound_page(struct page *page);
# 805 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
{
 if (__builtin_expect(!!(vma->vm_flags & 0x00000002), 1))
  pte = pte_mkwrite(pte);
 return pte;
}

vm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,
  struct page *page);
vm_fault_t finish_fault(struct vm_fault *vmf);
vm_fault_t finish_mkwrite_fault(struct vm_fault *vmf);
# 921 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum zone_type page_zonenum(const struct page *page)
{
 return (page->flags >> (((((sizeof(unsigned long)*8) - 0) - 8) - 1) * (1 != 0))) & ((1UL << 1) - 1);
}
# 934 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_zone_device_page(const struct page *page)
{
 return false;
}
# 963 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool page_is_devmap_managed(struct page *page)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_devmap_managed_page(struct page *page)
{
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_device_private_page(const struct page *page)
{
 return 0 &&
  0 &&
  is_zone_device_page(page) &&
  page->pgmap->type == MEMORY_DEVICE_PRIVATE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_pci_p2pdma_page(const struct page *page)
{
 return 0 &&
  0 &&
  is_zone_device_page(page) &&
  page->pgmap->type == MEMORY_DEVICE_PCI_P2PDMA;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void get_page(struct page *page)
{
 page = compound_head(page);




 ((void)(sizeof(( long)(((unsigned int) page_ref_count(page) + 127u <= 127u)))));
 page_ref_inc(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool try_get_page(struct page *page)
{
 page = compound_head(page);
 if (({ int __ret_warn_on = !!(page_ref_count(page) <= 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/mm.h"), "i" (1007), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return false;
 page_ref_inc(page);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_page(struct page *page)
{
 page = compound_head(page);







 if (page_is_devmap_managed(page)) {
  put_devmap_managed_page(page);
  return;
 }

 if (put_page_testzero(page))
  __put_page(page);
}
# 1045 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unpin_user_page(struct page *page)
{
 put_page(page);
}

void unpin_user_pages_dirty_lock(struct page **pages, unsigned long npages,
     bool make_dirty);

void unpin_user_pages(struct page **pages, unsigned long npages);
# 1067 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_zone_id(struct page *page)
{
 return (page->flags >> ((((((sizeof(unsigned long)*8) - 0) - 8) < ((((sizeof(unsigned long)*8) - 0) - 8) - 1))? (((sizeof(unsigned long)*8) - 0) - 8) : ((((sizeof(unsigned long)*8) - 0) - 8) - 1)) * ((8 + 1) != 0))) & ((1UL << (8 + 1)) - 1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_to_nid(const struct page *page)
{
 struct page *p = (struct page *)page;

 return (({ ((void)(sizeof(( long)(PagePoisoned(p))))); p; })->flags >> ((((sizeof(unsigned long)*8) - 0) - 8) * (8 != 0))) & ((1UL << 8) - 1);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpu_pid_to_cpupid(int cpu, int pid)
{
 return ((cpu & ((1 << 11)-1)) << 8) | (pid & ((1 << 8)-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpupid_to_pid(int cpupid)
{
 return cpupid & ((1 << 8)-1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpupid_to_cpu(int cpupid)
{
 return (cpupid >> 8) & ((1 << 11)-1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cpupid_to_nid(int cpupid)
{
 return cpu_to_node(cpupid_to_cpu(cpupid));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpupid_pid_unset(int cpupid)
{
 return cpupid_to_pid(cpupid) == (-1 & ((1 << 8)-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cpupid_cpu_unset(int cpupid)
{
 return cpupid_to_cpu(cpupid) == (-1 & ((1 << 11)-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __cpupid_match_pid(pid_t task_pid, int cpupid)
{
 return (task_pid & ((1 << 8)-1)) == cpupid_to_pid(cpupid);
}
# 1135 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_cpupid_last(struct page *page)
{
 return (page->flags >> ((((((sizeof(unsigned long)*8) - 0) - 8) - 1) - (8 +11)) * ((8 +11) != 0))) & ((1UL << (8 +11)) - 1);
}

extern int page_cpupid_xchg_last(struct page *page, int cpupid);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_cpupid_reset_last(struct page *page)
{
 page->flags |= ((1UL << (8 +11)) - 1) << ((((((sizeof(unsigned long)*8) - 0) - 8) - 1) - (8 +11)) * ((8 +11) != 0));
}
# 1210 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 page_kasan_tag(const struct page *page)
{
 return 0xff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_kasan_tag_set(struct page *page, u8 tag) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_kasan_tag_reset(struct page *page) { }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct zone *page_zone(const struct page *page)
{
 return &(node_data[page_to_nid(page)])->node_zones[page_zonenum(page)];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pg_data_t *page_pgdat(const struct page *page)
{
 return (node_data[page_to_nid(page)]);
}
# 1242 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_zone(struct page *page, enum zone_type zone)
{
 page->flags &= ~(((1UL << 1) - 1) << (((((sizeof(unsigned long)*8) - 0) - 8) - 1) * (1 != 0)));
 page->flags |= (zone & ((1UL << 1) - 1)) << (((((sizeof(unsigned long)*8) - 0) - 8) - 1) * (1 != 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_node(struct page *page, unsigned long node)
{
 page->flags &= ~(((1UL << 8) - 1) << ((((sizeof(unsigned long)*8) - 0) - 8) * (8 != 0)));
 page->flags |= (node & ((1UL << 8) - 1)) << ((((sizeof(unsigned long)*8) - 0) - 8) * (8 != 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_links(struct page *page, enum zone_type zone,
 unsigned long node, unsigned long pfn)
{
 set_page_zone(page, zone);
 set_page_node(page, node);



}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_cgroup *page_memcg(struct page *page)
{
 return page->mem_cgroup;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_cgroup *page_memcg_rcu(struct page *page)
{
 ({ int __ret_warn_on = !!(!rcu_read_lock_held()); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/mm.h"), "i" (1271), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return ({ union { typeof(page->mem_cgroup) __val; char __c[1]; } __u; if (1) __read_once_size(&(page->mem_cgroup), __u.__c, sizeof(page->mem_cgroup)); else __read_once_size_nocheck(&(page->mem_cgroup), __u.__c, sizeof(page->mem_cgroup)); do { } while (0); __u.__val; });
}
# 1289 "/home/nathan/src/linux-next/include/linux/mm.h"
# 1 "/home/nathan/src/linux-next/include/linux/vmstat.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/vm_event_item.h" 1
# 25 "/home/nathan/src/linux-next/include/linux/vm_event_item.h"
enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
  PGALLOC_NORMAL, PGALLOC_MOVABLE,
  ALLOCSTALL_NORMAL, ALLOCSTALL_MOVABLE,
  PGSCAN_SKIP_NORMAL, PGSCAN_SKIP_MOVABLE,
  PGFREE, PGACTIVATE, PGDEACTIVATE, PGLAZYFREE,
  PGFAULT, PGMAJFAULT,
  PGLAZYFREED,
  PGREFILL,
  PGSTEAL_KSWAPD,
  PGSTEAL_DIRECT,
  PGSCAN_KSWAPD,
  PGSCAN_DIRECT,
  PGSCAN_DIRECT_THROTTLE,

  PGSCAN_ZONE_RECLAIM_FAILED,

  PGINODESTEAL, SLABS_SCANNED, KSWAPD_INODESTEAL,
  KSWAPD_LOW_WMARK_HIT_QUICKLY, KSWAPD_HIGH_WMARK_HIT_QUICKLY,
  PAGEOUTRUN, PGROTATED,
  DROP_PAGECACHE, DROP_SLAB,
  OOM_KILL,

  NUMA_PTE_UPDATES,
  NUMA_HUGE_PTE_UPDATES,
  NUMA_HINT_FAULTS,
  NUMA_HINT_FAULTS_LOCAL,
  NUMA_PAGE_MIGRATE,


  PGMIGRATE_SUCCESS, PGMIGRATE_FAIL,


  COMPACTMIGRATE_SCANNED, COMPACTFREE_SCANNED,
  COMPACTISOLATED,
  COMPACTSTALL, COMPACTFAIL, COMPACTSUCCESS,
  KCOMPACTD_WAKE,
  KCOMPACTD_MIGRATE_SCANNED, KCOMPACTD_FREE_SCANNED,


  HTLB_BUDDY_PGALLOC, HTLB_BUDDY_PGALLOC_FAIL,

  UNEVICTABLE_PGCULLED,
  UNEVICTABLE_PGSCANNED,
  UNEVICTABLE_PGRESCUED,
  UNEVICTABLE_PGMLOCKED,
  UNEVICTABLE_PGMUNLOCKED,
  UNEVICTABLE_PGCLEARED,
  UNEVICTABLE_PGSTRANDED,

  THP_FAULT_ALLOC,
  THP_FAULT_FALLBACK,
  THP_COLLAPSE_ALLOC,
  THP_COLLAPSE_ALLOC_FAILED,
  THP_FILE_ALLOC,
  THP_FILE_MAPPED,
  THP_SPLIT_PAGE,
  THP_SPLIT_PAGE_FAILED,
  THP_DEFERRED_SPLIT_PAGE,
  THP_SPLIT_PMD,



  THP_ZERO_PAGE_ALLOC,
  THP_ZERO_PAGE_ALLOC_FAILED,
  THP_SWPOUT,
  THP_SWPOUT_FALLBACK,


  BALLOON_INFLATE,
  BALLOON_DEFLATE,

  BALLOON_MIGRATE,
# 110 "/home/nathan/src/linux-next/include/linux/vm_event_item.h"
  SWAP_RA,
  SWAP_RA_HIT,

  NR_VM_EVENT_ITEMS
};
# 9 "/home/nathan/src/linux-next/include/linux/vmstat.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/vmstat.h" 2

extern int sysctl_stat_interval;




extern int sysctl_vm_numa_stat;
extern struct static_key_true vm_numa_stat_key;
extern int sysctl_vm_numa_stat_handler(struct ctl_table *table,
  int write, void *buffer, size_t *length, loff_t *ppos);


struct reclaim_stat {
 unsigned nr_dirty;
 unsigned nr_unqueued_dirty;
 unsigned nr_congested;
 unsigned nr_writeback;
 unsigned nr_immediate;
 unsigned nr_activate[2];
 unsigned nr_ref_keep;
 unsigned nr_unmap_fail;
};

enum writeback_stat_item {
 NR_DIRTY_THRESHOLD,
 NR_DIRTY_BG_THRESHOLD,
 NR_VM_WRITEBACK_STAT_ITEMS,
};
# 51 "/home/nathan/src/linux-next/include/linux/vmstat.h"
struct vm_event_state {
 unsigned long event[NR_VM_EVENT_ITEMS];
};

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct vm_event_state) vm_event_states;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __count_vm_event(enum vm_event_item item)
{
 do { do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(vm_event_states.event[item])) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void count_vm_event(enum vm_event_item item)
{
 do { do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(vm_event_states.event[item])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __count_vm_events(enum vm_event_item item, long delta)
{
 do { do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(vm_event_states.event[item])) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void count_vm_events(enum vm_event_item item, long delta)
{
 do { do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(vm_event_states.event[item])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(vm_event_states.event[item])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item]))); (typeof((typeof(*(&(vm_event_states.event[item]))) *)(&(vm_event_states.event[item])))) (__ptr + ((local_paca->data_offset))); }); }) += delta; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

extern void all_vm_events(unsigned long *);

extern void vm_events_fold_cpu(int cpu);
# 137 "/home/nathan/src/linux-next/include/linux/vmstat.h"
extern atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];
extern atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];
extern atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_numa_state_add(long x, struct zone *zone,
     enum numa_stat_item item)
{
 atomic_long_add(x, &zone->vm_numa_stat[item]);
 atomic_long_add(x, &vm_numa_stat[item]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long global_numa_state(enum numa_stat_item item)
{
 long x = atomic_long_read(&vm_numa_stat[item]);

 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_numa_state_snapshot(struct zone *zone,
     enum numa_stat_item item)
{
 long x = atomic_long_read(&zone->vm_numa_stat[item]);
 int cpu;

 for (((cpu)) = -1; ((cpu)) = cpumask_next(((cpu)), (((const struct cpumask *)&__cpu_online_mask))), ((cpu)) < nr_cpu_ids;)
  x += ({ do { const void *__vpp_verify = (typeof((zone->pageset) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((zone->pageset))) *)((zone->pageset))); (typeof((typeof(*((zone->pageset))) *)((zone->pageset)))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })->vm_numa_stat_diff[item];

 return x;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zone_page_state_add(long x, struct zone *zone,
     enum zone_stat_item item)
{
 atomic_long_add(x, &zone->vm_stat[item]);
 atomic_long_add(x, &vm_zone_stat[item]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void node_page_state_add(long x, struct pglist_data *pgdat,
     enum node_stat_item item)
{
 atomic_long_add(x, &pgdat->vm_stat[item]);
 atomic_long_add(x, &vm_node_stat[item]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long global_zone_page_state(enum zone_stat_item item)
{
 long x = atomic_long_read(&vm_zone_stat[item]);

 if (x < 0)
  x = 0;

 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long global_node_page_state(enum node_stat_item item)
{
 long x = atomic_long_read(&vm_node_stat[item]);

 if (x < 0)
  x = 0;

 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_page_state(struct zone *zone,
     enum zone_stat_item item)
{
 long x = atomic_long_read(&zone->vm_stat[item]);

 if (x < 0)
  x = 0;

 return x;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long zone_page_state_snapshot(struct zone *zone,
     enum zone_stat_item item)
{
 long x = atomic_long_read(&zone->vm_stat[item]);


 int cpu;
 for (((cpu)) = -1; ((cpu)) = cpumask_next(((cpu)), (((const struct cpumask *)&__cpu_online_mask))), ((cpu)) < nr_cpu_ids;)
  x += ({ do { const void *__vpp_verify = (typeof((zone->pageset) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((zone->pageset))) *)((zone->pageset))); (typeof((typeof(*((zone->pageset))) *)((zone->pageset)))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })->vm_stat_diff[item];

 if (x < 0)
  x = 0;

 return x;
}


extern void __inc_numa_state(struct zone *zone, enum numa_stat_item item);
extern unsigned long sum_zone_node_page_state(int node,
           enum zone_stat_item item);
extern unsigned long sum_zone_numa_state(int node, enum numa_stat_item item);
extern unsigned long node_page_state(struct pglist_data *pgdat,
      enum node_stat_item item);






void __mod_zone_page_state(struct zone *, enum zone_stat_item item, long);
void __inc_zone_page_state(struct page *, enum zone_stat_item);
void __dec_zone_page_state(struct page *, enum zone_stat_item);

void __mod_node_page_state(struct pglist_data *, enum node_stat_item item, long);
void __inc_node_page_state(struct page *, enum node_stat_item);
void __dec_node_page_state(struct page *, enum node_stat_item);

void mod_zone_page_state(struct zone *, enum zone_stat_item, long);
void inc_zone_page_state(struct page *, enum zone_stat_item);
void dec_zone_page_state(struct page *, enum zone_stat_item);

void mod_node_page_state(struct pglist_data *, enum node_stat_item, long);
void inc_node_page_state(struct page *, enum node_stat_item);
void dec_node_page_state(struct page *, enum node_stat_item);

extern void inc_node_state(struct pglist_data *, enum node_stat_item);
extern void __inc_zone_state(struct zone *, enum zone_stat_item);
extern void __inc_node_state(struct pglist_data *, enum node_stat_item);
extern void dec_zone_state(struct zone *, enum zone_stat_item);
extern void __dec_zone_state(struct zone *, enum zone_stat_item);
extern void __dec_node_state(struct pglist_data *, enum node_stat_item);

void quiet_vmstat(void);
void cpu_vm_stats_fold(int cpu);
void refresh_zone_stat_thresholds(void);

struct ctl_table;
int vmstat_refresh(struct ctl_table *, int write,
     void *buffer, size_t *lenp, loff_t *ppos);

void drain_zonestat(struct zone *zone, struct per_cpu_pageset *);

int calculate_pressure_threshold(struct zone *zone);
int calculate_normal_threshold(struct zone *zone);
void set_pgdat_percpu_threshold(pg_data_t *pgdat,
    int (*calculate_pressure)(struct zone *));
# 380 "/home/nathan/src/linux-next/include/linux/vmstat.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __mod_zone_freepage_state(struct zone *zone, int nr_pages,
          int migratetype)
{
 __mod_zone_page_state(zone, NR_FREE_PAGES, nr_pages);
 if (__builtin_expect(!!((migratetype) == MIGRATE_CMA), 0))
  __mod_zone_page_state(zone, NR_FREE_CMA_PAGES, nr_pages);
}

extern const char * const vmstat_text[];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *zone_stat_name(enum zone_stat_item item)
{
 return vmstat_text[item];
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *numa_stat_name(enum numa_stat_item item)
{
 return vmstat_text[NR_VM_ZONE_STAT_ITEMS +
      item];
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *node_stat_name(enum node_stat_item item)
{
 return vmstat_text[NR_VM_ZONE_STAT_ITEMS +
      NR_VM_NUMA_STAT_ITEMS +
      item];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *lru_list_name(enum lru_list lru)
{
 return node_stat_name(NR_LRU_BASE + lru) + 3;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *writeback_stat_name(enum writeback_stat_item item)
{
 return vmstat_text[NR_VM_ZONE_STAT_ITEMS +
      NR_VM_NUMA_STAT_ITEMS +
      NR_VM_NODE_STAT_ITEMS +
      item];
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *vm_event_name(enum vm_event_item item)
{
 return vmstat_text[NR_VM_ZONE_STAT_ITEMS +
      NR_VM_NUMA_STAT_ITEMS +
      NR_VM_NODE_STAT_ITEMS +
      NR_VM_WRITEBACK_STAT_ITEMS +
      item];
}
# 1290 "/home/nathan/src/linux-next/include/linux/mm.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *lowmem_page_address(const struct page *page)
{
 return ({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(((phys_addr_t)((unsigned long)((page) - vmemmap)) << 16)) | 0xc000000000000000UL); });
}
# 1324 "/home/nathan/src/linux-next/include/linux/mm.h"
extern void *page_rmapping(struct page *page);
extern struct anon_vma *page_anon_vma(struct page *page);
extern struct address_space *page_mapping(struct page *page);

extern struct address_space *__page_file_mapping(struct page *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct address_space *page_file_mapping(struct page *page)
{
 if (__builtin_expect(!!(PageSwapCache(page)), 0))
  return __page_file_mapping(page);

 return page->mapping;
}

extern unsigned long __page_file_index(struct page *page);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long page_index(struct page *page)
{
 if (__builtin_expect(!!(PageSwapCache(page)), 0))
  return __page_file_index(page);
 return page->index;
}

bool page_mapped(struct page *page);
struct address_space *page_mapping(struct page *page);
struct address_space *page_mapping_file(struct page *page);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool page_is_pfmemalloc(struct page *page)
{




 return page->index == -1UL;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_page_pfmemalloc(struct page *page)
{
 page->index = -1UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_page_pfmemalloc(struct page *page)
{
 page->index = 0;
}




extern void pagefault_out_of_memory(void);
# 1397 "/home/nathan/src/linux-next/include/linux/mm.h"
extern void show_free_areas(unsigned int flags, nodemask_t *nodemask);


extern bool can_do_mlock(void);



extern int user_shm_lock(size_t, struct user_struct *);
extern void user_shm_unlock(size_t, struct user_struct *);




struct zap_details {
 struct address_space *check_mapping;
 unsigned long first_index;
 unsigned long last_index;
};

struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
        pte_t pte);
struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,
    pmd_t pmd);

void zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
    unsigned long size);
void zap_page_range(struct vm_area_struct *vma, unsigned long address,
      unsigned long size);
void unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *start_vma,
  unsigned long start, unsigned long end);

struct mmu_notifier_range;

void free_pgd_range(struct mmu_gather *tlb, unsigned long addr,
  unsigned long end, unsigned long floor, unsigned long ceiling);
int copy_page_range(struct mm_struct *dst, struct mm_struct *src,
   struct vm_area_struct *vma);
int follow_pte_pmd(struct mm_struct *mm, unsigned long address,
     struct mmu_notifier_range *range,
     pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp);
int follow_pfn(struct vm_area_struct *vma, unsigned long address,
 unsigned long *pfn);
int follow_phys(struct vm_area_struct *vma, unsigned long address,
  unsigned int flags, unsigned long *prot, resource_size_t *phys);
int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,
   void *buf, int len, int write);

extern void truncate_pagecache(struct inode *inode, loff_t new);
extern void truncate_setsize(struct inode *inode, loff_t newsize);
void pagecache_isize_extended(struct inode *inode, loff_t from, loff_t to);
void truncate_pagecache_range(struct inode *inode, loff_t offset, loff_t end);
int truncate_inode_page(struct address_space *mapping, struct page *page);
int generic_error_remove_page(struct address_space *mapping, struct page *page);
int invalidate_inode_page(struct page *page);


extern vm_fault_t handle_mm_fault(struct vm_area_struct *vma,
   unsigned long address, unsigned int flags);
extern int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,
       unsigned long address, unsigned int fault_flags,
       bool *unlocked);
void unmap_mapping_pages(struct address_space *mapping,
  unsigned long start, unsigned long nr, bool even_cows);
void unmap_mapping_range(struct address_space *mapping,
  loff_t const holebegin, loff_t const holelen, int even_cows);
# 1484 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unmap_shared_mapping_range(struct address_space *mapping,
  loff_t const holebegin, loff_t const holelen)
{
 unmap_mapping_range(mapping, holebegin, holelen, 0);
}

extern int access_process_vm(struct task_struct *tsk, unsigned long addr,
  void *buf, int len, unsigned int gup_flags);
extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
  void *buf, int len, unsigned int gup_flags);
extern int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
  unsigned long addr, void *buf, int len, unsigned int gup_flags);

long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
       unsigned long start, unsigned long nr_pages,
       unsigned int gup_flags, struct page **pages,
       struct vm_area_struct **vmas, int *locked);
long pin_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
      unsigned long start, unsigned long nr_pages,
      unsigned int gup_flags, struct page **pages,
      struct vm_area_struct **vmas, int *locked);
long get_user_pages(unsigned long start, unsigned long nr_pages,
       unsigned int gup_flags, struct page **pages,
       struct vm_area_struct **vmas);
long pin_user_pages(unsigned long start, unsigned long nr_pages,
      unsigned int gup_flags, struct page **pages,
      struct vm_area_struct **vmas);
long get_user_pages_locked(unsigned long start, unsigned long nr_pages,
      unsigned int gup_flags, struct page **pages, int *locked);
long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
      struct page **pages, unsigned int gup_flags);

int get_user_pages_fast(unsigned long start, int nr_pages,
   unsigned int gup_flags, struct page **pages);
int pin_user_pages_fast(unsigned long start, int nr_pages,
   unsigned int gup_flags, struct page **pages);

int account_locked_vm(struct mm_struct *mm, unsigned long pages, bool inc);
int __account_locked_vm(struct mm_struct *mm, unsigned long pages, bool inc,
   struct task_struct *task, bool bypass_rlim);


struct frame_vector {
 unsigned int nr_allocated;
 unsigned int nr_frames;
 bool got_ref;
 bool is_pfns;
 void *ptrs[0];


};

struct frame_vector *frame_vector_create(unsigned int nr_frames);
void frame_vector_destroy(struct frame_vector *vec);
int get_vaddr_frames(unsigned long start, unsigned int nr_pfns,
       unsigned int gup_flags, struct frame_vector *vec);
void put_vaddr_frames(struct frame_vector *vec);
int frame_vector_to_pages(struct frame_vector *vec);
void frame_vector_to_pfns(struct frame_vector *vec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int frame_vector_count(struct frame_vector *vec)
{
 return vec->nr_frames;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page **frame_vector_pages(struct frame_vector *vec)
{
 if (vec->is_pfns) {
  int err = frame_vector_to_pages(vec);

  if (err)
   return ERR_PTR(err);
 }
 return (struct page **)(vec->ptrs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long *frame_vector_pfns(struct frame_vector *vec)
{
 if (!vec->is_pfns)
  frame_vector_to_pfns(vec);
 return (unsigned long *)(vec->ptrs);
}

struct kvec;
int get_kernel_pages(const struct kvec *iov, int nr_pages, int write,
   struct page **pages);
int get_kernel_page(unsigned long start, int write, struct page **pages);
struct page *get_dump_page(unsigned long addr);

extern int try_to_release_page(struct page * page, gfp_t gfp_mask);
extern void do_invalidatepage(struct page *page, unsigned int offset,
         unsigned int length);

void __set_page_dirty(struct page *, struct address_space *, int warn);
int __set_page_dirty_nobuffers(struct page *page);
int __set_page_dirty_no_writeback(struct page *page);
int redirty_page_for_writepage(struct writeback_control *wbc,
    struct page *page);
void account_page_dirtied(struct page *page, struct address_space *mapping);
void account_page_cleaned(struct page *page, struct address_space *mapping,
     struct bdi_writeback *wb);
int set_page_dirty(struct page *page);
int set_page_dirty_lock(struct page *page);
void __cancel_dirty_page(struct page *page);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cancel_dirty_page(struct page *page)
{

 if (PageDirty(page))
  __cancel_dirty_page(page);
}
int clear_page_dirty_for_io(struct page *page);

int get_cmdline(struct task_struct *task, char *buffer, int buflen);

extern unsigned long move_page_tables(struct vm_area_struct *vma,
  unsigned long old_addr, struct vm_area_struct *new_vma,
  unsigned long new_addr, unsigned long len,
  bool need_rmap_locks);
extern unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,
         unsigned long end, pgprot_t newprot,
         int dirty_accountable, int prot_numa);
extern int mprotect_fixup(struct vm_area_struct *vma,
     struct vm_area_struct **pprev, unsigned long start,
     unsigned long end, unsigned long newflags);




int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
     struct page **pages);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_mm_counter(struct mm_struct *mm, int member)
{
 long val = atomic_long_read(&mm->rss_stat.count[member]);






 if (val < 0)
  val = 0;

 return (unsigned long)val;
}

void mm_trace_rss_stat(struct mm_struct *mm, int member, long count);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_mm_counter(struct mm_struct *mm, int member, long value)
{
 long count = atomic_long_add_return(value, &mm->rss_stat.count[member]);

 mm_trace_rss_stat(mm, member, count);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_mm_counter(struct mm_struct *mm, int member)
{
 long count = atomic_long_inc_return(&mm->rss_stat.count[member]);

 mm_trace_rss_stat(mm, member, count);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_mm_counter(struct mm_struct *mm, int member)
{
 long count = atomic_long_dec_return(&mm->rss_stat.count[member]);

 mm_trace_rss_stat(mm, member, count);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mm_counter_file(struct page *page)
{
 if (PageSwapBacked(page))
  return MM_SHMEMPAGES;
 return MM_FILEPAGES;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mm_counter(struct page *page)
{
 if (PageAnon(page))
  return MM_ANONPAGES;
 return mm_counter_file(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_mm_rss(struct mm_struct *mm)
{
 return get_mm_counter(mm, MM_FILEPAGES) +
  get_mm_counter(mm, MM_ANONPAGES) +
  get_mm_counter(mm, MM_SHMEMPAGES);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_mm_hiwater_rss(struct mm_struct *mm)
{
 return __builtin_choose_expr(((!!(sizeof((typeof(mm->hiwater_rss) *)1 == (typeof(get_mm_rss(mm)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(mm->hiwater_rss) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(get_mm_rss(mm)) * 0l)) : (int *)8))))), ((mm->hiwater_rss) > (get_mm_rss(mm)) ? (mm->hiwater_rss) : (get_mm_rss(mm))), ({ typeof(mm->hiwater_rss) __UNIQUE_ID___x12 = (mm->hiwater_rss); typeof(get_mm_rss(mm)) __UNIQUE_ID___y13 = (get_mm_rss(mm)); ((__UNIQUE_ID___x12) > (__UNIQUE_ID___y13) ? (__UNIQUE_ID___x12) : (__UNIQUE_ID___y13)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_mm_hiwater_vm(struct mm_struct *mm)
{
 return __builtin_choose_expr(((!!(sizeof((typeof(mm->hiwater_vm) *)1 == (typeof(mm->total_vm) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(mm->hiwater_vm) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(mm->total_vm) * 0l)) : (int *)8))))), ((mm->hiwater_vm) > (mm->total_vm) ? (mm->hiwater_vm) : (mm->total_vm)), ({ typeof(mm->hiwater_vm) __UNIQUE_ID___x14 = (mm->hiwater_vm); typeof(mm->total_vm) __UNIQUE_ID___y15 = (mm->total_vm); ((__UNIQUE_ID___x14) > (__UNIQUE_ID___y15) ? (__UNIQUE_ID___x14) : (__UNIQUE_ID___y15)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_hiwater_rss(struct mm_struct *mm)
{
 unsigned long _rss = get_mm_rss(mm);

 if ((mm)->hiwater_rss < _rss)
  (mm)->hiwater_rss = _rss;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void update_hiwater_vm(struct mm_struct *mm)
{
 if (mm->hiwater_vm < mm->total_vm)
  mm->hiwater_vm = mm->total_vm;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reset_mm_hiwater_rss(struct mm_struct *mm)
{
 mm->hiwater_rss = get_mm_rss(mm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void setmax_mm_hiwater_rss(unsigned long *maxrss,
      struct mm_struct *mm)
{
 unsigned long hiwater_rss = get_mm_hiwater_rss(mm);

 if (*maxrss < hiwater_rss)
  *maxrss = hiwater_rss;
}


void sync_mm_rss(struct mm_struct *mm);
# 1730 "/home/nathan/src/linux-next/include/linux/mm.h"
int vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot);

extern pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,
          spinlock_t **ptl);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pte_t *get_locked_pte(struct mm_struct *mm, unsigned long addr,
        spinlock_t **ptl)
{
 pte_t *ptep;
 (ptep = __get_locked_pte(mm, addr, ptl));
 return ptep;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd,
      unsigned long address)
{
 return 0;
}
# 1762 "/home/nathan/src/linux-next/include/linux/mm.h"
int __pud_alloc(struct mm_struct *mm, pgd_t *p4d, unsigned long address);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_inc_nr_puds(struct mm_struct *mm)
{
 if (0)
  return;
 atomic_long_add((1 << __pud_index_size) * sizeof(pud_t), &mm->pgtables_bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_dec_nr_puds(struct mm_struct *mm)
{
 if (0)
  return;
 atomic_long_sub((1 << __pud_index_size) * sizeof(pud_t), &mm->pgtables_bytes);
}
# 1790 "/home/nathan/src/linux-next/include/linux/mm.h"
int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_inc_nr_pmds(struct mm_struct *mm)
{
 if (0)
  return;
 atomic_long_add((1 << __pmd_index_size) * sizeof(pmd_t), &mm->pgtables_bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_dec_nr_pmds(struct mm_struct *mm)
{
 if (0)
  return;
 atomic_long_sub((1 << __pmd_index_size) * sizeof(pmd_t), &mm->pgtables_bytes);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_pgtables_bytes_init(struct mm_struct *mm)
{
 atomic_long_set(&mm->pgtables_bytes, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long mm_pgtables_bytes(const struct mm_struct *mm)
{
 return atomic_long_read(&mm->pgtables_bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_inc_nr_ptes(struct mm_struct *mm)
{
 atomic_long_add((1 << __pte_index_size) * sizeof(pte_t), &mm->pgtables_bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_dec_nr_ptes(struct mm_struct *mm)
{
 atomic_long_sub((1 << __pte_index_size) * sizeof(pte_t), &mm->pgtables_bytes);
}
# 1839 "/home/nathan/src/linux-next/include/linux/mm.h"
int __pte_alloc(struct mm_struct *mm, pmd_t *pmd);
int __pte_alloc_kernel(pmd_t *pmd);
# 1864 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
{
 return (__builtin_expect(!!(pud_none(*pud)), 0) && __pmd_alloc(mm, pud, address))?
  ((void *)0): (((pmd_t *) ({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(pud_val(*(pud)) & ~0xc0000000000000ffUL) | 0xc000000000000000UL); })) + (((address) >> ((16 + __pte_index_size))) & ((1 << __pmd_index_size) - 1)));
}
# 1882 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptlock_cache_init(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ptlock_alloc(struct page *page)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptlock_free(struct page *page)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *ptlock_ptr(struct page *page)
{
 return &page->ptl;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pte_lockptr(struct mm_struct *mm, pmd_t *pmd)
{
 return ptlock_ptr(pmd_page(*pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ptlock_init(struct page *page)
{







 ((void)(sizeof(( long)(*(unsigned long *)&page->ptl))));
 if (!ptlock_alloc(page))
  return false;
 do { spinlock_check(ptlock_ptr(page)); do { *(&(ptlock_ptr(page))->rlock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0); } while (0);
 return true;
}
# 1935 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgtable_init(void)
{
 ptlock_cache_init();
 pgtable_cache_init();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgtable_pte_page_ctor(struct page *page)
{
 if (!ptlock_init(page))
  return false;
 __SetPageTable(page);
 inc_zone_page_state(page, NR_PAGETABLE);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgtable_pte_page_dtor(struct page *page)
{
 ptlock_free(page);
 __ClearPageTable(page);
 dec_zone_page_state(page, NR_PAGETABLE);
}
# 1986 "/home/nathan/src/linux-next/include/linux/mm.h"
static struct page *pmd_to_page(pmd_t *pmd)
{
 unsigned long mask = ~((1 << __pmd_index_size) * sizeof(pmd_t) - 1);
 return (vmemmap + ((({ do { } while (0); (unsigned long)((void *)((unsigned long) pmd & mask)) & 0x0fffffffffffffffUL; }) >> 16)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pmd_lockptr(struct mm_struct *mm, pmd_t *pmd)
{
 return ptlock_ptr(pmd_to_page(pmd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pgtable_pmd_page_ctor(struct page *page)
{

 page->pmd_huge_pte = ((void *)0);

 return ptlock_init(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pgtable_pmd_page_dtor(struct page *page)
{

 ((void)(sizeof(( long)(page->pmd_huge_pte))));

 ptlock_free(page);
}
# 2029 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pmd_lock(struct mm_struct *mm, pmd_t *pmd)
{
 spinlock_t *ptl = pmd_lockptr(mm, pmd);
 spin_lock(ptl);
 return ptl;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pud_lockptr(struct mm_struct *mm, pud_t *pud)
{
 return &mm->page_table_lock;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *pud_lock(struct mm_struct *mm, pud_t *pud)
{
 spinlock_t *ptl = pud_lockptr(mm, pud);

 spin_lock(ptl);
 return ptl;
}

extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) pagecache_init(void);
extern void free_area_init(unsigned long * zones_size);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) free_area_init_node(int nid, unsigned long * zones_size,
  unsigned long zone_start_pfn, unsigned long *zholes_size);
extern void free_initmem(void);







extern unsigned long free_reserved_area(void *start, void *end,
     int poison, const char *s);
# 2078 "/home/nathan/src/linux-next/include/linux/mm.h"
extern void adjust_managed_page_count(struct page *page, long count);
extern void mem_init_print_info(const char *str);

extern void reserve_bootmem_region(phys_addr_t start, phys_addr_t end);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __free_reserved_page(struct page *page)
{
 ClearPageReserved(page);
 init_page_count(page);
 __free_pages((page), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_reserved_page(struct page *page)
{
 __free_reserved_page(page);
 adjust_managed_page_count(page, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mark_page_reserved(struct page *page)
{
 SetPageReserved(page);
 adjust_managed_page_count(page, -1);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long free_initmem_default(int poison)
{
 extern char __init_begin[], __init_end[];

 return free_reserved_area(&__init_begin, &__init_end,
      poison, "unused kernel");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_num_physpages(void)
{
 int nid;
 unsigned long phys_pages = 0;

 for (((nid)) = __first_node(&(node_states[N_ONLINE])); ((nid)) < (1 << 8); ((nid)) = __next_node((((nid))), &((node_states[N_ONLINE]))))
  phys_pages += ((node_data[nid])->node_present_pages);

 return phys_pages;
}
# 2155 "/home/nathan/src/linux-next/include/linux/mm.h"
extern void free_area_init_nodes(unsigned long *max_zone_pfn);
unsigned long node_map_pfn_alignment(void);
unsigned long __absent_pages_in_range(int nid, unsigned long start_pfn,
      unsigned long end_pfn);
extern unsigned long absent_pages_in_range(unsigned long start_pfn,
      unsigned long end_pfn);
extern void get_pfn_range_for_nid(unsigned int nid,
   unsigned long *start_pfn, unsigned long *end_pfn);
extern unsigned long find_min_pfn_with_active_regions(void);
extern void free_bootmem_with_active_regions(int nid,
      unsigned long max_low_pfn);
extern void sparse_memory_present_with_active_regions(int nid);
# 2179 "/home/nathan/src/linux-next/include/linux/mm.h"
extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) early_pfn_to_nid(unsigned long pfn);

extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) __early_pfn_to_nid(unsigned long pfn,
     struct mminit_pfnnid_cache *state);


extern void set_dma_reserve(unsigned long new_dma_reserve);
extern void memmap_init_zone(unsigned long, int, unsigned long, unsigned long,
  enum memmap_context, struct vmem_altmap *);
extern void setup_per_zone_wmarks(void);
extern int __attribute__((__section__(".meminit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) init_per_zone_wmark_min(void);
extern void mem_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) mmap_init(void);
extern void show_mem(unsigned int flags, nodemask_t *nodemask);
extern long si_mem_available(void);
extern void si_meminfo(struct sysinfo * val);
extern void si_meminfo_node(struct sysinfo *val, int nid);




extern __attribute__((__format__(printf, 3, 4)))
void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...);

extern void setup_per_cpu_pageset(void);


extern int min_free_kbytes;
extern int watermark_boost_factor;
extern int watermark_scale_factor;


extern atomic_long_t mmap_pages_allocated;
extern int nommu_shrink_inode_mappings(struct inode *, size_t, size_t);


void vma_interval_tree_insert(struct vm_area_struct *node,
         struct rb_root_cached *root);
void vma_interval_tree_insert_after(struct vm_area_struct *node,
        struct vm_area_struct *prev,
        struct rb_root_cached *root);
void vma_interval_tree_remove(struct vm_area_struct *node,
         struct rb_root_cached *root);
struct vm_area_struct *vma_interval_tree_iter_first(struct rb_root_cached *root,
    unsigned long start, unsigned long last);
struct vm_area_struct *vma_interval_tree_iter_next(struct vm_area_struct *node,
    unsigned long start, unsigned long last);





void anon_vma_interval_tree_insert(struct anon_vma_chain *node,
       struct rb_root_cached *root);
void anon_vma_interval_tree_remove(struct anon_vma_chain *node,
       struct rb_root_cached *root);
struct anon_vma_chain *
anon_vma_interval_tree_iter_first(struct rb_root_cached *root,
      unsigned long start, unsigned long last);
struct anon_vma_chain *anon_vma_interval_tree_iter_next(
 struct anon_vma_chain *node, unsigned long start, unsigned long last);
# 2249 "/home/nathan/src/linux-next/include/linux/mm.h"
extern int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin);
extern int __vma_adjust(struct vm_area_struct *vma, unsigned long start,
 unsigned long end, unsigned long pgoff, struct vm_area_struct *insert,
 struct vm_area_struct *expand);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vma_adjust(struct vm_area_struct *vma, unsigned long start,
 unsigned long end, unsigned long pgoff, struct vm_area_struct *insert)
{
 return __vma_adjust(vma, start, end, pgoff, insert, ((void *)0));
}
extern struct vm_area_struct *vma_merge(struct mm_struct *,
 struct vm_area_struct *prev, unsigned long addr, unsigned long end,
 unsigned long vm_flags, struct anon_vma *, struct file *, unsigned long,
 struct mempolicy *, struct vm_userfaultfd_ctx);
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);
extern int __split_vma(struct mm_struct *, struct vm_area_struct *,
 unsigned long addr, int new_below);
extern int split_vma(struct mm_struct *, struct vm_area_struct *,
 unsigned long addr, int new_below);
extern int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);
extern void __vma_link_rb(struct mm_struct *, struct vm_area_struct *,
 struct rb_node **, struct rb_node *);
extern void unlink_file_vma(struct vm_area_struct *);
extern struct vm_area_struct *copy_vma(struct vm_area_struct **,
 unsigned long addr, unsigned long len, unsigned long pgoff,
 bool *need_rmap_locks);
extern void exit_mmap(struct mm_struct *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int check_data_rlimit(unsigned long rlim,
        unsigned long new,
        unsigned long start,
        unsigned long end_data,
        unsigned long start_data)
{
 if (rlim < (~0UL)) {
  if (((new - start) + (end_data - start_data)) > rlim)
   return -28;
 }

 return 0;
}

extern int mm_take_all_locks(struct mm_struct *mm);
extern void mm_drop_all_locks(struct mm_struct *mm);

extern void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file);
extern struct file *get_mm_exe_file(struct mm_struct *mm);
extern struct file *get_task_exe_file(struct task_struct *task);

extern bool may_expand_vm(struct mm_struct *, vm_flags_t, unsigned long npages);
extern void vm_stat_account(struct mm_struct *, vm_flags_t, long npages);

extern bool vma_is_special_mapping(const struct vm_area_struct *vma,
       const struct vm_special_mapping *sm);
extern struct vm_area_struct *_install_special_mapping(struct mm_struct *mm,
       unsigned long addr, unsigned long len,
       unsigned long flags,
       const struct vm_special_mapping *spec);

extern int install_special_mapping(struct mm_struct *mm,
       unsigned long addr, unsigned long len,
       unsigned long flags, struct page **pages);

unsigned long randomize_stack_top(unsigned long stack_top);

extern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);

extern unsigned long mmap_region(struct file *file, unsigned long addr,
 unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,
 struct list_head *uf);
extern unsigned long do_mmap(struct file *file, unsigned long addr,
 unsigned long len, unsigned long prot, unsigned long flags,
 vm_flags_t vm_flags, unsigned long pgoff, unsigned long *populate,
 struct list_head *uf);
extern int __do_munmap(struct mm_struct *, unsigned long, size_t,
         struct list_head *uf, bool downgrade);
extern int do_munmap(struct mm_struct *, unsigned long, size_t,
       struct list_head *uf);
extern int do_madvise(unsigned long start, size_t len_in, int behavior);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
do_mmap_pgoff(struct file *file, unsigned long addr,
 unsigned long len, unsigned long prot, unsigned long flags,
 unsigned long pgoff, unsigned long *populate,
 struct list_head *uf)
{
 return do_mmap(file, addr, len, prot, flags, 0, pgoff, populate, uf);
}


extern int __mm_populate(unsigned long addr, unsigned long len,
    int ignore_errors);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mm_populate(unsigned long addr, unsigned long len)
{

 (void) __mm_populate(addr, len, 1);
}





extern int __attribute__((__warn_unused_result__)) vm_brk(unsigned long, unsigned long);
extern int __attribute__((__warn_unused_result__)) vm_brk_flags(unsigned long, unsigned long, unsigned long);
extern int vm_munmap(unsigned long, size_t);
extern unsigned long __attribute__((__warn_unused_result__)) vm_mmap(struct file *, unsigned long,
        unsigned long, unsigned long,
        unsigned long, unsigned long);

struct vm_unmapped_area_info {

 unsigned long flags;
 unsigned long length;
 unsigned long low_limit;
 unsigned long high_limit;
 unsigned long align_mask;
 unsigned long align_offset;
};

extern unsigned long unmapped_area(struct vm_unmapped_area_info *info);
extern unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info);
# 2379 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
vm_unmapped_area(struct vm_unmapped_area_info *info)
{
 if (info->flags & 1)
  return unmapped_area_topdown(info);
 else
  return unmapped_area(info);
}


extern void truncate_inode_pages(struct address_space *, loff_t);
extern void truncate_inode_pages_range(struct address_space *,
           loff_t lstart, loff_t lend);
extern void truncate_inode_pages_final(struct address_space *);


extern vm_fault_t filemap_fault(struct vm_fault *vmf);
extern void filemap_map_pages(struct vm_fault *vmf,
  unsigned long start_pgoff, unsigned long end_pgoff);
extern vm_fault_t filemap_page_mkwrite(struct vm_fault *vmf);


int __attribute__((__warn_unused_result__)) write_one_page(struct page *page);
void task_dirty_inc(struct task_struct *tsk);




int force_page_cache_readahead(struct address_space *mapping, struct file *filp,
   unsigned long offset, unsigned long nr_to_read);

void page_cache_sync_readahead(struct address_space *mapping,
          struct file_ra_state *ra,
          struct file *filp,
          unsigned long offset,
          unsigned long size);

void page_cache_async_readahead(struct address_space *mapping,
    struct file_ra_state *ra,
    struct file *filp,
    struct page *pg,
    unsigned long offset,
    unsigned long size);

extern unsigned long stack_guard_gap;

extern int expand_stack(struct vm_area_struct *vma, unsigned long address);


extern int expand_downwards(struct vm_area_struct *vma,
  unsigned long address);







extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
          struct vm_area_struct **pprev);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
{
 struct vm_area_struct * vma = find_vma(mm,start_addr);

 if (vma && end_addr <= vma->vm_start)
  vma = ((void *)0);
 return vma;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vm_start_gap(struct vm_area_struct *vma)
{
 unsigned long vm_start = vma->vm_start;

 if (vma->vm_flags & 0x00000100) {
  vm_start -= stack_guard_gap;
  if (vm_start > vma->vm_start)
   vm_start = 0;
 }
 return vm_start;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vm_end_gap(struct vm_area_struct *vma)
{
 unsigned long vm_end = vma->vm_end;

 if (vma->vm_flags & 0x00000000) {
  vm_end += stack_guard_gap;
  if (vm_end < vma->vm_end)
   vm_end = -(1UL << 16);
 }
 return vm_end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long vma_pages(struct vm_area_struct *vma)
{
 return (vma->vm_end - vma->vm_start) >> 16;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vm_area_struct *find_exact_vma(struct mm_struct *mm,
    unsigned long vm_start, unsigned long vm_end)
{
 struct vm_area_struct *vma = find_vma(mm, vm_start);

 if (vma && (vma->vm_start != vm_start || vma->vm_end != vm_end))
  vma = ((void *)0);

 return vma;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool range_in_vma(struct vm_area_struct *vma,
    unsigned long start, unsigned long end)
{
 return (vma && vma->vm_start <= start && end <= vma->vm_end);
}


pgprot_t vm_get_page_prot(unsigned long vm_flags);
void vma_set_page_prot(struct vm_area_struct *vma);
# 2514 "/home/nathan/src/linux-next/include/linux/mm.h"
unsigned long change_prot_numa(struct vm_area_struct *vma,
   unsigned long start, unsigned long end);


struct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);
int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
   unsigned long pfn, unsigned long size, pgprot_t);
int vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);
int vm_map_pages(struct vm_area_struct *vma, struct page **pages,
    unsigned long num);
int vm_map_pages_zero(struct vm_area_struct *vma, struct page **pages,
    unsigned long num);
vm_fault_t vmf_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
   unsigned long pfn);
vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,
   unsigned long pfn, pgprot_t pgprot);
vm_fault_t vmf_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
   pfn_t pfn);
vm_fault_t vmf_insert_mixed_prot(struct vm_area_struct *vma, unsigned long addr,
   pfn_t pfn, pgprot_t pgprot);
vm_fault_t vmf_insert_mixed_mkwrite(struct vm_area_struct *vma,
  unsigned long addr, pfn_t pfn);
int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) vm_fault_t vmf_insert_page(struct vm_area_struct *vma,
    unsigned long addr, struct page *page)
{
 int err = vm_insert_page(vma, addr, page);

 if (err == -12)
  return VM_FAULT_OOM;
 if (err < 0 && err != -16)
  return VM_FAULT_SIGBUS;

 return VM_FAULT_NOPAGE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) vm_fault_t vmf_error(int err)
{
 if (err == -12)
  return VM_FAULT_OOM;
 return VM_FAULT_SIGBUS;
}

struct page *follow_page(struct vm_area_struct *vma, unsigned long address,
    unsigned int foll_flags);
# 2638 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vm_fault_to_errno(vm_fault_t vm_fault, int foll_flags)
{
 if (vm_fault & VM_FAULT_OOM)
  return -12;
 if (vm_fault & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))
  return (foll_flags & 0x100) ? -133 : -14;
 if (vm_fault & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))
  return -14;
 return 0;
}

typedef int (*pte_fn_t)(pte_t *pte, unsigned long addr, void *data);
extern int apply_to_page_range(struct mm_struct *mm, unsigned long address,
          unsigned long size, pte_fn_t fn, void *data);
extern int apply_to_existing_page_range(struct mm_struct *mm,
       unsigned long address, unsigned long size,
       pte_fn_t fn, void *data);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool page_poisoning_enabled(void) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kernel_poison_pages(struct page *page, int numpages,
     int enable) { }





extern struct static_key_false init_on_alloc;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool want_init_on_alloc(gfp_t flags)
{
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&init_on_alloc), struct static_key_true)) branch = arch_static_branch_jump(&(&init_on_alloc)->key, false); else if (__builtin_types_compatible_p(typeof(*&init_on_alloc), struct static_key_false)) branch = arch_static_branch(&(&init_on_alloc)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) &&
     !page_poisoning_enabled())
  return true;
 return flags & (( gfp_t)0x100u);
}




extern struct static_key_false init_on_free;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool want_init_on_free(void)
{
 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&init_on_free), struct static_key_true)) branch = arch_static_branch_jump(&(&init_on_free)->key, false); else if (__builtin_types_compatible_p(typeof(*&init_on_free), struct static_key_false)) branch = arch_static_branch(&(&init_on_free)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) &&
        !page_poisoning_enabled();
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_debug_pagealloc(void) {}

extern bool _debug_pagealloc_enabled_early;
extern struct static_key_false _debug_pagealloc_enabled;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool debug_pagealloc_enabled(void)
{
 return 0 &&
  _debug_pagealloc_enabled_early;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool debug_pagealloc_enabled_static(void)
{
 if (!0)
  return false;

 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&_debug_pagealloc_enabled), struct static_key_true)) branch = arch_static_branch_jump(&(&_debug_pagealloc_enabled)->key, false); else if (__builtin_types_compatible_p(typeof(*&_debug_pagealloc_enabled), struct static_key_false)) branch = arch_static_branch(&(&_debug_pagealloc_enabled)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); });
}
# 2727 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
kernel_map_pages(struct page *page, int numpages, int enable) {}
# 2739 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vm_area_struct *get_gate_vma(struct mm_struct *mm)
{
 return ((void *)0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int in_gate_area_no_mm(unsigned long addr) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int in_gate_area(struct mm_struct *mm, unsigned long addr)
{
 return 0;
}


extern bool process_shares_mm(struct task_struct *p, struct mm_struct *mm);


extern int sysctl_drop_caches;
int drop_caches_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);


void drop_slab(void);
void drop_slab_node(int nid);




extern int randomize_va_space;


const char * arch_vma_name(struct vm_area_struct *vma);

void print_vma_addr(char *prefix, unsigned long rip);






void *sparse_buffer_alloc(unsigned long size);
struct page * __populate_section_memmap(unsigned long pfn,
  unsigned long nr_pages, int nid, struct vmem_altmap *altmap);
pgd_t *vmemmap_pgd_populate(unsigned long addr, int node);
pgd_t *vmemmap_p4d_populate(pgd_t *pgd, unsigned long addr, int node);
pud_t *vmemmap_pud_populate(pgd_t *p4d, unsigned long addr, int node);
pmd_t *vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node);
pte_t *vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node);
void *vmemmap_alloc_block(unsigned long size, int node);
struct vmem_altmap;
void *vmemmap_alloc_block_buf(unsigned long size, int node);
void *altmap_alloc_block_buf(unsigned long size, struct vmem_altmap *altmap);
void vmemmap_verify(pte_t *, int, unsigned long, unsigned long);
int vmemmap_populate_basepages(unsigned long start, unsigned long end,
          int node);
int vmemmap_populate(unsigned long start, unsigned long end, int node,
  struct vmem_altmap *altmap);
void vmemmap_populate_print_last(void);

void vmemmap_free(unsigned long start, unsigned long end,
  struct vmem_altmap *altmap);

void register_page_bootmem_memmap(unsigned long section_nr, struct page *map,
      unsigned long nr_pages);

enum mf_flags {
 MF_COUNT_INCREASED = 1 << 0,
 MF_ACTION_REQUIRED = 1 << 1,
 MF_MUST_KILL = 1 << 2,
 MF_SOFT_OFFLINE = 1 << 3,
};
extern int memory_failure(unsigned long pfn, int flags);
extern void memory_failure_queue(unsigned long pfn, int flags);
extern int unpoison_memory(unsigned long pfn);
extern int get_hwpoison_page(struct page *page);

extern int sysctl_memory_failure_early_kill;
extern int sysctl_memory_failure_recovery;
extern void shake_page(struct page *p, int access);
extern atomic_long_t num_poisoned_pages __attribute__((__section__(".data..read_mostly")));
extern int soft_offline_page(unsigned long pfn, int flags);





enum mf_result {
 MF_IGNORED,
 MF_FAILED,
 MF_DELAYED,
 MF_RECOVERED,
};

enum mf_action_page_type {
 MF_MSG_KERNEL,
 MF_MSG_KERNEL_HIGH_ORDER,
 MF_MSG_SLAB,
 MF_MSG_DIFFERENT_COMPOUND,
 MF_MSG_POISONED_HUGE,
 MF_MSG_HUGE,
 MF_MSG_FREE_HUGE,
 MF_MSG_NON_PMD_HUGE,
 MF_MSG_UNMAP_FAILED,
 MF_MSG_DIRTY_SWAPCACHE,
 MF_MSG_CLEAN_SWAPCACHE,
 MF_MSG_DIRTY_MLOCKED_LRU,
 MF_MSG_CLEAN_MLOCKED_LRU,
 MF_MSG_DIRTY_UNEVICTABLE_LRU,
 MF_MSG_CLEAN_UNEVICTABLE_LRU,
 MF_MSG_DIRTY_LRU,
 MF_MSG_CLEAN_LRU,
 MF_MSG_TRUNCATED_LRU,
 MF_MSG_BUDDY,
 MF_MSG_BUDDY_2ND,
 MF_MSG_DAX,
 MF_MSG_UNKNOWN,
};


extern void clear_huge_page(struct page *page,
       unsigned long addr_hint,
       unsigned int pages_per_huge_page);
extern void copy_user_huge_page(struct page *dst, struct page *src,
    unsigned long addr_hint,
    struct vm_area_struct *vma,
    unsigned int pages_per_huge_page);
extern long copy_huge_page_from_user(struct page *dst_page,
    const void *usr_src,
    unsigned int pages_per_huge_page,
    bool allow_pagefault);
# 2890 "/home/nathan/src/linux-next/include/linux/mm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int debug_guardpage_minorder(void) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool debug_guardpage_enabled(void) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool page_is_guard(struct page *page) { return false; }



void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) setup_nr_node_ids(void);




extern int memcmp_pages(struct page *page1, struct page *page2);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pages_identical(struct page *page1, struct page *page2)
{
 return !memcmp_pages(page1, page2);
}
# 30 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/delay.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/processor.h" 1
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/delay.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/time.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/time.h"
extern unsigned long tb_ticks_per_jiffy;
extern unsigned long tb_ticks_per_usec;
extern unsigned long tb_ticks_per_sec;
extern struct clock_event_device decrementer_clockevent;


extern void generic_calibrate_decr(void);
extern void hdec_interrupt(struct pt_regs *regs);


extern unsigned long ppc_proc_freq;

extern unsigned long ppc_tb_freq;


extern bool tb_invalid;

struct div_result {
 u64 result_high;
 u64 result_low;
};
# 76 "/home/nathan/src/linux-next/arch/powerpc/include/asm/time.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int get_rtcl(void)
{
 unsigned int rtcl;

 asm volatile("mfrtcl %0" : "=r" (rtcl));
 return rtcl;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_rtc(void)
{
 unsigned int hi, lo, hi2;

 do {
  asm volatile("mfrtcu %0; mfrtcl %1; mfrtcu %2"
        : "=r" (hi), "=r" (lo), "=r" (hi2));
 } while (hi2 != hi);
 return (u64)hi * 1000000000 + lo;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_vtb(void)
{

 if (cpu_has_feature(0x0000000000010000UL))
  return ({unsigned long rval; asm volatile("mfspr %0," "0x351" : "=r" (rval)); rval;});

 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_tb(void)
{
 return ({unsigned long rval; asm volatile( "90:	mfspr %0, %2;\n" "971:" " " "97:	cmpwi %0,0;\n" "	beq- 90b;\n" "; " "972: .pushsection __ftr_alt_97,\"a\"; .align 2; 973:" " " "" "; " "974: .popsection; .pushsection __ftr_fixup,\"a\"; .align 3; 975: .8byte ((%1)); .8byte ((%1)); .8byte 971b-975b; .8byte 972b-975b; .8byte 973b-975b; .8byte 974b-975b; .ifgt (974b- 973b)-(972b- 971b); .error \"Feature section else case larger than body\"; .endif; .popsection;" " " : "=r" (rval) : "i" (0x0000000000800000UL), "i" (0x10C) : "cr0"); rval;});
}
# 124 "/home/nathan/src/linux-next/arch/powerpc/include/asm/time.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_tb_or_rtc(void)
{
 return (0) ? get_rtc() : get_tb();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_tb(unsigned int upper, unsigned int lower)
{
 asm volatile("mtspr " "0x11C" ",%0" : : "r" ((unsigned long)(0)) : "memory");
 asm volatile("mtspr " "0x11D" ",%0" : : "r" ((unsigned long)(upper)) : "memory");
 asm volatile("mtspr " "0x11C" ",%0" : : "r" ((unsigned long)(lower)) : "memory");
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 get_dec(void)
{



 return (({unsigned long rval; asm volatile("mfspr %0," "0x016" : "=r" (rval)); rval;}));

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_dec(u64 val)
{




 --val;

 asm volatile("mtspr " "0x016" ",%0" : : "r" ((unsigned long)(val)) : "memory");

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long tb_ticks_since(unsigned long tstamp)
{
 if ((0)) {
  int delta = get_rtcl() - (unsigned int) tstamp;
  return delta < 0 ? delta + 1000000000 : delta;
 }
 return get_tb() - tstamp;
}
# 187 "/home/nathan/src/linux-next/arch/powerpc/include/asm/time.h"
extern void div128_by_32(u64 dividend_high, u64 dividend_low,
    unsigned divisor, struct div_result *dr);

extern void secondary_cpu_time_init(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) time_init(void);

extern __attribute__((section(".data..percpu" ""))) __typeof__(u64) decrementers_next_tb;


unsigned long long tb_to_ns(unsigned long long tb_ticks);
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/delay.h" 2
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/delay.h"
extern void __delay(unsigned long loops);
extern void udelay(unsigned long usecs);
# 34 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/ppc_asm.h" 1
# 37 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2
# 62 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern unsigned long isa_io_base;
extern unsigned long pci_io_base;
extern unsigned long pci_dram_offset;

extern resource_size_t isa_mem_base;







extern bool isa_io_special;
# 138 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 in_8(const volatile u8 *addr) { u8 ret; __asm__ __volatile__("sync;""lbz""%U1%X1 %0,%1;twi 0,%0,0;isync" : "=r" (ret) : "m" (*addr) : "memory"); return ret; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_8(volatile u8 *addr, u8 val) { __asm__ __volatile__("sync;""stb""%U0%X0 %1,%0" : "=m" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 in_be16(const volatile u16 *addr) { u16 ret; __asm__ __volatile__("sync;""lhz""%U1%X1 %0,%1;twi 0,%0,0;isync" : "=r" (ret) : "m" (*addr) : "memory"); return ret; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 in_be32(const volatile u32 *addr) { u32 ret; __asm__ __volatile__("sync;""lwz""%U1%X1 %0,%1;twi 0,%0,0;isync" : "=r" (ret) : "m" (*addr) : "memory"); return ret; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 in_le16(const volatile u16 *addr) { u16 ret; __asm__ __volatile__("sync;""lhbrx"" %0,%y1;twi 0,%0,0;isync" : "=r" (ret) : "Z" (*addr) : "memory"); return ret; };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 in_le32(const volatile u32 *addr) { u32 ret; __asm__ __volatile__("sync;""lwbrx"" %0,%y1;twi 0,%0,0;isync" : "=r" (ret) : "Z" (*addr) : "memory"); return ret; };

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_be16(volatile u16 *addr, u16 val) { __asm__ __volatile__("sync;""sth""%U0%X0 %1,%0" : "=m" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_be32(volatile u32 *addr, u32 val) { __asm__ __volatile__("sync;""stw""%U0%X0 %1,%0" : "=m" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_le16(volatile u16 *addr, u16 val) { __asm__ __volatile__("sync;""sthbrx"" %1,%y0" : "=Z" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_le32(volatile u32 *addr, u32 val) { __asm__ __volatile__("sync;""stwbrx"" %1,%y0" : "=Z" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };
# 167 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_be64(volatile u64 *addr, u64 val) { __asm__ __volatile__("sync;""std""%U0%X0 %1,%0" : "=m" (*addr) : "r" (val) : "memory"); mmiowb_set_pending(); };
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 in_be64(const volatile u64 *addr) { u64 ret; __asm__ __volatile__("sync;""ld""%U1%X1 %0,%1;twi 0,%0,0;isync" : "=r" (ret) : "m" (*addr) : "memory"); return ret; };


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 in_le64(const volatile u64 *addr)
{
 return (__builtin_constant_p((__u64)(in_be64(addr))) ? ((__u64)( (((__u64)(in_be64(addr)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(in_be64(addr)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(in_be64(addr)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(in_be64(addr)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(in_be64(addr)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(in_be64(addr)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(in_be64(addr)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(in_be64(addr)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(in_be64(addr)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void out_le64(volatile u64 *addr, u64 val)
{
 out_be64(addr, (__builtin_constant_p((__u64)(val)) ? ((__u64)( (((__u64)(val) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(val) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(val) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(val) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(val) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(val) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(val) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(val) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(val)));
}
# 201 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern void _insb(const volatile u8 *addr, void *buf, long count);
extern void _outsb(volatile u8 *addr,const void *buf,long count);
extern void _insw_ns(const volatile u16 *addr, void *buf, long count);
extern void _outsw_ns(volatile u16 *addr, const void *buf, long count);
extern void _insl_ns(const volatile u32 *addr, void *buf, long count);
extern void _outsl_ns(volatile u32 *addr, const void *buf, long count);
# 221 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern void _memset_io(volatile void *addr, int c, unsigned long n);
extern void _memcpy_fromio(void *dest, const volatile void *src,
      unsigned long n);
extern void _memcpy_toio(volatile void *dest, const void *src,
    unsigned long n);
# 246 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h" 1
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/eeh.h" 1
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h" 2

struct pci_dev;
struct pci_bus;
struct pci_dn;
# 74 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
struct eeh_pe {
 int type;
 int state;
 int config_addr;
 int addr;
 struct pci_controller *phb;
 struct pci_bus *bus;
 int check_count;
 int freeze_count;
 time64_t tstamp;
 int false_positives;
 atomic_t pass_dev_cnt;
 struct eeh_pe *parent;
 void *data;
 struct list_head child_list;
 struct list_head child;
 struct list_head edevs;
# 101 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
 unsigned long stack_trace[64];
 int trace_entries;

};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eeh_pe_passed(struct eeh_pe *pe)
{
 return pe ? !!atomic_read(&pe->pass_dev_cnt) : false;
}
# 134 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
struct eeh_dev {
 int mode;
 int class_code;
 int bdfn;
 struct pci_controller *controller;
 int pe_config_addr;
 u32 config_space[16];
 int pcix_cap;
 int pcie_cap;
 int aer_cap;
 int af_cap;
 struct eeh_pe *pe;
 struct list_head entry;
 struct list_head rmv_entry;
 struct pci_dn *pdn;
 struct pci_dev *pdev;
 bool in_error;
 struct pci_dev *physfn;
};
# 165 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_dn *eeh_dev_to_pdn(struct eeh_dev *edev)
{
 return edev ? edev->pdn : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_dev *eeh_dev_to_pci_dev(struct eeh_dev *edev)
{
 return edev ? edev->pdev : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct eeh_pe *eeh_dev_to_pe(struct eeh_dev* edev)
{
 return edev ? edev->pe : ((void *)0);
}


enum {
 EEH_NEXT_ERR_NONE = 0,
 EEH_NEXT_ERR_INF,
 EEH_NEXT_ERR_FROZEN_PE,
 EEH_NEXT_ERR_FENCED_PHB,
 EEH_NEXT_ERR_DEAD_PHB,
 EEH_NEXT_ERR_DEAD_IOC
};
# 215 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
struct eeh_ops {
 char *name;
 int (*init)(void);
 void* (*probe)(struct pci_dn *pdn, void *data);
 int (*set_option)(struct eeh_pe *pe, int option);
 int (*get_pe_addr)(struct eeh_pe *pe);
 int (*get_state)(struct eeh_pe *pe, int *delay);
 int (*reset)(struct eeh_pe *pe, int option);
 int (*get_log)(struct eeh_pe *pe, int severity, char *drv_log, unsigned long len);
 int (*configure_bridge)(struct eeh_pe *pe);
 int (*err_inject)(struct eeh_pe *pe, int type, int func,
     unsigned long addr, unsigned long mask);
 int (*read_config)(struct pci_dn *pdn, int where, int size, u32 *val);
 int (*write_config)(struct pci_dn *pdn, int where, int size, u32 val);
 int (*next_error)(struct eeh_pe **pe);
 int (*restore_config)(struct pci_dn *pdn);
 int (*notify_resume)(struct pci_dn *pdn);
};

extern int eeh_subsystem_flags;
extern u32 eeh_max_freezes;
extern bool eeh_debugfs_no_recover;
extern struct eeh_ops *eeh_ops;
extern raw_spinlock_t confirm_error_lock;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_add_flag(int flag)
{
 eeh_subsystem_flags |= flag;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_clear_flag(int flag)
{
 eeh_subsystem_flags &= ~flag;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eeh_has_flag(int flag)
{
        return !!(eeh_subsystem_flags & flag);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eeh_enabled(void)
{
 return eeh_has_flag(0x01) && !eeh_has_flag(0x02);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_serialize_lock(unsigned long *flags)
{
 do { ({ unsigned long __dummy; typeof(*flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); *flags = _raw_spin_lock_irqsave(&confirm_error_lock); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_serialize_unlock(unsigned long flags)
{
 do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); _raw_spin_unlock_irqrestore(&confirm_error_lock, flags); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eeh_state_active(int state)
{
 return (state & ((1 << 3) | (1 << 4)))
 == ((1 << 3) | (1 << 4));
}

typedef void (*eeh_edev_traverse_func)(struct eeh_dev *edev, void *flag);
typedef void *(*eeh_pe_traverse_func)(struct eeh_pe *pe, void *flag);
void eeh_set_pe_aux_size(int size);
int eeh_phb_pe_create(struct pci_controller *phb);
int eeh_wait_state(struct eeh_pe *pe, int max_wait);
struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb);
struct eeh_pe *eeh_pe_next(struct eeh_pe *pe, struct eeh_pe *root);
struct eeh_pe *eeh_pe_get(struct pci_controller *phb,
     int pe_no, int config_addr);
int eeh_add_to_parent_pe(struct eeh_dev *edev);
int eeh_rmv_from_parent_pe(struct eeh_dev *edev);
void eeh_pe_update_time_stamp(struct eeh_pe *pe);
void *eeh_pe_traverse(struct eeh_pe *root,
        eeh_pe_traverse_func fn, void *flag);
void eeh_pe_dev_traverse(struct eeh_pe *root,
    eeh_edev_traverse_func fn, void *flag);
void eeh_pe_restore_bars(struct eeh_pe *pe);
const char *eeh_pe_loc_get(struct eeh_pe *pe);
struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe);

struct eeh_dev *eeh_dev_init(struct pci_dn *pdn);
void eeh_dev_phb_init_dynamic(struct pci_controller *phb);
void eeh_show_enabled(void);
int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) eeh_ops_register(struct eeh_ops *ops);
int __attribute__((__section__(".exit.text"))) __attribute__((__cold__)) __attribute__((__no_instrument_function__)) eeh_ops_unregister(const char *name);
int eeh_check_failure(const volatile void *token);
int eeh_dev_check_failure(struct eeh_dev *edev);
void eeh_addr_cache_init(void);
void eeh_add_device_early(struct pci_dn *);
void eeh_add_device_tree_early(struct pci_dn *);
void eeh_add_device_late(struct pci_dev *);
void eeh_add_device_tree_late(struct pci_bus *);
void eeh_add_sysfs_files(struct pci_bus *);
void eeh_remove_device(struct pci_dev *);
int eeh_unfreeze_pe(struct eeh_pe *pe);
int eeh_pe_reset_and_recover(struct eeh_pe *pe);
int eeh_dev_open(struct pci_dev *pdev);
void eeh_dev_release(struct pci_dev *pdev);
struct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group);
int eeh_pe_set_option(struct eeh_pe *pe, int option);
int eeh_pe_get_state(struct eeh_pe *pe);
int eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed);
int eeh_pe_configure(struct eeh_pe *pe);
int eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,
        unsigned long addr, unsigned long mask);
int eeh_restore_vf_config(struct pci_dn *pdn);
# 383 "/home/nathan/src/linux-next/arch/powerpc/include/asm/eeh.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 eeh_readb(const volatile void *addr)
{
 u8 val = in_8(addr);
 if (((val) == (u8)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 eeh_readw(const volatile void *addr)
{
 u16 val = in_le16(addr);
 if (((val) == (u16)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 eeh_readl(const volatile void *addr)
{
 u32 val = in_le32(addr);
 if (((val) == (u32)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 eeh_readq(const volatile void *addr)
{
 u64 val = in_le64(addr);
 if (((val) == (u64)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 eeh_readw_be(const volatile void *addr)
{
 u16 val = in_be16(addr);
 if (((val) == (u16)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 eeh_readl_be(const volatile void *addr)
{
 u32 val = in_be32(addr);
 if (((val) == (u32)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 eeh_readq_be(const volatile void *addr)
{
 u64 val = in_be64(addr);
 if (((val) == (u64)~0 && eeh_enabled()))
  eeh_check_failure(addr);
 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_memcpy_fromio(void *dest, const
         volatile void *src,
         unsigned long n)
{
 _memcpy_fromio(dest, src, n);




 if (n >= 4 && ((*((u32 *)(dest + n - 4))) == (u32)~0 && eeh_enabled()))
  eeh_check_failure(src);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_readsb(const volatile void *addr, void * buf,
         int ns)
{
 _insb(addr, buf, ns);
 if ((((*(((u8*)buf)+ns-1))) == (u8)~0 && eeh_enabled()))
  eeh_check_failure(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_readsw(const volatile void *addr, void * buf,
         int ns)
{
 _insw_ns(addr, buf, ns);
 if ((((*(((u16*)buf)+ns-1))) == (u16)~0 && eeh_enabled()))
  eeh_check_failure(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eeh_readsl(const volatile void *addr, void * buf,
         int nl)
{
 _insl_ns(addr, buf, nl);
 if ((((*(((u32*)buf)+nl-1))) == (u32)~0 && eeh_enabled()))
  eeh_check_failure(addr);
}


void eeh_cache_debugfs_init(void);
# 247 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2
# 302 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char __raw_readb(const volatile void *addr)
{
 return *(volatile unsigned char *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short __raw_readw(const volatile void *addr)
{
 return *(volatile unsigned short *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __raw_readl(const volatile void *addr)
{
 return *(volatile unsigned int *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_writeb(unsigned char v, volatile void *addr)
{
 *(volatile unsigned char *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))) = v;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_writew(unsigned short v, volatile void *addr)
{
 *(volatile unsigned short *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))) = v;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_writel(unsigned int v, volatile void *addr)
{
 *(volatile unsigned int *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))) = v;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __raw_readq(const volatile void *addr)
{
 return *(volatile unsigned long *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)));
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_writeq(unsigned long v, volatile void *addr)
{
 *(volatile unsigned long *)((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))) = v;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_writeq_be(unsigned long v, volatile void *addr)
{
 __raw_writeq(( unsigned long)(( __be64)(__u64)(v)), addr);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_rm_writeb(u8 val, volatile void *paddr)
{
 __asm__ __volatile__("stbcix %0,0,%1"
  : : "r" (val), "r" (paddr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_rm_writew(u16 val, volatile void *paddr)
{
 __asm__ __volatile__("sthcix %0,0,%1"
  : : "r" (val), "r" (paddr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_rm_writel(u32 val, volatile void *paddr)
{
 __asm__ __volatile__("stwcix %0,0,%1"
  : : "r" (val), "r" (paddr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_rm_writeq(u64 val, volatile void *paddr)
{
 __asm__ __volatile__("stdcix %0,0,%1"
  : : "r" (val), "r" (paddr) : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __raw_rm_writeq_be(u64 val, volatile void *paddr)
{
 __raw_rm_writeq(( u64)(( __be64)(__u64)(val)), paddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 __raw_rm_readb(volatile void *paddr)
{
 u8 ret;
 __asm__ __volatile__("lbzcix %0,0, %1"
        : "=r" (ret) : "r" (paddr) : "memory");
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 __raw_rm_readw(volatile void *paddr)
{
 u16 ret;
 __asm__ __volatile__("lhzcix %0,0, %1"
        : "=r" (ret) : "r" (paddr) : "memory");
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __raw_rm_readl(volatile void *paddr)
{
 u32 ret;
 __asm__ __volatile__("lwzcix %0,0, %1"
        : "=r" (ret) : "r" (paddr) : "memory");
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 __raw_rm_readq(volatile void *paddr)
{
 u64 ret;
 __asm__ __volatile__("ldcix %0,0, %1"
        : "=r" (ret) : "r" (paddr) : "memory");
 return ret;
}
# 575 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern struct ppc_pci_io {





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io-defs.h" 1




u8 (*readb) (const volatile void * addr);
u16 (*readw) (const volatile void * addr);
u32 (*readl) (const volatile void * addr);
u16 (*readw_be) (const volatile void * addr);
u32 (*readl_be) (const volatile void * addr);
void (*writeb) (u8 val, volatile void * addr);
void (*writew) (u16 val, volatile void * addr);
void (*writel) (u32 val, volatile void * addr);
void (*writew_be) (u16 val, volatile void * addr);
void (*writel_be) (u32 val, volatile void * addr);


u64 (*readq) (const volatile void * addr);
u64 (*readq_be) (const volatile void * addr);
void (*writeq) (u64 val, volatile void * addr);
void (*writeq_be) (u64 val, volatile void * addr);


u8 (*inb) (unsigned long port);
u16 (*inw) (unsigned long port);
u32 (*inl) (unsigned long port);
void (*outb) (u8 val, unsigned long port);
void (*outw) (u16 val, unsigned long port);
void (*outl) (u32 val, unsigned long port);

void (*readsb) (const volatile void * a, void *b, unsigned long c);

void (*readsw) (const volatile void * a, void *b, unsigned long c);

void (*readsl) (const volatile void * a, void *b, unsigned long c);

void (*writesb) (volatile void * a, const void *b, unsigned long c);

void (*writesw) (volatile void * a, const void *b, unsigned long c);

void (*writesl) (volatile void * a, const void *b, unsigned long c);


void (*insb) (unsigned long p, void *b, unsigned long c);

void (*insw) (unsigned long p, void *b, unsigned long c);

void (*insl) (unsigned long p, void *b, unsigned long c);

void (*outsb) (unsigned long p, const void *b, unsigned long c);

void (*outsw) (unsigned long p, const void *b, unsigned long c);

void (*outsl) (unsigned long p, const void *b, unsigned long c);


void (*memset_io) (volatile void * a, int c, unsigned long n);

void (*memcpy_fromio) (void *d, const volatile void * s, unsigned long n);

void (*memcpy_toio) (volatile void * d, const void *s, unsigned long n);
# 581 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2




} ppc_pci_io;
# 605 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io-defs.h" 1




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 readb (const volatile void * addr) { if (ppc_pci_io.readb != ((void *)0)) return ppc_pci_io.readb (addr); return eeh_readb(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 readw (const volatile void * addr) { if (ppc_pci_io.readw != ((void *)0)) return ppc_pci_io.readw (addr); return eeh_readw(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 readl (const volatile void * addr) { if (ppc_pci_io.readl != ((void *)0)) return ppc_pci_io.readl (addr); return eeh_readl(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 readw_be (const volatile void * addr) { if (ppc_pci_io.readw_be != ((void *)0)) return ppc_pci_io.readw_be (addr); return eeh_readw_be(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 readl_be (const volatile void * addr) { if (ppc_pci_io.readl_be != ((void *)0)) return ppc_pci_io.readl_be (addr); return eeh_readl_be(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writeb (u8 val, volatile void * addr) { if (ppc_pci_io.writeb != ((void *)0)) ppc_pci_io.writeb (val, addr); else out_8(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writew (u16 val, volatile void * addr) { if (ppc_pci_io.writew != ((void *)0)) ppc_pci_io.writew (val, addr); else out_le16(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writel (u32 val, volatile void * addr) { if (ppc_pci_io.writel != ((void *)0)) ppc_pci_io.writel (val, addr); else out_le32(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writew_be (u16 val, volatile void * addr) { if (ppc_pci_io.writew_be != ((void *)0)) ppc_pci_io.writew_be (val, addr); else out_be16(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writel_be (u32 val, volatile void * addr) { if (ppc_pci_io.writel_be != ((void *)0)) ppc_pci_io.writel_be (val, addr); else out_be32(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 readq (const volatile void * addr) { if (ppc_pci_io.readq != ((void *)0)) return ppc_pci_io.readq (addr); return eeh_readq(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 readq_be (const volatile void * addr) { if (ppc_pci_io.readq_be != ((void *)0)) return ppc_pci_io.readq_be (addr); return eeh_readq_be(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52)))); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writeq (u64 val, volatile void * addr) { if (ppc_pci_io.writeq != ((void *)0)) ppc_pci_io.writeq (val, addr); else out_le64(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writeq_be (u64 val, volatile void * addr) { if (ppc_pci_io.writeq_be != ((void *)0)) ppc_pci_io.writeq_be (val, addr); else out_be64(((volatile void *)(((unsigned long)(addr)) & ~(0xfful << 52))), val); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 inb (unsigned long port) { if (ppc_pci_io.inb != ((void *)0)) return ppc_pci_io.inb (port); return readb((volatile void *)pci_io_base + port);; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 inw (unsigned long port) { if (ppc_pci_io.inw != ((void *)0)) return ppc_pci_io.inw (port); return readw((volatile void *)pci_io_base + port);; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 inl (unsigned long port) { if (ppc_pci_io.inl != ((void *)0)) return ppc_pci_io.inl (port); return readl((volatile void *)pci_io_base + port);; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outb (u8 val, unsigned long port) { if (ppc_pci_io.outb != ((void *)0)) ppc_pci_io.outb (val, port); else writeb(val,(volatile void *)pci_io_base+port);; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outw (u16 val, unsigned long port) { if (ppc_pci_io.outw != ((void *)0)) ppc_pci_io.outw (val, port); else writew(val,(volatile void *)pci_io_base+port);; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outl (u32 val, unsigned long port) { if (ppc_pci_io.outl != ((void *)0)) ppc_pci_io.outl (val, port); else writel(val,(volatile void *)pci_io_base+port);; }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void readsb (const volatile void * a, void *b, unsigned long c) { if (ppc_pci_io.readsb != ((void *)0)) ppc_pci_io.readsb (a, b, c); else eeh_readsb(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void readsw (const volatile void * a, void *b, unsigned long c) { if (ppc_pci_io.readsw != ((void *)0)) ppc_pci_io.readsw (a, b, c); else eeh_readsw(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void readsl (const volatile void * a, void *b, unsigned long c) { if (ppc_pci_io.readsl != ((void *)0)) ppc_pci_io.readsl (a, b, c); else eeh_readsl(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writesb (volatile void * a, const void *b, unsigned long c) { if (ppc_pci_io.writesb != ((void *)0)) ppc_pci_io.writesb (a, b, c); else _outsb(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))),(b),(c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writesw (volatile void * a, const void *b, unsigned long c) { if (ppc_pci_io.writesw != ((void *)0)) ppc_pci_io.writesw (a, b, c); else _outsw_ns(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))),(b),(c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void writesl (volatile void * a, const void *b, unsigned long c) { if (ppc_pci_io.writesl != ((void *)0)) ppc_pci_io.writesl (a, b, c); else _outsl_ns(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))),(b),(c)); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void insb (unsigned long p, void *b, unsigned long c) { if (ppc_pci_io.insb != ((void *)0)) ppc_pci_io.insb (p, b, c); else readsb((volatile void *)pci_io_base+(p), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void insw (unsigned long p, void *b, unsigned long c) { if (ppc_pci_io.insw != ((void *)0)) ppc_pci_io.insw (p, b, c); else readsw((volatile void *)pci_io_base+(p), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void insl (unsigned long p, void *b, unsigned long c) { if (ppc_pci_io.insl != ((void *)0)) ppc_pci_io.insl (p, b, c); else readsl((volatile void *)pci_io_base+(p), (b), (c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outsb (unsigned long p, const void *b, unsigned long c) { if (ppc_pci_io.outsb != ((void *)0)) ppc_pci_io.outsb (p, b, c); else writesb((volatile void *)pci_io_base+(p),(b),(c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outsw (unsigned long p, const void *b, unsigned long c) { if (ppc_pci_io.outsw != ((void *)0)) ppc_pci_io.outsw (p, b, c); else writesw((volatile void *)pci_io_base+(p),(b),(c)); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void outsl (unsigned long p, const void *b, unsigned long c) { if (ppc_pci_io.outsl != ((void *)0)) ppc_pci_io.outsl (p, b, c); else writesl((volatile void *)pci_io_base+(p),(b),(c)); }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memset_io (volatile void * a, int c, unsigned long n) { if (ppc_pci_io.memset_io != ((void *)0)) ppc_pci_io.memset_io (a, c, n); else _memset_io(((volatile void *)(((unsigned long)(a)) & ~(0xfful << 52))), c, n); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcpy_fromio (void *d, const volatile void * s, unsigned long n) { if (ppc_pci_io.memcpy_fromio != ((void *)0)) ppc_pci_io.memcpy_fromio (d, s, n); else eeh_memcpy_fromio(d, ((volatile void *)(((unsigned long)(s)) & ~(0xfful << 52))), n); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcpy_toio (volatile void * d, const void *s, unsigned long n) { if (ppc_pci_io.memcpy_toio != ((void *)0)) ppc_pci_io.memcpy_toio (d, s, n); else _memcpy_toio(((volatile void *)(((unsigned long)(d)) & ~(0xfful << 52))), s, n); }
# 606 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2
# 641 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/iomap.h" 1
# 29 "/home/nathan/src/linux-next/include/asm-generic/iomap.h"
extern unsigned int ioread8(void *);
extern unsigned int ioread16(void *);
extern unsigned int ioread16be(void *);
extern unsigned int ioread32(void *);
extern unsigned int ioread32be(void *);

extern u64 ioread64(void *);
extern u64 ioread64be(void *);







extern u64 ioread64_lo_hi(void *addr);
extern u64 ioread64_hi_lo(void *addr);
extern u64 ioread64be_lo_hi(void *addr);
extern u64 ioread64be_hi_lo(void *addr);


extern void iowrite8(u8, void *);
extern void iowrite16(u16, void *);
extern void iowrite16be(u16, void *);
extern void iowrite32(u32, void *);
extern void iowrite32be(u32, void *);

extern void iowrite64(u64, void *);
extern void iowrite64be(u64, void *);







extern void iowrite64_lo_hi(u64 val, void *addr);
extern void iowrite64_hi_lo(u64 val, void *addr);
extern void iowrite64be_lo_hi(u64 val, void *addr);
extern void iowrite64be_hi_lo(u64 val, void *addr);
# 82 "/home/nathan/src/linux-next/include/asm-generic/iomap.h"
extern void ioread8_rep(void *port, void *buf, unsigned long count);
extern void ioread16_rep(void *port, void *buf, unsigned long count);
extern void ioread32_rep(void *port, void *buf, unsigned long count);

extern void iowrite8_rep(void *port, const void *buf, unsigned long count);
extern void iowrite16_rep(void *port, const void *buf, unsigned long count);
extern void iowrite32_rep(void *port, const void *buf, unsigned long count);



extern void *ioport_map(unsigned long port, unsigned int nr);
extern void ioport_unmap(void *);
# 106 "/home/nathan/src/linux-next/include/asm-generic/iomap.h"
struct pci_dev;
extern void pci_iounmap(struct pci_dev *dev, void *);







# 1 "/home/nathan/src/linux-next/include/asm-generic/pci_iomap.h" 1
# 10 "/home/nathan/src/linux-next/include/asm-generic/pci_iomap.h"
struct pci_dev;


extern void *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
extern void *pci_iomap_wc(struct pci_dev *dev, int bar, unsigned long max);
extern void *pci_iomap_range(struct pci_dev *dev, int bar,
         unsigned long offset,
         unsigned long maxlen);
extern void *pci_iomap_wc_range(struct pci_dev *dev, int bar,
     unsigned long offset,
     unsigned long maxlen);
# 115 "/home/nathan/src/linux-next/include/asm-generic/iomap.h" 2
# 642 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iosync(void)
{
        __asm__ __volatile__ ("sync" : : : "memory");
}
# 710 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
extern void *ioremap(phys_addr_t address, unsigned long size);
extern void *ioremap_prot(phys_addr_t address, unsigned long size,
      unsigned long flags);
extern void *ioremap_wc(phys_addr_t address, unsigned long size);
void *ioremap(phys_addr_t address, unsigned long size);
void *ioremap_coherent(phys_addr_t address, unsigned long size);




extern void iounmap(volatile void *addr);

int early_ioremap_range(unsigned long ea, phys_addr_t pa,
   unsigned long size, pgprot_t prot);
void *do_ioremap(phys_addr_t pa, phys_addr_t offset, unsigned long size,
    pgprot_t prot, void *caller);

extern void *__ioremap_caller(phys_addr_t, unsigned long size,
          pgprot_t prot, void *caller);

extern void * __ioremap_at(phys_addr_t pa, void *ea,
       unsigned long size, pgprot_t prot);
extern void __iounmap_at(void *ea, unsigned long size);
# 770 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long virt_to_phys(volatile void * address)
{
 ({ int __ret_warn_on = !!(0 && !pfn_valid((({ do { } while (0); (unsigned long)(address) & 0x0fffffffffffffffUL; }) >> 16))); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/io.h"), "i" (772), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/io.h"), "i" (772), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });

 return ({ do { } while (0); (unsigned long)((unsigned long)address) & 0x0fffffffffffffffUL; });
}
# 789 "/home/nathan/src/linux-next/arch/powerpc/include/asm/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * phys_to_virt(unsigned long address)
{
 return (void *)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(address) | 0xc000000000000000UL); });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) phys_addr_t page_to_phys(struct page *page)
{
 unsigned long pfn = (unsigned long)((page) - vmemmap);

 ({ int __ret_warn_on = !!(0 && !pfn_valid(pfn)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/io.h"), "i" (801), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/io.h"), "i" (801), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });

 return ((phys_addr_t)(pfn) << 16);
}
# 14 "/home/nathan/src/linux-next/include/linux/io.h" 2


struct device;
struct resource;

          void __iowrite32_copy(void *to, const void *from, size_t count);
void __ioread32_copy(void *to, const void *from, size_t count);
void __iowrite64_copy(void *to, const void *from, size_t count);


int ioremap_page_range(unsigned long addr, unsigned long end,
         phys_addr_t phys_addr, pgprot_t prot);
# 35 "/home/nathan/src/linux-next/include/linux/io.h"
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) ioremap_huge_init(void);
int arch_ioremap_p4d_supported(void);
int arch_ioremap_pud_supported(void);
int arch_ioremap_pmd_supported(void);
# 47 "/home/nathan/src/linux-next/include/linux/io.h"
void * devm_ioport_map(struct device *dev, unsigned long port,
          unsigned int nr);
void devm_ioport_unmap(struct device *dev, void *addr);
# 65 "/home/nathan/src/linux-next/include/linux/io.h"
void *devm_ioremap(struct device *dev, resource_size_t offset,
      resource_size_t size);
void *devm_ioremap_uc(struct device *dev, resource_size_t offset,
       resource_size_t size);
void *devm_ioremap_wc(struct device *dev, resource_size_t offset,
       resource_size_t size);
void devm_iounmap(struct device *dev, void *addr);
int check_signature(const volatile void *io_addr,
   const unsigned char *signature, int length);
void devm_ioremap_release(struct device *dev, void *res);

void *devm_memremap(struct device *dev, resource_size_t offset,
  size_t size, unsigned long flags);
void devm_memunmap(struct device *dev, void *addr);

void *__devm_memremap_pages(struct device *dev, struct resource *res);
# 95 "/home/nathan/src/linux-next/include/linux/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pci_remap_cfgspace(phys_addr_t offset,
            size_t size)
{
 return ioremap(offset, size);
}
# 124 "/home/nathan/src/linux-next/include/linux/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__)) arch_phys_wc_add(unsigned long base,
      unsigned long size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_phys_wc_del(int handle)
{
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_phys_wc_index(int handle)
{
 return -1;
}




enum {

 MEMREMAP_WB = 1 << 0,
 MEMREMAP_WT = 1 << 1,
 MEMREMAP_WC = 1 << 2,
 MEMREMAP_ENC = 1 << 3,
 MEMREMAP_DEC = 1 << 4,
};

void *memremap(resource_size_t offset, size_t size, unsigned long flags);
void memunmap(void *addr);
# 166 "/home/nathan/src/linux-next/include/linux/io.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_io_reserve_memtype_wc(resource_size_t base,
          resource_size_t size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_io_free_memtype_wc(resource_size_t base,
        resource_size_t size)
{
}
# 21 "/home/nathan/src/linux-next/include/linux/irq.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/slab.h" 1
# 136 "/home/nathan/src/linux-next/include/linux/slab.h"
# 1 "/home/nathan/src/linux-next/include/linux/kasan.h" 1






struct kmem_cache;
struct page;
struct vm_struct;
struct task_struct;
# 101 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_shadow(const void *address, size_t size) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_task_stack(struct task_struct *task) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_stack_above_sp_to(const void *watermark) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_enable_current(void) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_disable_current(void) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_alloc_pages(struct page *page, unsigned int order) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_free_pages(struct page *page, unsigned int order) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_create(struct kmem_cache *cache,
          unsigned int *size,
          slab_flags_t *flags) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_slab(struct page *page) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_object_data(struct kmem_cache *cache,
     void *object) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_object_data(struct kmem_cache *cache,
     void *object) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_init_slab_obj(struct kmem_cache *cache,
    const void *object)
{
 return (void *)object;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_kmalloc_large(void *ptr, size_t size, gfp_t flags)
{
 return ptr;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_kfree_large(void *ptr, unsigned long ip) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_kfree(void *ptr, unsigned long ip) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_kmalloc(struct kmem_cache *s, const void *object,
    size_t size, gfp_t flags)
{
 return (void *)object;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_krealloc(const void *object, size_t new_size,
     gfp_t flags)
{
 return (void *)object;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_slab_alloc(struct kmem_cache *s, void *object,
       gfp_t flags)
{
 return object;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool kasan_slab_free(struct kmem_cache *s, void *object,
       unsigned long ip)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_module_alloc(void *addr, size_t size) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_free_shadow(const struct vm_struct *vm) {}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_add_zero_shadow(void *start, unsigned long size)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_remove_zero_shadow(void *start,
     unsigned long size)
{}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_slab(const void *ptr) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t kasan_metadata_size(struct kmem_cache *cache) { return 0; }
# 180 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_shrink(struct kmem_cache *cache) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_cache_shutdown(struct kmem_cache *cache) {}
# 198 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_init_tags(void) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kasan_reset_tag(const void *addr)
{
 return (void *)addr;
}
# 215 "/home/nathan/src/linux-next/include/linux/kasan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kasan_populate_vmalloc(unsigned long start,
     unsigned long size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_poison_vmalloc(const void *start, unsigned long size)
{ }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_unpoison_vmalloc(const void *start, unsigned long size)
{ }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_release_vmalloc(unsigned long start,
      unsigned long end,
      unsigned long free_region_start,
      unsigned long free_region_end) {}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kasan_non_canonical_hook(unsigned long addr) { }
# 137 "/home/nathan/src/linux-next/include/linux/slab.h" 2

struct mem_cgroup;



void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init(void);
bool slab_is_available(void);

extern bool usercopy_fallback;

struct kmem_cache *kmem_cache_create(const char *name, unsigned int size,
   unsigned int align, slab_flags_t flags,
   void (*ctor)(void *));
struct kmem_cache *kmem_cache_create_usercopy(const char *name,
   unsigned int size, unsigned int align,
   slab_flags_t flags,
   unsigned int useroffset, unsigned int usersize,
   void (*ctor)(void *));
void kmem_cache_destroy(struct kmem_cache *);
int kmem_cache_shrink(struct kmem_cache *);

void memcg_create_kmem_cache(struct mem_cgroup *, struct kmem_cache *);
void memcg_deactivate_kmem_caches(struct mem_cgroup *, struct mem_cgroup *);
# 187 "/home/nathan/src/linux-next/include/linux/slab.h"
void * __attribute__((__warn_unused_result__)) krealloc(const void *, size_t, gfp_t);
void kfree(const void *);
void kzfree(const void *);
size_t __ksize(const void *);
size_t ksize(const void *);


void __check_heap_object(const void *ptr, unsigned long n, struct page *page,
   bool to_user);
# 308 "/home/nathan/src/linux-next/include/linux/slab.h"
enum kmalloc_cache_type {
 KMALLOC_NORMAL = 0,
 KMALLOC_RECLAIM,



 NR_KMALLOC_TYPES
};


extern struct kmem_cache *
kmalloc_caches[NR_KMALLOC_TYPES][(16 + 1) + 1];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) enum kmalloc_cache_type kmalloc_type(gfp_t flags)
{
# 337 "/home/nathan/src/linux-next/include/linux/slab.h"
 return flags & (( gfp_t)0x10u) ? KMALLOC_RECLAIM : KMALLOC_NORMAL;

}
# 349 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned int kmalloc_index(size_t size)
{
 if (!size)
  return 0;

 if (size <= (1 << 3))
  return 3;

 if ((1 << 3) <= 32 && size > 64 && size <= 96)
  return 1;
 if ((1 << 3) <= 64 && size > 128 && size <= 192)
  return 2;
 if (size <= 8) return 3;
 if (size <= 16) return 4;
 if (size <= 32) return 5;
 if (size <= 64) return 6;
 if (size <= 128) return 7;
 if (size <= 256) return 8;
 if (size <= 512) return 9;
 if (size <= 1024) return 10;
 if (size <= 2 * 1024) return 11;
 if (size <= 4 * 1024) return 12;
 if (size <= 8 * 1024) return 13;
 if (size <= 16 * 1024) return 14;
 if (size <= 32 * 1024) return 15;
 if (size <= 64 * 1024) return 16;
 if (size <= 128 * 1024) return 17;
 if (size <= 256 * 1024) return 18;
 if (size <= 512 * 1024) return 19;
 if (size <= 1024 * 1024) return 20;
 if (size <= 2 * 1024 * 1024) return 21;
 if (size <= 4 * 1024 * 1024) return 22;
 if (size <= 8 * 1024 * 1024) return 23;
 if (size <= 16 * 1024 * 1024) return 24;
 if (size <= 32 * 1024 * 1024) return 25;
 if (size <= 64 * 1024 * 1024) return 26;
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/slab.h"), "i" (385), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);


 return -1;
}


void *__kmalloc(size_t size, gfp_t flags) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void kmem_cache_free(struct kmem_cache *, void *);
# 403 "/home/nathan/src/linux-next/include/linux/slab.h"
void kmem_cache_free_bulk(struct kmem_cache *, size_t, void **);
int kmem_cache_alloc_bulk(struct kmem_cache *, gfp_t, size_t, void **);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void kfree_bulk(size_t size, void **p)
{
 kmem_cache_free_bulk(((void *)0), size, p);
}


void *__kmalloc_node(size_t size, gfp_t flags, int node) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
# 431 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));


extern void *kmem_cache_alloc_node_trace(struct kmem_cache *s,
        gfp_t gfpflags,
        int node, size_t size) __attribute__((__assume_aligned__(__alignof__(unsigned long long)))) __attribute__((__malloc__));
# 469 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *kmalloc_order(size_t size, gfp_t flags, unsigned int order) __attribute__((__assume_aligned__((1UL << 16)))) __attribute__((__malloc__));


extern void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order) __attribute__((__assume_aligned__((1UL << 16)))) __attribute__((__malloc__));
# 481 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc_large(size_t size, gfp_t flags)
{
 unsigned int order = get_order(size);
 return kmalloc_order_trace(size, flags, order);
}
# 541 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc(size_t size, gfp_t flags)
{
 if (__builtin_constant_p(size)) {

  unsigned int index;

  if (size > (1UL << (16 + 1)))
   return kmalloc_large(size, flags);

  index = kmalloc_index(size);

  if (!index)
   return ((void *)16);

  return kmem_cache_alloc_trace(
    kmalloc_caches[kmalloc_type(flags)][index],
    flags, size);

 }
 return __kmalloc(size, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void *kmalloc_node(size_t size, gfp_t flags, int node)
{

 if (__builtin_constant_p(size) &&
  size <= (1UL << (16 + 1))) {
  unsigned int i = kmalloc_index(size);

  if (!i)
   return ((void *)16);

  return kmem_cache_alloc_node_trace(
    kmalloc_caches[kmalloc_type(flags)][i],
      flags, node, size);
 }

 return __kmalloc_node(size, flags, node);
}

int memcg_update_all_caches(int num_memcgs);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);
 if (__builtin_constant_p(n) && __builtin_constant_p(size))
  return kmalloc(bytes, flags);
 return __kmalloc(bytes, flags);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kcalloc(size_t n, size_t size, gfp_t flags)
{
 return kmalloc_array(n, size, flags | (( gfp_t)0x100u));
}
# 619 "/home/nathan/src/linux-next/include/linux/slab.h"
extern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmalloc_array_node(size_t n, size_t size, gfp_t flags,
           int node)
{
 size_t bytes;

 if (__builtin_expect(!!(({ typeof(n) __a = (n); typeof(size) __b = (size); typeof(&bytes) __d = (&bytes); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); })), 0))
  return ((void *)0);
 if (__builtin_constant_p(n) && __builtin_constant_p(size))
  return kmalloc_node(bytes, flags, node);
 return __kmalloc_node(bytes, flags, node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kcalloc_node(size_t n, size_t size, gfp_t flags, int node)
{
 return kmalloc_array_node(n, size, flags | (( gfp_t)0x100u), node);
}



extern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);
# 657 "/home/nathan/src/linux-next/include/linux/slab.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
{
 return kmem_cache_alloc(k, flags | (( gfp_t)0x100u));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kzalloc(size_t size, gfp_t flags)
{
 return kmalloc(size, flags | (( gfp_t)0x100u));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kzalloc_node(size_t size, gfp_t flags, int node)
{
 return kmalloc_node(size, flags | (( gfp_t)0x100u), node);
}

unsigned int kmem_cache_size(struct kmem_cache *s);
void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init_late(void);
# 22 "/home/nathan/src/linux-next/include/linux/irq.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/irqdomain.h" 1
# 35 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
# 1 "/home/nathan/src/linux-next/include/linux/of.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/of.h"
# 1 "/home/nathan/src/linux-next/include/linux/property.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/property.h"
# 1 "/home/nathan/src/linux-next/include/linux/fwnode.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/fwnode.h"
struct fwnode_operations;
struct device;

struct fwnode_handle {
 struct fwnode_handle *secondary;
 const struct fwnode_operations *ops;
 struct device *dev;
};







struct fwnode_endpoint {
 unsigned int port;
 unsigned int id;
 const struct fwnode_handle *local_fwnode;
};
# 43 "/home/nathan/src/linux-next/include/linux/fwnode.h"
struct fwnode_reference_args {
 struct fwnode_handle *fwnode;
 unsigned int nargs;
 u64 args[8];
};
# 110 "/home/nathan/src/linux-next/include/linux/fwnode.h"
struct fwnode_operations {
 struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
 void (*put)(struct fwnode_handle *fwnode);
 bool (*device_is_available)(const struct fwnode_handle *fwnode);
 const void *(*device_get_match_data)(const struct fwnode_handle *fwnode,
          const struct device *dev);
 bool (*property_present)(const struct fwnode_handle *fwnode,
     const char *propname);
 int (*property_read_int_array)(const struct fwnode_handle *fwnode,
           const char *propname,
           unsigned int elem_size, void *val,
           size_t nval);
 int
 (*property_read_string_array)(const struct fwnode_handle *fwnode_handle,
          const char *propname, const char **val,
          size_t nval);
 const char *(*get_name)(const struct fwnode_handle *fwnode);
 const char *(*get_name_prefix)(const struct fwnode_handle *fwnode);
 struct fwnode_handle *(*get_parent)(const struct fwnode_handle *fwnode);
 struct fwnode_handle *
 (*get_next_child_node)(const struct fwnode_handle *fwnode,
          struct fwnode_handle *child);
 struct fwnode_handle *
 (*get_named_child_node)(const struct fwnode_handle *fwnode,
    const char *name);
 int (*get_reference_args)(const struct fwnode_handle *fwnode,
      const char *prop, const char *nargs_prop,
      unsigned int nargs, unsigned int index,
      struct fwnode_reference_args *args);
 struct fwnode_handle *
 (*graph_get_next_endpoint)(const struct fwnode_handle *fwnode,
       struct fwnode_handle *prev);
 struct fwnode_handle *
 (*graph_get_remote_endpoint)(const struct fwnode_handle *fwnode);
 struct fwnode_handle *
 (*graph_get_port_parent)(struct fwnode_handle *fwnode);
 int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
        struct fwnode_endpoint *endpoint);
 int (*add_links)(const struct fwnode_handle *fwnode,
    struct device *dev);
};
# 15 "/home/nathan/src/linux-next/include/linux/property.h" 2


struct device;

enum dev_prop_type {
 DEV_PROP_U8,
 DEV_PROP_U16,
 DEV_PROP_U32,
 DEV_PROP_U64,
 DEV_PROP_STRING,
 DEV_PROP_REF,
};

enum dev_dma_attr {
 DEV_DMA_NOT_SUPPORTED,
 DEV_DMA_NON_COHERENT,
 DEV_DMA_COHERENT,
};

struct fwnode_handle *dev_fwnode(struct device *dev);

bool device_property_present(struct device *dev, const char *propname);
int device_property_read_u8_array(struct device *dev, const char *propname,
      u8 *val, size_t nval);
int device_property_read_u16_array(struct device *dev, const char *propname,
       u16 *val, size_t nval);
int device_property_read_u32_array(struct device *dev, const char *propname,
       u32 *val, size_t nval);
int device_property_read_u64_array(struct device *dev, const char *propname,
       u64 *val, size_t nval);
int device_property_read_string_array(struct device *dev, const char *propname,
          const char **val, size_t nval);
int device_property_read_string(struct device *dev, const char *propname,
    const char **val);
int device_property_match_string(struct device *dev,
     const char *propname, const char *string);

bool fwnode_device_is_available(const struct fwnode_handle *fwnode);
bool fwnode_property_present(const struct fwnode_handle *fwnode,
        const char *propname);
int fwnode_property_read_u8_array(const struct fwnode_handle *fwnode,
      const char *propname, u8 *val,
      size_t nval);
int fwnode_property_read_u16_array(const struct fwnode_handle *fwnode,
       const char *propname, u16 *val,
       size_t nval);
int fwnode_property_read_u32_array(const struct fwnode_handle *fwnode,
       const char *propname, u32 *val,
       size_t nval);
int fwnode_property_read_u64_array(const struct fwnode_handle *fwnode,
       const char *propname, u64 *val,
       size_t nval);
int fwnode_property_read_string_array(const struct fwnode_handle *fwnode,
          const char *propname, const char **val,
          size_t nval);
int fwnode_property_read_string(const struct fwnode_handle *fwnode,
    const char *propname, const char **val);
int fwnode_property_match_string(const struct fwnode_handle *fwnode,
     const char *propname, const char *string);
int fwnode_property_get_reference_args(const struct fwnode_handle *fwnode,
           const char *prop, const char *nargs_prop,
           unsigned int nargs, unsigned int index,
           struct fwnode_reference_args *args);

struct fwnode_handle *fwnode_find_reference(const struct fwnode_handle *fwnode,
         const char *name,
         unsigned int index);

const char *fwnode_get_name(const struct fwnode_handle *fwnode);
const char *fwnode_get_name_prefix(const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_get_parent(const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_get_next_parent(
 struct fwnode_handle *fwnode);
unsigned int fwnode_count_parents(const struct fwnode_handle *fwn);
struct fwnode_handle *fwnode_get_nth_parent(struct fwnode_handle *fwn,
         unsigned int depth);
struct fwnode_handle *fwnode_get_next_child_node(
 const struct fwnode_handle *fwnode, struct fwnode_handle *child);
struct fwnode_handle *fwnode_get_next_available_child_node(
 const struct fwnode_handle *fwnode, struct fwnode_handle *child);
# 104 "/home/nathan/src/linux-next/include/linux/property.h"
struct fwnode_handle *device_get_next_child_node(
 struct device *dev, struct fwnode_handle *child);





struct fwnode_handle *fwnode_get_named_child_node(
 const struct fwnode_handle *fwnode, const char *childname);
struct fwnode_handle *device_get_named_child_node(struct device *dev,
        const char *childname);

struct fwnode_handle *fwnode_handle_get(struct fwnode_handle *fwnode);
void fwnode_handle_put(struct fwnode_handle *fwnode);

int fwnode_irq_get(struct fwnode_handle *fwnode, unsigned int index);

unsigned int device_get_child_node_count(struct device *dev);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool device_property_read_bool(struct device *dev,
          const char *propname)
{
 return device_property_present(dev, propname);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_read_u8(struct device *dev,
       const char *propname, u8 *val)
{
 return device_property_read_u8_array(dev, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_read_u16(struct device *dev,
        const char *propname, u16 *val)
{
 return device_property_read_u16_array(dev, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_read_u32(struct device *dev,
        const char *propname, u32 *val)
{
 return device_property_read_u32_array(dev, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_read_u64(struct device *dev,
        const char *propname, u64 *val)
{
 return device_property_read_u64_array(dev, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_count_u8(struct device *dev, const char *propname)
{
 return device_property_read_u8_array(dev, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_count_u16(struct device *dev, const char *propname)
{
 return device_property_read_u16_array(dev, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_count_u32(struct device *dev, const char *propname)
{
 return device_property_read_u32_array(dev, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int device_property_count_u64(struct device *dev, const char *propname)
{
 return device_property_read_u64_array(dev, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fwnode_property_read_bool(const struct fwnode_handle *fwnode,
          const char *propname)
{
 return fwnode_property_present(fwnode, propname);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_read_u8(const struct fwnode_handle *fwnode,
       const char *propname, u8 *val)
{
 return fwnode_property_read_u8_array(fwnode, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_read_u16(const struct fwnode_handle *fwnode,
        const char *propname, u16 *val)
{
 return fwnode_property_read_u16_array(fwnode, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_read_u32(const struct fwnode_handle *fwnode,
        const char *propname, u32 *val)
{
 return fwnode_property_read_u32_array(fwnode, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_read_u64(const struct fwnode_handle *fwnode,
        const char *propname, u64 *val)
{
 return fwnode_property_read_u64_array(fwnode, propname, val, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_count_u8(const struct fwnode_handle *fwnode,
        const char *propname)
{
 return fwnode_property_read_u8_array(fwnode, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_count_u16(const struct fwnode_handle *fwnode,
         const char *propname)
{
 return fwnode_property_read_u16_array(fwnode, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_count_u32(const struct fwnode_handle *fwnode,
         const char *propname)
{
 return fwnode_property_read_u32_array(fwnode, propname, ((void *)0), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fwnode_property_count_u64(const struct fwnode_handle *fwnode,
         const char *propname)
{
 return fwnode_property_read_u64_array(fwnode, propname, ((void *)0), 0);
}

struct software_node;







struct software_node_ref_args {
 const struct software_node *node;
 unsigned int nargs;
 u64 args[8];
};
# 250 "/home/nathan/src/linux-next/include/linux/property.h"
struct property_entry {
 const char *name;
 size_t length;
 bool is_inline;
 enum dev_prop_type type;
 union {
  const void *pointer;
  union {
   u8 u8_data[sizeof(u64) / sizeof(u8)];
   u16 u16_data[sizeof(u64) / sizeof(u16)];
   u32 u32_data[sizeof(u64) / sizeof(u32)];
   u64 u64_data[sizeof(u64) / sizeof(u64)];
   const char *str[sizeof(u64) / sizeof(char *)];
  } value;
 };
};
# 356 "/home/nathan/src/linux-next/include/linux/property.h"
struct property_entry *
property_entries_dup(const struct property_entry *properties);

void property_entries_free(const struct property_entry *properties);

int device_add_properties(struct device *dev,
     const struct property_entry *properties);
void device_remove_properties(struct device *dev);

bool device_dma_supported(struct device *dev);

enum dev_dma_attr device_get_dma_attr(struct device *dev);

const void *device_get_match_data(struct device *dev);

int device_get_phy_mode(struct device *dev);

void *device_get_mac_address(struct device *dev, char *addr, int alen);

int fwnode_get_phy_mode(struct fwnode_handle *fwnode);
void *fwnode_get_mac_address(struct fwnode_handle *fwnode,
        char *addr, int alen);
struct fwnode_handle *fwnode_graph_get_next_endpoint(
 const struct fwnode_handle *fwnode, struct fwnode_handle *prev);
struct fwnode_handle *
fwnode_graph_get_port_parent(const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_graph_get_remote_port_parent(
 const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_graph_get_remote_port(
 const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_graph_get_remote_endpoint(
 const struct fwnode_handle *fwnode);
struct fwnode_handle *
fwnode_graph_get_remote_node(const struct fwnode_handle *fwnode, u32 port,
        u32 endpoint);
# 405 "/home/nathan/src/linux-next/include/linux/property.h"
struct fwnode_handle *
fwnode_graph_get_endpoint_by_id(const struct fwnode_handle *fwnode,
    u32 port, u32 endpoint, unsigned long flags);





int fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
    struct fwnode_endpoint *endpoint);
# 425 "/home/nathan/src/linux-next/include/linux/property.h"
struct software_node {
 const char *name;
 const struct software_node *parent;
 const struct property_entry *properties;
};

bool is_software_node(const struct fwnode_handle *fwnode);
const struct software_node *
to_software_node(const struct fwnode_handle *fwnode);
struct fwnode_handle *software_node_fwnode(const struct software_node *node);

const struct software_node *
software_node_find_by_name(const struct software_node *parent,
      const char *name);

int software_node_register_nodes(const struct software_node *nodes);
void software_node_unregister_nodes(const struct software_node *nodes);

int software_node_register(const struct software_node *node);

int software_node_notify(struct device *dev, unsigned long action);

struct fwnode_handle *
fwnode_create_software_node(const struct property_entry *properties,
       const struct fwnode_handle *parent);
void fwnode_remove_software_node(struct fwnode_handle *fwnode);
# 23 "/home/nathan/src/linux-next/include/linux/of.h" 2





typedef u32 phandle;
typedef u32 ihandle;

struct property {
 char *name;
 int length;
 void *value;
 struct property *next;

 unsigned long _flags;





 struct bin_attribute attr;

};





struct device_node {
 const char *name;
 phandle phandle;
 const char *full_name;
 struct fwnode_handle fwnode;

 struct property *properties;
 struct property *deadprops;
 struct device_node *parent;
 struct device_node *child;
 struct device_node *sibling;

 struct kobject kobj;

 unsigned long _flags;
 void *data;




};


struct of_phandle_args {
 struct device_node *np;
 int args_count;
 uint32_t args[16];
};

struct of_phandle_iterator {

 const char *cells_name;
 int cell_count;
 const struct device_node *parent;


 const __be32 *list_end;
 const __be32 *phandle_end;


 const __be32 *cur;
 uint32_t cur_count;
 phandle phandle;
 struct device_node *node;
};

struct of_reconfig_data {
 struct device_node *dn;
 struct property *prop;
 struct property *old_prop;
};


extern struct kobj_type of_node_ktype;
extern const struct fwnode_operations of_fwnode_ops;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void of_node_init(struct device_node *node)
{

 kobject_init(&node->kobj, &of_node_ktype);

 node->fwnode.ops = &of_fwnode_ops;
}
# 121 "/home/nathan/src/linux-next/include/linux/of.h"
extern struct device_node *of_node_get(struct device_node *node);
extern void of_node_put(struct device_node *node);
# 133 "/home/nathan/src/linux-next/include/linux/of.h"
extern struct device_node *of_root;
extern struct device_node *of_chosen;
extern struct device_node *of_aliases;
extern struct device_node *of_stdout;
extern raw_spinlock_t devtree_lock;
# 153 "/home/nathan/src/linux-next/include/linux/of.h"
void of_core_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_of_node(const struct fwnode_handle *fwnode)
{
 return !IS_ERR_OR_NULL(fwnode) && fwnode->ops == &of_fwnode_ops;
}
# 178 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool of_have_populated_dt(void)
{
 return of_root != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool of_node_is_root(const struct device_node *node)
{
 return node && (node->parent == ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_node_check_flag(struct device_node *n, unsigned long flag)
{
 return test_bit(flag, &n->_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_node_test_and_set_flag(struct device_node *n,
         unsigned long flag)
{
 return test_and_set_bit(flag, &n->_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void of_node_set_flag(struct device_node *n, unsigned long flag)
{
 set_bit(flag, &n->_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void of_node_clear_flag(struct device_node *n, unsigned long flag)
{
 clear_bit(flag, &n->_flags);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_check_flag(struct property *p, unsigned long flag)
{
 return test_bit(flag, &p->_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void of_property_set_flag(struct property *p, unsigned long flag)
{
 set_bit(flag, &p->_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void of_property_clear_flag(struct property *p, unsigned long flag)
{
 clear_bit(flag, &p->_flags);
}


extern struct device_node *__of_find_all_nodes(struct device_node *prev);
extern struct device_node *of_find_all_nodes(struct device_node *prev);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 of_read_number(const __be32 *cell, int size)
{
 u64 r = 0;
 for (; size--; cell++)
  r = (r << 32) | (( __u32)(__be32)(*cell));
 return r;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long of_read_ulong(const __be32 *cell, int size)
{

 return of_read_number(cell, size);
}
# 256 "/home/nathan/src/linux-next/include/linux/of.h"
extern bool of_node_name_eq(const struct device_node *np, const char *name);
extern bool of_node_name_prefix(const struct device_node *np, const char *prefix);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *of_node_full_name(const struct device_node *np)
{
 return np ? np->full_name : "<no-node>";
}




extern struct device_node *of_find_node_by_name(struct device_node *from,
 const char *name);
extern struct device_node *of_find_node_by_type(struct device_node *from,
 const char *type);
extern struct device_node *of_find_compatible_node(struct device_node *from,
 const char *type, const char *compat);
extern struct device_node *of_find_matching_node_and_match(
 struct device_node *from,
 const struct of_device_id *matches,
 const struct of_device_id **match);

extern struct device_node *of_find_node_opts_by_path(const char *path,
 const char **opts);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *of_find_node_by_path(const char *path)
{
 return of_find_node_opts_by_path(path, ((void *)0));
}

extern struct device_node *of_find_node_by_phandle(phandle handle);
extern struct device_node *of_get_parent(const struct device_node *node);
extern struct device_node *of_get_next_parent(struct device_node *node);
extern struct device_node *of_get_next_child(const struct device_node *node,
          struct device_node *prev);
extern struct device_node *of_get_next_available_child(
 const struct device_node *node, struct device_node *prev);

extern struct device_node *of_get_compatible_child(const struct device_node *parent,
     const char *compatible);
extern struct device_node *of_get_child_by_name(const struct device_node *node,
     const char *name);


extern struct device_node *of_find_next_cache_node(const struct device_node *);
extern int of_find_last_cache_level(unsigned int cpu);
extern struct device_node *of_find_node_with_property(
 struct device_node *from, const char *prop_name);

extern struct property *of_find_property(const struct device_node *np,
      const char *name,
      int *lenp);
extern int of_property_count_elems_of_size(const struct device_node *np,
    const char *propname, int elem_size);
extern int of_property_read_u32_index(const struct device_node *np,
           const char *propname,
           u32 index, u32 *out_value);
extern int of_property_read_u64_index(const struct device_node *np,
           const char *propname,
           u32 index, u64 *out_value);
extern int of_property_read_variable_u8_array(const struct device_node *np,
     const char *propname, u8 *out_values,
     size_t sz_min, size_t sz_max);
extern int of_property_read_variable_u16_array(const struct device_node *np,
     const char *propname, u16 *out_values,
     size_t sz_min, size_t sz_max);
extern int of_property_read_variable_u32_array(const struct device_node *np,
     const char *propname,
     u32 *out_values,
     size_t sz_min,
     size_t sz_max);
extern int of_property_read_u64(const struct device_node *np,
    const char *propname, u64 *out_value);
extern int of_property_read_variable_u64_array(const struct device_node *np,
     const char *propname,
     u64 *out_values,
     size_t sz_min,
     size_t sz_max);

extern int of_property_read_string(const struct device_node *np,
       const char *propname,
       const char **out_string);
extern int of_property_match_string(const struct device_node *np,
        const char *propname,
        const char *string);
extern int of_property_read_string_helper(const struct device_node *np,
           const char *propname,
           const char **out_strs, size_t sz, int index);
extern int of_device_is_compatible(const struct device_node *device,
       const char *);
extern int of_device_compatible_match(struct device_node *device,
          const char *const *compat);
extern bool of_device_is_available(const struct device_node *device);
extern bool of_device_is_big_endian(const struct device_node *device);
extern const void *of_get_property(const struct device_node *node,
    const char *name,
    int *lenp);
extern struct device_node *of_get_cpu_node(int cpu, unsigned int *thread);
extern struct device_node *of_get_next_cpu_node(struct device_node *prev);
extern struct device_node *of_get_cpu_state_node(struct device_node *cpu_node,
       int index);




extern int of_n_addr_cells(struct device_node *np);
extern int of_n_size_cells(struct device_node *np);
extern const struct of_device_id *of_match_node(
 const struct of_device_id *matches, const struct device_node *node);
extern int of_modalias_node(struct device_node *node, char *modalias, int len);
extern void of_print_phandle_args(const char *msg, const struct of_phandle_args *args);
extern struct device_node *of_parse_phandle(const struct device_node *np,
         const char *phandle_name,
         int index);
extern int of_parse_phandle_with_args(const struct device_node *np,
 const char *list_name, const char *cells_name, int index,
 struct of_phandle_args *out_args);
extern int of_parse_phandle_with_args_map(const struct device_node *np,
 const char *list_name, const char *stem_name, int index,
 struct of_phandle_args *out_args);
extern int of_parse_phandle_with_fixed_args(const struct device_node *np,
 const char *list_name, int cells_count, int index,
 struct of_phandle_args *out_args);
extern int of_count_phandle_with_args(const struct device_node *np,
 const char *list_name, const char *cells_name);


extern int of_phandle_iterator_init(struct of_phandle_iterator *it,
        const struct device_node *np,
        const char *list_name,
        const char *cells_name,
        int cell_count);

extern int of_phandle_iterator_next(struct of_phandle_iterator *it);
extern int of_phandle_iterator_args(struct of_phandle_iterator *it,
        uint32_t *args,
        int size);

extern void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align));
extern int of_alias_get_id(struct device_node *np, const char *stem);
extern int of_alias_get_highest_id(const char *stem);
extern int of_alias_get_alias_list(const struct of_device_id *matches,
       const char *stem, unsigned long *bitmap,
       unsigned int nbits);

extern int of_machine_is_compatible(const char *compat);

extern int of_add_property(struct device_node *np, struct property *prop);
extern int of_remove_property(struct device_node *np, struct property *prop);
extern int of_update_property(struct device_node *np, struct property *newprop);
# 413 "/home/nathan/src/linux-next/include/linux/of.h"
extern int of_attach_node(struct device_node *);
extern int of_detach_node(struct device_node *);
# 436 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u8_array(const struct device_node *np,
         const char *propname,
         u8 *out_values, size_t sz)
{
 int ret = of_property_read_variable_u8_array(np, propname, out_values,
           sz, 0);
 if (ret >= 0)
  return 0;
 else
  return ret;
}
# 466 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u16_array(const struct device_node *np,
          const char *propname,
          u16 *out_values, size_t sz)
{
 int ret = of_property_read_variable_u16_array(np, propname, out_values,
            sz, 0);
 if (ret >= 0)
  return 0;
 else
  return ret;
}
# 494 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u32_array(const struct device_node *np,
          const char *propname,
          u32 *out_values, size_t sz)
{
 int ret = of_property_read_variable_u32_array(np, propname, out_values,
            sz, 0);
 if (ret >= 0)
  return 0;
 else
  return ret;
}
# 522 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u64_array(const struct device_node *np,
          const char *propname,
          u64 *out_values, size_t sz)
{
 int ret = of_property_read_variable_u64_array(np, propname, out_values,
            sz, 0);
 if (ret >= 0)
  return 0;
 else
  return ret;
}
# 542 "/home/nathan/src/linux-next/include/linux/of.h"
const __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,
          u32 *pu);







const char *of_prop_next_string(struct property *prop, const char *cur);

bool of_console_check(struct device_node *dn, char *name, int index);

extern int of_cpu_node_to_id(struct device_node *np);

int of_map_rid(struct device_node *np, u32 rid,
        const char *map_name, const char *map_mask_name,
        struct device_node **target, u32 *id_out);
# 999 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_prop_val_eq(struct property *p1, struct property *p2)
{
 return p1->length == p2->length &&
        !memcmp(p1->value, p2->value, (size_t)p1->length);
}


extern int of_node_to_nid(struct device_node *np);
# 1017 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_numa_init(void)
{
 return -38;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *of_find_matching_node(
 struct device_node *from,
 const struct of_device_id *matches)
{
 return of_find_matching_node_and_match(from, matches, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *of_node_get_device_type(const struct device_node *np)
{
 return of_get_property(np, "device_type", ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool of_node_is_type(const struct device_node *np, const char *type)
{
 const char *match = of_node_get_device_type(np);

 return np && match && type && !strcmp(match, type);
}
# 1053 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_count_u8_elems(const struct device_node *np,
    const char *propname)
{
 return of_property_count_elems_of_size(np, propname, sizeof(u8));
}
# 1070 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_count_u16_elems(const struct device_node *np,
    const char *propname)
{
 return of_property_count_elems_of_size(np, propname, sizeof(u16));
}
# 1087 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_count_u32_elems(const struct device_node *np,
    const char *propname)
{
 return of_property_count_elems_of_size(np, propname, sizeof(u32));
}
# 1104 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_count_u64_elems(const struct device_node *np,
    const char *propname)
{
 return of_property_count_elems_of_size(np, propname, sizeof(u64));
}
# 1123 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_string_array(const struct device_node *np,
      const char *propname, const char **out_strs,
      size_t sz)
{
 return of_property_read_string_helper(np, propname, out_strs, sz, 0);
}
# 1142 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_count_strings(const struct device_node *np,
         const char *propname)
{
 return of_property_read_string_helper(np, propname, ((void *)0), 0, 0);
}
# 1166 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_string_index(const struct device_node *np,
      const char *propname,
      int index, const char **output)
{
 int rc = of_property_read_string_helper(np, propname, output, 1, index);
 return rc < 0 ? rc : 0;
}
# 1182 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool of_property_read_bool(const struct device_node *np,
      const char *propname)
{
 struct property *prop = of_find_property(np, propname, ((void *)0));

 return prop ? true : false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u8(const struct device_node *np,
           const char *propname,
           u8 *out_value)
{
 return of_property_read_u8_array(np, propname, out_value, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u16(const struct device_node *np,
           const char *propname,
           u16 *out_value)
{
 return of_property_read_u16_array(np, propname, out_value, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_u32(const struct device_node *np,
           const char *propname,
           u32 *out_value)
{
 return of_property_read_u32_array(np, propname, out_value, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_property_read_s32(const struct device_node *np,
           const char *propname,
           s32 *out_value)
{
 return of_property_read_u32(np, propname, (u32*) out_value);
}
# 1267 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_get_child_count(const struct device_node *np)
{
 struct device_node *child;
 int num = 0;

 for (child = of_get_next_child(np, ((void *)0)); child != ((void *)0); child = of_get_next_child(np, child))
  num++;

 return num;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_get_available_child_count(const struct device_node *np)
{
 struct device_node *child;
 int num = 0;

 for (child = of_get_next_available_child(np, ((void *)0)); child != ((void *)0); child = of_get_next_available_child(np, child))
  num++;

 return num;
}
# 1303 "/home/nathan/src/linux-next/include/linux/of.h"
typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);
typedef int (*of_init_fn_1_ret)(struct device_node *);
typedef void (*of_init_fn_1)(struct device_node *);
# 1328 "/home/nathan/src/linux-next/include/linux/of.h"
struct of_changeset_entry {
 struct list_head node;
 unsigned long action;
 struct device_node *np;
 struct property *prop;
 struct property *old_prop;
};
# 1346 "/home/nathan/src/linux-next/include/linux/of.h"
struct of_changeset {
 struct list_head entries;
};

enum of_reconfig_change {
 OF_RECONFIG_NO_CHANGE = 0,
 OF_RECONFIG_CHANGE_ADD,
 OF_RECONFIG_CHANGE_REMOVE,
};


extern int of_reconfig_notifier_register(struct notifier_block *);
extern int of_reconfig_notifier_unregister(struct notifier_block *);
extern int of_reconfig_notify(unsigned long, struct of_reconfig_data *rd);
extern int of_reconfig_get_state_change(unsigned long action,
     struct of_reconfig_data *arg);

extern void of_changeset_init(struct of_changeset *ocs);
extern void of_changeset_destroy(struct of_changeset *ocs);
extern int of_changeset_apply(struct of_changeset *ocs);
extern int of_changeset_revert(struct of_changeset *ocs);
extern int of_changeset_action(struct of_changeset *ocs,
  unsigned long action, struct device_node *np,
  struct property *prop);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_changeset_attach_node(struct of_changeset *ocs,
  struct device_node *np)
{
 return of_changeset_action(ocs, 0x0001, np, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_changeset_detach_node(struct of_changeset *ocs,
  struct device_node *np)
{
 return of_changeset_action(ocs, 0x0002, np, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_changeset_add_property(struct of_changeset *ocs,
  struct device_node *np, struct property *prop)
{
 return of_changeset_action(ocs, 0x0003, np, prop);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_changeset_remove_property(struct of_changeset *ocs,
  struct device_node *np, struct property *prop)
{
 return of_changeset_action(ocs, 0x0004, np, prop);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_changeset_update_property(struct of_changeset *ocs,
  struct device_node *np, struct property *prop)
{
 return of_changeset_action(ocs, 0x0005, np, prop);
}
# 1427 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool of_device_is_system_power_controller(const struct device_node *np)
{
 return of_property_read_bool(np, "system-power-controller");
}





enum of_overlay_notify_action {
 OF_OVERLAY_PRE_APPLY = 0,
 OF_OVERLAY_POST_APPLY,
 OF_OVERLAY_PRE_REMOVE,
 OF_OVERLAY_POST_REMOVE,
};

struct of_overlay_notify_data {
 struct device_node *overlay;
 struct device_node *target;
};
# 1460 "/home/nathan/src/linux-next/include/linux/of.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_overlay_fdt_apply(void *overlay_fdt, u32 overlay_fdt_size,
           int *ovcs_id)
{
 return -524;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_overlay_remove(int *ovcs_id)
{
 return -524;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_overlay_remove_all(void)
{
 return -524;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_overlay_notifier_register(struct notifier_block *nb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_overlay_notifier_unregister(struct notifier_block *nb)
{
 return 0;
}
# 36 "/home/nathan/src/linux-next/include/linux/irqdomain.h" 2



struct device_node;
struct irq_domain;
struct of_device_id;
struct irq_chip;
struct irq_data;
struct cpumask;
struct seq_file;
struct irq_affinity_desc;
# 63 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
struct irq_fwspec {
 struct fwnode_handle *fwnode;
 int param_count;
 u32 param[16];
};
# 76 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
enum irq_domain_bus_token {
 DOMAIN_BUS_ANY = 0,
 DOMAIN_BUS_WIRED,
 DOMAIN_BUS_GENERIC_MSI,
 DOMAIN_BUS_PCI_MSI,
 DOMAIN_BUS_PLATFORM_MSI,
 DOMAIN_BUS_NEXUS,
 DOMAIN_BUS_IPI,
 DOMAIN_BUS_FSL_MC_MSI,
 DOMAIN_BUS_TI_SCI_INTA_MSI,
 DOMAIN_BUS_WAKEUP,
};
# 104 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
struct irq_domain_ops {
 int (*match)(struct irq_domain *d, struct device_node *node,
       enum irq_domain_bus_token bus_token);
 int (*select)(struct irq_domain *d, struct irq_fwspec *fwspec,
        enum irq_domain_bus_token bus_token);
 int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
 void (*unmap)(struct irq_domain *d, unsigned int virq);
 int (*xlate)(struct irq_domain *d, struct device_node *node,
       const u32 *intspec, unsigned int intsize,
       unsigned long *out_hwirq, unsigned int *out_type);


 int (*alloc)(struct irq_domain *d, unsigned int virq,
       unsigned int nr_irqs, void *arg);
 void (*free)(struct irq_domain *d, unsigned int virq,
       unsigned int nr_irqs);
 int (*activate)(struct irq_domain *d, struct irq_data *irqd, bool reserve);
 void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
 int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
    unsigned long *out_hwirq, unsigned int *out_type);





};

extern struct irq_domain_ops irq_generic_chip_ops;

struct irq_domain_chip_generic;
# 161 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
struct irq_domain {
 struct list_head link;
 const char *name;
 const struct irq_domain_ops *ops;
 void *host_data;
 unsigned int flags;
 unsigned int mapcount;


 struct fwnode_handle *fwnode;
 enum irq_domain_bus_token bus_token;
 struct irq_domain_chip_generic *gc;

 struct irq_domain *parent;






 irq_hw_number_t hwirq_max;
 unsigned int revmap_direct_max_irq;
 unsigned int revmap_size;
 struct xarray revmap_tree;
 struct mutex revmap_tree_mutex;
 unsigned int linear_revmap[];
};


enum {

 IRQ_DOMAIN_FLAG_HIERARCHY = (1 << 0),


 IRQ_DOMAIN_NAME_ALLOCATED = (1 << 6),


 IRQ_DOMAIN_FLAG_IPI_PER_CPU = (1 << 2),


 IRQ_DOMAIN_FLAG_IPI_SINGLE = (1 << 3),


 IRQ_DOMAIN_FLAG_MSI = (1 << 4),


 IRQ_DOMAIN_FLAG_MSI_REMAP = (1 << 5),






 IRQ_DOMAIN_MSI_NOMASK_QUIRK = (1 << 6),






 IRQ_DOMAIN_FLAG_NONCORE = (1 << 16),
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *irq_domain_get_of_node(struct irq_domain *d)
{
 return ({ typeof(d->fwnode) __to_of_node_fwnode = (d->fwnode); is_of_node(__to_of_node_fwnode) ? ({ void *__mptr = (void *)(__to_of_node_fwnode); do { extern void __compiletime_assert_226(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(__to_of_node_fwnode)), typeof(((struct device_node *)0)->fwnode)) && !__builtin_types_compatible_p(typeof(*(__to_of_node_fwnode)), typeof(void))))) __compiletime_assert_226(); } while (0); ((struct device_node *)(__mptr - __builtin_offsetof(struct device_node, fwnode))); }) : ((void *)0); });
}


struct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,
      const char *name, phys_addr_t *pa);

enum {
 IRQCHIP_FWNODE_REAL,
 IRQCHIP_FWNODE_NAMED,
 IRQCHIP_FWNODE_NAMED_ID,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct fwnode_handle *irq_domain_alloc_named_fwnode(const char *name)
{
 return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_NAMED, 0, name, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct fwnode_handle *irq_domain_alloc_named_id_fwnode(const char *name, int id)
{
 return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_NAMED_ID, id, name,
      ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fwnode_handle *irq_domain_alloc_fwnode(phys_addr_t *pa)
{
 return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_REAL, 0, ((void *)0), pa);
}

void irq_domain_free_fwnode(struct fwnode_handle *fwnode);
struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
        irq_hw_number_t hwirq_max, int direct_max,
        const struct irq_domain_ops *ops,
        void *host_data);
struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
      unsigned int size,
      unsigned int first_irq,
      const struct irq_domain_ops *ops,
      void *host_data);
struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
      unsigned int size,
      unsigned int first_irq,
      irq_hw_number_t first_hwirq,
      const struct irq_domain_ops *ops,
      void *host_data);
extern struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,
         enum irq_domain_bus_token bus_token);
extern bool irq_domain_check_msi_remap(void);
extern void irq_set_default_host(struct irq_domain *host);
extern struct irq_domain *irq_get_default_host(void);
extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
      irq_hw_number_t hwirq, int node,
      const struct irq_affinity_desc *affinity);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
{
 return node ? &node->fwnode : ((void *)0);
}

extern const struct fwnode_operations irqchip_fwnode_ops;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_fwnode_irqchip(struct fwnode_handle *fwnode)
{
 return fwnode && fwnode->ops == &irqchip_fwnode_ops;
}

extern void irq_domain_update_bus_token(struct irq_domain *domain,
     enum irq_domain_bus_token bus_token);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
         enum irq_domain_bus_token bus_token)
{
 struct irq_fwspec fwspec = {
  .fwnode = fwnode,
 };

 return irq_find_matching_fwspec(&fwspec, bus_token);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_find_matching_host(struct device_node *node,
       enum irq_domain_bus_token bus_token)
{
 return irq_find_matching_fwnode(of_node_to_fwnode(node), bus_token);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_find_host(struct device_node *node)
{
 struct irq_domain *d;

 d = irq_find_matching_host(node, DOMAIN_BUS_WIRED);
 if (!d)
  d = irq_find_matching_host(node, DOMAIN_BUS_ANY);

 return d;
}
# 332 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
      unsigned int size,
      const struct irq_domain_ops *ops,
      void *host_data)
{
 return __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
      unsigned int max_irq,
      const struct irq_domain_ops *ops,
      void *host_data)
{
 return __irq_domain_add(of_node_to_fwnode(of_node), 0, max_irq, max_irq, ops, host_data);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_add_legacy_isa(
    struct device_node *of_node,
    const struct irq_domain_ops *ops,
    void *host_data)
{
 return irq_domain_add_legacy(of_node, 16, 0, 0, ops,
         host_data);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
      const struct irq_domain_ops *ops,
      void *host_data)
{
 return __irq_domain_add(of_node_to_fwnode(of_node), 0, ~0, 0, ops, host_data);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_create_linear(struct fwnode_handle *fwnode,
      unsigned int size,
      const struct irq_domain_ops *ops,
      void *host_data)
{
 return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_create_tree(struct fwnode_handle *fwnode,
      const struct irq_domain_ops *ops,
      void *host_data)
{
 return __irq_domain_add(fwnode, 0, ~0, 0, ops, host_data);
}

extern void irq_domain_remove(struct irq_domain *host);

extern int irq_domain_associate(struct irq_domain *domain, unsigned int irq,
     irq_hw_number_t hwirq);
extern void irq_domain_associate_many(struct irq_domain *domain,
          unsigned int irq_base,
          irq_hw_number_t hwirq_base, int count);
extern void irq_domain_disassociate(struct irq_domain *domain,
        unsigned int irq);

extern unsigned int irq_create_mapping(struct irq_domain *host,
           irq_hw_number_t hwirq);
extern unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec);
extern void irq_dispose_mapping(unsigned int virq);
# 401 "/home/nathan/src/linux-next/include/linux/irqdomain.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int irq_linear_revmap(struct irq_domain *domain,
          irq_hw_number_t hwirq)
{
 return hwirq < domain->revmap_size ? domain->linear_revmap[hwirq] : 0;
}
extern unsigned int irq_find_mapping(struct irq_domain *host,
         irq_hw_number_t hwirq);
extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
extern int irq_create_strict_mappings(struct irq_domain *domain,
          unsigned int irq_base,
          irq_hw_number_t hwirq_base, int count);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_create_identity_mapping(struct irq_domain *host,
           irq_hw_number_t hwirq)
{
 return irq_create_strict_mappings(host, hwirq, hwirq, 1);
}

extern const struct irq_domain_ops irq_domain_simple_ops;


int irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,
   const u32 *intspec, unsigned int intsize,
   irq_hw_number_t *out_hwirq, unsigned int *out_type);
int irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,
   const u32 *intspec, unsigned int intsize,
   irq_hw_number_t *out_hwirq, unsigned int *out_type);
int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
   const u32 *intspec, unsigned int intsize,
   irq_hw_number_t *out_hwirq, unsigned int *out_type);

int irq_domain_translate_twocell(struct irq_domain *d,
     struct irq_fwspec *fwspec,
     unsigned long *out_hwirq,
     unsigned int *out_type);

int irq_domain_translate_onecell(struct irq_domain *d,
     struct irq_fwspec *fwspec,
     unsigned long *out_hwirq,
     unsigned int *out_type);


int irq_reserve_ipi(struct irq_domain *domain, const struct cpumask *dest);
int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);


extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
      unsigned int virq);
extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
    irq_hw_number_t hwirq, struct irq_chip *chip,
    void *chip_data, irq_flow_handler_t handler,
    void *handler_data, const char *handler_name);

extern struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,
   unsigned int flags, unsigned int size,
   struct fwnode_handle *fwnode,
   const struct irq_domain_ops *ops, void *host_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,
         unsigned int flags,
         unsigned int size,
         struct device_node *node,
         const struct irq_domain_ops *ops,
         void *host_data)
{
 return irq_domain_create_hierarchy(parent, flags, size,
        of_node_to_fwnode(node),
        ops, host_data);
}

extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
       unsigned int nr_irqs, int node, void *arg,
       bool realloc,
       const struct irq_affinity_desc *affinity);
extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
extern int irq_domain_activate_irq(struct irq_data *irq_data, bool early);
extern void irq_domain_deactivate_irq(struct irq_data *irq_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_domain_alloc_irqs(struct irq_domain *domain,
   unsigned int nr_irqs, int node, void *arg)
{
 return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false,
           ((void *)0));
}

extern int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
        unsigned int irq_base,
        unsigned int nr_irqs, void *arg);
extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
      unsigned int virq,
      irq_hw_number_t hwirq,
      struct irq_chip *chip,
      void *chip_data);
extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
extern void irq_domain_free_irqs_common(struct irq_domain *domain,
     unsigned int virq,
     unsigned int nr_irqs);
extern void irq_domain_free_irqs_top(struct irq_domain *domain,
         unsigned int virq, unsigned int nr_irqs);

extern int irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg);
extern int irq_domain_pop_irq(struct irq_domain *domain, int virq);

extern int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
     unsigned int irq_base,
     unsigned int nr_irqs, void *arg);

extern void irq_domain_free_irqs_parent(struct irq_domain *domain,
     unsigned int irq_base,
     unsigned int nr_irqs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_hierarchy(struct irq_domain *domain)
{
 return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_ipi(struct irq_domain *domain)
{
 return domain->flags &
  (IRQ_DOMAIN_FLAG_IPI_PER_CPU | IRQ_DOMAIN_FLAG_IPI_SINGLE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_ipi_per_cpu(struct irq_domain *domain)
{
 return domain->flags & IRQ_DOMAIN_FLAG_IPI_PER_CPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_ipi_single(struct irq_domain *domain)
{
 return domain->flags & IRQ_DOMAIN_FLAG_IPI_SINGLE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_msi(struct irq_domain *domain)
{
 return domain->flags & IRQ_DOMAIN_FLAG_MSI;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_domain_is_msi_remap(struct irq_domain *domain)
{
 return domain->flags & IRQ_DOMAIN_FLAG_MSI_REMAP;
}

extern bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain);
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h" 2








extern atomic_t ppc_n_lost_interrupts;
# 29 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h"
extern irq_hw_number_t virq_to_hw(unsigned int virq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_canonicalize(int irq)
{
 return irq;
}

extern int distribute_irqs;

struct irqaction;
struct pt_regs;
# 56 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h"
extern void *hardirq_ctx[2048];
extern void *softirq_ctx[2048];

void call_do_softirq(void *sp);
void call_do_irq(struct pt_regs *regs, void *sp);
extern void do_IRQ(struct pt_regs *regs);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) init_IRQ(void);
extern void __do_irq(struct pt_regs *regs);

int irq_choose_cpu(const struct cpumask *mask);
# 24 "/home/nathan/src/linux-next/include/linux/irq.h" 2

# 1 "./arch/powerpc/include/generated/asm/irq_regs.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/irq_regs.h" 1
# 17 "/home/nathan/src/linux-next/include/asm-generic/irq_regs.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(struct pt_regs *) __irq_regs;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pt_regs *get_irq_regs(void)
{
 return ({ __this_cpu_preempt_check("read"); ({ typeof(__irq_regs) pscr_ret__; do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(__irq_regs)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pt_regs *set_irq_regs(struct pt_regs *new_regs)
{
 struct pt_regs *old_regs;

 old_regs = ({ __this_cpu_preempt_check("read"); ({ typeof(__irq_regs) pscr_ret__; do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(__irq_regs)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }); });
 ({ __this_cpu_preempt_check("write"); do { do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(__irq_regs)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }) = new_regs; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }) = new_regs; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }) = new_regs; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(__irq_regs)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(__irq_regs))) *)(&(__irq_regs))); (typeof((typeof(*(&(__irq_regs))) *)(&(__irq_regs)))) (__ptr + ((local_paca->data_offset))); }); }) = new_regs; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 return old_regs;
}
# 2 "./arch/powerpc/include/generated/asm/irq_regs.h" 2
# 26 "/home/nathan/src/linux-next/include/linux/irq.h" 2

struct seq_file;
struct module;
struct msi_msg;
struct irq_affinity_desc;
enum irqchip_irq_state;
# 75 "/home/nathan/src/linux-next/include/linux/irq.h"
enum {
 IRQ_TYPE_NONE = 0x00000000,
 IRQ_TYPE_EDGE_RISING = 0x00000001,
 IRQ_TYPE_EDGE_FALLING = 0x00000002,
 IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING),
 IRQ_TYPE_LEVEL_HIGH = 0x00000004,
 IRQ_TYPE_LEVEL_LOW = 0x00000008,
 IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH),
 IRQ_TYPE_SENSE_MASK = 0x0000000f,
 IRQ_TYPE_DEFAULT = IRQ_TYPE_SENSE_MASK,

 IRQ_TYPE_PROBE = 0x00000010,

 IRQ_LEVEL = (1 << 8),
 IRQ_PER_CPU = (1 << 9),
 IRQ_NOPROBE = (1 << 10),
 IRQ_NOREQUEST = (1 << 11),
 IRQ_NOAUTOEN = (1 << 12),
 IRQ_NO_BALANCING = (1 << 13),
 IRQ_MOVE_PCNTXT = (1 << 14),
 IRQ_NESTED_THREAD = (1 << 15),
 IRQ_NOTHREAD = (1 << 16),
 IRQ_PER_CPU_DEVID = (1 << 17),
 IRQ_IS_POLLED = (1 << 18),
 IRQ_DISABLE_UNLAZY = (1 << 19),
};
# 119 "/home/nathan/src/linux-next/include/linux/irq.h"
enum {
 IRQ_SET_MASK_OK = 0,
 IRQ_SET_MASK_OK_NOCOPY,
 IRQ_SET_MASK_OK_DONE,
};

struct msi_desc;
struct irq_domain;
# 143 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_common_data {
 unsigned int state_use_accessors;

 unsigned int node;

 void *handler_data;
 struct msi_desc *msi_desc;
 cpumask_var_t affinity;






};
# 173 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_data {
 u32 mask;
 unsigned int irq;
 unsigned long hwirq;
 struct irq_common_data *common;
 struct irq_chip *chip;
 struct irq_domain *domain;

 struct irq_data *parent_data;

 void *chip_data;
};
# 215 "/home/nathan/src/linux-next/include/linux/irq.h"
enum {
 IRQD_TRIGGER_MASK = 0xf,
 IRQD_SETAFFINITY_PENDING = (1 << 8),
 IRQD_ACTIVATED = (1 << 9),
 IRQD_NO_BALANCING = (1 << 10),
 IRQD_PER_CPU = (1 << 11),
 IRQD_AFFINITY_SET = (1 << 12),
 IRQD_LEVEL = (1 << 13),
 IRQD_WAKEUP_STATE = (1 << 14),
 IRQD_MOVE_PCNTXT = (1 << 15),
 IRQD_IRQ_DISABLED = (1 << 16),
 IRQD_IRQ_MASKED = (1 << 17),
 IRQD_IRQ_INPROGRESS = (1 << 18),
 IRQD_WAKEUP_ARMED = (1 << 19),
 IRQD_FORWARDED_TO_VCPU = (1 << 20),
 IRQD_AFFINITY_MANAGED = (1 << 21),
 IRQD_IRQ_STARTED = (1 << 22),
 IRQD_MANAGED_SHUTDOWN = (1 << 23),
 IRQD_SINGLE_TARGET = (1 << 24),
 IRQD_DEFAULT_TRIGGER_SET = (1 << 25),
 IRQD_CAN_RESERVE = (1 << 26),
 IRQD_MSI_NOMASK_QUIRK = (1 << 27),
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_setaffinity_pending(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_SETAFFINITY_PENDING;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_per_cpu(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_PER_CPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_can_balance(struct irq_data *d)
{
 return !((((d)->common)->state_use_accessors) & (IRQD_PER_CPU | IRQD_NO_BALANCING));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_affinity_was_set(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_AFFINITY_SET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_mark_affinity_was_set(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_AFFINITY_SET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_trigger_type_was_set(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_DEFAULT_TRIGGER_SET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 irqd_get_trigger_type(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_TRIGGER_MASK;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_trigger_type(struct irq_data *d, u32 type)
{
 (((d)->common)->state_use_accessors) &= ~IRQD_TRIGGER_MASK;
 (((d)->common)->state_use_accessors) |= type & IRQD_TRIGGER_MASK;
 (((d)->common)->state_use_accessors) |= IRQD_DEFAULT_TRIGGER_SET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_level_type(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_LEVEL;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_single_target(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_SINGLE_TARGET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_single_target(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_SINGLE_TARGET;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_wakeup_set(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_WAKEUP_STATE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_can_move_in_process_context(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_MOVE_PCNTXT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_irq_disabled(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_IRQ_DISABLED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_irq_masked(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_IRQ_MASKED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_irq_inprogress(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_IRQ_INPROGRESS;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_wakeup_armed(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_WAKEUP_ARMED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_forwarded_to_vcpu(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_FORWARDED_TO_VCPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_forwarded_to_vcpu(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_FORWARDED_TO_VCPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) &= ~IRQD_FORWARDED_TO_VCPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_affinity_is_managed(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_AFFINITY_MANAGED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_activated(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_ACTIVATED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_activated(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_ACTIVATED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_clr_activated(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) &= ~IRQD_ACTIVATED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_started(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_IRQ_STARTED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_is_managed_and_shutdown(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_MANAGED_SHUTDOWN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_can_reserve(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_CAN_RESERVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_clr_can_reserve(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) &= ~IRQD_CAN_RESERVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_can_reserve(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_CAN_RESERVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_set_msi_nomask_quirk(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) |= IRQD_MSI_NOMASK_QUIRK;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irqd_clr_msi_nomask_quirk(struct irq_data *d)
{
 (((d)->common)->state_use_accessors) &= ~IRQD_MSI_NOMASK_QUIRK;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irqd_msi_nomask_quirk(struct irq_data *d)
{
 return (((d)->common)->state_use_accessors) & IRQD_MSI_NOMASK_QUIRK;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
{
 return d->hwirq;
}
# 467 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_chip {
 struct device *parent_device;
 const char *name;
 unsigned int (*irq_startup)(struct irq_data *data);
 void (*irq_shutdown)(struct irq_data *data);
 void (*irq_enable)(struct irq_data *data);
 void (*irq_disable)(struct irq_data *data);

 void (*irq_ack)(struct irq_data *data);
 void (*irq_mask)(struct irq_data *data);
 void (*irq_mask_ack)(struct irq_data *data);
 void (*irq_unmask)(struct irq_data *data);
 void (*irq_eoi)(struct irq_data *data);

 int (*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
 int (*irq_retrigger)(struct irq_data *data);
 int (*irq_set_type)(struct irq_data *data, unsigned int flow_type);
 int (*irq_set_wake)(struct irq_data *data, unsigned int on);

 void (*irq_bus_lock)(struct irq_data *data);
 void (*irq_bus_sync_unlock)(struct irq_data *data);

 void (*irq_cpu_online)(struct irq_data *data);
 void (*irq_cpu_offline)(struct irq_data *data);

 void (*irq_suspend)(struct irq_data *data);
 void (*irq_resume)(struct irq_data *data);
 void (*irq_pm_shutdown)(struct irq_data *data);

 void (*irq_calc_mask)(struct irq_data *data);

 void (*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 int (*irq_request_resources)(struct irq_data *data);
 void (*irq_release_resources)(struct irq_data *data);

 void (*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 void (*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);

 int (*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
 int (*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);

 int (*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);

 void (*ipi_send_single)(struct irq_data *data, unsigned int cpu);
 void (*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);

 int (*irq_nmi_setup)(struct irq_data *data);
 void (*irq_nmi_teardown)(struct irq_data *data);

 unsigned long flags;
};
# 533 "/home/nathan/src/linux-next/include/linux/irq.h"
enum {
 IRQCHIP_SET_TYPE_MASKED = (1 << 0),
 IRQCHIP_EOI_IF_HANDLED = (1 << 1),
 IRQCHIP_MASK_ON_SUSPEND = (1 << 2),
 IRQCHIP_ONOFFLINE_ENABLED = (1 << 3),
 IRQCHIP_SKIP_SET_WAKE = (1 << 4),
 IRQCHIP_ONESHOT_SAFE = (1 << 5),
 IRQCHIP_EOI_THREADED = (1 << 6),
 IRQCHIP_SUPPORTS_LEVEL_MSI = (1 << 7),
 IRQCHIP_SUPPORTS_NMI = (1 << 8),
};


# 1 "/home/nathan/src/linux-next/include/linux/irqdesc.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/irqdesc.h"
struct irq_affinity_notify;
struct proc_dir_entry;
struct module;
struct irq_desc;
struct irq_domain;
struct pt_regs;
# 56 "/home/nathan/src/linux-next/include/linux/irqdesc.h"
struct irq_desc {
 struct irq_common_data irq_common_data;
 struct irq_data irq_data;
 unsigned int *kstat_irqs;
 irq_flow_handler_t handle_irq;



 struct irqaction *action;
 unsigned int status_use_accessors;
 unsigned int core_internal_state__do_not_mess_with_it;
 unsigned int depth;
 unsigned int wake_depth;
 unsigned int tot_count;
 unsigned int irq_count;
 unsigned long last_unhandled;
 unsigned int irqs_unhandled;
 atomic_t threads_handled;
 int threads_handled_last;
 raw_spinlock_t lock;
 struct cpumask *percpu_enabled;
 const struct cpumask *percpu_affinity;

 const struct cpumask *affinity_hint;
 struct irq_affinity_notify *affinity_notify;




 unsigned long threads_oneshot;
 atomic_t threads_active;
 wait_queue_head_t wait_for_threads;

 unsigned int nr_actions;
 unsigned int no_suspend_depth;
 unsigned int cond_suspend_depth;
 unsigned int force_resume_depth;


 struct proc_dir_entry *dir;






 struct callback_head rcu;
 struct kobject kobj;

 struct mutex request_mutex;
 int parent_irq;
 struct module *owner;
 const char *name;
} __attribute__((__aligned__(1 << (7))));


extern void irq_lock_sparse(void);
extern void irq_unlock_sparse(void);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_desc *irq_data_to_desc(struct irq_data *data)
{
 return ({ void *__mptr = (void *)(data->common); do { extern void __compiletime_assert_122(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(data->common)), typeof(((struct irq_desc *)0)->irq_common_data)) && !__builtin_types_compatible_p(typeof(*(data->common)), typeof(void))))) __compiletime_assert_122(); } while (0); ((struct irq_desc *)(__mptr - __builtin_offsetof(struct irq_desc, irq_common_data))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int irq_desc_get_irq(struct irq_desc *desc)
{
 return desc->irq_data.irq;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
{
 return &desc->irq_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)
{
 return desc->irq_data.chip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_desc_get_chip_data(struct irq_desc *desc)
{
 return desc->irq_data.chip_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_desc_get_handler_data(struct irq_desc *desc)
{
 return desc->irq_common_data.handler_data;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void generic_handle_irq_desc(struct irq_desc *desc)
{
 desc->handle_irq(desc);
}

int generic_handle_irq(unsigned int irq);
# 184 "/home/nathan/src/linux-next/include/linux/irqdesc.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_desc_has_action(struct irq_desc *desc)
{
 return desc->action != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_has_action(unsigned int irq)
{
 return irq_desc_has_action(irq_to_desc(irq));
}
# 204 "/home/nathan/src/linux-next/include/linux/irqdesc.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_handler_locked(struct irq_data *data,
       irq_flow_handler_t handler)
{
 struct irq_desc *desc = irq_data_to_desc(data);

 desc->handle_irq = handler;
}
# 224 "/home/nathan/src/linux-next/include/linux/irqdesc.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
irq_set_chip_handler_name_locked(struct irq_data *data, struct irq_chip *chip,
     irq_flow_handler_t handler, const char *name)
{
 struct irq_desc *desc = irq_data_to_desc(data);

 desc->handle_irq = handler;
 desc->name = name;
 data->chip = chip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_balancing_disabled(unsigned int irq)
{
 struct irq_desc *desc;

 desc = irq_to_desc(irq);
 return desc->status_use_accessors & (IRQ_PER_CPU | IRQ_NO_BALANCING);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_is_percpu(unsigned int irq)
{
 struct irq_desc *desc;

 desc = irq_to_desc(irq);
 return desc->status_use_accessors & IRQ_PER_CPU;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool irq_is_percpu_devid(unsigned int irq)
{
 struct irq_desc *desc;

 desc = irq_to_desc(irq);
 return desc->status_use_accessors & IRQ_PER_CPU_DEVID;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
irq_set_lockdep_class(unsigned int irq, struct lock_class_key *lock_class,
        struct lock_class_key *request_class)
{
 struct irq_desc *desc = irq_to_desc(irq);

 if (desc) {
  do { (void)(lock_class); } while (0);
  do { (void)(request_class); } while (0);
 }
}
# 546 "/home/nathan/src/linux-next/include/linux/irq.h" 2
# 562 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irqaction;
extern int setup_irq(unsigned int irq, struct irqaction *new);
extern void remove_irq(unsigned int irq, struct irqaction *act);
extern int setup_percpu_irq(unsigned int irq, struct irqaction *new);
extern void remove_percpu_irq(unsigned int irq, struct irqaction *act);

extern void irq_cpu_online(void);
extern void irq_cpu_offline(void);
extern int irq_set_affinity_locked(struct irq_data *data,
       const struct cpumask *cpumask, bool force);
extern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);


extern void irq_migrate_all_off_this_cpu(void);
extern int irq_affinity_online_cpu(unsigned int cpu);
# 591 "/home/nathan/src/linux-next/include/linux/irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_move_irq(struct irq_data *data) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_move_masked_irq(struct irq_data *data) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_force_complete_move(struct irq_desc *desc) { }


extern int no_irq_affinity;


int irq_set_parent(int irq, int parent_irq);
# 611 "/home/nathan/src/linux-next/include/linux/irq.h"
extern void handle_level_irq(struct irq_desc *desc);
extern void handle_fasteoi_irq(struct irq_desc *desc);
extern void handle_edge_irq(struct irq_desc *desc);
extern void handle_edge_eoi_irq(struct irq_desc *desc);
extern void handle_simple_irq(struct irq_desc *desc);
extern void handle_untracked_irq(struct irq_desc *desc);
extern void handle_percpu_irq(struct irq_desc *desc);
extern void handle_percpu_devid_irq(struct irq_desc *desc);
extern void handle_bad_irq(struct irq_desc *desc);
extern void handle_nested_irq(unsigned int irq);

extern void handle_fasteoi_nmi(struct irq_desc *desc);
extern void handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc);

extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
extern int irq_chip_pm_get(struct irq_data *data);
extern int irq_chip_pm_put(struct irq_data *data);

extern void handle_fasteoi_ack_irq(struct irq_desc *desc);
extern void handle_fasteoi_mask_irq(struct irq_desc *desc);
extern int irq_chip_set_parent_state(struct irq_data *data,
         enum irqchip_irq_state which,
         bool val);
extern int irq_chip_get_parent_state(struct irq_data *data,
         enum irqchip_irq_state which,
         bool *state);
extern void irq_chip_enable_parent(struct irq_data *data);
extern void irq_chip_disable_parent(struct irq_data *data);
extern void irq_chip_ack_parent(struct irq_data *data);
extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
extern void irq_chip_mask_parent(struct irq_data *data);
extern void irq_chip_mask_ack_parent(struct irq_data *data);
extern void irq_chip_unmask_parent(struct irq_data *data);
extern void irq_chip_eoi_parent(struct irq_data *data);
extern int irq_chip_set_affinity_parent(struct irq_data *data,
     const struct cpumask *dest,
     bool force);
extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
          void *vcpu_info);
extern int irq_chip_set_type_parent(struct irq_data *data, unsigned int type);
extern int irq_chip_request_resources_parent(struct irq_data *data);
extern void irq_chip_release_resources_parent(struct irq_data *data);



extern void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret);



extern int noirqdebug_setup(char *str);


extern int can_request_irq(unsigned int irq, unsigned long irqflags);


extern struct irq_chip no_irq_chip;
extern struct irq_chip dummy_irq_chip;

extern void
irq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
         irq_flow_handler_t handle, const char *name);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *chip,
         irq_flow_handler_t handle)
{
 irq_set_chip_and_handler_name(irq, chip, handle, ((void *)0));
}

extern int irq_set_percpu_devid(unsigned int irq);
extern int irq_set_percpu_devid_partition(unsigned int irq,
       const struct cpumask *affinity);
extern int irq_get_percpu_devid_partition(unsigned int irq,
       struct cpumask *affinity);

extern void
__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
    const char *name);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
irq_set_handler(unsigned int irq, irq_flow_handler_t handle)
{
 __irq_set_handler(irq, handle, 0, ((void *)0));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
irq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)
{
 __irq_set_handler(irq, handle, 1, ((void *)0));
}






void
irq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,
     void *data);

void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_status_flags(unsigned int irq, unsigned long set)
{
 irq_modify_status(irq, 0, set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_clear_status_flags(unsigned int irq, unsigned long clr)
{
 irq_modify_status(irq, clr, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_noprobe(unsigned int irq)
{
 irq_modify_status(irq, 0, IRQ_NOPROBE);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_probe(unsigned int irq)
{
 irq_modify_status(irq, IRQ_NOPROBE, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_nothread(unsigned int irq)
{
 irq_modify_status(irq, 0, IRQ_NOTHREAD);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_thread(unsigned int irq)
{
 irq_modify_status(irq, IRQ_NOTHREAD, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_nested_thread(unsigned int irq, bool nest)
{
 if (nest)
  irq_set_status_flags(irq, IRQ_NESTED_THREAD);
 else
  irq_clear_status_flags(irq, IRQ_NESTED_THREAD);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_set_percpu_devid_flags(unsigned int irq)
{
 irq_set_status_flags(irq,
        IRQ_NOAUTOEN | IRQ_PER_CPU | IRQ_NOTHREAD |
        IRQ_NOPROBE | IRQ_PER_CPU_DEVID);
}


extern int irq_set_chip(unsigned int irq, struct irq_chip *chip);
extern int irq_set_handler_data(unsigned int irq, void *data);
extern int irq_set_chip_data(unsigned int irq, void *data);
extern int irq_set_irq_type(unsigned int irq, unsigned int type);
extern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);
extern int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,
    struct msi_desc *entry);
extern struct irq_data *irq_get_irq_data(unsigned int irq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_chip *irq_get_chip(unsigned int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);
 return d ? d->chip : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_chip *irq_data_get_irq_chip(struct irq_data *d)
{
 return d->chip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_get_chip_data(unsigned int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);
 return d ? d->chip_data : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_data_get_irq_chip_data(struct irq_data *d)
{
 return d->chip_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_get_handler_data(unsigned int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);
 return d ? d->common->handler_data : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *irq_data_get_irq_handler_data(struct irq_data *d)
{
 return d->common->handler_data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct msi_desc *irq_get_msi_desc(unsigned int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);
 return d ? d->common->msi_desc : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct msi_desc *irq_data_get_msi_desc(struct irq_data *d)
{
 return d->common->msi_desc;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 irq_get_trigger_type(unsigned int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);
 return d ? irqd_get_trigger_type(d) : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_common_data_get_node(struct irq_common_data *d)
{

 return d->node;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int irq_data_get_node(struct irq_data *d)
{
 return irq_common_data_get_node(d->common);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *irq_get_affinity_mask(int irq)
{
 struct irq_data *d = irq_get_irq_data(irq);

 return d ? d->common->affinity : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
{
 return d->common->affinity;
}
# 861 "/home/nathan/src/linux-next/include/linux/irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_data_update_effective_affinity(struct irq_data *d,
            const struct cpumask *m)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
{
 return d->common->affinity;
}


unsigned int arch_dynirq_lower_bound(unsigned int from);

int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
        struct module *owner,
        const struct irq_affinity_desc *affinity);

int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
      unsigned int cnt, int node, struct module *owner,
      const struct irq_affinity_desc *affinity);
# 913 "/home/nathan/src/linux-next/include/linux/irq.h"
void irq_free_descs(unsigned int irq, unsigned int cnt);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_free_desc(unsigned int irq)
{
 irq_free_descs(irq, 1);
}
# 948 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_chip_regs {
 unsigned long enable;
 unsigned long disable;
 unsigned long mask;
 unsigned long ack;
 unsigned long eoi;
 unsigned long type;
 unsigned long polarity;
};
# 971 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_chip_type {
 struct irq_chip chip;
 struct irq_chip_regs regs;
 irq_flow_handler_t handler;
 u32 type;
 u32 mask_cache_priv;
 u32 *mask_cache;
};
# 1013 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_chip_generic {
 raw_spinlock_t lock;
 void *reg_base;
 u32 (*reg_readl)(void *addr);
 void (*reg_writel)(u32 val, void *addr);
 void (*suspend)(struct irq_chip_generic *gc);
 void (*resume)(struct irq_chip_generic *gc);
 unsigned int irq_base;
 unsigned int irq_cnt;
 u32 mask_cache;
 u32 type_cache;
 u32 polarity_cache;
 u32 wake_enabled;
 u32 wake_active;
 unsigned int num_ct;
 void *private;
 unsigned long installed;
 unsigned long unused;
 struct irq_domain *domain;
 struct list_head list;
 struct irq_chip_type chip_types[0];
};
# 1046 "/home/nathan/src/linux-next/include/linux/irq.h"
enum irq_gc_flags {
 IRQ_GC_INIT_MASK_CACHE = 1 << 0,
 IRQ_GC_INIT_NESTED_LOCK = 1 << 1,
 IRQ_GC_MASK_CACHE_PER_TYPE = 1 << 2,
 IRQ_GC_NO_MASK = 1 << 3,
 IRQ_GC_BE_IO = 1 << 4,
};
# 1063 "/home/nathan/src/linux-next/include/linux/irq.h"
struct irq_domain_chip_generic {
 unsigned int irqs_per_chip;
 unsigned int num_chips;
 unsigned int irq_flags_to_clear;
 unsigned int irq_flags_to_set;
 enum irq_gc_flags gc_flags;
 struct irq_chip_generic *gc[0];
};


void irq_gc_noop(struct irq_data *d);
void irq_gc_mask_disable_reg(struct irq_data *d);
void irq_gc_mask_set_bit(struct irq_data *d);
void irq_gc_mask_clr_bit(struct irq_data *d);
void irq_gc_unmask_enable_reg(struct irq_data *d);
void irq_gc_ack_set_bit(struct irq_data *d);
void irq_gc_ack_clr_bit(struct irq_data *d);
void irq_gc_mask_disable_and_ack_set(struct irq_data *d);
void irq_gc_eoi(struct irq_data *d);
int irq_gc_set_wake(struct irq_data *d, unsigned int on);


int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,
    irq_hw_number_t hw_irq);
struct irq_chip_generic *
irq_alloc_generic_chip(const char *name, int nr_ct, unsigned int irq_base,
         void *reg_base, irq_flow_handler_t handler);
void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,
       enum irq_gc_flags flags, unsigned int clr,
       unsigned int set);
int irq_setup_alt_chip(struct irq_data *d, unsigned int type);
void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,
        unsigned int clr, unsigned int set);

struct irq_chip_generic *
devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
       unsigned int irq_base, void *reg_base,
       irq_flow_handler_t handler);
int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,
    u32 msk, enum irq_gc_flags flags,
    unsigned int clr, unsigned int set);

struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);

int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,
         int num_ct, const char *name,
         irq_flow_handler_t handler,
         unsigned int clr, unsigned int set,
         enum irq_gc_flags flags);
# 1121 "/home/nathan/src/linux-next/include/linux/irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_free_generic_chip(struct irq_chip_generic *gc)
{
 kfree(gc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_destroy_generic_chip(struct irq_chip_generic *gc,
         u32 msk, unsigned int clr,
         unsigned int set)
{
 irq_remove_generic_chip(gc, msk, clr, set);
 irq_free_generic_chip(gc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
{
 return ({ void *__mptr = (void *)(d->chip); do { extern void __compiletime_assert_1136(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(d->chip)), typeof(((struct irq_chip_type *)0)->chip)) && !__builtin_types_compatible_p(typeof(*(d->chip)), typeof(void))))) __compiletime_assert_1136(); } while (0); ((struct irq_chip_type *)(__mptr - __builtin_offsetof(struct irq_chip_type, chip))); });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_gc_lock(struct irq_chip_generic *gc)
{
 _raw_spin_lock(&gc->lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_gc_unlock(struct irq_chip_generic *gc)
{
 __raw_spin_unlock(&gc->lock);
}
# 1166 "/home/nathan/src/linux-next/include/linux/irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void irq_reg_writel(struct irq_chip_generic *gc,
      u32 val, int reg_offset)
{
 if (gc->reg_writel)
  gc->reg_writel(val, gc->reg_base + reg_offset);
 else
  writel(val, gc->reg_base + reg_offset);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 irq_reg_readl(struct irq_chip_generic *gc,
    int reg_offset)
{
 if (gc->reg_readl)
  return gc->reg_readl(gc->reg_base + reg_offset);
 else
  return readl(gc->reg_base + reg_offset);
}

struct irq_matrix;
struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,
        unsigned int alloc_start,
        unsigned int alloc_end);
void irq_matrix_online(struct irq_matrix *m);
void irq_matrix_offline(struct irq_matrix *m);
void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit, bool replace);
int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk);
void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk);
int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,
    unsigned int *mapped_cpu);
void irq_matrix_reserve(struct irq_matrix *m);
void irq_matrix_remove_reserved(struct irq_matrix *m);
int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
       bool reserved, unsigned int *mapped_cpu);
void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
       unsigned int bit, bool managed);
void irq_matrix_assign(struct irq_matrix *m, unsigned int bit);
unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown);
unsigned int irq_matrix_allocated(struct irq_matrix *m);
unsigned int irq_matrix_reserved(struct irq_matrix *m);
void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind);



irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu);
int __ipi_send_single(struct irq_desc *desc, unsigned int cpu);
int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest);
int ipi_send_single(unsigned int virq, unsigned int cpu);
int ipi_send_mask(unsigned int virq, const struct cpumask *dest);
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/hardirq.h" 2

typedef struct {
 unsigned int __softirq_pending;
 unsigned int timer_irqs_event;
 unsigned int broadcast_irqs_event;
 unsigned int timer_irqs_others;
 unsigned int pmu_irqs;
 unsigned int mce_exceptions;
 unsigned int spurious_irqs;
 unsigned int hmi_exceptions;
 unsigned int sreset_irqs;

 unsigned int soft_nmi_irqs;


 unsigned int doorbell_irqs;

} __attribute__((__aligned__((1 << 7)))) irq_cpustat_t;

extern __attribute__((section(".data..percpu" ""))) __typeof__(irq_cpustat_t) irq_stat __attribute__((__aligned__((1 << 7))));




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ack_bad_irq(unsigned int irq)
{
 printk("\001" "2" "unexpected IRQ trap at vector %02x\n", irq);
}

extern u64 arch_irq_stat_cpu(unsigned int cpu);
# 10 "/home/nathan/src/linux-next/include/linux/hardirq.h" 2


extern void synchronize_irq(unsigned int irq);
extern bool synchronize_hardirq(unsigned int irq);
# 26 "/home/nathan/src/linux-next/include/linux/hardirq.h"
extern void rcu_nmi_enter(void);
extern void rcu_nmi_exit(void);
# 46 "/home/nathan/src/linux-next/include/linux/hardirq.h"
extern void irq_enter(void);
# 61 "/home/nathan/src/linux-next/include/linux/hardirq.h"
extern void irq_exit(void);
# 12 "/home/nathan/src/linux-next/include/linux/interrupt.h" 2







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/interrupt.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sections.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/uaccess.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/uaccess.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 1







# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/extable.h" 1
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/asm/extable.h"
struct exception_table_entry {
 int insn;
 int fixup;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long extable_fixup(const struct exception_table_entry *x)
{
 return (unsigned long)&x->fixup + x->fixup;
}
# 9 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/kup-radix.h" 1
# 66 "/home/nathan/src/linux-next/arch/powerpc/include/asm/book3s/64/kup-radix.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_kuap(void)
{
 if (!early_mmu_has_feature(0x80000000UL))
  return 0;

 return ({unsigned long rval; asm volatile("mfspr %0," "0x1d" : "=r" (rval)); rval;});
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_kuap(unsigned long value)
{
 if (!early_mmu_has_feature(0x80000000UL))
  return;





 isync();
 asm volatile("mtspr " "0x1d" ",%0" : : "r" ((unsigned long)(value)) : "memory");
 isync();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void allow_user_access(void *to, const void *from,
           unsigned long size, unsigned long dir)
{

 do { extern void __compiletime_assert_92(void) ; if (!(!(!__builtin_constant_p(dir)))) __compiletime_assert_92(); } while (0);
 if (dir == 1)
  set_kuap((((0x8000000000000000UL))));
 else if (dir == 2)
  set_kuap((((0x4000000000000000UL))));
 else if (dir == (1 | 2))
  set_kuap(0);
 else
  do { extern void __compiletime_assert_100(void) ; if (!(!(1))) __compiletime_assert_100(); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_user_access(void *to, const void *from,
           unsigned long size, unsigned long dir)
{
 set_kuap(((((0x4000000000000000UL))) | (((0x8000000000000000UL)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long prevent_user_access_return(void)
{
 unsigned long flags = get_kuap();

 set_kuap(((((0x4000000000000000UL))) | (((0x8000000000000000UL)))));

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_user_access(unsigned long flags)
{
 set_kuap(flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
bad_kuap_fault(struct pt_regs *regs, unsigned long address, bool is_write)
{
 return ({ int __ret_warn_on = !!(mmu_has_feature(0x80000000UL) && (regs->kuap & (is_write ? (((0x8000000000000000UL))) : (((0x4000000000000000UL)))))); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("Bug: %s fault blocked by AMR!", is_write ? "Write" : "Read"); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("arch/powerpc/include/asm/book3s/64/kup-radix.h"), "i" (128), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); });


}
# 17 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h" 2
# 42 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
void setup_kup(void);


void setup_kuep(bool disabled);





void setup_kuap(bool disabled);
# 67 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_read_from_user(const void *from, unsigned long size)
{
 allow_user_access(((void *)0), from, size, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_write_to_user(void *to, unsigned long size)
{
 allow_user_access(to, ((void *)0), size, 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_read_write_user(void *to, const void *from,
      unsigned long size)
{
 allow_user_access(to, from, size, (1 | 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_read_from_user(const void *from, unsigned long size)
{
 prevent_user_access(((void *)0), from, size, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_write_to_user(void *to, unsigned long size)
{
 prevent_user_access(to, ((void *)0), size, 2);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_read_write_user(void *to, const void *from,
        unsigned long size)
{
 prevent_user_access(to, from, size, (1 | 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prevent_current_access_user(void)
{
 prevent_user_access(((void *)0), ((void *)0), ~0UL, 4);
}
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h" 2
# 34 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_fs(mm_segment_t fs)
{
 get_current()->thread.addr_limit = fs;

 set_ti_thread_flag(((struct thread_info *)get_current()), 3);
}
# 108 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern long __put_user_bad(void);
# 199 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern long __get_user_bad(void);
# 327 "/home/nathan/src/linux-next/arch/powerpc/include/asm/uaccess.h"
extern unsigned long __copy_tofrom_user(void *to,
  const void *from, unsigned long size);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_in_user(void *to, const void *from, unsigned long n)
{
 unsigned long ret;

 asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
 allow_read_write_user(to, from, n);
 ret = __copy_tofrom_user(to, from, n);
 prevent_read_write_user(to, from, n);
 return ret;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long raw_copy_from_user(void *to,
  const void *from, unsigned long n)
{
 unsigned long ret;
 if (__builtin_constant_p(n) && (n <= 8)) {
  ret = 1;

  switch (n) {
  case 1:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 1); do { ret = 0; (void)0; if (1 > sizeof(*(u8 *)to)) (*(u8 *)to) = __get_user_bad(); switch (1) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u8 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u8 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 1); } while (0);
   break;
  case 2:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 2); do { ret = 0; (void)0; if (2 > sizeof(*(u16 *)to)) (*(u16 *)to) = __get_user_bad(); switch (2) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u16 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u16 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 2); } while (0);
   break;
  case 4:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 4); do { ret = 0; (void)0; if (4 > sizeof(*(u32 *)to)) (*(u32 *)to) = __get_user_bad(); switch (4) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u32 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u32 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 4); } while (0);
   break;
  case 8:
   asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
   do { allow_read_from_user(from, 8); do { ret = 0; (void)0; if (8 > sizeof(*(u64 *)to)) (*(u64 *)to) = __get_user_bad(); switch (8) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret), "=r" (*(u64 *)to) : "b" (from), "i" (-14), "0" (ret)); break; default: (*(u64 *)to) = __get_user_bad(); } } while (0); prevent_read_from_user(from, 8); } while (0);
   break;
  }
  if (ret == 0)
   return 0;
 }

 asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory");
 allow_read_from_user(from, n);
 ret = __copy_tofrom_user(( void *)to, from, n);
 prevent_read_from_user(from, n);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_to_user_allowed(void *to, const void *from, unsigned long n)
{
 if (__builtin_constant_p(n) && (n <= 8)) {
  unsigned long ret = 1;

  switch (n) {
  case 1:
   do { ret = 0; switch (1) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u8 *)from), "b" ((u8 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 2:
   do { ret = 0; switch (2) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u16 *)from), "b" ((u16 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 4:
   do { ret = 0; switch (4) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u32 *)from), "b" ((u32 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  case 8:
   do { ret = 0; switch (8) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (ret) : "r" (*(u64 *)from), "b" ((u64 *)to), "i" (-14), "0" (ret)); break; default: __put_user_bad(); } } while (0);
   break;
  }
  if (ret == 0)
   return 0;
 }

 return __copy_tofrom_user(to, ( const void *)from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
raw_copy_to_user(void *to, const void *from, unsigned long n)
{
 unsigned long ret;

 allow_write_to_user(to, n);
 ret = raw_copy_to_user_allowed(to, from, n);
 prevent_write_to_user(to, n);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_to_user_mcsafe(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(from, n, true)), 1)) {
  if (((void)0, (((( unsigned long)(to)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg)))) {
   allow_write_to_user(to, n);
   n = memcpy_mcsafe((void *)to, from, n);
   prevent_write_to_user(to, n);
  }
 }

 return n;
}

unsigned long __arch_clear_user(void *addr, unsigned long size);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long clear_user(void *addr, unsigned long size)
{
 unsigned long ret = size;
 might_fault();
 if (__builtin_expect(!!(((void)0, (((( unsigned long)(addr)) <= ((get_current()->thread.addr_limit)).seg) && (((size)) <= ((get_current()->thread.addr_limit)).seg)))), 1)) {
  allow_write_to_user(addr, size);
  ret = __arch_clear_user(addr, size);
  prevent_write_to_user(addr, size);
 }
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long __clear_user(void *addr, unsigned long size)
{
 return clear_user(addr, size);
}

extern long strncpy_from_user(char *dst, const char *src, long count);
extern __attribute__((__warn_unused_result__)) long strnlen_user(const char *str, long n);

extern long __copy_from_user_flushcache(void *dst, const void *src,
  unsigned size);
extern void memcpy_page_flushcache(char *to, struct page *page, size_t offset,
      size_t len);

static __attribute__((__warn_unused_result__)) inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool user_access_begin(const void *ptr, size_t len)
{
 if (__builtin_expect(!!(!((void)0, (((( unsigned long)(ptr)) <= ((get_current()->thread.addr_limit)).seg) && (((len)) <= ((get_current()->thread.addr_limit)).seg)))), 0))
  return false;
 allow_read_write_user((void *)ptr, ptr, len);
 return true;
}
# 12 "/home/nathan/src/linux-next/include/linux/uaccess.h" 2
# 58 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user_inatomic(void *to, const void *from, unsigned long n)
{
 kasan_check_write(to, n);
 check_object_size(to, n, false);
 return raw_copy_from_user(to, from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 kasan_check_write(to, n);
 check_object_size(to, n, false);
 return raw_copy_from_user(to, from, n);
}
# 88 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_to_user_inatomic(void *to, const void *from, unsigned long n)
{
 kasan_check_read(from, n);
 check_object_size(from, n, true);
 return raw_copy_to_user(to, from, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_to_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 kasan_check_read(from, n);
 check_object_size(from, n, true);
 return raw_copy_to_user(to, from, n);
}
# 120 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern __attribute__((__warn_unused_result__)) unsigned long
_copy_from_user(void *, const void *, unsigned long);
# 136 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern __attribute__((__warn_unused_result__)) unsigned long
_copy_to_user(void *, const void *, unsigned long);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_from_user(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(to, n, false)), 1))
  n = _copy_from_user(to, from, n);
 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_to_user(void *to, const void *from, unsigned long n)
{
 if (__builtin_expect(!!(check_copy_size(from, n, true)), 1))
  n = _copy_to_user(to, from, n);
 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned long __attribute__((__warn_unused_result__))
copy_in_user(void *to, const void *from, unsigned long n)
{
 might_fault();
 if (((void)0, (((( unsigned long)(to)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg))) && ((void)0, (((( unsigned long)(from)) <= ((get_current()->thread.addr_limit)).seg) && (((n)) <= ((get_current()->thread.addr_limit)).seg))))
  n = raw_copy_in_user(to, from, n);
 return n;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void pagefault_disabled_inc(void)
{
 get_current()->pagefault_disabled++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void pagefault_disabled_dec(void)
{
 get_current()->pagefault_disabled--;
}
# 183 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pagefault_disable(void)
{
 pagefault_disabled_inc();




 __asm__ __volatile__("" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pagefault_enable(void)
{




 __asm__ __volatile__("" : : : "memory");
 pagefault_disabled_dec();
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pagefault_disabled(void)
{
 return get_current()->pagefault_disabled != 0;
}
# 225 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) unsigned long
__copy_from_user_inatomic_nocache(void *to, const void *from,
      unsigned long n)
{
 return __copy_from_user_inatomic(to, from, n);
}



extern __attribute__((__warn_unused_result__)) int check_zeroed_user(const void *from, size_t size);
# 283 "/home/nathan/src/linux-next/include/linux/uaccess.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__)) int
copy_struct_from_user(void *dst, size_t ksize, const void *src,
        size_t usize)
{
 size_t size = __builtin_choose_expr(((!!(sizeof((typeof(ksize) *)1 == (typeof(usize) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(ksize) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(usize) * 0l)) : (int *)8))))), ((ksize) < (usize) ? (ksize) : (usize)), ({ typeof(ksize) __UNIQUE_ID___x16 = (ksize); typeof(usize) __UNIQUE_ID___y17 = (usize); ((__UNIQUE_ID___x16) < (__UNIQUE_ID___y17) ? (__UNIQUE_ID___x16) : (__UNIQUE_ID___y17)); }));
 size_t rest = __builtin_choose_expr(((!!(sizeof((typeof(ksize) *)1 == (typeof(usize) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(ksize) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(usize) * 0l)) : (int *)8))))), ((ksize) > (usize) ? (ksize) : (usize)), ({ typeof(ksize) __UNIQUE_ID___x18 = (ksize); typeof(usize) __UNIQUE_ID___y19 = (usize); ((__UNIQUE_ID___x18) > (__UNIQUE_ID___y19) ? (__UNIQUE_ID___x18) : (__UNIQUE_ID___y19)); })) - size;


 if (usize < ksize) {
  memset(dst + size, 0, rest);
 } else if (usize > ksize) {
  int ret = check_zeroed_user(src + size, rest);
  if (ret <= 0)
   return ret ?: -7;
 }

 if (copy_from_user(dst, src, size))
  return -14;
 return 0;
}
# 313 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern long probe_kernel_read(void *dst, const void *src, size_t size);
extern long probe_kernel_read_strict(void *dst, const void *src, size_t size);
extern long __probe_kernel_read(void *dst, const void *src, size_t size);
# 326 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern long probe_user_read(void *dst, const void *src, size_t size);
extern long __probe_user_read(void *dst, const void *src, size_t size);
# 338 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern long __attribute__((__no_instrument_function__)) probe_kernel_write(void *dst, const void *src, size_t size);
extern long __attribute__((__no_instrument_function__)) __probe_kernel_write(void *dst, const void *src, size_t size);
# 350 "/home/nathan/src/linux-next/include/linux/uaccess.h"
extern long __attribute__((__no_instrument_function__)) probe_user_write(void *dst, const void *src, size_t size);
extern long __attribute__((__no_instrument_function__)) __probe_user_write(void *dst, const void *src, size_t size);

extern long strncpy_from_unsafe(char *dst, const void *unsafe_addr, long count);
extern long strncpy_from_unsafe_strict(char *dst, const void *unsafe_addr,
           long count);
extern long __strncpy_from_unsafe(char *dst, const void *unsafe_addr, long count);
extern long strncpy_from_unsafe_user(char *dst, const void *unsafe_addr,
         long count);
extern long strnlen_unsafe_user(const void *unsafe_addr, long count);
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sections.h" 2



# 1 "/home/nathan/src/linux-next/include/asm-generic/sections.h" 1
# 35 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
extern char _text[], _stext[], _etext[];
extern char _data[], _sdata[], _edata[];
extern char __bss_start[], __bss_stop[];
extern char __init_begin[], __init_end[];
extern char _sinittext[], _einittext[];
extern char __start_ro_after_init[], __end_ro_after_init[];
extern char _end[];
extern char __per_cpu_load[], __per_cpu_start[], __per_cpu_end[];
extern char __kprobes_text_start[], __kprobes_text_end[];
extern char __entry_text_start[], __entry_text_end[];
extern char __start_rodata[], __end_rodata[];
extern char __irqentry_text_start[], __irqentry_text_end[];
extern char __softirqentry_text_start[], __softirqentry_text_end[];
extern char __start_once[], __end_once[];


extern char __ctors_start[], __ctors_end[];


extern char __start_opd[], __end_opd[];

extern const void __nosave_begin, __nosave_end;
# 67 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_is_kernel_text(unsigned long addr)
{
 return 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_is_kernel_data(unsigned long addr)
{
 return 0;
}
# 105 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool memory_contains(void *begin, void *end, void *virt,
       size_t size)
{
 return virt >= begin && virt + size <= end;
}
# 122 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool memory_intersects(void *begin, void *end, void *virt,
         size_t size)
{
 void *vend = virt + size;

 return (virt >= begin && virt < end) || (vend >= begin && vend < end);
}
# 139 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool init_section_contains(void *virt, size_t size)
{
 return memory_contains(__init_begin, __init_end, virt, size);
}
# 153 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool init_section_intersects(void *virt, size_t size)
{
 return memory_intersects(__init_begin, __init_end, virt, size);
}
# 166 "/home/nathan/src/linux-next/include/asm-generic/sections.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_kernel_rodata(unsigned long addr)
{
 return addr >= (unsigned long)__start_rodata &&
        addr < (unsigned long)__end_rodata;
}
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/sections.h" 2

extern bool init_mem_is_free;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int arch_is_kernel_initmem_freed(unsigned long addr)
{
 if (!init_mem_is_free)
  return 0;

 return addr >= (unsigned long)__init_begin &&
  addr < (unsigned long)__init_end;
}

extern char __head_end[];



extern char __start_interrupts[];
extern char __end_interrupts[];

extern char __prom_init_toc_start[];
extern char __prom_init_toc_end[];


extern char start_real_trampolines[];
extern char end_real_trampolines[];
extern char start_virt_trampolines[];
extern char end_virt_trampolines[];


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int in_kernel_text(unsigned long addr)
{
 if (addr >= (unsigned long)_stext && addr < (unsigned long)__init_end)
  return 1;

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long kernel_toc_addr(void)
{

 extern unsigned long __toc_start;





 return (unsigned long)(&__toc_start) + 0x8000UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int overlaps_interrupt_vector_text(unsigned long start,
       unsigned long end)
{
 unsigned long real_start, real_end;
 real_start = __start_interrupts - _stext;
 real_end = __end_interrupts - _stext;

 return start < (unsigned long)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(real_end) | 0xc000000000000000UL); }) &&
  (unsigned long)({ do { } while (0); (void *)(unsigned long)((phys_addr_t)(real_start) | 0xc000000000000000UL); }) < end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int overlaps_kernel_text(unsigned long start, unsigned long end)
{
 return start < (unsigned long)__init_end &&
  (unsigned long)_stext < end;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dereference_function_descriptor(void *ptr)
{
 struct ppc64_opd_entry *desc = ptr;
 void *p;

 if (!probe_kernel_read(&p, &desc->funcaddr, sizeof(p)))
  ptr = p;
 return ptr;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dereference_kernel_function_descriptor(void *ptr)
{
 if (ptr < (void *)__start_opd || ptr >= (void *)__end_opd)
  return ptr;

 return dereference_function_descriptor(ptr);
}
# 21 "/home/nathan/src/linux-next/include/linux/interrupt.h" 2
# 87 "/home/nathan/src/linux-next/include/linux/interrupt.h"
enum {
 IRQC_IS_HARDIRQ = 0,
 IRQC_IS_NESTED,
};

typedef irqreturn_t (*irq_handler_t)(int, void *);
# 110 "/home/nathan/src/linux-next/include/linux/interrupt.h"
struct irqaction {
 irq_handler_t handler;
 void *dev_id;
 void *percpu_dev_id;
 struct irqaction *next;
 irq_handler_t thread_fn;
 struct task_struct *thread;
 struct irqaction *secondary;
 unsigned int irq;
 unsigned int flags;
 unsigned long thread_flags;
 unsigned long thread_mask;
 const char *name;
 struct proc_dir_entry *dir;
} __attribute__((__aligned__(1 << (7))));

extern irqreturn_t no_action(int cpl, void *dev_id);
# 138 "/home/nathan/src/linux-next/include/linux/interrupt.h"
extern int __attribute__((__warn_unused_result__))
request_threaded_irq(unsigned int irq, irq_handler_t handler,
       irq_handler_t thread_fn,
       unsigned long flags, const char *name, void *dev);
# 156 "/home/nathan/src/linux-next/include/linux/interrupt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__))
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
     const char *name, void *dev)
{
 return request_threaded_irq(irq, handler, ((void *)0), flags, name, dev);
}

extern int __attribute__((__warn_unused_result__))
request_any_context_irq(unsigned int irq, irq_handler_t handler,
   unsigned long flags, const char *name, void *dev_id);

extern int __attribute__((__warn_unused_result__))
__request_percpu_irq(unsigned int irq, irq_handler_t handler,
       unsigned long flags, const char *devname,
       void *percpu_dev_id);

extern int __attribute__((__warn_unused_result__))
request_nmi(unsigned int irq, irq_handler_t handler, unsigned long flags,
     const char *name, void *dev);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__))
request_percpu_irq(unsigned int irq, irq_handler_t handler,
     const char *devname, void *percpu_dev_id)
{
 return __request_percpu_irq(irq, handler, 0,
        devname, percpu_dev_id);
}

extern int __attribute__((__warn_unused_result__))
request_percpu_nmi(unsigned int irq, irq_handler_t handler,
     const char *devname, void *dev);

extern const void *free_irq(unsigned int, void *);
extern void free_percpu_irq(unsigned int, void *);

extern const void *free_nmi(unsigned int irq, void *dev_id);
extern void free_percpu_nmi(unsigned int irq, void *percpu_dev_id);

struct device;

extern int __attribute__((__warn_unused_result__))
devm_request_threaded_irq(struct device *dev, unsigned int irq,
     irq_handler_t handler, irq_handler_t thread_fn,
     unsigned long irqflags, const char *devname,
     void *dev_id);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __attribute__((__warn_unused_result__))
devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
   unsigned long irqflags, const char *devname, void *dev_id)
{
 return devm_request_threaded_irq(dev, irq, handler, ((void *)0), irqflags,
      devname, dev_id);
}

extern int __attribute__((__warn_unused_result__))
devm_request_any_context_irq(struct device *dev, unsigned int irq,
   irq_handler_t handler, unsigned long irqflags,
   const char *devname, void *dev_id);

extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
# 235 "/home/nathan/src/linux-next/include/linux/interrupt.h"
extern void disable_irq_nosync(unsigned int irq);
extern bool disable_hardirq(unsigned int irq);
extern void disable_irq(unsigned int irq);
extern void disable_percpu_irq(unsigned int irq);
extern void enable_irq(unsigned int irq);
extern void enable_percpu_irq(unsigned int irq, unsigned int type);
extern bool irq_percpu_is_enabled(unsigned int irq);
extern void irq_wake_thread(unsigned int irq, void *dev_id);

extern void disable_nmi_nosync(unsigned int irq);
extern void disable_percpu_nmi(unsigned int irq);
extern void enable_nmi(unsigned int irq);
extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
extern int prepare_percpu_nmi(unsigned int irq);
extern void teardown_percpu_nmi(unsigned int irq);


extern void suspend_device_irqs(void);
extern void resume_device_irqs(void);
extern void rearm_wake_irq(unsigned int irq);
# 268 "/home/nathan/src/linux-next/include/linux/interrupt.h"
struct irq_affinity_notify {
 unsigned int irq;
 struct kref kref;
 struct work_struct work;
 void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
 void (*release)(struct kref *ref);
};
# 292 "/home/nathan/src/linux-next/include/linux/interrupt.h"
struct irq_affinity {
 unsigned int pre_vectors;
 unsigned int post_vectors;
 unsigned int nr_sets;
 unsigned int set_size[4];
 void (*calc_sets)(struct irq_affinity *, unsigned int nvecs);
 void *priv;
};






struct irq_affinity_desc {
 struct cpumask mask;
 unsigned int is_managed : 1;
};



extern cpumask_var_t irq_default_affinity;


extern int __irq_set_affinity(unsigned int irq, const struct cpumask *cpumask,
         bool force);
# 326 "/home/nathan/src/linux-next/include/linux/interrupt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)
{
 return __irq_set_affinity(irq, cpumask, false);
}
# 343 "/home/nathan/src/linux-next/include/linux/interrupt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
{
 return __irq_set_affinity(irq, cpumask, true);
}

extern int irq_can_set_affinity(unsigned int irq);
extern int irq_select_affinity(unsigned int irq);

extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);

extern int
irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);

struct irq_affinity_desc *
irq_create_affinity_masks(unsigned int nvec, struct irq_affinity *affd);

unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
           const struct irq_affinity *affd);
# 420 "/home/nathan/src/linux-next/include/linux/interrupt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_irq_nosync_lockdep(unsigned int irq)
{
 disable_irq_nosync(irq);



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_irq_nosync_lockdep_irqsave(unsigned int irq, unsigned long *flags)
{
 disable_irq_nosync(irq);



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_irq_lockdep(unsigned int irq)
{
 disable_irq(irq);



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void enable_irq_lockdep(unsigned int irq)
{



 enable_irq(irq);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long *flags)
{



 enable_irq(irq);
}


extern int irq_set_irq_wake(unsigned int irq, unsigned int on);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int enable_irq_wake(unsigned int irq)
{
 return irq_set_irq_wake(irq, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int disable_irq_wake(unsigned int irq)
{
 return irq_set_irq_wake(irq, 0);
}




enum irqchip_irq_state {
 IRQCHIP_STATE_PENDING,
 IRQCHIP_STATE_ACTIVE,
 IRQCHIP_STATE_MASKED,
 IRQCHIP_STATE_LINE_LEVEL,
};

extern int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
     bool *state);
extern int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
     bool state);





extern bool force_irqthreads;
# 526 "/home/nathan/src/linux-next/include/linux/interrupt.h"
enum
{
 HI_SOFTIRQ=0,
 TIMER_SOFTIRQ,
 NET_TX_SOFTIRQ,
 NET_RX_SOFTIRQ,
 BLOCK_SOFTIRQ,
 IRQ_POLL_SOFTIRQ,
 TASKLET_SOFTIRQ,
 SCHED_SOFTIRQ,
 HRTIMER_SOFTIRQ,
 RCU_SOFTIRQ,

 NR_SOFTIRQS
};






extern const char * const softirq_to_name[NR_SOFTIRQS];





struct softirq_action
{
 void (*action)(struct softirq_action *);
};

           void do_softirq(void);
           void __do_softirq(void);


void do_softirq_own_stack(void);







extern void open_softirq(int nr, void (*action)(struct softirq_action *));
extern void softirq_init(void);
extern void __raise_softirq_irqoff(unsigned int nr);

extern void raise_softirq_irqoff(unsigned int nr);
extern void raise_softirq(unsigned int nr);

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct task_struct *) ksoftirqd;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *this_cpu_ksoftirqd(void)
{
 return ({ typeof(ksoftirqd) pscr_ret__; do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(ksoftirqd)) { case 1: pscr_ret__ = ({ typeof(ksoftirqd) __ret; if ((sizeof(ksoftirqd) == sizeof(char) || sizeof(ksoftirqd) == sizeof(short) || sizeof(ksoftirqd) == sizeof(int) || sizeof(ksoftirqd) == sizeof(long))) __ret = ({ typeof(ksoftirqd) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(ksoftirqd) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 2: pscr_ret__ = ({ typeof(ksoftirqd) __ret; if ((sizeof(ksoftirqd) == sizeof(char) || sizeof(ksoftirqd) == sizeof(short) || sizeof(ksoftirqd) == sizeof(int) || sizeof(ksoftirqd) == sizeof(long))) __ret = ({ typeof(ksoftirqd) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(ksoftirqd) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 4: pscr_ret__ = ({ typeof(ksoftirqd) __ret; if ((sizeof(ksoftirqd) == sizeof(char) || sizeof(ksoftirqd) == sizeof(short) || sizeof(ksoftirqd) == sizeof(int) || sizeof(ksoftirqd) == sizeof(long))) __ret = ({ typeof(ksoftirqd) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(ksoftirqd) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 8: pscr_ret__ = ({ typeof(ksoftirqd) __ret; if ((sizeof(ksoftirqd) == sizeof(char) || sizeof(ksoftirqd) == sizeof(short) || sizeof(ksoftirqd) == sizeof(int) || sizeof(ksoftirqd) == sizeof(long))) __ret = ({ typeof(ksoftirqd) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(ksoftirqd) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(ksoftirqd)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd))); (typeof((typeof(*(&(ksoftirqd))) *)(&(ksoftirqd)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}
# 604 "/home/nathan/src/linux-next/include/linux/interrupt.h"
struct tasklet_struct
{
 struct tasklet_struct *next;
 unsigned long state;
 atomic_t count;
 void (*func)(unsigned long);
 unsigned long data;
};
# 620 "/home/nathan/src/linux-next/include/linux/interrupt.h"
enum
{
 TASKLET_STATE_SCHED,
 TASKLET_STATE_RUN
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tasklet_trylock(struct tasklet_struct *t)
{
 return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_unlock(struct tasklet_struct *t)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 clear_bit(TASKLET_STATE_RUN, &(t)->state);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_unlock_wait(struct tasklet_struct *t)
{
 while (test_bit(TASKLET_STATE_RUN, &(t)->state)) { __asm__ __volatile__("" : : : "memory"); }
}






extern void __tasklet_schedule(struct tasklet_struct *t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_schedule(struct tasklet_struct *t)
{
 if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
  __tasklet_schedule(t);
}

extern void __tasklet_hi_schedule(struct tasklet_struct *t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_hi_schedule(struct tasklet_struct *t)
{
 if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
  __tasklet_hi_schedule(t);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_disable_nosync(struct tasklet_struct *t)
{
 atomic_inc(&t->count);
 __asm__ __volatile__ ("sync" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_disable(struct tasklet_struct *t)
{
 tasklet_disable_nosync(t);
 tasklet_unlock_wait(t);
 __asm__ __volatile__ ("sync" : : : "memory");
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tasklet_enable(struct tasklet_struct *t)
{
 __asm__ __volatile__ ("sync" : : : "memory");
 atomic_dec(&t->count);
}

extern void tasklet_kill(struct tasklet_struct *t);
extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
extern void tasklet_init(struct tasklet_struct *t,
    void (*func)(unsigned long), unsigned long data);
# 717 "/home/nathan/src/linux-next/include/linux/interrupt.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long probe_irq_on(void)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int probe_irq_off(unsigned long val)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int probe_irq_mask(unsigned long val)
{
 return 0;
}
# 737 "/home/nathan/src/linux-next/include/linux/interrupt.h"
extern void init_irq_proc(void);
# 750 "/home/nathan/src/linux-next/include/linux/interrupt.h"
struct seq_file;
int show_interrupts(struct seq_file *p, void *v);
int arch_show_interrupts(struct seq_file *p, int prec);

extern int early_irq_init(void);
extern int arch_probe_nr_irqs(void);
extern int arch_early_irq_init(void);
# 39 "/home/nathan/src/linux-next/include/linux/pci.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/resource_ext.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/resource_ext.h"
struct resource_win {
 struct resource res;
 resource_size_t offset;
};





struct resource_entry {
 struct list_head node;
 struct resource *res;
 resource_size_t offset;
 struct resource __res;
};

extern struct resource_entry *
resource_list_create_entry(struct resource *res, size_t extra_size);
extern void resource_list_free(struct list_head *head);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void resource_list_add(struct resource_entry *entry,
         struct list_head *head)
{
 list_add(&entry->node, head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void resource_list_add_tail(struct resource_entry *entry,
       struct list_head *head)
{
 list_add_tail(&entry->node, head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void resource_list_del(struct resource_entry *entry)
{
 list_del(&entry->node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void resource_list_free_entry(struct resource_entry *entry)
{
 kfree(entry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
resource_list_destroy_entry(struct resource_entry *entry)
{
 resource_list_del(entry);
 resource_list_free_entry(entry);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct resource_entry *
resource_list_first_type(struct list_head *list, unsigned long type)
{
 struct resource_entry *entry;

 for ((entry) = ({ void *__mptr = (void *)(((list))->next); do { extern void __compiletime_assert_74(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(((list))->next)), typeof(((typeof(*(entry)) *)0)->node)) && !__builtin_types_compatible_p(typeof(*(((list))->next)), typeof(void))))) __compiletime_assert_74(); } while (0); ((typeof(*(entry)) *)(__mptr - __builtin_offsetof(typeof(*(entry)), node))); }); &(entry)->node != ((list)); (entry) = ({ void *__mptr = (void *)(((entry))->node.next); do { extern void __compiletime_assert_74(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(((entry))->node.next)), typeof(((typeof(*((entry))) *)0)->node)) && !__builtin_types_compatible_p(typeof(*(((entry))->node.next)), typeof(void))))) __compiletime_assert_74(); } while (0); ((typeof(*((entry))) *)(__mptr - __builtin_offsetof(typeof(*((entry))), node))); })) {
  if (resource_type(entry->res) == type)
   return entry;
 }
 return ((void *)0);
}
# 41 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/pci.h" 1
# 21 "/home/nathan/src/linux-next/include/uapi/linux/pci.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/pci_regs.h" 1
# 22 "/home/nathan/src/linux-next/include/uapi/linux/pci.h" 2
# 42 "/home/nathan/src/linux-next/include/linux/pci.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/pci_ids.h" 1
# 44 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 62 "/home/nathan/src/linux-next/include/linux/pci.h"
struct pci_slot {
 struct pci_bus *bus;
 struct list_head list;
 struct hotplug_slot *hotplug;
 unsigned char number;
 struct kobject kobj;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *pci_slot_name(const struct pci_slot *slot)
{
 return kobject_name(&slot->kobj);
}


enum pci_mmap_state {
 pci_mmap_io,
 pci_mmap_mem
};


enum {

 PCI_STD_RESOURCES,
 PCI_STD_RESOURCE_END = PCI_STD_RESOURCES + 6 - 1,


 PCI_ROM_RESOURCE,
# 99 "/home/nathan/src/linux-next/include/linux/pci.h"
 PCI_BRIDGE_RESOURCES,
 PCI_BRIDGE_RESOURCE_END = PCI_BRIDGE_RESOURCES +
      4 - 1,


 PCI_NUM_RESOURCES,


 DEVICE_COUNT_RESOURCE = PCI_NUM_RESOURCES,
};
# 121 "/home/nathan/src/linux-next/include/linux/pci.h"
enum pci_interrupt_pin {
 PCI_INTERRUPT_UNKNOWN,
 PCI_INTERRUPT_INTA,
 PCI_INTERRUPT_INTB,
 PCI_INTERRUPT_INTC,
 PCI_INTERRUPT_INTD,
};
# 136 "/home/nathan/src/linux-next/include/linux/pci.h"
typedef int pci_power_t;
# 147 "/home/nathan/src/linux-next/include/linux/pci.h"
extern const char *pci_power_names[];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *pci_power_name(pci_power_t state)
{
 return pci_power_names[1 + ( int) state];
}
# 161 "/home/nathan/src/linux-next/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

enum pci_channel_state {

 pci_channel_io_normal = ( pci_channel_state_t) 1,


 pci_channel_io_frozen = ( pci_channel_state_t) 2,


 pci_channel_io_perm_failure = ( pci_channel_state_t) 3,
};

typedef unsigned int pcie_reset_state_t;

enum pcie_reset_state {

 pcie_deassert_reset = ( pcie_reset_state_t) 1,


 pcie_warm_reset = ( pcie_reset_state_t) 2,


 pcie_hot_reset = ( pcie_reset_state_t) 3
};

typedef unsigned short pci_dev_flags_t;
enum pci_dev_flags {

 PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = ( pci_dev_flags_t) (1 << 0),

 PCI_DEV_FLAGS_NO_D3 = ( pci_dev_flags_t) (1 << 1),

 PCI_DEV_FLAGS_ASSIGNED = ( pci_dev_flags_t) (1 << 2),

 PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = ( pci_dev_flags_t) (1 << 3),

 PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = ( pci_dev_flags_t) (1 << 5),

 PCI_DEV_FLAGS_NO_BUS_RESET = ( pci_dev_flags_t) (1 << 6),

 PCI_DEV_FLAGS_NO_PM_RESET = ( pci_dev_flags_t) (1 << 7),

 PCI_DEV_FLAGS_VPD_REF_F0 = ( pci_dev_flags_t) (1 << 8),

 PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = ( pci_dev_flags_t) (1 << 9),

 PCI_DEV_FLAGS_NO_FLR_RESET = ( pci_dev_flags_t) (1 << 10),

 PCI_DEV_FLAGS_NO_RELAXED_ORDERING = ( pci_dev_flags_t) (1 << 11),
};

enum pci_irq_reroute_variant {
 INTEL_IRQ_REROUTE_VARIANT = 1,
 MAX_IRQ_REROUTE_VARIANTS = 3
};

typedef unsigned short pci_bus_flags_t;
enum pci_bus_flags {
 PCI_BUS_FLAGS_NO_MSI = ( pci_bus_flags_t) 1,
 PCI_BUS_FLAGS_NO_MMRBC = ( pci_bus_flags_t) 2,
 PCI_BUS_FLAGS_NO_AERSID = ( pci_bus_flags_t) 4,
 PCI_BUS_FLAGS_NO_EXTCFG = ( pci_bus_flags_t) 8,
};


enum pcie_link_width {
 PCIE_LNK_WIDTH_RESRV = 0x00,
 PCIE_LNK_X1 = 0x01,
 PCIE_LNK_X2 = 0x02,
 PCIE_LNK_X4 = 0x04,
 PCIE_LNK_X8 = 0x08,
 PCIE_LNK_X12 = 0x0c,
 PCIE_LNK_X16 = 0x10,
 PCIE_LNK_X32 = 0x20,
 PCIE_LNK_WIDTH_UNKNOWN = 0xff,
};


enum pci_bus_speed {
 PCI_SPEED_33MHz = 0x00,
 PCI_SPEED_66MHz = 0x01,
 PCI_SPEED_66MHz_PCIX = 0x02,
 PCI_SPEED_100MHz_PCIX = 0x03,
 PCI_SPEED_133MHz_PCIX = 0x04,
 PCI_SPEED_66MHz_PCIX_ECC = 0x05,
 PCI_SPEED_100MHz_PCIX_ECC = 0x06,
 PCI_SPEED_133MHz_PCIX_ECC = 0x07,
 PCI_SPEED_66MHz_PCIX_266 = 0x09,
 PCI_SPEED_100MHz_PCIX_266 = 0x0a,
 PCI_SPEED_133MHz_PCIX_266 = 0x0b,
 AGP_UNKNOWN = 0x0c,
 AGP_1X = 0x0d,
 AGP_2X = 0x0e,
 AGP_4X = 0x0f,
 AGP_8X = 0x10,
 PCI_SPEED_66MHz_PCIX_533 = 0x11,
 PCI_SPEED_100MHz_PCIX_533 = 0x12,
 PCI_SPEED_133MHz_PCIX_533 = 0x13,
 PCIE_SPEED_2_5GT = 0x14,
 PCIE_SPEED_5_0GT = 0x15,
 PCIE_SPEED_8_0GT = 0x16,
 PCIE_SPEED_16_0GT = 0x17,
 PCIE_SPEED_32_0GT = 0x18,
 PCI_SPEED_UNKNOWN = 0xff,
};

enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev);
enum pcie_link_width pcie_get_width_cap(struct pci_dev *dev);

struct pci_cap_saved_data {
 u16 cap_nr;
 bool cap_extended;
 unsigned int size;
 u32 data[0];
};

struct pci_cap_saved_state {
 struct hlist_node next;
 struct pci_cap_saved_data cap;
};

struct irq_affinity;
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_p2pdma;


struct pci_dev {
 struct list_head bus_list;
 struct pci_bus *bus;
 struct pci_bus *subordinate;

 void *sysdata;
 struct proc_dir_entry *procent;
 struct pci_slot *slot;

 unsigned int devfn;
 unsigned short vendor;
 unsigned short device;
 unsigned short subsystem_vendor;
 unsigned short subsystem_device;
 unsigned int class;
 u8 revision;
 u8 hdr_type;




 u8 pcie_cap;
 u8 msi_cap;
 u8 msix_cap;
 u8 pcie_mpss:3;
 u8 rom_base_reg;
 u8 pin;
 u16 pcie_flags_reg;
 unsigned long *dma_alias_mask;

 struct pci_driver *driver;
 u64 dma_mask;





 struct device_dma_parameters dma_parms;

 pci_power_t current_state;


 unsigned int imm_ready:1;
 u8 pm_cap;
 unsigned int pme_support:5;

 unsigned int pme_poll:1;
 unsigned int d1_support:1;
 unsigned int d2_support:1;
 unsigned int no_d1d2:1;
 unsigned int no_d3cold:1;
 unsigned int bridge_d3:1;
 unsigned int d3cold_allowed:1;
 unsigned int mmio_always_on:1;

 unsigned int wakeup_prepared:1;
 unsigned int runtime_d3cold:1;



 unsigned int skip_bus_pm:1;
 unsigned int ignore_hotplug:1;
 unsigned int hotplug_user_indicators:1;


 unsigned int clear_retrain_link:1;

 unsigned int d3_delay;
 unsigned int d3cold_delay;


 struct pcie_link_state *link_state;
 unsigned int ltr_path:1;


 unsigned int eetlp_prefix_path:1;

 pci_channel_state_t error_state;
 struct device dev;

 int cfg_size;





 unsigned int irq;
 struct resource resource[DEVICE_COUNT_RESOURCE];

 bool match_driver;

 unsigned int transparent:1;
 unsigned int io_window:1;
 unsigned int pref_window:1;
 unsigned int pref_64_window:1;
 unsigned int multifunction:1;

 unsigned int is_busmaster:1;
 unsigned int no_msi:1;
 unsigned int no_64bit_msi:1;
 unsigned int block_cfg_access:1;
 unsigned int broken_parity_status:1;
 unsigned int irq_reroute_variant:2;
 unsigned int msi_enabled:1;
 unsigned int msix_enabled:1;
 unsigned int ari_enabled:1;
 unsigned int ats_enabled:1;
 unsigned int pasid_enabled:1;
 unsigned int pri_enabled:1;
 unsigned int is_managed:1;
 unsigned int needs_freset:1;
 unsigned int state_saved:1;
 unsigned int is_physfn:1;
 unsigned int is_virtfn:1;
 unsigned int reset_fn:1;
 unsigned int is_hotplug_bridge:1;
 unsigned int shpc_managed:1;
 unsigned int is_thunderbolt:1;







 unsigned int untrusted:1;
 unsigned int __aer_firmware_first_valid:1;
 unsigned int __aer_firmware_first:1;
 unsigned int broken_intx_masking:1;
 unsigned int io_window_1k:1;
 unsigned int irq_managed:1;
 unsigned int non_compliant_bars:1;
 unsigned int is_probed:1;
 unsigned int link_active_reporting:1;
 unsigned int no_vf_scan:1;
 pci_dev_flags_t dev_flags;
 atomic_t enable_cnt;

 u32 saved_config_space[16];
 struct hlist_head saved_cap_space;
 struct bin_attribute *rom_attr;
 int rom_attr_enabled;
 struct bin_attribute *res_attr[DEVICE_COUNT_RESOURCE];
 struct bin_attribute *res_attr_wc[DEVICE_COUNT_RESOURCE];
# 444 "/home/nathan/src/linux-next/include/linux/pci.h"
 const struct attribute_group **msi_irq_groups;

 struct pci_vpd *vpd;
# 467 "/home/nathan/src/linux-next/include/linux/pci.h"
 phys_addr_t rom;
 size_t romlen;
 char *driver_override;

 unsigned long priv_flags;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_dev *pci_physfn(struct pci_dev *dev)
{




 return dev;
}

struct pci_dev *pci_alloc_dev(struct pci_bus *bus);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_channel_offline(struct pci_dev *pdev)
{
 return (pdev->error_state != pci_channel_io_normal);
}

struct pci_host_bridge {
 struct device dev;
 struct pci_bus *bus;
 struct pci_ops *ops;
 void *sysdata;
 int busnr;
 struct list_head windows;
 struct list_head dma_ranges;
 u8 (*swizzle_irq)(struct pci_dev *, u8 *);
 int (*map_irq)(const struct pci_dev *, u8, u8);
 void (*release_fn)(struct pci_host_bridge *);
 void *release_data;
 struct msi_controller *msi;
 unsigned int ignore_reset_delay:1;
 unsigned int no_ext_tags:1;
 unsigned int native_aer:1;
 unsigned int native_pcie_hotplug:1;
 unsigned int native_shpc_hotplug:1;
 unsigned int native_pme:1;
 unsigned int native_ltr:1;
 unsigned int preserve_config:1;


 resource_size_t (*align_resource)(struct pci_dev *dev,
   const struct resource *res,
   resource_size_t start,
   resource_size_t size,
   resource_size_t align);
 unsigned long private[0] __attribute__((__aligned__((1 << 7))));
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pci_host_bridge_priv(struct pci_host_bridge *bridge)
{
 return (void *)bridge->private;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_host_bridge *pci_host_bridge_from_priv(void *priv)
{
 return ({ void *__mptr = (void *)(priv); do { extern void __compiletime_assert_533(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(priv)), typeof(((struct pci_host_bridge *)0)->private)) && !__builtin_types_compatible_p(typeof(*(priv)), typeof(void))))) __compiletime_assert_533(); } while (0); ((struct pci_host_bridge *)(__mptr - __builtin_offsetof(struct pci_host_bridge, private))); });
}

struct pci_host_bridge *pci_alloc_host_bridge(size_t priv);
struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
         size_t priv);
void pci_free_host_bridge(struct pci_host_bridge *bridge);
struct pci_host_bridge *pci_find_host_bridge(struct pci_bus *bus);

void pci_set_host_bridge_release(struct pci_host_bridge *bridge,
     void (*release_fn)(struct pci_host_bridge *),
     void *release_data);

int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge);
# 563 "/home/nathan/src/linux-next/include/linux/pci.h"
struct pci_bus_resource {
 struct list_head list;
 struct resource *res;
 unsigned int flags;
};



struct pci_bus {
 struct list_head node;
 struct pci_bus *parent;
 struct list_head children;
 struct list_head devices;
 struct pci_dev *self;
 struct list_head slots;

 struct resource *resource[4];
 struct list_head resources;
 struct resource busn_res;

 struct pci_ops *ops;
 struct msi_controller *msi;
 void *sysdata;
 struct proc_dir_entry *procdir;

 unsigned char number;
 unsigned char primary;
 unsigned char max_bus_speed;
 unsigned char cur_bus_speed;




 char name[48];

 unsigned short bridge_ctl;
 pci_bus_flags_t bus_flags;
 struct device *bridge;
 struct device dev;
 struct bin_attribute *legacy_io;
 struct bin_attribute *legacy_mem;
 unsigned int is_added:1;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 pci_dev_id(struct pci_dev *dev)
{
 return ((((u16)(dev->bus->number)) << 8) | (dev->devfn));
}
# 622 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_is_root_bus(struct pci_bus *pbus)
{
 return !(pbus->parent);
}
# 634 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_is_bridge(struct pci_dev *dev)
{
 return dev->hdr_type == 1 ||
  dev->hdr_type == 2;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_dev *pci_upstream_bridge(struct pci_dev *dev)
{
 dev = pci_physfn(dev);
 if (pci_is_root_bus(dev->bus))
  return ((void *)0);

 return dev->bus->self;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_dev_msi_enabled(struct pci_dev *pci_dev)
{
 return pci_dev->msi_enabled || pci_dev->msix_enabled;
}
# 672 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pcibios_err_to_errno(int err)
{
 if (err <= 0x00)
  return err;

 switch (err) {
 case 0x81:
  return -2;
 case 0x83:
  return -25;
 case 0x86:
  return -19;
 case 0x87:
  return -14;
 case 0x88:
  return -5;
 case 0x89:
  return -28;
 }

 return -34;
}



struct pci_ops {
 int (*add_bus)(struct pci_bus *bus);
 void (*remove_bus)(struct pci_bus *bus);
 void *(*map_bus)(struct pci_bus *bus, unsigned int devfn, int where);
 int (*read)(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *val);
 int (*write)(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val);
};





int raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,
   int reg, int len, u32 *val);
int raw_pci_write(unsigned int domain, unsigned int bus, unsigned int devfn,
    int reg, int len, u32 val);


typedef u64 pci_bus_addr_t;




struct pci_bus_region {
 pci_bus_addr_t start;
 pci_bus_addr_t end;
};

struct pci_dynids {
 spinlock_t lock;
 struct list_head list;
};
# 738 "/home/nathan/src/linux-next/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

enum pci_ers_result {

 PCI_ERS_RESULT_NONE = ( pci_ers_result_t) 1,


 PCI_ERS_RESULT_CAN_RECOVER = ( pci_ers_result_t) 2,


 PCI_ERS_RESULT_NEED_RESET = ( pci_ers_result_t) 3,


 PCI_ERS_RESULT_DISCONNECT = ( pci_ers_result_t) 4,


 PCI_ERS_RESULT_RECOVERED = ( pci_ers_result_t) 5,


 PCI_ERS_RESULT_NO_AER_DRIVER = ( pci_ers_result_t) 6,
};


struct pci_error_handlers {

 pci_ers_result_t (*error_detected)(struct pci_dev *dev,
        enum pci_channel_state error);


 pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev);


 pci_ers_result_t (*slot_reset)(struct pci_dev *dev);


 void (*reset_prepare)(struct pci_dev *dev);
 void (*reset_done)(struct pci_dev *dev);


 void (*resume)(struct pci_dev *dev);
};


struct module;
# 824 "/home/nathan/src/linux-next/include/linux/pci.h"
struct pci_driver {
 struct list_head node;
 const char *name;
 const struct pci_device_id *id_table;
 int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);
 void (*remove)(struct pci_dev *dev);
 int (*suspend)(struct pci_dev *dev, pm_message_t state);
 int (*resume)(struct pci_dev *dev);
 void (*shutdown)(struct pci_dev *dev);
 int (*sriov_configure)(struct pci_dev *dev, int num_vfs);
 const struct pci_error_handlers *err_handler;
 const struct attribute_group **groups;
 struct device_driver driver;
 struct pci_dynids dynids;
};
# 912 "/home/nathan/src/linux-next/include/linux/pci.h"
enum {
 PCI_REASSIGN_ALL_RSRC = 0x00000001,
 PCI_REASSIGN_ALL_BUS = 0x00000002,
 PCI_PROBE_ONLY = 0x00000004,
 PCI_CAN_SKIP_ISA_ALIGN = 0x00000008,
 PCI_ENABLE_PROC_DOMAINS = 0x00000010,
 PCI_COMPAT_DOMAIN_0 = 0x00000020,
 PCI_SCAN_ALL_PCIE_DEVS = 0x00000040,
};
# 930 "/home/nathan/src/linux-next/include/linux/pci.h"
extern unsigned int pci_flags;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_set_flags(int flags) { pci_flags = flags; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_add_flags(int flags) { pci_flags |= flags; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_clear_flags(int flags) { pci_flags &= ~flags; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_has_flag(int flag) { return pci_flags & flag; }

void pcie_bus_configure_settings(struct pci_bus *bus);

enum pcie_bus_config_types {
 PCIE_BUS_TUNE_OFF,
 PCIE_BUS_DEFAULT,
 PCIE_BUS_SAFE,
 PCIE_BUS_PERFORMANCE,
 PCIE_BUS_PEER2PEER,
};

extern enum pcie_bus_config_types pcie_bus_config;

extern struct bus_type pci_bus_type;



extern struct list_head pci_root_buses;

int no_pci_devices(void);

void pcibios_resource_survey_bus(struct pci_bus *bus);
void pcibios_bus_add_device(struct pci_dev *pdev);
void pcibios_add_bus(struct pci_bus *bus);
void pcibios_remove_bus(struct pci_bus *bus);
void pcibios_fixup_bus(struct pci_bus *);
int __attribute__((__warn_unused_result__)) pcibios_enable_device(struct pci_dev *, int mask);

char *pcibios_setup(char *str);


resource_size_t pcibios_align_resource(void *, const struct resource *,
    resource_size_t,
    resource_size_t);


void pci_fixup_cardbus(struct pci_bus *);



void pcibios_resource_to_bus(struct pci_bus *bus, struct pci_bus_region *region,
        struct resource *res);
void pcibios_bus_to_resource(struct pci_bus *bus, struct resource *res,
        struct pci_bus_region *region);
void pcibios_scan_specific_bus(int busn);
struct pci_bus *pci_find_bus(int domain, int busnr);
void pci_bus_add_devices(const struct pci_bus *bus);
struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops, void *sysdata);
struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
        struct pci_ops *ops, void *sysdata,
        struct list_head *resources);
int pci_host_probe(struct pci_host_bridge *bridge);
int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int busmax);
int pci_bus_update_busn_res_end(struct pci_bus *b, int busmax);
void pci_bus_release_busn_res(struct pci_bus *b);
struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
      struct pci_ops *ops, void *sysdata,
      struct list_head *resources);
int pci_scan_root_bus_bridge(struct pci_host_bridge *bridge);
struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev,
    int busnr);
struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
     const char *name,
     struct hotplug_slot *hotplug);
void pci_destroy_slot(struct pci_slot *slot);

void pci_dev_assign_slot(struct pci_dev *dev);



int pci_scan_slot(struct pci_bus *bus, int devfn);
struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn);
void pci_device_add(struct pci_dev *dev, struct pci_bus *bus);
unsigned int pci_scan_child_bus(struct pci_bus *bus);
void pci_bus_add_device(struct pci_dev *dev);
void pci_read_bridge_bases(struct pci_bus *child);
struct resource *pci_find_parent_resource(const struct pci_dev *dev,
       struct resource *res);
struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev);
u8 pci_swizzle_interrupt_pin(const struct pci_dev *dev, u8 pin);
int pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge);
u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp);
struct pci_dev *pci_dev_get(struct pci_dev *dev);
void pci_dev_put(struct pci_dev *dev);
void pci_remove_bus(struct pci_bus *b);
void pci_stop_and_remove_bus_device(struct pci_dev *dev);
void pci_stop_and_remove_bus_device_locked(struct pci_dev *dev);
void pci_stop_root_bus(struct pci_bus *bus);
void pci_remove_root_bus(struct pci_bus *bus);
void pci_setup_cardbus(struct pci_bus *bus);
void pcibios_setup_bridge(struct pci_bus *bus, unsigned long type);
void pci_sort_breadthfirst(void);





enum pci_lost_interrupt_reason {
 PCI_LOST_IRQ_NO_INFORMATION = 0,
 PCI_LOST_IRQ_DISABLE_MSI,
 PCI_LOST_IRQ_DISABLE_MSIX,
 PCI_LOST_IRQ_DISABLE_ACPI,
};
enum pci_lost_interrupt_reason pci_lost_interrupt(struct pci_dev *dev);
int pci_find_capability(struct pci_dev *dev, int cap);
int pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap);
int pci_find_ext_capability(struct pci_dev *dev, int cap);
int pci_find_next_ext_capability(struct pci_dev *dev, int pos, int cap);
int pci_find_ht_capability(struct pci_dev *dev, int ht_cap);
int pci_find_next_ht_capability(struct pci_dev *dev, int pos, int ht_cap);
struct pci_bus *pci_find_next_bus(const struct pci_bus *from);

struct pci_dev *pci_get_device(unsigned int vendor, unsigned int device,
          struct pci_dev *from);
struct pci_dev *pci_get_subsys(unsigned int vendor, unsigned int device,
          unsigned int ss_vendor, unsigned int ss_device,
          struct pci_dev *from);
struct pci_dev *pci_get_slot(struct pci_bus *bus, unsigned int devfn);
struct pci_dev *pci_get_domain_bus_and_slot(int domain, unsigned int bus,
         unsigned int devfn);
struct pci_dev *pci_get_class(unsigned int class, struct pci_dev *from);
int pci_dev_present(const struct pci_device_id *ids);

int pci_bus_read_config_byte(struct pci_bus *bus, unsigned int devfn,
        int where, u8 *val);
int pci_bus_read_config_word(struct pci_bus *bus, unsigned int devfn,
        int where, u16 *val);
int pci_bus_read_config_dword(struct pci_bus *bus, unsigned int devfn,
         int where, u32 *val);
int pci_bus_write_config_byte(struct pci_bus *bus, unsigned int devfn,
         int where, u8 val);
int pci_bus_write_config_word(struct pci_bus *bus, unsigned int devfn,
         int where, u16 val);
int pci_bus_write_config_dword(struct pci_bus *bus, unsigned int devfn,
          int where, u32 val);

int pci_generic_config_read(struct pci_bus *bus, unsigned int devfn,
       int where, int size, u32 *val);
int pci_generic_config_write(struct pci_bus *bus, unsigned int devfn,
       int where, int size, u32 val);
int pci_generic_config_read32(struct pci_bus *bus, unsigned int devfn,
         int where, int size, u32 *val);
int pci_generic_config_write32(struct pci_bus *bus, unsigned int devfn,
          int where, int size, u32 val);

struct pci_ops *pci_bus_set_ops(struct pci_bus *bus, struct pci_ops *ops);

int pci_read_config_byte(const struct pci_dev *dev, int where, u8 *val);
int pci_read_config_word(const struct pci_dev *dev, int where, u16 *val);
int pci_read_config_dword(const struct pci_dev *dev, int where, u32 *val);
int pci_write_config_byte(const struct pci_dev *dev, int where, u8 val);
int pci_write_config_word(const struct pci_dev *dev, int where, u16 val);
int pci_write_config_dword(const struct pci_dev *dev, int where, u32 val);

int pcie_capability_read_word(struct pci_dev *dev, int pos, u16 *val);
int pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val);
int pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val);
int pcie_capability_write_dword(struct pci_dev *dev, int pos, u32 val);
int pcie_capability_clear_and_set_word(struct pci_dev *dev, int pos,
           u16 clear, u16 set);
int pcie_capability_clear_and_set_dword(struct pci_dev *dev, int pos,
     u32 clear, u32 set);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pcie_capability_set_word(struct pci_dev *dev, int pos,
        u16 set)
{
 return pcie_capability_clear_and_set_word(dev, pos, 0, set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pcie_capability_set_dword(struct pci_dev *dev, int pos,
         u32 set)
{
 return pcie_capability_clear_and_set_dword(dev, pos, 0, set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pcie_capability_clear_word(struct pci_dev *dev, int pos,
          u16 clear)
{
 return pcie_capability_clear_and_set_word(dev, pos, clear, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pcie_capability_clear_dword(struct pci_dev *dev, int pos,
           u32 clear)
{
 return pcie_capability_clear_and_set_dword(dev, pos, clear, 0);
}


int pci_user_read_config_byte(struct pci_dev *dev, int where, u8 *val);
int pci_user_read_config_word(struct pci_dev *dev, int where, u16 *val);
int pci_user_read_config_dword(struct pci_dev *dev, int where, u32 *val);
int pci_user_write_config_byte(struct pci_dev *dev, int where, u8 val);
int pci_user_write_config_word(struct pci_dev *dev, int where, u16 val);
int pci_user_write_config_dword(struct pci_dev *dev, int where, u32 val);

int __attribute__((__warn_unused_result__)) pci_enable_device(struct pci_dev *dev);
int __attribute__((__warn_unused_result__)) pci_enable_device_io(struct pci_dev *dev);
int __attribute__((__warn_unused_result__)) pci_enable_device_mem(struct pci_dev *dev);
int __attribute__((__warn_unused_result__)) pci_reenable_device(struct pci_dev *);
int __attribute__((__warn_unused_result__)) pcim_enable_device(struct pci_dev *pdev);
void pcim_pin_device(struct pci_dev *pdev);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_intx_mask_supported(struct pci_dev *pdev)
{




 return !pdev->broken_intx_masking;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_is_enabled(struct pci_dev *pdev)
{
 return (atomic_read(&pdev->enable_cnt) > 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_is_managed(struct pci_dev *pdev)
{
 return pdev->is_managed;
}

void pci_disable_device(struct pci_dev *dev);

extern unsigned int pcibios_max_latency;
void pci_set_master(struct pci_dev *dev);
void pci_clear_master(struct pci_dev *dev);

int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state);
int pci_set_cacheline_size(struct pci_dev *dev);

int __attribute__((__warn_unused_result__)) pci_set_mwi(struct pci_dev *dev);
int __attribute__((__warn_unused_result__)) pcim_set_mwi(struct pci_dev *dev);
int pci_try_set_mwi(struct pci_dev *dev);
void pci_clear_mwi(struct pci_dev *dev);
void pci_intx(struct pci_dev *dev, int enable);
bool pci_check_and_mask_intx(struct pci_dev *dev);
bool pci_check_and_unmask_intx(struct pci_dev *dev);
int pci_wait_for_pending(struct pci_dev *dev, int pos, u16 mask);
int pci_wait_for_pending_transaction(struct pci_dev *dev);
int pcix_get_max_mmrbc(struct pci_dev *dev);
int pcix_get_mmrbc(struct pci_dev *dev);
int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc);
int pcie_get_readrq(struct pci_dev *dev);
int pcie_set_readrq(struct pci_dev *dev, int rq);
int pcie_get_mps(struct pci_dev *dev);
int pcie_set_mps(struct pci_dev *dev, int mps);
u32 pcie_bandwidth_available(struct pci_dev *dev, struct pci_dev **limiting_dev,
        enum pci_bus_speed *speed,
        enum pcie_link_width *width);
void pcie_print_link_status(struct pci_dev *dev);
bool pcie_has_flr(struct pci_dev *dev);
int pcie_flr(struct pci_dev *dev);
int __pci_reset_function_locked(struct pci_dev *dev);
int pci_reset_function(struct pci_dev *dev);
int pci_reset_function_locked(struct pci_dev *dev);
int pci_try_reset_function(struct pci_dev *dev);
int pci_probe_reset_slot(struct pci_slot *slot);
int pci_probe_reset_bus(struct pci_bus *bus);
int pci_reset_bus(struct pci_dev *dev);
void pci_reset_secondary_bus(struct pci_dev *dev);
void pcibios_reset_secondary_bus(struct pci_dev *dev);
void pci_update_resource(struct pci_dev *dev, int resno);
int __attribute__((__warn_unused_result__)) pci_assign_resource(struct pci_dev *dev, int i);
int __attribute__((__warn_unused_result__)) pci_reassign_resource(struct pci_dev *dev, int i, resource_size_t add_size, resource_size_t align);
void pci_release_resource(struct pci_dev *dev, int resno);
int __attribute__((__warn_unused_result__)) pci_resize_resource(struct pci_dev *dev, int i, int size);
int pci_select_bars(struct pci_dev *dev, unsigned long flags);
bool pci_device_is_present(struct pci_dev *pdev);
void pci_ignore_hotplug(struct pci_dev *dev);
struct pci_dev *pci_real_dma_dev(struct pci_dev *dev);

int __attribute__((__format__(printf, 6, 7))) pci_request_irq(struct pci_dev *dev, unsigned int nr,
  irq_handler_t handler, irq_handler_t thread_fn, void *dev_id,
  const char *fmt, ...);
void pci_free_irq(struct pci_dev *dev, unsigned int nr, void *dev_id);


int pci_enable_rom(struct pci_dev *pdev);
void pci_disable_rom(struct pci_dev *pdev);
void __attribute__((__warn_unused_result__)) *pci_map_rom(struct pci_dev *pdev, size_t *size);
void pci_unmap_rom(struct pci_dev *pdev, void *rom);
void __attribute__((__warn_unused_result__)) *pci_platform_rom(struct pci_dev *pdev, size_t *size);


int pci_save_state(struct pci_dev *dev);
void pci_restore_state(struct pci_dev *dev);
struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev);
int pci_load_saved_state(struct pci_dev *dev,
    struct pci_saved_state *state);
int pci_load_and_free_saved_state(struct pci_dev *dev,
      struct pci_saved_state **state);
struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *dev, char cap);
struct pci_cap_saved_state *pci_find_saved_ext_cap(struct pci_dev *dev,
         u16 cap);
int pci_add_cap_save_buffer(struct pci_dev *dev, char cap, unsigned int size);
int pci_add_ext_cap_save_buffer(struct pci_dev *dev,
    u16 cap, unsigned int size);
int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state);
int pci_set_power_state(struct pci_dev *dev, pci_power_t state);
pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state);
bool pci_pme_capable(struct pci_dev *dev, pci_power_t state);
void pci_pme_active(struct pci_dev *dev, bool enable);
int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable);
int pci_wake_from_d3(struct pci_dev *dev, bool enable);
int pci_prepare_to_sleep(struct pci_dev *dev);
int pci_back_from_sleep(struct pci_dev *dev);
bool pci_dev_run_wake(struct pci_dev *dev);
void pci_d3cold_enable(struct pci_dev *dev);
void pci_d3cold_disable(struct pci_dev *dev);
bool pcie_relaxed_ordering_enabled(struct pci_dev *dev);
void pci_wakeup_bus(struct pci_bus *bus);
void pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state);


void set_pcie_port_type(struct pci_dev *pdev);
void set_pcie_hotplug_bridge(struct pci_dev *pdev);


int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap);
unsigned int pci_rescan_bus_bridge_resize(struct pci_dev *bridge);
unsigned int pci_rescan_bus(struct pci_bus *bus);
void pci_lock_rescan_remove(void);
void pci_unlock_rescan_remove(void);


ssize_t pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, void *buf);
ssize_t pci_write_vpd(struct pci_dev *dev, loff_t pos, size_t count, const void *buf);
int pci_set_vpd_size(struct pci_dev *dev, size_t len);


resource_size_t pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx);
void pci_bus_assign_resources(const struct pci_bus *bus);
void pci_bus_claim_resources(struct pci_bus *bus);
void pci_bus_size_bridges(struct pci_bus *bus);
int pci_claim_resource(struct pci_dev *, int);
int pci_claim_bridge_resource(struct pci_dev *bridge, int i);
void pci_assign_unassigned_resources(void);
void pci_assign_unassigned_bridge_resources(struct pci_dev *bridge);
void pci_assign_unassigned_bus_resources(struct pci_bus *bus);
void pci_assign_unassigned_root_bus_resources(struct pci_bus *bus);
int pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type);
void pdev_enable_device(struct pci_dev *);
int pci_enable_resources(struct pci_dev *, int mask);
void pci_assign_irq(struct pci_dev *dev);
struct resource *pci_find_resource(struct pci_dev *dev, struct resource *res);

int __attribute__((__warn_unused_result__)) pci_request_regions(struct pci_dev *, const char *);
int __attribute__((__warn_unused_result__)) pci_request_regions_exclusive(struct pci_dev *, const char *);
void pci_release_regions(struct pci_dev *);
int __attribute__((__warn_unused_result__)) pci_request_region(struct pci_dev *, int, const char *);
void pci_release_region(struct pci_dev *, int);
int pci_request_selected_regions(struct pci_dev *, int, const char *);
int pci_request_selected_regions_exclusive(struct pci_dev *, int, const char *);
void pci_release_selected_regions(struct pci_dev *, int);


void pci_add_resource(struct list_head *resources, struct resource *res);
void pci_add_resource_offset(struct list_head *resources, struct resource *res,
        resource_size_t offset);
void pci_free_resource_list(struct list_head *resources);
void pci_bus_add_resource(struct pci_bus *bus, struct resource *res,
     unsigned int flags);
struct resource *pci_bus_resource_n(const struct pci_bus *bus, int n);
void pci_bus_remove_resources(struct pci_bus *bus);
int devm_request_pci_bus_resources(struct device *dev,
       struct list_head *resources);


int pci_bridge_secondary_bus_reset(struct pci_dev *dev);






int __attribute__((__warn_unused_result__)) pci_bus_alloc_resource(struct pci_bus *bus,
   struct resource *res, resource_size_t size,
   resource_size_t align, resource_size_t min,
   unsigned long type_mask,
   resource_size_t (*alignf)(void *,
        const struct resource *,
        resource_size_t,
        resource_size_t),
   void *alignf_data);


int pci_register_io_range(struct fwnode_handle *fwnode, phys_addr_t addr,
   resource_size_t size);
unsigned long pci_address_to_pio(phys_addr_t addr);
phys_addr_t pci_pio_to_address(unsigned long pio);
int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr);
int devm_pci_remap_iospace(struct device *dev, const struct resource *res,
      phys_addr_t phys_addr);
void pci_unmap_iospace(struct resource *res);
void *devm_pci_remap_cfgspace(struct device *dev,
          resource_size_t offset,
          resource_size_t size);
void *devm_pci_remap_cfg_resource(struct device *dev,
       struct resource *res);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) pci_bus_addr_t pci_bus_address(struct pci_dev *pdev, int bar)
{
 struct pci_bus_region region;

 pcibios_resource_to_bus(pdev->bus, &region, &pdev->resource[bar]);
 return region.start;
}


int __attribute__((__warn_unused_result__)) __pci_register_driver(struct pci_driver *, struct module *,
           const char *mod_name);





void pci_unregister_driver(struct pci_driver *dev);
# 1376 "/home/nathan/src/linux-next/include/linux/pci.h"
struct pci_driver *pci_dev_driver(const struct pci_dev *dev);
int pci_add_dynid(struct pci_driver *drv,
    unsigned int vendor, unsigned int device,
    unsigned int subvendor, unsigned int subdevice,
    unsigned int class, unsigned int class_mask,
    unsigned long driver_data);
const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
      struct pci_dev *dev);
int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
      int pass);

void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
    void *userdata);
int pci_cfg_space_size(struct pci_dev *dev);
unsigned char pci_bus_max_busnr(struct pci_bus *bus);
void pci_setup_bridge(struct pci_bus *bus);
resource_size_t pcibios_window_alignment(struct pci_bus *bus,
      unsigned long type);




int pci_set_vga_state(struct pci_dev *pdev, bool decode,
        unsigned int command_bits, u32 flags);
# 1414 "/home/nathan/src/linux-next/include/linux/pci.h"
# 1 "/home/nathan/src/linux-next/include/linux/dmapool.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/dmapool.h"
# 1 "/home/nathan/src/linux-next/include/linux/scatterlist.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
struct scatterlist {
 unsigned long page_link;
 unsigned int offset;
 unsigned int length;
 dma_addr_t dma_address;

 unsigned int dma_length;

};
# 42 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
struct sg_table {
 struct scatterlist *sgl;
 unsigned int nents;
 unsigned int orig_nents;
};
# 87 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_assign_page(struct scatterlist *sg, struct page *page)
{
 unsigned long page_link = sg->page_link & (0x01UL | 0x02UL);





 do { if (__builtin_constant_p((unsigned long) page & (0x01UL | 0x02UL))) { if ((unsigned long) page & (0x01UL | 0x02UL)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/scatterlist.h"), "i" (95), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/scatterlist.h"), "i" (95), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)((unsigned long) page & (0x01UL | 0x02UL)))); } } while (0);



 sg->page_link = page_link | (unsigned long) page;
}
# 116 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_set_page(struct scatterlist *sg, struct page *page,
          unsigned int len, unsigned int offset)
{
 sg_assign_page(sg, page);
 sg->offset = offset;
 sg->length = len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *sg_page(struct scatterlist *sg)
{



 return (struct page *)((sg)->page_link & ~(0x01UL | 0x02UL));
}
# 139 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_set_buf(struct scatterlist *sg, const void *buf,
         unsigned int buflen)
{



 sg_set_page(sg, (vmemmap + ((({ do { } while (0); (unsigned long)(buf) & 0x0fffffffffffffffUL; }) >> 16))), buflen, ((unsigned long)(buf) & ~(~((1 << 16) - 1))));
}
# 164 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_chain(struct scatterlist *prv, unsigned int prv_nents,
       struct scatterlist *sgl)
{



 prv[prv_nents - 1].offset = 0;
 prv[prv_nents - 1].length = 0;





 prv[prv_nents - 1].page_link = ((unsigned long) sgl | 0x01UL)
     & ~0x02UL;
}
# 190 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_mark_end(struct scatterlist *sg)
{



 sg->page_link |= 0x02UL;
 sg->page_link &= ~0x01UL;
}
# 207 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_unmark_end(struct scatterlist *sg)
{
 sg->page_link &= ~0x02UL;
}
# 222 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t sg_phys(struct scatterlist *sg)
{
 return page_to_phys(sg_page(sg)) + sg->offset;
}
# 237 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *sg_virt(struct scatterlist *sg)
{
 return lowmem_page_address(sg_page(sg)) + sg->offset;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sg_init_marker(struct scatterlist *sgl,
      unsigned int nents)
{
 sg_mark_end(&sgl[nents - 1]);
}

int sg_nents(struct scatterlist *sg);
int sg_nents_for_len(struct scatterlist *sg, u64 len);
struct scatterlist *sg_next(struct scatterlist *);
struct scatterlist *sg_last(struct scatterlist *s, unsigned int);
void sg_init_table(struct scatterlist *, unsigned int);
void sg_init_one(struct scatterlist *, const void *, unsigned int);
int sg_split(struct scatterlist *in, const int in_mapped_nents,
      const off_t skip, const int nb_splits,
      const size_t *split_sizes,
      struct scatterlist **out, int *out_mapped_nents,
      gfp_t gfp_mask);

typedef struct scatterlist *(sg_alloc_fn)(unsigned int, gfp_t);
typedef void (sg_free_fn)(struct scatterlist *, unsigned int);

void __sg_free_table(struct sg_table *, unsigned int, unsigned int,
       sg_free_fn *);
void sg_free_table(struct sg_table *);
int __sg_alloc_table(struct sg_table *, unsigned int, unsigned int,
       struct scatterlist *, unsigned int, gfp_t, sg_alloc_fn *);
int sg_alloc_table(struct sg_table *, unsigned int, gfp_t);
int __sg_alloc_table_from_pages(struct sg_table *sgt, struct page **pages,
    unsigned int n_pages, unsigned int offset,
    unsigned long size, unsigned int max_segment,
    gfp_t gfp_mask);
int sg_alloc_table_from_pages(struct sg_table *sgt, struct page **pages,
         unsigned int n_pages, unsigned int offset,
         unsigned long size, gfp_t gfp_mask);


struct scatterlist *sgl_alloc_order(unsigned long long length,
        unsigned int order, bool chainable,
        gfp_t gfp, unsigned int *nent_p);
struct scatterlist *sgl_alloc(unsigned long long length, gfp_t gfp,
         unsigned int *nent_p);
void sgl_free_n_order(struct scatterlist *sgl, int nents, int order);
void sgl_free_order(struct scatterlist *sgl, int order);
void sgl_free(struct scatterlist *sgl);


size_t sg_copy_buffer(struct scatterlist *sgl, unsigned int nents, void *buf,
        size_t buflen, off_t skip, bool to_buffer);

size_t sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,
      const void *buf, size_t buflen);
size_t sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,
    void *buf, size_t buflen);

size_t sg_pcopy_from_buffer(struct scatterlist *sgl, unsigned int nents,
       const void *buf, size_t buflen, off_t skip);
size_t sg_pcopy_to_buffer(struct scatterlist *sgl, unsigned int nents,
     void *buf, size_t buflen, off_t skip);
size_t sg_zero_buffer(struct scatterlist *sgl, unsigned int nents,
         size_t buflen, off_t skip);
# 335 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
void sg_free_table_chained(struct sg_table *table,
      unsigned nents_first_chunk);
int sg_alloc_table_chained(struct sg_table *table, int nents,
      struct scatterlist *first_chunk,
      unsigned nents_first_chunk);
# 352 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
struct sg_page_iter {
 struct scatterlist *sg;
 unsigned int sg_pgoffset;


 unsigned int __nents;
 int __pg_advance;

};
# 369 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
struct sg_dma_page_iter {
 struct sg_page_iter base;
};

bool __sg_page_iter_next(struct sg_page_iter *piter);
bool __sg_page_iter_dma_next(struct sg_dma_page_iter *dma_iter);
void __sg_page_iter_start(struct sg_page_iter *piter,
     struct scatterlist *sglist, unsigned int nents,
     unsigned long pgoffset);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *sg_page_iter_page(struct sg_page_iter *piter)
{
 return (vmemmap + ((unsigned long)(((sg_page(piter->sg))) - vmemmap) + (piter->sg_pgoffset)));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t
sg_page_iter_dma_address(struct sg_dma_page_iter *dma_iter)
{
 return ((dma_iter->base.sg)->dma_address) +
        (dma_iter->base.sg_pgoffset << 16);
}
# 447 "/home/nathan/src/linux-next/include/linux/scatterlist.h"
struct sg_mapping_iter {

 struct page *page;
 void *addr;
 size_t length;
 size_t consumed;
 struct sg_page_iter piter;


 unsigned int __offset;
 unsigned int __remaining;
 unsigned int __flags;
};

void sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
      unsigned int nents, unsigned int flags);
bool sg_miter_skip(struct sg_mapping_iter *miter, off_t offset);
bool sg_miter_next(struct sg_mapping_iter *miter);
void sg_miter_stop(struct sg_mapping_iter *miter);
# 15 "/home/nathan/src/linux-next/include/linux/dmapool.h" 2


struct device;



struct dma_pool *dma_pool_create(const char *name, struct device *dev,
   size_t size, size_t align, size_t allocation);

void dma_pool_destroy(struct dma_pool *pool);

void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
       dma_addr_t *handle);
void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t addr);




struct dma_pool *dmam_pool_create(const char *name, struct device *dev,
      size_t size, size_t align, size_t allocation);
void dmam_pool_destroy(struct dma_pool *pool);
# 52 "/home/nathan/src/linux-next/include/linux/dmapool.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dma_pool_zalloc(struct dma_pool *pool, gfp_t mem_flags,
        dma_addr_t *handle)
{
 return dma_pool_alloc(pool, mem_flags | (( gfp_t)0x100u), handle);
}
# 1415 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 1425 "/home/nathan/src/linux-next/include/linux/pci.h"
struct msix_entry {
 u32 vector;
 u16 entry;
};


int pci_msi_vec_count(struct pci_dev *dev);
void pci_disable_msi(struct pci_dev *dev);
int pci_msix_vec_count(struct pci_dev *dev);
void pci_disable_msix(struct pci_dev *dev);
void pci_restore_msi_state(struct pci_dev *dev);
int pci_msi_enabled(void);
int pci_enable_msi(struct pci_dev *dev);
int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
     int minvec, int maxvec);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_enable_msix_exact(struct pci_dev *dev,
     struct msix_entry *entries, int nvec)
{
 int rc = pci_enable_msix_range(dev, entries, nvec, nvec);
 if (rc < 0)
  return rc;
 return 0;
}
int pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,
       unsigned int max_vecs, unsigned int flags,
       struct irq_affinity *affd);

void pci_free_irq_vectors(struct pci_dev *dev);
int pci_irq_vector(struct pci_dev *dev, unsigned int nr);
const struct cpumask *pci_irq_get_affinity(struct pci_dev *pdev, int vec);
# 1515 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_irqd_intx_xlate(struct irq_domain *d,
          struct device_node *node,
          const u32 *intspec,
          unsigned int intsize,
          unsigned long *out_hwirq,
          unsigned int *out_type)
{
 const u32 intx = intspec[0];

 if (intx < PCI_INTERRUPT_INTA || intx > PCI_INTERRUPT_INTD)
  return -22;

 *out_hwirq = intx - PCI_INTERRUPT_INTA;
 return 0;
}
# 1548 "/home/nathan/src/linux-next/include/linux/pci.h"
int pci_disable_link_state(struct pci_dev *pdev, int state);
int pci_disable_link_state_locked(struct pci_dev *pdev, int state);
void pcie_no_aspm(void);
bool pcie_aspm_support_enabled(void);
bool pcie_aspm_enabled(struct pci_dev *pdev);
# 1566 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_aer_available(void) { return false; }


bool pci_ats_disabled(void);

void pci_cfg_access_lock(struct pci_dev *dev);
bool pci_cfg_access_trylock(struct pci_dev *dev);
void pci_cfg_access_unlock(struct pci_dev *dev);







extern int pci_domains_supported;
# 1608 "/home/nathan/src/linux-next/include/linux/pci.h"
typedef int (*arch_set_vga_state_t)(struct pci_dev *pdev, bool decode,
        unsigned int command_bits, u32 flags);
void pci_register_set_vga_state(arch_set_vga_state_t func);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
pci_request_io_regions(struct pci_dev *pdev, const char *name)
{
 return pci_request_selected_regions(pdev,
       pci_select_bars(pdev, 0x00000100), name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_release_io_regions(struct pci_dev *pdev)
{
 return pci_release_selected_regions(pdev,
       pci_select_bars(pdev, 0x00000100));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
pci_request_mem_regions(struct pci_dev *pdev, const char *name)
{
 return pci_request_selected_regions(pdev,
       pci_select_bars(pdev, 0x00000200), name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_release_mem_regions(struct pci_dev *pdev)
{
 return pci_release_selected_regions(pdev,
       pci_select_bars(pdev, 0x00000200));
}
# 1768 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,
        unsigned int max_vecs, unsigned int flags)
{
 return pci_alloc_irq_vectors_affinity(dev, min_vecs, max_vecs, flags,
           ((void *)0));
}




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h" 1
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h"
# 1 "/home/nathan/src/linux-next/include/linux/dma-mapping.h" 1








# 1 "/home/nathan/src/linux-next/include/linux/dma-debug.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/dma-debug.h"
struct device;
struct scatterlist;
struct bus_type;
# 74 "/home/nathan/src/linux-next/include/linux/dma-debug.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_debug_add_bus(struct bus_type *bus)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_map_single(struct device *dev, const void *addr,
     unsigned long len)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_map_page(struct device *dev, struct page *page,
          size_t offset, size_t size,
          int direction, dma_addr_t dma_addr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_mapping_error(struct device *dev,
       dma_addr_t dma_addr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,
     size_t size, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,
        int nents, int mapped_ents, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_unmap_sg(struct device *dev,
          struct scatterlist *sglist,
          int nelems, int dir)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_alloc_coherent(struct device *dev, size_t size,
         dma_addr_t dma_addr, void *virt)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_free_coherent(struct device *dev, size_t size,
        void *virt, dma_addr_t addr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_map_resource(struct device *dev, phys_addr_t addr,
       size_t size, int direction,
       dma_addr_t dma_addr)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_unmap_resource(struct device *dev,
         dma_addr_t dma_addr, size_t size,
         int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_sync_single_for_cpu(struct device *dev,
       dma_addr_t dma_handle,
       size_t size, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_sync_single_for_device(struct device *dev,
          dma_addr_t dma_handle,
          size_t size, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_sync_sg_for_cpu(struct device *dev,
          struct scatterlist *sg,
          int nelems, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_sync_sg_for_device(struct device *dev,
      struct scatterlist *sg,
      int nelems, int direction)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_dump_mappings(struct device *dev)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void debug_dma_assert_idle(struct page *page)
{
}
# 10 "/home/nathan/src/linux-next/include/linux/dma-mapping.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/dma-direction.h" 1




enum dma_data_direction {
 DMA_BIDIRECTIONAL = 0,
 DMA_TO_DEVICE = 1,
 DMA_FROM_DEVICE = 2,
 DMA_NONE = 3,
};
# 11 "/home/nathan/src/linux-next/include/linux/dma-mapping.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/mem_encrypt.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/mem_encrypt.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mem_encrypt.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mem_encrypt.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/svm.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/svm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_secure_guest(void)
{
 return ({unsigned long rval; asm volatile("mfmsr %0" : "=r" (rval) : : "memory"); rval;}) & (1UL<<(22));
}

void dtl_cache_ctor(void *addr);
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/mem_encrypt.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_encrypt_active(void)
{
 return is_secure_guest();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool force_dma_unencrypted(struct device *dev)
{
 return is_secure_guest();
}

int set_memory_encrypted(unsigned long addr, int numpages);
int set_memory_decrypted(unsigned long addr, int numpages);
# 18 "/home/nathan/src/linux-next/include/linux/mem_encrypt.h" 2
# 14 "/home/nathan/src/linux-next/include/linux/dma-mapping.h" 2
# 76 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
struct dma_map_ops {
 void* (*alloc)(struct device *dev, size_t size,
    dma_addr_t *dma_handle, gfp_t gfp,
    unsigned long attrs);
 void (*free)(struct device *dev, size_t size,
         void *vaddr, dma_addr_t dma_handle,
         unsigned long attrs);
 int (*mmap)(struct device *, struct vm_area_struct *,
     void *, dma_addr_t, size_t,
     unsigned long attrs);

 int (*get_sgtable)(struct device *dev, struct sg_table *sgt, void *,
      dma_addr_t, size_t, unsigned long attrs);

 dma_addr_t (*map_page)(struct device *dev, struct page *page,
          unsigned long offset, size_t size,
          enum dma_data_direction dir,
          unsigned long attrs);
 void (*unmap_page)(struct device *dev, dma_addr_t dma_handle,
      size_t size, enum dma_data_direction dir,
      unsigned long attrs);




 int (*map_sg)(struct device *dev, struct scatterlist *sg,
        int nents, enum dma_data_direction dir,
        unsigned long attrs);
 void (*unmap_sg)(struct device *dev,
    struct scatterlist *sg, int nents,
    enum dma_data_direction dir,
    unsigned long attrs);
 dma_addr_t (*map_resource)(struct device *dev, phys_addr_t phys_addr,
          size_t size, enum dma_data_direction dir,
          unsigned long attrs);
 void (*unmap_resource)(struct device *dev, dma_addr_t dma_handle,
      size_t size, enum dma_data_direction dir,
      unsigned long attrs);
 void (*sync_single_for_cpu)(struct device *dev,
        dma_addr_t dma_handle, size_t size,
        enum dma_data_direction dir);
 void (*sync_single_for_device)(struct device *dev,
           dma_addr_t dma_handle, size_t size,
           enum dma_data_direction dir);
 void (*sync_sg_for_cpu)(struct device *dev,
    struct scatterlist *sg, int nents,
    enum dma_data_direction dir);
 void (*sync_sg_for_device)(struct device *dev,
       struct scatterlist *sg, int nents,
       enum dma_data_direction dir);
 void (*cache_sync)(struct device *dev, void *vaddr, size_t size,
   enum dma_data_direction direction);
 int (*dma_supported)(struct device *dev, u64 mask);
 u64 (*get_required_mask)(struct device *dev);
 size_t (*max_mapping_size)(struct device *dev);
 unsigned long (*get_merge_boundary)(struct device *dev);
};



extern const struct dma_map_ops dma_virt_ops;
extern const struct dma_map_ops dma_dummy_ops;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_dma_direction(int dma_direction)
{
 return ((dma_direction == DMA_BIDIRECTIONAL) ||
  (dma_direction == DMA_TO_DEVICE) ||
  (dma_direction == DMA_FROM_DEVICE));
}






int dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,
           dma_addr_t *dma_handle, void **ret);
int dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr);

int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,
       void *cpu_addr, size_t size, int *ret);

void *dma_alloc_from_global_coherent(struct device *dev, ssize_t size, dma_addr_t *dma_handle);
int dma_release_from_global_coherent(int order, void *vaddr);
int dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *cpu_addr,
      size_t size, int *ret);
# 191 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dma_is_direct(const struct dma_map_ops *ops)
{
 return __builtin_expect(!!(!ops), 1);
}





dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,
  unsigned long offset, size_t size, enum dma_data_direction dir,
  unsigned long attrs);
int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
  enum dma_data_direction dir, unsigned long attrs);
dma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,
  size_t size, enum dma_data_direction dir, unsigned long attrs);



void dma_direct_sync_single_for_device(struct device *dev,
  dma_addr_t addr, size_t size, enum dma_data_direction dir);
void dma_direct_sync_sg_for_device(struct device *dev,
  struct scatterlist *sgl, int nents, enum dma_data_direction dir);
# 228 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,
  size_t size, enum dma_data_direction dir, unsigned long attrs);
void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,
  int nents, enum dma_data_direction dir, unsigned long attrs);
void dma_direct_sync_single_for_cpu(struct device *dev,
  dma_addr_t addr, size_t size, enum dma_data_direction dir);
void dma_direct_sync_sg_for_cpu(struct device *dev,
  struct scatterlist *sgl, int nents, enum dma_data_direction dir);
# 256 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
size_t dma_direct_max_mapping_size(struct device *dev);



# 1 "./arch/powerpc/include/generated/asm/dma-mapping.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/dma-mapping.h" 1




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
{
 return ((void *)0);
}
# 2 "./arch/powerpc/include/generated/asm/dma-mapping.h" 2
# 260 "/home/nathan/src/linux-next/include/linux/dma-mapping.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct dma_map_ops *get_dma_ops(struct device *dev)
{
 if (dev->dma_ops)
  return dev->dma_ops;
 return get_arch_dma_ops(dev->bus);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_dma_ops(struct device *dev,
          const struct dma_map_ops *dma_ops)
{
 dev->dma_ops = dma_ops;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t dma_map_page_attrs(struct device *dev,
  struct page *page, size_t offset, size_t size,
  enum dma_data_direction dir, unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);
 dma_addr_t addr;

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (281), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (281), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
 else
  addr = ops->map_page(dev, page, offset, size, dir, attrs);
 debug_dma_map_page(dev, page, offset, size, dir, addr);

 return addr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr,
  size_t size, enum dma_data_direction dir, unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (296), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (296), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  dma_direct_unmap_page(dev, addr, size, dir, attrs);
 else if (ops->unmap_page)
  ops->unmap_page(dev, addr, size, dir, attrs);
 debug_dma_unmap_page(dev, addr, size, dir);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
       int nents, enum dma_data_direction dir,
       unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);
 int ents;

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (315), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (315), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  ents = dma_direct_map_sg(dev, sg, nents, dir, attrs);
 else
  ents = ops->map_sg(dev, sg, nents, dir, attrs);
 do { if (__builtin_constant_p(ents < 0)) { if (ents < 0) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (320), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (320), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(ents < 0))); } } while (0);
 debug_dma_map_sg(dev, sg, nents, ents, dir);

 return ents;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
          int nents, enum dma_data_direction dir,
          unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (332), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (332), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 debug_dma_unmap_sg(dev, sg, nents, dir);
 if (dma_is_direct(ops))
  dma_direct_unmap_sg(dev, sg, nents, dir, attrs);
 else if (ops->unmap_sg)
  ops->unmap_sg(dev, sg, nents, dir, attrs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t dma_map_resource(struct device *dev,
       phys_addr_t phys_addr,
       size_t size,
       enum dma_data_direction dir,
       unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);
 dma_addr_t addr = (~(dma_addr_t)0);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (349), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (349), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);


 if (({ int __ret_warn_on = !!(pfn_valid(((unsigned long)((phys_addr) >> 16)))); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (352), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return (~(dma_addr_t)0);

 if (dma_is_direct(ops))
  addr = dma_direct_map_resource(dev, phys_addr, size, dir, attrs);
 else if (ops->map_resource)
  addr = ops->map_resource(dev, phys_addr, size, dir, attrs);

 debug_dma_map_resource(dev, phys_addr, size, dir, addr);
 return addr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_unmap_resource(struct device *dev, dma_addr_t addr,
          size_t size, enum dma_data_direction dir,
          unsigned long attrs)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (370), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (370), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (!dma_is_direct(ops) && ops->unmap_resource)
  ops->unmap_resource(dev, addr, size, dir, attrs);
 debug_dma_unmap_resource(dev, addr, size, dir);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,
        size_t size,
        enum dma_data_direction dir)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (382), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (382), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  dma_direct_sync_single_for_cpu(dev, addr, size, dir);
 else if (ops->sync_single_for_cpu)
  ops->sync_single_for_cpu(dev, addr, size, dir);
 debug_dma_sync_single_for_cpu(dev, addr, size, dir);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_sync_single_for_device(struct device *dev,
           dma_addr_t addr, size_t size,
           enum dma_data_direction dir)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (396), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (396), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  dma_direct_sync_single_for_device(dev, addr, size, dir);
 else if (ops->sync_single_for_device)
  ops->sync_single_for_device(dev, addr, size, dir);
 debug_dma_sync_single_for_device(dev, addr, size, dir);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
      int nelems, enum dma_data_direction dir)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (410), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (410), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  dma_direct_sync_sg_for_cpu(dev, sg, nelems, dir);
 else if (ops->sync_sg_for_cpu)
  ops->sync_sg_for_cpu(dev, sg, nelems, dir);
 debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
         int nelems, enum dma_data_direction dir)
{
 const struct dma_map_ops *ops = get_dma_ops(dev);

 do { if (__builtin_constant_p(!valid_dma_direction(dir))) { if (!valid_dma_direction(dir)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (424), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (424), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!valid_dma_direction(dir)))); } } while (0);
 if (dma_is_direct(ops))
  dma_direct_sync_sg_for_device(dev, sg, nelems, dir);
 else if (ops->sync_sg_for_device)
  ops->sync_sg_for_device(dev, sg, nelems, dir);
 debug_dma_sync_sg_for_device(dev, sg, nelems, dir);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
 debug_dma_mapping_error(dev, dma_addr);

 if (dma_addr == (~(dma_addr_t)0))
  return -12;
 return 0;
}

void *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
  gfp_t flag, unsigned long attrs);
void dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,
  dma_addr_t dma_handle, unsigned long attrs);
void *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
  gfp_t gfp, unsigned long attrs);
void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
  dma_addr_t dma_handle);
void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
  enum dma_data_direction dir);
int dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt,
  void *cpu_addr, dma_addr_t dma_addr, size_t size,
  unsigned long attrs);
int dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma,
  void *cpu_addr, dma_addr_t dma_addr, size_t size,
  unsigned long attrs);
bool dma_can_mmap(struct device *dev);
int dma_supported(struct device *dev, u64 mask);
int dma_set_mask(struct device *dev, u64 mask);
int dma_set_coherent_mask(struct device *dev, u64 mask);
u64 dma_get_required_mask(struct device *dev);
size_t dma_max_mapping_size(struct device *dev);
unsigned long dma_get_merge_boundary(struct device *dev);
# 580 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
  size_t size, enum dma_data_direction dir, unsigned long attrs)
{

 if (({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(is_vmalloc_addr(ptr)); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("%s %s: " "rejecting DMA map of vmalloc memory\n", dev_driver_string(dev), dev_name(dev)); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dma-mapping.h"), "i" (585), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); }))

  return (~(dma_addr_t)0);
 debug_dma_map_single(dev, ptr, size);
 return dma_map_page_attrs(dev, (vmemmap + ((({ do { } while (0); (unsigned long)(ptr) & 0x0fffffffffffffffUL; }) >> 16))), ((unsigned long)(ptr) & ~(~((1 << 16) - 1))),
   size, dir, attrs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
  size_t size, enum dma_data_direction dir, unsigned long attrs)
{
 return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_sync_single_range_for_cpu(struct device *dev,
  dma_addr_t addr, unsigned long offset, size_t size,
  enum dma_data_direction dir)
{
 return dma_sync_single_for_cpu(dev, addr + offset, size, dir);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_sync_single_range_for_device(struct device *dev,
  dma_addr_t addr, unsigned long offset, size_t size,
  enum dma_data_direction dir)
{
 return dma_sync_single_for_device(dev, addr + offset, size, dir);
}
# 621 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
extern int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
  void *cpu_addr, dma_addr_t dma_addr, size_t size,
  unsigned long attrs);

struct page **dma_common_find_pages(void *cpu_addr);
void *dma_common_contiguous_remap(struct page *page, size_t size,
   pgprot_t prot, const void *caller);

void *dma_common_pages_remap(struct page **pages, size_t size,
   pgprot_t prot, const void *caller);
void dma_common_free_remap(void *cpu_addr, size_t size);

bool dma_in_atomic_pool(void *start, size_t size);
void *dma_alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags);
bool dma_free_from_pool(void *start, size_t size);

int
dma_common_get_sgtable(struct device *dev, struct sg_table *sgt, void *cpu_addr,
  dma_addr_t dma_addr, size_t size, unsigned long attrs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dma_alloc_coherent(struct device *dev, size_t size,
  dma_addr_t *dma_handle, gfp_t gfp)
{

 return dma_alloc_attrs(dev, size, dma_handle, gfp,
   (gfp & (( gfp_t)0x2000u)) ? (1UL << 8) : 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_free_coherent(struct device *dev, size_t size,
  void *cpu_addr, dma_addr_t dma_handle)
{
 return dma_free_attrs(dev, size, cpu_addr, dma_handle, 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 dma_get_mask(struct device *dev)
{
 if (dev->dma_mask && *dev->dma_mask)
  return *dev->dma_mask;
 return (((32) == 64) ? ~0ULL : ((1ULL<<(32))-1));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
 int rc = dma_set_mask(dev, mask);
 if (rc == 0)
  dma_set_coherent_mask(dev, mask);
 return rc;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_coerce_mask_and_coherent(struct device *dev, u64 mask)
{
 dev->dma_mask = &dev->coherent_dma_mask;
 return dma_set_mask_and_coherent(dev, mask);
}
# 695 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dma_addressing_limited(struct device *dev)
{
 return ({ typeof(dma_get_mask(dev)) __x = (dma_get_mask(dev)); typeof(dev->bus_dma_limit) __y = (dev->bus_dma_limit); __x == 0 ? __y : ((__y == 0) ? __x : __builtin_choose_expr(((!!(sizeof((typeof(__x) *)1 == (typeof(__y) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(__x) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(__y) * 0l)) : (int *)8))))), ((__x) < (__y) ? (__x) : (__y)), ({ typeof(__x) __UNIQUE_ID___x20 = (__x); typeof(__y) __UNIQUE_ID___y21 = (__y); ((__UNIQUE_ID___x20) < (__UNIQUE_ID___y21) ? (__UNIQUE_ID___x20) : (__UNIQUE_ID___y21)); }))); }) <
       dma_get_required_mask(dev);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_setup_dma_ops(struct device *dev, u64 dma_base,
  u64 size, const struct iommu_ops *iommu, bool coherent)
{
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_teardown_dma_ops(struct device *dev)
{
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int dma_get_max_seg_size(struct device *dev)
{
 if (dev->dma_parms && dev->dma_parms->max_segment_size)
  return dev->dma_parms->max_segment_size;
 return 0x00010000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_set_max_seg_size(struct device *dev, unsigned int size)
{
 if (dev->dma_parms) {
  dev->dma_parms->max_segment_size = size;
  return 0;
 }
 return -5;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long dma_get_seg_boundary(struct device *dev)
{
 if (dev->dma_parms && dev->dma_parms->segment_boundary_mask)
  return dev->dma_parms->segment_boundary_mask;
 return (((32) == 64) ? ~0ULL : ((1ULL<<(32))-1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_set_seg_boundary(struct device *dev, unsigned long mask)
{
 if (dev->dma_parms) {
  dev->dma_parms->segment_boundary_mask = mask;
  return 0;
 }
 return -5;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_get_cache_alignment(void)
{



 return 1;
}


int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
    dma_addr_t device_addr, size_t size);
# 771 "/home/nathan/src/linux-next/include/linux/dma-mapping.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dmam_alloc_coherent(struct device *dev, size_t size,
  dma_addr_t *dma_handle, gfp_t gfp)
{
 return dmam_alloc_attrs(dev, size, dma_handle, gfp,
   (gfp & (( gfp_t)0x2000u)) ? (1UL << 8) : 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dma_alloc_wc(struct device *dev, size_t size,
     dma_addr_t *dma_addr, gfp_t gfp)
{
 unsigned long attrs = (1UL << 2);

 if (gfp & (( gfp_t)0x2000u))
  attrs |= (1UL << 8);

 return dma_alloc_attrs(dev, size, dma_addr, gfp, attrs);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dma_free_wc(struct device *dev, size_t size,
          void *cpu_addr, dma_addr_t dma_addr)
{
 return dma_free_attrs(dev, size, cpu_addr, dma_addr,
         (1UL << 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dma_mmap_wc(struct device *dev,
         struct vm_area_struct *vma,
         void *cpu_addr, dma_addr_t dma_addr,
         size_t size)
{
 return dma_mmap_attrs(dev, vma, cpu_addr, dma_addr, size,
         (1UL << 2));
}
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h" 2


# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/seq_file.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/seq_file.h"
# 1 "/home/nathan/src/linux-next/include/linux/cred.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/cred.h"
# 1 "/home/nathan/src/linux-next/include/linux/key.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/key.h"
# 1 "/home/nathan/src/linux-next/include/linux/assoc_array.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/assoc_array.h"
struct assoc_array {
 struct assoc_array_ptr *root;
 unsigned long nr_leaves_on_tree;
};




struct assoc_array_ops {

 unsigned long (*get_key_chunk)(const void *index_key, int level);


 unsigned long (*get_object_key_chunk)(const void *object, int level);


 bool (*compare_object)(const void *object, const void *index_key);




 int (*diff_objects)(const void *object, const void *index_key);


 void (*free_object)(void *object);
};




struct assoc_array_edit;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void assoc_array_init(struct assoc_array *array)
{
 array->root = ((void *)0);
 array->nr_leaves_on_tree = 0;
}

extern int assoc_array_iterate(const struct assoc_array *array,
          int (*iterator)(const void *object,
            void *iterator_data),
          void *iterator_data);
extern void *assoc_array_find(const struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key);
extern void assoc_array_destroy(struct assoc_array *array,
    const struct assoc_array_ops *ops);
extern struct assoc_array_edit *assoc_array_insert(struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key,
         void *object);
extern void assoc_array_insert_set_object(struct assoc_array_edit *edit,
       void *object);
extern struct assoc_array_edit *assoc_array_delete(struct assoc_array *array,
         const struct assoc_array_ops *ops,
         const void *index_key);
extern struct assoc_array_edit *assoc_array_clear(struct assoc_array *array,
        const struct assoc_array_ops *ops);
extern void assoc_array_apply_edit(struct assoc_array_edit *edit);
extern void assoc_array_cancel_edit(struct assoc_array_edit *edit);
extern int assoc_array_gc(struct assoc_array *array,
     const struct assoc_array_ops *ops,
     bool (*iterator)(void *object, void *iterator_data),
     void *iterator_data);
# 21 "/home/nathan/src/linux-next/include/linux/key.h" 2







typedef int32_t key_serial_t;


typedef uint32_t key_perm_t;

struct key;
struct net;
# 74 "/home/nathan/src/linux-next/include/linux/key.h"
struct seq_file;
struct user_struct;
struct signal_struct;
struct cred;

struct key_type;
struct key_owner;
struct key_tag;
struct keyring_list;
struct keyring_name;

struct key_tag {
 struct callback_head rcu;
 refcount_t usage;
 bool removed;
};

struct keyring_index_key {

 unsigned long hash;
 union {
  struct {




   char desc[sizeof(long) - 2];
   u16 desc_len;

  };
  unsigned long x;
 };
 struct key_type *type;
 struct key_tag *domain_tag;
 const char *description;
};

union key_payload {
 void *rcu_data0;
 void *data[4];
};
# 130 "/home/nathan/src/linux-next/include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) key_ref_t make_key_ref(const struct key *key,
         bool possession)
{
 return (key_ref_t) ((unsigned long) key | possession);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *key_ref_to_ptr(const key_ref_t key_ref)
{
 return (struct key *) ((unsigned long) key_ref & ~1UL);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_key_possessed(const key_ref_t key_ref)
{
 return (unsigned long) key_ref & 1UL;
}

typedef int (*key_restrict_link_func_t)(struct key *dest_keyring,
     const struct key_type *type,
     const union key_payload *payload,
     struct key *restriction_key);

struct key_restriction {
 key_restrict_link_func_t check;
 struct key *key;
 struct key_type *keytype;
};

enum key_state {
 KEY_IS_UNINSTANTIATED,
 KEY_IS_POSITIVE,
};
# 172 "/home/nathan/src/linux-next/include/linux/key.h"
struct key {
 refcount_t usage;
 key_serial_t serial;
 union {
  struct list_head graveyard_link;
  struct rb_node serial_node;
 };
 struct rw_semaphore sem;
 struct key_user *user;
 void *security;
 union {
  time64_t expiry;
  time64_t revoked_at;
 };
 time64_t last_used_at;
 kuid_t uid;
 kgid_t gid;
 key_perm_t perm;
 unsigned short quotalen;
 unsigned short datalen;



 short state;






 unsigned long flags;
# 219 "/home/nathan/src/linux-next/include/linux/key.h"
 union {
  struct keyring_index_key index_key;
  struct {
   unsigned long hash;
   unsigned long len_desc;
   struct key_type *type;
   struct key_tag *domain_tag;
   char *description;
  };
 };





 union {
  union key_payload payload;
  struct {

   struct list_head name_link;
   struct assoc_array keys;
  };
 };
# 254 "/home/nathan/src/linux-next/include/linux/key.h"
 struct key_restriction *restrict_link;
};

extern struct key *key_alloc(struct key_type *type,
        const char *desc,
        kuid_t uid, kgid_t gid,
        const struct cred *cred,
        key_perm_t perm,
        unsigned long flags,
        struct key_restriction *restrict_link);
# 273 "/home/nathan/src/linux-next/include/linux/key.h"
extern void key_revoke(struct key *key);
extern void key_invalidate(struct key *key);
extern void key_put(struct key *key);
extern bool key_put_tag(struct key_tag *tag);
extern void key_remove_domain(struct key_tag *domain_tag);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *__key_get(struct key *key)
{
 refcount_inc(&key->usage);
 return key;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *key_get(struct key *key)
{
 return key ? __key_get(key) : key;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void key_ref_put(key_ref_t key_ref)
{
 key_put(key_ref_to_ptr(key_ref));
}

extern struct key *request_key_tag(struct key_type *type,
       const char *description,
       struct key_tag *domain_tag,
       const char *callout_info);

extern struct key *request_key_rcu(struct key_type *type,
       const char *description,
       struct key_tag *domain_tag);

extern struct key *request_key_with_auxdata(struct key_type *type,
         const char *description,
         struct key_tag *domain_tag,
         const void *callout_info,
         size_t callout_len,
         void *aux);
# 319 "/home/nathan/src/linux-next/include/linux/key.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct key *request_key(struct key_type *type,
          const char *description,
          const char *callout_info)
{
 return request_key_tag(type, description, ((void *)0), callout_info);
}
# 358 "/home/nathan/src/linux-next/include/linux/key.h"
extern int wait_for_key_construction(struct key *key, bool intr);

extern int key_validate(const struct key *key);

extern key_ref_t key_create_or_update(key_ref_t keyring,
          const char *type,
          const char *description,
          const void *payload,
          size_t plen,
          key_perm_t perm,
          unsigned long flags);

extern int key_update(key_ref_t key,
        const void *payload,
        size_t plen);

extern int key_link(struct key *keyring,
      struct key *key);

extern int key_move(struct key *key,
      struct key *from_keyring,
      struct key *to_keyring,
      unsigned int flags);

extern int key_unlink(struct key *keyring,
        struct key *key);

extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
     const struct cred *cred,
     key_perm_t perm,
     unsigned long flags,
     struct key_restriction *restrict_link,
     struct key *dest);

extern int restrict_link_reject(struct key *keyring,
    const struct key_type *type,
    const union key_payload *payload,
    struct key *restriction_key);

extern int keyring_clear(struct key *keyring);

extern key_ref_t keyring_search(key_ref_t keyring,
    struct key_type *type,
    const char *description,
    bool recurse);

extern int keyring_add_key(struct key *keyring,
      struct key *key);

extern int keyring_restrict(key_ref_t keyring, const char *type,
       const char *restriction);

extern struct key *key_lookup(key_serial_t id);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) key_serial_t key_serial(const struct key *key)
{
 return key ? key->serial : 0;
}

extern void key_set_timeout(struct key *, unsigned);

extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
     key_perm_t perm);
extern void key_free_user_ns(struct user_namespace *);
# 434 "/home/nathan/src/linux-next/include/linux/key.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) short key_read_state(const struct key *key)
{

 return ({ typeof(*&key->state) ___p1 = ({ union { typeof(*&key->state) __val; char __c[1]; } __u; if (1) __read_once_size(&(*&key->state), __u.__c, sizeof(*&key->state)); else __read_once_size_nocheck(&(*&key->state), __u.__c, sizeof(*&key->state)); do { } while (0); __u.__val; }); do { extern void __compiletime_assert_437(void) ; if (!((sizeof(*&key->state) == sizeof(char) || sizeof(*&key->state) == sizeof(short) || sizeof(*&key->state) == sizeof(int) || sizeof(*&key->state) == sizeof(long)))) __compiletime_assert_437(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}
# 447 "/home/nathan/src/linux-next/include/linux/key.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool key_is_positive(const struct key *key)
{
 return key_read_state(key) == KEY_IS_POSITIVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool key_is_negative(const struct key *key)
{
 return key_read_state(key) < 0;
}
# 470 "/home/nathan/src/linux-next/include/linux/key.h"
extern struct ctl_table key_sysctls[];




extern int install_thread_keyring_to_cred(struct cred *cred);
extern void key_fsuid_changed(struct cred *new_cred);
extern void key_fsgid_changed(struct cred *new_cred);
extern void key_init(void);
# 14 "/home/nathan/src/linux-next/include/linux/cred.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/sched/user.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/sched/user.h"
struct user_struct {
 refcount_t __count;
 atomic_t processes;
 atomic_t sigpending;




 atomic_long_t epoll_watches;



 unsigned long mq_bytes;

 unsigned long locked_shm;
 unsigned long unix_inflight;
 atomic_long_t pipe_bufs;


 struct hlist_node uidhash_node;
 kuid_t uid;



 atomic_long_t locked_vm;



 struct ratelimit_state ratelimit;
};

extern int uids_sysfs_init(void);

extern struct user_struct *find_user(kuid_t);

extern struct user_struct root_user;




extern struct user_struct * alloc_uid(kuid_t);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_struct *get_uid(struct user_struct *u)
{
 refcount_inc(&u->__count);
 return u;
}
extern void free_uid(struct user_struct *);
# 18 "/home/nathan/src/linux-next/include/linux/cred.h" 2

struct cred;
struct inode;




struct group_info {
 atomic_t usage;
 int ngroups;
 kgid_t gid[0];
} ;
# 40 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct group_info *get_group_info(struct group_info *gi)
{
 atomic_inc(&gi->usage);
 return gi;
}
# 56 "/home/nathan/src/linux-next/include/linux/cred.h"
extern struct group_info init_groups;

extern struct group_info *groups_alloc(int);
extern void groups_free(struct group_info *);

extern int in_group_p(kgid_t);
extern int in_egroup_p(kgid_t);
extern int groups_search(const struct group_info *, kgid_t);

extern int set_current_groups(struct group_info *);
extern void set_groups(struct cred *, struct group_info *);
extern bool may_setgroups(void);
extern void groups_sort(struct group_info *);
# 111 "/home/nathan/src/linux-next/include/linux/cred.h"
struct cred {
 atomic_t usage;







 kuid_t uid;
 kgid_t gid;
 kuid_t suid;
 kgid_t sgid;
 kuid_t euid;
 kgid_t egid;
 kuid_t fsuid;
 kgid_t fsgid;
 unsigned securebits;
 kernel_cap_t cap_inheritable;
 kernel_cap_t cap_permitted;
 kernel_cap_t cap_effective;
 kernel_cap_t cap_bset;
 kernel_cap_t cap_ambient;

 unsigned char jit_keyring;

 struct key *session_keyring;
 struct key *process_keyring;
 struct key *thread_keyring;
 struct key *request_key_auth;




 struct user_struct *user;
 struct user_namespace *user_ns;
 struct group_info *group_info;

 union {
  int non_rcu;
  struct callback_head rcu;
 };
} ;

extern void __put_cred(struct cred *);
extern void exit_creds(struct task_struct *);
extern int copy_creds(struct task_struct *, unsigned long);
extern const struct cred *get_task_cred(struct task_struct *);
extern struct cred *cred_alloc_blank(void);
extern struct cred *prepare_creds(void);
extern struct cred *prepare_exec_creds(void);
extern int commit_creds(struct cred *);
extern void abort_creds(struct cred *);
extern const struct cred *override_creds(const struct cred *);
extern void revert_creds(const struct cred *);
extern struct cred *prepare_kernel_cred(struct task_struct *);
extern int change_create_files_as(struct cred *, struct inode *);
extern int set_security_override(struct cred *, u32);
extern int set_security_override_from_ctx(struct cred *, const char *);
extern int set_create_files_as(struct cred *, struct inode *);
extern int cred_fscmp(const struct cred *, const struct cred *);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) cred_init(void);
# 203 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_creds(const struct cred *cred)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_creds_for_do_exit(struct task_struct *tsk)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void validate_process_creds(void)
{
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cap_ambient_invariant_ok(const struct cred *cred)
{
 return cap_issubset(cred->cap_ambient,
       cap_intersect(cred->cap_permitted,
       cred->cap_inheritable));
}
# 228 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cred *get_new_cred(struct cred *cred)
{
 atomic_inc(&cred->usage);
 return cred;
}
# 247 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cred *get_cred(const struct cred *cred)
{
 struct cred *nonconst_cred = (struct cred *) cred;
 if (!cred)
  return cred;
 validate_creds(cred);
 nonconst_cred->non_rcu = 0;
 return get_new_cred(nonconst_cred);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct cred *get_cred_rcu(const struct cred *cred)
{
 struct cred *nonconst_cred = (struct cred *) cred;
 if (!cred)
  return ((void *)0);
 if (!atomic_inc_not_zero((&nonconst_cred->usage)))
  return ((void *)0);
 validate_creds(cred);
 nonconst_cred->non_rcu = 0;
 return cred;
}
# 280 "/home/nathan/src/linux-next/include/linux/cred.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_cred(const struct cred *_cred)
{
 struct cred *cred = (struct cred *) _cred;

 if (cred) {
  validate_creds(cred);
  if (atomic_dec_and_test(&(cred)->usage))
   __put_cred(cred);
 }
}
# 390 "/home/nathan/src/linux-next/include/linux/cred.h"
extern struct user_namespace init_user_ns;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_namespace *current_user_ns(void)
{
 return &init_user_ns;
}
# 13 "/home/nathan/src/linux-next/include/linux/seq_file.h" 2

struct seq_operations;

struct seq_file {
 char *buf;
 size_t size;
 size_t from;
 size_t count;
 size_t pad_until;
 loff_t index;
 loff_t read_pos;
 u64 version;
 struct mutex lock;
 const struct seq_operations *op;
 int poll_event;
 const struct file *file;
 void *private;
};

struct seq_operations {
 void * (*start) (struct seq_file *m, loff_t *pos);
 void (*stop) (struct seq_file *m, void *v);
 void * (*next) (struct seq_file *m, void *v, loff_t *pos);
 int (*show) (struct seq_file *m, void *v);
};
# 51 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool seq_has_overflowed(struct seq_file *m)
{
 return m->count == m->size;
}
# 64 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t seq_get_buf(struct seq_file *m, char **bufp)
{
 do { if (__builtin_constant_p(m->count > m->size)) { if (m->count > m->size) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (66), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (66), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(m->count > m->size))); } } while (0);
 if (m->count < m->size)
  *bufp = m->buf + m->count;
 else
  *bufp = ((void *)0);

 return m->size - m->count;
}
# 84 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_commit(struct seq_file *m, int num)
{
 if (num < 0) {
  m->count = m->size;
 } else {
  do { if (__builtin_constant_p(m->count + num > m->size)) { if (m->count + num > m->size) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (89), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/seq_file.h"), "i" (89), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(m->count + num > m->size))); } } while (0);
  m->count += num;
 }
}
# 102 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_setwidth(struct seq_file *m, size_t size)
{
 m->pad_until = m->count + size;
}
void seq_pad(struct seq_file *m, char c);

char *mangle_path(char *s, const char *p, const char *esc);
int seq_open(struct file *, const struct seq_operations *);
ssize_t seq_read(struct file *, char *, size_t, loff_t *);
loff_t seq_lseek(struct file *, loff_t, int);
int seq_release(struct inode *, struct file *);
int seq_write(struct seq_file *seq, const void *data, size_t len);

__attribute__((__format__(printf, 2, 0)))
void seq_vprintf(struct seq_file *m, const char *fmt, va_list args);
__attribute__((__format__(printf, 2, 3)))
void seq_printf(struct seq_file *m, const char *fmt, ...);
void seq_putc(struct seq_file *m, char c);
void seq_puts(struct seq_file *m, const char *s);
void seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,
          unsigned long long num, unsigned int width);
void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
    unsigned long long num);
void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num);
void seq_put_hex_ll(struct seq_file *m, const char *delimiter,
      unsigned long long v, unsigned int width);

void seq_escape(struct seq_file *m, const char *s, const char *esc);
void seq_escape_mem_ascii(struct seq_file *m, const char *src, size_t isz);

void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
    int rowsize, int groupsize, const void *buf, size_t len,
    bool ascii);

int seq_path(struct seq_file *, const struct path *, const char *);
int seq_file_path(struct seq_file *, struct file *, const char *);
int seq_dentry(struct seq_file *, struct dentry *, const char *);
int seq_path_root(struct seq_file *m, const struct path *path,
    const struct path *root, const char *esc);

int single_open(struct file *, int (*)(struct seq_file *, void *), void *);
int single_open_size(struct file *, int (*)(struct seq_file *, void *), void *, size_t);
int single_release(struct inode *, struct file *);
void *__seq_open_private(struct file *, const struct seq_operations *, int);
int seq_open_private(struct file *, const struct seq_operations *, int);
int seq_release_private(struct inode *, struct file *);
# 176 "/home/nathan/src/linux-next/include/linux/seq_file.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_namespace *seq_user_ns(struct seq_file *seq)
{



 extern struct user_namespace init_user_ns;
 return &init_user_ns;

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void seq_show_option(struct seq_file *m, const char *name,
       const char *value)
{
 seq_putc(m, ',');
 seq_escape(m, name, ",= \t\n\\");
 if (value) {
  seq_putc(m, '=');
  seq_escape(m, value, ", \t\n\\");
 }
}
# 226 "/home/nathan/src/linux-next/include/linux/seq_file.h"
extern struct list_head *seq_list_start(struct list_head *head,
  loff_t pos);
extern struct list_head *seq_list_start_head(struct list_head *head,
  loff_t pos);
extern struct list_head *seq_list_next(void *v, struct list_head *head,
  loff_t *ppos);





extern struct hlist_node *seq_hlist_start(struct hlist_head *head,
       loff_t pos);
extern struct hlist_node *seq_hlist_start_head(struct hlist_head *head,
            loff_t pos);
extern struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,
      loff_t *ppos);

extern struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,
           loff_t pos);
extern struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,
         loff_t pos);
extern struct hlist_node *seq_hlist_next_rcu(void *v,
         struct hlist_head *head,
         loff_t *ppos);


extern struct hlist_node *seq_hlist_start_percpu(struct hlist_head *head, int *cpu, loff_t pos);

extern struct hlist_node *seq_hlist_next_percpu(void *v, struct hlist_head *head, int *cpu, loff_t *pos);

void seq_file_init(void);
# 7 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h" 2




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/setup.h" 1




# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/setup.h" 1
# 6 "/home/nathan/src/linux-next/arch/powerpc/include/asm/setup.h" 2


extern void ppc_printk_progress(char *s, unsigned short hex);

extern unsigned int rtas_data;
extern unsigned long long memory_limit;
extern bool init_mem_is_free;
extern unsigned long klimit;
extern void *zalloc_maybe_bootmem(size_t size, gfp_t mask);

struct device_node;
extern void note_scsi_host(struct device_node *, void *);


extern unsigned long reloc_offset(void);
extern unsigned long add_reloc_offset(unsigned long);
extern void reloc_got2(unsigned long);



void check_for_initrd(void);
void mem_topology_setup(void);
void initmem_init(void);
void setup_panic(void);



extern void pseries_enable_reloc_on_exc(void);
extern void pseries_disable_reloc_on_exc(void);
extern void pseries_big_endian_exceptions(void);
extern void pseries_little_endian_exceptions(void);







void rfi_flush_enable(bool enable);


enum l1d_flush_type {
 L1D_FLUSH_NONE = 0x1,
 L1D_FLUSH_FALLBACK = 0x2,
 L1D_FLUSH_ORI = 0x4,
 L1D_FLUSH_MTTRIG = 0x8,
};

void setup_rfi_flush(enum l1d_flush_type, bool enable);
void do_rfi_flush_fixups(enum l1d_flush_type types);

void setup_barrier_nospec(void);



void do_barrier_nospec_fixups(bool enable);
extern bool barrier_nospec_enabled;


void do_barrier_nospec_fixups_range(bool enable, void *start, void *end);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void setup_spectre_v2(void) {};

void do_btb_flush_fixups(void);
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h" 2






struct pt_regs;
struct pci_bus;
struct device_node;
struct iommu_table;
struct rtc_time;
struct file;
struct pci_controller;
struct kimage;
struct pci_host_bridge;

struct machdep_calls {
 char *name;


 void (*iommu_save)(void);
 void (*iommu_restore)(void);


 unsigned long (*memory_block_size)(void);



 void (*dma_set_mask)(struct device *dev, u64 dma_mask);

 int (*probe)(void);
 void (*setup_arch)(void);

 void (*show_cpuinfo)(struct seq_file *m);
 void (*show_percpuinfo)(struct seq_file *m, int i);

 unsigned long (*get_proc_freq)(unsigned int cpu);

 void (*init_IRQ)(void);


 unsigned int (*get_irq)(void);



 void (*pcibios_fixup)(void);
 void (*pci_irq_fixup)(struct pci_dev *dev);
 int (*pcibios_root_bridge_prepare)(struct pci_host_bridge
    *bridge);


 int (*pci_setup_phb)(struct pci_controller *host);

 void __attribute__((__noreturn__)) (*restart)(char *cmd);
 void __attribute__((__noreturn__)) (*halt)(void);
 void (*panic)(char *str);
 void (*cpu_die)(void);

 long (*time_init)(void);

 int (*set_rtc_time)(struct rtc_time *);
 void (*get_rtc_time)(struct rtc_time *);
 time64_t (*get_boot_time)(void);
 unsigned char (*rtc_read_val)(int addr);
 void (*rtc_write_val)(int addr, unsigned char val);

 void (*calibrate_decr)(void);

 void (*progress)(char *, unsigned short);


 void (*log_error)(char *buf, unsigned int err_type, int fatal);

 unsigned char (*nvram_read_val)(int addr);
 void (*nvram_write_val)(int addr, unsigned char val);
 ssize_t (*nvram_write)(char *buf, size_t count, loff_t *index);
 ssize_t (*nvram_read)(char *buf, size_t count, loff_t *index);
 ssize_t (*nvram_size)(void);
 void (*nvram_sync)(void);


 int (*system_reset_exception)(struct pt_regs *regs);
 int (*machine_check_exception)(struct pt_regs *regs);
 int (*handle_hmi_exception)(struct pt_regs *regs);


 int (*hmi_exception_early)(struct pt_regs *regs);
 long (*machine_check_early)(struct pt_regs *regs);


 bool (*mce_check_early_recovery)(struct pt_regs *regs);





 long (*feature_call)(unsigned int feature, ...);


 int (*pci_get_legacy_ide_irq)(struct pci_dev *dev, int channel);


 pgprot_t (*phys_mem_access_prot)(struct file *file,
      unsigned long pfn,
      unsigned long size,
      pgprot_t vma_prot);





 void (*power_save)(void);



 void (*enable_pmcs)(void);


 int (*set_dabr)(unsigned long dabr,
        unsigned long dabrx);


 int (*set_dawr)(unsigned long dawr,
        unsigned long dawrx);
# 153 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h"
 int (*pci_exclude_device)(struct pci_controller *, unsigned char, unsigned char);



 void (*pcibios_fixup_resources)(struct pci_dev *);


 void (*pcibios_fixup_bus)(struct pci_bus *);


 void (*pcibios_fixup_phb)(struct pci_controller *hose);





 void (*pcibios_bus_add_device)(struct pci_dev *pdev);

 resource_size_t (*pcibios_default_alignment)(void);
# 183 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h"
 void (*machine_shutdown)(void);


 void (*kexec_cpu_down)(int crash_shutdown, int secondary);






 int (*machine_kexec_prepare)(struct kimage *image);





 void (*machine_kexec)(struct kimage *image);
# 208 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h"
 void (*suspend_disable_irqs)(void);
 void (*suspend_enable_irqs)(void);

 int (*suspend_disable_cpu)(void);


 ssize_t (*cpu_probe)(const char *, size_t);
 ssize_t (*cpu_release)(const char *, size_t);



 int (*get_random_seed)(unsigned long *v);

};

extern void e500_idle(void);
extern void power4_idle(void);
extern void power7_idle(void);
extern void power9_idle(void);
extern void ppc6xx_idle(void);
extern void book3e_idle(void);






extern struct machdep_calls ppc_md;
extern struct machdep_calls *machine_id;
# 252 "/home/nathan/src/linux-next/arch/powerpc/include/asm/machdep.h"
extern void probe_machine(void);






typedef enum sys_ctrler_kind {
 SYS_CTRLER_UNKNOWN = 0,
 SYS_CTRLER_CUDA = 1,
 SYS_CTRLER_PMU = 2,
 SYS_CTRLER_SMU = 3,
} sys_ctrler_t;
extern sys_ctrler_t sys_ctrler;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void log_error(char *buf, unsigned int err_type, int fatal)
{
 if (ppc_md.log_error)
  ppc_md.log_error(buf, err_type, fatal);
}
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 1
# 15 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h" 1
# 16 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/of_fdt.h" 1
# 23 "/home/nathan/src/linux-next/include/linux/of_fdt.h"
struct device_node;


extern void *of_fdt_unflatten_tree(const unsigned long *blob,
       struct device_node *dad,
       struct device_node **mynodes);


extern int __attribute__((__section__(".init.data"))) dt_root_addr_cells;
extern int __attribute__((__section__(".init.data"))) dt_root_size_cells;
extern void *initial_boot_params;

extern char __dtb_start[];
extern char __dtb_end[];


extern u64 of_flat_dt_translate_address(unsigned long node);
extern void of_fdt_limit_memory(int limit);




extern int of_scan_flat_dt(int (*it)(unsigned long node, const char *uname,
         int depth, void *data),
      void *data);
extern int of_scan_flat_dt_subnodes(unsigned long node,
        int (*it)(unsigned long node,
           const char *uname,
           void *data),
        void *data);
extern int of_get_flat_dt_subnode_by_name(unsigned long node,
       const char *uname);
extern const void *of_get_flat_dt_prop(unsigned long node, const char *name,
           int *size);
extern int of_flat_dt_is_compatible(unsigned long node, const char *name);
extern unsigned long of_get_flat_dt_root(void);
extern uint32_t of_get_flat_dt_phandle(unsigned long node);

extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
         int depth, void *data);
extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
         int depth, void *data);
extern int early_init_dt_scan_chosen_stdout(void);
extern void early_init_fdt_scan_reserved_mem(void);
extern void early_init_fdt_reserve_self(void);
extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) early_init_dt_scan_chosen_arch(unsigned long node);
extern void early_init_dt_add_memory_arch(u64 base, u64 size);
extern int early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size);
extern int early_init_dt_reserve_memory_arch(phys_addr_t base, phys_addr_t size,
          bool no_map);
extern u64 dt_mem_next_cell(int s, const __be32 **cellp);


extern int early_init_dt_scan_root(unsigned long node, const char *uname,
       int depth, void *data);

extern bool early_init_dt_scan(void *params);
extern bool early_init_dt_verify(void *params);
extern void early_init_dt_scan_nodes(void);

extern const char *of_flat_dt_get_machine_name(void);
extern const void *of_flat_dt_match_machine(const void *default_match,
  const void * (*get_next_compat)(const char * const**));


extern void unflatten_device_tree(void);
extern void unflatten_and_copy_device_tree(void);
extern void early_init_devtree(void *);
extern void early_get_first_memblock_info(void *, phys_addr_t *);
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/of_address.h" 1








struct of_pci_range_parser {
 struct device_node *node;
 const __be32 *range;
 const __be32 *end;
 int np;
 int pna;
 bool dma;
};

struct of_pci_range {
 u32 pci_space;
 u64 pci_addr;
 u64 cpu_addr;
 u64 size;
 u32 flags;
};





extern u64 of_translate_dma_address(struct device_node *dev,
        const __be32 *in_addr);


extern u64 of_translate_address(struct device_node *np, const __be32 *addr);
extern int of_address_to_resource(struct device_node *dev, int index,
      struct resource *r);
extern void *of_iomap(struct device_node *device, int index);
void *of_io_request_and_map(struct device_node *device,
        int index, const char *name);





extern const __be32 *of_get_address(struct device_node *dev, int index,
      u64 *size, unsigned int *flags);

extern int of_pci_range_parser_init(struct of_pci_range_parser *parser,
   struct device_node *node);
extern int of_pci_dma_range_parser_init(struct of_pci_range_parser *parser,
   struct device_node *node);
extern struct of_pci_range *of_pci_range_parser_one(
     struct of_pci_range_parser *parser,
     struct of_pci_range *range);
extern bool of_dma_is_coherent(struct device_node *np);
# 101 "/home/nathan/src/linux-next/include/linux/of_address.h"
extern int of_address_to_resource(struct device_node *dev, int index,
      struct resource *r);
void *of_iomap(struct device_node *node, int index);
# 118 "/home/nathan/src/linux-next/include/linux/of_address.h"
extern const __be32 *of_get_pci_address(struct device_node *dev, int bar_no,
          u64 *size, unsigned int *flags);
extern int of_pci_address_to_resource(struct device_node *dev, int bar,
          struct resource *r);
extern int of_pci_range_to_resource(struct of_pci_range *range,
        struct device_node *np,
        struct resource *res);
# 22 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/of_irq.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/of_irq.h"
typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);
# 28 "/home/nathan/src/linux-next/include/linux/of_irq.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int of_irq_parse_oldworld(struct device_node *device, int index,
          struct of_phandle_args *out_irq)
{
 return -22;
}


extern int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq);
extern int of_irq_parse_one(struct device_node *device, int index,
     struct of_phandle_args *out_irq);
extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data);
extern int of_irq_to_resource(struct device_node *dev, int index,
         struct resource *r);

extern void of_irq_init(const struct of_device_id *matches);


extern int of_irq_count(struct device_node *dev);
extern int of_irq_get(struct device_node *dev, int index);
extern int of_irq_get_byname(struct device_node *dev, const char *name);
extern int of_irq_to_resource_table(struct device_node *dev,
  struct resource *res, int nr_irqs);
extern struct device_node *of_irq_find_parent(struct device_node *child);
extern struct irq_domain *of_msi_get_domain(struct device *dev,
         struct device_node *np,
         enum irq_domain_bus_token token);
extern struct irq_domain *of_msi_map_get_device_domain(struct device *dev,
             u32 rid);
extern void of_msi_configure(struct device *dev, struct device_node *np);
u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in);
# 108 "/home/nathan/src/linux-next/include/linux/of_irq.h"
extern unsigned int irq_of_parse_and_map(struct device_node *node, int index);
# 23 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/platform_device.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/platform_device.h"
struct mfd_cell;
struct property_entry;
struct platform_device_id;

struct platform_device {
 const char *name;
 int id;
 bool id_auto;
 struct device dev;
 u64 dma_mask;
 u32 num_resources;
 struct resource *resource;

 const struct platform_device_id *id_entry;
 char *driver_override;


 struct mfd_cell *mfd_cell;


 struct pdev_archdata archdata;
};






extern int platform_device_register(struct platform_device *);
extern void platform_device_unregister(struct platform_device *);

extern struct bus_type platform_bus_type;
extern struct device platform_bus;

extern struct resource *platform_get_resource(struct platform_device *,
           unsigned int, unsigned int);
extern struct device *
platform_find_device_by_driver(struct device *start,
          const struct device_driver *drv);
extern void *
devm_platform_ioremap_resource(struct platform_device *pdev,
          unsigned int index);
extern void *
devm_platform_ioremap_resource_wc(struct platform_device *pdev,
      unsigned int index);
extern void *
devm_platform_ioremap_resource_byname(struct platform_device *pdev,
          const char *name);
extern int platform_get_irq(struct platform_device *, unsigned int);
extern int platform_get_irq_optional(struct platform_device *, unsigned int);
extern int platform_irq_count(struct platform_device *);
extern struct resource *platform_get_resource_byname(struct platform_device *,
           unsigned int,
           const char *);
extern int platform_get_irq_byname(struct platform_device *, const char *);
extern int platform_get_irq_byname_optional(struct platform_device *dev,
         const char *name);
extern int platform_add_devices(struct platform_device **, int);

struct platform_device_info {
  struct device *parent;
  struct fwnode_handle *fwnode;
  bool of_node_reused;

  const char *name;
  int id;

  const struct resource *res;
  unsigned int num_res;

  const void *data;
  size_t size_data;
  u64 dma_mask;

  struct property_entry *properties;
};
extern struct platform_device *platform_device_register_full(
  const struct platform_device_info *pdevinfo);
# 111 "/home/nathan/src/linux-next/include/linux/platform_device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct platform_device *platform_device_register_resndata(
  struct device *parent, const char *name, int id,
  const struct resource *res, unsigned int num,
  const void *data, size_t size) {

 struct platform_device_info pdevinfo = {
  .parent = parent,
  .name = name,
  .id = id,
  .res = res,
  .num_res = num,
  .data = data,
  .size_data = size,
  .dma_mask = 0,
 };

 return platform_device_register_full(&pdevinfo);
}
# 152 "/home/nathan/src/linux-next/include/linux/platform_device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct platform_device *platform_device_register_simple(
  const char *name, int id,
  const struct resource *res, unsigned int num)
{
 return platform_device_register_resndata(((void *)0), name, id,
   res, num, ((void *)0), 0);
}
# 176 "/home/nathan/src/linux-next/include/linux/platform_device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct platform_device *platform_device_register_data(
  struct device *parent, const char *name, int id,
  const void *data, size_t size)
{
 return platform_device_register_resndata(parent, name, id,
   ((void *)0), 0, data, size);
}

extern struct platform_device *platform_device_alloc(const char *name, int id);
extern int platform_device_add_resources(struct platform_device *pdev,
      const struct resource *res,
      unsigned int num);
extern int platform_device_add_data(struct platform_device *pdev,
        const void *data, size_t size);
extern int platform_device_add_properties(struct platform_device *pdev,
    const struct property_entry *properties);
extern int platform_device_add(struct platform_device *pdev);
extern void platform_device_del(struct platform_device *pdev);
extern void platform_device_put(struct platform_device *pdev);

struct platform_driver {
 int (*probe)(struct platform_device *);
 int (*remove)(struct platform_device *);
 void (*shutdown)(struct platform_device *);
 int (*suspend)(struct platform_device *, pm_message_t state);
 int (*resume)(struct platform_device *);
 struct device_driver driver;
 const struct platform_device_id *id_table;
 bool prevent_deferred_probe;
};
# 215 "/home/nathan/src/linux-next/include/linux/platform_device.h"
extern int __platform_driver_register(struct platform_driver *,
     struct module *);
extern void platform_driver_unregister(struct platform_driver *);






extern int __platform_driver_probe(struct platform_driver *driver,
  int (*probe)(struct platform_device *), struct module *module);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *platform_get_drvdata(const struct platform_device *pdev)
{
 return dev_get_drvdata(&pdev->dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void platform_set_drvdata(struct platform_device *pdev,
     void *data)
{
 dev_set_drvdata(&pdev->dev, data);
}
# 290 "/home/nathan/src/linux-next/include/linux/platform_device.h"
extern struct platform_device *__platform_create_bundle(
 struct platform_driver *driver, int (*probe)(struct platform_device *),
 struct resource *res, unsigned int n_res,
 const void *data, size_t size, struct module *module);

int __platform_register_drivers(struct platform_driver * const *drivers,
    unsigned int count, struct module *owner);
void platform_unregister_drivers(struct platform_driver * const *drivers,
     unsigned int count);





extern int platform_pm_suspend(struct device *dev);
extern int platform_pm_resume(struct device *dev);
# 323 "/home/nathan/src/linux-next/include/linux/platform_device.h"
extern int platform_dma_configure(struct device *dev);
# 343 "/home/nathan/src/linux-next/include/linux/platform_device.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_sh_early_platform_device(struct platform_device *pdev)
{
 return 0;
}
# 24 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h" 2
# 48 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h"
struct boot_param_header {
 __be32 magic;
 __be32 totalsize;
 __be32 off_dt_struct;
 __be32 off_dt_strings;
 __be32 off_mem_rsvmap;
 __be32 version;
 __be32 last_comp_version;

 __be32 boot_cpuid_phys;

 __be32 dt_strings_size;

 __be32 dt_struct_size;
};
# 71 "/home/nathan/src/linux-next/arch/powerpc/include/asm/prom.h"
void of_parse_dma_window(struct device_node *dn, const __be32 *dma_window,
    unsigned long *busno, unsigned long *phys,
    unsigned long *size);

extern void of_instantiate_rtc(void);

extern int of_get_ibm_chip_id(struct device_node *np);

struct of_drc_info {
 char *drc_type;
 char *drc_name_prefix;
 u32 drc_index_start;
 u32 drc_name_suffix_start;
 u32 num_sequential_elems;
 u32 sequential_inc;
 u32 drc_power_domain;
 u32 last_drc_index;
};

extern int of_read_drc_info_cell(struct property **prop,
   const __be32 **curval, struct of_drc_info *data);
# 18 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h" 2
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/pci.h" 1
# 8 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h" 2




struct device_node;




struct pci_controller_ops {
 void (*dma_dev_setup)(struct pci_dev *pdev);
 void (*dma_bus_setup)(struct pci_bus *bus);
 bool (*iommu_bypass_supported)(struct pci_dev *pdev,
    u64 mask);

 int (*probe_mode)(struct pci_bus *bus);



 bool (*enable_device_hook)(struct pci_dev *pdev);

 void (*disable_device)(struct pci_dev *pdev);

 void (*release_device)(struct pci_dev *pdev);


 resource_size_t (*window_alignment)(struct pci_bus *bus,
         unsigned long type);
 void (*setup_bridge)(struct pci_bus *bus,
     unsigned long type);
 void (*reset_secondary_bus)(struct pci_dev *pdev);


 int (*setup_msi_irqs)(struct pci_dev *pdev,
       int nvec, int type);
 void (*teardown_msi_irqs)(struct pci_dev *pdev);


 void (*shutdown)(struct pci_controller *hose);
};




struct pci_controller {
 struct pci_bus *bus;
 char is_dynamic;

 int node;

 struct device_node *dn;
 struct list_head list_node;
 struct device *parent;

 int first_busno;
 int last_busno;
 int self_busno;
 struct resource busn;

 void *io_base_virt;

 void *io_base_alloc;

 resource_size_t io_base_phys;
 resource_size_t pci_io_size;





 resource_size_t isa_mem_phys;
 resource_size_t isa_mem_size;

 struct pci_controller_ops controller_ops;
 struct pci_ops *ops;
 unsigned int *cfg_addr;
 void *cfg_data;
# 111 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h"
 u32 indirect_type;



 struct resource io_resource;
 struct resource mem_resources[3];
 resource_size_t mem_offset[3];
 int global_number;

 resource_size_t dma_window_base_cur;
 resource_size_t dma_window_size;


 unsigned long buid;
 struct pci_dn *pci_data;


 void *private_data;
 struct npu *npu;
};



extern int early_read_config_byte(struct pci_controller *hose, int bus,
   int dev_fn, int where, u8 *val);
extern int early_read_config_word(struct pci_controller *hose, int bus,
   int dev_fn, int where, u16 *val);
extern int early_read_config_dword(struct pci_controller *hose, int bus,
   int dev_fn, int where, u32 *val);
extern int early_write_config_byte(struct pci_controller *hose, int bus,
   int dev_fn, int where, u8 val);
extern int early_write_config_word(struct pci_controller *hose, int bus,
   int dev_fn, int where, u16 val);
extern int early_write_config_dword(struct pci_controller *hose, int bus,
   int dev_fn, int where, u32 val);

extern int early_find_capability(struct pci_controller *hose, int bus,
     int dev_fn, int cap);

extern void setup_indirect_pci(struct pci_controller* hose,
          resource_size_t cfg_addr,
          resource_size_t cfg_data, u32 flags);

extern int indirect_read_config(struct pci_bus *bus, unsigned int devfn,
    int offset, int len, u32 *val);

extern int __indirect_read_config(struct pci_controller *hose,
      unsigned char bus_number, unsigned int devfn,
      int offset, int len, u32 *val);

extern int indirect_write_config(struct pci_bus *bus, unsigned int devfn,
     int offset, int len, u32 val);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_controller *pci_bus_to_host(const struct pci_bus *bus)
{
 return bus->sysdata;
}
# 181 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h"
struct iommu_table;

struct pci_dn {
 int flags;



 int busno;
 int devfn;
 int vendor_id;
 int device_id;
 int class_code;

 struct pci_dn *parent;
 struct pci_controller *phb;
 struct iommu_table_group *table_group;

 int pci_ext_config_space;

 struct eeh_dev *edev;


 unsigned int pe_number;
# 214 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h"
 int mps;
 struct list_head child_list;
 struct list_head list;
 struct resource holes[6];
};




extern struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,
        int devfn);
extern struct pci_dn *pci_get_pdn(struct pci_dev *pdev);
extern struct pci_dn *pci_add_device_node_info(struct pci_controller *hose,
            struct device_node *dn);
extern void pci_remove_device_node_info(struct device_node *dn);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_device_from_OF_node(struct device_node *np,
       u8 *bus, u8 *devfn)
{
 if (!((struct pci_dn *) (np)->data))
  return -19;
 *bus = ((struct pci_dn *) (np)->data)->busno;
 *devfn = ((struct pci_dn *) (np)->data)->devfn;
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct eeh_dev *pdn_to_eeh_dev(struct pci_dn *pdn)
{
 return pdn ? pdn->edev : ((void *)0);
}





extern struct pci_bus *pci_find_bus_by_node(struct device_node *dn);


extern void pci_hp_remove_devices(struct pci_bus *bus);


extern void pci_hp_add_devices(struct pci_bus *bus);

extern int pcibios_unmap_io_space(struct pci_bus *bus);
extern int pcibios_map_io_space(struct pci_bus *bus);
# 275 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci-bridge.h"
extern struct pci_controller *pci_find_hose_for_OF_device(
   struct device_node* node);

extern struct pci_controller *pci_find_controller_for_domain(int domain_nr);


extern void pci_process_bridge_OF_ranges(struct pci_controller *hose,
   struct device_node *dev, int primary);


extern struct pci_controller *pcibios_alloc_controller(struct device_node *dev);
extern void pcibios_free_controller(struct pci_controller *phb);
extern void pcibios_free_controller_deferred(struct pci_host_bridge *bridge);


extern int pcibios_vaddr_is_ioport(void *address);
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h" 2
# 43 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_get_legacy_ide_irq(struct pci_dev *dev, int channel)
{
 if (ppc_md.pci_get_legacy_ide_irq)
  return ppc_md.pci_get_legacy_ide_irq(dev, channel);
 return channel ? 15 : 14;
}


extern void set_pci_dma_ops(const struct dma_map_ops *dma_ops);
# 67 "/home/nathan/src/linux-next/arch/powerpc/include/asm/pci.h"
extern int pci_domain_nr(struct pci_bus *bus);


extern int pci_proc_domain(struct pci_bus *bus);

struct vm_area_struct;







extern int pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val,
      size_t count);
extern int pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val,
      size_t count);
extern int pci_mmap_legacy_page_range(struct pci_bus *bus,
          struct vm_area_struct *vma,
          enum pci_mmap_state mmap_state);



extern void pcibios_claim_one_bus(struct pci_bus *b);

extern void pcibios_finish_adding_to_bus(struct pci_bus *bus);

extern void pcibios_resource_survey(void);

extern struct pci_controller *init_phb_dynamic(struct device_node *dn);
extern int remove_phb_dynamic(struct pci_controller *phb);

extern struct pci_dev *of_create_pci_dev(struct device_node *node,
     struct pci_bus *bus, int devfn);

extern unsigned int pci_parse_of_flags(u32 addr0, int bridge);

extern void of_scan_pci_bridge(struct pci_dev *dev);

extern void of_scan_bus(struct device_node *node, struct pci_bus *bus);
extern void of_rescan_bus(struct device_node *node, struct pci_bus *bus);

struct file;
extern pgprot_t pci_phys_mem_access_prot(struct file *file,
      unsigned long pfn,
      unsigned long size,
      pgprot_t prot);

extern resource_size_t pcibios_io_space_offset(struct pci_controller *hose);
extern void pcibios_setup_bus_self(struct pci_bus *bus);
extern void pcibios_setup_phb_io_space(struct pci_controller *hose);
extern void pcibios_scan_phb(struct pci_controller *hose);



extern struct pci_dev *pnv_pci_get_gpu_dev(struct pci_dev *npdev);
extern struct pci_dev *pnv_pci_get_npu_dev(struct pci_dev *gpdev, int index);
extern int pnv_npu2_init(struct pci_controller *hose);
extern int pnv_npu2_map_lpar_dev(struct pci_dev *gpdev, unsigned int lparid,
  unsigned long msr);
extern int pnv_npu2_unmap_lpar_dev(struct pci_dev *gpdev);
# 1779 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 1792 "/home/nathan/src/linux-next/include/linux/pci.h"
int pci_mmap_resource_range(struct pci_dev *dev, int bar,
       struct vm_area_struct *vma,
       enum pci_mmap_state mmap_state, int write_combine);
int pci_mmap_page_range(struct pci_dev *pdev, int bar,
   struct vm_area_struct *vma,
   enum pci_mmap_state mmap_state, int write_combine);
# 1807 "/home/nathan/src/linux-next/include/linux/pci.h"
int pci_iobar_pfn(struct pci_dev *pdev, int bar, struct vm_area_struct *vma);
# 1834 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pci_get_drvdata(struct pci_dev *pdev)
{
 return dev_get_drvdata(&pdev->dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
 dev_set_drvdata(&pdev->dev, data);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *pci_name(const struct pci_dev *pdev)
{
 return dev_name(&pdev->dev);
}

void pci_resource_to_user(const struct pci_dev *dev, int bar,
     const struct resource *rsrc,
     resource_size_t *start, resource_size_t *end);
# 1860 "/home/nathan/src/linux-next/include/linux/pci.h"
struct pci_fixup {
 u16 vendor;
 u16 device;
 u32 class;
 unsigned int class_shift;



 void (*hook)(struct pci_dev *dev);

};

enum pci_fixup_pass {
 pci_fixup_early,
 pci_fixup_header,
 pci_fixup_final,
 pci_fixup_enable,
 pci_fixup_resume,
 pci_fixup_suspend,
 pci_fixup_resume_early,
 pci_fixup_suspend_late,
};
# 1965 "/home/nathan/src/linux-next/include/linux/pci.h"
void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev);





void *pcim_iomap(struct pci_dev *pdev, int bar, unsigned long maxlen);
void pcim_iounmap(struct pci_dev *pdev, void *addr);
void * const *pcim_iomap_table(struct pci_dev *pdev);
int pcim_iomap_regions(struct pci_dev *pdev, int mask, const char *name);
int pcim_iomap_regions_request_all(struct pci_dev *pdev, int mask,
       const char *name);
void pcim_iounmap_regions(struct pci_dev *pdev, int mask);

extern int pci_pci_problems;
# 1988 "/home/nathan/src/linux-next/include/linux/pci.h"
extern unsigned long pci_cardbus_io_size;
extern unsigned long pci_cardbus_mem_size;
extern u8 pci_dfl_cache_line_size;
extern u8 pci_cache_line_size;


void pcibios_disable_device(struct pci_dev *dev);
void pcibios_set_master(struct pci_dev *dev);
int pcibios_set_pcie_reset_state(struct pci_dev *dev,
     enum pcie_reset_state state);
int pcibios_add_device(struct pci_dev *dev);
void pcibios_release_device(struct pci_dev *dev);

void pcibios_penalize_isa_irq(int irq, int active);



int pcibios_alloc_irq(struct pci_dev *dev);
void pcibios_free_irq(struct pci_dev *dev);
resource_size_t pcibios_default_alignment(void);
# 2017 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_mmcfg_early_init(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_mmcfg_late_init(void) { }


int pci_ext_cfg_avail(void);

void *pci_ioremap_bar(struct pci_dev *pdev, int bar);
void *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar);
# 2047 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_iov_virtfn_bus(struct pci_dev *dev, int id)
{
 return -38;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_iov_virtfn_devfn(struct pci_dev *dev, int id)
{
 return -38;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)
{ return -19; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_iov_add_virtfn(struct pci_dev *dev, int id)
{
 return -38;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_iov_remove_virtfn(struct pci_dev *dev,
      int id) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_disable_sriov(struct pci_dev *dev) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_num_vf(struct pci_dev *dev) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_vfs_assigned(struct pci_dev *dev)
{ return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_sriov_set_totalvfs(struct pci_dev *dev, u16 numvfs)
{ return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_sriov_get_totalvfs(struct pci_dev *dev)
{ return 0; }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) resource_size_t pci_iov_resource_size(struct pci_dev *dev, int resno)
{ return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_vf_drivers_autoprobe(struct pci_dev *dev, bool probe) { }



void pci_hp_create_module_link(struct pci_slot *pci_slot);
void pci_hp_remove_module_link(struct pci_slot *pci_slot);
# 2093 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_pcie_cap(struct pci_dev *dev)
{
 return dev->pcie_cap;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_is_pcie(struct pci_dev *dev)
{
 return pci_pcie_cap(dev);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 pcie_caps_reg(const struct pci_dev *dev)
{
 return dev->pcie_flags_reg;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_pcie_type(const struct pci_dev *dev)
{
 return (pcie_caps_reg(dev) & 0x00f0) >> 4;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pci_dev *pcie_find_root_port(struct pci_dev *dev)
{
 while (1) {
  if (!pci_is_pcie(dev))
   break;
  if (pci_pcie_type(dev) == 0x4)
   return dev;
  if (!dev->bus->self)
   break;
  dev = dev->bus->self;
 }
 return ((void *)0);
}

void pci_request_acs(void);
bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags);
bool pci_acs_path_enabled(struct pci_dev *start,
     struct pci_dev *end, u16 acs_flags);
int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask);
# 2184 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 pci_vpd_lrdt_size(const u8 *lrdt)
{
 return (u16)lrdt[1] + ((u16)lrdt[2] << 8);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 pci_vpd_lrdt_tag(const u8 *lrdt)
{
 return (u16)(lrdt[0] & 0x7f);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 pci_vpd_srdt_size(const u8 *srdt)
{
 return (*srdt) & 0x07;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 pci_vpd_srdt_tag(const u8 *srdt)
{
 return ((*srdt) & 0x78) >> 3;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 pci_vpd_info_field_size(const u8 *info_field)
{
 return info_field[2];
}
# 2243 "/home/nathan/src/linux-next/include/linux/pci.h"
int pci_vpd_find_tag(const u8 *buf, unsigned int off, unsigned int len, u8 rdt);
# 2255 "/home/nathan/src/linux-next/include/linux/pci.h"
int pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,
         unsigned int len, const char *kw);



struct device_node;
struct irq_domain;
struct irq_domain *pci_host_bridge_of_msi_domain(struct pci_bus *bus);
int pci_parse_request_of_pci_ranges(struct device *dev,
        struct list_head *resources,
        struct list_head *ib_resources,
        struct resource **bus_range);


struct device_node *pcibios_get_phb_of_node(struct pci_bus *bus);
# 2284 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *
pci_device_to_OF_node(const struct pci_dev *pdev)
{
 return pdev ? pdev->dev.of_node : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct device_node *pci_bus_to_OF_node(struct pci_bus *bus)
{
 return bus ? bus->dev.of_node : ((void *)0);
}
# 2302 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct irq_domain *
pci_host_bridge_acpi_msi_domain(struct pci_bus *bus) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_pr3_present(struct pci_dev *pdev) { return false; }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct eeh_dev *pci_dev_to_eeh_dev(struct pci_dev *pdev)
{
 return pdev->dev.archdata.edev;
}


void pci_add_dma_alias(struct pci_dev *dev, u8 devfn_from, unsigned nr_devfns);
bool pci_devs_are_dma_aliases(struct pci_dev *dev1, struct pci_dev *dev2);
int pci_for_each_dma_alias(struct pci_dev *pdev,
      int (*fn)(struct pci_dev *pdev,
         u16 alias, void *data), void *data);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_set_dev_assigned(struct pci_dev *pdev)
{
 pdev->dev_flags |= PCI_DEV_FLAGS_ASSIGNED;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pci_clear_dev_assigned(struct pci_dev *pdev)
{
 pdev->dev_flags &= ~PCI_DEV_FLAGS_ASSIGNED;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_is_dev_assigned(struct pci_dev *pdev)
{
 return (pdev->dev_flags & PCI_DEV_FLAGS_ASSIGNED) == PCI_DEV_FLAGS_ASSIGNED;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_ari_enabled(struct pci_bus *bus)
{
 return bus->self && bus->self->ari_enabled;
}
# 2353 "/home/nathan/src/linux-next/include/linux/pci.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pci_is_thunderbolt_attached(struct pci_dev *pdev)
{
 struct pci_dev *parent = pdev;

 if (pdev->is_thunderbolt)
  return true;

 while ((parent = pci_upstream_bridge(parent)))
  if (parent->is_thunderbolt)
   return true;

 return false;
}


void pci_uevent_ers(struct pci_dev *pdev, enum pci_ers_result err_type);




# 1 "/home/nathan/src/linux-next/include/linux/pci-dma-compat.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/pci-dma-compat.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *
pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
       dma_addr_t *dma_handle)
{
 return dma_alloc_coherent(&hwdev->dev, size, dma_handle, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *
pci_zalloc_consistent(struct pci_dev *hwdev, size_t size,
        dma_addr_t *dma_handle)
{
 return dma_alloc_coherent(&hwdev->dev, size, dma_handle, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_free_consistent(struct pci_dev *hwdev, size_t size,
      void *vaddr, dma_addr_t dma_handle)
{
 dma_free_coherent(&hwdev->dev, size, vaddr, dma_handle);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t
pci_map_single(struct pci_dev *hwdev, void *ptr, size_t size, int direction)
{
 return dma_map_single_attrs(&hwdev->dev, ptr, size, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
   size_t size, int direction)
{
 dma_unmap_single_attrs(&hwdev->dev, dma_addr, size, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t
pci_map_page(struct pci_dev *hwdev, struct page *page,
      unsigned long offset, size_t size, int direction)
{
 return dma_map_page_attrs(&hwdev->dev, page, offset, size, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address,
        size_t size, int direction)
{
 dma_unmap_page_attrs(&hwdev->dev, dma_address, size, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
    int nents, int direction)
{
 return dma_map_sg_attrs(&hwdev->dev, sg, nents, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
      int nents, int direction)
{
 dma_unmap_sg_attrs(&hwdev->dev, sg, nents, (enum dma_data_direction)direction, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_dma_sync_single_for_cpu(struct pci_dev *hwdev, dma_addr_t dma_handle,
      size_t size, int direction)
{
 dma_sync_single_for_cpu(&hwdev->dev, dma_handle, size, (enum dma_data_direction)direction);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_dma_sync_single_for_device(struct pci_dev *hwdev, dma_addr_t dma_handle,
      size_t size, int direction)
{
 dma_sync_single_for_device(&hwdev->dev, dma_handle, size, (enum dma_data_direction)direction);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev, struct scatterlist *sg,
  int nelems, int direction)
{
 dma_sync_sg_for_cpu(&hwdev->dev, sg, nelems, (enum dma_data_direction)direction);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
pci_dma_sync_sg_for_device(struct pci_dev *hwdev, struct scatterlist *sg,
  int nelems, int direction)
{
 dma_sync_sg_for_device(&hwdev->dev, sg, nelems, (enum dma_data_direction)direction);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
pci_dma_mapping_error(struct pci_dev *pdev, dma_addr_t dma_addr)
{
 return dma_mapping_error(&pdev->dev, dma_addr);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
 return dma_set_mask(&dev->dev, mask);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
{
 return dma_set_coherent_mask(&dev->dev, mask);
}
# 2373 "/home/nathan/src/linux-next/include/linux/pci.h" 2
# 18 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/etherdevice.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
# 1 "/home/nathan/src/linux-next/include/linux/if_ether.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/if_ether.h"
# 1 "/home/nathan/src/linux-next/include/linux/skbuff.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/skbuff.h"
# 1 "/home/nathan/src/linux-next/include/linux/bvec.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/bvec.h"
struct bio_vec {
 struct page *bv_page;
 unsigned int bv_len;
 unsigned int bv_offset;
};

struct bvec_iter {
 sector_t bi_sector;

 unsigned int bi_size;

 unsigned int bi_idx;

 unsigned int bi_bvec_done;

};

struct bvec_iter_all {
 struct bio_vec bv;
 int idx;
 unsigned done;
};
# 87 "/home/nathan/src/linux-next/include/linux/bvec.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bvec_iter_advance(const struct bio_vec *bv,
  struct bvec_iter *iter, unsigned bytes)
{
 unsigned int idx = iter->bi_idx;

 if (({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(bytes > iter->bi_size); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("Attempted to advance past end of bvec iter\n"); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/bvec.h"), "i" (93), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); })) {

  iter->bi_size = 0;
  return false;
 }

 iter->bi_size -= bytes;
 bytes += iter->bi_bvec_done;

 while (bytes && bytes >= bv[idx].bv_len) {
  bytes -= bv[idx].bv_len;
  idx++;
 }

 iter->bi_idx = idx;
 iter->bi_bvec_done = bytes;
 return true;
}
# 126 "/home/nathan/src/linux-next/include/linux/bvec.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio_vec *bvec_init_iter_all(struct bvec_iter_all *iter_all)
{
 iter_all->done = 0;
 iter_all->idx = 0;

 return &iter_all->bv;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bvec_advance(const struct bio_vec *bvec,
    struct bvec_iter_all *iter_all)
{
 struct bio_vec *bv = &iter_all->bv;

 if (iter_all->done) {
  bv->bv_page++;
  bv->bv_offset = 0;
 } else {
  bv->bv_page = bvec->bv_page + (bvec->bv_offset >> 16);
  bv->bv_offset = bvec->bv_offset & ~(~((1 << 16) - 1));
 }
 bv->bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned int)((1UL << 16) - bv->bv_offset)) *)1 == (typeof((unsigned int)(bvec->bv_len - iter_all->done)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned int)((1UL << 16) - bv->bv_offset)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned int)(bvec->bv_len - iter_all->done)) * 0l)) : (int *)8))))), (((unsigned int)((1UL << 16) - bv->bv_offset)) < ((unsigned int)(bvec->bv_len - iter_all->done)) ? ((unsigned int)((1UL << 16) - bv->bv_offset)) : ((unsigned int)(bvec->bv_len - iter_all->done))), ({ typeof((unsigned int)((1UL << 16) - bv->bv_offset)) __UNIQUE_ID___x22 = ((unsigned int)((1UL << 16) - bv->bv_offset)); typeof((unsigned int)(bvec->bv_len - iter_all->done)) __UNIQUE_ID___y23 = ((unsigned int)(bvec->bv_len - iter_all->done)); ((__UNIQUE_ID___x22) < (__UNIQUE_ID___y23) ? (__UNIQUE_ID___x22) : (__UNIQUE_ID___y23)); }));

 iter_all->done += bv->bv_len;

 if (iter_all->done == bvec->bv_len) {
  iter_all->idx++;
  iter_all->done = 0;
 }
}
# 18 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/socket.h" 1





# 1 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/socket.h" 1
# 19 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/socket.h"
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/socket.h" 1





# 1 "./arch/powerpc/include/generated/uapi/asm/sockios.h" 1
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/sockios.h" 1
# 2 "./arch/powerpc/include/generated/uapi/asm/sockios.h" 2
# 7 "/home/nathan/src/linux-next/include/uapi/asm-generic/socket.h" 2
# 20 "/home/nathan/src/linux-next/arch/powerpc/include/uapi/asm/socket.h" 2
# 7 "/home/nathan/src/linux-next/include/linux/socket.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/sockios.h" 1
# 23 "/home/nathan/src/linux-next/include/uapi/linux/sockios.h"
# 1 "./arch/powerpc/include/generated/uapi/asm/sockios.h" 1
# 24 "/home/nathan/src/linux-next/include/uapi/linux/sockios.h" 2
# 8 "/home/nathan/src/linux-next/include/linux/socket.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/uio.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/uio.h"
# 1 "/home/nathan/src/linux-next/include/crypto/hash.h" 1
# 11 "/home/nathan/src/linux-next/include/crypto/hash.h"
# 1 "/home/nathan/src/linux-next/include/linux/crypto.h" 1
# 131 "/home/nathan/src/linux-next/include/linux/crypto.h"
struct scatterlist;
struct crypto_async_request;
struct crypto_tfm;
struct crypto_type;

typedef void (*crypto_completion_t)(struct crypto_async_request *req, int err);
# 145 "/home/nathan/src/linux-next/include/linux/crypto.h"
struct crypto_async_request {
 struct list_head list;
 crypto_completion_t complete;
 void *data;
 struct crypto_tfm *tfm;

 u32 flags;
};
# 208 "/home/nathan/src/linux-next/include/linux/crypto.h"
struct cipher_alg {
 unsigned int cia_min_keysize;
 unsigned int cia_max_keysize;
 int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,
                   unsigned int keylen);
 void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};
# 228 "/home/nathan/src/linux-next/include/linux/crypto.h"
struct compress_alg {
 int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,
       unsigned int slen, u8 *dst, unsigned int *dlen);
 int (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,
         unsigned int slen, u8 *dst, unsigned int *dlen);
};
# 435 "/home/nathan/src/linux-next/include/linux/crypto.h"
struct crypto_alg {
 struct list_head cra_list;
 struct list_head cra_users;

 u32 cra_flags;
 unsigned int cra_blocksize;
 unsigned int cra_ctxsize;
 unsigned int cra_alignmask;

 int cra_priority;
 refcount_t cra_refcnt;

 char cra_name[128];
 char cra_driver_name[128];

 const struct crypto_type *cra_type;

 union {
  struct cipher_alg cipher;
  struct compress_alg compress;
 } cra_u;

 int (*cra_init)(struct crypto_tfm *tfm);
 void (*cra_exit)(struct crypto_tfm *tfm);
 void (*cra_destroy)(struct crypto_alg *alg);

 struct module *cra_module;
# 475 "/home/nathan/src/linux-next/include/linux/crypto.h"
} __attribute__ ((__aligned__(__alignof__(unsigned long long))));
# 498 "/home/nathan/src/linux-next/include/linux/crypto.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_init(struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_get(struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_aead_encrypt(unsigned int cryptlen, struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_aead_decrypt(unsigned int cryptlen, struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_ahash_update(unsigned int nbytes, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_ahash_final(unsigned int nbytes, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_akcipher_encrypt(unsigned int src_len, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_akcipher_decrypt(unsigned int src_len, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_akcipher_sign(int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_akcipher_verify(int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_compress(unsigned int slen, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_decompress(unsigned int slen, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_kpp_set_secret(struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_kpp_generate_public_key(struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_kpp_compute_shared_secret(struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_rng_seed(struct crypto_alg *alg, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_rng_generate(struct crypto_alg *alg, unsigned int dlen, int ret)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_skcipher_encrypt(unsigned int cryptlen, int ret, struct crypto_alg *alg)
{}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_stats_skcipher_decrypt(unsigned int cryptlen, int ret, struct crypto_alg *alg)
{}




struct crypto_wait {
 struct completion completion;
 int err;
};
# 555 "/home/nathan/src/linux-next/include/linux/crypto.h"
void crypto_req_done(struct crypto_async_request *req, int err);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_wait_req(int err, struct crypto_wait *wait)
{
 switch (err) {
 case -115:
 case -16:
  wait_for_completion(&wait->completion);
  reinit_completion(&wait->completion);
  err = wait->err;
  break;
 }

 return err;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_init_wait(struct crypto_wait *wait)
{
 __init_completion(&wait->completion);
}




int crypto_register_alg(struct crypto_alg *alg);
void crypto_unregister_alg(struct crypto_alg *alg);
int crypto_register_algs(struct crypto_alg *algs, int count);
void crypto_unregister_algs(struct crypto_alg *algs, int count);




int crypto_has_alg(const char *name, u32 type, u32 mask);







struct crypto_tfm {

 u32 crt_flags;

 void (*exit)(struct crypto_tfm *tfm);

 struct crypto_alg *__crt_alg;

 void *__crt_ctx[] __attribute__ ((__aligned__(__alignof__(unsigned long long))));
};

struct crypto_cipher {
 struct crypto_tfm base;
};

struct crypto_comp {
 struct crypto_tfm base;
};

enum {
 CRYPTOA_UNSPEC,
 CRYPTOA_ALG,
 CRYPTOA_TYPE,
 CRYPTOA_U32,
 __CRYPTOA_MAX,
};






struct crypto_attr_alg {
 char name[128];
};

struct crypto_attr_type {
 u32 type;
 u32 mask;
};

struct crypto_attr_u32 {
 u32 num;
};





struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask);
void crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_free_tfm(struct crypto_tfm *tfm)
{
 return crypto_destroy_tfm(tfm, tfm);
}

int alg_test(const char *driver, const char *alg, u32 type, u32 mask);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_name;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_driver_name;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_tfm_alg_priority(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_priority;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_flags & 0x0000000f;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_blocksize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_tfm_alg_alignmask(struct crypto_tfm *tfm)
{
 return tfm->__crt_alg->cra_alignmask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 crypto_tfm_get_flags(struct crypto_tfm *tfm)
{
 return tfm->crt_flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_tfm_set_flags(struct crypto_tfm *tfm, u32 flags)
{
 tfm->crt_flags |= flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_tfm_clear_flags(struct crypto_tfm *tfm, u32 flags)
{
 tfm->crt_flags &= ~flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *crypto_tfm_ctx(struct crypto_tfm *tfm)
{
 return tfm->__crt_ctx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_tfm_ctx_alignment(void)
{
 struct crypto_tfm *tfm;
 return __alignof__(tfm->__crt_ctx);
}
# 730 "/home/nathan/src/linux-next/include/linux/crypto.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_cipher *__crypto_cipher_cast(struct crypto_tfm *tfm)
{
 return (struct crypto_cipher *)tfm;
}
# 749 "/home/nathan/src/linux-next/include/linux/crypto.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_cipher *crypto_alloc_cipher(const char *alg_name,
       u32 type, u32 mask)
{
 type &= ~0x0000000f;
 type |= 0x00000001;
 mask |= 0x0000000f;

 return __crypto_cipher_cast(crypto_alloc_base(alg_name, type, mask));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_tfm *crypto_cipher_tfm(struct crypto_cipher *tfm)
{
 return &tfm->base;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_free_cipher(struct crypto_cipher *tfm)
{
 crypto_free_tfm(crypto_cipher_tfm(tfm));
}
# 783 "/home/nathan/src/linux-next/include/linux/crypto.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_has_cipher(const char *alg_name, u32 type, u32 mask)
{
 type &= ~0x0000000f;
 type |= 0x00000001;
 mask |= 0x0000000f;

 return crypto_has_alg(alg_name, type, mask);
}
# 802 "/home/nathan/src/linux-next/include/linux/crypto.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_cipher_blocksize(struct crypto_cipher *tfm)
{
 return crypto_tfm_alg_blocksize(crypto_cipher_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_cipher_alignmask(struct crypto_cipher *tfm)
{
 return crypto_tfm_alg_alignmask(crypto_cipher_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 crypto_cipher_get_flags(struct crypto_cipher *tfm)
{
 return crypto_tfm_get_flags(crypto_cipher_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_cipher_set_flags(struct crypto_cipher *tfm,
        u32 flags)
{
 crypto_tfm_set_flags(crypto_cipher_tfm(tfm), flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_cipher_clear_flags(struct crypto_cipher *tfm,
          u32 flags)
{
 crypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);
}
# 845 "/home/nathan/src/linux-next/include/linux/crypto.h"
int crypto_cipher_setkey(struct crypto_cipher *tfm,
    const u8 *key, unsigned int keylen);
# 857 "/home/nathan/src/linux-next/include/linux/crypto.h"
void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,
          u8 *dst, const u8 *src);
# 869 "/home/nathan/src/linux-next/include/linux/crypto.h"
void crypto_cipher_decrypt_one(struct crypto_cipher *tfm,
          u8 *dst, const u8 *src);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_comp *__crypto_comp_cast(struct crypto_tfm *tfm)
{
 return (struct crypto_comp *)tfm;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_comp *crypto_alloc_comp(const char *alg_name,
          u32 type, u32 mask)
{
 type &= ~0x0000000f;
 type |= 0x00000002;
 mask |= 0x0000000f;

 return __crypto_comp_cast(crypto_alloc_base(alg_name, type, mask));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_tfm *crypto_comp_tfm(struct crypto_comp *tfm)
{
 return &tfm->base;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_free_comp(struct crypto_comp *tfm)
{
 crypto_free_tfm(crypto_comp_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_has_comp(const char *alg_name, u32 type, u32 mask)
{
 type &= ~0x0000000f;
 type |= 0x00000002;
 mask |= 0x0000000f;

 return crypto_has_alg(alg_name, type, mask);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_comp_name(struct crypto_comp *tfm)
{
 return crypto_tfm_alg_name(crypto_comp_tfm(tfm));
}

int crypto_comp_compress(struct crypto_comp *tfm,
    const u8 *src, unsigned int slen,
    u8 *dst, unsigned int *dlen);

int crypto_comp_decompress(struct crypto_comp *tfm,
      const u8 *src, unsigned int slen,
      u8 *dst, unsigned int *dlen);
# 12 "/home/nathan/src/linux-next/include/crypto/hash.h" 2


struct crypto_ahash;
# 42 "/home/nathan/src/linux-next/include/crypto/hash.h"
struct hash_alg_common {
 unsigned int digestsize;
 unsigned int statesize;

 struct crypto_alg base;
};

struct ahash_request {
 struct crypto_async_request base;

 unsigned int nbytes;
 struct scatterlist *src;
 u8 *result;


 void *priv;

 void *__ctx[] __attribute__ ((__aligned__(__alignof__(unsigned long long))));
};
# 128 "/home/nathan/src/linux-next/include/crypto/hash.h"
struct ahash_alg {
 int (*init)(struct ahash_request *req);
 int (*update)(struct ahash_request *req);
 int (*final)(struct ahash_request *req);
 int (*finup)(struct ahash_request *req);
 int (*digest)(struct ahash_request *req);
 int (*export)(struct ahash_request *req, void *out);
 int (*import)(struct ahash_request *req, const void *in);
 int (*setkey)(struct crypto_ahash *tfm, const u8 *key,
        unsigned int keylen);

 struct hash_alg_common halg;
};

struct shash_desc {
 struct crypto_shash *tfm;
 void *__ctx[] __attribute__ ((__aligned__(__alignof__(unsigned long long))));
};
# 190 "/home/nathan/src/linux-next/include/crypto/hash.h"
struct shash_alg {
 int (*init)(struct shash_desc *desc);
 int (*update)(struct shash_desc *desc, const u8 *data,
        unsigned int len);
 int (*final)(struct shash_desc *desc, u8 *out);
 int (*finup)(struct shash_desc *desc, const u8 *data,
       unsigned int len, u8 *out);
 int (*digest)(struct shash_desc *desc, const u8 *data,
        unsigned int len, u8 *out);
 int (*export)(struct shash_desc *desc, void *out);
 int (*import)(struct shash_desc *desc, const void *in);
 int (*setkey)(struct crypto_shash *tfm, const u8 *key,
        unsigned int keylen);
 int (*init_tfm)(struct crypto_shash *tfm);
 void (*exit_tfm)(struct crypto_shash *tfm);

 unsigned int descsize;


 unsigned int digestsize
  __attribute__ ((aligned(__alignof__(struct hash_alg_common))));
 unsigned int statesize;

 struct crypto_alg base;
};

struct crypto_ahash {
 int (*init)(struct ahash_request *req);
 int (*update)(struct ahash_request *req);
 int (*final)(struct ahash_request *req);
 int (*finup)(struct ahash_request *req);
 int (*digest)(struct ahash_request *req);
 int (*export)(struct ahash_request *req, void *out);
 int (*import)(struct ahash_request *req, const void *in);
 int (*setkey)(struct crypto_ahash *tfm, const u8 *key,
        unsigned int keylen);

 unsigned int reqsize;
 struct crypto_tfm base;
};

struct crypto_shash {
 unsigned int descsize;
 struct crypto_tfm base;
};
# 246 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_ahash *__crypto_ahash_cast(struct crypto_tfm *tfm)
{
 return ({ void *__mptr = (void *)(tfm); do { extern void __compiletime_assert_248(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(tfm)), typeof(((struct crypto_ahash *)0)->base)) && !__builtin_types_compatible_p(typeof(*(tfm)), typeof(void))))) __compiletime_assert_248(); } while (0); ((struct crypto_ahash *)(__mptr - __builtin_offsetof(struct crypto_ahash, base))); });
}
# 265 "/home/nathan/src/linux-next/include/crypto/hash.h"
struct crypto_ahash *crypto_alloc_ahash(const char *alg_name, u32 type,
     u32 mask);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_tfm *crypto_ahash_tfm(struct crypto_ahash *tfm)
{
 return &tfm->base;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_free_ahash(struct crypto_ahash *tfm)
{
 crypto_destroy_tfm(tfm, crypto_ahash_tfm(tfm));
}
# 292 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_has_ahash(const char *alg_name, u32 type, u32 mask);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_ahash_alg_name(struct crypto_ahash *tfm)
{
 return crypto_tfm_alg_name(crypto_ahash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_ahash_driver_name(struct crypto_ahash *tfm)
{
 return crypto_tfm_alg_driver_name(crypto_ahash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_ahash_alignmask(
 struct crypto_ahash *tfm)
{
 return crypto_tfm_alg_alignmask(crypto_ahash_tfm(tfm));
}
# 319 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_ahash_blocksize(struct crypto_ahash *tfm)
{
 return crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hash_alg_common *__crypto_hash_alg_common(
 struct crypto_alg *alg)
{
 return ({ void *__mptr = (void *)(alg); do { extern void __compiletime_assert_327(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(alg)), typeof(((struct hash_alg_common *)0)->base)) && !__builtin_types_compatible_p(typeof(*(alg)), typeof(void))))) __compiletime_assert_327(); } while (0); ((struct hash_alg_common *)(__mptr - __builtin_offsetof(struct hash_alg_common, base))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct hash_alg_common *crypto_hash_alg_common(
 struct crypto_ahash *tfm)
{
 return __crypto_hash_alg_common(crypto_ahash_tfm(tfm)->__crt_alg);
}
# 346 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_ahash_digestsize(struct crypto_ahash *tfm)
{
 return crypto_hash_alg_common(tfm)->digestsize;
}
# 361 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_ahash_statesize(struct crypto_ahash *tfm)
{
 return crypto_hash_alg_common(tfm)->statesize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 crypto_ahash_get_flags(struct crypto_ahash *tfm)
{
 return crypto_tfm_get_flags(crypto_ahash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_ahash_set_flags(struct crypto_ahash *tfm, u32 flags)
{
 crypto_tfm_set_flags(crypto_ahash_tfm(tfm), flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_ahash_clear_flags(struct crypto_ahash *tfm, u32 flags)
{
 crypto_tfm_clear_flags(crypto_ahash_tfm(tfm), flags);
}
# 391 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_ahash *crypto_ahash_reqtfm(
 struct ahash_request *req)
{
 return __crypto_ahash_cast(req->base.tfm);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_ahash_reqsize(struct crypto_ahash *tfm)
{
 return tfm->reqsize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *ahash_request_ctx(struct ahash_request *req)
{
 return req->__ctx;
}
# 424 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
   unsigned int keylen);
# 438 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_ahash_finup(struct ahash_request *req);
# 455 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_ahash_final(struct ahash_request *req);
# 468 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_ahash_digest(struct ahash_request *req);
# 481 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_ahash_export(struct ahash_request *req, void *out)
{
 return crypto_ahash_reqtfm(req)->export(req, out);
}
# 497 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_ahash_import(struct ahash_request *req, const void *in)
{
 struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);

 if (crypto_ahash_get_flags(tfm) & 0x00000001)
  return -126;

 return tfm->import(req, in);
}
# 518 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_ahash_init(struct ahash_request *req)
{
 struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);

 if (crypto_ahash_get_flags(tfm) & 0x00000001)
  return -126;

 return tfm->init(req);
}
# 539 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_ahash_update(struct ahash_request *req)
{
 struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 struct crypto_alg *alg = tfm->base.__crt_alg;
 unsigned int nbytes = req->nbytes;
 int ret;

 crypto_stats_get(alg);
 ret = crypto_ahash_reqtfm(req)->update(req);
 crypto_stats_ahash_update(nbytes, ret, alg);
 return ret;
}
# 571 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ahash_request_set_tfm(struct ahash_request *req,
      struct crypto_ahash *tfm)
{
 req->base.tfm = crypto_ahash_tfm(tfm);
}
# 589 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ahash_request *ahash_request_alloc(
 struct crypto_ahash *tfm, gfp_t gfp)
{
 struct ahash_request *req;

 req = kmalloc(sizeof(struct ahash_request) +
        crypto_ahash_reqsize(tfm), gfp);

 if (__builtin_expect(!!(req), 1))
  ahash_request_set_tfm(req, tfm);

 return req;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ahash_request_free(struct ahash_request *req)
{
 kzfree(req);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ahash_request_zero(struct ahash_request *req)
{
 memzero_explicit(req, sizeof(*req) +
         crypto_ahash_reqsize(crypto_ahash_reqtfm(req)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ahash_request *ahash_request_cast(
 struct crypto_async_request *req)
{
 return ({ void *__mptr = (void *)(req); do { extern void __compiletime_assert_621(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(req)), typeof(((struct ahash_request *)0)->base)) && !__builtin_types_compatible_p(typeof(*(req)), typeof(void))))) __compiletime_assert_621(); } while (0); ((struct ahash_request *)(__mptr - __builtin_offsetof(struct ahash_request, base))); });
}
# 649 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ahash_request_set_callback(struct ahash_request *req,
           u32 flags,
           crypto_completion_t compl,
           void *data)
{
 req->base.complete = compl;
 req->base.data = data;
 req->base.flags = flags;
}
# 672 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ahash_request_set_crypt(struct ahash_request *req,
        struct scatterlist *src, u8 *result,
        unsigned int nbytes)
{
 req->src = src;
 req->nbytes = nbytes;
 req->result = result;
}
# 708 "/home/nathan/src/linux-next/include/crypto/hash.h"
struct crypto_shash *crypto_alloc_shash(const char *alg_name, u32 type,
     u32 mask);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct crypto_tfm *crypto_shash_tfm(struct crypto_shash *tfm)
{
 return &tfm->base;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_free_shash(struct crypto_shash *tfm)
{
 crypto_destroy_tfm(tfm, crypto_shash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_shash_alg_name(struct crypto_shash *tfm)
{
 return crypto_tfm_alg_name(crypto_shash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *crypto_shash_driver_name(struct crypto_shash *tfm)
{
 return crypto_tfm_alg_driver_name(crypto_shash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_shash_alignmask(
 struct crypto_shash *tfm)
{
 return crypto_tfm_alg_alignmask(crypto_shash_tfm(tfm));
}
# 750 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_shash_blocksize(struct crypto_shash *tfm)
{
 return crypto_tfm_alg_blocksize(crypto_shash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct shash_alg *__crypto_shash_alg(struct crypto_alg *alg)
{
 return ({ void *__mptr = (void *)(alg); do { extern void __compiletime_assert_757(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(alg)), typeof(((struct shash_alg *)0)->base)) && !__builtin_types_compatible_p(typeof(*(alg)), typeof(void))))) __compiletime_assert_757(); } while (0); ((struct shash_alg *)(__mptr - __builtin_offsetof(struct shash_alg, base))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct shash_alg *crypto_shash_alg(struct crypto_shash *tfm)
{
 return __crypto_shash_alg(crypto_shash_tfm(tfm)->__crt_alg);
}
# 774 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_shash_digestsize(struct crypto_shash *tfm)
{
 return crypto_shash_alg(tfm)->digestsize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_shash_statesize(struct crypto_shash *tfm)
{
 return crypto_shash_alg(tfm)->statesize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 crypto_shash_get_flags(struct crypto_shash *tfm)
{
 return crypto_tfm_get_flags(crypto_shash_tfm(tfm));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_shash_set_flags(struct crypto_shash *tfm, u32 flags)
{
 crypto_tfm_set_flags(crypto_shash_tfm(tfm), flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void crypto_shash_clear_flags(struct crypto_shash *tfm, u32 flags)
{
 crypto_tfm_clear_flags(crypto_shash_tfm(tfm), flags);
}
# 814 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int crypto_shash_descsize(struct crypto_shash *tfm)
{
 return tfm->descsize;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *shash_desc_ctx(struct shash_desc *desc)
{
 return desc->__ctx;
}
# 837 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_shash_setkey(struct crypto_shash *tfm, const u8 *key,
   unsigned int keylen);
# 855 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_shash_digest(struct shash_desc *desc, const u8 *data,
   unsigned int len, u8 *out);
# 870 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_shash_export(struct shash_desc *desc, void *out)
{
 return crypto_shash_alg(desc->tfm)->export(desc, out);
}
# 887 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_shash_import(struct shash_desc *desc, const void *in)
{
 struct crypto_shash *tfm = desc->tfm;

 if (crypto_shash_get_flags(tfm) & 0x00000001)
  return -126;

 return crypto_shash_alg(tfm)->import(desc, in);
}
# 909 "/home/nathan/src/linux-next/include/crypto/hash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int crypto_shash_init(struct shash_desc *desc)
{
 struct crypto_shash *tfm = desc->tfm;

 if (crypto_shash_get_flags(tfm) & 0x00000001)
  return -126;

 return crypto_shash_alg(tfm)->init(desc);
}
# 931 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_shash_update(struct shash_desc *desc, const u8 *data,
   unsigned int len);
# 948 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_shash_final(struct shash_desc *desc, u8 *out);
# 965 "/home/nathan/src/linux-next/include/crypto/hash.h"
int crypto_shash_finup(struct shash_desc *desc, const u8 *data,
         unsigned int len, u8 *out);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void shash_desc_zero(struct shash_desc *desc)
{
 memzero_explicit(desc,
    sizeof(*desc) + crypto_shash_descsize(desc->tfm));
}
# 11 "/home/nathan/src/linux-next/include/linux/uio.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/uio.h" 1
# 17 "/home/nathan/src/linux-next/include/uapi/linux/uio.h"
struct iovec
{
 void *iov_base;
 __kernel_size_t iov_len;
};
# 12 "/home/nathan/src/linux-next/include/linux/uio.h" 2

struct page;
struct pipe_inode_info;

struct kvec {
 void *iov_base;
 size_t iov_len;
};

enum iter_type {

 ITER_IOVEC = 4,
 ITER_KVEC = 8,
 ITER_BVEC = 16,
 ITER_PIPE = 32,
 ITER_DISCARD = 64,
};

struct iov_iter {





 unsigned int type;
 size_t iov_offset;
 size_t count;
 union {
  const struct iovec *iov;
  const struct kvec *kvec;
  const struct bio_vec *bvec;
  struct pipe_inode_info *pipe;
 };
 union {
  unsigned long nr_segs;
  struct {
   unsigned int head;
   unsigned int start_head;
  };
 };
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum iter_type iov_iter_type(const struct iov_iter *i)
{
 return i->type & ~(0 | 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool iter_is_iovec(const struct iov_iter *i)
{
 return iov_iter_type(i) == ITER_IOVEC;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool iov_iter_is_kvec(const struct iov_iter *i)
{
 return iov_iter_type(i) == ITER_KVEC;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool iov_iter_is_bvec(const struct iov_iter *i)
{
 return iov_iter_type(i) == ITER_BVEC;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool iov_iter_is_pipe(const struct iov_iter *i)
{
 return iov_iter_type(i) == ITER_PIPE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool iov_iter_is_discard(const struct iov_iter *i)
{
 return iov_iter_type(i) == ITER_DISCARD;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char iov_iter_rw(const struct iov_iter *i)
{
 return i->type & (0 | 1);
}
# 96 "/home/nathan/src/linux-next/include/linux/uio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
{
 unsigned long seg;
 size_t ret = 0;

 for (seg = 0; seg < nr_segs; seg++)
  ret += iov[seg].iov_len;
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct iovec iov_iter_iovec(const struct iov_iter *iter)
{
 return (struct iovec) {
  .iov_base = iter->iov->iov_base + iter->iov_offset,
  .iov_len = __builtin_choose_expr(((!!(sizeof((typeof(iter->count) *)1 == (typeof(iter->iov->iov_len - iter->iov_offset) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(iter->count) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(iter->iov->iov_len - iter->iov_offset) * 0l)) : (int *)8))))), ((iter->count) < (iter->iov->iov_len - iter->iov_offset) ? (iter->count) : (iter->iov->iov_len - iter->iov_offset)), ({ typeof(iter->count) __UNIQUE_ID___x24 = (iter->count); typeof(iter->iov->iov_len - iter->iov_offset) __UNIQUE_ID___y25 = (iter->iov->iov_len - iter->iov_offset); ((__UNIQUE_ID___x24) < (__UNIQUE_ID___y25) ? (__UNIQUE_ID___x24) : (__UNIQUE_ID___y25)); })),

 };
}

size_t iov_iter_copy_from_user_atomic(struct page *page,
  struct iov_iter *i, unsigned long offset, size_t bytes);
void iov_iter_advance(struct iov_iter *i, size_t bytes);
void iov_iter_revert(struct iov_iter *i, size_t bytes);
int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
size_t iov_iter_single_seg_count(const struct iov_iter *i);
size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
    struct iov_iter *i);
size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
    struct iov_iter *i);

size_t _copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
size_t _copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
bool _copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i);
size_t _copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
bool _copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, true)), 0))
  return 0;
 else
  return _copy_to_iter(addr, bytes, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, false)), 0))
  return 0;
 else
  return _copy_from_iter(addr, bytes, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
bool copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, false)), 0))
  return false;
 else
  return _copy_from_iter_full(addr, bytes, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, false)), 0))
  return 0;
 else
  return _copy_from_iter_nocache(addr, bytes, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
bool copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, false)), 0))
  return false;
 else
  return _copy_from_iter_full_nocache(addr, bytes, i);
}
# 184 "/home/nathan/src/linux-next/include/linux/uio.h"
size_t _copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i);





size_t _copy_to_iter_mcsafe(const void *addr, size_t bytes, struct iov_iter *i);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, false)), 0))
  return 0;
 else
  return _copy_from_iter_flushcache(addr, bytes, i);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) __attribute__((__warn_unused_result__))
size_t copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i)
{
 if (__builtin_expect(!!(!check_copy_size(addr, bytes, true)), 0))
  return 0;
 else
  return _copy_to_iter_mcsafe(addr, bytes, i);
}

size_t iov_iter_zero(size_t bytes, struct iov_iter *);
unsigned long iov_iter_alignment(const struct iov_iter *i);
unsigned long iov_iter_gap_alignment(const struct iov_iter *i);
void iov_iter_init(struct iov_iter *i, unsigned int direction, const struct iovec *iov,
   unsigned long nr_segs, size_t count);
void iov_iter_kvec(struct iov_iter *i, unsigned int direction, const struct kvec *kvec,
   unsigned long nr_segs, size_t count);
void iov_iter_bvec(struct iov_iter *i, unsigned int direction, const struct bio_vec *bvec,
   unsigned long nr_segs, size_t count);
void iov_iter_pipe(struct iov_iter *i, unsigned int direction, struct pipe_inode_info *pipe,
   size_t count);
void iov_iter_discard(struct iov_iter *i, unsigned int direction, size_t count);
ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
   size_t maxsize, unsigned maxpages, size_t *start);
ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
   size_t maxsize, size_t *start);
int iov_iter_npages(const struct iov_iter *i, int maxpages);

const void *dup_iter(struct iov_iter *new, struct iov_iter *old, gfp_t flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t iov_iter_count(const struct iov_iter *i)
{
 return i->count;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iov_iter_truncate(struct iov_iter *i, u64 count)
{






 if (i->count > count)
  i->count = count;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iov_iter_reexpand(struct iov_iter *i, size_t count)
{
 i->count = count;
}
size_t csum_and_copy_to_iter(const void *addr, size_t bytes, void *csump, struct iov_iter *i);
size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
bool csum_and_copy_from_iter_full(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
size_t hash_and_copy_to_iter(const void *addr, size_t bytes, void *hashp,
  struct iov_iter *i);

ssize_t import_iovec(int type, const struct iovec * uvector,
   unsigned nr_segs, unsigned fast_segs,
   struct iovec **iov, struct iov_iter *i);


struct compat_iovec;
ssize_t compat_import_iovec(int type, const struct compat_iovec * uvector,
   unsigned nr_segs, unsigned fast_segs,
   struct iovec **iov, struct iov_iter *i);


int import_single_range(int type, void *buf, size_t len,
   struct iovec *iov, struct iov_iter *i);

int iov_iter_for_each_range(struct iov_iter *i, size_t bytes,
       int (*f)(struct kvec *vec, void *context),
       void *context);
# 9 "/home/nathan/src/linux-next/include/linux/socket.h" 2


# 1 "/home/nathan/src/linux-next/include/uapi/linux/socket.h" 1
# 10 "/home/nathan/src/linux-next/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;





struct __kernel_sockaddr_storage {
 union {
  struct {
   __kernel_sa_family_t ss_family;

   char __data[128 - sizeof(unsigned short)];


  };
  void *__align;
 };
};
# 12 "/home/nathan/src/linux-next/include/linux/socket.h" 2

struct pid;
struct cred;
struct socket;





struct seq_file;
extern void socket_seq_show(struct seq_file *seq);


typedef __kernel_sa_family_t sa_family_t;





struct sockaddr {
 sa_family_t sa_family;
 char sa_data[14];
};

struct linger {
 int l_onoff;
 int l_linger;
};
# 49 "/home/nathan/src/linux-next/include/linux/socket.h"
struct msghdr {
 void *msg_name;
 int msg_namelen;
 struct iov_iter msg_iter;
 void *msg_control;
 __kernel_size_t msg_controllen;
 unsigned int msg_flags;
 struct kiocb *msg_iocb;
};

struct user_msghdr {
 void *msg_name;
 int msg_namelen;
 struct iovec *msg_iov;
 __kernel_size_t msg_iovlen;
 void *msg_control;
 __kernel_size_t msg_controllen;
 unsigned int msg_flags;
};


struct mmsghdr {
 struct user_msghdr msg_hdr;
 unsigned int msg_len;
};







struct cmsghdr {
 __kernel_size_t cmsg_len;
        int cmsg_level;
        int cmsg_type;
};
# 127 "/home/nathan/src/linux-next/include/linux/socket.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
            struct cmsghdr *__cmsg)
{
 struct cmsghdr * __ptr;

 __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
 if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
  return (struct cmsghdr *)0;

 return __ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)
{
 return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t msg_data_left(struct msghdr *msg)
{
 return iov_iter_count(&msg->msg_iter);
}







struct ucred {
 __u32 pid;
 __u32 uid;
 __u32 gid;
};
# 353 "/home/nathan/src/linux-next/include/linux/socket.h"
extern int move_addr_to_kernel(void *uaddr, int ulen, struct __kernel_sockaddr_storage *kaddr);
extern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);

struct timespec64;
struct __kernel_timespec;
struct old_timespec32;

struct scm_timestamping_internal {
 struct timespec64 ts[3];
};

extern void put_cmsg_scm_timestamping64(struct msghdr *msg, struct scm_timestamping_internal *tss);
extern void put_cmsg_scm_timestamping(struct msghdr *msg, struct scm_timestamping_internal *tss);




extern long __sys_recvmsg(int fd, struct user_msghdr *msg,
     unsigned int flags, bool forbid_cmsg_compat);
extern long __sys_sendmsg(int fd, struct user_msghdr *msg,
     unsigned int flags, bool forbid_cmsg_compat);
extern int __sys_recvmmsg(int fd, struct mmsghdr *mmsg,
     unsigned int vlen, unsigned int flags,
     struct __kernel_timespec *timeout,
     struct old_timespec32 *timeout32);
extern int __sys_sendmmsg(int fd, struct mmsghdr *mmsg,
     unsigned int vlen, unsigned int flags,
     bool forbid_cmsg_compat);
extern long __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg,
          unsigned int flags);
extern long __sys_recvmsg_sock(struct socket *sock, struct msghdr *msg,
          struct user_msghdr *umsg,
          struct sockaddr *uaddr,
          unsigned int flags);
extern int sendmsg_copy_msghdr(struct msghdr *msg,
          struct user_msghdr *umsg, unsigned flags,
          struct iovec **iov);
extern int recvmsg_copy_msghdr(struct msghdr *msg,
          struct user_msghdr *umsg, unsigned flags,
          struct sockaddr **uaddr,
          struct iovec **iov);


extern int __sys_recvfrom(int fd, void *ubuf, size_t size,
     unsigned int flags, struct sockaddr *addr,
     int *addr_len);
extern int __sys_sendto(int fd, void *buff, size_t len,
   unsigned int flags, struct sockaddr *addr,
   int addr_len);
extern int __sys_accept4_file(struct file *file, unsigned file_flags,
   struct sockaddr *upeer_sockaddr,
    int *upeer_addrlen, int flags);
extern int __sys_accept4(int fd, struct sockaddr *upeer_sockaddr,
    int *upeer_addrlen, int flags);
extern int __sys_socket(int family, int type, int protocol);
extern int __sys_bind(int fd, struct sockaddr *umyaddr, int addrlen);
extern int __sys_connect_file(struct file *file, struct __kernel_sockaddr_storage *addr,
         int addrlen, int file_flags);
extern int __sys_connect(int fd, struct sockaddr *uservaddr,
    int addrlen);
extern int __sys_listen(int fd, int backlog);
extern int __sys_getsockname(int fd, struct sockaddr *usockaddr,
        int *usockaddr_len);
extern int __sys_getpeername(int fd, struct sockaddr *usockaddr,
        int *usockaddr_len);
extern int __sys_socketpair(int family, int type, int protocol,
       int *usockvec);
extern int __sys_shutdown(int fd, int how);

extern struct ns_common *get_net_ns(struct ns_common *ns);
# 21 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/net.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/net.h"
# 1 "/home/nathan/src/linux-next/include/linux/random.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/random.h"
# 1 "/home/nathan/src/linux-next/include/linux/once.h" 1







bool __do_once_start(bool *done, unsigned long *flags);
void __do_once_done(bool *done, struct static_key_true *once_key,
      unsigned long *flags);
# 12 "/home/nathan/src/linux-next/include/linux/random.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/random.h" 1
# 41 "/home/nathan/src/linux-next/include/uapi/linux/random.h"
struct rand_pool_info {
 int entropy_count;
 int buf_size;
 __u32 buf[0];
};
# 14 "/home/nathan/src/linux-next/include/linux/random.h" 2

struct random_ready_callback {
 struct list_head list;
 void (*func)(struct random_ready_callback *rdy);
 struct module *owner;
};

extern void add_device_randomness(const void *, unsigned int);
extern void add_bootloader_randomness(const void *, unsigned int);
# 31 "/home/nathan/src/linux-next/include/linux/random.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_latent_entropy(void) {}


extern void add_input_randomness(unsigned int type, unsigned int code,
     unsigned int value) ;
extern void add_interrupt_randomness(int irq, int irq_flags) ;

extern void get_random_bytes(void *buf, int nbytes);
extern int wait_for_random_bytes(void);
extern int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) rand_initialize(void);
extern bool rng_is_initialized(void);
extern int add_random_ready_callback(struct random_ready_callback *rdy);
extern void del_random_ready_callback(struct random_ready_callback *rdy);
extern int __attribute__((__warn_unused_result__)) get_random_bytes_arch(void *buf, int nbytes);





u32 get_random_u32(void);
u64 get_random_u64(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int get_random_int(void)
{
 return get_random_u32();
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_random_long(void)
{

 return get_random_u64();



}
# 79 "/home/nathan/src/linux-next/include/linux/random.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_random_canary(void)
{
 unsigned long val = get_random_long();

 return val & 0x00ffffffffffffffUL;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_random_bytes_wait(void *buf, int nbytes)
{
 int ret = wait_for_random_bytes();
 get_random_bytes(buf, nbytes);
 return ret;
}
# 103 "/home/nathan/src/linux-next/include/linux/random.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_random_u32_wait(u32 *out) { int ret = wait_for_random_bytes(); if (__builtin_expect(!!(ret), 0)) return ret; *out = get_random_u32(); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_random_u64_wait(u64 *out) { int ret = wait_for_random_bytes(); if (__builtin_expect(!!(ret), 0)) return ret; *out = get_random_u64(); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_random_int_wait(int *out) { int ret = wait_for_random_bytes(); if (__builtin_expect(!!(ret), 0)) return ret; *out = get_random_int(); return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_random_long_wait(long *out) { int ret = wait_for_random_bytes(); if (__builtin_expect(!!(ret), 0)) return ret; *out = get_random_long(); return 0; }


unsigned long randomize_page(unsigned long start, unsigned long range);

u32 prandom_u32(void);
void prandom_bytes(void *buf, size_t nbytes);
void prandom_seed(u32 seed);
void prandom_reseed_late(void);

struct rnd_state {
 __u32 s1, s2, s3, s4;
};

u32 prandom_u32_state(struct rnd_state *state);
void prandom_bytes_state(struct rnd_state *state, void *buf, size_t nbytes);
void prandom_seed_full_state(struct rnd_state *pcpu_state);
# 139 "/home/nathan/src/linux-next/include/linux/random.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 prandom_u32_max(u32 ep_ro)
{
 return (u32)(((u64) prandom_u32() * ep_ro) >> 32);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __seed(u32 x, u32 m)
{
 return (x < m) ? x + m : x;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prandom_seed_state(struct rnd_state *state, u64 seed)
{
 u32 i = (seed >> 32) ^ (seed << 10) ^ seed;

 state->s1 = __seed(i, 2U);
 state->s2 = __seed(i, 8U);
 state->s3 = __seed(i, 16U);
 state->s4 = __seed(i, 128U);
}



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/archrandom.h" 1








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) arch_get_random_long(unsigned long *v)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) arch_get_random_int(unsigned int *v)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) arch_get_random_seed_long(unsigned long *v)
{
 if (ppc_md.get_random_seed)
  return ppc_md.get_random_seed(v);

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __attribute__((__warn_unused_result__)) arch_get_random_seed_int(unsigned int *v)
{
 unsigned long val;
 bool rc;

 rc = arch_get_random_seed_long(&val);
 if (rc)
  *v = val;

 return rc;
}



int powernv_hwrng_present(void);
int powernv_get_random_long(unsigned long *v);
int powernv_get_random_real_mode(unsigned long *v);
# 169 "/home/nathan/src/linux-next/include/linux/random.h" 2
# 189 "/home/nathan/src/linux-next/include/linux/random.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 next_pseudo_random32(u32 seed)
{
 return seed * 1664525 + 1013904223;
}
# 19 "/home/nathan/src/linux-next/include/linux/net.h" 2






# 1 "/home/nathan/src/linux-next/include/uapi/linux/net.h" 1
# 48 "/home/nathan/src/linux-next/include/uapi/linux/net.h"
typedef enum {
 SS_FREE = 0,
 SS_UNCONNECTED,
 SS_CONNECTING,
 SS_CONNECTED,
 SS_DISCONNECTING
} socket_state;
# 26 "/home/nathan/src/linux-next/include/linux/net.h" 2

struct poll_table_struct;
struct pipe_inode_info;
struct inode;
struct file;
struct net;
# 59 "/home/nathan/src/linux-next/include/linux/net.h"
enum sock_type {
 SOCK_STREAM = 1,
 SOCK_DGRAM = 2,
 SOCK_RAW = 3,
 SOCK_RDM = 4,
 SOCK_SEQPACKET = 5,
 SOCK_DCCP = 6,
 SOCK_PACKET = 10,
};
# 88 "/home/nathan/src/linux-next/include/linux/net.h"
enum sock_shutdown_cmd {
 SHUT_RD,
 SHUT_WR,
 SHUT_RDWR,
};

struct socket_wq {

 wait_queue_head_t wait;
 struct fasync_struct *fasync_list;
 unsigned long flags;
 struct callback_head rcu;
} __attribute__((__aligned__((1 << 7))));
# 112 "/home/nathan/src/linux-next/include/linux/net.h"
struct socket {
 socket_state state;

 short type;

 unsigned long flags;

 struct file *file;
 struct sock *sk;
 const struct proto_ops *ops;

 struct socket_wq wq;
};

struct vm_area_struct;
struct page;
struct sockaddr;
struct msghdr;
struct module;
struct sk_buff;
typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,
          unsigned int, size_t);

struct proto_ops {
 int family;
 struct module *owner;
 int (*release) (struct socket *sock);
 int (*bind) (struct socket *sock,
          struct sockaddr *myaddr,
          int sockaddr_len);
 int (*connect) (struct socket *sock,
          struct sockaddr *vaddr,
          int sockaddr_len, int flags);
 int (*socketpair)(struct socket *sock1,
          struct socket *sock2);
 int (*accept) (struct socket *sock,
          struct socket *newsock, int flags, bool kern);
 int (*getname) (struct socket *sock,
          struct sockaddr *addr,
          int peer);
 __poll_t (*poll) (struct file *file, struct socket *sock,
          struct poll_table_struct *wait);
 int (*ioctl) (struct socket *sock, unsigned int cmd,
          unsigned long arg);

 int (*compat_ioctl) (struct socket *sock, unsigned int cmd,
          unsigned long arg);

 int (*gettstamp) (struct socket *sock, void *userstamp,
          bool timeval, bool time32);
 int (*listen) (struct socket *sock, int len);
 int (*shutdown) (struct socket *sock, int flags);
 int (*setsockopt)(struct socket *sock, int level,
          int optname, char *optval, unsigned int optlen);
 int (*getsockopt)(struct socket *sock, int level,
          int optname, char *optval, int *optlen);

 int (*compat_setsockopt)(struct socket *sock, int level,
          int optname, char *optval, unsigned int optlen);
 int (*compat_getsockopt)(struct socket *sock, int level,
          int optname, char *optval, int *optlen);

 void (*show_fdinfo)(struct seq_file *m, struct socket *sock);
 int (*sendmsg) (struct socket *sock, struct msghdr *m,
          size_t total_len);
# 185 "/home/nathan/src/linux-next/include/linux/net.h"
 int (*recvmsg) (struct socket *sock, struct msghdr *m,
          size_t total_len, int flags);
 int (*mmap) (struct file *file, struct socket *sock,
          struct vm_area_struct * vma);
 ssize_t (*sendpage) (struct socket *sock, struct page *page,
          int offset, size_t size, int flags);
 ssize_t (*splice_read)(struct socket *sock, loff_t *ppos,
           struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 int (*set_peek_off)(struct sock *sk, int val);
 int (*peek_len)(struct socket *sock);




 int (*read_sock)(struct sock *sk, read_descriptor_t *desc,
         sk_read_actor_t recv_actor);
 int (*sendpage_locked)(struct sock *sk, struct page *page,
        int offset, size_t size, int flags);
 int (*sendmsg_locked)(struct sock *sk, struct msghdr *msg,
       size_t size);
 int (*set_rcvlowat)(struct sock *sk, int val);
};




struct net_proto_family {
 int family;
 int (*create)(struct net *net, struct socket *sock,
      int protocol, int kern);
 struct module *owner;
};

struct iovec;
struct kvec;

enum {
 SOCK_WAKE_IO,
 SOCK_WAKE_WAITD,
 SOCK_WAKE_SPACE,
 SOCK_WAKE_URG,
};

int sock_wake_async(struct socket_wq *sk_wq, int how, int band);
int sock_register(const struct net_proto_family *fam);
void sock_unregister(int family);
bool sock_is_registered(int family);
int __sock_create(struct net *net, int family, int type, int proto,
    struct socket **res, int kern);
int sock_create(int family, int type, int proto, struct socket **res);
int sock_create_kern(struct net *net, int family, int type, int proto, struct socket **res);
int sock_create_lite(int family, int type, int proto, struct socket **res);
struct socket *sock_alloc(void);
void sock_release(struct socket *sock);
int sock_sendmsg(struct socket *sock, struct msghdr *msg);
int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags);
struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);
struct socket *sockfd_lookup(int fd, int *err);
struct socket *sock_from_file(struct file *file, int *err);

int net_ratelimit(void);
# 292 "/home/nathan/src/linux-next/include/linux/net.h"
int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
     size_t num, size_t len);
int kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,
     struct kvec *vec, size_t num, size_t len);
int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
     size_t num, size_t len, int flags);

int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);
int kernel_listen(struct socket *sock, int backlog);
int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
     int flags);
int kernel_getsockname(struct socket *sock, struct sockaddr *addr);
int kernel_getpeername(struct socket *sock, struct sockaddr *addr);
int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
        int *optlen);
int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
        unsigned int optlen);
int kernel_sendpage(struct socket *sock, struct page *page, int offset,
      size_t size, int flags);
int kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,
      size_t size, int flags);
int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);


u32 kernel_sock_ip_overhead(struct sock *sk);
# 27 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/textsearch.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/textsearch.h"
struct module;

struct ts_config;
# 23 "/home/nathan/src/linux-next/include/linux/textsearch.h"
struct ts_state
{
 unsigned int offset;
 char cb[40];
};
# 39 "/home/nathan/src/linux-next/include/linux/textsearch.h"
struct ts_ops
{
 const char *name;
 struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
 unsigned int (*find)(struct ts_config *,
     struct ts_state *);
 void (*destroy)(struct ts_config *);
 void * (*get_pattern)(struct ts_config *);
 unsigned int (*get_pattern_len)(struct ts_config *);
 struct module *owner;
 struct list_head list;
};
# 59 "/home/nathan/src/linux-next/include/linux/textsearch.h"
struct ts_config
{
 struct ts_ops *ops;
 int flags;
# 76 "/home/nathan/src/linux-next/include/linux/textsearch.h"
 unsigned int (*get_next_block)(unsigned int consumed,
        const u8 **dst,
        struct ts_config *conf,
        struct ts_state *state);
# 89 "/home/nathan/src/linux-next/include/linux/textsearch.h"
 void (*finish)(struct ts_config *conf,
       struct ts_state *state);
};
# 105 "/home/nathan/src/linux-next/include/linux/textsearch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int textsearch_next(struct ts_config *conf,
        struct ts_state *state)
{
 unsigned int ret = conf->ops->find(conf, state);

 if (conf->finish)
  conf->finish(conf, state);

 return ret;
}
# 124 "/home/nathan/src/linux-next/include/linux/textsearch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int textsearch_find(struct ts_config *conf,
        struct ts_state *state)
{
 state->offset = 0;
 return textsearch_next(conf, state);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *textsearch_get_pattern(struct ts_config *conf)
{
 return conf->ops->get_pattern(conf);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int textsearch_get_pattern_len(struct ts_config *conf)
{
 return conf->ops->get_pattern_len(conf);
}

extern int textsearch_register(struct ts_ops *);
extern int textsearch_unregister(struct ts_ops *);
extern struct ts_config *textsearch_prepare(const char *, const void *,
         unsigned int, gfp_t, int);
extern void textsearch_destroy(struct ts_config *conf);
extern unsigned int textsearch_find_continuous(struct ts_config *,
            struct ts_state *,
            const void *, unsigned int);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ts_config *alloc_ts_config(size_t payload,
      gfp_t gfp_mask)
{
 struct ts_config *conf;

 conf = kzalloc((((sizeof(*conf)) + 8 -1) & ~(8 -1)) + payload, gfp_mask);
 if (conf == ((void *)0))
  return ERR_PTR(-12);

 return conf;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *ts_config_priv(struct ts_config *conf)
{
 return ((u8 *) conf + (((sizeof(struct ts_config)) + 8 -1) & ~(8 -1)));
}
# 28 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 1 "/home/nathan/src/linux-next/include/net/checksum.h" 1
# 22 "/home/nathan/src/linux-next/include/net/checksum.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
# 1 "/home/nathan/src/linux-next/include/linux/in6.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/in6.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/in6.h" 1
# 26 "/home/nathan/src/linux-next/include/uapi/linux/in6.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/libc-compat.h" 1
# 27 "/home/nathan/src/linux-next/include/uapi/linux/in6.h" 2






struct in6_addr {
 union {
  __u8 u6_addr8[16];

  __be16 u6_addr16[8];
  __be32 u6_addr32[4];

 } in6_u;





};



struct sockaddr_in6 {
 unsigned short int sin6_family;
 __be16 sin6_port;
 __be32 sin6_flowinfo;
 struct in6_addr sin6_addr;
 __u32 sin6_scope_id;
};



struct ipv6_mreq {

 struct in6_addr ipv6mr_multiaddr;


 int ipv6mr_ifindex;
};




struct in6_flowlabel_req {
 struct in6_addr flr_dst;
 __be32 flr_label;
 __u8 flr_action;
 __u8 flr_share;
 __u16 flr_flags;
 __u16 flr_expires;
 __u16 flr_linger;
 __u32 __flr_pad;

};
# 20 "/home/nathan/src/linux-next/include/linux/in6.h" 2





extern const struct in6_addr in6addr_any;

extern const struct in6_addr in6addr_loopback;

extern const struct in6_addr in6addr_linklocal_allnodes;


extern const struct in6_addr in6addr_linklocal_allrouters;


extern const struct in6_addr in6addr_interfacelocal_allnodes;


extern const struct in6_addr in6addr_interfacelocal_allrouters;


extern const struct in6_addr in6addr_sitelocal_allrouters;
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h" 2
# 21 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
extern __wsum csum_partial_copy_generic(const void *src, void *dst,
           int len, __wsum sum,
           int *src_err, int *dst_err);


extern __wsum csum_and_copy_from_user(const void *src, void *dst,
          int len, __wsum sum, int *err_ptr);

extern __wsum csum_and_copy_to_user(const void *src, void *dst,
        int len, __wsum sum, int *err_ptr);
# 40 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 csum_fold(__wsum sum)
{
 unsigned int tmp;


 __asm__("rlwinm %0,%1,16,0,31" : "=r" (tmp) : "r" (sum));



 return ( __sum16)(~(( u32)sum + tmp) >> 16);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 from64to32(u64 x)
{
 return (x + ror64(x, 32)) >> 32;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr, __u32 len,
     __u8 proto, __wsum sum)
{

 u64 s = ( u32)sum;

 s += ( u32)saddr;
 s += ( u32)daddr;

 s += proto + len;



 return ( __wsum) from64to32(s);
# 82 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, __u32 len,
     __u8 proto, __wsum sum)
{
 return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_add(__wsum csum, __wsum addend)
{

 u64 res = ( u64)csum;

 if (__builtin_constant_p(csum) && csum == 0)
  return addend;
 if (__builtin_constant_p(addend) && addend == 0)
  return csum;


 res += ( u64)addend;
 return ( __wsum)((u32)res + (res >> 32));






}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum ip_fast_csum_nofold(const void *iph, unsigned int ihl)
{
 const u32 *ptr = (const u32 *)iph + 1;

 unsigned int i;
 u64 s = *(const u32 *)iph;

 for (i = 0; i < ihl - 1; i++, ptr++)
  s += *ptr;
 return ( __wsum)from64to32(s);
# 146 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
{
 return csum_fold(ip_fast_csum_nofold(iph, ihl));
}
# 165 "/home/nathan/src/linux-next/arch/powerpc/include/asm/checksum.h"
__wsum __csum_partial(const void *buff, int len, __wsum sum);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_partial(const void *buff, int len, __wsum sum)
{
 if (__builtin_constant_p(len) && len <= 16 && (len & 1) == 0) {
  if (len == 2)
   sum = csum_add(sum, ( __wsum)*(const u16 *)buff);
  if (len >= 4)
   sum = csum_add(sum, ( __wsum)*(const u32 *)buff);
  if (len == 6)
   sum = csum_add(sum, ( __wsum)
         *(const u16 *)(buff + 4));
  if (len >= 8)
   sum = csum_add(sum, ( __wsum)
         *(const u32 *)(buff + 4));
  if (len == 10)
   sum = csum_add(sum, ( __wsum)
         *(const u16 *)(buff + 8));
  if (len >= 12)
   sum = csum_add(sum, ( __wsum)
         *(const u32 *)(buff + 8));
  if (len == 14)
   sum = csum_add(sum, ( __wsum)
         *(const u16 *)(buff + 12));
  if (len >= 16)
   sum = csum_add(sum, ( __wsum)
         *(const u32 *)(buff + 12));
 } else if (__builtin_constant_p(len) && (len & 3) == 0) {
  sum = csum_add(sum, ip_fast_csum_nofold(buff, len >> 2));
 } else {
  sum = __csum_partial(buff, len, sum);
 }
 return sum;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 ip_compute_csum(const void *buff, int len)
{
 return csum_fold(csum_partial(buff, len, 0));
}


__sum16 csum_ipv6_magic(const struct in6_addr *saddr,
   const struct in6_addr *daddr,
   __u32 len, __u8 proto, __wsum sum);
# 23 "/home/nathan/src/linux-next/include/net/checksum.h" 2
# 65 "/home/nathan/src/linux-next/include/net/checksum.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_sub(__wsum csum, __wsum addend)
{
 return csum_add(csum, ~addend);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 csum16_add(__sum16 csum, __be16 addend)
{
 u16 res = ( u16)csum;

 res += ( u16)addend;
 return ( __sum16)(res + (res < ( u16)addend));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 csum16_sub(__sum16 csum, __be16 addend)
{
 return csum16_add(csum, ~addend);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum
csum_block_add(__wsum csum, __wsum csum2, int offset)
{
 u32 sum = ( u32)csum2;


 if (offset & 1)
  sum = ror32(sum, 8);

 return csum_add(csum, ( __wsum)sum);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum
csum_block_add_ext(__wsum csum, __wsum csum2, int offset, int len)
{
 return csum_block_add(csum, csum2, offset);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum
csum_block_sub(__wsum csum, __wsum csum2, int offset)
{
 return csum_block_add(csum, ~csum2, offset);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_unfold(__sum16 n)
{
 return ( __wsum)n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum csum_partial_ext(const void *buff, int len, __wsum sum)
{
 return csum_partial(buff, len, sum);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void csum_replace_by_diff(__sum16 *sum, __wsum diff)
{
 *sum = csum_fold(csum_add(diff, ~csum_unfold(*sum)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void csum_replace4(__sum16 *sum, __be32 from, __be32 to)
{
 __wsum tmp = csum_sub(~csum_unfold(*sum), ( __wsum)from);

 *sum = csum_fold(csum_add(tmp, ( __wsum)to));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void csum_replace2(__sum16 *sum, __be16 old, __be16 new)
{
 *sum = ~csum16_add(csum16_sub(~(*sum), old), new);
}

struct sk_buff;
void inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
         __be32 from, __be32 to, bool pseudohdr);
void inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,
          const __be32 *from, const __be32 *to,
          bool pseudohdr);
void inet_proto_csum_replace_by_diff(__sum16 *sum, struct sk_buff *skb,
         __wsum diff, bool pseudohdr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_proto_csum_replace2(__sum16 *sum, struct sk_buff *skb,
         __be16 from, __be16 to,
         bool pseudohdr)
{
 inet_proto_csum_replace4(sum, skb, ( __be32)from,
     ( __be32)to, pseudohdr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum remcsum_adjust(void *ptr, __wsum csum,
        int start, int offset)
{
 __sum16 *psum = (__sum16 *)(ptr + offset);
 __wsum delta;


 csum = csum_sub(csum, csum_partial(ptr, start, 0));


 delta = csum_sub(( __wsum)csum_fold(csum),
    ( __wsum)*psum);
 *psum = csum_fold(csum);

 return delta;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void remcsum_unadjust(__sum16 *psum, __wsum delta)
{
 *psum = csum_fold(csum_sub(delta, ( __wsum)*psum));
}
# 29 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/netdev_features.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

enum {
 NETIF_F_SG_BIT,
 NETIF_F_IP_CSUM_BIT,
 __UNUSED_NETIF_F_1,
 NETIF_F_HW_CSUM_BIT,
 NETIF_F_IPV6_CSUM_BIT,
 NETIF_F_HIGHDMA_BIT,
 NETIF_F_FRAGLIST_BIT,
 NETIF_F_HW_VLAN_CTAG_TX_BIT,
 NETIF_F_HW_VLAN_CTAG_RX_BIT,
 NETIF_F_HW_VLAN_CTAG_FILTER_BIT,
 NETIF_F_VLAN_CHALLENGED_BIT,
 NETIF_F_GSO_BIT,
 NETIF_F_LLTX_BIT,

 NETIF_F_NETNS_LOCAL_BIT,
 NETIF_F_GRO_BIT,
 NETIF_F_LRO_BIT,

     NETIF_F_GSO_SHIFT,
 NETIF_F_TSO_BIT
  = NETIF_F_GSO_SHIFT,
 NETIF_F_GSO_ROBUST_BIT,
 NETIF_F_TSO_ECN_BIT,
 NETIF_F_TSO_MANGLEID_BIT,
 NETIF_F_TSO6_BIT,
 NETIF_F_FSO_BIT,
 NETIF_F_GSO_GRE_BIT,
 NETIF_F_GSO_GRE_CSUM_BIT,
 NETIF_F_GSO_IPXIP4_BIT,
 NETIF_F_GSO_IPXIP6_BIT,
 NETIF_F_GSO_UDP_TUNNEL_BIT,
 NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT,
 NETIF_F_GSO_PARTIAL_BIT,



 NETIF_F_GSO_TUNNEL_REMCSUM_BIT,
 NETIF_F_GSO_SCTP_BIT,
 NETIF_F_GSO_ESP_BIT,
 NETIF_F_GSO_UDP_BIT,
 NETIF_F_GSO_UDP_L4_BIT,
 NETIF_F_GSO_FRAGLIST_BIT,
     NETIF_F_GSO_LAST =
  NETIF_F_GSO_FRAGLIST_BIT,

 NETIF_F_FCOE_CRC_BIT,
 NETIF_F_SCTP_CRC_BIT,
 NETIF_F_FCOE_MTU_BIT,
 NETIF_F_NTUPLE_BIT,
 NETIF_F_RXHASH_BIT,
 NETIF_F_RXCSUM_BIT,
 NETIF_F_NOCACHE_COPY_BIT,
 NETIF_F_LOOPBACK_BIT,
 NETIF_F_RXFCS_BIT,
 NETIF_F_RXALL_BIT,
 NETIF_F_HW_VLAN_STAG_TX_BIT,
 NETIF_F_HW_VLAN_STAG_RX_BIT,
 NETIF_F_HW_VLAN_STAG_FILTER_BIT,
 NETIF_F_HW_L2FW_DOFFLOAD_BIT,

 NETIF_F_HW_TC_BIT,
 NETIF_F_HW_ESP_BIT,
 NETIF_F_HW_ESP_TX_CSUM_BIT,
 NETIF_F_RX_UDP_TUNNEL_PORT_BIT,
 NETIF_F_HW_TLS_TX_BIT,
 NETIF_F_HW_TLS_RX_BIT,

 NETIF_F_GRO_HW_BIT,
 NETIF_F_HW_TLS_RECORD_BIT,
 NETIF_F_GRO_FRAGLIST_BIT,
# 93 "/home/nathan/src/linux-next/include/linux/netdev_features.h"
     NETDEV_FEATURE_COUNT
};
# 160 "/home/nathan/src/linux-next/include/linux/netdev_features.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int find_next_netdev_feature(u64 feature, unsigned long start)
{



 feature &= ~0ULL >> (-start & ((sizeof(feature) * 8) - 1));

 return fls64(feature) - 1;
}
# 33 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/sched/clock.h" 1
# 15 "/home/nathan/src/linux-next/include/linux/sched/clock.h"
extern unsigned long long __attribute__((__no_instrument_function__)) sched_clock(void);




extern u64 running_clock(void);
extern u64 sched_clock_cpu(int cpu);


extern void sched_clock_init(void);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sched_clock_tick(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_sched_clock_stable(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sched_clock_idle_sleep_event(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sched_clock_idle_wakeup_event(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 cpu_clock(int cpu)
{
 return sched_clock();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 local_clock(void)
{
 return sched_clock();
}
# 97 "/home/nathan/src/linux-next/include/linux/sched/clock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void enable_sched_clock_irqtime(void) {}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disable_sched_clock_irqtime(void) {}
# 35 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 1 "/home/nathan/src/linux-next/include/net/flow_dissector.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/siphash.h" 1
# 20 "/home/nathan/src/linux-next/include/linux/siphash.h"
typedef struct {
 u64 key[2];
} siphash_key_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool siphash_key_is_zero(const siphash_key_t *key)
{
 return !(key->key[0] | key->key[1]);
}

u64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key);




u64 siphash_1u64(const u64 a, const siphash_key_t *key);
u64 siphash_2u64(const u64 a, const u64 b, const siphash_key_t *key);
u64 siphash_3u64(const u64 a, const u64 b, const u64 c,
   const siphash_key_t *key);
u64 siphash_4u64(const u64 a, const u64 b, const u64 c, const u64 d,
   const siphash_key_t *key);
u64 siphash_1u32(const u32 a, const siphash_key_t *key);
u64 siphash_3u32(const u32 a, const u32 b, const u32 c,
   const siphash_key_t *key);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 siphash_2u32(const u32 a, const u32 b,
          const siphash_key_t *key)
{
 return siphash_1u64((u64)b << 32 | a, key);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 siphash_4u32(const u32 a, const u32 b, const u32 c,
          const u32 d, const siphash_key_t *key)
{
 return siphash_2u64((u64)b << 32 | a, (u64)d << 32 | c, key);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ___siphash_aligned(const __le64 *data, size_t len,
         const siphash_key_t *key)
{
 if (__builtin_constant_p(len) && len == 4)
  return siphash_1u32(__le32_to_cpup((const __le32 *)data), key);
 if (__builtin_constant_p(len) && len == 8)
  return siphash_1u64((__builtin_constant_p((__u64)(( __u64)(__le64)(data[0]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[0]))), key);
 if (__builtin_constant_p(len) && len == 16)
  return siphash_2u64((__builtin_constant_p((__u64)(( __u64)(__le64)(data[0]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[0]))), (__builtin_constant_p((__u64)(( __u64)(__le64)(data[1]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[1]))),
        key);
 if (__builtin_constant_p(len) && len == 24)
  return siphash_3u64((__builtin_constant_p((__u64)(( __u64)(__le64)(data[0]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[0]))), (__builtin_constant_p((__u64)(( __u64)(__le64)(data[1]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[1]))),
        (__builtin_constant_p((__u64)(( __u64)(__le64)(data[2]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[2]))), key);
 if (__builtin_constant_p(len) && len == 32)
  return siphash_4u64((__builtin_constant_p((__u64)(( __u64)(__le64)(data[0]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[0])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[0]))), (__builtin_constant_p((__u64)(( __u64)(__le64)(data[1]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[1])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[1]))),
        (__builtin_constant_p((__u64)(( __u64)(__le64)(data[2]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[2])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[2]))), (__builtin_constant_p((__u64)(( __u64)(__le64)(data[3]))) ? ((__u64)( (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__le64)(data[3])) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__le64)(data[3]))),
        key);
 return __siphash_aligned(data, len, key);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 siphash(const void *data, size_t len,
     const siphash_key_t *key)
{




 return ___siphash_aligned(data, len, key);
}


typedef struct {
 unsigned long key[2];
} hsiphash_key_t;

u32 __hsiphash_aligned(const void *data, size_t len,
         const hsiphash_key_t *key);





u32 hsiphash_1u32(const u32 a, const hsiphash_key_t *key);
u32 hsiphash_2u32(const u32 a, const u32 b, const hsiphash_key_t *key);
u32 hsiphash_3u32(const u32 a, const u32 b, const u32 c,
    const hsiphash_key_t *key);
u32 hsiphash_4u32(const u32 a, const u32 b, const u32 c, const u32 d,
    const hsiphash_key_t *key);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ___hsiphash_aligned(const __le32 *data, size_t len,
          const hsiphash_key_t *key)
{
 if (__builtin_constant_p(len) && len == 4)
  return hsiphash_1u32((__builtin_constant_p((__u32)(( __u32)(__le32)(data[0]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[0]))), key);
 if (__builtin_constant_p(len) && len == 8)
  return hsiphash_2u32((__builtin_constant_p((__u32)(( __u32)(__le32)(data[0]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[0]))), (__builtin_constant_p((__u32)(( __u32)(__le32)(data[1]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[1]))),
         key);
 if (__builtin_constant_p(len) && len == 12)
  return hsiphash_3u32((__builtin_constant_p((__u32)(( __u32)(__le32)(data[0]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[0]))), (__builtin_constant_p((__u32)(( __u32)(__le32)(data[1]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[1]))),
         (__builtin_constant_p((__u32)(( __u32)(__le32)(data[2]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[2]))), key);
 if (__builtin_constant_p(len) && len == 16)
  return hsiphash_4u32((__builtin_constant_p((__u32)(( __u32)(__le32)(data[0]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[0])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[0]))), (__builtin_constant_p((__u32)(( __u32)(__le32)(data[1]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[1])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[1]))),
         (__builtin_constant_p((__u32)(( __u32)(__le32)(data[2]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[2])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[2]))), (__builtin_constant_p((__u32)(( __u32)(__le32)(data[3]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(data[3])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(data[3])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(data[3])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(data[3])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(data[3]))),
         key);
 return __hsiphash_aligned(data, len, key);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 hsiphash(const void *data, size_t len,
      const hsiphash_key_t *key)
{




 return ___hsiphash_aligned(data, len, key);
}
# 8 "/home/nathan/src/linux-next/include/net/flow_dissector.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_ether.h" 1
# 163 "/home/nathan/src/linux-next/include/uapi/linux/if_ether.h"
struct ethhdr {
 unsigned char h_dest[6];
 unsigned char h_source[6];
 __be16 h_proto;
} __attribute__((packed));
# 9 "/home/nathan/src/linux-next/include/net/flow_dissector.h" 2

struct sk_buff;





struct flow_dissector_key_control {
 u16 thoff;
 u16 addr_type;
 u32 flags;
};





enum flow_dissect_ret {
 FLOW_DISSECT_RET_OUT_GOOD,
 FLOW_DISSECT_RET_OUT_BAD,
 FLOW_DISSECT_RET_PROTO_AGAIN,
 FLOW_DISSECT_RET_IPPROTO_AGAIN,
 FLOW_DISSECT_RET_CONTINUE,
};







struct flow_dissector_key_basic {
 __be16 n_proto;
 u8 ip_proto;
 u8 padding;
};

struct flow_dissector_key_tags {
 u32 flow_label;
};

struct flow_dissector_key_vlan {
 union {
  struct {
   u16 vlan_id:12,
    vlan_dei:1,
    vlan_priority:3;
  };
  __be16 vlan_tci;
 };
 __be16 vlan_tpid;
};

struct flow_dissector_key_mpls {
 u32 mpls_ttl:8,
  mpls_bos:1,
  mpls_tc:3,
  mpls_label:20;
};
# 76 "/home/nathan/src/linux-next/include/net/flow_dissector.h"
struct flow_dissector_key_enc_opts {
 u8 data[255];


 u8 len;
 __be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
 __be32 keyid;
};






struct flow_dissector_key_ipv4_addrs {

 __be32 src;
 __be32 dst;
};






struct flow_dissector_key_ipv6_addrs {

 struct in6_addr src;
 struct in6_addr dst;
};





struct flow_dissector_key_tipc {
 __be32 key;
};






struct flow_dissector_key_addrs {
 union {
  struct flow_dissector_key_ipv4_addrs v4addrs;
  struct flow_dissector_key_ipv6_addrs v6addrs;
  struct flow_dissector_key_tipc tipckey;
 };
};
# 141 "/home/nathan/src/linux-next/include/net/flow_dissector.h"
struct flow_dissector_key_arp {
 __u32 sip;
 __u32 tip;
 __u8 op;
 unsigned char sha[6];
 unsigned char tha[6];
};







struct flow_dissector_key_ports {
 union {
  __be32 ports;
  struct {
   __be16 src;
   __be16 dst;
  };
 };
};







struct flow_dissector_key_icmp {
 struct {
  u8 type;
  u8 code;
 };
 u16 id;
};






struct flow_dissector_key_eth_addrs {

 unsigned char dst[6];
 unsigned char src[6];
};





struct flow_dissector_key_tcp {
 __be16 flags;
};






struct flow_dissector_key_ip {
 __u8 tos;
 __u8 ttl;
};






struct flow_dissector_key_meta {
 int ingress_ifindex;
 u16 ingress_iftype;
};
# 225 "/home/nathan/src/linux-next/include/net/flow_dissector.h"
struct flow_dissector_key_ct {
 u16 ct_state;
 u16 ct_zone;
 u32 ct_mark;
 u32 ct_labels[4];
};

enum flow_dissector_key_id {
 FLOW_DISSECTOR_KEY_CONTROL,
 FLOW_DISSECTOR_KEY_BASIC,
 FLOW_DISSECTOR_KEY_IPV4_ADDRS,
 FLOW_DISSECTOR_KEY_IPV6_ADDRS,
 FLOW_DISSECTOR_KEY_PORTS,
 FLOW_DISSECTOR_KEY_PORTS_RANGE,
 FLOW_DISSECTOR_KEY_ICMP,
 FLOW_DISSECTOR_KEY_ETH_ADDRS,
 FLOW_DISSECTOR_KEY_TIPC,
 FLOW_DISSECTOR_KEY_ARP,
 FLOW_DISSECTOR_KEY_VLAN,
 FLOW_DISSECTOR_KEY_FLOW_LABEL,
 FLOW_DISSECTOR_KEY_GRE_KEYID,
 FLOW_DISSECTOR_KEY_MPLS_ENTROPY,
 FLOW_DISSECTOR_KEY_ENC_KEYID,
 FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,
 FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,
 FLOW_DISSECTOR_KEY_ENC_CONTROL,
 FLOW_DISSECTOR_KEY_ENC_PORTS,
 FLOW_DISSECTOR_KEY_MPLS,
 FLOW_DISSECTOR_KEY_TCP,
 FLOW_DISSECTOR_KEY_IP,
 FLOW_DISSECTOR_KEY_CVLAN,
 FLOW_DISSECTOR_KEY_ENC_IP,
 FLOW_DISSECTOR_KEY_ENC_OPTS,
 FLOW_DISSECTOR_KEY_META,
 FLOW_DISSECTOR_KEY_CT,

 FLOW_DISSECTOR_KEY_MAX,
};





struct flow_dissector_key {
 enum flow_dissector_key_id key_id;
 size_t offset;

};

struct flow_dissector {
 unsigned int used_keys;
 unsigned short int offset[FLOW_DISSECTOR_KEY_MAX];
};

struct flow_keys_basic {
 struct flow_dissector_key_control control;
 struct flow_dissector_key_basic basic;
};

struct flow_keys {
 struct flow_dissector_key_control control;

 struct flow_dissector_key_basic basic __attribute__((__aligned__(__alignof__(u64))));
 struct flow_dissector_key_tags tags;
 struct flow_dissector_key_vlan vlan;
 struct flow_dissector_key_vlan cvlan;
 struct flow_dissector_key_keyid keyid;
 struct flow_dissector_key_ports ports;
 struct flow_dissector_key_icmp icmp;

 struct flow_dissector_key_addrs addrs;
};




__be32 flow_get_u32_src(const struct flow_keys *flow);
__be32 flow_get_u32_dst(const struct flow_keys *flow);

extern struct flow_dissector flow_keys_dissector;
extern struct flow_dissector flow_keys_basic_dissector;
# 315 "/home/nathan/src/linux-next/include/net/flow_dissector.h"
struct flow_keys_digest {
 u8 data[16];
};

void make_flow_keys_digest(struct flow_keys_digest *digest,
      const struct flow_keys *flow);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool flow_keys_have_l4(const struct flow_keys *keys)
{
 return (keys->ports.ports || keys->tags.flow_label);
}

u32 flow_hash_from_keys(struct flow_keys *keys);
void skb_flow_get_icmp_tci(const struct sk_buff *skb,
      struct flow_dissector_key_icmp *key_icmp,
      void *data, int thoff, int hlen);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dissector_uses_key(const struct flow_dissector *flow_dissector,
          enum flow_dissector_key_id key_id)
{
 return flow_dissector->used_keys & (1 << key_id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_flow_dissector_target(struct flow_dissector *flow_dissector,
           enum flow_dissector_key_id key_id,
           void *target_container)
{
 return ((char *)target_container) + flow_dissector->offset[key_id];
}

struct bpf_flow_dissector {
 struct bpf_flow_keys *flow_keys;
 const struct sk_buff *skb;
 void *data;
 void *data_end;
};
# 36 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/splice.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/splice.h"
# 1 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h"
struct pipe_buffer {
 struct page *page;
 unsigned int offset, len;
 const struct pipe_buf_operations *ops;
 unsigned int flags;
 unsigned long private;
};
# 48 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
 struct mutex mutex;
 wait_queue_head_t rd_wait, wr_wait;
 unsigned int head;
 unsigned int tail;
 unsigned int max_usage;
 unsigned int ring_size;
 unsigned int readers;
 unsigned int writers;
 unsigned int files;
 unsigned int r_counter;
 unsigned int w_counter;
 struct page *tmp_page;
 struct fasync_struct *fasync_readers;
 struct fasync_struct *fasync_writers;
 struct pipe_buffer *bufs;
 struct user_struct *user;
};
# 77 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {







 int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);





 void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
# 101 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h"
 int (*steal)(struct pipe_inode_info *, struct pipe_buffer *);




 bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pipe_empty(unsigned int head, unsigned int tail)
{
 return head == tail;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int pipe_occupancy(unsigned int head, unsigned int tail)
{
 return head - tail;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pipe_full(unsigned int head, unsigned int tail,
        unsigned int limit)
{
 return pipe_occupancy(head, tail) >= limit;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int pipe_space_for_user(unsigned int head, unsigned int tail,
            struct pipe_inode_info *pipe)
{
 unsigned int p_occupancy, p_space;

 p_occupancy = pipe_occupancy(head, tail);
 if (p_occupancy >= pipe->max_usage)
  return 0;
 p_space = pipe->ring_size - p_occupancy;
 if (p_space > pipe->max_usage)
  p_space = pipe->max_usage;
 return p_space;
}
# 168 "/home/nathan/src/linux-next/include/linux/pipe_fs_i.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) bool pipe_buf_get(struct pipe_inode_info *pipe,
    struct pipe_buffer *buf)
{
 return buf->ops->get(pipe, buf);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pipe_buf_release(struct pipe_inode_info *pipe,
        struct pipe_buffer *buf)
{
 const struct pipe_buf_operations *ops = buf->ops;

 buf->ops = ((void *)0);
 ops->release(pipe, buf);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pipe_buf_confirm(struct pipe_inode_info *pipe,
       struct pipe_buffer *buf)
{
 return buf->ops->confirm(pipe, buf);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pipe_buf_steal(struct pipe_inode_info *pipe,
     struct pipe_buffer *buf)
{
 return buf->ops->steal(pipe, buf);
}






void pipe_lock(struct pipe_inode_info *);
void pipe_unlock(struct pipe_inode_info *);
void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);

extern unsigned int pipe_max_size;
extern unsigned long pipe_user_pages_hard;
extern unsigned long pipe_user_pages_soft;


void pipe_wait(struct pipe_inode_info *pipe);

struct pipe_inode_info *alloc_pipe_info(void);
void free_pipe_info(struct pipe_inode_info *);


bool generic_pipe_buf_get(struct pipe_inode_info *, struct pipe_buffer *);
int generic_pipe_buf_confirm(struct pipe_inode_info *, struct pipe_buffer *);
int generic_pipe_buf_steal(struct pipe_inode_info *, struct pipe_buffer *);
int generic_pipe_buf_nosteal(struct pipe_inode_info *, struct pipe_buffer *);
void generic_pipe_buf_release(struct pipe_inode_info *, struct pipe_buffer *);
void pipe_buf_mark_unmergeable(struct pipe_buffer *buf);

extern const struct pipe_buf_operations nosteal_pipe_buf_ops;


long pipe_fcntl(struct file *, unsigned int, unsigned long arg);
struct pipe_inode_info *get_pipe_info(struct file *file);

int create_pipe_files(struct file **, int);
unsigned int round_pipe_size(unsigned long size);
# 13 "/home/nathan/src/linux-next/include/linux/splice.h" 2
# 29 "/home/nathan/src/linux-next/include/linux/splice.h"
struct splice_desc {
 size_t total_len;
 unsigned int len;
 unsigned int flags;



 union {
  void *userptr;
  struct file *file;
  void *data;
 } u;
 loff_t pos;
 loff_t *opos;
 size_t num_spliced;
 bool need_wakeup;
};

struct partial_page {
 unsigned int offset;
 unsigned int len;
 unsigned long private;
};




struct splice_pipe_desc {
 struct page **pages;
 struct partial_page *partial;
 int nr_pages;
 unsigned int nr_pages_max;
 const struct pipe_buf_operations *ops;
 void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

typedef int (splice_actor)(struct pipe_inode_info *, struct pipe_buffer *,
      struct splice_desc *);
typedef int (splice_direct_actor)(struct pipe_inode_info *,
      struct splice_desc *);

extern ssize_t splice_from_pipe(struct pipe_inode_info *, struct file *,
    loff_t *, size_t, unsigned int,
    splice_actor *);
extern ssize_t __splice_from_pipe(struct pipe_inode_info *,
      struct splice_desc *, splice_actor *);
extern ssize_t splice_to_pipe(struct pipe_inode_info *,
         struct splice_pipe_desc *);
extern ssize_t add_to_pipe(struct pipe_inode_info *,
         struct pipe_buffer *);
extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
          splice_direct_actor *);




extern int splice_grow_spd(const struct pipe_inode_info *, struct splice_pipe_desc *);
extern void splice_shrink_spd(struct splice_pipe_desc *);

extern const struct pipe_buf_operations page_cache_pipe_buf_ops;
extern const struct pipe_buf_operations default_pipe_buf_ops;
# 37 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h" 1






struct sockaddr_pkt {
 unsigned short spkt_family;
 unsigned char spkt_device[14];
 __be16 spkt_protocol;
};

struct sockaddr_ll {
 unsigned short sll_family;
 __be16 sll_protocol;
 int sll_ifindex;
 unsigned short sll_hatype;
 unsigned char sll_pkttype;
 unsigned char sll_halen;
 unsigned char sll_addr[8];
};
# 74 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h"
struct tpacket_stats {
 unsigned int tp_packets;
 unsigned int tp_drops;
};

struct tpacket_stats_v3 {
 unsigned int tp_packets;
 unsigned int tp_drops;
 unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
 __u64 __attribute__((aligned(8))) tp_all;
 __u64 __attribute__((aligned(8))) tp_huge;
 __u64 __attribute__((aligned(8))) tp_failed;
};

union tpacket_stats_u {
 struct tpacket_stats stats1;
 struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
 __u32 tp_status;
 __u32 tp_len;
 __u32 tp_snaplen;
 __u16 tp_mac;
 __u16 tp_net;
 __u16 tp_vlan_tci;
 __u16 tp_vlan_tpid;
};
# 131 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h"
struct tpacket_hdr {
 unsigned long tp_status;
 unsigned int tp_len;
 unsigned int tp_snaplen;
 unsigned short tp_mac;
 unsigned short tp_net;
 unsigned int tp_sec;
 unsigned int tp_usec;
};





struct tpacket2_hdr {
 __u32 tp_status;
 __u32 tp_len;
 __u32 tp_snaplen;
 __u16 tp_mac;
 __u16 tp_net;
 __u32 tp_sec;
 __u32 tp_nsec;
 __u16 tp_vlan_tci;
 __u16 tp_vlan_tpid;
 __u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
 __u32 tp_rxhash;
 __u32 tp_vlan_tci;
 __u16 tp_vlan_tpid;
 __u16 tp_padding;
};

struct tpacket3_hdr {
 __u32 tp_next_offset;
 __u32 tp_sec;
 __u32 tp_nsec;
 __u32 tp_snaplen;
 __u32 tp_len;
 __u32 tp_status;
 __u16 tp_mac;
 __u16 tp_net;

 union {
  struct tpacket_hdr_variant1 hv1;
 };
 __u8 tp_padding[8];
};

struct tpacket_bd_ts {
 unsigned int ts_sec;
 union {
  unsigned int ts_usec;
  unsigned int ts_nsec;
 };
};

struct tpacket_hdr_v1 {
 __u32 block_status;
 __u32 num_pkts;
 __u32 offset_to_first_pkt;




 __u32 blk_len;
# 208 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h"
 __u64 __attribute__((aligned(8))) seq_num;
# 235 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h"
 struct tpacket_bd_ts ts_first_pkt, ts_last_pkt;
};

union tpacket_bd_header_u {
 struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
 __u32 version;
 __u32 offset_to_priv;
 union tpacket_bd_header_u hdr;
};




enum tpacket_versions {
 TPACKET_V1,
 TPACKET_V2,
 TPACKET_V3
};
# 270 "/home/nathan/src/linux-next/include/uapi/linux/if_packet.h"
struct tpacket_req {
 unsigned int tp_block_size;
 unsigned int tp_block_nr;
 unsigned int tp_frame_size;
 unsigned int tp_frame_nr;
};

struct tpacket_req3 {
 unsigned int tp_block_size;
 unsigned int tp_block_nr;
 unsigned int tp_frame_size;
 unsigned int tp_frame_nr;
 unsigned int tp_retire_blk_tov;
 unsigned int tp_sizeof_priv;
 unsigned int tp_feature_req_word;
};

union tpacket_req_u {
 struct tpacket_req req;
 struct tpacket_req3 req3;
};

struct packet_mreq {
 int mr_ifindex;
 unsigned short mr_type;
 unsigned short mr_alen;
 unsigned char mr_address[8];
};
# 39 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 1 "/home/nathan/src/linux-next/include/net/flow.h" 1
# 25 "/home/nathan/src/linux-next/include/net/flow.h"
struct flowi_tunnel {
 __be64 tun_id;
};

struct flowi_common {
 int flowic_oif;
 int flowic_iif;
 __u32 flowic_mark;
 __u8 flowic_tos;
 __u8 flowic_scope;
 __u8 flowic_proto;
 __u8 flowic_flags;



 __u32 flowic_secid;
 kuid_t flowic_uid;
 struct flowi_tunnel flowic_tun_key;
 __u32 flowic_multipath_hash;
};

union flowi_uli {
 struct {
  __be16 dport;
  __be16 sport;
 } ports;

 struct {
  __u8 type;
  __u8 code;
 } icmpt;

 struct {
  __le16 dport;
  __le16 sport;
 } dnports;

 __be32 spi;
 __be32 gre_key;

 struct {
  __u8 type;
 } mht;
};

struct flowi4 {
 struct flowi_common __fl_common;
# 85 "/home/nathan/src/linux-next/include/net/flow.h"
 __be32 saddr;
 __be32 daddr;

 union flowi_uli uli;







} __attribute__((__aligned__(64/8)));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flowi4_init_output(struct flowi4 *fl4, int oif,
          __u32 mark, __u8 tos, __u8 scope,
          __u8 proto, __u8 flags,
          __be32 daddr, __be32 saddr,
          __be16 dport, __be16 sport,
          kuid_t uid)
{
 fl4->__fl_common.flowic_oif = oif;
 fl4->__fl_common.flowic_iif = 1;
 fl4->__fl_common.flowic_mark = mark;
 fl4->__fl_common.flowic_tos = tos;
 fl4->__fl_common.flowic_scope = scope;
 fl4->__fl_common.flowic_proto = proto;
 fl4->__fl_common.flowic_flags = flags;
 fl4->__fl_common.flowic_secid = 0;
 fl4->__fl_common.flowic_tun_key.tun_id = 0;
 fl4->__fl_common.flowic_uid = uid;
 fl4->daddr = daddr;
 fl4->saddr = saddr;
 fl4->uli.ports.dport = dport;
 fl4->uli.ports.sport = sport;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flowi4_update_output(struct flowi4 *fl4, int oif, __u8 tos,
     __be32 daddr, __be32 saddr)
{
 fl4->__fl_common.flowic_oif = oif;
 fl4->__fl_common.flowic_tos = tos;
 fl4->daddr = daddr;
 fl4->saddr = saddr;
}


struct flowi6 {
 struct flowi_common __fl_common;
# 143 "/home/nathan/src/linux-next/include/net/flow.h"
 struct in6_addr daddr;
 struct in6_addr saddr;

 __be32 flowlabel;
 union flowi_uli uli;







 __u32 mp_hash;
} __attribute__((__aligned__(64/8)));

struct flowidn {
 struct flowi_common __fl_common;






 __le16 daddr;
 __le16 saddr;
 union flowi_uli uli;


} __attribute__((__aligned__(64/8)));

struct flowi {
 union {
  struct flowi_common __fl_common;
  struct flowi4 ip4;
  struct flowi6 ip6;
  struct flowidn dn;
 } u;
# 190 "/home/nathan/src/linux-next/include/net/flow.h"
} __attribute__((__aligned__(64/8)));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct flowi *flowi4_to_flowi(struct flowi4 *fl4)
{
 return ({ void *__mptr = (void *)(fl4); do { extern void __compiletime_assert_194(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(fl4)), typeof(((struct flowi *)0)->u.ip4)) && !__builtin_types_compatible_p(typeof(*(fl4)), typeof(void))))) __compiletime_assert_194(); } while (0); ((struct flowi *)(__mptr - __builtin_offsetof(struct flowi, u.ip4))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct flowi *flowi6_to_flowi(struct flowi6 *fl6)
{
 return ({ void *__mptr = (void *)(fl6); do { extern void __compiletime_assert_199(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(fl6)), typeof(((struct flowi *)0)->u.ip6)) && !__builtin_types_compatible_p(typeof(*(fl6)), typeof(void))))) __compiletime_assert_199(); } while (0); ((struct flowi *)(__mptr - __builtin_offsetof(struct flowi, u.ip6))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct flowi *flowidn_to_flowi(struct flowidn *fldn)
{
 return ({ void *__mptr = (void *)(fldn); do { extern void __compiletime_assert_204(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(fldn)), typeof(((struct flowi *)0)->u.dn)) && !__builtin_types_compatible_p(typeof(*(fldn)), typeof(void))))) __compiletime_assert_204(); } while (0); ((struct flowi *)(__mptr - __builtin_offsetof(struct flowi, u.dn))); });
}

typedef unsigned long flow_compare_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int flow_key_size(u16 family)
{
 switch (family) {
 case 2:
  do { extern void __compiletime_assert_213(void) ; if (!(!(sizeof(struct flowi4) % sizeof(flow_compare_t)))) __compiletime_assert_213(); } while (0);
  return sizeof(struct flowi4) / sizeof(flow_compare_t);
 case 10:
  do { extern void __compiletime_assert_216(void) ; if (!(!(sizeof(struct flowi6) % sizeof(flow_compare_t)))) __compiletime_assert_216(); } while (0);
  return sizeof(struct flowi6) / sizeof(flow_compare_t);
 case 12:
  do { extern void __compiletime_assert_219(void) ; if (!(!(sizeof(struct flowidn) % sizeof(flow_compare_t)))) __compiletime_assert_219(); } while (0);
  return sizeof(struct flowidn) / sizeof(flow_compare_t);
 }
 return 0;
}

__u32 __get_hash_from_flowi6(const struct flowi6 *fl6, struct flow_keys *keys);
# 40 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/netfilter/nf_conntrack_common.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/netfilter/nf_conntrack_common.h" 1






enum ip_conntrack_info {

 IP_CT_ESTABLISHED,



 IP_CT_RELATED,



 IP_CT_NEW,


 IP_CT_IS_REPLY,

 IP_CT_ESTABLISHED_REPLY = IP_CT_ESTABLISHED + IP_CT_IS_REPLY,
 IP_CT_RELATED_REPLY = IP_CT_RELATED + IP_CT_IS_REPLY,



 IP_CT_NUMBER,





 IP_CT_UNTRACKED = 7,

};






enum ip_conntrack_status {

 IPS_EXPECTED_BIT = 0,
 IPS_EXPECTED = (1 << IPS_EXPECTED_BIT),


 IPS_SEEN_REPLY_BIT = 1,
 IPS_SEEN_REPLY = (1 << IPS_SEEN_REPLY_BIT),


 IPS_ASSURED_BIT = 2,
 IPS_ASSURED = (1 << IPS_ASSURED_BIT),


 IPS_CONFIRMED_BIT = 3,
 IPS_CONFIRMED = (1 << IPS_CONFIRMED_BIT),


 IPS_SRC_NAT_BIT = 4,
 IPS_SRC_NAT = (1 << IPS_SRC_NAT_BIT),


 IPS_DST_NAT_BIT = 5,
 IPS_DST_NAT = (1 << IPS_DST_NAT_BIT),


 IPS_NAT_MASK = (IPS_DST_NAT | IPS_SRC_NAT),


 IPS_SEQ_ADJUST_BIT = 6,
 IPS_SEQ_ADJUST = (1 << IPS_SEQ_ADJUST_BIT),


 IPS_SRC_NAT_DONE_BIT = 7,
 IPS_SRC_NAT_DONE = (1 << IPS_SRC_NAT_DONE_BIT),

 IPS_DST_NAT_DONE_BIT = 8,
 IPS_DST_NAT_DONE = (1 << IPS_DST_NAT_DONE_BIT),


 IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),


 IPS_DYING_BIT = 9,
 IPS_DYING = (1 << IPS_DYING_BIT),


 IPS_FIXED_TIMEOUT_BIT = 10,
 IPS_FIXED_TIMEOUT = (1 << IPS_FIXED_TIMEOUT_BIT),


 IPS_TEMPLATE_BIT = 11,
 IPS_TEMPLATE = (1 << IPS_TEMPLATE_BIT),


 IPS_UNTRACKED_BIT = 12,
 IPS_UNTRACKED = (1 << IPS_UNTRACKED_BIT),


 IPS_HELPER_BIT = 13,
 IPS_HELPER = (1 << IPS_HELPER_BIT),


 IPS_OFFLOAD_BIT = 14,
 IPS_OFFLOAD = (1 << IPS_OFFLOAD_BIT),




 IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |
     IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |
     IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),

 __IPS_MAX_BIT = 15,
};


enum ip_conntrack_events {
 IPCT_NEW,
 IPCT_RELATED,
 IPCT_DESTROY,
 IPCT_REPLY,
 IPCT_ASSURED,
 IPCT_PROTOINFO,
 IPCT_HELPER,
 IPCT_MARK,
 IPCT_SEQADJ,
 IPCT_NATSEQADJ = IPCT_SEQADJ,
 IPCT_SECMARK,
 IPCT_LABEL,
 IPCT_SYNPROXY,

 __IPCT_MAX

};

enum ip_conntrack_expect_events {
 IPEXP_NEW,
 IPEXP_DESTROY,
};
# 7 "/home/nathan/src/linux-next/include/linux/netfilter/nf_conntrack_common.h" 2

struct ip_conntrack_stat {
 unsigned int found;
 unsigned int invalid;
 unsigned int ignore;
 unsigned int insert;
 unsigned int insert_failed;
 unsigned int drop;
 unsigned int early_drop;
 unsigned int error;
 unsigned int expect_new;
 unsigned int expect_create;
 unsigned int expect_delete;
 unsigned int search_restart;
};




struct nf_conntrack {
 atomic_t use;
};

void nf_conntrack_destroy(struct nf_conntrack *nfct);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nf_conntrack_put(struct nf_conntrack *nfct)
{
 if (nfct && atomic_dec_and_test(&nfct->use))
  nf_conntrack_destroy(nfct);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nf_conntrack_get(struct nf_conntrack *nfct)
{
 if (nfct)
  atomic_inc(&nfct->use);
}
# 42 "/home/nathan/src/linux-next/include/linux/skbuff.h" 2
# 241 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct net_device;
struct scatterlist;
struct pipe_inode_info;
struct iov_iter;
struct napi_struct;
struct bpf_prog;
union bpf_attr;
struct skb_ext;
# 289 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct sk_buff_head {

 struct sk_buff *next;
 struct sk_buff *prev;

 __u32 qlen;
 spinlock_t lock;
};

struct sk_buff;
# 312 "/home/nathan/src/linux-next/include/linux/skbuff.h"
extern int sysctl_max_skb_frags;






typedef struct bio_vec skb_frag_t;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_frag_size(const skb_frag_t *frag)
{
 return frag->bv_len;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_size_set(skb_frag_t *frag, unsigned int size)
{
 frag->bv_len = size;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_size_add(skb_frag_t *frag, int delta)
{
 frag->bv_len += delta;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_size_sub(skb_frag_t *frag, int delta)
{
 frag->bv_len -= delta;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_frag_must_loop(struct page *p)
{




 return false;
}
# 416 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
 ktime_t hwtstamp;
};


enum {

 SKBTX_HW_TSTAMP = 1 << 0,


 SKBTX_SW_TSTAMP = 1 << 1,


 SKBTX_IN_PROGRESS = 1 << 2,


 SKBTX_DEV_ZEROCOPY = 1 << 3,


 SKBTX_WIFI_STATUS = 1 << 4,






 SKBTX_SHARED_FRAG = 1 << 5,


 SKBTX_SCHED_TSTAMP = 1 << 6,
};
# 461 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct ubuf_info {
 void (*callback)(struct ubuf_info *, bool zerocopy_success);
 union {
  struct {
   unsigned long desc;
   void *ctx;
  };
  struct {
   u32 id;
   u16 len;
   u16 zerocopy:1;
   u32 bytelen;
  };
 };
 refcount_t refcnt;

 struct mmpin {
  struct user_struct *user;
  unsigned int num_pg;
 } mmp;
};



int mm_account_pinned_pages(struct mmpin *mmp, size_t size);
void mm_unaccount_pinned_pages(struct mmpin *mmp);

struct ubuf_info *sock_zerocopy_alloc(struct sock *sk, size_t size);
struct ubuf_info *sock_zerocopy_realloc(struct sock *sk, size_t size,
     struct ubuf_info *uarg);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_zerocopy_get(struct ubuf_info *uarg)
{
 refcount_inc(&uarg->refcnt);
}

void sock_zerocopy_put(struct ubuf_info *uarg);
void sock_zerocopy_put_abort(struct ubuf_info *uarg, bool have_uref);

void sock_zerocopy_callback(struct ubuf_info *uarg, bool success);

int skb_zerocopy_iter_dgram(struct sk_buff *skb, struct msghdr *msg, int len);
int skb_zerocopy_iter_stream(struct sock *sk, struct sk_buff *skb,
        struct msghdr *msg, int len,
        struct ubuf_info *uarg);




struct skb_shared_info {
 __u8 __unused;
 __u8 meta_len;
 __u8 nr_frags;
 __u8 tx_flags;
 unsigned short gso_size;

 unsigned short gso_segs;
 struct sk_buff *frag_list;
 struct skb_shared_hwtstamps hwtstamps;
 unsigned int gso_type;
 u32 tskey;




 atomic_t dataref;



 void * destructor_arg;


 skb_frag_t frags[16UL];
};
# 551 "/home/nathan/src/linux-next/include/linux/skbuff.h"
enum {
 SKB_FCLONE_UNAVAILABLE,
 SKB_FCLONE_ORIG,
 SKB_FCLONE_CLONE,
};

enum {
 SKB_GSO_TCPV4 = 1 << 0,


 SKB_GSO_DODGY = 1 << 1,


 SKB_GSO_TCP_ECN = 1 << 2,

 SKB_GSO_TCP_FIXEDID = 1 << 3,

 SKB_GSO_TCPV6 = 1 << 4,

 SKB_GSO_FCOE = 1 << 5,

 SKB_GSO_GRE = 1 << 6,

 SKB_GSO_GRE_CSUM = 1 << 7,

 SKB_GSO_IPXIP4 = 1 << 8,

 SKB_GSO_IPXIP6 = 1 << 9,

 SKB_GSO_UDP_TUNNEL = 1 << 10,

 SKB_GSO_UDP_TUNNEL_CSUM = 1 << 11,

 SKB_GSO_PARTIAL = 1 << 12,

 SKB_GSO_TUNNEL_REMCSUM = 1 << 13,

 SKB_GSO_SCTP = 1 << 14,

 SKB_GSO_ESP = 1 << 15,

 SKB_GSO_UDP = 1 << 16,

 SKB_GSO_UDP_L4 = 1 << 17,

 SKB_GSO_FRAGLIST = 1 << 18,
};






typedef unsigned int sk_buff_data_t;
# 687 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct sk_buff {
 union {
  struct {

   struct sk_buff *next;
   struct sk_buff *prev;

   union {
    struct net_device *dev;




    unsigned long dev_scratch;
   };
  };
  struct rb_node rbnode;
  struct list_head list;
 };

 union {
  struct sock *sk;
  int ip_defrag_offset;
 };

 union {
  ktime_t tstamp;
  u64 skb_mstamp_ns;
 };






 char cb[48] __attribute__((__aligned__(8)));

 union {
  struct {
   unsigned long _skb_refdst;
   void (*destructor)(struct sk_buff *skb);
  };
  struct list_head tcp_tsorted_anchor;
 };


 unsigned long _nfct;

 unsigned int len,
    data_len;
 __u16 mac_len,
    hdr_len;




 __u16 queue_mapping;
# 753 "/home/nathan/src/linux-next/include/linux/skbuff.h"
 __u8 __cloned_offset[0];
 __u8 cloned:1,
    nohdr:1,
    fclone:2,
    peeked:1,
    head_frag:1,
    pfmemalloc:1;

 __u8 active_extensions;





 __u32 headers_start[0];
# 778 "/home/nathan/src/linux-next/include/linux/skbuff.h"
 __u8 __pkt_type_offset[0];
 __u8 pkt_type:3;
 __u8 ignore_df:1;
 __u8 nf_trace:1;
 __u8 ip_summed:2;
 __u8 ooo_okay:1;

 __u8 l4_hash:1;
 __u8 sw_hash:1;
 __u8 wifi_acked_valid:1;
 __u8 wifi_acked:1;
 __u8 no_fcs:1;

 __u8 encapsulation:1;
 __u8 encap_hdr_csum:1;
 __u8 csum_valid:1;







 __u8 __pkt_vlan_present_offset[0];
 __u8 vlan_present:1;
 __u8 csum_complete_sw:1;
 __u8 csum_level:2;
 __u8 csum_not_inet:1;
 __u8 dst_pending_confirm:1;

 __u8 ndisc_nodetype:2;


 __u8 ipvs_property:1;
 __u8 inner_protocol_type:1;
 __u8 remcsum_offload:1;





 __u8 tc_skip_classify:1;
 __u8 tc_at_ingress:1;
 __u8 tc_redirected:1;
 __u8 tc_from_ingress:1;






 __u16 tc_index;


 union {
  __wsum csum;
  struct {
   __u16 csum_start;
   __u16 csum_offset;
  };
 };
 __u32 priority;
 int skb_iif;
 __u32 hash;
 __be16 vlan_proto;
 __u16 vlan_tci;

 union {
  unsigned int napi_id;
  unsigned int sender_cpu;
 };





 union {
  __u32 mark;
  __u32 reserved_tailroom;
 };

 union {
  __be16 inner_protocol;
  __u8 inner_ipproto;
 };

 __u16 inner_transport_header;
 __u16 inner_network_header;
 __u16 inner_mac_header;

 __be16 protocol;
 __u16 transport_header;
 __u16 network_header;
 __u16 mac_header;


 __u32 headers_end[0];



 sk_buff_data_t tail;
 sk_buff_data_t end;
 unsigned char *head,
    *data;
 unsigned int truesize;
 refcount_t users;



 struct skb_ext *extensions;

};
# 904 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_pfmemalloc(const struct sk_buff *skb)
{
 return __builtin_expect(!!(skb->pfmemalloc), 0);
}
# 922 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dst_entry *skb_dst(const struct sk_buff *skb)
{



 ({ int __ret_warn_on = !!((skb->_skb_refdst & 1UL) && !rcu_read_lock_held() && !rcu_read_lock_bh_held()); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (929), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (929), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });


 return (struct dst_entry *)(skb->_skb_refdst & ~(1UL));
}
# 941 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
{
 skb->_skb_refdst = (unsigned long)dst;
}
# 956 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst)
{
 ({ int __ret_warn_on = !!(!rcu_read_lock_held() && !rcu_read_lock_bh_held()); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (958), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (958), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 skb->_skb_refdst = (unsigned long)dst | 1UL;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_dst_is_noref(const struct sk_buff *skb)
{
 return (skb->_skb_refdst & 1UL) && skb_dst(skb);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *skb_rtable(const struct sk_buff *skb)
{
 return (struct rtable *)skb_dst(skb);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_pkt_type_ok(u32 ptype)
{
 return ptype <= 3;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_napi_id(const struct sk_buff *skb)
{

 return skb->napi_id;



}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_unref(struct sk_buff *skb)
{
 if (__builtin_expect(!!(!skb), 0))
  return false;
 if (__builtin_expect(!!(refcount_read(&skb->users) == 1), 1))
  __asm__ __volatile__ ("lwsync" " " : : :"memory");
 else if (__builtin_expect(!!(!refcount_dec_and_test(&skb->users)), 1))
  return false;

 return true;
}

void skb_release_head_state(struct sk_buff *skb);
void kfree_skb(struct sk_buff *skb);
void kfree_skb_list(struct sk_buff *segs);
void skb_dump(const char *level, const struct sk_buff *skb, bool full_pkt);
void skb_tx_error(struct sk_buff *skb);
void consume_skb(struct sk_buff *skb);
void __consume_stateless_skb(struct sk_buff *skb);
void __kfree_skb(struct sk_buff *skb);
extern struct kmem_cache *skbuff_head_cache;

void kfree_skb_partial(struct sk_buff *skb, bool head_stolen);
bool skb_try_coalesce(struct sk_buff *to, struct sk_buff *from,
        bool *fragstolen, int *delta_truesize);

struct sk_buff *__alloc_skb(unsigned int size, gfp_t priority, int flags,
       int node);
struct sk_buff *__build_skb(void *data, unsigned int frag_size);
struct sk_buff *build_skb(void *data, unsigned int frag_size);
struct sk_buff *build_skb_around(struct sk_buff *skb,
     void *data, unsigned int frag_size);
# 1048 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *alloc_skb(unsigned int size,
     gfp_t priority)
{
 return __alloc_skb(size, priority, 0, (-1));
}

struct sk_buff *alloc_skb_with_frags(unsigned long header_len,
         unsigned long data_len,
         int max_page_order,
         int *errcode,
         gfp_t gfp_mask);
struct sk_buff *alloc_skb_for_msg(struct sk_buff *first);


struct sk_buff_fclones {
 struct sk_buff skb1;

 struct sk_buff skb2;

 refcount_t fclone_ref;
};
# 1079 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_fclone_busy(const struct sock *sk,
       const struct sk_buff *skb)
{
 const struct sk_buff_fclones *fclones;

 fclones = ({ void *__mptr = (void *)(skb); do { extern void __compiletime_assert_1084(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(skb)), typeof(((struct sk_buff_fclones *)0)->skb1)) && !__builtin_types_compatible_p(typeof(*(skb)), typeof(void))))) __compiletime_assert_1084(); } while (0); ((struct sk_buff_fclones *)(__mptr - __builtin_offsetof(struct sk_buff_fclones, skb1))); });

 return skb->fclone == SKB_FCLONE_ORIG &&
        refcount_read(&fclones->fclone_ref) > 1 &&
        fclones->skb2.sk == sk;
}
# 1098 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *alloc_skb_fclone(unsigned int size,
            gfp_t priority)
{
 return __alloc_skb(size, priority, 0x01, (-1));
}

struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
void skb_headers_offset_update(struct sk_buff *skb, int off);
int skb_copy_ubufs(struct sk_buff *skb, gfp_t gfp_mask);
struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t priority);
void skb_copy_header(struct sk_buff *new, const struct sk_buff *old);
struct sk_buff *skb_copy(const struct sk_buff *skb, gfp_t priority);
struct sk_buff *__pskb_copy_fclone(struct sk_buff *skb, int headroom,
       gfp_t gfp_mask, bool fclone);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__pskb_copy(struct sk_buff *skb, int headroom,
       gfp_t gfp_mask)
{
 return __pskb_copy_fclone(skb, headroom, gfp_mask, false);
}

int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail, gfp_t gfp_mask);
struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
         unsigned int headroom);
struct sk_buff *skb_copy_expand(const struct sk_buff *skb, int newheadroom,
    int newtailroom, gfp_t priority);
int __attribute__((__warn_unused_result__)) skb_to_sgvec_nomark(struct sk_buff *skb, struct scatterlist *sg,
         int offset, int len);
int __attribute__((__warn_unused_result__)) skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg,
         int offset, int len);
int skb_cow_data(struct sk_buff *skb, int tailbits, struct sk_buff **trailer);
int __skb_pad(struct sk_buff *skb, int pad, bool free_on_error);
# 1141 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_pad(struct sk_buff *skb, int pad)
{
 return __skb_pad(skb, pad, true);
}


int skb_append_pagefrags(struct sk_buff *skb, struct page *page,
    int offset, size_t size);

struct skb_seq_state {
 __u32 lower_offset;
 __u32 upper_offset;
 __u32 frag_idx;
 __u32 stepped_offset;
 struct sk_buff *root_skb;
 struct sk_buff *cur_skb;
 __u8 *frag_data;
};

void skb_prepare_seq_read(struct sk_buff *skb, unsigned int from,
     unsigned int to, struct skb_seq_state *st);
unsigned int skb_seq_read(unsigned int consumed, const u8 **data,
     struct skb_seq_state *st);
void skb_abort_seq_read(struct skb_seq_state *st);

unsigned int skb_find_text(struct sk_buff *skb, unsigned int from,
      unsigned int to, struct ts_config *config);
# 1195 "/home/nathan/src/linux-next/include/linux/skbuff.h"
enum pkt_hash_types {
 PKT_HASH_TYPE_NONE,
 PKT_HASH_TYPE_L2,
 PKT_HASH_TYPE_L3,
 PKT_HASH_TYPE_L4,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_clear_hash(struct sk_buff *skb)
{
 skb->hash = 0;
 skb->sw_hash = 0;
 skb->l4_hash = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_clear_hash_if_not_l4(struct sk_buff *skb)
{
 if (!skb->l4_hash)
  skb_clear_hash(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__skb_set_hash(struct sk_buff *skb, __u32 hash, bool is_sw, bool is_l4)
{
 skb->l4_hash = is_l4;
 skb->sw_hash = is_sw;
 skb->hash = hash;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{

 __skb_set_hash(skb, hash, false, type == PKT_HASH_TYPE_L4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__skb_set_sw_hash(struct sk_buff *skb, __u32 hash, bool is_l4)
{
 __skb_set_hash(skb, hash, true, is_l4);
}

void __skb_get_hash(struct sk_buff *skb);
u32 __skb_get_hash_symmetric(const struct sk_buff *skb);
u32 skb_get_poff(const struct sk_buff *skb);
u32 __skb_get_poff(const struct sk_buff *skb, void *data,
     const struct flow_keys_basic *keys, int hlen);
__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
       void *data, int hlen_proto);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 skb_flow_get_ports(const struct sk_buff *skb,
     int thoff, u8 ip_proto)
{
 return __skb_flow_get_ports(skb, thoff, ip_proto, ((void *)0), 0);
}

void skb_flow_dissector_init(struct flow_dissector *flow_dissector,
        const struct flow_dissector_key *key,
        unsigned int key_count);


int skb_flow_dissector_prog_query(const union bpf_attr *attr,
      union bpf_attr *uattr);
int skb_flow_dissector_bpf_prog_attach(const union bpf_attr *attr,
           struct bpf_prog *prog);

int skb_flow_dissector_bpf_prog_detach(const union bpf_attr *attr);
# 1280 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct bpf_flow_dissector;
bool bpf_flow_dissect(struct bpf_prog *prog, struct bpf_flow_dissector *ctx,
        __be16 proto, int nhoff, int hlen, unsigned int flags);

bool __skb_flow_dissect(const struct net *net,
   const struct sk_buff *skb,
   struct flow_dissector *flow_dissector,
   void *target_container,
   void *data, __be16 proto, int nhoff, int hlen,
   unsigned int flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_flow_dissect(const struct sk_buff *skb,
        struct flow_dissector *flow_dissector,
        void *target_container, unsigned int flags)
{
 return __skb_flow_dissect(((void *)0), skb, flow_dissector,
      target_container, ((void *)0), 0, 0, 0, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,
           struct flow_keys *flow,
           unsigned int flags)
{
 memset(flow, 0, sizeof(*flow));
 return __skb_flow_dissect(((void *)0), skb, &flow_keys_dissector,
      flow, ((void *)0), 0, 0, 0, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
skb_flow_dissect_flow_keys_basic(const struct net *net,
     const struct sk_buff *skb,
     struct flow_keys_basic *flow, void *data,
     __be16 proto, int nhoff, int hlen,
     unsigned int flags)
{
 memset(flow, 0, sizeof(*flow));
 return __skb_flow_dissect(net, skb, &flow_keys_basic_dissector, flow,
      data, proto, nhoff, hlen, flags);
}

void skb_flow_dissect_meta(const struct sk_buff *skb,
      struct flow_dissector *flow_dissector,
      void *target_container);





void
skb_flow_dissect_ct(const struct sk_buff *skb,
      struct flow_dissector *flow_dissector,
      void *target_container,
      u16 *ctinfo_map,
      size_t mapsize);
void
skb_flow_dissect_tunnel_info(const struct sk_buff *skb,
        struct flow_dissector *flow_dissector,
        void *target_container);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 skb_get_hash(struct sk_buff *skb)
{
 if (!skb->l4_hash && !skb->sw_hash)
  __skb_get_hash(skb);

 return skb->hash;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 skb_get_hash_flowi6(struct sk_buff *skb, const struct flowi6 *fl6)
{
 if (!skb->l4_hash && !skb->sw_hash) {
  struct flow_keys keys;
  __u32 hash = __get_hash_from_flowi6(fl6, &keys);

  __skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));
 }

 return skb->hash;
}

__u32 skb_get_hash_perturb(const struct sk_buff *skb,
      const siphash_key_t *perturb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 skb_get_hash_raw(const struct sk_buff *skb)
{
 return skb->hash;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_hash(struct sk_buff *to, const struct sk_buff *from)
{
 to->hash = from->hash;
 to->sw_hash = from->sw_hash;
 to->l4_hash = from->l4_hash;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_decrypted(struct sk_buff *to,
          const struct sk_buff *from)
{



}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
 return skb->head + skb->end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_end_offset(const struct sk_buff *skb)
{
 return skb->end;
}
# 1407 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
 return &((struct skb_shared_info *)(skb_end_pointer(skb)))->hwtstamps;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ubuf_info *skb_zcopy(struct sk_buff *skb)
{
 bool is_zcopy = skb && ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags & SKBTX_DEV_ZEROCOPY;

 return is_zcopy ? ((struct ubuf_info *)(((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg)) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_zcopy_set(struct sk_buff *skb, struct ubuf_info *uarg,
     bool *have_ref)
{
 if (skb && uarg && !skb_zcopy(skb)) {
  if (__builtin_expect(!!(have_ref && *have_ref), 0))
   *have_ref = false;
  else
   sock_zerocopy_get(uarg);
  ((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg = uarg;
  ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags |= (SKBTX_DEV_ZEROCOPY | SKBTX_SHARED_FRAG);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_zcopy_set_nouarg(struct sk_buff *skb, void *val)
{
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg = (void *)((uintptr_t) val | 0x1UL);
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags |= (SKBTX_DEV_ZEROCOPY | SKBTX_SHARED_FRAG);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_zcopy_is_nouarg(struct sk_buff *skb)
{
 return (uintptr_t) ((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg & 0x1UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_zcopy_get_nouarg(struct sk_buff *skb)
{
 return (void *)((uintptr_t) ((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg & ~0x1UL);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_zcopy_clear(struct sk_buff *skb, bool zerocopy)
{
 struct ubuf_info *uarg = skb_zcopy(skb);

 if (uarg) {
  if (skb_zcopy_is_nouarg(skb)) {

  } else if (uarg->callback == sock_zerocopy_callback) {
   uarg->zerocopy = uarg->zerocopy && zerocopy;
   sock_zerocopy_put(uarg);
  } else {
   uarg->callback(uarg, zerocopy);
  }

  ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags &= ~(SKBTX_DEV_ZEROCOPY | SKBTX_SHARED_FRAG);
 }
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_zcopy_abort(struct sk_buff *skb)
{
 struct ubuf_info *uarg = skb_zcopy(skb);

 if (uarg) {
  sock_zerocopy_put_abort(uarg, false);
  ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags &= ~(SKBTX_DEV_ZEROCOPY | SKBTX_SHARED_FRAG);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_mark_not_on_list(struct sk_buff *skb)
{
 skb->next = ((void *)0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_list_del_init(struct sk_buff *skb)
{
 __list_del_entry(&skb->list);
 skb_mark_not_on_list(skb);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_queue_empty(const struct sk_buff_head *list)
{
 return list->next == (const struct sk_buff *) list;
}
# 1512 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_queue_empty_lockless(const struct sk_buff_head *list)
{
 return ({ union { typeof(list->next) __val; char __c[1]; } __u; if (1) __read_once_size(&(list->next), __u.__c, sizeof(list->next)); else __read_once_size_nocheck(&(list->next), __u.__c, sizeof(list->next)); do { } while (0); __u.__val; }) == (const struct sk_buff *) list;
}
# 1525 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_queue_is_last(const struct sk_buff_head *list,
         const struct sk_buff *skb)
{
 return skb->next == (const struct sk_buff *) list;
}
# 1538 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_queue_is_first(const struct sk_buff_head *list,
          const struct sk_buff *skb)
{
 return skb->prev == (const struct sk_buff *) list;
}
# 1552 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_queue_next(const struct sk_buff_head *list,
          const struct sk_buff *skb)
{



 do { if (__builtin_constant_p(skb_queue_is_last(list, skb))) { if (skb_queue_is_last(list, skb)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (1558), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (1558), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb_queue_is_last(list, skb)))); } } while (0);
 return skb->next;
}
# 1570 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_queue_prev(const struct sk_buff_head *list,
          const struct sk_buff *skb)
{



 do { if (__builtin_constant_p(skb_queue_is_first(list, skb))) { if (skb_queue_is_first(list, skb)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (1576), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (1576), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb_queue_is_first(list, skb)))); } } while (0);
 return skb->prev;
}
# 1587 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_get(struct sk_buff *skb)
{
 refcount_inc(&skb->users);
 return skb;
}
# 1605 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_cloned(const struct sk_buff *skb)
{
 return skb->cloned &&
        (atomic_read(&((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref) & ((1 << 16) - 1)) != 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_unclone(struct sk_buff *skb, gfp_t pri)
{
 do { if (gfpflags_allow_blocking(pri)) do { do { } while (0); } while (0); } while (0);

 if (skb_cloned(skb))
  return pskb_expand_head(skb, 0, 0, pri);

 return 0;
}
# 1628 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_header_cloned(const struct sk_buff *skb)
{
 int dataref;

 if (!skb->cloned)
  return 0;

 dataref = atomic_read(&((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref);
 dataref = (dataref & ((1 << 16) - 1)) - (dataref >> 16);
 return dataref != 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_header_unclone(struct sk_buff *skb, gfp_t pri)
{
 do { if (gfpflags_allow_blocking(pri)) do { do { } while (0); } while (0); } while (0);

 if (skb_header_cloned(skb))
  return pskb_expand_head(skb, 0, 0, pri);

 return 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_header_release(struct sk_buff *skb)
{
 skb->nohdr = 1;
 atomic_set(&((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref, 1 + (1 << 16));
}
# 1668 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_shared(const struct sk_buff *skb)
{
 return refcount_read(&skb->users) != 1;
}
# 1686 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_share_check(struct sk_buff *skb, gfp_t pri)
{
 do { if (gfpflags_allow_blocking(pri)) do { do { } while (0); } while (0); } while (0);
 if (skb_shared(skb)) {
  struct sk_buff *nskb = skb_clone(skb, pri);

  if (__builtin_expect(!!(nskb), 1))
   consume_skb(skb);
  else
   kfree_skb(skb);
  skb = nskb;
 }
 return skb;
}
# 1721 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_unshare(struct sk_buff *skb,
       gfp_t pri)
{
 do { if (gfpflags_allow_blocking(pri)) do { do { } while (0); } while (0); } while (0);
 if (skb_cloned(skb)) {
  struct sk_buff *nskb = skb_copy(skb, pri);


  if (__builtin_expect(!!(nskb), 1))
   consume_skb(skb);
  else
   kfree_skb(skb);
  skb = nskb;
 }
 return skb;
}
# 1751 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_peek(const struct sk_buff_head *list_)
{
 struct sk_buff *skb = list_->next;

 if (skb == (struct sk_buff *)list_)
  skb = ((void *)0);
 return skb;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__skb_peek(const struct sk_buff_head *list_)
{
 return list_->next;
}
# 1780 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_peek_next(struct sk_buff *skb,
  const struct sk_buff_head *list_)
{
 struct sk_buff *next = skb->next;

 if (next == (struct sk_buff *)list_)
  next = ((void *)0);
 return next;
}
# 1803 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *skb_peek_tail(const struct sk_buff_head *list_)
{
 struct sk_buff *skb = ({ union { typeof(list_->prev) __val; char __c[1]; } __u; if (1) __read_once_size(&(list_->prev), __u.__c, sizeof(list_->prev)); else __read_once_size_nocheck(&(list_->prev), __u.__c, sizeof(list_->prev)); do { } while (0); __u.__val; });

 if (skb == (struct sk_buff *)list_)
  skb = ((void *)0);
 return skb;

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 skb_queue_len(const struct sk_buff_head *list_)
{
 return list_->qlen;
}
# 1831 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 skb_queue_len_lockless(const struct sk_buff_head *list_)
{
 return ({ union { typeof(list_->qlen) __val; char __c[1]; } __u; if (1) __read_once_size(&(list_->qlen), __u.__c, sizeof(list_->qlen)); else __read_once_size_nocheck(&(list_->qlen), __u.__c, sizeof(list_->qlen)); do { } while (0); __u.__val; });
}
# 1846 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_head_init(struct sk_buff_head *list)
{
 list->prev = list->next = (struct sk_buff *)list;
 list->qlen = 0;
}
# 1860 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_head_init(struct sk_buff_head *list)
{
 do { spinlock_check(&list->lock); do { *(&(&list->lock)->rlock) = (raw_spinlock_t) { .raw_lock = { 0 }, }; } while (0); } while (0);
 __skb_queue_head_init(list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_head_init_class(struct sk_buff_head *list,
  struct lock_class_key *class)
{
 skb_queue_head_init(list);
 do { (void)(class); } while (0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_insert(struct sk_buff *newsk,
    struct sk_buff *prev, struct sk_buff *next,
    struct sk_buff_head *list)
{



 ({ union { typeof(newsk->next) __val; char __c[1]; } __u = { .__val = ( typeof(newsk->next)) (next) }; __write_once_size(&(newsk->next), __u.__c, sizeof(newsk->next)); __u.__val; });
 ({ union { typeof(newsk->prev) __val; char __c[1]; } __u = { .__val = ( typeof(newsk->prev)) (prev) }; __write_once_size(&(newsk->prev), __u.__c, sizeof(newsk->prev)); __u.__val; });
 ({ union { typeof(next->prev) __val; char __c[1]; } __u = { .__val = ( typeof(next->prev)) (newsk) }; __write_once_size(&(next->prev), __u.__c, sizeof(next->prev)); __u.__val; });
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (newsk) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });
 list->qlen++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_splice(const struct sk_buff_head *list,
          struct sk_buff *prev,
          struct sk_buff *next)
{
 struct sk_buff *first = list->next;
 struct sk_buff *last = list->prev;

 ({ union { typeof(first->prev) __val; char __c[1]; } __u = { .__val = ( typeof(first->prev)) (prev) }; __write_once_size(&(first->prev), __u.__c, sizeof(first->prev)); __u.__val; });
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (first) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });

 ({ union { typeof(last->next) __val; char __c[1]; } __u = { .__val = ( typeof(last->next)) (next) }; __write_once_size(&(last->next), __u.__c, sizeof(last->next)); __u.__val; });
 ({ union { typeof(next->prev) __val; char __c[1]; } __u = { .__val = ( typeof(next->prev)) (last) }; __write_once_size(&(next->prev), __u.__c, sizeof(next->prev)); __u.__val; });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_splice(const struct sk_buff_head *list,
        struct sk_buff_head *head)
{
 if (!skb_queue_empty(list)) {
  __skb_queue_splice(list, (struct sk_buff *) head, head->next);
  head->qlen += list->qlen;
 }
}
# 1928 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_splice_init(struct sk_buff_head *list,
      struct sk_buff_head *head)
{
 if (!skb_queue_empty(list)) {
  __skb_queue_splice(list, (struct sk_buff *) head, head->next);
  head->qlen += list->qlen;
  __skb_queue_head_init(list);
 }
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_splice_tail(const struct sk_buff_head *list,
      struct sk_buff_head *head)
{
 if (!skb_queue_empty(list)) {
  __skb_queue_splice(list, head->prev, (struct sk_buff *) head);
  head->qlen += list->qlen;
 }
}
# 1960 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_queue_splice_tail_init(struct sk_buff_head *list,
           struct sk_buff_head *head)
{
 if (!skb_queue_empty(list)) {
  __skb_queue_splice(list, head->prev, (struct sk_buff *) head);
  head->qlen += list->qlen;
  __skb_queue_head_init(list);
 }
}
# 1981 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_after(struct sk_buff_head *list,
         struct sk_buff *prev,
         struct sk_buff *newsk)
{
 __skb_insert(newsk, prev, prev->next, list);
}

void skb_append(struct sk_buff *old, struct sk_buff *newsk,
  struct sk_buff_head *list);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_before(struct sk_buff_head *list,
          struct sk_buff *next,
          struct sk_buff *newsk)
{
 __skb_insert(newsk, next->prev, next, list);
}
# 2008 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_head(struct sk_buff_head *list,
        struct sk_buff *newsk)
{
 __skb_queue_after(list, (struct sk_buff *)list, newsk);
}
void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk);
# 2025 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_tail(struct sk_buff_head *list,
       struct sk_buff *newsk)
{
 __skb_queue_before(list, (struct sk_buff *)list, newsk);
}
void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk);





void skb_unlink(struct sk_buff *skb, struct sk_buff_head *list);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
 struct sk_buff *next, *prev;

 ({ union { typeof(list->qlen) __val; char __c[1]; } __u = { .__val = ( typeof(list->qlen)) (list->qlen - 1) }; __write_once_size(&(list->qlen), __u.__c, sizeof(list->qlen)); __u.__val; });
 next = skb->next;
 prev = skb->prev;
 skb->next = skb->prev = ((void *)0);
 ({ union { typeof(next->prev) __val; char __c[1]; } __u = { .__val = ( typeof(next->prev)) (prev) }; __write_once_size(&(next->prev), __u.__c, sizeof(next->prev)); __u.__val; });
 ({ union { typeof(prev->next) __val; char __c[1]; } __u = { .__val = ( typeof(prev->next)) (next) }; __write_once_size(&(prev->next), __u.__c, sizeof(prev->next)); __u.__val; });
}
# 2057 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
 struct sk_buff *skb = skb_peek(list);
 if (skb)
  __skb_unlink(skb, list);
 return skb;
}
struct sk_buff *skb_dequeue(struct sk_buff_head *list);
# 2074 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
 struct sk_buff *skb = skb_peek_tail(list);
 if (skb)
  __skb_unlink(skb, list);
 return skb;
}
struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_nonlinear(const struct sk_buff *skb)
{
 return skb->data_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_headlen(const struct sk_buff *skb)
{
 return skb->len - skb->data_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __skb_pagelen(const struct sk_buff *skb)
{
 unsigned int i, len = 0;

 for (i = ((struct skb_shared_info *)(skb_end_pointer(skb)))->nr_frags - 1; (int)i >= 0; i--)
  len += skb_frag_size(&((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i]);
 return len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_pagelen(const struct sk_buff *skb)
{
 return skb_headlen(skb) + __skb_pagelen(skb);
}
# 2121 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_fill_page_desc(struct sk_buff *skb, int i,
     struct page *page, int off, int size)
{
 skb_frag_t *frag = &((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i];






 frag->bv_page = page;
 frag->bv_offset = off;
 skb_frag_size_set(frag, size);

 page = compound_head(page);
 if (page_is_pfmemalloc(page))
  skb->pfmemalloc = true;
}
# 2154 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_fill_page_desc(struct sk_buff *skb, int i,
          struct page *page, int off, int size)
{
 __skb_fill_page_desc(skb, i, page, off, size);
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->nr_frags = i + 1;
}

void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
       int size, unsigned int truesize);

void skb_coalesce_rx_frag(struct sk_buff *skb, int i, int size,
     unsigned int truesize);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_tail_pointer(const struct sk_buff *skb)
{
 return skb->head + skb->tail;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_tail_pointer(struct sk_buff *skb)
{
 skb->tail = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
{
 skb_reset_tail_pointer(skb);
 skb->tail += offset;
}
# 2207 "/home/nathan/src/linux-next/include/linux/skbuff.h"
void *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
void *skb_put(struct sk_buff *skb, unsigned int len);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__skb_put(struct sk_buff *skb, unsigned int len)
{
 void *tmp = skb_tail_pointer(skb);
 do { if (__builtin_constant_p(skb_is_nonlinear(skb))) { if (skb_is_nonlinear(skb)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2212), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2212), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb_is_nonlinear(skb)))); } } while (0);
 skb->tail += len;
 skb->len += len;
 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__skb_put_zero(struct sk_buff *skb, unsigned int len)
{
 void *tmp = __skb_put(skb, len);

 memset(tmp, 0, len);
 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__skb_put_data(struct sk_buff *skb, const void *data,
       unsigned int len)
{
 void *tmp = __skb_put(skb, len);

 memcpy(tmp, data, len);
 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_put_u8(struct sk_buff *skb, u8 val)
{
 *(u8 *)__skb_put(skb, 1) = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_put_zero(struct sk_buff *skb, unsigned int len)
{
 void *tmp = skb_put(skb, len);

 memset(tmp, 0, len);

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_put_data(struct sk_buff *skb, const void *data,
     unsigned int len)
{
 void *tmp = skb_put(skb, len);

 memcpy(tmp, data, len);

 return tmp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_put_u8(struct sk_buff *skb, u8 val)
{
 *(u8 *)skb_put(skb, 1) = val;
}

void *skb_push(struct sk_buff *skb, unsigned int len);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__skb_push(struct sk_buff *skb, unsigned int len)
{
 skb->data -= len;
 skb->len += len;
 return skb->data;
}

void *skb_pull(struct sk_buff *skb, unsigned int len);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__skb_pull(struct sk_buff *skb, unsigned int len)
{
 skb->len -= len;
 do { if (__builtin_constant_p(skb->len < skb->data_len)) { if (skb->len < skb->data_len) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2276), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2276), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb->len < skb->data_len))); } } while (0);
 return skb->data += len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_pull_inline(struct sk_buff *skb, unsigned int len)
{
 return __builtin_expect(!!(len > skb->len), 0) ? ((void *)0) : __skb_pull(skb, len);
}

void *__pskb_pull_tail(struct sk_buff *skb, int delta);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
 if (len > skb_headlen(skb) &&
     !__pskb_pull_tail(skb, len - skb_headlen(skb)))
  return ((void *)0);
 skb->len -= len;
 return skb->data += len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *pskb_pull(struct sk_buff *skb, unsigned int len)
{
 return __builtin_expect(!!(len > skb->len), 0) ? ((void *)0) : __pskb_pull(skb, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
 if (__builtin_expect(!!(len <= skb_headlen(skb)), 1))
  return true;
 if (__builtin_expect(!!(len > skb->len), 0))
  return false;
 return __pskb_pull_tail(skb, len - skb_headlen(skb)) != ((void *)0);
}

void skb_condense(struct sk_buff *skb);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_headroom(const struct sk_buff *skb)
{
 return skb->data - skb->head;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_tailroom(const struct sk_buff *skb)
{
 return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
}
# 2341 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_availroom(const struct sk_buff *skb)
{
 if (skb_is_nonlinear(skb))
  return 0;

 return skb->end - skb->tail - skb->reserved_tailroom;
}
# 2357 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reserve(struct sk_buff *skb, int len)
{
 skb->data += len;
 skb->tail += len;
}
# 2375 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_tailroom_reserve(struct sk_buff *skb, unsigned int mtu,
     unsigned int needed_tailroom)
{
 do { if (__builtin_constant_p(skb_is_nonlinear(skb))) { if (skb_is_nonlinear(skb)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2378), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2378), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb_is_nonlinear(skb)))); } } while (0);
 if (mtu < skb_tailroom(skb) - needed_tailroom)

  skb->reserved_tailroom = skb_tailroom(skb) - mtu;
 else

  skb->reserved_tailroom = needed_tailroom;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_inner_protocol(struct sk_buff *skb,
       __be16 protocol)
{
 skb->inner_protocol = protocol;
 skb->inner_protocol_type = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_inner_ipproto(struct sk_buff *skb,
      __u8 ipproto)
{
 skb->inner_ipproto = ipproto;
 skb->inner_protocol_type = 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_inner_headers(struct sk_buff *skb)
{
 skb->inner_mac_header = skb->mac_header;
 skb->inner_network_header = skb->network_header;
 skb->inner_transport_header = skb->transport_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_mac_len(struct sk_buff *skb)
{
 skb->mac_len = skb->network_header - skb->mac_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_inner_transport_header(const struct sk_buff
       *skb)
{
 return skb->head + skb->inner_transport_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_inner_transport_offset(const struct sk_buff *skb)
{
 return skb_inner_transport_header(skb) - skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_inner_transport_header(struct sk_buff *skb)
{
 skb->inner_transport_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_inner_transport_header(struct sk_buff *skb,
         const int offset)
{
 skb_reset_inner_transport_header(skb);
 skb->inner_transport_header += offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_inner_network_header(const struct sk_buff *skb)
{
 return skb->head + skb->inner_network_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_inner_network_header(struct sk_buff *skb)
{
 skb->inner_network_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_inner_network_header(struct sk_buff *skb,
      const int offset)
{
 skb_reset_inner_network_header(skb);
 skb->inner_network_header += offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_inner_mac_header(const struct sk_buff *skb)
{
 return skb->head + skb->inner_mac_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_inner_mac_header(struct sk_buff *skb)
{
 skb->inner_mac_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_inner_mac_header(struct sk_buff *skb,
         const int offset)
{
 skb_reset_inner_mac_header(skb);
 skb->inner_mac_header += offset;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_transport_header_was_set(const struct sk_buff *skb)
{
 return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_transport_header(const struct sk_buff *skb)
{
 return skb->head + skb->transport_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_transport_header(struct sk_buff *skb)
{
 skb->transport_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_transport_header(struct sk_buff *skb,
         const int offset)
{
 skb_reset_transport_header(skb);
 skb->transport_header += offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_network_header(const struct sk_buff *skb)
{
 return skb->head + skb->network_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_network_header(struct sk_buff *skb)
{
 skb->network_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_network_header(struct sk_buff *skb, const int offset)
{
 skb_reset_network_header(skb);
 skb->network_header += offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_mac_header(const struct sk_buff *skb)
{
 return skb->head + skb->mac_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_mac_offset(const struct sk_buff *skb)
{
 return skb_mac_header(skb) - skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 skb_mac_header_len(const struct sk_buff *skb)
{
 return skb->network_header - skb->mac_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_mac_header_was_set(const struct sk_buff *skb)
{
 return skb->mac_header != (typeof(skb->mac_header))~0U;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_mac_header(struct sk_buff *skb)
{
 skb->mac_header = skb->data - skb->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_mac_header(struct sk_buff *skb, const int offset)
{
 skb_reset_mac_header(skb);
 skb->mac_header += offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_pop_mac_header(struct sk_buff *skb)
{
 skb->mac_header = skb->network_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_probe_transport_header(struct sk_buff *skb)
{
 struct flow_keys_basic keys;

 if (skb_transport_header_was_set(skb))
  return;

 if (skb_flow_dissect_flow_keys_basic(((void *)0), skb, &keys,
          ((void *)0), 0, 0, 0, 0))
  skb_set_transport_header(skb, keys.control.thoff);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_mac_header_rebuild(struct sk_buff *skb)
{
 if (skb_mac_header_was_set(skb)) {
  const unsigned char *old_mac = skb_mac_header(skb);

  skb_set_mac_header(skb, -skb->mac_len);
  memmove(skb_mac_header(skb), old_mac, skb->mac_len);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_checksum_start_offset(const struct sk_buff *skb)
{
 return skb->csum_start - skb_headroom(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned char *skb_checksum_start(const struct sk_buff *skb)
{
 return skb->head + skb->csum_start;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_transport_offset(const struct sk_buff *skb)
{
 return skb_transport_header(skb) - skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 skb_network_header_len(const struct sk_buff *skb)
{
 return skb->transport_header - skb->network_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 skb_inner_network_header_len(const struct sk_buff *skb)
{
 return skb->inner_transport_header - skb->inner_network_header;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_network_offset(const struct sk_buff *skb)
{
 return skb_network_header(skb) - skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_inner_network_offset(const struct sk_buff *skb)
{
 return skb_inner_network_header(skb) - skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pskb_network_may_pull(struct sk_buff *skb, unsigned int len)
{
 return pskb_may_pull(skb, skb_network_offset(skb) + len);
}
# 2656 "/home/nathan/src/linux-next/include/linux/skbuff.h"
int ___pskb_trim(struct sk_buff *skb, unsigned int len);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_set_length(struct sk_buff *skb, unsigned int len)
{
 if (({ int __ret_warn_on = !!(skb_is_nonlinear(skb)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2660), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2660), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); }))
  return;
 skb->len = len;
 skb_set_tail_pointer(skb, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_trim(struct sk_buff *skb, unsigned int len)
{
 __skb_set_length(skb, len);
}

void skb_trim(struct sk_buff *skb, unsigned int len);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
 if (skb->data_len)
  return ___pskb_trim(skb, len);
 __skb_trim(skb, len);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pskb_trim(struct sk_buff *skb, unsigned int len)
{
 return (len < skb->len) ? __pskb_trim(skb, len) : 0;
}
# 2695 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pskb_trim_unique(struct sk_buff *skb, unsigned int len)
{
 int err = pskb_trim(skb, len);
 do { if (__builtin_constant_p(err)) { if (err) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2698), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2698), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(err))); } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_grow(struct sk_buff *skb, unsigned int len)
{
 unsigned int diff = len - skb->len;

 if (skb_tailroom(skb) < diff) {
  int ret = pskb_expand_head(skb, 0, diff - skb_tailroom(skb),
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
  if (ret)
   return ret;
 }
 __skb_set_length(skb, len);
 return 0;
}
# 2723 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_orphan(struct sk_buff *skb)
{
 if (skb->destructor) {
  skb->destructor(skb);
  skb->destructor = ((void *)0);
  skb->sk = ((void *)0);
 } else {
  do { if (__builtin_constant_p(skb->sk)) { if (skb->sk) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2730), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (2730), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(skb->sk))); } } while (0);
 }
}
# 2743 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_orphan_frags(struct sk_buff *skb, gfp_t gfp_mask)
{
 if (__builtin_expect(!!(!skb_zcopy(skb)), 1))
  return 0;
 if (!skb_zcopy_is_nouarg(skb) &&
     ((struct ubuf_info *)(((struct skb_shared_info *)(skb_end_pointer(skb)))->destructor_arg))->callback == sock_zerocopy_callback)
  return 0;
 return skb_copy_ubufs(skb, gfp_mask);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_orphan_frags_rx(struct sk_buff *skb, gfp_t gfp_mask)
{
 if (__builtin_expect(!!(!skb_zcopy(skb)), 1))
  return 0;
 return skb_copy_ubufs(skb, gfp_mask);
}
# 2769 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_queue_purge(struct sk_buff_head *list)
{
 struct sk_buff *skb;
 while ((skb = __skb_dequeue(list)) != ((void *)0))
  kfree_skb(skb);
}
void skb_queue_purge(struct sk_buff_head *list);

unsigned int skb_rbtree_purge(struct rb_root *root);

void *netdev_alloc_frag(unsigned int fragsz);

struct sk_buff *__netdev_alloc_skb(struct net_device *dev, unsigned int length,
       gfp_t gfp_mask);
# 2797 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *netdev_alloc_skb(struct net_device *dev,
            unsigned int length)
{
 return __netdev_alloc_skb(dev, length, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__dev_alloc_skb(unsigned int length,
           gfp_t gfp_mask)
{
 return __netdev_alloc_skb(((void *)0), length, gfp_mask);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *dev_alloc_skb(unsigned int length)
{
 return netdev_alloc_skb(((void *)0), length);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
  unsigned int length, gfp_t gfp)
{
 struct sk_buff *skb = __netdev_alloc_skb(dev, length + 0, gfp);

 if (0 && skb)
  skb_reserve(skb, 0);
 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
  unsigned int length)
{
 return __netdev_alloc_skb_ip_align(dev, length, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_free_frag(void *addr)
{
 page_frag_free(addr);
}

void *napi_alloc_frag(unsigned int fragsz);
struct sk_buff *__napi_alloc_skb(struct napi_struct *napi,
     unsigned int length, gfp_t gfp_mask);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *napi_alloc_skb(struct napi_struct *napi,
          unsigned int length)
{
 return __napi_alloc_skb(napi, length, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}
void napi_consume_skb(struct sk_buff *skb, int budget);

void __kfree_skb_flush(void);
void __kfree_skb_defer(struct sk_buff *skb);
# 2860 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *__dev_alloc_pages(gfp_t gfp_mask,
          unsigned int order)
{
# 2871 "/home/nathan/src/linux-next/include/linux/skbuff.h"
 gfp_mask |= (( gfp_t)0x40000u) | (( gfp_t)0x20000u);

 return alloc_pages_node((-1), gfp_mask, order);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *dev_alloc_pages(unsigned int order)
{
 return __dev_alloc_pages(((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)) | (( gfp_t)0x2000u), order);
}
# 2889 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *__dev_alloc_page(gfp_t gfp_mask)
{
 return __dev_alloc_pages(gfp_mask, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *dev_alloc_page(void)
{
 return dev_alloc_pages(0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_propagate_pfmemalloc(struct page *page,
          struct sk_buff *skb)
{
 if (page_is_pfmemalloc(page))
  skb->pfmemalloc = true;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_frag_off(const skb_frag_t *frag)
{
 return frag->bv_offset;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_off_add(skb_frag_t *frag, int delta)
{
 frag->bv_offset += delta;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_off_set(skb_frag_t *frag, unsigned int offset)
{
 frag->bv_offset = offset;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_off_copy(skb_frag_t *fragto,
         const skb_frag_t *fragfrom)
{
 fragto->bv_offset = fragfrom->bv_offset;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *skb_frag_page(const skb_frag_t *frag)
{
 return frag->bv_page;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_frag_ref(skb_frag_t *frag)
{
 get_page(skb_frag_page(frag));
}
# 2980 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_ref(struct sk_buff *skb, int f)
{
 __skb_frag_ref(&((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[f]);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_frag_unref(skb_frag_t *frag)
{
 put_page(skb_frag_page(frag));
}
# 3003 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_unref(struct sk_buff *skb, int f)
{
 __skb_frag_unref(&((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[f]);
}
# 3015 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_frag_address(const skb_frag_t *frag)
{
 return lowmem_page_address(skb_frag_page(frag)) + skb_frag_off(frag);
}
# 3027 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_frag_address_safe(const skb_frag_t *frag)
{
 void *ptr = lowmem_page_address(skb_frag_page(frag));
 if (__builtin_expect(!!(!ptr), 0))
  return ((void *)0);

 return ptr + skb_frag_off(frag);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_page_copy(skb_frag_t *fragto,
          const skb_frag_t *fragfrom)
{
 fragto->bv_page = fragfrom->bv_page;
}
# 3054 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_frag_set_page(skb_frag_t *frag, struct page *page)
{
 frag->bv_page = page;
}
# 3067 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_set_page(struct sk_buff *skb, int f,
         struct page *page)
{
 __skb_frag_set_page(&((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[f], page);
}

bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t prio);
# 3086 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dma_addr_t skb_frag_dma_map(struct device *dev,
       const skb_frag_t *frag,
       size_t offset, size_t size,
       enum dma_data_direction dir)
{
 return dma_map_page_attrs(dev, skb_frag_page(frag), skb_frag_off(frag) + offset, size, dir, 0);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *pskb_copy(struct sk_buff *skb,
     gfp_t gfp_mask)
{
 return __pskb_copy(skb, skb_headroom(skb), gfp_mask);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *pskb_copy_for_clone(struct sk_buff *skb,
        gfp_t gfp_mask)
{
 return __pskb_copy_fclone(skb, skb_headroom(skb), gfp_mask, true);
}
# 3117 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_clone_writable(const struct sk_buff *skb, unsigned int len)
{
 return !skb_header_cloned(skb) &&
        skb_headroom(skb) + len <= skb->hdr_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_try_make_writable(struct sk_buff *skb,
     unsigned int write_len)
{
 return skb_cloned(skb) && !skb_clone_writable(skb, write_len) &&
        pskb_expand_head(skb, 0, 0, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_cow(struct sk_buff *skb, unsigned int headroom,
       int cloned)
{
 int delta = 0;

 if (headroom > skb_headroom(skb))
  delta = headroom - skb_headroom(skb);

 if (delta || cloned)
  return pskb_expand_head(skb, ((((delta)) + ((typeof((delta)))((__builtin_choose_expr(((!!(sizeof((typeof(32) *)1 == (typeof((1 << 7)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(32) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((1 << 7)) * 0l)) : (int *)8))))), ((32) > ((1 << 7)) ? (32) : ((1 << 7))), ({ typeof(32) __UNIQUE_ID___x26 = (32); typeof((1 << 7)) __UNIQUE_ID___y27 = ((1 << 7)); ((__UNIQUE_ID___x26) > (__UNIQUE_ID___y27) ? (__UNIQUE_ID___x26) : (__UNIQUE_ID___y27)); })))) - 1)) & ~((typeof((delta)))((__builtin_choose_expr(((!!(sizeof((typeof(32) *)1 == (typeof((1 << 7)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(32) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((1 << 7)) * 0l)) : (int *)8))))), ((32) > ((1 << 7)) ? (32) : ((1 << 7))), ({ typeof(32) __UNIQUE_ID___x26 = (32); typeof((1 << 7)) __UNIQUE_ID___y27 = ((1 << 7)); ((__UNIQUE_ID___x26) > (__UNIQUE_ID___y27) ? (__UNIQUE_ID___x26) : (__UNIQUE_ID___y27)); })))) - 1)), 0,
     ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 return 0;
}
# 3156 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_cow(struct sk_buff *skb, unsigned int headroom)
{
 return __skb_cow(skb, headroom, skb_cloned(skb));
}
# 3171 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
 return __skb_cow(skb, headroom, skb_header_cloned(skb));
}
# 3186 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_padto(struct sk_buff *skb, unsigned int len)
{
 unsigned int size = skb->len;
 if (__builtin_expect(!!(size >= len), 1))
  return 0;
 return skb_pad(skb, len - size);
}
# 3205 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_put_padto(struct sk_buff *skb, unsigned int len,
      bool free_on_error)
{
 unsigned int size = skb->len;

 if (__builtin_expect(!!(size < len), 0)) {
  len -= size;
  if (__skb_pad(skb, len, free_on_error))
   return -12;
  __skb_put(skb, len);
 }
 return 0;
}
# 3229 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
 return __skb_put_padto(skb, len, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_add_data(struct sk_buff *skb,
          struct iov_iter *from, int copy)
{
 const int off = skb->len;

 if (skb->ip_summed == 0) {
  __wsum csum = 0;
  if (csum_and_copy_from_iter_full(skb_put(skb, copy), copy,
              &csum, from)) {
   skb->csum = csum_block_add(skb->csum, csum, off);
   return 0;
  }
 } else if (copy_from_iter_full(skb_put(skb, copy), copy, from))
  return 0;

 __skb_trim(skb, off);
 return -14;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_can_coalesce(struct sk_buff *skb, int i,
        const struct page *page, int off)
{
 if (skb_zcopy(skb))
  return false;
 if (i) {
  const skb_frag_t *frag = &((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i - 1];

  return page == skb_frag_page(frag) &&
         off == skb_frag_off(frag) + skb_frag_size(frag);
 }
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_linearize(struct sk_buff *skb)
{
 return __pskb_pull_tail(skb, skb->data_len) ? 0 : -12;
}
# 3279 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_linearize(struct sk_buff *skb)
{
 return skb_is_nonlinear(skb) ? __skb_linearize(skb) : 0;
}
# 3291 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_has_shared_frag(const struct sk_buff *skb)
{
 return skb_is_nonlinear(skb) &&
        ((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags & SKBTX_SHARED_FRAG;
}
# 3304 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_linearize_cow(struct sk_buff *skb)
{
 return skb_is_nonlinear(skb) || skb_cloned(skb) ?
        __skb_linearize(skb) : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
__skb_postpull_rcsum(struct sk_buff *skb, const void *start, unsigned int len,
       unsigned int off)
{
 if (skb->ip_summed == 2)
  skb->csum = csum_block_sub(skb->csum,
        csum_partial(start, len, 0), off);
 else if (skb->ip_summed == 3 &&
   skb_checksum_start_offset(skb) < 0)
  skb->ip_summed = 0;
}
# 3332 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_postpull_rcsum(struct sk_buff *skb,
          const void *start, unsigned int len)
{
 __skb_postpull_rcsum(skb, start, len, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
__skb_postpush_rcsum(struct sk_buff *skb, const void *start, unsigned int len,
       unsigned int off)
{
 if (skb->ip_summed == 2)
  skb->csum = csum_block_add(skb->csum,
        csum_partial(start, len, 0), off);
}
# 3356 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_postpush_rcsum(struct sk_buff *skb,
          const void *start, unsigned int len)
{
 __skb_postpush_rcsum(skb, start, len, 0);
}

void *skb_pull_rcsum(struct sk_buff *skb, unsigned int len);
# 3375 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_push_rcsum(struct sk_buff *skb, unsigned int len)
{
 skb_push(skb, len);
 skb_postpush_rcsum(skb, skb->data, len);
 return skb->data;
}

int pskb_trim_rcsum_slow(struct sk_buff *skb, unsigned int len);
# 3393 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int pskb_trim_rcsum(struct sk_buff *skb, unsigned int len)
{
 if (__builtin_expect(!!(len >= skb->len), 1))
  return 0;
 return pskb_trim_rcsum_slow(skb, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_trim_rcsum(struct sk_buff *skb, unsigned int len)
{
 if (skb->ip_summed == 2)
  skb->ip_summed = 0;
 __skb_trim(skb, len);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __skb_grow_rcsum(struct sk_buff *skb, unsigned int len)
{
 if (skb->ip_summed == 2)
  skb->ip_summed = 0;
 return __skb_grow(skb, len);
}
# 3467 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_has_frag_list(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_frag_list_init(struct sk_buff *skb)
{
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list = ((void *)0);
}





int __skb_wait_for_more_packets(struct sock *sk, struct sk_buff_head *queue,
    int *err, long *timeo_p,
    const struct sk_buff *skb);
struct sk_buff *__skb_try_recv_from_queue(struct sock *sk,
       struct sk_buff_head *queue,
       unsigned int flags,
       void (*destructor)(struct sock *sk,
          struct sk_buff *skb),
       int *off, int *err,
       struct sk_buff **last);
struct sk_buff *__skb_try_recv_datagram(struct sock *sk,
     struct sk_buff_head *queue,
     unsigned int flags,
     void (*destructor)(struct sock *sk,
          struct sk_buff *skb),
     int *off, int *err,
     struct sk_buff **last);
struct sk_buff *__skb_recv_datagram(struct sock *sk,
        struct sk_buff_head *sk_queue,
        unsigned int flags,
        void (*destructor)(struct sock *sk,
             struct sk_buff *skb),
        int *off, int *err);
struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
      int *err);
__poll_t datagram_poll(struct file *file, struct socket *sock,
      struct poll_table_struct *wait);
int skb_copy_datagram_iter(const struct sk_buff *from, int offset,
      struct iov_iter *to, int size);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_copy_datagram_msg(const struct sk_buff *from, int offset,
     struct msghdr *msg, int size)
{
 return skb_copy_datagram_iter(from, offset, &msg->msg_iter, size);
}
int skb_copy_and_csum_datagram_msg(struct sk_buff *skb, int hlen,
       struct msghdr *msg);
int skb_copy_and_hash_datagram_iter(const struct sk_buff *skb, int offset,
      struct iov_iter *to, int len,
      struct ahash_request *hash);
int skb_copy_datagram_from_iter(struct sk_buff *skb, int offset,
     struct iov_iter *from, int len);
int zerocopy_sg_from_iter(struct sk_buff *skb, struct iov_iter *frm);
void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
void __skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb, int len);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_free_datagram_locked(struct sock *sk,
         struct sk_buff *skb)
{
 __skb_free_datagram_locked(sk, skb, 0);
}
int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
__wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
         int len, __wsum csum);
int skb_splice_bits(struct sk_buff *skb, struct sock *sk, unsigned int offset,
      struct pipe_inode_info *pipe, unsigned int len,
      unsigned int flags);
int skb_send_sock_locked(struct sock *sk, struct sk_buff *skb, int offset,
    int len);
void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
int skb_zerocopy(struct sk_buff *to, struct sk_buff *from,
   int len, int hlen);
void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
void skb_scrub_packet(struct sk_buff *skb, bool xnet);
bool skb_gso_validate_network_len(const struct sk_buff *skb, unsigned int mtu);
bool skb_gso_validate_mac_len(const struct sk_buff *skb, unsigned int len);
struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
struct sk_buff *skb_segment_list(struct sk_buff *skb, netdev_features_t features,
     unsigned int offset);
struct sk_buff *skb_vlan_untag(struct sk_buff *skb);
int skb_ensure_writable(struct sk_buff *skb, int write_len);
int __skb_vlan_pop(struct sk_buff *skb, u16 *vlan_tci);
int skb_vlan_pop(struct sk_buff *skb);
int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci);
int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto,
    int mac_len, bool ethernet);
int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto, int mac_len,
   bool ethernet);
int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse);
int skb_mpls_dec_ttl(struct sk_buff *skb);
struct sk_buff *pskb_extract(struct sk_buff *skb, int off, int to_copy,
        gfp_t gfp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int memcpy_from_msg(void *data, struct msghdr *msg, int len)
{
 return copy_from_iter_full(data, len, &msg->msg_iter) ? 0 : -14;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int memcpy_to_msg(struct msghdr *msg, void *data, int len)
{
 return copy_to_iter(data, len, &msg->msg_iter) == len ? 0 : -14;
}

struct skb_checksum_ops {
 __wsum (*update)(const void *mem, int len, __wsum wsum);
 __wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
};

extern const struct skb_checksum_ops *crc32c_csum_stub __attribute__((__section__(".data..read_mostly")));

__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
        __wsum csum, const struct skb_checksum_ops *ops);
__wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
      __wsum csum);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__))
__skb_header_pointer(const struct sk_buff *skb, int offset,
       int len, void *data, int hlen, void *buffer)
{
 if (hlen - offset >= len)
  return data + offset;

 if (!skb ||
     skb_copy_bits(skb, offset, buffer, len) < 0)
  return ((void *)0);

 return buffer;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void * __attribute__((__warn_unused_result__))
skb_header_pointer(const struct sk_buff *skb, int offset, int len, void *buffer)
{
 return __skb_header_pointer(skb, offset, len, skb->data,
        skb_headlen(skb), buffer);
}
# 3619 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_needs_linearize(struct sk_buff *skb,
           netdev_features_t features)
{
 return skb_is_nonlinear(skb) &&
        ((skb_has_frag_list(skb) && !(features & ((netdev_features_t)1 << (NETIF_F_FRAGLIST_BIT)))) ||
  (((struct skb_shared_info *)(skb_end_pointer(skb)))->nr_frags && !(features & ((netdev_features_t)1 << (NETIF_F_SG_BIT)))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_from_linear_data(const struct sk_buff *skb,
          void *to,
          const unsigned int len)
{
 memcpy(to, skb->data, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_from_linear_data_offset(const struct sk_buff *skb,
          const int offset, void *to,
          const unsigned int len)
{
 memcpy(to, skb->data + offset, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_to_linear_data(struct sk_buff *skb,
        const void *from,
        const unsigned int len)
{
 memcpy(skb->data, from, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_to_linear_data_offset(struct sk_buff *skb,
        const int offset,
        const void *from,
        const unsigned int len)
{
 memcpy(skb->data + offset, from, len);
}

void skb_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t skb_get_ktime(const struct sk_buff *skb)
{
 return skb->tstamp;
}
# 3672 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_get_timestamp(const struct sk_buff *skb,
         struct __kernel_old_timeval *stamp)
{
 *stamp = ns_to_kernel_old_timeval(skb->tstamp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_get_new_timestamp(const struct sk_buff *skb,
      struct __kernel_sock_timeval *stamp)
{
 struct timespec64 ts = ns_to_timespec64((skb->tstamp));

 stamp->tv_sec = ts.tv_sec;
 stamp->tv_usec = ts.tv_nsec / 1000;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_get_timestampns(const struct sk_buff *skb,
           struct __kernel_old_timespec *stamp)
{
 struct timespec64 ts = ns_to_timespec64((skb->tstamp));

 stamp->tv_sec = ts.tv_sec;
 stamp->tv_nsec = ts.tv_nsec;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_get_new_timestampns(const struct sk_buff *skb,
        struct __kernel_timespec *stamp)
{
 struct timespec64 ts = ns_to_timespec64((skb->tstamp));

 stamp->tv_sec = ts.tv_sec;
 stamp->tv_nsec = ts.tv_nsec;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __net_timestamp(struct sk_buff *skb)
{
 skb->tstamp = ktime_get_real();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t net_timedelta(ktime_t t)
{
 return ((ktime_get_real()) - (t));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t net_invalid_timestamp(void)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 skb_metadata_len(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->meta_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_metadata_end(const struct sk_buff *skb)
{
 return skb_mac_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_metadata_differs(const struct sk_buff *skb_a,
       const struct sk_buff *skb_b,
       u8 meta_len)
{
 const void *a = skb_metadata_end(skb_a);
 const void *b = skb_metadata_end(skb_b);


 u64 diffs = 0;

 switch (meta_len) {


 case 32: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 24: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 16: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 8: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));
  break;
 case 28: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 20: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 12: diffs |= (*(u64 *)(a -= sizeof(u64))) ^ (*(u64 *)(b -= sizeof(u64)));

 case 4: diffs |= (*(u32 *)(a -= sizeof(u32))) ^ (*(u32 *)(b -= sizeof(u32)));
  break;
 }
 return diffs;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_metadata_differs(const struct sk_buff *skb_a,
     const struct sk_buff *skb_b)
{
 u8 len_a = skb_metadata_len(skb_a);
 u8 len_b = skb_metadata_len(skb_b);

 if (!(len_a | len_b))
  return false;

 return len_a != len_b ?
        true : __skb_metadata_differs(skb_a, skb_b, len_a);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_metadata_set(struct sk_buff *skb, u8 meta_len)
{
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->meta_len = meta_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_metadata_clear(struct sk_buff *skb)
{
 skb_metadata_set(skb, 0);
}

struct sk_buff *skb_clone_sk(struct sk_buff *skb);
# 3798 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_clone_tx_timestamp(struct sk_buff *skb)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_defer_rx_timestamp(struct sk_buff *skb)
{
 return false;
}
# 3821 "/home/nathan/src/linux-next/include/linux/skbuff.h"
void skb_complete_tx_timestamp(struct sk_buff *skb,
          struct skb_shared_hwtstamps *hwtstamps);

void __skb_tstamp_tx(struct sk_buff *orig_skb,
       struct skb_shared_hwtstamps *hwtstamps,
       struct sock *sk, int tstype);
# 3839 "/home/nathan/src/linux-next/include/linux/skbuff.h"
void skb_tstamp_tx(struct sk_buff *orig_skb,
     struct skb_shared_hwtstamps *hwtstamps);
# 3854 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_tx_timestamp(struct sk_buff *skb)
{
 skb_clone_tx_timestamp(skb);
 if (((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags & SKBTX_SW_TSTAMP)
  skb_tstamp_tx(skb, ((void *)0));
}
# 3868 "/home/nathan/src/linux-next/include/linux/skbuff.h"
void skb_complete_wifi_ack(struct sk_buff *skb, bool acked);

__sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len);
__sum16 __skb_checksum_complete(struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_csum_unnecessary(const struct sk_buff *skb)
{
 return ((skb->ip_summed == 1) ||
  skb->csum_valid ||
  (skb->ip_summed == 3 &&
   skb_checksum_start_offset(skb) >= 0));
}
# 3897 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 skb_checksum_complete(struct sk_buff *skb)
{
 return skb_csum_unnecessary(skb) ?
        0 : __skb_checksum_complete(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_decr_checksum_unnecessary(struct sk_buff *skb)
{
 if (skb->ip_summed == 1) {
  if (skb->csum_level == 0)
   skb->ip_summed = 0;
  else
   skb->csum_level--;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_incr_checksum_unnecessary(struct sk_buff *skb)
{
 if (skb->ip_summed == 1) {
  if (skb->csum_level < 3)
   skb->csum_level++;
 } else if (skb->ip_summed == 0) {
  skb->ip_summed = 1;
  skb->csum_level = 0;
 }
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_checksum_validate_needed(struct sk_buff *skb,
        bool zero_okay,
        __sum16 check)
{
 if (skb_csum_unnecessary(skb) || (zero_okay && !check)) {
  skb->csum_valid = 1;
  __skb_decr_checksum_unnecessary(skb);
  return false;
 }

 return true;
}
# 3953 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_checksum_complete_unset(struct sk_buff *skb)
{
 if (skb->ip_summed == 2)
  skb->ip_summed = 0;
}
# 3968 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 __skb_checksum_validate_complete(struct sk_buff *skb,
             bool complete,
             __wsum psum)
{
 if (skb->ip_summed == 2) {
  if (!csum_fold(csum_add(psum, skb->csum))) {
   skb->csum_valid = 1;
   return 0;
  }
 }

 skb->csum = psum;

 if (complete || skb->len <= 76) {
  __sum16 csum;

  csum = __skb_checksum_complete(skb);
  skb->csum_valid = !csum;
  return csum;
 }

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum null_compute_pseudo(struct sk_buff *skb, int proto)
{
 return 0;
}
# 4034 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_checksum_convert_check(struct sk_buff *skb)
{
 return (skb->ip_summed == 0 && skb->csum_valid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_checksum_convert(struct sk_buff *skb, __wsum pseudo)
{
 skb->csum = ~pseudo;
 skb->ip_summed = 2;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_remcsum_adjust_partial(struct sk_buff *skb, void *ptr,
           u16 start, u16 offset)
{
 skb->ip_summed = 3;
 skb->csum_start = ((unsigned char *)ptr + start) - skb->head;
 skb->csum_offset = offset - start;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_remcsum_process(struct sk_buff *skb, void *ptr,
           int start, int offset, bool nopartial)
{
 __wsum delta;

 if (!nopartial) {
  skb_remcsum_adjust_partial(skb, ptr, start, offset);
  return;
 }

  if (__builtin_expect(!!(skb->ip_summed != 2), 0)) {
  __skb_checksum_complete(skb);
  skb_postpull_rcsum(skb, skb->data, ptr - (void *)skb->data);
 }

 delta = remcsum_adjust(ptr, skb->csum, start, offset);


 skb->csum = csum_add(skb->csum, delta);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nf_conntrack *skb_nfct(const struct sk_buff *skb)
{

 return (void *)(skb->_nfct & ~(7UL));



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long skb_get_nfct(const struct sk_buff *skb)
{

 return skb->_nfct;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_nfct(struct sk_buff *skb, unsigned long nfct)
{

 skb->_nfct = nfct;

}


enum skb_ext_id {




 SKB_EXT_SEC_PATH,







 SKB_EXT_NUM,
};
# 4137 "/home/nathan/src/linux-next/include/linux/skbuff.h"
struct skb_ext {
 refcount_t refcnt;
 u8 offset[SKB_EXT_NUM];
 u8 chunks;
 char data[0] __attribute__((__aligned__(8)));
};

struct skb_ext *__skb_ext_alloc(void);
void *__skb_ext_set(struct sk_buff *skb, enum skb_ext_id id,
      struct skb_ext *ext);
void *skb_ext_add(struct sk_buff *skb, enum skb_ext_id id);
void __skb_ext_del(struct sk_buff *skb, enum skb_ext_id id);
void __skb_ext_put(struct skb_ext *ext);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_ext_put(struct sk_buff *skb)
{
 if (skb->active_extensions)
  __skb_ext_put(skb->extensions);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_ext_copy(struct sk_buff *dst,
      const struct sk_buff *src)
{
 dst->active_extensions = src->active_extensions;

 if (src->active_extensions) {
  struct skb_ext *ext = src->extensions;

  refcount_inc(&ext->refcnt);
  dst->extensions = ext;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_ext_copy(struct sk_buff *dst, const struct sk_buff *src)
{
 skb_ext_put(dst);
 __skb_ext_copy(dst, src);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_ext_exist(const struct skb_ext *ext, enum skb_ext_id i)
{
 return !!ext->offset[i];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_ext_exist(const struct sk_buff *skb, enum skb_ext_id id)
{
 return skb->active_extensions & (1 << id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_ext_del(struct sk_buff *skb, enum skb_ext_id id)
{
 if (skb_ext_exist(skb, id))
  __skb_ext_del(skb, id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_ext_find(const struct sk_buff *skb, enum skb_ext_id id)
{
 if (skb_ext_exist(skb, id)) {
  struct skb_ext *ext = skb->extensions;

  return (void *)ext + (ext->offset[id] << 3);
 }

 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_ext_reset(struct sk_buff *skb)
{
 if (__builtin_expect(!!(skb->active_extensions), 0)) {
  __skb_ext_put(skb->extensions);
  skb->active_extensions = 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_has_extensions(struct sk_buff *skb)
{
 return __builtin_expect(!!(skb->active_extensions), 0);
}
# 4224 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nf_reset_ct(struct sk_buff *skb)
{

 nf_conntrack_put(skb_nfct(skb));
 skb->_nfct = 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nf_reset_trace(struct sk_buff *skb)
{



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipvs_reset(struct sk_buff *skb)
{



}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __nf_copy(struct sk_buff *dst, const struct sk_buff *src,
        bool copy)
{

 dst->_nfct = src->_nfct;
 nf_conntrack_get(skb_nfct(src));





}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nf_copy(struct sk_buff *dst, const struct sk_buff *src)
{

 nf_conntrack_put(skb_nfct(dst));

 __nf_copy(dst, src, true);
}
# 4279 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_secmark(struct sk_buff *to, const struct sk_buff *from)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_init_secmark(struct sk_buff *skb)
{ }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int secpath_exists(const struct sk_buff *skb)
{

 return skb_ext_exist(skb, SKB_EXT_SEC_PATH);



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_irq_freeable(const struct sk_buff *skb)
{
 return !skb->destructor &&
  !secpath_exists(skb) &&
  !skb_nfct(skb) &&
  !skb->_skb_refdst &&
  !skb_has_frag_list(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)
{
 skb->queue_mapping = queue_mapping;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 skb_get_queue_mapping(const struct sk_buff *skb)
{
 return skb->queue_mapping;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_copy_queue_mapping(struct sk_buff *to, const struct sk_buff *from)
{
 to->queue_mapping = from->queue_mapping;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
 skb->queue_mapping = rx_queue + 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 skb_get_rx_queue(const struct sk_buff *skb)
{
 return skb->queue_mapping - 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_rx_queue_recorded(const struct sk_buff *skb)
{
 return skb->queue_mapping != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_dst_pending_confirm(struct sk_buff *skb, u32 val)
{
 skb->dst_pending_confirm = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_get_dst_pending_confirm(const struct sk_buff *skb)
{
 return skb->dst_pending_confirm != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sec_path *skb_sec_path(const struct sk_buff *skb)
{

 return skb_ext_find(skb, SKB_EXT_SEC_PATH);



}







struct skb_gso_cb {
 union {
  int mac_offset;
  int data_offset;
 };
 int encap_level;
 __wsum csum;
 __u16 csum_start;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_tnl_header_len(const struct sk_buff *inner_skb)
{
 return (skb_mac_header(inner_skb) - inner_skb->head) -
  ((struct skb_gso_cb *)((inner_skb)->cb + 32))->mac_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gso_pskb_expand_head(struct sk_buff *skb, int extra)
{
 int new_headroom, headroom;
 int ret;

 headroom = skb_headroom(skb);
 ret = pskb_expand_head(skb, extra, 0, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (ret)
  return ret;

 new_headroom = skb_headroom(skb);
 ((struct skb_gso_cb *)((skb)->cb + 32))->mac_offset += (new_headroom - headroom);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void gso_reset_checksum(struct sk_buff *skb, __wsum res)
{

 if (skb->remcsum_offload)
  return;

 ((struct skb_gso_cb *)((skb)->cb + 32))->csum = res;
 ((struct skb_gso_cb *)((skb)->cb + 32))->csum_start = skb_checksum_start(skb) - skb->head;
}
# 4410 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 gso_make_checksum(struct sk_buff *skb, __wsum res)
{
 unsigned char *csum_start = skb_transport_header(skb);
 int plen = (skb->head + ((struct skb_gso_cb *)((skb)->cb + 32))->csum_start) - csum_start;
 __wsum partial = ((struct skb_gso_cb *)((skb)->cb + 32))->csum;

 ((struct skb_gso_cb *)((skb)->cb + 32))->csum = res;
 ((struct skb_gso_cb *)((skb)->cb + 32))->csum_start = csum_start - skb->head;

 return csum_fold(csum_partial(csum_start, plen, partial));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_gso(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_size;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_gso_v6(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & SKB_GSO_TCPV6;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_gso_sctp(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & SKB_GSO_SCTP;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_gso_tcp(const struct sk_buff *skb)
{
 return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gso_reset(struct sk_buff *skb)
{
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_size = 0;
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs = 0;
 ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_increase_gso_size(struct skb_shared_info *shinfo,
      u16 increment)
{
 if (({ int __ret_warn_on = !!(shinfo->gso_size == 0xFFFF); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (4455), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return;
 shinfo->gso_size += increment;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_decrease_gso_size(struct skb_shared_info *shinfo,
      u16 decrement)
{
 if (({ int __ret_warn_on = !!(shinfo->gso_size == 0xFFFF); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/skbuff.h"), "i" (4463), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return;
 shinfo->gso_size -= decrement;
}

void __skb_warn_lro_forwarding(const struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_warn_if_lro(const struct sk_buff *skb)
{


 const struct skb_shared_info *shinfo = ((struct skb_shared_info *)(skb_end_pointer(skb)));

 if (skb_is_nonlinear(skb) && shinfo->gso_size != 0 &&
     __builtin_expect(!!(shinfo->gso_type == 0), 0)) {
  __skb_warn_lro_forwarding(skb);
  return true;
 }
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_forward_csum(struct sk_buff *skb)
{

 if (skb->ip_summed == 2)
  skb->ip_summed = 0;
}
# 4499 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_checksum_none_assert(const struct sk_buff *skb)
{



}

bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);

int skb_checksum_setup(struct sk_buff *skb, bool recalculate);
struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
         unsigned int transport_len,
         __sum16(*skb_chkf)(struct sk_buff *skb));
# 4522 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_head_is_locked(const struct sk_buff *skb)
{
 return !skb->head_frag || skb_cloned(skb);
}
# 4536 "/home/nathan/src/linux-next/include/linux/skbuff.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum lco_csum(struct sk_buff *skb)
{
 unsigned char *csum_start = skb_checksum_start(skb);
 unsigned char *l4_hdr = skb_transport_header(skb);
 __wsum partial;


 partial = ~csum_unfold(*( __sum16 *)(csum_start +
          skb->csum_offset));




 return csum_partial(l4_hdr, csum_start - l4_hdr, partial);
}
# 20 "/home/nathan/src/linux-next/include/linux/if_ether.h" 2


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ethhdr *eth_hdr(const struct sk_buff *skb)
{
 return (struct ethhdr *)skb_mac_header(skb);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ethhdr *skb_eth_hdr(const struct sk_buff *skb)
{
 return (struct ethhdr *)skb->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ethhdr *inner_eth_hdr(const struct sk_buff *skb)
{
 return (struct ethhdr *)skb_inner_mac_header(skb);
}

int eth_header_parse(const struct sk_buff *skb, unsigned char *haddr);

extern ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len);
# 21 "/home/nathan/src/linux-next/include/linux/etherdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/netdevice.h" 1
# 26 "/home/nathan/src/linux-next/include/linux/netdevice.h"
# 1 "/home/nathan/src/linux-next/include/linux/delay.h" 1
# 24 "/home/nathan/src/linux-next/include/linux/delay.h"
extern unsigned long loops_per_jiffy;
# 49 "/home/nathan/src/linux-next/include/linux/delay.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ndelay(unsigned long x)
{
 udelay((((x) + (1000) - 1) / (1000)));
}



extern unsigned long lpj_fine;
void calibrate_delay(void);
void __attribute__((weak)) calibration_delay_done(void);
void msleep(unsigned int msecs);
unsigned long msleep_interruptible(unsigned int msecs);
void usleep_range(unsigned long min, unsigned long max);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ssleep(unsigned int seconds)
{
 msleep(seconds * 1000);
}
# 27 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/prefetch.h" 1
# 54 "/home/nathan/src/linux-next/include/linux/prefetch.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void prefetch_range(void *addr, size_t len)
{

 char *cp;
 char *end = addr + len;

 for (cp = addr; cp < end; cp += (4*(1 << 7)))
  prefetch(cp);

}
# 29 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2






# 1 "/home/nathan/src/linux-next/include/linux/dynamic_queue_limits.h" 1
# 41 "/home/nathan/src/linux-next/include/linux/dynamic_queue_limits.h"
struct dql {

 unsigned int num_queued;
 unsigned int adj_limit;
 unsigned int last_obj_cnt;



 unsigned int limit __attribute__((__aligned__((1 << 7))));
 unsigned int num_completed;

 unsigned int prev_ovlimit;
 unsigned int prev_num_queued;
 unsigned int prev_last_obj_cnt;

 unsigned int lowest_slack;
 unsigned long slack_start_time;


 unsigned int max_limit;
 unsigned int min_limit;
 unsigned int slack_hold_time;
};
# 73 "/home/nathan/src/linux-next/include/linux/dynamic_queue_limits.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dql_queued(struct dql *dql, unsigned int count)
{
 do { if (__builtin_constant_p(count > ((~0U) / 16))) { if (count > ((~0U) / 16)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dynamic_queue_limits.h"), "i" (75), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/dynamic_queue_limits.h"), "i" (75), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(count > ((~0U) / 16)))); } } while (0);

 dql->last_obj_cnt = count;






 __asm__ __volatile__("" : : : "memory");

 dql->num_queued += count;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dql_avail(const struct dql *dql)
{
 return ({ union { typeof(dql->adj_limit) __val; char __c[1]; } __u; if (1) __read_once_size(&(dql->adj_limit), __u.__c, sizeof(dql->adj_limit)); else __read_once_size_nocheck(&(dql->adj_limit), __u.__c, sizeof(dql->adj_limit)); do { } while (0); __u.__val; }) - ({ union { typeof(dql->num_queued) __val; char __c[1]; } __u; if (1) __read_once_size(&(dql->num_queued), __u.__c, sizeof(dql->num_queued)); else __read_once_size_nocheck(&(dql->num_queued), __u.__c, sizeof(dql->num_queued)); do { } while (0); __u.__val; });
}


void dql_completed(struct dql *dql, unsigned int count);


void dql_reset(struct dql *dql);


void dql_init(struct dql *dql, unsigned int hold_time);
# 36 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/ethtool.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/ethtool.h"
# 1 "/home/nathan/src/linux-next/include/linux/compat.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/compat.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/if.h" 1
# 37 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/hdlc/ioctl.h" 1
# 40 "/home/nathan/src/linux-next/include/uapi/linux/hdlc/ioctl.h"
typedef struct {
 unsigned int clock_rate;
 unsigned int clock_type;
 unsigned short loopback;
} sync_serial_settings;

typedef struct {
 unsigned int clock_rate;
 unsigned int clock_type;
 unsigned short loopback;
 unsigned int slot_map;
} te1_settings;

typedef struct {
 unsigned short encoding;
 unsigned short parity;
} raw_hdlc_proto;

typedef struct {
 unsigned int t391;
 unsigned int t392;
 unsigned int n391;
 unsigned int n392;
 unsigned int n393;
 unsigned short lmi;
 unsigned short dce;
} fr_proto;

typedef struct {
 unsigned int dlci;
} fr_proto_pvc;

typedef struct {
 unsigned int dlci;
 char master[16];
}fr_proto_pvc_info;

typedef struct {
    unsigned int interval;
    unsigned int timeout;
} cisco_proto;

typedef struct {
 unsigned short dce;
 unsigned int modulo;
 unsigned int window;
 unsigned int t1;
 unsigned int t2;
 unsigned int n2;
} x25_hdlc_proto;
# 38 "/home/nathan/src/linux-next/include/uapi/linux/if.h" 2
# 82 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
enum net_device_flags {


 IFF_UP = 1<<0,
 IFF_BROADCAST = 1<<1,
 IFF_DEBUG = 1<<2,
 IFF_LOOPBACK = 1<<3,
 IFF_POINTOPOINT = 1<<4,
 IFF_NOTRAILERS = 1<<5,
 IFF_RUNNING = 1<<6,
 IFF_NOARP = 1<<7,
 IFF_PROMISC = 1<<8,
 IFF_ALLMULTI = 1<<9,
 IFF_MASTER = 1<<10,
 IFF_SLAVE = 1<<11,
 IFF_MULTICAST = 1<<12,
 IFF_PORTSEL = 1<<13,
 IFF_AUTOMEDIA = 1<<14,
 IFF_DYNAMIC = 1<<15,


 IFF_LOWER_UP = 1<<16,
 IFF_DORMANT = 1<<17,
 IFF_ECHO = 1<<18,

};
# 167 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
enum {
 IF_OPER_UNKNOWN,
 IF_OPER_NOTPRESENT,
 IF_OPER_DOWN,
 IF_OPER_LOWERLAYERDOWN,
 IF_OPER_TESTING,
 IF_OPER_DORMANT,
 IF_OPER_UP,
};


enum {
 IF_LINK_MODE_DEFAULT,
 IF_LINK_MODE_DORMANT,
};
# 195 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
struct ifmap {
 unsigned long mem_start;
 unsigned long mem_end;
 unsigned short base_addr;
 unsigned char irq;
 unsigned char dma;
 unsigned char port;

};


struct if_settings {
 unsigned int type;
 unsigned int size;
 union {

  raw_hdlc_proto *raw_hdlc;
  cisco_proto *cisco;
  fr_proto *fr;
  fr_proto_pvc *fr_pvc;
  fr_proto_pvc_info *fr_pvc_info;
  x25_hdlc_proto *x25;


  sync_serial_settings *sync;
  te1_settings *te1;
 } ifs_ifsu;
};
# 233 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
struct ifreq {

 union
 {
  char ifrn_name[16];
 } ifr_ifrn;

 union {
  struct sockaddr ifru_addr;
  struct sockaddr ifru_dstaddr;
  struct sockaddr ifru_broadaddr;
  struct sockaddr ifru_netmask;
  struct sockaddr ifru_hwaddr;
  short ifru_flags;
  int ifru_ivalue;
  int ifru_mtu;
  struct ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  void * ifru_data;
  struct if_settings ifru_settings;
 } ifr_ifru;
};
# 285 "/home/nathan/src/linux-next/include/uapi/linux/if.h"
struct ifconf {
 int ifc_len;
 union {
  char *ifcu_buf;
  struct ifreq *ifcu_req;
 } ifc_ifcu;
};
# 17 "/home/nathan/src/linux-next/include/linux/compat.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/aio_abi.h" 1
# 34 "/home/nathan/src/linux-next/include/uapi/linux/aio_abi.h"
typedef __kernel_ulong_t aio_context_t;

enum {
 IOCB_CMD_PREAD = 0,
 IOCB_CMD_PWRITE = 1,
 IOCB_CMD_FSYNC = 2,
 IOCB_CMD_FDSYNC = 3,

 IOCB_CMD_POLL = 5,
 IOCB_CMD_NOOP = 6,
 IOCB_CMD_PREADV = 7,
 IOCB_CMD_PWRITEV = 8,
};
# 60 "/home/nathan/src/linux-next/include/uapi/linux/aio_abi.h"
struct io_event {
 __u64 data;
 __u64 obj;
 __s64 res;
 __s64 res2;
};







struct iocb {

 __u64 aio_data;





 __kernel_rwf_t aio_rw_flags;
 __u32 aio_key;





 __u16 aio_lio_opcode;
 __s16 aio_reqprio;
 __u32 aio_fildes;

 __u64 aio_buf;
 __u64 aio_nbytes;
 __s64 aio_offset;


 __u64 aio_reserved2;


 __u32 aio_flags;





 __u32 aio_resfd;
};
# 19 "/home/nathan/src/linux-next/include/linux/compat.h" 2



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/compat.h" 1
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/compat.h"
# 1 "/home/nathan/src/linux-next/include/asm-generic/compat.h" 1





typedef u32 compat_size_t;
typedef s32 compat_ssize_t;
typedef s32 compat_clock_t;
typedef s32 compat_pid_t;
typedef u32 compat_ino_t;
typedef s32 compat_off_t;
typedef s64 compat_loff_t;
typedef s32 compat_daddr_t;
typedef s32 compat_timer_t;
typedef s32 compat_key_t;
typedef s16 compat_short_t;
typedef s32 compat_int_t;
typedef s32 compat_long_t;
typedef u16 compat_ushort_t;
typedef u32 compat_uint_t;
typedef u32 compat_ulong_t;
typedef u32 compat_uptr_t;
typedef u32 compat_aio_context_t;
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/compat.h" 2








typedef u32 __compat_uid_t;
typedef u32 __compat_gid_t;
typedef u32 __compat_uid32_t;
typedef u32 __compat_gid32_t;
typedef u32 compat_mode_t;
typedef u32 compat_dev_t;
typedef s16 compat_nlink_t;
typedef u16 compat_ipc_pid_t;
typedef u32 compat_caddr_t;
typedef __kernel_fsid_t compat_fsid_t;
typedef s64 compat_s64;
typedef u64 compat_u64;

struct compat_stat {
 compat_dev_t st_dev;
 compat_ino_t st_ino;
 compat_mode_t st_mode;
 compat_nlink_t st_nlink;
 __compat_uid32_t st_uid;
 __compat_gid32_t st_gid;
 compat_dev_t st_rdev;
 compat_off_t st_size;
 compat_off_t st_blksize;
 compat_off_t st_blocks;
 old_time32_t st_atime;
 u32 st_atime_nsec;
 old_time32_t st_mtime;
 u32 st_mtime_nsec;
 old_time32_t st_ctime;
 u32 st_ctime_nsec;
 u32 __unused4[2];
};

struct compat_flock {
 short l_type;
 short l_whence;
 compat_off_t l_start;
 compat_off_t l_len;
 compat_pid_t l_pid;
};





struct compat_flock64 {
 short l_type;
 short l_whence;
 compat_loff_t l_start;
 compat_loff_t l_len;
 compat_pid_t l_pid;
};

struct compat_statfs {
 int f_type;
 int f_bsize;
 int f_blocks;
 int f_bfree;
 int f_bavail;
 int f_files;
 int f_ffree;
 compat_fsid_t f_fsid;
 int f_namelen;
 int f_frsize;
 int f_flags;
 int f_spare[4];
};



typedef u32 compat_old_sigset_t;




typedef u32 compat_sigset_word;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *arch_compat_alloc_user_space(long len)
{
 struct pt_regs *regs = get_current()->thread.regs;
 unsigned long usp = regs->gpr[1];






 if (!(test_ti_thread_flag(((struct thread_info *)get_current()), 20)))
  usp -= 512;

 return (void *) (usp - len);
}





struct compat_ipc64_perm {
 compat_key_t key;
 __compat_uid_t uid;
 __compat_gid_t gid;
 __compat_uid_t cuid;
 __compat_gid_t cgid;
 compat_mode_t mode;
 unsigned int seq;
 unsigned int __pad2;
 unsigned long __unused1;
 unsigned long __unused2;
};

struct compat_semid64_ds {
 struct compat_ipc64_perm sem_perm;
 unsigned int sem_otime_high;
 unsigned int sem_otime;
 unsigned int sem_ctime_high;
 unsigned int sem_ctime;
 compat_ulong_t sem_nsems;
 compat_ulong_t __unused3;
 compat_ulong_t __unused4;
};

struct compat_msqid64_ds {
 struct compat_ipc64_perm msg_perm;
 unsigned int msg_stime_high;
 unsigned int msg_stime;
 unsigned int msg_rtime_high;
 unsigned int msg_rtime;
 unsigned int msg_ctime_high;
 unsigned int msg_ctime;
 compat_ulong_t msg_cbytes;
 compat_ulong_t msg_qnum;
 compat_ulong_t msg_qbytes;
 compat_pid_t msg_lspid;
 compat_pid_t msg_lrpid;
 compat_ulong_t __unused4;
 compat_ulong_t __unused5;
};

struct compat_shmid64_ds {
 struct compat_ipc64_perm shm_perm;
 unsigned int shm_atime_high;
 unsigned int shm_atime;
 unsigned int shm_dtime_high;
 unsigned int shm_dtime;
 unsigned int shm_ctime_high;
 unsigned int shm_ctime;
 unsigned int __unused4;
 compat_size_t shm_segsz;
 compat_pid_t shm_cpid;
 compat_pid_t shm_lpid;
 compat_ulong_t shm_nattch;
 compat_ulong_t __unused5;
 compat_ulong_t __unused6;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_compat_task(void)
{
 return (test_ti_thread_flag(((struct thread_info *)get_current()), 20));
}
# 23 "/home/nathan/src/linux-next/include/linux/compat.h" 2


# 1 "./arch/powerpc/include/generated/uapi/asm/siginfo.h" 1
# 26 "/home/nathan/src/linux-next/include/linux/compat.h" 2
# 100 "/home/nathan/src/linux-next/include/linux/compat.h"
typedef struct compat_sigaltstack {
 compat_uptr_t ss_sp;
 int ss_flags;
 compat_size_t ss_size;
} compat_stack_t;
# 113 "/home/nathan/src/linux-next/include/linux/compat.h"
typedef __compat_uid32_t compat_uid_t;
typedef __compat_gid32_t compat_gid_t;

struct compat_sel_arg_struct;
struct rusage;

struct old_itimerval32;

struct compat_tms {
 compat_clock_t tms_utime;
 compat_clock_t tms_stime;
 compat_clock_t tms_cutime;
 compat_clock_t tms_cstime;
};



typedef struct {
 compat_sigset_word sig[(64 / 32)];
} compat_sigset_t;

int set_compat_user_sigmask(const compat_sigset_t *umask,
       size_t sigsetsize);

struct compat_sigaction {

 compat_uptr_t sa_handler;
 compat_ulong_t sa_flags;





 compat_uptr_t sa_restorer;

 compat_sigset_t sa_mask __attribute__((__packed__));
};

typedef union compat_sigval {
 compat_int_t sival_int;
 compat_uptr_t sival_ptr;
} compat_sigval_t;

typedef struct compat_siginfo {
 int si_signo;

 int si_errno;
 int si_code;





 union {
  int _pad[128/sizeof(int) - 3];


  struct {
   compat_pid_t _pid;
   __compat_uid32_t _uid;
  } _kill;


  struct {
   compat_timer_t _tid;
   int _overrun;
   compat_sigval_t _sigval;
  } _timer;


  struct {
   compat_pid_t _pid;
   __compat_uid32_t _uid;
   compat_sigval_t _sigval;
  } _rt;


  struct {
   compat_pid_t _pid;
   __compat_uid32_t _uid;
   int _status;
   compat_clock_t _utime;
   compat_clock_t _stime;
  } _sigchld;
# 210 "/home/nathan/src/linux-next/include/linux/compat.h"
  struct {
   compat_uptr_t _addr;





   union {




    short int _addr_lsb;

    struct {
     char _dummy_bnd[(__alignof__(compat_uptr_t) < sizeof(short) ? sizeof(short) : __alignof__(compat_uptr_t))];
     compat_uptr_t _lower;
     compat_uptr_t _upper;
    } _addr_bnd;

    struct {
     char _dummy_pkey[(__alignof__(compat_uptr_t) < sizeof(short) ? sizeof(short) : __alignof__(compat_uptr_t))];
     u32 _pkey;
    } _addr_pkey;
   };
  } _sigfault;


  struct {
   compat_long_t _band;
   int _fd;
  } _sigpoll;

  struct {
   compat_uptr_t _call_addr;
   int _syscall;
   unsigned int _arch;
  } _sigsys;
 } _sifields;
} compat_siginfo_t;





extern int compat_get_timespec(struct timespec *, const void *);
extern int compat_put_timespec(const struct timespec *, void *);
extern int compat_get_timeval(struct timeval *, const void *);
extern int compat_put_timeval(const struct timeval *, void *);

struct compat_iovec {
 compat_uptr_t iov_base;
 compat_size_t iov_len;
};

struct compat_rlimit {
 compat_ulong_t rlim_cur;
 compat_ulong_t rlim_max;
};

struct compat_rusage {
 struct old_timeval32 ru_utime;
 struct old_timeval32 ru_stime;
 compat_long_t ru_maxrss;
 compat_long_t ru_ixrss;
 compat_long_t ru_idrss;
 compat_long_t ru_isrss;
 compat_long_t ru_minflt;
 compat_long_t ru_majflt;
 compat_long_t ru_nswap;
 compat_long_t ru_inblock;
 compat_long_t ru_oublock;
 compat_long_t ru_msgsnd;
 compat_long_t ru_msgrcv;
 compat_long_t ru_nsignals;
 compat_long_t ru_nvcsw;
 compat_long_t ru_nivcsw;
};

extern int put_compat_rusage(const struct rusage *,
        struct compat_rusage *);

struct compat_siginfo;
struct __compat_aio_sigset;

struct compat_dirent {
 u32 d_ino;
 compat_off_t d_off;
 u16 d_reclen;
 char d_name[256];
};

struct compat_ustat {
 compat_daddr_t f_tfree;
 compat_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];
};



typedef struct compat_sigevent {
 compat_sigval_t sigev_value;
 compat_int_t sigev_signo;
 compat_int_t sigev_notify;
 union {
  compat_int_t _pad[((64/sizeof(int)) - 3)];
  compat_int_t _tid;

  struct {
   compat_uptr_t _function;
   compat_uptr_t _attribute;
  } _sigev_thread;
 } _sigev_un;
} compat_sigevent_t;

struct compat_ifmap {
 compat_ulong_t mem_start;
 compat_ulong_t mem_end;
 unsigned short base_addr;
 unsigned char irq;
 unsigned char dma;
 unsigned char port;
};

struct compat_if_settings {
 unsigned int type;
 unsigned int size;
 compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
 union {
  char ifrn_name[16];
 } ifr_ifrn;
 union {
  struct sockaddr ifru_addr;
  struct sockaddr ifru_dstaddr;
  struct sockaddr ifru_broadaddr;
  struct sockaddr ifru_netmask;
  struct sockaddr ifru_hwaddr;
  short ifru_flags;
  compat_int_t ifru_ivalue;
  compat_int_t ifru_mtu;
  struct compat_ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  compat_caddr_t ifru_data;
  struct compat_if_settings ifru_settings;
 } ifr_ifru;
};

struct compat_ifconf {
 compat_int_t ifc_len;
 compat_caddr_t ifcbuf;
};

struct compat_robust_list {
 compat_uptr_t next;
};

struct compat_robust_list_head {
 struct compat_robust_list list;
 compat_long_t futex_offset;
 compat_uptr_t list_op_pending;
};


struct compat_old_sigaction {
 compat_uptr_t sa_handler;
 compat_old_sigset_t sa_mask;
 compat_ulong_t sa_flags;
 compat_uptr_t sa_restorer;
};


struct compat_keyctl_kdf_params {
 compat_uptr_t hashname;
 compat_uptr_t otherinfo;
 __u32 otherinfolen;
 __u32 __spare[8];
};

struct compat_statfs;
struct compat_statfs64;
struct compat_old_linux_dirent;
struct compat_linux_dirent;
struct linux_dirent64;
struct compat_msghdr;
struct compat_mmsghdr;
struct compat_sysinfo;
struct compat_sysctl_args;
struct compat_kexec_segment;
struct compat_mq_attr;
struct compat_msgbuf;





long compat_get_bitmap(unsigned long *mask, const compat_ulong_t *umask,
         unsigned long bitmap_size);
long compat_put_bitmap(compat_ulong_t *umask, unsigned long *mask,
         unsigned long bitmap_size);
int copy_siginfo_from_user32(kernel_siginfo_t *to, const struct compat_siginfo *from);
int copy_siginfo_to_user32(struct compat_siginfo *to, const kernel_siginfo_t *from);
int get_compat_sigevent(struct sigevent *event,
  const struct compat_sigevent *u_event);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int old_timeval32_compare(struct old_timeval32 *lhs,
     struct old_timeval32 *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_usec - rhs->tv_usec;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int old_timespec32_compare(struct old_timespec32 *lhs,
     struct old_timespec32 *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_nsec - rhs->tv_nsec;
}

extern int get_compat_sigset(sigset_t *set, const compat_sigset_t *compat);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
put_compat_sigset(compat_sigset_t *compat, const sigset_t *set,
    unsigned int size)
{


 compat_sigset_t v;
 switch ((64 / 64)) {
 case 4: v.sig[7] = (set->sig[3] >> 32); v.sig[6] = set->sig[3];

 case 3: v.sig[5] = (set->sig[2] >> 32); v.sig[4] = set->sig[2];

 case 2: v.sig[3] = (set->sig[1] >> 32); v.sig[2] = set->sig[1];

 case 1: v.sig[1] = (set->sig[0] >> 32); v.sig[0] = set->sig[0];
 }
 return copy_to_user(compat, &v, size) ? -14 : 0;



}

extern int compat_ptrace_request(struct task_struct *child,
     compat_long_t request,
     compat_ulong_t addr, compat_ulong_t data);

extern long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
          compat_ulong_t addr, compat_ulong_t data);

struct epoll_event;

extern ssize_t compat_rw_copy_check_uvector(int type,
  const struct compat_iovec *uvector,
  unsigned long nr_segs,
  unsigned long fast_segs, struct iovec *fast_pointer,
  struct iovec **ret_pointer);

extern void *compat_alloc_user_space(unsigned long len);

int compat_restore_altstack(const compat_stack_t *uss);
int __compat_save_altstack(compat_stack_t *, unsigned long);
# 510 "/home/nathan/src/linux-next/include/linux/compat.h"
           long compat_sys_io_setup(unsigned nr_reqs, u32 *ctx32p);
           long compat_sys_io_submit(compat_aio_context_t ctx_id, int nr,
         u32 *iocb);
           long compat_sys_io_pgetevents(compat_aio_context_t ctx_id,
     compat_long_t min_nr,
     compat_long_t nr,
     struct io_event *events,
     struct old_timespec32 *timeout,
     const struct __compat_aio_sigset *usig);
           long compat_sys_io_pgetevents_time64(compat_aio_context_t ctx_id,
     compat_long_t min_nr,
     compat_long_t nr,
     struct io_event *events,
     struct __kernel_timespec *timeout,
     const struct __compat_aio_sigset *usig);


           long compat_sys_lookup_dcookie(u32, u32, char *, compat_size_t);


           long compat_sys_epoll_pwait(int epfd,
   struct epoll_event *events,
   int maxevents, int timeout,
   const compat_sigset_t *sigmask,
   compat_size_t sigsetsize);


           long compat_sys_fcntl(unsigned int fd, unsigned int cmd,
     compat_ulong_t arg);
           long compat_sys_fcntl64(unsigned int fd, unsigned int cmd,
       compat_ulong_t arg);


           long compat_sys_ioctl(unsigned int fd, unsigned int cmd,
     compat_ulong_t arg);


           long compat_sys_mount(const char *dev_name,
     const char *dir_name,
     const char *type, compat_ulong_t flags,
     const void *data);


           long compat_sys_statfs(const char *pathname,
      struct compat_statfs *buf);
           long compat_sys_statfs64(const char *pathname,
        compat_size_t sz,
        struct compat_statfs64 *buf);
           long compat_sys_fstatfs(unsigned int fd,
       struct compat_statfs *buf);
           long compat_sys_fstatfs64(unsigned int fd, compat_size_t sz,
         struct compat_statfs64 *buf);
           long compat_sys_truncate(const char *, compat_off_t);
           long compat_sys_ftruncate(unsigned int, compat_ulong_t);

           long compat_sys_openat(int dfd, const char *filename,
      int flags, umode_t mode);


           long compat_sys_getdents(unsigned int fd,
        struct compat_linux_dirent *dirent,
        unsigned int count);


           long compat_sys_lseek(unsigned int, compat_off_t, unsigned int);
           ssize_t compat_sys_readv(compat_ulong_t fd,
  const struct compat_iovec *vec, compat_ulong_t vlen);
           ssize_t compat_sys_writev(compat_ulong_t fd,
  const struct compat_iovec *vec, compat_ulong_t vlen);

           ssize_t compat_sys_preadv(compat_ulong_t fd,
  const struct compat_iovec *vec,
  compat_ulong_t vlen, u32 pos_low, u32 pos_high);
           ssize_t compat_sys_pwritev(compat_ulong_t fd,
  const struct compat_iovec *vec,
  compat_ulong_t vlen, u32 pos_low, u32 pos_high);
# 599 "/home/nathan/src/linux-next/include/linux/compat.h"
           long compat_sys_sendfile(int out_fd, int in_fd,
        compat_off_t *offset, compat_size_t count);
           long compat_sys_sendfile64(int out_fd, int in_fd,
        compat_loff_t *offset, compat_size_t count);


           long compat_sys_pselect6_time32(int n, compat_ulong_t *inp,
        compat_ulong_t *outp,
        compat_ulong_t *exp,
        struct old_timespec32 *tsp,
        void *sig);
           long compat_sys_pselect6_time64(int n, compat_ulong_t *inp,
        compat_ulong_t *outp,
        compat_ulong_t *exp,
        struct __kernel_timespec *tsp,
        void *sig);
           long compat_sys_ppoll_time32(struct pollfd *ufds,
     unsigned int nfds,
     struct old_timespec32 *tsp,
     const compat_sigset_t *sigmask,
     compat_size_t sigsetsize);
           long compat_sys_ppoll_time64(struct pollfd *ufds,
     unsigned int nfds,
     struct __kernel_timespec *tsp,
     const compat_sigset_t *sigmask,
     compat_size_t sigsetsize);


           long compat_sys_signalfd4(int ufd,
         const compat_sigset_t *sigmask,
         compat_size_t sigsetsize, int flags);


           long compat_sys_vmsplice(int fd, const struct compat_iovec *,
        unsigned int nr_segs, unsigned int flags);


           long compat_sys_newfstatat(unsigned int dfd,
          const char *filename,
          struct compat_stat *statbuf,
          int flag);
           long compat_sys_newfstat(unsigned int fd,
        struct compat_stat *statbuf);




           long compat_sys_waitid(int, compat_pid_t,
  struct compat_siginfo *, int,
  struct compat_rusage *);




           long
compat_sys_set_robust_list(struct compat_robust_list_head *head,
      compat_size_t len);
           long
compat_sys_get_robust_list(int pid, compat_uptr_t *head_ptr,
      compat_size_t *len_ptr);


           long compat_sys_getitimer(int which,
         struct old_itimerval32 *it);
           long compat_sys_setitimer(int which,
         struct old_itimerval32 *in,
         struct old_itimerval32 *out);


           long compat_sys_kexec_load(compat_ulong_t entry,
          compat_ulong_t nr_segments,
          struct compat_kexec_segment *,
          compat_ulong_t flags);


           long compat_sys_timer_create(clockid_t which_clock,
   struct compat_sigevent *timer_event_spec,
   timer_t *created_timer_id);


           long compat_sys_ptrace(compat_long_t request, compat_long_t pid,
      compat_long_t addr, compat_long_t data);


           long compat_sys_sched_setaffinity(compat_pid_t pid,
         unsigned int len,
         compat_ulong_t *user_mask_ptr);
           long compat_sys_sched_getaffinity(compat_pid_t pid,
         unsigned int len,
         compat_ulong_t *user_mask_ptr);


           long compat_sys_sigaltstack(const compat_stack_t *uss_ptr,
           compat_stack_t *uoss_ptr);
           long compat_sys_rt_sigsuspend(compat_sigset_t *unewset,
      compat_size_t sigsetsize);

           long compat_sys_rt_sigaction(int,
     const struct compat_sigaction *,
     struct compat_sigaction *,
     compat_size_t);

           long compat_sys_rt_sigprocmask(int how, compat_sigset_t *set,
       compat_sigset_t *oset,
       compat_size_t sigsetsize);
           long compat_sys_rt_sigpending(compat_sigset_t *uset,
      compat_size_t sigsetsize);
           long compat_sys_rt_sigtimedwait_time32(compat_sigset_t *uthese,
  struct compat_siginfo *uinfo,
  struct old_timespec32 *uts, compat_size_t sigsetsize);
           long compat_sys_rt_sigtimedwait_time64(compat_sigset_t *uthese,
  struct compat_siginfo *uinfo,
  struct __kernel_timespec *uts, compat_size_t sigsetsize);
           long compat_sys_rt_sigqueueinfo(compat_pid_t pid, int sig,
    struct compat_siginfo *uinfo);



           long compat_sys_times(struct compat_tms *tbuf);
           long compat_sys_getrlimit(unsigned int resource,
         struct compat_rlimit *rlim);
           long compat_sys_setrlimit(unsigned int resource,
         struct compat_rlimit *rlim);
           long compat_sys_getrusage(int who, struct compat_rusage *ru);


           long compat_sys_gettimeofday(struct old_timeval32 *tv,
  struct timezone *tz);
           long compat_sys_settimeofday(struct old_timeval32 *tv,
  struct timezone *tz);


           long compat_sys_sysinfo(struct compat_sysinfo *info);


           long compat_sys_mq_open(const char *u_name,
   int oflag, compat_mode_t mode,
   struct compat_mq_attr *u_attr);
           long compat_sys_mq_notify(mqd_t mqdes,
   const struct compat_sigevent *u_notification);
           long compat_sys_mq_getsetattr(mqd_t mqdes,
   const struct compat_mq_attr *u_mqstat,
   struct compat_mq_attr *u_omqstat);


           long compat_sys_msgctl(int first, int second, void *uptr);
           long compat_sys_msgrcv(int msqid, compat_uptr_t msgp,
  compat_ssize_t msgsz, compat_long_t msgtyp, int msgflg);
           long compat_sys_msgsnd(int msqid, compat_uptr_t msgp,
  compat_ssize_t msgsz, int msgflg);


           long compat_sys_semctl(int semid, int semnum, int cmd, int arg);


           long compat_sys_shmctl(int first, int second, void *uptr);
           long compat_sys_shmat(int shmid, compat_uptr_t shmaddr, int shmflg);


           long compat_sys_recvfrom(int fd, void *buf, compat_size_t len,
       unsigned flags, struct sockaddr *addr,
       int *addrlen);
           long compat_sys_setsockopt(int fd, int level, int optname,
          char *optval, unsigned int optlen);
           long compat_sys_getsockopt(int fd, int level, int optname,
          char *optval, int *optlen);
           long compat_sys_sendmsg(int fd, struct compat_msghdr *msg,
       unsigned flags);
           long compat_sys_recvmsg(int fd, struct compat_msghdr *msg,
       unsigned int flags);




           long compat_sys_keyctl(u32 option,
         u32 arg2, u32 arg3, u32 arg4, u32 arg5);


           long compat_sys_execve(const char *filename, const compat_uptr_t *argv,
       const compat_uptr_t *envp);




           long compat_sys_mbind(compat_ulong_t start, compat_ulong_t len,
     compat_ulong_t mode,
     compat_ulong_t *nmask,
     compat_ulong_t maxnode, compat_ulong_t flags);
           long compat_sys_get_mempolicy(int *policy,
      compat_ulong_t *nmask,
      compat_ulong_t maxnode,
      compat_ulong_t addr,
      compat_ulong_t flags);
           long compat_sys_set_mempolicy(int mode, compat_ulong_t *nmask,
      compat_ulong_t maxnode);
           long compat_sys_migrate_pages(compat_pid_t pid,
  compat_ulong_t maxnode, const compat_ulong_t *old_nodes,
  const compat_ulong_t *new_nodes);
           long compat_sys_move_pages(pid_t pid, compat_ulong_t nr_pages,
          __u32 *pages,
          const int *nodes,
          int *status,
          int flags);

           long compat_sys_rt_tgsigqueueinfo(compat_pid_t tgid,
     compat_pid_t pid, int sig,
     struct compat_siginfo *uinfo);
           long compat_sys_recvmmsg_time64(int fd, struct compat_mmsghdr *mmsg,
        unsigned vlen, unsigned int flags,
        struct __kernel_timespec *timeout);
           long compat_sys_recvmmsg_time32(int fd, struct compat_mmsghdr *mmsg,
        unsigned vlen, unsigned int flags,
        struct old_timespec32 *timeout);
           long compat_sys_wait4(compat_pid_t pid,
     compat_uint_t *stat_addr, int options,
     struct compat_rusage *ru);
           long compat_sys_fanotify_mark(int, unsigned int, __u32, __u32,
         int, const char *);
           long compat_sys_open_by_handle_at(int mountdirfd,
          struct file_handle *handle,
          int flags);
           long compat_sys_sendmmsg(int fd, struct compat_mmsghdr *mmsg,
        unsigned vlen, unsigned int flags);
           ssize_t compat_sys_process_vm_readv(compat_pid_t pid,
  const struct compat_iovec *lvec,
  compat_ulong_t liovcnt, const struct compat_iovec *rvec,
  compat_ulong_t riovcnt, compat_ulong_t flags);
           ssize_t compat_sys_process_vm_writev(compat_pid_t pid,
  const struct compat_iovec *lvec,
  compat_ulong_t liovcnt, const struct compat_iovec *rvec,
  compat_ulong_t riovcnt, compat_ulong_t flags);
           long compat_sys_execveat(int dfd, const char *filename,
       const compat_uptr_t *argv,
       const compat_uptr_t *envp, int flags);
           ssize_t compat_sys_preadv2(compat_ulong_t fd,
  const struct compat_iovec *vec,
  compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
           ssize_t compat_sys_pwritev2(compat_ulong_t fd,
  const struct compat_iovec *vec,
  compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
# 858 "/home/nathan/src/linux-next/include/linux/compat.h"
           long compat_sys_open(const char *filename, int flags,
    umode_t mode);


           long compat_sys_signalfd(int ufd,
        const compat_sigset_t *sigmask,
        compat_size_t sigsetsize);


           long compat_sys_newstat(const char *filename,
       struct compat_stat *statbuf);
           long compat_sys_newlstat(const char *filename,
        struct compat_stat *statbuf);


           long compat_sys_select(int n, compat_ulong_t *inp,
  compat_ulong_t *outp, compat_ulong_t *exp,
  struct old_timeval32 *tvp);
           long compat_sys_ustat(unsigned dev, struct compat_ustat *u32);
           long compat_sys_recv(int fd, void *buf, compat_size_t len,
    unsigned flags);
           long compat_sys_sysctl(struct compat_sysctl_args *args);


           long compat_sys_old_readdir(unsigned int fd,
           struct compat_old_linux_dirent *,
           unsigned int count);


           long compat_sys_old_select(struct compat_sel_arg_struct *arg);


           long compat_sys_ipc(u32, int, int, u32, compat_uptr_t, u32);



           long compat_sys_sigpending(compat_old_sigset_t *set);



           long compat_sys_sigprocmask(int how, compat_old_sigset_t *nset,
           compat_old_sigset_t *oset);


           long compat_sys_sigaction(int sig,
                                   const struct compat_old_sigaction *act,
                                   struct compat_old_sigaction *oact);



           long compat_sys_socketcall(int call, u32 *args);
# 920 "/home/nathan/src/linux-next/include/linux/compat.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool in_compat_syscall(void) { return is_compat_task(); }
# 929 "/home/nathan/src/linux-next/include/linux/compat.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct old_timeval32 ns_to_old_timeval32(s64 nsec)
{
 struct __kernel_old_timeval tv;
 struct old_timeval32 ctv;

 tv = ns_to_kernel_old_timeval(nsec);
 ctv.tv_sec = tv.tv_sec;
 ctv.tv_usec = tv.tv_usec;

 return ctv;
}







int kcompat_sys_statfs64(const char * pathname, compat_size_t sz,
       struct compat_statfs64 * buf);
int kcompat_sys_fstatfs64(unsigned int fd, compat_size_t sz,
     struct compat_statfs64 * buf);
# 968 "/home/nathan/src/linux-next/include/linux/compat.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *compat_ptr(compat_uptr_t uptr)
{
 return (void *)(unsigned long)uptr;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) compat_uptr_t ptr_to_compat(void *uptr)
{
 return (u32)(unsigned long)uptr;
}
# 18 "/home/nathan/src/linux-next/include/linux/ethtool.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h" 1
# 96 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_cmd {
 __u32 cmd;
 __u32 supported;
 __u32 advertising;
 __u16 speed;
 __u8 duplex;
 __u8 port;
 __u8 phy_address;
 __u8 transceiver;
 __u8 autoneg;
 __u8 mdio_support;
 __u32 maxtxpkt;
 __u32 maxrxpkt;
 __u16 speed_hi;
 __u8 eth_tp_mdix;
 __u8 eth_tp_mdix_ctrl;
 __u32 lp_advertising;
 __u32 reserved[2];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
      __u32 speed)
{
 ep->speed = (__u16)(speed & 0xFFFF);
 ep->speed_hi = (__u16)(speed >> 16);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 ethtool_cmd_speed(const struct ethtool_cmd *ep)
{
 return (ep->speed_hi << 16) | ep->speed;
}
# 177 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
 __u32 cmd;
 char driver[32];
 char version[32];
 char fw_version[32];
 char bus_info[32];
 char erom_version[32];
 char reserved2[12];
 __u32 n_priv_flags;
 __u32 n_stats;
 __u32 testinfo_len;
 __u32 eedump_len;
 __u32 regdump_len;
};
# 203 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
 __u32 cmd;
 __u32 supported;
 __u32 wolopts;
 __u8 sopass[6];
};


struct ethtool_value {
 __u32 cmd;
 __u32 data;
};




enum tunable_id {
 ETHTOOL_ID_UNSPEC,
 ETHTOOL_RX_COPYBREAK,
 ETHTOOL_TX_COPYBREAK,
 ETHTOOL_PFC_PREVENTION_TOUT,




 __ETHTOOL_TUNABLE_COUNT,
};

enum tunable_type_id {
 ETHTOOL_TUNABLE_UNSPEC,
 ETHTOOL_TUNABLE_U8,
 ETHTOOL_TUNABLE_U16,
 ETHTOOL_TUNABLE_U32,
 ETHTOOL_TUNABLE_U64,
 ETHTOOL_TUNABLE_STRING,
 ETHTOOL_TUNABLE_S8,
 ETHTOOL_TUNABLE_S16,
 ETHTOOL_TUNABLE_S32,
 ETHTOOL_TUNABLE_S64,
};

struct ethtool_tunable {
 __u32 cmd;
 __u32 id;
 __u32 type_id;
 __u32 len;
 void *data[0];
};
# 283 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum phy_tunable_id {
 ETHTOOL_PHY_ID_UNSPEC,
 ETHTOOL_PHY_DOWNSHIFT,
 ETHTOOL_PHY_FAST_LINK_DOWN,
 ETHTOOL_PHY_EDPD,




 __ETHTOOL_PHY_TUNABLE_COUNT,
};
# 310 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_regs {
 __u32 cmd;
 __u32 version;
 __u32 len;
 __u8 data[0];
};
# 335 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
 __u32 cmd;
 __u32 magic;
 __u32 offset;
 __u32 len;
 __u8 data[0];
};
# 360 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_eee {
 __u32 cmd;
 __u32 supported;
 __u32 advertised;
 __u32 lp_advertised;
 __u32 eee_active;
 __u32 eee_enabled;
 __u32 tx_lpi_enabled;
 __u32 tx_lpi_timer;
 __u32 reserved[2];
};
# 382 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
 __u32 cmd;
 __u32 type;
 __u32 eeprom_len;
 __u32 reserved[8];
};
# 462 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
 __u32 cmd;
 __u32 rx_coalesce_usecs;
 __u32 rx_max_coalesced_frames;
 __u32 rx_coalesce_usecs_irq;
 __u32 rx_max_coalesced_frames_irq;
 __u32 tx_coalesce_usecs;
 __u32 tx_max_coalesced_frames;
 __u32 tx_coalesce_usecs_irq;
 __u32 tx_max_coalesced_frames_irq;
 __u32 stats_block_coalesce_usecs;
 __u32 use_adaptive_rx_coalesce;
 __u32 use_adaptive_tx_coalesce;
 __u32 pkt_rate_low;
 __u32 rx_coalesce_usecs_low;
 __u32 rx_max_coalesced_frames_low;
 __u32 tx_coalesce_usecs_low;
 __u32 tx_max_coalesced_frames_low;
 __u32 pkt_rate_high;
 __u32 rx_coalesce_usecs_high;
 __u32 rx_max_coalesced_frames_high;
 __u32 tx_coalesce_usecs_high;
 __u32 tx_max_coalesced_frames_high;
 __u32 rate_sample_interval;
};
# 513 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
 __u32 cmd;
 __u32 rx_max_pending;
 __u32 rx_mini_max_pending;
 __u32 rx_jumbo_max_pending;
 __u32 tx_max_pending;
 __u32 rx_pending;
 __u32 rx_mini_pending;
 __u32 rx_jumbo_pending;
 __u32 tx_pending;
};
# 541 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_channels {
 __u32 cmd;
 __u32 max_rx;
 __u32 max_tx;
 __u32 max_other;
 __u32 max_combined;
 __u32 rx_count;
 __u32 tx_count;
 __u32 other_count;
 __u32 combined_count;
};
# 575 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
 __u32 cmd;
 __u32 autoneg;
 __u32 rx_pause;
 __u32 tx_pause;
};
# 600 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_stringset {
 ETH_SS_TEST = 0,
 ETH_SS_STATS,
 ETH_SS_PRIV_FLAGS,
 ETH_SS_NTUPLE_FILTERS,
 ETH_SS_FEATURES,
 ETH_SS_RSS_HASH_FUNCS,
 ETH_SS_TUNABLES,
 ETH_SS_PHY_STATS,
 ETH_SS_PHY_TUNABLES,
 ETH_SS_LINK_MODES,
 ETH_SS_MSG_CLASSES,
 ETH_SS_WOL_MODES,


 ETH_SS_COUNT
};
# 630 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_gstrings {
 __u32 cmd;
 __u32 string_set;
 __u32 len;
 __u8 data[0];
};
# 654 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_sset_info {
 __u32 cmd;
 __u32 reserved;
 __u64 sset_mask;
 __u32 data[0];
};
# 671 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_test_flags {
 ETH_TEST_FL_OFFLINE = (1 << 0),
 ETH_TEST_FL_FAILED = (1 << 1),
 ETH_TEST_FL_EXTERNAL_LB = (1 << 2),
 ETH_TEST_FL_EXTERNAL_LB_DONE = (1 << 3),
};
# 692 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_test {
 __u32 cmd;
 __u32 flags;
 __u32 reserved;
 __u32 len;
 __u64 data[0];
};
# 711 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_stats {
 __u32 cmd;
 __u32 n_stats;
 __u64 data[0];
};
# 728 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_perm_addr {
 __u32 cmd;
 __u32 size;
 __u8 data[0];
};
# 743 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_flags {
 ETH_FLAG_TXVLAN = (1 << 7),
 ETH_FLAG_RXVLAN = (1 << 8),
 ETH_FLAG_LRO = (1 << 15),
 ETH_FLAG_NTUPLE = (1 << 27),
 ETH_FLAG_RXHASH = (1 << 28),
};
# 767 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
 __be32 ip4src;
 __be32 ip4dst;
 __be16 psrc;
 __be16 pdst;
 __u8 tos;
};
# 784 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
 __be32 ip4src;
 __be32 ip4dst;
 __be32 spi;
 __u8 tos;
};
# 802 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
 __be32 ip4src;
 __be32 ip4dst;
 __be32 l4_4_bytes;
 __u8 tos;
 __u8 ip_ver;
 __u8 proto;
};
# 821 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_tcpip6_spec {
 __be32 ip6src[4];
 __be32 ip6dst[4];
 __be16 psrc;
 __be16 pdst;
 __u8 tclass;
};
# 838 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip6_spec {
 __be32 ip6src[4];
 __be32 ip6dst[4];
 __be32 spi;
 __u8 tclass;
};
# 853 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_usrip6_spec {
 __be32 ip6src[4];
 __be32 ip6dst[4];
 __be32 l4_4_bytes;
 __u8 tclass;
 __u8 l4_proto;
};

union ethtool_flow_union {
 struct ethtool_tcpip4_spec tcp_ip4_spec;
 struct ethtool_tcpip4_spec udp_ip4_spec;
 struct ethtool_tcpip4_spec sctp_ip4_spec;
 struct ethtool_ah_espip4_spec ah_ip4_spec;
 struct ethtool_ah_espip4_spec esp_ip4_spec;
 struct ethtool_usrip4_spec usr_ip4_spec;
 struct ethtool_tcpip6_spec tcp_ip6_spec;
 struct ethtool_tcpip6_spec udp_ip6_spec;
 struct ethtool_tcpip6_spec sctp_ip6_spec;
 struct ethtool_ah_espip6_spec ah_ip6_spec;
 struct ethtool_ah_espip6_spec esp_ip6_spec;
 struct ethtool_usrip6_spec usr_ip6_spec;
 struct ethhdr ether_spec;
 __u8 hdata[52];
};
# 889 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
 __u8 padding[2];
 unsigned char h_dest[6];
 __be16 vlan_etype;
 __be16 vlan_tci;
 __be32 data[2];
};
# 914 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
 __u32 flow_type;
 union ethtool_flow_union h_u;
 struct ethtool_flow_ext h_ext;
 union ethtool_flow_union m_u;
 struct ethtool_flow_ext m_ext;
 __u64 ring_cookie;
 __u32 location;
};
# 938 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie)
{
 return 0x00000000FFFFFFFFLL & ring_cookie;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie)
{
 return (0x000000FF00000000LL & ring_cookie) >>
    32;
}
# 1010 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
 __u32 cmd;
 __u32 flow_type;
 __u64 data;
 struct ethtool_rx_flow_spec fs;
 union {
  __u32 rule_cnt;
  __u32 rss_context;
 };
 __u32 rule_locs[0];
};
# 1036 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_rxfh_indir {
 __u32 cmd;
 __u32 size;
 __u32 ring_index[0];
};
# 1071 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_rxfh {
 __u32 cmd;
 __u32 rss_context;
 __u32 indir_size;
 __u32 key_size;
 __u8 hfunc;
 __u8 rsvd8[3];
 __u32 rsvd32;
 __u32 rss_config[0];
};
# 1100 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_rx_ntuple_flow_spec {
 __u32 flow_type;
 union {
  struct ethtool_tcpip4_spec tcp_ip4_spec;
  struct ethtool_tcpip4_spec udp_ip4_spec;
  struct ethtool_tcpip4_spec sctp_ip4_spec;
  struct ethtool_ah_espip4_spec ah_ip4_spec;
  struct ethtool_ah_espip4_spec esp_ip4_spec;
  struct ethtool_usrip4_spec usr_ip4_spec;
  struct ethhdr ether_spec;
  __u8 hdata[72];
 } h_u, m_u;

 __u16 vlan_tag;
 __u16 vlan_tag_mask;
 __u64 data;
 __u64 data_mask;

 __s32 action;


};






struct ethtool_rx_ntuple {
 __u32 cmd;
 struct ethtool_rx_ntuple_flow_spec fs;
};


enum ethtool_flash_op_type {
 ETHTOOL_FLASH_ALL_REGIONS = 0,
};


struct ethtool_flash {
 __u32 cmd;
 __u32 region;
 char data[128];
};
# 1159 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_dump {
 __u32 cmd;
 __u32 version;
 __u32 flag;
 __u32 len;
 __u8 data[0];
};
# 1178 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_get_features_block {
 __u32 available;
 __u32 requested;
 __u32 active;
 __u32 never_changed;
};
# 1193 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_gfeatures {
 __u32 cmd;
 __u32 size;
 struct ethtool_get_features_block features[0];
};






struct ethtool_set_features_block {
 __u32 valid;
 __u32 requested;
};







struct ethtool_sfeatures {
 __u32 cmd;
 __u32 size;
 struct ethtool_set_features_block features[0];
};
# 1239 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
 __u32 cmd;
 __u32 so_timestamping;
 __s32 phc_index;
 __u32 tx_types;
 __u32 tx_reserved[3];
 __u32 rx_filters;
 __u32 rx_reserved[3];
};
# 1274 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_sfeatures_retval_bits {
 ETHTOOL_F_UNSUPPORTED__BIT,
 ETHTOOL_F_WISH__BIT,
 ETHTOOL_F_COMPAT__BIT,
};
# 1293 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_per_queue_op {
 __u32 cmd;
 __u32 sub_command;
 __u32 queue_mask[(((4096) + (32) - 1) / (32))];
 char data[];
};
# 1311 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_fecparam {
 __u32 cmd;

 __u32 active_fec;
 __u32 fec;
 __u32 reserved;
};
# 1327 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_fec_config_bits {
 ETHTOOL_FEC_NONE_BIT,
 ETHTOOL_FEC_AUTO_BIT,
 ETHTOOL_FEC_OFF_BIT,
 ETHTOOL_FEC_RS_BIT,
 ETHTOOL_FEC_BASER_BIT,
};
# 1441 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_link_mode_bit_indices {
 ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
 ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
 ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
 ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
 ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
 ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
 ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
 ETHTOOL_LINK_MODE_TP_BIT = 7,
 ETHTOOL_LINK_MODE_AUI_BIT = 8,
 ETHTOOL_LINK_MODE_MII_BIT = 9,
 ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
 ETHTOOL_LINK_MODE_BNC_BIT = 11,
 ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
 ETHTOOL_LINK_MODE_Pause_BIT = 13,
 ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
 ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
 ETHTOOL_LINK_MODE_Backplane_BIT = 16,
 ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
 ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
 ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
 ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
 ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
 ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
 ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
 ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
 ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
 ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
 ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
 ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
 ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
 ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
 ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,







 ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
 ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
 ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
 ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
 ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
 ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
 ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
 ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
 ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
 ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
 ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
 ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
 ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
 ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
 ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
 ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
 ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,

 ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
 ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
 ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
 ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
 ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
 ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
 ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
 ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
 ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
 ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
 ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
 ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
 ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
 ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
 ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
 ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
 ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
 ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
 ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
 ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
 ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
 ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
 ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
 ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
 ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,


 __ETHTOOL_LINK_MODE_MASK_NBITS
};
# 1639 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ethtool_validate_speed(__u32 speed)
{
 return speed <= ((int)(~0U >> 1)) || speed == (__u32)-1;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ethtool_validate_duplex(__u8 duplex)
{
 switch (duplex) {
 case 0x00:
 case 0x01:
 case 0xff:
  return 1;
 }

 return 0;
}
# 1766 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
enum ethtool_reset_flags {





 ETH_RESET_MGMT = 1 << 0,
 ETH_RESET_IRQ = 1 << 1,
 ETH_RESET_DMA = 1 << 2,
 ETH_RESET_FILTER = 1 << 3,
 ETH_RESET_OFFLOAD = 1 << 4,
 ETH_RESET_MAC = 1 << 5,
 ETH_RESET_PHY = 1 << 6,
 ETH_RESET_RAM = 1 << 7,

 ETH_RESET_AP = 1 << 8,

 ETH_RESET_DEDICATED = 0x0000ffff,

 ETH_RESET_ALL = 0xffffffff,

};
# 1887 "/home/nathan/src/linux-next/include/uapi/linux/ethtool.h"
struct ethtool_link_settings {
 __u32 cmd;
 __u32 speed;
 __u8 duplex;
 __u8 port;
 __u8 phy_address;
 __u8 autoneg;
 __u8 mdio_support;
 __u8 eth_tp_mdix;
 __u8 eth_tp_mdix_ctrl;
 __s8 link_mode_masks_nwords;
 __u8 transceiver;
 __u8 reserved1[3];
 __u32 reserved[7];
 __u32 link_mode_masks[0];





};
# 19 "/home/nathan/src/linux-next/include/linux/ethtool.h" 2



struct compat_ethtool_rx_flow_spec {
 u32 flow_type;
 union ethtool_flow_union h_u;
 struct ethtool_flow_ext h_ext;
 union ethtool_flow_union m_u;
 struct ethtool_flow_ext m_ext;
 compat_u64 ring_cookie;
 u32 location;
};

struct compat_ethtool_rxnfc {
 u32 cmd;
 u32 flow_type;
 compat_u64 data;
 struct compat_ethtool_rx_flow_spec fs;
 u32 rule_cnt;
 u32 rule_locs[0];
};
# 54 "/home/nathan/src/linux-next/include/linux/ethtool.h"
enum ethtool_phys_id_state {
 ETHTOOL_ID_INACTIVE,
 ETHTOOL_ID_ACTIVE,
 ETHTOOL_ID_ON,
 ETHTOOL_ID_OFF
};

enum {
 ETH_RSS_HASH_TOP_BIT,
 ETH_RSS_HASH_XOR_BIT,
 ETH_RSS_HASH_CRC32_BIT,





 ETH_RSS_HASH_FUNCS_COUNT
};
# 83 "/home/nathan/src/linux-next/include/linux/ethtool.h"
struct net_device;


u32 ethtool_op_get_link(struct net_device *dev);
int ethtool_op_get_ts_info(struct net_device *dev, struct ethtool_ts_info *eti);
# 96 "/home/nathan/src/linux-next/include/linux/ethtool.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ethtool_rxfh_indir_default(u32 index, u32 n_rx_rings)
{
 return index % n_rx_rings;
}
# 108 "/home/nathan/src/linux-next/include/linux/ethtool.h"
struct ethtool_link_ksettings {
 struct ethtool_link_settings base;
 struct {
  unsigned long supported[(((__ETHTOOL_LINK_MODE_MASK_NBITS) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
  unsigned long advertising[(((__ETHTOOL_LINK_MODE_MASK_NBITS) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
  unsigned long lp_advertising[(((__ETHTOOL_LINK_MODE_MASK_NBITS) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
 } link_modes;
};
# 159 "/home/nathan/src/linux-next/include/linux/ethtool.h"
extern int
__ethtool_get_link_ksettings(struct net_device *dev,
        struct ethtool_link_ksettings *link_ksettings);
# 170 "/home/nathan/src/linux-next/include/linux/ethtool.h"
void ethtool_intersect_link_masks(struct ethtool_link_ksettings *dst,
      struct ethtool_link_ksettings *src);

void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
          u32 legacy_u32);


bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
         const unsigned long *src);
# 325 "/home/nathan/src/linux-next/include/linux/ethtool.h"
struct ethtool_ops {
 void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
 int (*get_regs_len)(struct net_device *);
 void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
 void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
 int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
 u32 (*get_msglevel)(struct net_device *);
 void (*set_msglevel)(struct net_device *, u32);
 int (*nway_reset)(struct net_device *);
 u32 (*get_link)(struct net_device *);
 int (*get_eeprom_len)(struct net_device *);
 int (*get_eeprom)(struct net_device *,
         struct ethtool_eeprom *, u8 *);
 int (*set_eeprom)(struct net_device *,
         struct ethtool_eeprom *, u8 *);
 int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
 int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
 void (*get_ringparam)(struct net_device *,
     struct ethtool_ringparam *);
 int (*set_ringparam)(struct net_device *,
     struct ethtool_ringparam *);
 void (*get_pauseparam)(struct net_device *,
      struct ethtool_pauseparam*);
 int (*set_pauseparam)(struct net_device *,
      struct ethtool_pauseparam*);
 void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
 void (*get_strings)(struct net_device *, u32 stringset, u8 *);
 int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
 void (*get_ethtool_stats)(struct net_device *,
         struct ethtool_stats *, u64 *);
 int (*begin)(struct net_device *);
 void (*complete)(struct net_device *);
 u32 (*get_priv_flags)(struct net_device *);
 int (*set_priv_flags)(struct net_device *, u32);
 int (*get_sset_count)(struct net_device *, int);
 int (*get_rxnfc)(struct net_device *,
        struct ethtool_rxnfc *, u32 *rule_locs);
 int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
 int (*flash_device)(struct net_device *, struct ethtool_flash *);
 int (*reset)(struct net_device *, u32 *);
 u32 (*get_rxfh_key_size)(struct net_device *);
 u32 (*get_rxfh_indir_size)(struct net_device *);
 int (*get_rxfh)(struct net_device *, u32 *indir, u8 *key,
       u8 *hfunc);
 int (*set_rxfh)(struct net_device *, const u32 *indir,
       const u8 *key, const u8 hfunc);
 int (*get_rxfh_context)(struct net_device *, u32 *indir, u8 *key,
        u8 *hfunc, u32 rss_context);
 int (*set_rxfh_context)(struct net_device *, const u32 *indir,
        const u8 *key, const u8 hfunc,
        u32 *rss_context, bool delete);
 void (*get_channels)(struct net_device *, struct ethtool_channels *);
 int (*set_channels)(struct net_device *, struct ethtool_channels *);
 int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
 int (*get_dump_data)(struct net_device *,
     struct ethtool_dump *, void *);
 int (*set_dump)(struct net_device *, struct ethtool_dump *);
 int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
 int (*get_module_info)(struct net_device *,
       struct ethtool_modinfo *);
 int (*get_module_eeprom)(struct net_device *,
         struct ethtool_eeprom *, u8 *);
 int (*get_eee)(struct net_device *, struct ethtool_eee *);
 int (*set_eee)(struct net_device *, struct ethtool_eee *);
 int (*get_tunable)(struct net_device *,
          const struct ethtool_tunable *, void *);
 int (*set_tunable)(struct net_device *,
          const struct ethtool_tunable *, const void *);
 int (*get_per_queue_coalesce)(struct net_device *, u32,
       struct ethtool_coalesce *);
 int (*set_per_queue_coalesce)(struct net_device *, u32,
       struct ethtool_coalesce *);
 int (*get_link_ksettings)(struct net_device *,
          struct ethtool_link_ksettings *);
 int (*set_link_ksettings)(struct net_device *,
          const struct ethtool_link_ksettings *);
 int (*get_fecparam)(struct net_device *,
          struct ethtool_fecparam *);
 int (*set_fecparam)(struct net_device *,
          struct ethtool_fecparam *);
 void (*get_ethtool_phy_stats)(struct net_device *,
      struct ethtool_stats *, u64 *);
};

struct ethtool_rx_flow_rule {
 struct flow_rule *rule;
 unsigned long priv[0];
};

struct ethtool_rx_flow_spec_input {
 const struct ethtool_rx_flow_spec *fs;
 u32 rss_ctx;
};

struct ethtool_rx_flow_rule *
ethtool_rx_flow_rule_create(const struct ethtool_rx_flow_spec_input *input);
void ethtool_rx_flow_rule_destroy(struct ethtool_rx_flow_rule *rule);
# 38 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/net/net_namespace.h" 1
# 16 "/home/nathan/src/linux-next/include/net/net_namespace.h"
# 1 "/home/nathan/src/linux-next/include/net/netns/core.h" 1




struct ctl_table_header;
struct prot_inuse;

struct netns_core {

 struct ctl_table_header *sysctl_hdr;

 int sysctl_somaxconn;


 int *sock_inuse;
 struct prot_inuse *prot_inuse;

};
# 17 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/mib.h" 1




# 1 "/home/nathan/src/linux-next/include/net/snmp.h" 1
# 18 "/home/nathan/src/linux-next/include/net/snmp.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/snmp.h" 1
# 19 "/home/nathan/src/linux-next/include/uapi/linux/snmp.h"
enum
{
 IPSTATS_MIB_NUM = 0,

 IPSTATS_MIB_INPKTS,
 IPSTATS_MIB_INOCTETS,
 IPSTATS_MIB_INDELIVERS,
 IPSTATS_MIB_OUTFORWDATAGRAMS,
 IPSTATS_MIB_OUTPKTS,
 IPSTATS_MIB_OUTOCTETS,

 IPSTATS_MIB_INHDRERRORS,
 IPSTATS_MIB_INTOOBIGERRORS,
 IPSTATS_MIB_INNOROUTES,
 IPSTATS_MIB_INADDRERRORS,
 IPSTATS_MIB_INUNKNOWNPROTOS,
 IPSTATS_MIB_INTRUNCATEDPKTS,
 IPSTATS_MIB_INDISCARDS,
 IPSTATS_MIB_OUTDISCARDS,
 IPSTATS_MIB_OUTNOROUTES,
 IPSTATS_MIB_REASMTIMEOUT,
 IPSTATS_MIB_REASMREQDS,
 IPSTATS_MIB_REASMOKS,
 IPSTATS_MIB_REASMFAILS,
 IPSTATS_MIB_FRAGOKS,
 IPSTATS_MIB_FRAGFAILS,
 IPSTATS_MIB_FRAGCREATES,
 IPSTATS_MIB_INMCASTPKTS,
 IPSTATS_MIB_OUTMCASTPKTS,
 IPSTATS_MIB_INBCASTPKTS,
 IPSTATS_MIB_OUTBCASTPKTS,
 IPSTATS_MIB_INMCASTOCTETS,
 IPSTATS_MIB_OUTMCASTOCTETS,
 IPSTATS_MIB_INBCASTOCTETS,
 IPSTATS_MIB_OUTBCASTOCTETS,
 IPSTATS_MIB_CSUMERRORS,
 IPSTATS_MIB_NOECTPKTS,
 IPSTATS_MIB_ECT1PKTS,
 IPSTATS_MIB_ECT0PKTS,
 IPSTATS_MIB_CEPKTS,
 IPSTATS_MIB_REASM_OVERLAPS,
 __IPSTATS_MIB_MAX
};






enum
{
 ICMP_MIB_NUM = 0,
 ICMP_MIB_INMSGS,
 ICMP_MIB_INERRORS,
 ICMP_MIB_INDESTUNREACHS,
 ICMP_MIB_INTIMEEXCDS,
 ICMP_MIB_INPARMPROBS,
 ICMP_MIB_INSRCQUENCHS,
 ICMP_MIB_INREDIRECTS,
 ICMP_MIB_INECHOS,
 ICMP_MIB_INECHOREPS,
 ICMP_MIB_INTIMESTAMPS,
 ICMP_MIB_INTIMESTAMPREPS,
 ICMP_MIB_INADDRMASKS,
 ICMP_MIB_INADDRMASKREPS,
 ICMP_MIB_OUTMSGS,
 ICMP_MIB_OUTERRORS,
 ICMP_MIB_OUTDESTUNREACHS,
 ICMP_MIB_OUTTIMEEXCDS,
 ICMP_MIB_OUTPARMPROBS,
 ICMP_MIB_OUTSRCQUENCHS,
 ICMP_MIB_OUTREDIRECTS,
 ICMP_MIB_OUTECHOS,
 ICMP_MIB_OUTECHOREPS,
 ICMP_MIB_OUTTIMESTAMPS,
 ICMP_MIB_OUTTIMESTAMPREPS,
 ICMP_MIB_OUTADDRMASKS,
 ICMP_MIB_OUTADDRMASKREPS,
 ICMP_MIB_CSUMERRORS,
 __ICMP_MIB_MAX
};







enum
{
 ICMP6_MIB_NUM = 0,
 ICMP6_MIB_INMSGS,
 ICMP6_MIB_INERRORS,
 ICMP6_MIB_OUTMSGS,
 ICMP6_MIB_OUTERRORS,
 ICMP6_MIB_CSUMERRORS,
 __ICMP6_MIB_MAX
};
# 125 "/home/nathan/src/linux-next/include/uapi/linux/snmp.h"
enum
{
 TCP_MIB_NUM = 0,
 TCP_MIB_RTOALGORITHM,
 TCP_MIB_RTOMIN,
 TCP_MIB_RTOMAX,
 TCP_MIB_MAXCONN,
 TCP_MIB_ACTIVEOPENS,
 TCP_MIB_PASSIVEOPENS,
 TCP_MIB_ATTEMPTFAILS,
 TCP_MIB_ESTABRESETS,
 TCP_MIB_CURRESTAB,
 TCP_MIB_INSEGS,
 TCP_MIB_OUTSEGS,
 TCP_MIB_RETRANSSEGS,
 TCP_MIB_INERRS,
 TCP_MIB_OUTRSTS,
 TCP_MIB_CSUMERRORS,
 __TCP_MIB_MAX
};






enum
{
 UDP_MIB_NUM = 0,
 UDP_MIB_INDATAGRAMS,
 UDP_MIB_NOPORTS,
 UDP_MIB_INERRORS,
 UDP_MIB_OUTDATAGRAMS,
 UDP_MIB_RCVBUFERRORS,
 UDP_MIB_SNDBUFERRORS,
 UDP_MIB_CSUMERRORS,
 UDP_MIB_IGNOREDMULTI,
 __UDP_MIB_MAX
};


enum
{
 LINUX_MIB_NUM = 0,
 LINUX_MIB_SYNCOOKIESSENT,
 LINUX_MIB_SYNCOOKIESRECV,
 LINUX_MIB_SYNCOOKIESFAILED,
 LINUX_MIB_EMBRYONICRSTS,
 LINUX_MIB_PRUNECALLED,
 LINUX_MIB_RCVPRUNED,
 LINUX_MIB_OFOPRUNED,
 LINUX_MIB_OUTOFWINDOWICMPS,
 LINUX_MIB_LOCKDROPPEDICMPS,
 LINUX_MIB_ARPFILTER,
 LINUX_MIB_TIMEWAITED,
 LINUX_MIB_TIMEWAITRECYCLED,
 LINUX_MIB_TIMEWAITKILLED,
 LINUX_MIB_PAWSACTIVEREJECTED,
 LINUX_MIB_PAWSESTABREJECTED,
 LINUX_MIB_DELAYEDACKS,
 LINUX_MIB_DELAYEDACKLOCKED,
 LINUX_MIB_DELAYEDACKLOST,
 LINUX_MIB_LISTENOVERFLOWS,
 LINUX_MIB_LISTENDROPS,
 LINUX_MIB_TCPHPHITS,
 LINUX_MIB_TCPPUREACKS,
 LINUX_MIB_TCPHPACKS,
 LINUX_MIB_TCPRENORECOVERY,
 LINUX_MIB_TCPSACKRECOVERY,
 LINUX_MIB_TCPSACKRENEGING,
 LINUX_MIB_TCPSACKREORDER,
 LINUX_MIB_TCPRENOREORDER,
 LINUX_MIB_TCPTSREORDER,
 LINUX_MIB_TCPFULLUNDO,
 LINUX_MIB_TCPPARTIALUNDO,
 LINUX_MIB_TCPDSACKUNDO,
 LINUX_MIB_TCPLOSSUNDO,
 LINUX_MIB_TCPLOSTRETRANSMIT,
 LINUX_MIB_TCPRENOFAILURES,
 LINUX_MIB_TCPSACKFAILURES,
 LINUX_MIB_TCPLOSSFAILURES,
 LINUX_MIB_TCPFASTRETRANS,
 LINUX_MIB_TCPSLOWSTARTRETRANS,
 LINUX_MIB_TCPTIMEOUTS,
 LINUX_MIB_TCPLOSSPROBES,
 LINUX_MIB_TCPLOSSPROBERECOVERY,
 LINUX_MIB_TCPRENORECOVERYFAIL,
 LINUX_MIB_TCPSACKRECOVERYFAIL,
 LINUX_MIB_TCPRCVCOLLAPSED,
 LINUX_MIB_TCPDSACKOLDSENT,
 LINUX_MIB_TCPDSACKOFOSENT,
 LINUX_MIB_TCPDSACKRECV,
 LINUX_MIB_TCPDSACKOFORECV,
 LINUX_MIB_TCPABORTONDATA,
 LINUX_MIB_TCPABORTONCLOSE,
 LINUX_MIB_TCPABORTONMEMORY,
 LINUX_MIB_TCPABORTONTIMEOUT,
 LINUX_MIB_TCPABORTONLINGER,
 LINUX_MIB_TCPABORTFAILED,
 LINUX_MIB_TCPMEMORYPRESSURES,
 LINUX_MIB_TCPMEMORYPRESSURESCHRONO,
 LINUX_MIB_TCPSACKDISCARD,
 LINUX_MIB_TCPDSACKIGNOREDOLD,
 LINUX_MIB_TCPDSACKIGNOREDNOUNDO,
 LINUX_MIB_TCPSPURIOUSRTOS,
 LINUX_MIB_TCPMD5NOTFOUND,
 LINUX_MIB_TCPMD5UNEXPECTED,
 LINUX_MIB_TCPMD5FAILURE,
 LINUX_MIB_SACKSHIFTED,
 LINUX_MIB_SACKMERGED,
 LINUX_MIB_SACKSHIFTFALLBACK,
 LINUX_MIB_TCPBACKLOGDROP,
 LINUX_MIB_PFMEMALLOCDROP,
 LINUX_MIB_TCPMINTTLDROP,
 LINUX_MIB_TCPDEFERACCEPTDROP,
 LINUX_MIB_IPRPFILTER,
 LINUX_MIB_TCPTIMEWAITOVERFLOW,
 LINUX_MIB_TCPREQQFULLDOCOOKIES,
 LINUX_MIB_TCPREQQFULLDROP,
 LINUX_MIB_TCPRETRANSFAIL,
 LINUX_MIB_TCPRCVCOALESCE,
 LINUX_MIB_TCPBACKLOGCOALESCE,
 LINUX_MIB_TCPOFOQUEUE,
 LINUX_MIB_TCPOFODROP,
 LINUX_MIB_TCPOFOMERGE,
 LINUX_MIB_TCPCHALLENGEACK,
 LINUX_MIB_TCPSYNCHALLENGE,
 LINUX_MIB_TCPFASTOPENACTIVE,
 LINUX_MIB_TCPFASTOPENACTIVEFAIL,
 LINUX_MIB_TCPFASTOPENPASSIVE,
 LINUX_MIB_TCPFASTOPENPASSIVEFAIL,
 LINUX_MIB_TCPFASTOPENLISTENOVERFLOW,
 LINUX_MIB_TCPFASTOPENCOOKIEREQD,
 LINUX_MIB_TCPFASTOPENBLACKHOLE,
 LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES,
 LINUX_MIB_BUSYPOLLRXPACKETS,
 LINUX_MIB_TCPAUTOCORKING,
 LINUX_MIB_TCPFROMZEROWINDOWADV,
 LINUX_MIB_TCPTOZEROWINDOWADV,
 LINUX_MIB_TCPWANTZEROWINDOWADV,
 LINUX_MIB_TCPSYNRETRANS,
 LINUX_MIB_TCPORIGDATASENT,
 LINUX_MIB_TCPHYSTARTTRAINDETECT,
 LINUX_MIB_TCPHYSTARTTRAINCWND,
 LINUX_MIB_TCPHYSTARTDELAYDETECT,
 LINUX_MIB_TCPHYSTARTDELAYCWND,
 LINUX_MIB_TCPACKSKIPPEDSYNRECV,
 LINUX_MIB_TCPACKSKIPPEDPAWS,
 LINUX_MIB_TCPACKSKIPPEDSEQ,
 LINUX_MIB_TCPACKSKIPPEDFINWAIT2,
 LINUX_MIB_TCPACKSKIPPEDTIMEWAIT,
 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
 LINUX_MIB_TCPWINPROBE,
 LINUX_MIB_TCPKEEPALIVE,
 LINUX_MIB_TCPMTUPFAIL,
 LINUX_MIB_TCPMTUPSUCCESS,
 LINUX_MIB_TCPDELIVERED,
 LINUX_MIB_TCPDELIVEREDCE,
 LINUX_MIB_TCPACKCOMPRESSED,
 LINUX_MIB_TCPZEROWINDOWDROP,
 LINUX_MIB_TCPRCVQDROP,
 LINUX_MIB_TCPWQUEUETOOBIG,
 LINUX_MIB_TCPFASTOPENPASSIVEALTKEY,
 LINUX_MIB_TCPTIMEOUTREHASH,
 LINUX_MIB_TCPDUPLICATEDATAREHASH,
 __LINUX_MIB_MAX
};


enum
{
 LINUX_MIB_XFRMNUM = 0,
 LINUX_MIB_XFRMINERROR,
 LINUX_MIB_XFRMINBUFFERERROR,
 LINUX_MIB_XFRMINHDRERROR,
 LINUX_MIB_XFRMINNOSTATES,
 LINUX_MIB_XFRMINSTATEPROTOERROR,
 LINUX_MIB_XFRMINSTATEMODEERROR,
 LINUX_MIB_XFRMINSTATESEQERROR,
 LINUX_MIB_XFRMINSTATEEXPIRED,
 LINUX_MIB_XFRMINSTATEMISMATCH,
 LINUX_MIB_XFRMINSTATEINVALID,
 LINUX_MIB_XFRMINTMPLMISMATCH,
 LINUX_MIB_XFRMINNOPOLS,
 LINUX_MIB_XFRMINPOLBLOCK,
 LINUX_MIB_XFRMINPOLERROR,
 LINUX_MIB_XFRMOUTERROR,
 LINUX_MIB_XFRMOUTBUNDLEGENERROR,
 LINUX_MIB_XFRMOUTBUNDLECHECKERROR,
 LINUX_MIB_XFRMOUTNOSTATES,
 LINUX_MIB_XFRMOUTSTATEPROTOERROR,
 LINUX_MIB_XFRMOUTSTATEMODEERROR,
 LINUX_MIB_XFRMOUTSTATESEQERROR,
 LINUX_MIB_XFRMOUTSTATEEXPIRED,
 LINUX_MIB_XFRMOUTPOLBLOCK,
 LINUX_MIB_XFRMOUTPOLDEAD,
 LINUX_MIB_XFRMOUTPOLERROR,
 LINUX_MIB_XFRMFWDHDRERROR,
 LINUX_MIB_XFRMOUTSTATEINVALID,
 LINUX_MIB_XFRMACQUIREERROR,
 __LINUX_MIB_XFRMMAX
};


enum
{
 LINUX_MIB_TLSNUM = 0,
 LINUX_MIB_TLSCURRTXSW,
 LINUX_MIB_TLSCURRRXSW,
 LINUX_MIB_TLSCURRTXDEVICE,
 LINUX_MIB_TLSCURRRXDEVICE,
 LINUX_MIB_TLSTXSW,
 LINUX_MIB_TLSRXSW,
 LINUX_MIB_TLSTXDEVICE,
 LINUX_MIB_TLSRXDEVICE,
 LINUX_MIB_TLSDECRYPTERROR,
 LINUX_MIB_TLSRXDEVICERESYNC,
 __LINUX_MIB_TLSMAX
};
# 19 "/home/nathan/src/linux-next/include/net/snmp.h" 2
# 29 "/home/nathan/src/linux-next/include/net/snmp.h"
struct snmp_mib {
 const char *name;
 int entry;
};
# 47 "/home/nathan/src/linux-next/include/net/snmp.h"
# 1 "/home/nathan/src/linux-next/include/linux/u64_stats_sync.h" 1
# 65 "/home/nathan/src/linux-next/include/linux/u64_stats_sync.h"
struct u64_stats_sync {



};



# 1 "./arch/powerpc/include/generated/asm/local64.h" 1
# 1 "/home/nathan/src/linux-next/include/asm-generic/local64.h" 1
# 22 "/home/nathan/src/linux-next/include/asm-generic/local64.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/local.h" 1
# 13 "/home/nathan/src/linux-next/arch/powerpc/include/asm/local.h"
typedef struct
{
 long v;
} local_t;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long local_read(const local_t *l)
{
 return ({ union { typeof(l->v) __val; char __c[1]; } __u; if (1) __read_once_size(&(l->v), __u.__c, sizeof(l->v)); else __read_once_size_nocheck(&(l->v), __u.__c, sizeof(l->v)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_set(local_t *l, long i)
{
 ({ union { typeof(l->v) __val; char __c[1]; } __u = { .__val = ( typeof(l->v)) (i) }; __write_once_size(&(l->v), __u.__c, sizeof(l->v)); __u.__val; });
}
# 57 "/home/nathan/src/linux-next/arch/powerpc/include/asm/local.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_add(long i, local_t *l) { unsigned long flags; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0); l->v += i; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long local_add_return(long a, local_t *l) { long t; unsigned long flags; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0); t = (l->v += a); do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0); return t; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void local_sub(long i, local_t *l) { unsigned long flags; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0); l->v -= i; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0); } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long local_sub_return(long a, local_t *l) { long t; unsigned long flags; do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0); t = (l->v -= a); do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0); return t; }
# 79 "/home/nathan/src/linux-next/arch/powerpc/include/asm/local.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long local_cmpxchg(local_t *l, long o, long n)
{
 long t;
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0);
 t = l->v;
 if (t == o)
  l->v = n;
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0);

 return t;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long local_xchg(local_t *l, long n)
{
 long t;
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0);
 t = l->v;
 l->v = n;
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0);

 return t;
}
# 115 "/home/nathan/src/linux-next/arch/powerpc/include/asm/local.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int local_add_unless(local_t *l, long a, long u)
{
 unsigned long flags;
 int ret = 0;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = irq_soft_mask_or_return(1 | 2); } while(0); } while(0);
 if (l->v != u) {
  l->v += a;
  ret = 1;
 }
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while(0); } while (0);

 return ret;
}
# 23 "/home/nathan/src/linux-next/include/asm-generic/local64.h" 2

typedef struct {
 local_t a;
} local64_t;
# 2 "./arch/powerpc/include/generated/asm/local64.h" 2
# 73 "/home/nathan/src/linux-next/include/linux/u64_stats_sync.h" 2

typedef struct {
 local64_t v;
} u64_stats_t ;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 u64_stats_read(const u64_stats_t *p)
{
 return local_read(&(&p->v)->a);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_stats_add(u64_stats_t *p, unsigned long val)
{
 local_add((val),(&(&p->v)->a));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_stats_inc(u64_stats_t *p)
{
 local_add_return(1LL, &(&p->v)->a);
}
# 115 "/home/nathan/src/linux-next/include/linux/u64_stats_sync.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_stats_init(struct u64_stats_sync *syncp)
{



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_stats_update_begin(struct u64_stats_sync *syncp)
{



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_stats_update_end(struct u64_stats_sync *syncp)
{



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
u64_stats_update_begin_irqsave(struct u64_stats_sync *syncp)
{
 unsigned long flags = 0;





 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
u64_stats_update_end_irqrestore(struct u64_stats_sync *syncp,
    unsigned long flags)
{




}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
{



 return 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
{



 return __u64_stats_fetch_begin(syncp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
      unsigned int start)
{



 return false;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
      unsigned int start)
{



 return __u64_stats_fetch_retry(syncp, start);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)
{



 return __u64_stats_fetch_begin(syncp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool u64_stats_fetch_retry_irq(const struct u64_stats_sync *syncp,
          unsigned int start)
{



 return __u64_stats_fetch_retry(syncp, start);
}
# 48 "/home/nathan/src/linux-next/include/net/snmp.h" 2



struct ipstats_mib {

 u64 mibs[__IPSTATS_MIB_MAX];
 struct u64_stats_sync syncp;
};



struct icmp_mib {
 unsigned long mibs[__ICMP_MIB_MAX];
};


struct icmpmsg_mib {
 atomic_long_t mibs[512];
};




struct icmpv6_mib {
 unsigned long mibs[__ICMP6_MIB_MAX];
};

struct icmpv6_mib_device {
 atomic_long_t mibs[__ICMP6_MIB_MAX];
};



struct icmpv6msg_mib {
 atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
 atomic_long_t mibs[512];
};




struct tcp_mib {
 unsigned long mibs[__TCP_MIB_MAX];
};



struct udp_mib {
 unsigned long mibs[__UDP_MIB_MAX];
};



struct linux_mib {
 unsigned long mibs[__LINUX_MIB_MAX];
};



struct linux_xfrm_mib {
 unsigned long mibs[__LINUX_MIB_XFRMMAX];
};



struct linux_tls_mib {
 unsigned long mibs[__LINUX_MIB_TLSMAX];
};
# 6 "/home/nathan/src/linux-next/include/net/netns/mib.h" 2

struct netns_mib {
 __typeof__(struct tcp_mib) *tcp_statistics;
 __typeof__(struct ipstats_mib) *ip_statistics;
 __typeof__(struct linux_mib) *net_statistics;
 __typeof__(struct udp_mib) *udp_statistics;
 __typeof__(struct udp_mib) *udplite_statistics;
 __typeof__(struct icmp_mib) *icmp_statistics;
 __typeof__(struct icmpmsg_mib) *icmpmsg_statistics;


 struct proc_dir_entry *proc_net_devsnmp6;
 __typeof__(struct udp_mib) *udp_stats_in6;
 __typeof__(struct udp_mib) *udplite_stats_in6;
 __typeof__(struct ipstats_mib) *ipv6_statistics;
 __typeof__(struct icmpv6_mib) *icmpv6_statistics;
 __typeof__(struct icmpv6msg_mib) *icmpv6msg_statistics;







};
# 18 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/unix.h" 1







struct ctl_table_header;
struct netns_unix {
 int sysctl_max_dgram_qlen;
 struct ctl_table_header *ctl;
};
# 19 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/packet.h" 1
# 11 "/home/nathan/src/linux-next/include/net/netns/packet.h"
struct netns_packet {
 struct mutex sklist_lock;
 struct hlist_head sklist;
};
# 20 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/ipv4.h" 1
# 10 "/home/nathan/src/linux-next/include/net/netns/ipv4.h"
# 1 "/home/nathan/src/linux-next/include/net/inet_frag.h" 1








struct fqdir {

 long high_thresh;
 long low_thresh;
 int timeout;
 int max_dist;
 struct inet_frags *f;
 struct net *net;
 bool dead;

 struct rhashtable rhashtable __attribute__((__aligned__((1 << 7))));


 atomic_long_t mem __attribute__((__aligned__((1 << 7))));
 struct work_struct destroy_work;
};
# 34 "/home/nathan/src/linux-next/include/net/inet_frag.h"
enum {
 INET_FRAG_FIRST_IN = ((((1UL))) << (0)),
 INET_FRAG_LAST_IN = ((((1UL))) << (1)),
 INET_FRAG_COMPLETE = ((((1UL))) << (2)),
 INET_FRAG_HASH_DEAD = ((((1UL))) << (3)),
};

struct frag_v4_compare_key {
 __be32 saddr;
 __be32 daddr;
 u32 user;
 u32 vif;
 __be16 id;
 u16 protocol;
};

struct frag_v6_compare_key {
 struct in6_addr saddr;
 struct in6_addr daddr;
 u32 user;
 __be32 id;
 u32 iif;
};
# 77 "/home/nathan/src/linux-next/include/net/inet_frag.h"
struct inet_frag_queue {
 struct rhash_head node;
 union {
  struct frag_v4_compare_key v4;
  struct frag_v6_compare_key v6;
 } key;
 struct timer_list timer;
 spinlock_t lock;
 refcount_t refcnt;
 struct rb_root rb_fragments;
 struct sk_buff *fragments_tail;
 struct sk_buff *last_run_head;
 ktime_t stamp;
 int len;
 int meat;
 __u8 flags;
 u16 max_size;
 struct fqdir *fqdir;
 struct callback_head rcu;
};

struct inet_frags {
 unsigned int qsize;

 void (*constructor)(struct inet_frag_queue *q,
            const void *arg);
 void (*destructor)(struct inet_frag_queue *);
 void (*frag_expire)(struct timer_list *t);
 struct kmem_cache *frags_cachep;
 const char *frags_cache_name;
 struct rhashtable_params rhash_params;
 refcount_t refcnt;
 struct completion completion;
};

int inet_frags_init(struct inet_frags *);
void inet_frags_fini(struct inet_frags *);

int fqdir_init(struct fqdir **fqdirp, struct inet_frags *f, struct net *net);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fqdir_pre_exit(struct fqdir *fqdir)
{
 fqdir->high_thresh = 0;
 fqdir->dead = true;
}
void fqdir_exit(struct fqdir *fqdir);

void inet_frag_kill(struct inet_frag_queue *q);
void inet_frag_destroy(struct inet_frag_queue *q);
struct inet_frag_queue *inet_frag_find(struct fqdir *fqdir, void *key);


unsigned int inet_frag_rbtree_purge(struct rb_root *root);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_frag_put(struct inet_frag_queue *q)
{
 if (refcount_dec_and_test(&q->refcnt))
  inet_frag_destroy(q);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long frag_mem_limit(const struct fqdir *fqdir)
{
 return atomic_long_read(&fqdir->mem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sub_frag_mem_limit(struct fqdir *fqdir, long val)
{
 atomic_long_sub(val, &fqdir->mem);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_frag_mem_limit(struct fqdir *fqdir, long val)
{
 atomic_long_add(val, &fqdir->mem);
}
# 163 "/home/nathan/src/linux-next/include/net/inet_frag.h"
extern const u8 ip_frag_ecn_table[16];





int inet_frag_queue_insert(struct inet_frag_queue *q, struct sk_buff *skb,
      int offset, int end);
void *inet_frag_reasm_prepare(struct inet_frag_queue *q, struct sk_buff *skb,
         struct sk_buff *parent);
void inet_frag_reasm_finish(struct inet_frag_queue *q, struct sk_buff *head,
       void *reasm_data, bool try_coalesce);
struct sk_buff *inet_frag_pull_head(struct inet_frag_queue *q);
# 11 "/home/nathan/src/linux-next/include/net/netns/ipv4.h" 2



struct tcpm_hash_bucket;
struct ctl_table_header;
struct ipv4_devconf;
struct fib_rules_ops;
struct hlist_head;
struct fib_table;
struct sock;
struct local_ports {
 seqlock_t lock;
 int range[2];
 bool warned;
};

struct ping_group_range {
 seqlock_t lock;
 kgid_t range[2];
};

struct inet_hashinfo;

struct inet_timewait_death_row {
 atomic_t tw_count;

 struct inet_hashinfo *hashinfo __attribute__((__aligned__((1 << 7))));
 int sysctl_max_tw_buckets;
};

struct tcp_fastopen_context;

struct netns_ipv4 {

 struct ctl_table_header *forw_hdr;
 struct ctl_table_header *frags_hdr;
 struct ctl_table_header *ipv4_hdr;
 struct ctl_table_header *route_hdr;
 struct ctl_table_header *xfrm4_hdr;

 struct ipv4_devconf *devconf_all;
 struct ipv4_devconf *devconf_dflt;
 struct ip_ra_chain *ra_chain;
 struct mutex ra_mutex;







 bool fib_has_custom_local_routes;



 struct hlist_head *fib_table_hash;
 bool fib_offload_disabled;
 struct sock *fibnl;

 struct sock * *icmp_sk;
 struct sock *mc_autojoin_sk;

 struct inet_peer_base *peers;
 struct sock * *tcp_sk;
 struct fqdir *fqdir;

 struct xt_table *iptable_filter;
 struct xt_table *iptable_mangle;
 struct xt_table *iptable_raw;
 struct xt_table *arptable_filter;



 struct xt_table *nat_table;


 int sysctl_icmp_echo_ignore_all;
 int sysctl_icmp_echo_ignore_broadcasts;
 int sysctl_icmp_ignore_bogus_error_responses;
 int sysctl_icmp_ratelimit;
 int sysctl_icmp_ratemask;
 int sysctl_icmp_errors_use_inbound_ifaddr;

 struct local_ports ip_local_ports;

 int sysctl_tcp_ecn;
 int sysctl_tcp_ecn_fallback;

 int sysctl_ip_default_ttl;
 int sysctl_ip_no_pmtu_disc;
 int sysctl_ip_fwd_use_pmtu;
 int sysctl_ip_fwd_update_priority;
 int sysctl_ip_nonlocal_bind;

 int sysctl_ip_dynaddr;
 int sysctl_ip_early_demux;



 int sysctl_tcp_early_demux;
 int sysctl_udp_early_demux;

 int sysctl_fwmark_reflect;
 int sysctl_tcp_fwmark_accept;



 int sysctl_tcp_mtu_probing;
 int sysctl_tcp_mtu_probe_floor;
 int sysctl_tcp_base_mss;
 int sysctl_tcp_min_snd_mss;
 int sysctl_tcp_probe_threshold;
 u32 sysctl_tcp_probe_interval;

 int sysctl_tcp_keepalive_time;
 int sysctl_tcp_keepalive_probes;
 int sysctl_tcp_keepalive_intvl;

 int sysctl_tcp_syn_retries;
 int sysctl_tcp_synack_retries;
 int sysctl_tcp_syncookies;
 int sysctl_tcp_reordering;
 int sysctl_tcp_retries1;
 int sysctl_tcp_retries2;
 int sysctl_tcp_orphan_retries;
 int sysctl_tcp_fin_timeout;
 unsigned int sysctl_tcp_notsent_lowat;
 int sysctl_tcp_tw_reuse;
 int sysctl_tcp_sack;
 int sysctl_tcp_window_scaling;
 int sysctl_tcp_timestamps;
 int sysctl_tcp_early_retrans;
 int sysctl_tcp_recovery;
 int sysctl_tcp_thin_linear_timeouts;
 int sysctl_tcp_slow_start_after_idle;
 int sysctl_tcp_retrans_collapse;
 int sysctl_tcp_stdurg;
 int sysctl_tcp_rfc1337;
 int sysctl_tcp_abort_on_overflow;
 int sysctl_tcp_fack;
 int sysctl_tcp_max_reordering;
 int sysctl_tcp_dsack;
 int sysctl_tcp_app_win;
 int sysctl_tcp_adv_win_scale;
 int sysctl_tcp_frto;
 int sysctl_tcp_nometrics_save;
 int sysctl_tcp_no_ssthresh_metrics_save;
 int sysctl_tcp_moderate_rcvbuf;
 int sysctl_tcp_tso_win_divisor;
 int sysctl_tcp_workaround_signed_windows;
 int sysctl_tcp_limit_output_bytes;
 int sysctl_tcp_challenge_ack_limit;
 int sysctl_tcp_min_tso_segs;
 int sysctl_tcp_min_rtt_wlen;
 int sysctl_tcp_autocorking;
 int sysctl_tcp_invalid_ratelimit;
 int sysctl_tcp_pacing_ss_ratio;
 int sysctl_tcp_pacing_ca_ratio;
 int sysctl_tcp_wmem[3];
 int sysctl_tcp_rmem[3];
 int sysctl_tcp_comp_sack_nr;
 unsigned long sysctl_tcp_comp_sack_delay_ns;
 struct inet_timewait_death_row tcp_death_row;
 int sysctl_max_syn_backlog;
 int sysctl_tcp_fastopen;
 const struct tcp_congestion_ops *tcp_congestion_control;
 struct tcp_fastopen_context *tcp_fastopen_ctx;
 spinlock_t tcp_fastopen_ctx_lock;
 unsigned int sysctl_tcp_fastopen_blackhole_timeout;
 atomic_t tfo_active_disable_times;
 unsigned long tfo_active_disable_stamp;

 int sysctl_udp_wmem_min;
 int sysctl_udp_rmem_min;





 int sysctl_igmp_max_memberships;
 int sysctl_igmp_max_msf;
 int sysctl_igmp_llm_reports;
 int sysctl_igmp_qrv;

 struct ping_group_range ping_group_range;

 atomic_t dev_addr_genid;


 unsigned long *sysctl_local_reserved_ports;
 int sysctl_ip_prot_sock;
# 217 "/home/nathan/src/linux-next/include/net/netns/ipv4.h"
 struct fib_notifier_ops *notifier_ops;
 unsigned int fib_seq;

 struct fib_notifier_ops *ipmr_notifier_ops;
 unsigned int ipmr_seq;

 atomic_t rt_genid;
 siphash_key_t ip_id_key;
};
# 21 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/ipv6.h" 1
# 10 "/home/nathan/src/linux-next/include/net/netns/ipv6.h"
# 1 "/home/nathan/src/linux-next/include/net/dst_ops.h" 1







struct dst_entry;
struct kmem_cachep;
struct net_device;
struct sk_buff;
struct sock;
struct net;

struct dst_ops {
 unsigned short family;
 unsigned int gc_thresh;

 int (*gc)(struct dst_ops *ops);
 struct dst_entry * (*check)(struct dst_entry *, __u32 cookie);
 unsigned int (*default_advmss)(const struct dst_entry *);
 unsigned int (*mtu)(const struct dst_entry *);
 u32 * (*cow_metrics)(struct dst_entry *, unsigned long);
 void (*destroy)(struct dst_entry *);
 void (*ifdown)(struct dst_entry *,
       struct net_device *dev, int how);
 struct dst_entry * (*negative_advice)(struct dst_entry *);
 void (*link_failure)(struct sk_buff *);
 void (*update_pmtu)(struct dst_entry *dst, struct sock *sk,
            struct sk_buff *skb, u32 mtu,
            bool confirm_neigh);
 void (*redirect)(struct dst_entry *dst, struct sock *sk,
         struct sk_buff *skb);
 int (*local_out)(struct net *net, struct sock *sk, struct sk_buff *skb);
 struct neighbour * (*neigh_lookup)(const struct dst_entry *dst,
      struct sk_buff *skb,
      const void *daddr);
 void (*confirm_neigh)(const struct dst_entry *dst,
       const void *daddr);

 struct kmem_cache *kmem_cachep;

 struct percpu_counter pcpuc_entries __attribute__((__aligned__((1 << 7))));
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_entries_get_fast(struct dst_ops *dst)
{
 return percpu_counter_read_positive(&dst->pcpuc_entries);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_entries_get_slow(struct dst_ops *dst)
{
 return percpu_counter_sum_positive(&dst->pcpuc_entries);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_entries_add(struct dst_ops *dst, int val)
{
 percpu_counter_add(&dst->pcpuc_entries, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_entries_init(struct dst_ops *dst)
{
 return ({ static struct lock_class_key __key; __percpu_counter_init(&dst->pcpuc_entries, 0, ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)), &__key); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_entries_destroy(struct dst_ops *dst)
{
 percpu_counter_destroy(&dst->pcpuc_entries);
}
# 11 "/home/nathan/src/linux-next/include/net/netns/ipv6.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/icmpv6.h" 1







struct icmp6hdr {

 __u8 icmp6_type;
 __u8 icmp6_code;
 __sum16 icmp6_cksum;


 union {
  __be32 un_data32[1];
  __be16 un_data16[2];
  __u8 un_data8[4];

  struct icmpv6_echo {
   __be16 identifier;
   __be16 sequence;
  } u_echo;

                struct icmpv6_nd_advt {







                        __u32 router:1,
     solicited:1,
                          override:1,
                          reserved:29;



                } u_nd_advt;

                struct icmpv6_nd_ra {
   __u8 hop_limit;
# 52 "/home/nathan/src/linux-next/include/uapi/linux/icmpv6.h"
   __u8 managed:1,
     other:1,
     home_agent:1,
     router_pref:2,
     reserved:3;



   __be16 rt_lifetime;
                } u_nd_ra;

 } icmp6_dataun;
# 80 "/home/nathan/src/linux-next/include/uapi/linux/icmpv6.h"
};
# 156 "/home/nathan/src/linux-next/include/uapi/linux/icmpv6.h"
struct icmp6_filter {
 __u32 data[8];
};
# 12 "/home/nathan/src/linux-next/include/net/netns/ipv6.h" 2

struct ctl_table_header;

struct netns_sysctl_ipv6 {

 struct ctl_table_header *hdr;
 struct ctl_table_header *route_hdr;
 struct ctl_table_header *icmp_hdr;
 struct ctl_table_header *frags_hdr;
 struct ctl_table_header *xfrm6_hdr;

 int bindv6only;
 int flush_delay;
 int ip6_rt_max_size;
 int ip6_rt_gc_min_interval;
 int ip6_rt_gc_timeout;
 int ip6_rt_gc_interval;
 int ip6_rt_gc_elasticity;
 int ip6_rt_mtu_expires;
 int ip6_rt_min_advmss;
 int multipath_hash_policy;
 int flowlabel_consistency;
 int auto_flowlabels;
 int icmpv6_time;
 int icmpv6_echo_ignore_all;
 int icmpv6_echo_ignore_multicast;
 int icmpv6_echo_ignore_anycast;
 unsigned long icmpv6_ratemask[(((255 + 1) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
 unsigned long *icmpv6_ratemask_ptr;
 int anycast_src_echo_reply;
 int ip_nonlocal_bind;
 int fwmark_reflect;
 int idgen_retries;
 int idgen_delay;
 int flowlabel_state_ranges;
 int flowlabel_reflect;
 int max_dst_opts_cnt;
 int max_hbh_opts_cnt;
 int max_dst_opts_len;
 int max_hbh_opts_len;
 int seg6_flowlabel;
 bool skip_notify_on_dev_down;
};

struct netns_ipv6 {
 struct netns_sysctl_ipv6 sysctl;
 struct ipv6_devconf *devconf_all;
 struct ipv6_devconf *devconf_dflt;
 struct inet_peer_base *peers;
 struct fqdir *fqdir;

 struct xt_table *ip6table_filter;
 struct xt_table *ip6table_mangle;
 struct xt_table *ip6table_raw;



 struct xt_table *ip6table_nat;

 struct fib6_info *fib6_null_entry;
 struct rt6_info *ip6_null_entry;
 struct rt6_statistics *rt6_stats;
 struct timer_list ip6_fib_timer;
 struct hlist_head *fib_table_hash;
 struct fib6_table *fib6_main_tbl;
 struct list_head fib6_walkers;
 struct dst_ops ip6_dst_ops;
 rwlock_t fib6_walker_lock;
 spinlock_t fib6_gc_lock;
 unsigned int ip6_rt_gc_expire;
 unsigned long ip6_rt_last_gc;
# 94 "/home/nathan/src/linux-next/include/net/netns/ipv6.h"
 struct sock * *icmp_sk;
 struct sock *ndisc_sk;
 struct sock *tcp_sk;
 struct sock *igmp_sk;
 struct sock *mc_autojoin_sk;
# 107 "/home/nathan/src/linux-next/include/net/netns/ipv6.h"
 atomic_t dev_addr_genid;
 atomic_t fib6_sernum;
 struct seg6_pernet_data *seg6_data;
 struct fib_notifier_ops *notifier_ops;
 struct fib_notifier_ops *ip6mr_notifier_ops;
 unsigned int ipmr_seq;
 struct {
  struct hlist_head head;
  spinlock_t lock;
  u32 seq;
 } ip6addrlbl_table;
};


struct netns_nf_frag {
 struct fqdir *fqdir;
};
# 22 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/nexthop.h" 1
# 11 "/home/nathan/src/linux-next/include/net/netns/nexthop.h"
struct netns_nexthop {
 struct rb_root rb_root;
 struct hlist_head *devhash;

 unsigned int seq;
 u32 last_id_allocated;
};
# 23 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/ieee802154_6lowpan.h" 1
# 11 "/home/nathan/src/linux-next/include/net/netns/ieee802154_6lowpan.h"
struct netns_sysctl_lowpan {

 struct ctl_table_header *frags_hdr;

};

struct netns_ieee802154_lowpan {
 struct netns_sysctl_lowpan sysctl;
 struct fqdir *fqdir;
};
# 24 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/sctp.h" 1




struct sock;
struct proc_dir_entry;
struct sctp_mib;
struct ctl_table_header;

struct netns_sctp {
 __typeof__(struct sctp_mib) *sctp_statistics;


 struct proc_dir_entry *proc_net_sctp;


 struct ctl_table_header *sysctl_header;





 struct sock *ctl_sock;







 struct list_head local_addr_list;
 struct list_head addr_waitq;
 struct timer_list addr_wq_timer;
 struct list_head auto_asconf_splist;

 spinlock_t addr_wq_lock;


 spinlock_t local_addr_lock;
# 51 "/home/nathan/src/linux-next/include/net/netns/sctp.h"
 unsigned int rto_initial;
 unsigned int rto_min;
 unsigned int rto_max;




 int rto_alpha;
 int rto_beta;


 int max_burst;


 int cookie_preserve_enable;


 char *sctp_hmac_alg;


 unsigned int valid_cookie_life;


 unsigned int sack_timeout;


 unsigned int hb_interval;





 int max_retrans_association;
 int max_retrans_path;
 int max_retrans_init;




 int pf_retrans;





 int ps_retrans;






 int pf_enable;







 int pf_expose;






 int sndbuf_policy;






 int rcvbuf_policy;

 int default_auto_asconf;


 int addip_enable;
 int addip_noauth;


 int prsctp_enable;


 int reconf_enable;


 int auth_enable;


 int intl_enable;


 int ecn_enable;
# 155 "/home/nathan/src/linux-next/include/net/netns/sctp.h"
 int scope_policy;




 int rwnd_upd_shift;


 unsigned long max_autoclose;
};
# 25 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/dccp.h" 1




struct sock;

struct netns_dccp {
 struct sock *v4_ctl_sk;
 struct sock *v6_ctl_sk;
};
# 26 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/netfilter.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/netfilter_defs.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/netfilter.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/in.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/in.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/in.h" 1
# 28 "/home/nathan/src/linux-next/include/uapi/linux/in.h"
enum {
  IPPROTO_IP = 0,

  IPPROTO_ICMP = 1,

  IPPROTO_IGMP = 2,

  IPPROTO_IPIP = 4,

  IPPROTO_TCP = 6,

  IPPROTO_EGP = 8,

  IPPROTO_PUP = 12,

  IPPROTO_UDP = 17,

  IPPROTO_IDP = 22,

  IPPROTO_TP = 29,

  IPPROTO_DCCP = 33,

  IPPROTO_IPV6 = 41,

  IPPROTO_RSVP = 46,

  IPPROTO_GRE = 47,

  IPPROTO_ESP = 50,

  IPPROTO_AH = 51,

  IPPROTO_MTP = 92,

  IPPROTO_BEETPH = 94,

  IPPROTO_ENCAP = 98,

  IPPROTO_PIM = 103,

  IPPROTO_COMP = 108,

  IPPROTO_SCTP = 132,

  IPPROTO_UDPLITE = 136,

  IPPROTO_MPLS = 137,

  IPPROTO_RAW = 255,

  IPPROTO_MPTCP = 262,

  IPPROTO_MAX
};




struct in_addr {
 __be32 s_addr;
};
# 170 "/home/nathan/src/linux-next/include/uapi/linux/in.h"
struct ip_mreq {
 struct in_addr imr_multiaddr;
 struct in_addr imr_interface;
};

struct ip_mreqn {
 struct in_addr imr_multiaddr;
 struct in_addr imr_address;
 int imr_ifindex;
};

struct ip_mreq_source {
 __be32 imr_multiaddr;
 __be32 imr_interface;
 __be32 imr_sourceaddr;
};

struct ip_msfilter {
 __be32 imsf_multiaddr;
 __be32 imsf_interface;
 __u32 imsf_fmode;
 __u32 imsf_numsrc;
 __be32 imsf_slist[1];
};





struct group_req {
 __u32 gr_interface;
 struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
 __u32 gsr_interface;
 struct __kernel_sockaddr_storage gsr_group;
 struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
 __u32 gf_interface;
 struct __kernel_sockaddr_storage gf_group;
 __u32 gf_fmode;
 __u32 gf_numsrc;
 struct __kernel_sockaddr_storage gf_slist[1];
};







struct in_pktinfo {
 int ipi_ifindex;
 struct in_addr ipi_spec_dst;
 struct in_addr ipi_addr;
};





struct sockaddr_in {
  __kernel_sa_family_t sin_family;
  __be16 sin_port;
  struct in_addr sin_addr;


  unsigned char __pad[16 - sizeof(short int) -
   sizeof(unsigned short int) - sizeof(struct in_addr)];
};
# 20 "/home/nathan/src/linux-next/include/linux/in.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int proto_ports_offset(int proto)
{
 switch (proto) {
 case IPPROTO_TCP:
 case IPPROTO_UDP:
 case IPPROTO_DCCP:
 case IPPROTO_ESP:
 case IPPROTO_SCTP:
 case IPPROTO_UDPLITE:
  return 0;
 case IPPROTO_AH:
  return 4;
 default:
  return -22;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_loopback(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xff000000))) == (( __be32)(__u32)(0x7f000000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_multicast(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xf0000000))) == (( __be32)(__u32)(0xe0000000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_local_multicast(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xffffff00))) == (( __be32)(__u32)(0xe0000000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_lbcast(__be32 addr)
{

 return addr == (( __be32)(__u32)(((unsigned long int) 0xffffffff)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_all_snoopers(__be32 addr)
{
 return addr == (( __be32)(__u32)(0xe000006aU));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_zeronet(__be32 addr)
{
 return (addr == 0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_private_10(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xff000000))) == (( __be32)(__u32)(0x0a000000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_private_172(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xfff00000))) == (( __be32)(__u32)(0xac100000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_private_192(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xffff0000))) == (( __be32)(__u32)(0xc0a80000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_linklocal_169(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xffff0000))) == (( __be32)(__u32)(0xa9fe0000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_anycast_6to4(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xffffff00))) == (( __be32)(__u32)(0xc0586300));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_test_192(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xffffff00))) == (( __be32)(__u32)(0xc0000200));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_is_test_198(__be32 addr)
{
 return (addr & (( __be32)(__u32)(0xfffe0000))) == (( __be32)(__u32)(0xc6120000));
}
# 8 "/home/nathan/src/linux-next/include/uapi/linux/netfilter.h" 2
# 42 "/home/nathan/src/linux-next/include/uapi/linux/netfilter.h"
enum nf_inet_hooks {
 NF_INET_PRE_ROUTING,
 NF_INET_LOCAL_IN,
 NF_INET_FORWARD,
 NF_INET_LOCAL_OUT,
 NF_INET_POST_ROUTING,
 NF_INET_NUMHOOKS
};

enum nf_dev_hooks {
 NF_NETDEV_INGRESS,
 NF_NETDEV_NUMHOOKS
};

enum {
 NFPROTO_UNSPEC = 0,
 NFPROTO_INET = 1,
 NFPROTO_IPV4 = 2,
 NFPROTO_ARP = 3,
 NFPROTO_NETDEV = 5,
 NFPROTO_BRIDGE = 7,
 NFPROTO_IPV6 = 10,
 NFPROTO_DECNET = 12,
 NFPROTO_NUMPROTO,
};

union nf_inet_addr {
 __u32 all[4];
 __be32 ip;
 __be32 ip6[4];
 struct in_addr in;
 struct in6_addr in6;
};
# 6 "/home/nathan/src/linux-next/include/linux/netfilter_defs.h" 2
# 6 "/home/nathan/src/linux-next/include/net/netns/netfilter.h" 2

struct proc_dir_entry;
struct nf_logger;
struct nf_queue_handler;

struct netns_nf {

 struct proc_dir_entry *proc_netfilter;

 const struct nf_queue_handler *queue_handler;
 const struct nf_logger *nf_loggers[NFPROTO_NUMPROTO];

 struct ctl_table_header *nf_log_dir_header;

 struct nf_hook_entries *hooks_ipv4[NF_INET_NUMHOOKS];
 struct nf_hook_entries *hooks_ipv6[NF_INET_NUMHOOKS];
# 32 "/home/nathan/src/linux-next/include/net/netns/netfilter.h"
 bool defrag_ipv4;


 bool defrag_ipv6;

};
# 27 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/x_tables.h" 1







struct ebt_table;

struct netns_xt {
 struct list_head tables[NFPROTO_NUMPROTO];
 bool notrack_deprecated_warning;
 bool clusterip_deprecated_warning;






};
# 28 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2

# 1 "/home/nathan/src/linux-next/include/net/netns/conntrack.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/list_nulls.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/list_nulls.h"
struct hlist_nulls_head {
 struct hlist_nulls_node *first;
};

struct hlist_nulls_node {
 struct hlist_nulls_node *next, **pprev;
};
# 43 "/home/nathan/src/linux-next/include/linux/list_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_a_nulls(const struct hlist_nulls_node *ptr)
{
 return ((unsigned long)ptr & 1);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long get_nulls_value(const struct hlist_nulls_node *ptr)
{
 return ((unsigned long)ptr) >> 1;
}
# 67 "/home/nathan/src/linux-next/include/linux/list_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_nulls_unhashed(const struct hlist_nulls_node *h)
{
 return !h->pprev;
}
# 81 "/home/nathan/src/linux-next/include/linux/list_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_nulls_unhashed_lockless(const struct hlist_nulls_node *h)
{
 return !({ union { typeof(h->pprev) __val; char __c[1]; } __u; if (1) __read_once_size(&(h->pprev), __u.__c, sizeof(h->pprev)); else __read_once_size_nocheck(&(h->pprev), __u.__c, sizeof(h->pprev)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hlist_nulls_empty(const struct hlist_nulls_head *h)
{
 return is_a_nulls(({ union { typeof(h->first) __val; char __c[1]; } __u; if (1) __read_once_size(&(h->first), __u.__c, sizeof(h->first)); else __read_once_size_nocheck(&(h->first), __u.__c, sizeof(h->first)); do { } while (0); __u.__val; }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_add_head(struct hlist_nulls_node *n,
     struct hlist_nulls_head *h)
{
 struct hlist_nulls_node *first = h->first;

 n->next = first;
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&h->first) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 h->first = n;
 if (!is_a_nulls(first))
  ({ union { typeof(first->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(first->pprev)) (&n->next) }; __write_once_size(&(first->pprev), __u.__c, sizeof(first->pprev)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hlist_nulls_del(struct hlist_nulls_node *n)
{
 struct hlist_nulls_node *next = n->next;
 struct hlist_nulls_node **pprev = n->pprev;

 ({ union { typeof(*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*pprev)) (next) }; __write_once_size(&(*pprev), __u.__c, sizeof(*pprev)); __u.__val; });
 if (!is_a_nulls(next))
  ({ union { typeof(next->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(next->pprev)) (pprev) }; __write_once_size(&(next->pprev), __u.__c, sizeof(next->pprev)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_del(struct hlist_nulls_node *n)
{
 __hlist_nulls_del(n);
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (((void *) 0x122 + (0x5deadbeef0000000UL))) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
}
# 7 "/home/nathan/src/linux-next/include/net/netns/conntrack.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/netfilter/nf_conntrack_tcp.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/netfilter/nf_conntrack_tcp.h" 1








enum tcp_conntrack {
 TCP_CONNTRACK_NONE,
 TCP_CONNTRACK_SYN_SENT,
 TCP_CONNTRACK_SYN_RECV,
 TCP_CONNTRACK_ESTABLISHED,
 TCP_CONNTRACK_FIN_WAIT,
 TCP_CONNTRACK_CLOSE_WAIT,
 TCP_CONNTRACK_LAST_ACK,
 TCP_CONNTRACK_TIME_WAIT,
 TCP_CONNTRACK_CLOSE,
 TCP_CONNTRACK_LISTEN,

 TCP_CONNTRACK_MAX,
 TCP_CONNTRACK_IGNORE,
 TCP_CONNTRACK_RETRANS,
 TCP_CONNTRACK_UNACK,
 TCP_CONNTRACK_TIMEOUT_MAX
};
# 52 "/home/nathan/src/linux-next/include/uapi/linux/netfilter/nf_conntrack_tcp.h"
struct nf_ct_tcp_flags {
 __u8 flags;
 __u8 mask;
};
# 6 "/home/nathan/src/linux-next/include/linux/netfilter/nf_conntrack_tcp.h" 2


struct ip_ct_tcp_state {
 u_int32_t td_end;
 u_int32_t td_maxend;
 u_int32_t td_maxwin;
 u_int32_t td_maxack;
 u_int8_t td_scale;
 u_int8_t flags;
};

struct ip_ct_tcp {
 struct ip_ct_tcp_state seen[2];
 u_int8_t state;

 u_int8_t last_dir;
 u_int8_t retrans;
 u_int8_t last_index;
 u_int32_t last_seq;
 u_int32_t last_ack;
 u_int32_t last_end;
 u_int16_t last_win;

 u_int8_t last_wscale;
 u_int8_t last_flags;
};
# 10 "/home/nathan/src/linux-next/include/net/netns/conntrack.h" 2








struct ctl_table_header;
struct nf_conntrack_ecache;

struct nf_generic_net {
 unsigned int timeout;
};

struct nf_tcp_net {
 unsigned int timeouts[TCP_CONNTRACK_TIMEOUT_MAX];
 int tcp_loose;
 int tcp_be_liberal;
 int tcp_max_retrans;
};

enum udp_conntrack {
 UDP_CT_UNREPLIED,
 UDP_CT_REPLIED,
 UDP_CT_MAX
};

struct nf_udp_net {
 unsigned int timeouts[UDP_CT_MAX];
};

struct nf_icmp_net {
 unsigned int timeout;
};
# 72 "/home/nathan/src/linux-next/include/net/netns/conntrack.h"
struct nf_ip_net {
 struct nf_generic_net generic;
 struct nf_tcp_net tcp;
 struct nf_udp_net udp;
 struct nf_icmp_net icmp;
 struct nf_icmp_net icmpv6;
# 87 "/home/nathan/src/linux-next/include/net/netns/conntrack.h"
};

struct ct_pcpu {
 spinlock_t lock;
 struct hlist_nulls_head unconfirmed;
 struct hlist_nulls_head dying;
};

struct netns_ct {
 atomic_t count;
 unsigned int expect_count;




 bool auto_assign_helper_warned;

 struct ctl_table_header *sysctl_header;

 unsigned int sysctl_log_invalid;
 int sysctl_events;
 int sysctl_acct;
 int sysctl_auto_assign_helper;
 int sysctl_tstamp;
 int sysctl_checksum;

 struct ct_pcpu *pcpu_lists;
 struct ip_conntrack_stat *stat;
 struct nf_ct_event_notifier *nf_conntrack_event_cb;
 struct nf_exp_event_notifier *nf_expect_event_cb;
 struct nf_ip_net nf_ct_proto;



};
# 30 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2

# 1 "/home/nathan/src/linux-next/include/net/netns/nftables.h" 1






struct netns_nftables {
 struct list_head tables;
 struct list_head commit_list;
 struct list_head module_list;
 struct mutex commit_mutex;
 unsigned int base_seq;
 u8 gencursor;
 u8 validate_state;
};
# 32 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/xfrm.h" 1








# 1 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h" 1
# 15 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
typedef union {
 __be32 a4;
 __be32 a6[4];
 struct in6_addr in6;
} xfrm_address_t;





struct xfrm_id {
 xfrm_address_t daddr;
 __be32 spi;
 __u8 proto;
};

struct xfrm_sec_ctx {
 __u8 ctx_doi;
 __u8 ctx_alg;
 __u16 ctx_len;
 __u32 ctx_sid;
 char ctx_str[0];
};
# 49 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
struct xfrm_selector {
 xfrm_address_t daddr;
 xfrm_address_t saddr;
 __be16 dport;
 __be16 dport_mask;
 __be16 sport;
 __be16 sport_mask;
 __u16 family;
 __u8 prefixlen_d;
 __u8 prefixlen_s;
 __u8 proto;
 int ifindex;
 __kernel_uid32_t user;
};



struct xfrm_lifetime_cfg {
 __u64 soft_byte_limit;
 __u64 hard_byte_limit;
 __u64 soft_packet_limit;
 __u64 hard_packet_limit;
 __u64 soft_add_expires_seconds;
 __u64 hard_add_expires_seconds;
 __u64 soft_use_expires_seconds;
 __u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
 __u64 bytes;
 __u64 packets;
 __u64 add_time;
 __u64 use_time;
};

struct xfrm_replay_state {
 __u32 oseq;
 __u32 seq;
 __u32 bitmap;
};



struct xfrm_replay_state_esn {
 unsigned int bmp_len;
 __u32 oseq;
 __u32 seq;
 __u32 oseq_hi;
 __u32 seq_hi;
 __u32 replay_window;
 __u32 bmp[0];
};

struct xfrm_algo {
 char alg_name[64];
 unsigned int alg_key_len;
 char alg_key[0];
};

struct xfrm_algo_auth {
 char alg_name[64];
 unsigned int alg_key_len;
 unsigned int alg_trunc_len;
 char alg_key[0];
};

struct xfrm_algo_aead {
 char alg_name[64];
 unsigned int alg_key_len;
 unsigned int alg_icv_len;
 char alg_key[0];
};

struct xfrm_stats {
 __u32 replay_window;
 __u32 replay;
 __u32 integrity_failed;
};

enum {
 XFRM_POLICY_TYPE_MAIN = 0,
 XFRM_POLICY_TYPE_SUB = 1,
 XFRM_POLICY_TYPE_MAX = 2,
 XFRM_POLICY_TYPE_ANY = 255
};

enum {
 XFRM_POLICY_IN = 0,
 XFRM_POLICY_OUT = 1,
 XFRM_POLICY_FWD = 2,
 XFRM_POLICY_MASK = 3,
 XFRM_POLICY_MAX = 3
};

enum {
 XFRM_SHARE_ANY,
 XFRM_SHARE_SESSION,
 XFRM_SHARE_USER,
 XFRM_SHARE_UNIQUE
};
# 158 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
enum {
 XFRM_MSG_BASE = 0x10,

 XFRM_MSG_NEWSA = 0x10,

 XFRM_MSG_DELSA,

 XFRM_MSG_GETSA,


 XFRM_MSG_NEWPOLICY,

 XFRM_MSG_DELPOLICY,

 XFRM_MSG_GETPOLICY,


 XFRM_MSG_ALLOCSPI,

 XFRM_MSG_ACQUIRE,

 XFRM_MSG_EXPIRE,


 XFRM_MSG_UPDPOLICY,

 XFRM_MSG_UPDSA,


 XFRM_MSG_POLEXPIRE,


 XFRM_MSG_FLUSHSA,

 XFRM_MSG_FLUSHPOLICY,


 XFRM_MSG_NEWAE,

 XFRM_MSG_GETAE,


 XFRM_MSG_REPORT,


 XFRM_MSG_MIGRATE,


 XFRM_MSG_NEWSADINFO,

 XFRM_MSG_GETSADINFO,


 XFRM_MSG_NEWSPDINFO,

 XFRM_MSG_GETSPDINFO,


 XFRM_MSG_MAPPING,

 __XFRM_MSG_MAX
};
# 228 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
struct xfrm_user_sec_ctx {
 __u16 len;
 __u16 exttype;
 __u8 ctx_alg;
 __u8 ctx_doi;
 __u16 ctx_len;
};

struct xfrm_user_tmpl {
 struct xfrm_id id;
 __u16 family;
 xfrm_address_t saddr;
 __u32 reqid;
 __u8 mode;
 __u8 share;
 __u8 optional;
 __u32 aalgos;
 __u32 ealgos;
 __u32 calgos;
};

struct xfrm_encap_tmpl {
 __u16 encap_type;
 __be16 encap_sport;
 __be16 encap_dport;
 xfrm_address_t encap_oa;
};


enum xfrm_ae_ftype_t {
 XFRM_AE_UNSPEC,
 XFRM_AE_RTHR=1,
 XFRM_AE_RVAL=2,
 XFRM_AE_LVAL=4,
 XFRM_AE_ETHR=8,
 XFRM_AE_CR=16,
 XFRM_AE_CE=32,
 XFRM_AE_CU=64,
 __XFRM_AE_MAX


};

struct xfrm_userpolicy_type {
 __u8 type;
 __u16 reserved1;
 __u8 reserved2;
};


enum xfrm_attr_type_t {
 XFRMA_UNSPEC,
 XFRMA_ALG_AUTH,
 XFRMA_ALG_CRYPT,
 XFRMA_ALG_COMP,
 XFRMA_ENCAP,
 XFRMA_TMPL,
 XFRMA_SA,
 XFRMA_POLICY,
 XFRMA_SEC_CTX,
 XFRMA_LTIME_VAL,
 XFRMA_REPLAY_VAL,
 XFRMA_REPLAY_THRESH,
 XFRMA_ETIMER_THRESH,
 XFRMA_SRCADDR,
 XFRMA_COADDR,
 XFRMA_LASTUSED,
 XFRMA_POLICY_TYPE,
 XFRMA_MIGRATE,
 XFRMA_ALG_AEAD,
 XFRMA_KMADDRESS,
 XFRMA_ALG_AUTH_TRUNC,
 XFRMA_MARK,
 XFRMA_TFCPAD,
 XFRMA_REPLAY_ESN_VAL,
 XFRMA_SA_EXTRA_FLAGS,
 XFRMA_PROTO,
 XFRMA_ADDRESS_FILTER,
 XFRMA_PAD,
 XFRMA_OFFLOAD_DEV,
 XFRMA_SET_MARK,
 XFRMA_SET_MARK_MASK,
 XFRMA_IF_ID,
 __XFRMA_MAX



};

struct xfrm_mark {
 __u32 v;
 __u32 m;
};

enum xfrm_sadattr_type_t {
 XFRMA_SAD_UNSPEC,
 XFRMA_SAD_CNT,
 XFRMA_SAD_HINFO,
 __XFRMA_SAD_MAX


};

struct xfrmu_sadhinfo {
 __u32 sadhcnt;
 __u32 sadhmcnt;
};

enum xfrm_spdattr_type_t {
 XFRMA_SPD_UNSPEC,
 XFRMA_SPD_INFO,
 XFRMA_SPD_HINFO,
 XFRMA_SPD_IPV4_HTHRESH,
 XFRMA_SPD_IPV6_HTHRESH,
 __XFRMA_SPD_MAX


};

struct xfrmu_spdinfo {
 __u32 incnt;
 __u32 outcnt;
 __u32 fwdcnt;
 __u32 inscnt;
 __u32 outscnt;
 __u32 fwdscnt;
};

struct xfrmu_spdhinfo {
 __u32 spdhcnt;
 __u32 spdhmcnt;
};

struct xfrmu_spdhthresh {
 __u8 lbits;
 __u8 rbits;
};

struct xfrm_usersa_info {
 struct xfrm_selector sel;
 struct xfrm_id id;
 xfrm_address_t saddr;
 struct xfrm_lifetime_cfg lft;
 struct xfrm_lifetime_cur curlft;
 struct xfrm_stats stats;
 __u32 seq;
 __u32 reqid;
 __u16 family;
 __u8 mode;
 __u8 replay_window;
 __u8 flags;
# 387 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
};



struct xfrm_usersa_id {
 xfrm_address_t daddr;
 __be32 spi;
 __u16 family;
 __u8 proto;
};

struct xfrm_aevent_id {
 struct xfrm_usersa_id sa_id;
 xfrm_address_t saddr;
 __u32 flags;
 __u32 reqid;
};

struct xfrm_userspi_info {
 struct xfrm_usersa_info info;
 __u32 min;
 __u32 max;
};

struct xfrm_userpolicy_info {
 struct xfrm_selector sel;
 struct xfrm_lifetime_cfg lft;
 struct xfrm_lifetime_cur curlft;
 __u32 priority;
 __u32 index;
 __u8 dir;
 __u8 action;


 __u8 flags;



 __u8 share;
};

struct xfrm_userpolicy_id {
 struct xfrm_selector sel;
 __u32 index;
 __u8 dir;
};

struct xfrm_user_acquire {
 struct xfrm_id id;
 xfrm_address_t saddr;
 struct xfrm_selector sel;
 struct xfrm_userpolicy_info policy;
 __u32 aalgos;
 __u32 ealgos;
 __u32 calgos;
 __u32 seq;
};

struct xfrm_user_expire {
 struct xfrm_usersa_info state;
 __u8 hard;
};

struct xfrm_user_polexpire {
 struct xfrm_userpolicy_info pol;
 __u8 hard;
};

struct xfrm_usersa_flush {
 __u8 proto;
};

struct xfrm_user_report {
 __u8 proto;
 struct xfrm_selector sel;
};



struct xfrm_user_kmaddress {
 xfrm_address_t local;
 xfrm_address_t remote;
 __u32 reserved;
 __u16 family;
};

struct xfrm_user_migrate {
 xfrm_address_t old_daddr;
 xfrm_address_t old_saddr;
 xfrm_address_t new_daddr;
 xfrm_address_t new_saddr;
 __u8 proto;
 __u8 mode;
 __u16 reserved;
 __u32 reqid;
 __u16 old_family;
 __u16 new_family;
};

struct xfrm_user_mapping {
 struct xfrm_usersa_id id;
 __u32 reqid;
 xfrm_address_t old_saddr;
 xfrm_address_t new_saddr;
 __be16 old_sport;
 __be16 new_sport;
};

struct xfrm_address_filter {
 xfrm_address_t saddr;
 xfrm_address_t daddr;
 __u16 family;
 __u8 splen;
 __u8 dplen;
};

struct xfrm_user_offload {
 int ifindex;
 __u8 flags;
};
# 519 "/home/nathan/src/linux-next/include/uapi/linux/xfrm.h"
enum xfrm_nlgroups {
 XFRMNLGRP_NONE,

 XFRMNLGRP_ACQUIRE,

 XFRMNLGRP_EXPIRE,

 XFRMNLGRP_SA,

 XFRMNLGRP_POLICY,

 XFRMNLGRP_AEVENTS,

 XFRMNLGRP_REPORT,

 XFRMNLGRP_MIGRATE,

 XFRMNLGRP_MAPPING,

 __XFRMNLGRP_MAX
};
# 10 "/home/nathan/src/linux-next/include/net/netns/xfrm.h" 2


struct ctl_table_header;

struct xfrm_policy_hash {
 struct hlist_head *table;
 unsigned int hmask;
 u8 dbits4;
 u8 sbits4;
 u8 dbits6;
 u8 sbits6;
};

struct xfrm_policy_hthresh {
 struct work_struct work;
 seqlock_t lock;
 u8 lbits4;
 u8 rbits4;
 u8 lbits6;
 u8 rbits6;
};

struct netns_xfrm {
 struct list_head state_all;
# 42 "/home/nathan/src/linux-next/include/net/netns/xfrm.h"
 struct hlist_head *state_bydst;
 struct hlist_head *state_bysrc;
 struct hlist_head *state_byspi;
 unsigned int state_hmask;
 unsigned int state_num;
 struct work_struct state_hash_work;

 struct list_head policy_all;
 struct hlist_head *policy_byidx;
 unsigned int policy_idx_hmask;
 struct hlist_head policy_inexact[XFRM_POLICY_MAX];
 struct xfrm_policy_hash policy_bydst[XFRM_POLICY_MAX];
 unsigned int policy_count[XFRM_POLICY_MAX * 2];
 struct work_struct policy_hash_work;
 struct xfrm_policy_hthresh policy_hthresh;
 struct list_head inexact_bins;


 struct sock *nlsk;
 struct sock *nlsk_stash;

 u32 sysctl_aevent_etime;
 u32 sysctl_aevent_rseqth;
 int sysctl_larval_drop;
 u32 sysctl_acq_expires;

 struct ctl_table_header *sysctl_hdr;


 struct dst_ops xfrm4_dst_ops;

 struct dst_ops xfrm6_dst_ops;

 spinlock_t xfrm_state_lock;
 spinlock_t xfrm_policy_lock;
 struct mutex xfrm_cfg_mutex;
};
# 33 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/mpls.h" 1








struct mpls_route;
struct ctl_table_header;

struct netns_mpls {
 int ip_ttl_propagate;
 int default_ttl;
 size_t platform_labels;
 struct mpls_route * *platform_label;

 struct ctl_table_header *ctl;
};
# 34 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/can.h" 1
# 11 "/home/nathan/src/linux-next/include/net/netns/can.h"
struct can_dev_rcv_lists;
struct can_pkg_stats;
struct can_rcv_lists_stats;

struct netns_can {

 struct proc_dir_entry *proc_dir;
 struct proc_dir_entry *pde_version;
 struct proc_dir_entry *pde_stats;
 struct proc_dir_entry *pde_reset_stats;
 struct proc_dir_entry *pde_rcvlist_all;
 struct proc_dir_entry *pde_rcvlist_fil;
 struct proc_dir_entry *pde_rcvlist_inv;
 struct proc_dir_entry *pde_rcvlist_sff;
 struct proc_dir_entry *pde_rcvlist_eff;
 struct proc_dir_entry *pde_rcvlist_err;
 struct proc_dir_entry *bcmproc_dir;



 struct can_dev_rcv_lists *rx_alldev_list;
 spinlock_t rcvlists_lock;
 struct timer_list stattimer;
 struct can_pkg_stats *pkg_stats;
 struct can_rcv_lists_stats *rcv_lists_stats;


 struct hlist_head cgw_list;
};
# 35 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/xdp.h" 1







struct netns_xdp {
 struct mutex lock;
 struct hlist_head list;
};
# 36 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/ns_common.h" 1




struct proc_ns_operations;

struct ns_common {
 atomic_long_t stashed;
 const struct proc_ns_operations *ops;
 unsigned int inum;
};
# 37 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2




struct user_namespace;
struct proc_dir_entry;
struct net_device;
struct sock;
struct ctl_table_header;
struct net_generic;
struct uevent_sock;
struct netns_ipvs;
struct bpf_prog;





struct net {



 refcount_t passive;


 refcount_t count;


 spinlock_t rules_mod_lock;

 unsigned int dev_unreg_count;

 unsigned int dev_base_seq;
 int ifindex;

 spinlock_t nsid_lock;
 atomic_t fnhe_genid;

 struct list_head list;
 struct list_head exit_list;





 struct llist_node cleanup_list;


 struct key_tag *key_domain;

 struct user_namespace *user_ns;
 struct ucounts *ucounts;
 struct idr netns_ids;

 struct ns_common ns;

 struct list_head dev_base_head;
 struct proc_dir_entry *proc_net;
 struct proc_dir_entry *proc_net_stat;


 struct ctl_table_set sysctls;


 struct sock *rtnl;
 struct sock *genl_sock;

 struct uevent_sock *uevent_sock;

 struct hlist_head *dev_name_head;
 struct hlist_head *dev_index_head;
 struct raw_notifier_head netdev_chain;




 u32 hash_mix;

 struct net_device *loopback_dev;


 struct list_head rules_ops;

 struct netns_core core;
 struct netns_mib mib;
 struct netns_packet packet;
 struct netns_unix unx;
 struct netns_nexthop nexthop;
 struct netns_ipv4 ipv4;

 struct netns_ipv6 ipv6;
# 139 "/home/nathan/src/linux-next/include/net/net_namespace.h"
 struct netns_nf nf;
 struct netns_xt xt;

 struct netns_ct ct;





 struct netns_nf_frag nf_frag;
 struct ctl_table_header *nf_frag_frags_hdr;

 struct sock *nfnl;
 struct sock *nfnl_stash;
# 161 "/home/nathan/src/linux-next/include/net/net_namespace.h"
 struct sk_buff_head wext_nlevents;

 struct net_generic *gen;

 struct bpf_prog *flow_dissector_prog;



 struct netns_xfrm xfrm;
# 186 "/home/nathan/src/linux-next/include/net/net_namespace.h"
 struct sock *diag_nlsk;
} ;


# 1 "/home/nathan/src/linux-next/include/linux/seq_file_net.h" 1






struct net;
extern struct net init_net;

struct seq_net_private {

 struct net *net;

};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *seq_file_net(struct seq_file *seq)
{

 return ((struct seq_net_private *)seq->private)->net;



}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *seq_file_single_net(struct seq_file *seq)
{

 return (struct net *)seq->private;



}
# 190 "/home/nathan/src/linux-next/include/net/net_namespace.h" 2


extern struct net init_net;


struct net *copy_net_ns(unsigned long flags, struct user_namespace *user_ns,
   struct net *old_net);

void net_ns_get_ownership(const struct net *net, kuid_t *uid, kgid_t *gid);

void net_ns_barrier(void);
# 223 "/home/nathan/src/linux-next/include/net/net_namespace.h"
extern struct list_head net_namespace_list;

struct net *get_net_ns_by_pid(pid_t pid);
struct net *get_net_ns_by_fd(int fd);


void ipx_register_sysctl(void);
void ipx_unregister_sysctl(void);






void __put_net(struct net *net);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *get_net(struct net *net)
{
 refcount_inc(&net->count);
 return net;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *maybe_get_net(struct net *net)
{





 if (!refcount_inc_not_zero(&net->count))
  net = ((void *)0);
 return net;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_net(struct net *net)
{
 if (refcount_dec_and_test(&net->count))
  __put_net(net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int net_eq(const struct net *net1, const struct net *net2)
{
 return net1 == net2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int check_net(const struct net *net)
{
 return refcount_read(&net->count) != 0;
}

void net_drop_ns(void *);
# 307 "/home/nathan/src/linux-next/include/net/net_namespace.h"
typedef struct {

 struct net *net;

} possible_net_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void write_pnet(possible_net_t *pnet, struct net *net)
{

 pnet->net = net;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *read_pnet(const possible_net_t *pnet)
{

 return pnet->net;



}
# 349 "/home/nathan/src/linux-next/include/net/net_namespace.h"
int peernet2id_alloc(struct net *net, struct net *peer, gfp_t gfp);
int peernet2id(const struct net *net, struct net *peer);
bool peernet_has_id(const struct net *net, struct net *peer);
struct net *get_net_ns_by_id(const struct net *net, int id);

struct pernet_operations {
 struct list_head list;
# 378 "/home/nathan/src/linux-next/include/net/net_namespace.h"
 int (*init)(struct net *net);
 void (*pre_exit)(struct net *net);
 void (*exit)(struct net *net);
 void (*exit_batch)(struct list_head *net_exit_list);
 unsigned int *id;
 size_t size;
};
# 405 "/home/nathan/src/linux-next/include/net/net_namespace.h"
int register_pernet_subsys(struct pernet_operations *);
void unregister_pernet_subsys(struct pernet_operations *);
int register_pernet_device(struct pernet_operations *);
void unregister_pernet_device(struct pernet_operations *);

struct ctl_table;
struct ctl_table_header;


int net_sysctl_init(void);
struct ctl_table_header *register_net_sysctl(struct net *net, const char *path,
          struct ctl_table *table);
void unregister_net_sysctl_table(struct ctl_table_header *header);
# 430 "/home/nathan/src/linux-next/include/net/net_namespace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rt_genid_ipv4(const struct net *net)
{
 return atomic_read(&net->ipv4.rt_genid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rt_genid_bump_ipv4(struct net *net)
{
 atomic_inc(&net->ipv4.rt_genid);
}

extern void (*__fib6_flush_trees)(struct net *net);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rt_genid_bump_ipv6(struct net *net)
{
 if (__fib6_flush_trees)
  __fib6_flush_trees(net);
}
# 456 "/home/nathan/src/linux-next/include/net/net_namespace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rt_genid_bump_all(struct net *net)
{
 rt_genid_bump_ipv4(net);
 rt_genid_bump_ipv6(net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fnhe_genid(const struct net *net)
{
 return atomic_read(&net->fnhe_genid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fnhe_genid_bump(struct net *net)
{
 atomic_inc(&net->fnhe_genid);
}
# 39 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2



# 1 "/home/nathan/src/linux-next/include/net/netprio_cgroup.h" 1
# 11 "/home/nathan/src/linux-next/include/net/netprio_cgroup.h"
# 1 "/home/nathan/src/linux-next/include/linux/cgroup.h" 1
# 16 "/home/nathan/src/linux-next/include/linux/cgroup.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/cgroupstats.h" 1
# 20 "/home/nathan/src/linux-next/include/uapi/linux/cgroupstats.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/taskstats.h" 1
# 41 "/home/nathan/src/linux-next/include/uapi/linux/taskstats.h"
struct taskstats {





 __u16 version;
 __u32 ac_exitcode;




 __u8 ac_flag;
 __u8 ac_nice;
# 72 "/home/nathan/src/linux-next/include/uapi/linux/taskstats.h"
 __u64 cpu_count __attribute__((aligned(8)));
 __u64 cpu_delay_total;






 __u64 blkio_count;
 __u64 blkio_delay_total;


 __u64 swapin_count;
 __u64 swapin_delay_total;







 __u64 cpu_run_real_total;







 __u64 cpu_run_virtual_total;




 char ac_comm[32];
 __u8 ac_sched __attribute__((aligned(8)));

 __u8 ac_pad[3];
 __u32 ac_uid __attribute__((aligned(8)));

 __u32 ac_gid;
 __u32 ac_pid;
 __u32 ac_ppid;

 __u32 ac_btime;
 __u64 ac_etime __attribute__((aligned(8)));

 __u64 ac_utime;
 __u64 ac_stime;
 __u64 ac_minflt;
 __u64 ac_majflt;
# 132 "/home/nathan/src/linux-next/include/uapi/linux/taskstats.h"
 __u64 coremem;



 __u64 virtmem;




 __u64 hiwater_rss;
 __u64 hiwater_vm;


 __u64 read_char;
 __u64 write_char;
 __u64 read_syscalls;
 __u64 write_syscalls;




 __u64 read_bytes;
 __u64 write_bytes;
 __u64 cancelled_write_bytes;

 __u64 nvcsw;
 __u64 nivcsw;


 __u64 ac_utimescaled;
 __u64 ac_stimescaled;
 __u64 cpu_scaled_run_real_total;


 __u64 freepages_count;
 __u64 freepages_delay_total;


 __u64 thrashing_count;
 __u64 thrashing_delay_total;


 __u64 ac_btime64;
};
# 184 "/home/nathan/src/linux-next/include/uapi/linux/taskstats.h"
enum {
 TASKSTATS_CMD_UNSPEC = 0,
 TASKSTATS_CMD_GET,
 TASKSTATS_CMD_NEW,
 __TASKSTATS_CMD_MAX,
};



enum {
 TASKSTATS_TYPE_UNSPEC = 0,
 TASKSTATS_TYPE_PID,
 TASKSTATS_TYPE_TGID,
 TASKSTATS_TYPE_STATS,
 TASKSTATS_TYPE_AGGR_PID,
 TASKSTATS_TYPE_AGGR_TGID,
 TASKSTATS_TYPE_NULL,
 __TASKSTATS_TYPE_MAX,
};



enum {
 TASKSTATS_CMD_ATTR_UNSPEC = 0,
 TASKSTATS_CMD_ATTR_PID,
 TASKSTATS_CMD_ATTR_TGID,
 TASKSTATS_CMD_ATTR_REGISTER_CPUMASK,
 TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK,
 __TASKSTATS_CMD_ATTR_MAX,
};
# 21 "/home/nathan/src/linux-next/include/uapi/linux/cgroupstats.h" 2
# 32 "/home/nathan/src/linux-next/include/uapi/linux/cgroupstats.h"
struct cgroupstats {
 __u64 nr_sleeping;
 __u64 nr_running;
 __u64 nr_stopped;
 __u64 nr_uninterruptible;

 __u64 nr_io_wait;
};







enum {
 CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX,
 CGROUPSTATS_CMD_GET,
 CGROUPSTATS_CMD_NEW,
 __CGROUPSTATS_CMD_MAX,
};



enum {
 CGROUPSTATS_TYPE_UNSPEC = 0,
 CGROUPSTATS_TYPE_CGROUP_STATS,
 __CGROUPSTATS_TYPE_MAX,
};



enum {
 CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
 CGROUPSTATS_CMD_ATTR_FD,
 __CGROUPSTATS_CMD_ATTR_MAX,
};
# 17 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2






# 1 "/home/nathan/src/linux-next/include/linux/nsproxy.h" 1







struct mnt_namespace;
struct uts_namespace;
struct ipc_namespace;
struct pid_namespace;
struct cgroup_namespace;
struct fs_struct;
# 31 "/home/nathan/src/linux-next/include/linux/nsproxy.h"
struct nsproxy {
 atomic_t count;
 struct uts_namespace *uts_ns;
 struct ipc_namespace *ipc_ns;
 struct mnt_namespace *mnt_ns;
 struct pid_namespace *pid_ns_for_children;
 struct net *net_ns;
 struct time_namespace *time_ns;
 struct time_namespace *time_ns_for_children;
 struct cgroup_namespace *cgroup_ns;
};
extern struct nsproxy init_nsproxy;
# 70 "/home/nathan/src/linux-next/include/linux/nsproxy.h"
int copy_namespaces(unsigned long flags, struct task_struct *tsk);
void exit_task_namespaces(struct task_struct *tsk);
void switch_task_namespaces(struct task_struct *tsk, struct nsproxy *new);
void free_nsproxy(struct nsproxy *ns);
int unshare_nsproxy_namespaces(unsigned long, struct nsproxy **,
 struct cred *, struct fs_struct *);
int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) nsproxy_cache_init(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_nsproxy(struct nsproxy *ns)
{
 if (atomic_dec_and_test(&ns->count)) {
  free_nsproxy(ns);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void get_nsproxy(struct nsproxy *ns)
{
 atomic_inc(&ns->count);
}
# 24 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/user_namespace.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/user_namespace.h"
struct uid_gid_extent {
 u32 first;
 u32 lower_first;
 u32 count;
};

struct uid_gid_map {
 u32 nr_extents;
 union {
  struct uid_gid_extent extent[5];
  struct {
   struct uid_gid_extent *forward;
   struct uid_gid_extent *reverse;
  };
 };
};





struct ucounts;

enum ucount_type {
 UCOUNT_USER_NAMESPACES,
 UCOUNT_PID_NAMESPACES,
 UCOUNT_UTS_NAMESPACES,
 UCOUNT_IPC_NAMESPACES,
 UCOUNT_NET_NAMESPACES,
 UCOUNT_MNT_NAMESPACES,
 UCOUNT_CGROUP_NAMESPACES,
 UCOUNT_TIME_NAMESPACES,

 UCOUNT_INOTIFY_INSTANCES,
 UCOUNT_INOTIFY_WATCHES,

 UCOUNT_COUNTS,
};

struct user_namespace {
 struct uid_gid_map uid_map;
 struct uid_gid_map gid_map;
 struct uid_gid_map projid_map;
 atomic_t count;
 struct user_namespace *parent;
 int level;
 kuid_t owner;
 kgid_t group;
 struct ns_common ns;
 unsigned long flags;







 struct list_head keyring_name_list;
 struct key *user_keyring_register;
 struct rw_semaphore keyring_sem;






 struct work_struct work;

 struct ctl_table_set set;
 struct ctl_table_header *sysctls;

 struct ucounts *ucounts;
 int ucount_max[UCOUNT_COUNTS];
} ;

struct ucounts {
 struct hlist_node node;
 struct user_namespace *ns;
 kuid_t uid;
 int count;
 atomic_t ucount[UCOUNT_COUNTS];
};

extern struct user_namespace init_user_ns;

bool setup_userns_sysctls(struct user_namespace *ns);
void retire_userns_sysctls(struct user_namespace *ns);
struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid, enum ucount_type type);
void dec_ucount(struct ucounts *ucounts, enum ucount_type type);
# 142 "/home/nathan/src/linux-next/include/linux/user_namespace.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_namespace *get_user_ns(struct user_namespace *ns)
{
 return &init_user_ns;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int create_user_ns(struct cred *new)
{
 return -22;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unshare_userns(unsigned long unshare_flags,
     struct cred **new_cred)
{
 if (unshare_flags & 0x10000000)
  return -22;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_user_ns(struct user_namespace *ns)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool userns_may_setgroups(const struct user_namespace *ns)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool in_userns(const struct user_namespace *ancestor,
        const struct user_namespace *child)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool current_in_userns(const struct user_namespace *target_ns)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ns_common *ns_get_owner(struct ns_common *ns)
{
 return ERR_PTR(-1);
}
# 25 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/kernel_stat.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/kernel_stat.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/irq.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/kernel_stat.h" 2







enum cpu_usage_stat {
 CPUTIME_USER,
 CPUTIME_NICE,
 CPUTIME_SYSTEM,
 CPUTIME_SOFTIRQ,
 CPUTIME_IRQ,
 CPUTIME_IDLE,
 CPUTIME_IOWAIT,
 CPUTIME_STEAL,
 CPUTIME_GUEST,
 CPUTIME_GUEST_NICE,
 NR_STATS,
};

struct kernel_cpustat {
 u64 cpustat[NR_STATS];
};

struct kernel_stat {
 unsigned long irqs_sum;
 unsigned int softirqs[NR_SOFTIRQS];
};

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct kernel_stat) kstat;
extern __attribute__((section(".data..percpu" ""))) __typeof__(struct kernel_cpustat) kernel_cpustat;







extern unsigned long long nr_context_switches(void);

extern unsigned int kstat_irqs_cpu(unsigned int irq, int cpu);
extern void kstat_incr_irq_this_cpu(unsigned int irq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kstat_incr_softirqs_this_cpu(unsigned int irq)
{
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(kstat.softirqs[irq])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(kstat.softirqs[irq])) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(kstat.softirqs[irq])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq]))); (typeof((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(kstat.softirqs[irq])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq]))); (typeof((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(kstat.softirqs[irq])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq]))); (typeof((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(kstat.softirqs[irq])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq]))); (typeof((typeof(*(&(kstat.softirqs[irq]))) *)(&(kstat.softirqs[irq])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int kstat_softirqs_cpu(unsigned int irq, int cpu)
{
       return (*({ do { const void *__vpp_verify = (typeof((&(kstat)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(kstat)))) *)((&(kstat)))); (typeof((typeof(*((&(kstat)))) *)((&(kstat))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })).softirqs[irq];
}




extern unsigned int kstat_irqs(unsigned int irq);
extern unsigned int kstat_irqs_usr(unsigned int irq);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int kstat_cpu_irqs_sum(unsigned int cpu)
{
 return (*({ do { const void *__vpp_verify = (typeof((&(kstat)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(kstat)))) *)((&(kstat)))); (typeof((typeof(*((&(kstat)))) *)((&(kstat))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })).irqs_sum;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 kcpustat_field(struct kernel_cpustat *kcpustat,
     enum cpu_usage_stat usage, int cpu)
{
 return kcpustat->cpustat[usage];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)
{
 *dst = (*({ do { const void *__vpp_verify = (typeof((&(kernel_cpustat)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(kernel_cpustat)))) *)((&(kernel_cpustat)))); (typeof((typeof(*((&(kernel_cpustat)))) *)((&(kernel_cpustat))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));
}



extern void account_user_time(struct task_struct *, u64);
extern void account_guest_time(struct task_struct *, u64);
extern void account_system_time(struct task_struct *, int, u64);
extern void account_system_index_time(struct task_struct *, u64,
          enum cpu_usage_stat);
extern void account_steal_time(u64);
extern void account_idle_time(u64);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void account_process_tick(struct task_struct *tsk, int user)
{
 vtime_flush(tsk);
}




extern void account_idle_ticks(unsigned long ticks);
# 27 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h" 1
# 22 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
# 1 "/home/nathan/src/linux-next/include/linux/bpf-cgroup.h" 1




# 1 "/home/nathan/src/linux-next/include/linux/bpf.h" 1






# 1 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h" 1
# 12 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/bpf_common.h" 1
# 13 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h" 2
# 47 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum {
 BPF_REG_0 = 0,
 BPF_REG_1,
 BPF_REG_2,
 BPF_REG_3,
 BPF_REG_4,
 BPF_REG_5,
 BPF_REG_6,
 BPF_REG_7,
 BPF_REG_8,
 BPF_REG_9,
 BPF_REG_10,
 __MAX_BPF_REG,
};




struct bpf_insn {
 __u8 code;
 __u8 dst_reg:4;
 __u8 src_reg:4;
 __s16 off;
 __s32 imm;
};


struct bpf_lpm_trie_key {
 __u32 prefixlen;
 __u8 data[0];
};

struct bpf_cgroup_storage_key {
 __u64 cgroup_inode_id;
 __u32 attach_type;
};


enum bpf_cmd {
 BPF_MAP_CREATE,
 BPF_MAP_LOOKUP_ELEM,
 BPF_MAP_UPDATE_ELEM,
 BPF_MAP_DELETE_ELEM,
 BPF_MAP_GET_NEXT_KEY,
 BPF_PROG_LOAD,
 BPF_OBJ_PIN,
 BPF_OBJ_GET,
 BPF_PROG_ATTACH,
 BPF_PROG_DETACH,
 BPF_PROG_TEST_RUN,
 BPF_PROG_GET_NEXT_ID,
 BPF_MAP_GET_NEXT_ID,
 BPF_PROG_GET_FD_BY_ID,
 BPF_MAP_GET_FD_BY_ID,
 BPF_OBJ_GET_INFO_BY_FD,
 BPF_PROG_QUERY,
 BPF_RAW_TRACEPOINT_OPEN,
 BPF_BTF_LOAD,
 BPF_BTF_GET_FD_BY_ID,
 BPF_TASK_FD_QUERY,
 BPF_MAP_LOOKUP_AND_DELETE_ELEM,
 BPF_MAP_FREEZE,
 BPF_BTF_GET_NEXT_ID,
 BPF_MAP_LOOKUP_BATCH,
 BPF_MAP_LOOKUP_AND_DELETE_BATCH,
 BPF_MAP_UPDATE_BATCH,
 BPF_MAP_DELETE_BATCH,
};

enum bpf_map_type {
 BPF_MAP_TYPE_UNSPEC,
 BPF_MAP_TYPE_HASH,
 BPF_MAP_TYPE_ARRAY,
 BPF_MAP_TYPE_PROG_ARRAY,
 BPF_MAP_TYPE_PERF_EVENT_ARRAY,
 BPF_MAP_TYPE_PERCPU_HASH,
 BPF_MAP_TYPE_PERCPU_ARRAY,
 BPF_MAP_TYPE_STACK_TRACE,
 BPF_MAP_TYPE_CGROUP_ARRAY,
 BPF_MAP_TYPE_LRU_HASH,
 BPF_MAP_TYPE_LRU_PERCPU_HASH,
 BPF_MAP_TYPE_LPM_TRIE,
 BPF_MAP_TYPE_ARRAY_OF_MAPS,
 BPF_MAP_TYPE_HASH_OF_MAPS,
 BPF_MAP_TYPE_DEVMAP,
 BPF_MAP_TYPE_SOCKMAP,
 BPF_MAP_TYPE_CPUMAP,
 BPF_MAP_TYPE_XSKMAP,
 BPF_MAP_TYPE_SOCKHASH,
 BPF_MAP_TYPE_CGROUP_STORAGE,
 BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
 BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
 BPF_MAP_TYPE_QUEUE,
 BPF_MAP_TYPE_STACK,
 BPF_MAP_TYPE_SK_STORAGE,
 BPF_MAP_TYPE_DEVMAP_HASH,
 BPF_MAP_TYPE_STRUCT_OPS,
};
# 154 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum bpf_prog_type {
 BPF_PROG_TYPE_UNSPEC,
 BPF_PROG_TYPE_SOCKET_FILTER,
 BPF_PROG_TYPE_KPROBE,
 BPF_PROG_TYPE_SCHED_CLS,
 BPF_PROG_TYPE_SCHED_ACT,
 BPF_PROG_TYPE_TRACEPOINT,
 BPF_PROG_TYPE_XDP,
 BPF_PROG_TYPE_PERF_EVENT,
 BPF_PROG_TYPE_CGROUP_SKB,
 BPF_PROG_TYPE_CGROUP_SOCK,
 BPF_PROG_TYPE_LWT_IN,
 BPF_PROG_TYPE_LWT_OUT,
 BPF_PROG_TYPE_LWT_XMIT,
 BPF_PROG_TYPE_SOCK_OPS,
 BPF_PROG_TYPE_SK_SKB,
 BPF_PROG_TYPE_CGROUP_DEVICE,
 BPF_PROG_TYPE_SK_MSG,
 BPF_PROG_TYPE_RAW_TRACEPOINT,
 BPF_PROG_TYPE_CGROUP_SOCK_ADDR,
 BPF_PROG_TYPE_LWT_SEG6LOCAL,
 BPF_PROG_TYPE_LIRC_MODE2,
 BPF_PROG_TYPE_SK_REUSEPORT,
 BPF_PROG_TYPE_FLOW_DISSECTOR,
 BPF_PROG_TYPE_CGROUP_SYSCTL,
 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,
 BPF_PROG_TYPE_CGROUP_SOCKOPT,
 BPF_PROG_TYPE_TRACING,
 BPF_PROG_TYPE_STRUCT_OPS,
 BPF_PROG_TYPE_EXT,
};

enum bpf_attach_type {
 BPF_CGROUP_INET_INGRESS,
 BPF_CGROUP_INET_EGRESS,
 BPF_CGROUP_INET_SOCK_CREATE,
 BPF_CGROUP_SOCK_OPS,
 BPF_SK_SKB_STREAM_PARSER,
 BPF_SK_SKB_STREAM_VERDICT,
 BPF_CGROUP_DEVICE,
 BPF_SK_MSG_VERDICT,
 BPF_CGROUP_INET4_BIND,
 BPF_CGROUP_INET6_BIND,
 BPF_CGROUP_INET4_CONNECT,
 BPF_CGROUP_INET6_CONNECT,
 BPF_CGROUP_INET4_POST_BIND,
 BPF_CGROUP_INET6_POST_BIND,
 BPF_CGROUP_UDP4_SENDMSG,
 BPF_CGROUP_UDP6_SENDMSG,
 BPF_LIRC_MODE2,
 BPF_FLOW_DISSECTOR,
 BPF_CGROUP_SYSCTL,
 BPF_CGROUP_UDP4_RECVMSG,
 BPF_CGROUP_UDP6_RECVMSG,
 BPF_CGROUP_GETSOCKOPT,
 BPF_CGROUP_SETSOCKOPT,
 BPF_TRACE_RAW_TP,
 BPF_TRACE_FENTRY,
 BPF_TRACE_FEXIT,
 __MAX_BPF_ATTACH_TYPE
};
# 375 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum bpf_stack_build_id_status {

 BPF_STACK_BUILD_ID_EMPTY = 0,

 BPF_STACK_BUILD_ID_VALID = 1,

 BPF_STACK_BUILD_ID_IP = 2,
};


struct bpf_stack_build_id {
 __s32 status;
 unsigned char build_id[20];
 union {
  __u64 offset;
  __u64 ip;
 };
};

union bpf_attr {
 struct {
  __u32 map_type;
  __u32 key_size;
  __u32 value_size;
  __u32 max_entries;
  __u32 map_flags;


  __u32 inner_map_fd;
  __u32 numa_node;


  char map_name[16U];
  __u32 map_ifindex;
  __u32 btf_fd;
  __u32 btf_key_type_id;
  __u32 btf_value_type_id;
  __u32 btf_vmlinux_value_type_id;



 };

 struct {
  __u32 map_fd;
  __u64 __attribute__((aligned(8))) key;
  union {
   __u64 __attribute__((aligned(8))) value;
   __u64 __attribute__((aligned(8))) next_key;
  };
  __u64 flags;
 };

 struct {
  __u64 __attribute__((aligned(8))) in_batch;


  __u64 __attribute__((aligned(8))) out_batch;
  __u64 __attribute__((aligned(8))) keys;
  __u64 __attribute__((aligned(8))) values;
  __u32 count;




  __u32 map_fd;
  __u64 elem_flags;
  __u64 flags;
 } batch;

 struct {
  __u32 prog_type;
  __u32 insn_cnt;
  __u64 __attribute__((aligned(8))) insns;
  __u64 __attribute__((aligned(8))) license;
  __u32 log_level;
  __u32 log_size;
  __u64 __attribute__((aligned(8))) log_buf;
  __u32 kern_version;
  __u32 prog_flags;
  char prog_name[16U];
  __u32 prog_ifindex;




  __u32 expected_attach_type;
  __u32 prog_btf_fd;
  __u32 func_info_rec_size;
  __u64 __attribute__((aligned(8))) func_info;
  __u32 func_info_cnt;
  __u32 line_info_rec_size;
  __u64 __attribute__((aligned(8))) line_info;
  __u32 line_info_cnt;
  __u32 attach_btf_id;
  __u32 attach_prog_fd;
 };

 struct {
  __u64 __attribute__((aligned(8))) pathname;
  __u32 bpf_fd;
  __u32 file_flags;
 };

 struct {
  __u32 target_fd;
  __u32 attach_bpf_fd;
  __u32 attach_type;
  __u32 attach_flags;
  __u32 replace_bpf_fd;



 };

 struct {
  __u32 prog_fd;
  __u32 retval;
  __u32 data_size_in;
  __u32 data_size_out;



  __u64 __attribute__((aligned(8))) data_in;
  __u64 __attribute__((aligned(8))) data_out;
  __u32 repeat;
  __u32 duration;
  __u32 ctx_size_in;
  __u32 ctx_size_out;



  __u64 __attribute__((aligned(8))) ctx_in;
  __u64 __attribute__((aligned(8))) ctx_out;
 } test;

 struct {
  union {
   __u32 start_id;
   __u32 prog_id;
   __u32 map_id;
   __u32 btf_id;
  };
  __u32 next_id;
  __u32 open_flags;
 };

 struct {
  __u32 bpf_fd;
  __u32 info_len;
  __u64 __attribute__((aligned(8))) info;
 } info;

 struct {
  __u32 target_fd;
  __u32 attach_type;
  __u32 query_flags;
  __u32 attach_flags;
  __u64 __attribute__((aligned(8))) prog_ids;
  __u32 prog_cnt;
 } query;

 struct {
  __u64 name;
  __u32 prog_fd;
 } raw_tracepoint;

 struct {
  __u64 __attribute__((aligned(8))) btf;
  __u64 __attribute__((aligned(8))) btf_log_buf;
  __u32 btf_size;
  __u32 btf_log_size;
  __u32 btf_log_level;
 };

 struct {
  __u32 pid;
  __u32 fd;
  __u32 flags;
  __u32 buf_len;
  __u64 __attribute__((aligned(8))) buf;




  __u32 prog_id;
  __u32 fd_type;
  __u64 probe_offset;
  __u64 probe_addr;
 } task_fd_query;
} __attribute__((aligned(8)));
# 3021 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum bpf_func_id {
 BPF_FUNC_unspec, BPF_FUNC_map_lookup_elem, BPF_FUNC_map_update_elem, BPF_FUNC_map_delete_elem, BPF_FUNC_probe_read, BPF_FUNC_ktime_get_ns, BPF_FUNC_trace_printk, BPF_FUNC_get_prandom_u32, BPF_FUNC_get_smp_processor_id, BPF_FUNC_skb_store_bytes, BPF_FUNC_l3_csum_replace, BPF_FUNC_l4_csum_replace, BPF_FUNC_tail_call, BPF_FUNC_clone_redirect, BPF_FUNC_get_current_pid_tgid, BPF_FUNC_get_current_uid_gid, BPF_FUNC_get_current_comm, BPF_FUNC_get_cgroup_classid, BPF_FUNC_skb_vlan_push, BPF_FUNC_skb_vlan_pop, BPF_FUNC_skb_get_tunnel_key, BPF_FUNC_skb_set_tunnel_key, BPF_FUNC_perf_event_read, BPF_FUNC_redirect, BPF_FUNC_get_route_realm, BPF_FUNC_perf_event_output, BPF_FUNC_skb_load_bytes, BPF_FUNC_get_stackid, BPF_FUNC_csum_diff, BPF_FUNC_skb_get_tunnel_opt, BPF_FUNC_skb_set_tunnel_opt, BPF_FUNC_skb_change_proto, BPF_FUNC_skb_change_type, BPF_FUNC_skb_under_cgroup, BPF_FUNC_get_hash_recalc, BPF_FUNC_get_current_task, BPF_FUNC_probe_write_user, BPF_FUNC_current_task_under_cgroup, BPF_FUNC_skb_change_tail, BPF_FUNC_skb_pull_data, BPF_FUNC_csum_update, BPF_FUNC_set_hash_invalid, BPF_FUNC_get_numa_node_id, BPF_FUNC_skb_change_head, BPF_FUNC_xdp_adjust_head, BPF_FUNC_probe_read_str, BPF_FUNC_get_socket_cookie, BPF_FUNC_get_socket_uid, BPF_FUNC_set_hash, BPF_FUNC_setsockopt, BPF_FUNC_skb_adjust_room, BPF_FUNC_redirect_map, BPF_FUNC_sk_redirect_map, BPF_FUNC_sock_map_update, BPF_FUNC_xdp_adjust_meta, BPF_FUNC_perf_event_read_value, BPF_FUNC_perf_prog_read_value, BPF_FUNC_getsockopt, BPF_FUNC_override_return, BPF_FUNC_sock_ops_cb_flags_set, BPF_FUNC_msg_redirect_map, BPF_FUNC_msg_apply_bytes, BPF_FUNC_msg_cork_bytes, BPF_FUNC_msg_pull_data, BPF_FUNC_bind, BPF_FUNC_xdp_adjust_tail, BPF_FUNC_skb_get_xfrm_state, BPF_FUNC_get_stack, BPF_FUNC_skb_load_bytes_relative, BPF_FUNC_fib_lookup, BPF_FUNC_sock_hash_update, BPF_FUNC_msg_redirect_hash, BPF_FUNC_sk_redirect_hash, BPF_FUNC_lwt_push_encap, BPF_FUNC_lwt_seg6_store_bytes, BPF_FUNC_lwt_seg6_adjust_srh, BPF_FUNC_lwt_seg6_action, BPF_FUNC_rc_repeat, BPF_FUNC_rc_keydown, BPF_FUNC_skb_cgroup_id, BPF_FUNC_get_current_cgroup_id, BPF_FUNC_get_local_storage, BPF_FUNC_sk_select_reuseport, BPF_FUNC_skb_ancestor_cgroup_id, BPF_FUNC_sk_lookup_tcp, BPF_FUNC_sk_lookup_udp, BPF_FUNC_sk_release, BPF_FUNC_map_push_elem, BPF_FUNC_map_pop_elem, BPF_FUNC_map_peek_elem, BPF_FUNC_msg_push_data, BPF_FUNC_msg_pop_data, BPF_FUNC_rc_pointer_rel, BPF_FUNC_spin_lock, BPF_FUNC_spin_unlock, BPF_FUNC_sk_fullsock, BPF_FUNC_tcp_sock, BPF_FUNC_skb_ecn_set_ce, BPF_FUNC_get_listener_sock, BPF_FUNC_skc_lookup_tcp, BPF_FUNC_tcp_check_syncookie, BPF_FUNC_sysctl_get_name, BPF_FUNC_sysctl_get_current_value, BPF_FUNC_sysctl_get_new_value, BPF_FUNC_sysctl_set_new_value, BPF_FUNC_strtol, BPF_FUNC_strtoul, BPF_FUNC_sk_storage_get, BPF_FUNC_sk_storage_delete, BPF_FUNC_send_signal, BPF_FUNC_tcp_gen_syncookie, BPF_FUNC_skb_output, BPF_FUNC_probe_read_user, BPF_FUNC_probe_read_kernel, BPF_FUNC_probe_read_user_str, BPF_FUNC_probe_read_kernel_str, BPF_FUNC_tcp_send_ack, BPF_FUNC_send_signal_thread, BPF_FUNC_jiffies64,
 __BPF_FUNC_MAX_ID,
};
# 3095 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum bpf_adj_room_mode {
 BPF_ADJ_ROOM_NET,
 BPF_ADJ_ROOM_MAC,
};


enum bpf_hdr_start_off {
 BPF_HDR_START_MAC,
 BPF_HDR_START_NET,
};


enum bpf_lwt_encap_mode {
 BPF_LWT_ENCAP_SEG6,
 BPF_LWT_ENCAP_SEG6_INLINE,
 BPF_LWT_ENCAP_IP,
};
# 3122 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
struct __sk_buff {
 __u32 len;
 __u32 pkt_type;
 __u32 mark;
 __u32 queue_mapping;
 __u32 protocol;
 __u32 vlan_present;
 __u32 vlan_tci;
 __u32 vlan_proto;
 __u32 priority;
 __u32 ingress_ifindex;
 __u32 ifindex;
 __u32 tc_index;
 __u32 cb[5];
 __u32 hash;
 __u32 tc_classid;
 __u32 data;
 __u32 data_end;
 __u32 napi_id;


 __u32 family;
 __u32 remote_ip4;
 __u32 local_ip4;
 __u32 remote_ip6[4];
 __u32 local_ip6[4];
 __u32 remote_port;
 __u32 local_port;


 __u32 data_meta;
 union { struct bpf_flow_keys * flow_keys; __u64 :64; } __attribute__((aligned(8)));
 __u64 tstamp;
 __u32 wire_len;
 __u32 gso_segs;
 union { struct bpf_sock * sk; __u64 :64; } __attribute__((aligned(8)));
};

struct bpf_tunnel_key {
 __u32 tunnel_id;
 union {
  __u32 remote_ipv4;
  __u32 remote_ipv6[4];
 };
 __u8 tunnel_tos;
 __u8 tunnel_ttl;
 __u16 tunnel_ext;
 __u32 tunnel_label;
};




struct bpf_xfrm_state {
 __u32 reqid;
 __u32 spi;
 __u16 family;
 __u16 ext;
 union {
  __u32 remote_ipv4;
  __u32 remote_ipv6[4];
 };
};
# 3193 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum bpf_ret_code {
 BPF_OK = 0,

 BPF_DROP = 2,

 BPF_REDIRECT = 7,
# 3207 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
 BPF_LWT_REROUTE = 128,
};

struct bpf_sock {
 __u32 bound_dev_if;
 __u32 family;
 __u32 type;
 __u32 protocol;
 __u32 mark;
 __u32 priority;

 __u32 src_ip4;
 __u32 src_ip6[4];
 __u32 src_port;
 __u32 dst_port;
 __u32 dst_ip4;
 __u32 dst_ip6[4];
 __u32 state;
};

struct bpf_tcp_sock {
 __u32 snd_cwnd;
 __u32 srtt_us;
 __u32 rtt_min;
 __u32 snd_ssthresh;
 __u32 rcv_nxt;
 __u32 snd_nxt;
 __u32 snd_una;
 __u32 mss_cache;
 __u32 ecn_flags;
 __u32 rate_delivered;
 __u32 rate_interval_us;
 __u32 packets_out;
 __u32 retrans_out;
 __u32 total_retrans;
 __u32 segs_in;


 __u32 data_segs_in;


 __u32 segs_out;


 __u32 data_segs_out;


 __u32 lost_out;
 __u32 sacked_out;
 __u64 bytes_received;



 __u64 bytes_acked;



 __u32 dsack_dups;


 __u32 delivered;
 __u32 delivered_ce;
 __u32 icsk_retransmits;
};

struct bpf_sock_tuple {
 union {
  struct {
   __be32 saddr;
   __be32 daddr;
   __be16 sport;
   __be16 dport;
  } ipv4;
  struct {
   __be32 saddr[4];
   __be32 daddr[4];
   __be16 sport;
   __be16 dport;
  } ipv6;
 };
};

struct bpf_xdp_sock {
 __u32 queue_id;
};
# 3300 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum xdp_action {
 XDP_ABORTED = 0,
 XDP_DROP,
 XDP_PASS,
 XDP_TX,
 XDP_REDIRECT,
};




struct xdp_md {
 __u32 data;
 __u32 data_end;
 __u32 data_meta;

 __u32 ingress_ifindex;
 __u32 rx_queue_index;
};

enum sk_action {
 SK_DROP = 0,
 SK_PASS,
};




struct sk_msg_md {
 union { void * data; __u64 :64; } __attribute__((aligned(8)));
 union { void * data_end; __u64 :64; } __attribute__((aligned(8)));

 __u32 family;
 __u32 remote_ip4;
 __u32 local_ip4;
 __u32 remote_ip6[4];
 __u32 local_ip6[4];
 __u32 remote_port;
 __u32 local_port;
 __u32 size;
};

struct sk_reuseport_md {




 union { void * data; __u64 :64; } __attribute__((aligned(8)));

 union { void * data_end; __u64 :64; } __attribute__((aligned(8)));






 __u32 len;




 __u32 eth_protocol;
 __u32 ip_protocol;
 __u32 bind_inany;
 __u32 hash;
};



struct bpf_prog_info {
 __u32 type;
 __u32 id;
 __u8 tag[8];
 __u32 jited_prog_len;
 __u32 xlated_prog_len;
 __u64 __attribute__((aligned(8))) jited_prog_insns;
 __u64 __attribute__((aligned(8))) xlated_prog_insns;
 __u64 load_time;
 __u32 created_by_uid;
 __u32 nr_map_ids;
 __u64 __attribute__((aligned(8))) map_ids;
 char name[16U];
 __u32 ifindex;
 __u32 gpl_compatible:1;
 __u32 :31;
 __u64 netns_dev;
 __u64 netns_ino;
 __u32 nr_jited_ksyms;
 __u32 nr_jited_func_lens;
 __u64 __attribute__((aligned(8))) jited_ksyms;
 __u64 __attribute__((aligned(8))) jited_func_lens;
 __u32 btf_id;
 __u32 func_info_rec_size;
 __u64 __attribute__((aligned(8))) func_info;
 __u32 nr_func_info;
 __u32 nr_line_info;
 __u64 __attribute__((aligned(8))) line_info;
 __u64 __attribute__((aligned(8))) jited_line_info;
 __u32 nr_jited_line_info;
 __u32 line_info_rec_size;
 __u32 jited_line_info_rec_size;
 __u32 nr_prog_tags;
 __u64 __attribute__((aligned(8))) prog_tags;
 __u64 run_time_ns;
 __u64 run_cnt;
} __attribute__((aligned(8)));

struct bpf_map_info {
 __u32 type;
 __u32 id;
 __u32 key_size;
 __u32 value_size;
 __u32 max_entries;
 __u32 map_flags;
 char name[16U];
 __u32 ifindex;
 __u32 btf_vmlinux_value_type_id;
 __u64 netns_dev;
 __u64 netns_ino;
 __u32 btf_id;
 __u32 btf_key_type_id;
 __u32 btf_value_type_id;
} __attribute__((aligned(8)));

struct bpf_btf_info {
 __u64 __attribute__((aligned(8))) btf;
 __u32 btf_size;
 __u32 id;
} __attribute__((aligned(8)));





struct bpf_sock_addr {
 __u32 user_family;
 __u32 user_ip4;


 __u32 user_ip6[4];


 __u32 user_port;


 __u32 family;
 __u32 type;
 __u32 protocol;
 __u32 msg_src_ip4;


 __u32 msg_src_ip6[4];


 union { struct bpf_sock * sk; __u64 :64; } __attribute__((aligned(8)));
};







struct bpf_sock_ops {
 __u32 op;
 union {
  __u32 args[4];
  __u32 reply;
  __u32 replylong[4];
 };
 __u32 family;
 __u32 remote_ip4;
 __u32 local_ip4;
 __u32 remote_ip6[4];
 __u32 local_ip6[4];
 __u32 remote_port;
 __u32 local_port;
 __u32 is_fullsock;



 __u32 snd_cwnd;
 __u32 srtt_us;
 __u32 bpf_sock_ops_cb_flags;
 __u32 state;
 __u32 rtt_min;
 __u32 snd_ssthresh;
 __u32 rcv_nxt;
 __u32 snd_nxt;
 __u32 snd_una;
 __u32 mss_cache;
 __u32 ecn_flags;
 __u32 rate_delivered;
 __u32 rate_interval_us;
 __u32 packets_out;
 __u32 retrans_out;
 __u32 total_retrans;
 __u32 segs_in;
 __u32 data_segs_in;
 __u32 segs_out;
 __u32 data_segs_out;
 __u32 lost_out;
 __u32 sacked_out;
 __u32 sk_txhash;
 __u64 bytes_received;
 __u64 bytes_acked;
 union { struct bpf_sock * sk; __u64 :64; } __attribute__((aligned(8)));
};
# 3521 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
enum {
 BPF_SOCK_OPS_VOID,
 BPF_SOCK_OPS_TIMEOUT_INIT,


 BPF_SOCK_OPS_RWND_INIT,



 BPF_SOCK_OPS_TCP_CONNECT_CB,


 BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB,



 BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,



 BPF_SOCK_OPS_NEEDS_ECN,


 BPF_SOCK_OPS_BASE_RTT,






 BPF_SOCK_OPS_RTO_CB,




 BPF_SOCK_OPS_RETRANS_CB,





 BPF_SOCK_OPS_STATE_CB,



 BPF_SOCK_OPS_TCP_LISTEN_CB,


 BPF_SOCK_OPS_RTT_CB,

};






enum {
 BPF_TCP_ESTABLISHED = 1,
 BPF_TCP_SYN_SENT,
 BPF_TCP_SYN_RECV,
 BPF_TCP_FIN_WAIT1,
 BPF_TCP_FIN_WAIT2,
 BPF_TCP_TIME_WAIT,
 BPF_TCP_CLOSE,
 BPF_TCP_CLOSE_WAIT,
 BPF_TCP_LAST_ACK,
 BPF_TCP_LISTEN,
 BPF_TCP_CLOSING,
 BPF_TCP_NEW_SYN_RECV,

 BPF_TCP_MAX_STATES
};




struct bpf_perf_event_value {
 __u64 counter;
 __u64 enabled;
 __u64 running;
};
# 3611 "/home/nathan/src/linux-next/include/uapi/linux/bpf.h"
struct bpf_cgroup_dev_ctx {

 __u32 access_type;
 __u32 major;
 __u32 minor;
};

struct bpf_raw_tracepoint_args {
 __u64 args[0];
};







enum {
 BPF_FIB_LKUP_RET_SUCCESS,
 BPF_FIB_LKUP_RET_BLACKHOLE,
 BPF_FIB_LKUP_RET_UNREACHABLE,
 BPF_FIB_LKUP_RET_PROHIBIT,
 BPF_FIB_LKUP_RET_NOT_FWDED,
 BPF_FIB_LKUP_RET_FWD_DISABLED,
 BPF_FIB_LKUP_RET_UNSUPP_LWT,
 BPF_FIB_LKUP_RET_NO_NEIGH,
 BPF_FIB_LKUP_RET_FRAG_NEEDED,
};

struct bpf_fib_lookup {



 __u8 family;


 __u8 l4_protocol;
 __be16 sport;
 __be16 dport;


 __u16 tot_len;




 __u32 ifindex;

 union {

  __u8 tos;
  __be32 flowinfo;


  __u32 rt_metric;
 };

 union {
  __be32 ipv4_src;
  __u32 ipv6_src[4];
 };





 union {
  __be32 ipv4_dst;
  __u32 ipv6_dst[4];
 };


 __be16 h_vlan_proto;
 __be16 h_vlan_TCI;
 __u8 smac[6];
 __u8 dmac[6];
};

enum bpf_task_fd_type {
 BPF_FD_TYPE_RAW_TRACEPOINT,
 BPF_FD_TYPE_TRACEPOINT,
 BPF_FD_TYPE_KPROBE,
 BPF_FD_TYPE_KRETPROBE,
 BPF_FD_TYPE_UPROBE,
 BPF_FD_TYPE_URETPROBE,
};





struct bpf_flow_keys {
 __u16 nhoff;
 __u16 thoff;
 __u16 addr_proto;
 __u8 is_frag;
 __u8 is_first_frag;
 __u8 is_encap;
 __u8 ip_proto;
 __be16 n_proto;
 __be16 sport;
 __be16 dport;
 union {
  struct {
   __be32 ipv4_src;
   __be32 ipv4_dst;
  };
  struct {
   __u32 ipv6_src[4];
   __u32 ipv6_dst[4];
  };
 };
 __u32 flags;
 __be32 flow_label;
};

struct bpf_func_info {
 __u32 insn_off;
 __u32 type_id;
};




struct bpf_line_info {
 __u32 insn_off;
 __u32 file_name_off;
 __u32 line_off;
 __u32 line_col;
};

struct bpf_spin_lock {
 __u32 val;
};

struct bpf_sysctl {
 __u32 write;


 __u32 file_pos;


};

struct bpf_sockopt {
 union { struct bpf_sock * sk; __u64 :64; } __attribute__((aligned(8)));
 union { void * optval; __u64 :64; } __attribute__((aligned(8)));
 union { void * optval_end; __u64 :64; } __attribute__((aligned(8)));

 __s32 level;
 __s32 optname;
 __s32 optlen;
 __s32 retval;
};
# 8 "/home/nathan/src/linux-next/include/linux/bpf.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/file.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/file.h"
struct file;

extern void fput(struct file *);
extern void fput_many(struct file *, unsigned int);

struct file_operations;
struct task_struct;
struct vfsmount;
struct dentry;
struct inode;
struct path;
extern struct file *alloc_file_pseudo(struct inode *, struct vfsmount *,
 const char *, int flags, const struct file_operations *);
extern struct file *alloc_file_clone(struct file *, int flags,
 const struct file_operations *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fput_light(struct file *file, int fput_needed)
{
 if (fput_needed)
  fput(file);
}

struct fd {
 struct file *file;
 unsigned int flags;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fdput(struct fd fd)
{
 if (fd.flags & 1)
  fput(fd.file);
}

extern struct file *fget(unsigned int fd);
extern struct file *fget_many(unsigned int fd, unsigned int refs);
extern struct file *fget_raw(unsigned int fd);
extern struct file *fget_task(struct task_struct *task, unsigned int fd);
extern unsigned long __fdget(unsigned int fd);
extern unsigned long __fdget_raw(unsigned int fd);
extern unsigned long __fdget_pos(unsigned int fd);
extern void __f_unlock_pos(struct file *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fd __to_fd(unsigned long v)
{
 return (struct fd){(struct file *)(v & ~3),v & 3};
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fd fdget(unsigned int fd)
{
 return __to_fd(__fdget(fd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fd fdget_raw(unsigned int fd)
{
 return __to_fd(__fdget_raw(fd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fd fdget_pos(int fd)
{
 return __to_fd(__fdget_pos(fd));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fdput_pos(struct fd f)
{
 if (f.flags & 2)
  __f_unlock_pos(f.file);
 fdput(f);
}

extern int f_dupfd(unsigned int from, struct file *file, unsigned flags);
extern int replace_fd(unsigned fd, struct file *file, unsigned flags);
extern void set_close_on_exec(unsigned int fd, int flag);
extern bool get_close_on_exec(unsigned int fd);
extern int get_unused_fd_flags(unsigned flags);
extern void put_unused_fd(unsigned int fd);

extern void fd_install(unsigned int fd, struct file *file);

extern void flush_delayed_fput(void);
extern void __fput_sync(struct file *);
# 11 "/home/nathan/src/linux-next/include/linux/bpf.h" 2
# 22 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct bpf_verifier_env;
struct bpf_verifier_log;
struct perf_event;
struct bpf_prog;
struct bpf_prog_aux;
struct bpf_map;
struct sock;
struct seq_file;
struct btf;
struct btf_type;
struct exception_table_entry;

extern struct idr btf_idr;
extern spinlock_t btf_idr_lock;


struct bpf_map_ops {

 int (*map_alloc_check)(union bpf_attr *attr);
 struct bpf_map *(*map_alloc)(union bpf_attr *attr);
 void (*map_release)(struct bpf_map *map, struct file *map_file);
 void (*map_free)(struct bpf_map *map);
 int (*map_get_next_key)(struct bpf_map *map, void *key, void *next_key);
 void (*map_release_uref)(struct bpf_map *map);
 void *(*map_lookup_elem_sys_only)(struct bpf_map *map, void *key);
 int (*map_lookup_batch)(struct bpf_map *map, const union bpf_attr *attr,
    union bpf_attr *uattr);
 int (*map_lookup_and_delete_batch)(struct bpf_map *map,
        const union bpf_attr *attr,
        union bpf_attr *uattr);
 int (*map_update_batch)(struct bpf_map *map, const union bpf_attr *attr,
    union bpf_attr *uattr);
 int (*map_delete_batch)(struct bpf_map *map, const union bpf_attr *attr,
    union bpf_attr *uattr);


 void *(*map_lookup_elem)(struct bpf_map *map, void *key);
 int (*map_update_elem)(struct bpf_map *map, void *key, void *value, u64 flags);
 int (*map_delete_elem)(struct bpf_map *map, void *key);
 int (*map_push_elem)(struct bpf_map *map, void *value, u64 flags);
 int (*map_pop_elem)(struct bpf_map *map, void *value);
 int (*map_peek_elem)(struct bpf_map *map, void *value);


 void *(*map_fd_get_ptr)(struct bpf_map *map, struct file *map_file,
    int fd);
 void (*map_fd_put_ptr)(void *ptr);
 u32 (*map_gen_lookup)(struct bpf_map *map, struct bpf_insn *insn_buf);
 u32 (*map_fd_sys_lookup_elem)(void *ptr);
 void (*map_seq_show_elem)(struct bpf_map *map, void *key,
      struct seq_file *m);
 int (*map_check_btf)(const struct bpf_map *map,
        const struct btf *btf,
        const struct btf_type *key_type,
        const struct btf_type *value_type);


 int (*map_poke_track)(struct bpf_map *map, struct bpf_prog_aux *aux);
 void (*map_poke_untrack)(struct bpf_map *map, struct bpf_prog_aux *aux);
 void (*map_poke_run)(struct bpf_map *map, u32 key, struct bpf_prog *old,
        struct bpf_prog *new);


 int (*map_direct_value_addr)(const struct bpf_map *map,
         u64 *imm, u32 off);
 int (*map_direct_value_meta)(const struct bpf_map *map,
         u64 imm, u32 *off);
 int (*map_mmap)(struct bpf_map *map, struct vm_area_struct *vma);
};

struct bpf_map_memory {
 u32 pages;
 struct user_struct *user;
};

struct bpf_map {



 const struct bpf_map_ops *ops __attribute__((__aligned__((1 << 7))));
 struct bpf_map *inner_map_meta;



 enum bpf_map_type map_type;
 u32 key_size;
 u32 value_size;
 u32 max_entries;
 u32 map_flags;
 int spin_lock_off;
 u32 id;
 int numa_node;
 u32 btf_key_type_id;
 u32 btf_value_type_id;
 struct btf *btf;
 struct bpf_map_memory memory;
 char name[16U];
 u32 btf_vmlinux_value_type_id;
 bool unpriv_array;
 bool frozen;





 atomic64_t refcnt __attribute__((__aligned__((1 << 7))));
 atomic64_t usercnt;
 struct work_struct work;
 struct mutex freeze_mutex;
 u64 writecnt;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool map_value_has_spin_lock(const struct bpf_map *map)
{
 return map->spin_lock_off >= 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void check_and_init_map_lock(struct bpf_map *map, void *dst)
{
 if (__builtin_expect(!!(!map_value_has_spin_lock(map)), 1))
  return;
 *(struct bpf_spin_lock *)(dst + map->spin_lock_off) =
  (struct bpf_spin_lock){};
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_map_value(struct bpf_map *map, void *dst, void *src)
{
 if (__builtin_expect(!!(map_value_has_spin_lock(map)), 0)) {
  u32 off = map->spin_lock_off;

  memcpy(dst, src, off);
  memcpy(dst + off + sizeof(struct bpf_spin_lock),
         src + off + sizeof(struct bpf_spin_lock),
         map->value_size - off - sizeof(struct bpf_spin_lock));
 } else {
  memcpy(dst, src, map->value_size);
 }
}
void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,
      bool lock_src);

struct bpf_offload_dev;
struct bpf_offloaded_map;

struct bpf_map_dev_ops {
 int (*map_get_next_key)(struct bpf_offloaded_map *map,
    void *key, void *next_key);
 int (*map_lookup_elem)(struct bpf_offloaded_map *map,
          void *key, void *value);
 int (*map_update_elem)(struct bpf_offloaded_map *map,
          void *key, void *value, u64 flags);
 int (*map_delete_elem)(struct bpf_offloaded_map *map, void *key);
};

struct bpf_offloaded_map {
 struct bpf_map map;
 struct net_device *netdev;
 const struct bpf_map_dev_ops *dev_ops;
 void *dev_priv;
 struct list_head offloads;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bpf_offloaded_map *map_to_offmap(struct bpf_map *map)
{
 return ({ void *__mptr = (void *)(map); do { extern void __compiletime_assert_187(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(map)), typeof(((struct bpf_offloaded_map *)0)->map)) && !__builtin_types_compatible_p(typeof(*(map)), typeof(void))))) __compiletime_assert_187(); } while (0); ((struct bpf_offloaded_map *)(__mptr - __builtin_offsetof(struct bpf_offloaded_map, map))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_map_offload_neutral(const struct bpf_map *map)
{
 return map->map_type == BPF_MAP_TYPE_PERF_EVENT_ARRAY;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_map_support_seq_show(const struct bpf_map *map)
{
 return (map->btf_value_type_id || map->btf_vmlinux_value_type_id) &&
  map->ops->map_seq_show_elem;
}

int map_check_no_btf(const struct bpf_map *map,
       const struct btf *btf,
       const struct btf_type *key_type,
       const struct btf_type *value_type);

extern const struct bpf_map_ops bpf_map_offload_ops;


enum bpf_arg_type {
 ARG_DONTCARE = 0,




 ARG_CONST_MAP_PTR,
 ARG_PTR_TO_MAP_KEY,
 ARG_PTR_TO_MAP_VALUE,
 ARG_PTR_TO_UNINIT_MAP_VALUE,
 ARG_PTR_TO_MAP_VALUE_OR_NULL,




 ARG_PTR_TO_MEM,
 ARG_PTR_TO_MEM_OR_NULL,
 ARG_PTR_TO_UNINIT_MEM,




 ARG_CONST_SIZE,
 ARG_CONST_SIZE_OR_ZERO,

 ARG_PTR_TO_CTX,
 ARG_ANYTHING,
 ARG_PTR_TO_SPIN_LOCK,
 ARG_PTR_TO_SOCK_COMMON,
 ARG_PTR_TO_INT,
 ARG_PTR_TO_LONG,
 ARG_PTR_TO_SOCKET,
 ARG_PTR_TO_BTF_ID,
};


enum bpf_return_type {
 RET_INTEGER,
 RET_VOID,
 RET_PTR_TO_MAP_VALUE,
 RET_PTR_TO_MAP_VALUE_OR_NULL,
 RET_PTR_TO_SOCKET_OR_NULL,
 RET_PTR_TO_TCP_SOCK_OR_NULL,
 RET_PTR_TO_SOCK_COMMON_OR_NULL,
};





struct bpf_func_proto {
 u64 (*func)(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
 bool gpl_only;
 bool pkt_access;
 enum bpf_return_type ret_type;
 union {
  struct {
   enum bpf_arg_type arg1_type;
   enum bpf_arg_type arg2_type;
   enum bpf_arg_type arg3_type;
   enum bpf_arg_type arg4_type;
   enum bpf_arg_type arg5_type;
  };
  enum bpf_arg_type arg_type[5];
 };
 int *btf_id;
};





struct bpf_context;

enum bpf_access_type {
 BPF_READ = 1,
 BPF_WRITE = 2
};
# 298 "/home/nathan/src/linux-next/include/linux/bpf.h"
enum bpf_reg_type {
 NOT_INIT = 0,
 SCALAR_VALUE,
 PTR_TO_CTX,
 CONST_PTR_TO_MAP,
 PTR_TO_MAP_VALUE,
 PTR_TO_MAP_VALUE_OR_NULL,
 PTR_TO_STACK,
 PTR_TO_PACKET_META,
 PTR_TO_PACKET,
 PTR_TO_PACKET_END,
 PTR_TO_FLOW_KEYS,
 PTR_TO_SOCKET,
 PTR_TO_SOCKET_OR_NULL,
 PTR_TO_SOCK_COMMON,
 PTR_TO_SOCK_COMMON_OR_NULL,
 PTR_TO_TCP_SOCK,
 PTR_TO_TCP_SOCK_OR_NULL,
 PTR_TO_TP_BUFFER,
 PTR_TO_XDP_SOCK,
 PTR_TO_BTF_ID,
};




struct bpf_insn_access_aux {
 enum bpf_reg_type reg_type;
 union {
  int ctx_field_size;
  u32 btf_id;
 };
 struct bpf_verifier_log *log;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
bpf_ctx_record_field_size(struct bpf_insn_access_aux *aux, u32 size)
{
 aux->ctx_field_size = size;
}

struct bpf_prog_ops {
 int (*test_run)(struct bpf_prog *prog, const union bpf_attr *kattr,
   union bpf_attr *uattr);
};

struct bpf_verifier_ops {

 const struct bpf_func_proto *
 (*get_func_proto)(enum bpf_func_id func_id,
     const struct bpf_prog *prog);




 bool (*is_valid_access)(int off, int size, enum bpf_access_type type,
    const struct bpf_prog *prog,
    struct bpf_insn_access_aux *info);
 int (*gen_prologue)(struct bpf_insn *insn, bool direct_write,
       const struct bpf_prog *prog);
 int (*gen_ld_abs)(const struct bpf_insn *orig,
     struct bpf_insn *insn_buf);
 u32 (*convert_ctx_access)(enum bpf_access_type type,
      const struct bpf_insn *src,
      struct bpf_insn *dst,
      struct bpf_prog *prog, u32 *target_size);
 int (*btf_struct_access)(struct bpf_verifier_log *log,
     const struct btf_type *t, int off, int size,
     enum bpf_access_type atype,
     u32 *next_btf_id);
};

struct bpf_prog_offload_ops {

 int (*insn_hook)(struct bpf_verifier_env *env,
    int insn_idx, int prev_insn_idx);
 int (*finalize)(struct bpf_verifier_env *env);

 int (*replace_insn)(struct bpf_verifier_env *env, u32 off,
       struct bpf_insn *insn);
 int (*remove_insns)(struct bpf_verifier_env *env, u32 off, u32 cnt);

 int (*prepare)(struct bpf_prog *prog);
 int (*translate)(struct bpf_prog *prog);
 void (*destroy)(struct bpf_prog *prog);
};

struct bpf_prog_offload {
 struct bpf_prog *prog;
 struct net_device *netdev;
 struct bpf_offload_dev *offdev;
 void *dev_priv;
 struct list_head offloads;
 bool dev_state;
 bool opt_failed;
 void *jited_image;
 u32 jited_len;
};

enum bpf_cgroup_storage_type {
 BPF_CGROUP_STORAGE_SHARED,
 BPF_CGROUP_STORAGE_PERCPU,
 __BPF_CGROUP_STORAGE_MAX
};
# 410 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct bpf_prog_stats {
 u64 cnt;
 u64 nsecs;
 struct u64_stats_sync syncp;
} __attribute__((__aligned__(2 * sizeof(u64))));

struct btf_func_model {
 u8 ret_size;
 u8 nr_args;
 u8 arg_size[12];
};
# 456 "/home/nathan/src/linux-next/include/linux/bpf.h"
int arch_prepare_bpf_trampoline(void *image, void *image_end,
    const struct btf_func_model *m, u32 flags,
    struct bpf_prog **fentry_progs, int fentry_cnt,
    struct bpf_prog **fexit_progs, int fexit_cnt,
    void *orig_call);

u64 __attribute__((__no_instrument_function__)) __bpf_prog_enter(void);
void __attribute__((__no_instrument_function__)) __bpf_prog_exit(struct bpf_prog *prog, u64 start);

enum bpf_tramp_prog_type {
 BPF_TRAMP_FENTRY,
 BPF_TRAMP_FEXIT,
 BPF_TRAMP_MAX,
 BPF_TRAMP_REPLACE,
};

struct bpf_trampoline {

 struct hlist_node hlist;

 struct mutex mutex;
 refcount_t refcnt;
 u64 key;
 struct {
  struct btf_func_model model;
  void *addr;
  bool ftrace_managed;
 } func;




 struct bpf_prog *extension_prog;

 struct hlist_head progs_hlist[BPF_TRAMP_MAX];

 int progs_cnt[BPF_TRAMP_MAX];

 void *image;
 u64 selector;
};



struct bpf_dispatcher_prog {
 struct bpf_prog *prog;
 refcount_t users;
};

struct bpf_dispatcher {

 struct mutex mutex;
 void *func;
 struct bpf_dispatcher_prog progs[48];
 int num_progs;
 void *image;
 u32 image_off;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) unsigned int bpf_dispatcher_nopfunc(
 const void *ctx,
 const struct bpf_insn *insnsi,
 unsigned int (*bpf_func)(const void *,
     const struct bpf_insn *))
{
 return bpf_func(ctx, insnsi);
}

struct bpf_trampoline *bpf_trampoline_lookup(u64 key);
int bpf_trampoline_link_prog(struct bpf_prog *prog);
int bpf_trampoline_unlink_prog(struct bpf_prog *prog);
void bpf_trampoline_put(struct bpf_trampoline *tr);
# 557 "/home/nathan/src/linux-next/include/linux/bpf.h"
void bpf_dispatcher_change_prog(struct bpf_dispatcher *d, struct bpf_prog *from,
    struct bpf_prog *to);
struct bpf_image {
 struct latch_tree_node tnode;
 unsigned char data[];
};

bool is_bpf_image_address(unsigned long address);
void *bpf_image_alloc(void);
# 593 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct bpf_func_info_aux {
 u16 linkage;
 bool unreliable;
};

enum bpf_jit_poke_reason {
 BPF_POKE_REASON_TAIL_CALL,
};


struct bpf_jit_poke_descriptor {
 void *ip;
 union {
  struct {
   struct bpf_map *map;
   u32 key;
  } tail_call;
 };
 bool ip_stable;
 u8 adj_off;
 u16 reason;
};

struct bpf_prog_aux {
 atomic64_t refcnt;
 u32 used_map_cnt;
 u32 max_ctx_offset;
 u32 max_pkt_offset;
 u32 max_tp_access;
 u32 stack_depth;
 u32 id;
 u32 func_cnt;
 u32 func_idx;
 u32 attach_btf_id;
 struct bpf_prog *linked_prog;
 bool verifier_zext;
 bool offload_requested;
 bool attach_btf_trace;
 bool func_proto_unreliable;
 enum bpf_tramp_prog_type trampoline_prog_type;
 struct bpf_trampoline *trampoline;
 struct hlist_node tramp_hlist;

 const struct btf_type *attach_func_proto;

 const char *attach_func_name;
 struct bpf_prog **func;
 void *jit_data;
 struct bpf_jit_poke_descriptor *poke_tab;
 u32 size_poke_tab;
 struct latch_tree_node ksym_tnode;
 struct list_head ksym_lnode;
 const struct bpf_prog_ops *ops;
 struct bpf_map **used_maps;
 struct bpf_prog *prog;
 struct user_struct *user;
 u64 load_time;
 struct bpf_map *cgroup_storage[__BPF_CGROUP_STORAGE_MAX];
 char name[16U];



 struct bpf_prog_offload *offload;
 struct btf *btf;
 struct bpf_func_info *func_info;
 struct bpf_func_info_aux *func_info_aux;






 struct bpf_line_info *linfo;







 void **jited_linfo;
 u32 func_info_cnt;
 u32 nr_linfo;




 u32 linfo_idx;
 u32 num_exentries;
 struct exception_table_entry *extable;
 struct bpf_prog_stats *stats;
 union {
  struct work_struct work;
  struct callback_head rcu;
 };
};

struct bpf_array_aux {





 enum bpf_prog_type type;
 bool jited;

 struct list_head poke_progs;
 struct bpf_map *map;
 struct mutex poke_mutex;
 struct work_struct work;
};

struct bpf_struct_ops_value;
struct btf_type;
struct btf_member;


struct bpf_struct_ops {
 const struct bpf_verifier_ops *verifier_ops;
 int (*init)(struct btf *btf);
 int (*check_member)(const struct btf_type *t,
       const struct btf_member *member);
 int (*init_member)(const struct btf_type *t,
      const struct btf_member *member,
      void *kdata, const void *udata);
 int (*reg)(void *kdata);
 void (*unreg)(void *kdata);
 const struct btf_type *type;
 const struct btf_type *value_type;
 const char *name;
 struct btf_func_model func_models[64];
 u32 type_id;
 u32 value_id;
};



const struct bpf_struct_ops *bpf_struct_ops_find(u32 type_id);
void bpf_struct_ops_init(struct btf *btf, struct bpf_verifier_log *log);
bool bpf_struct_ops_get(const void *kdata);
void bpf_struct_ops_put(const void *kdata);
int bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,
           void *value);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_try_module_get(const void *data, struct module *owner)
{
 if (owner == ((void *)((0xeB9FUL << 2) + (0x5deadbeef0000000UL))))
  return bpf_struct_ops_get(data);
 else
  return try_module_get(owner);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_module_put(const void *data, struct module *owner)
{
 if (owner == ((void *)((0xeB9FUL << 2) + (0x5deadbeef0000000UL))))
  bpf_struct_ops_put(data);
 else
  module_put(owner);
}
# 775 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct bpf_array {
 struct bpf_map map;
 u32 elem_size;
 u32 index_mask;
 struct bpf_array_aux *aux;
 union {
  char value[0] __attribute__((__aligned__(8)));
  void *ptrs[0] __attribute__((__aligned__(8)));
  void *pptrs[0] __attribute__((__aligned__(8)));
 };
};
# 798 "/home/nathan/src/linux-next/include/linux/bpf.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_map_flags_to_cap(struct bpf_map *map)
{
 u32 access_flags = map->map_flags & ((1U << 7) | (1U << 8));




 if (access_flags & (1U << 7))
  return ((((1UL))) << (0));
 else if (access_flags & (1U << 8))
  return ((((1UL))) << (1));
 else
  return ((((1UL))) << (0)) | ((((1UL))) << (1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_map_flags_access_ok(u32 access_flags)
{
 return (access_flags & ((1U << 7) | (1U << 8))) !=
        ((1U << 7) | (1U << 8));
}

struct bpf_event_entry {
 struct perf_event *event;
 struct file *perf_file;
 struct file *map_file;
 struct callback_head rcu;
};

bool bpf_prog_array_compatible(struct bpf_array *array, const struct bpf_prog *fp);
int bpf_prog_calc_tag(struct bpf_prog *fp);
const char *kernel_type_name(u32 btf_type_id);

const struct bpf_func_proto *bpf_get_trace_printk_proto(void);

typedef unsigned long (*bpf_ctx_copy_t)(void *dst, const void *src,
     unsigned long off, unsigned long len);
typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type type,
     const struct bpf_insn *src,
     struct bpf_insn *dst,
     struct bpf_prog *prog,
     u32 *target_size);

u64 bpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,
       void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy);
# 855 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct bpf_prog_array_item {
 struct bpf_prog *prog;
 struct bpf_cgroup_storage *cgroup_storage[__BPF_CGROUP_STORAGE_MAX];
};

struct bpf_prog_array {
 struct callback_head rcu;
 struct bpf_prog_array_item items[0];
};

struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags);
void bpf_prog_array_free(struct bpf_prog_array *progs);
int bpf_prog_array_length(struct bpf_prog_array *progs);
bool bpf_prog_array_is_empty(struct bpf_prog_array *array);
int bpf_prog_array_copy_to_user(struct bpf_prog_array *progs,
    __u32 *prog_ids, u32 cnt);

void bpf_prog_array_delete_safe(struct bpf_prog_array *progs,
    struct bpf_prog *old_prog);
int bpf_prog_array_copy_info(struct bpf_prog_array *array,
        u32 *prog_ids, u32 request_cnt,
        u32 *prog_cnt);
int bpf_prog_array_copy(struct bpf_prog_array *old_array,
   struct bpf_prog *exclude_prog,
   struct bpf_prog *include_prog,
   struct bpf_prog_array **new_array);
# 962 "/home/nathan/src/linux-next/include/linux/bpf.h"
extern __attribute__((section(".data..percpu" ""))) __typeof__(int) bpf_prog_active;

extern const struct file_operations bpf_map_fops;
extern const struct file_operations bpf_prog_fops;







# 1 "/home/nathan/src/linux-next/include/linux/bpf_types.h" 1




extern const struct bpf_prog_ops sk_filter_prog_ops; extern const struct bpf_verifier_ops sk_filter_verifier_ops;

extern const struct bpf_prog_ops tc_cls_act_prog_ops; extern const struct bpf_verifier_ops tc_cls_act_verifier_ops;

extern const struct bpf_prog_ops tc_cls_act_prog_ops; extern const struct bpf_verifier_ops tc_cls_act_verifier_ops;

extern const struct bpf_prog_ops xdp_prog_ops; extern const struct bpf_verifier_ops xdp_verifier_ops;


extern const struct bpf_prog_ops cg_skb_prog_ops; extern const struct bpf_verifier_ops cg_skb_verifier_ops;

extern const struct bpf_prog_ops cg_sock_prog_ops; extern const struct bpf_verifier_ops cg_sock_verifier_ops;

extern const struct bpf_prog_ops cg_sock_addr_prog_ops; extern const struct bpf_verifier_ops cg_sock_addr_verifier_ops;


extern const struct bpf_prog_ops lwt_in_prog_ops; extern const struct bpf_verifier_ops lwt_in_verifier_ops;

extern const struct bpf_prog_ops lwt_out_prog_ops; extern const struct bpf_verifier_ops lwt_out_verifier_ops;

extern const struct bpf_prog_ops lwt_xmit_prog_ops; extern const struct bpf_verifier_ops lwt_xmit_verifier_ops;

extern const struct bpf_prog_ops lwt_seg6local_prog_ops; extern const struct bpf_verifier_ops lwt_seg6local_verifier_ops;

extern const struct bpf_prog_ops sock_ops_prog_ops; extern const struct bpf_verifier_ops sock_ops_verifier_ops;

extern const struct bpf_prog_ops sk_skb_prog_ops; extern const struct bpf_verifier_ops sk_skb_verifier_ops;

extern const struct bpf_prog_ops sk_msg_prog_ops; extern const struct bpf_verifier_ops sk_msg_verifier_ops;

extern const struct bpf_prog_ops flow_dissector_prog_ops; extern const struct bpf_verifier_ops flow_dissector_verifier_ops;



extern const struct bpf_prog_ops kprobe_prog_ops; extern const struct bpf_verifier_ops kprobe_verifier_ops;

extern const struct bpf_prog_ops tracepoint_prog_ops; extern const struct bpf_verifier_ops tracepoint_verifier_ops;

extern const struct bpf_prog_ops perf_event_prog_ops; extern const struct bpf_verifier_ops perf_event_verifier_ops;

extern const struct bpf_prog_ops raw_tracepoint_prog_ops; extern const struct bpf_verifier_ops raw_tracepoint_verifier_ops;

extern const struct bpf_prog_ops raw_tracepoint_writable_prog_ops; extern const struct bpf_verifier_ops raw_tracepoint_writable_verifier_ops;

extern const struct bpf_prog_ops tracing_prog_ops; extern const struct bpf_verifier_ops tracing_verifier_ops;



extern const struct bpf_prog_ops cg_dev_prog_ops; extern const struct bpf_verifier_ops cg_dev_verifier_ops;

extern const struct bpf_prog_ops cg_sysctl_prog_ops; extern const struct bpf_verifier_ops cg_sysctl_verifier_ops;

extern const struct bpf_prog_ops cg_sockopt_prog_ops; extern const struct bpf_verifier_ops cg_sockopt_verifier_ops;







extern const struct bpf_prog_ops sk_reuseport_prog_ops; extern const struct bpf_verifier_ops sk_reuseport_verifier_ops;



extern const struct bpf_prog_ops bpf_struct_ops_prog_ops; extern const struct bpf_verifier_ops bpf_struct_ops_verifier_ops;

extern const struct bpf_prog_ops bpf_extension_prog_ops; extern const struct bpf_verifier_ops bpf_extension_verifier_ops;



extern const struct bpf_map_ops array_map_ops;
extern const struct bpf_map_ops percpu_array_map_ops;
extern const struct bpf_map_ops prog_array_map_ops;
extern const struct bpf_map_ops perf_event_array_map_ops;

extern const struct bpf_map_ops cgroup_array_map_ops;


extern const struct bpf_map_ops cgroup_storage_map_ops;
extern const struct bpf_map_ops cgroup_storage_map_ops;

extern const struct bpf_map_ops htab_map_ops;
extern const struct bpf_map_ops htab_percpu_map_ops;
extern const struct bpf_map_ops htab_lru_map_ops;
extern const struct bpf_map_ops htab_lru_percpu_map_ops;
extern const struct bpf_map_ops trie_map_ops;

extern const struct bpf_map_ops stack_trace_map_ops;

extern const struct bpf_map_ops array_of_maps_map_ops;
extern const struct bpf_map_ops htab_of_maps_map_ops;

extern const struct bpf_map_ops dev_map_ops;
extern const struct bpf_map_ops dev_map_hash_ops;
extern const struct bpf_map_ops sk_storage_map_ops;




extern const struct bpf_map_ops cpu_map_ops;




extern const struct bpf_map_ops reuseport_array_ops;


extern const struct bpf_map_ops queue_map_ops;
extern const struct bpf_map_ops stack_map_ops;

extern const struct bpf_map_ops bpf_struct_ops_map_ops;
# 973 "/home/nathan/src/linux-next/include/linux/bpf.h" 2



extern const struct bpf_prog_ops bpf_offload_prog_ops;
extern const struct bpf_verifier_ops tc_cls_act_analyzer_ops;
extern const struct bpf_verifier_ops xdp_analyzer_ops;

struct bpf_prog *bpf_prog_get(u32 ufd);
struct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,
           bool attach_drv);
void bpf_prog_add(struct bpf_prog *prog, int i);
void bpf_prog_sub(struct bpf_prog *prog, int i);
void bpf_prog_inc(struct bpf_prog *prog);
struct bpf_prog * __attribute__((__warn_unused_result__)) bpf_prog_inc_not_zero(struct bpf_prog *prog);
void bpf_prog_put(struct bpf_prog *prog);
int __bpf_prog_charge(struct user_struct *user, u32 pages);
void __bpf_prog_uncharge(struct user_struct *user, u32 pages);
void __bpf_free_used_maps(struct bpf_prog_aux *aux,
     struct bpf_map **used_maps, u32 len);

void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock);
void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock);

struct bpf_map *bpf_map_get_with_uref(u32 ufd);
struct bpf_map *__bpf_map_get(struct fd f);
void bpf_map_inc(struct bpf_map *map);
void bpf_map_inc_with_uref(struct bpf_map *map);
struct bpf_map * __attribute__((__warn_unused_result__)) bpf_map_inc_not_zero(struct bpf_map *map);
void bpf_map_put_with_uref(struct bpf_map *map);
void bpf_map_put(struct bpf_map *map);
int bpf_map_charge_memlock(struct bpf_map *map, u32 pages);
void bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages);
int bpf_map_charge_init(struct bpf_map_memory *mem, u64 size);
void bpf_map_charge_finish(struct bpf_map_memory *mem);
void bpf_map_charge_move(struct bpf_map_memory *dst,
    struct bpf_map_memory *src);
void *bpf_map_area_alloc(u64 size, int numa_node);
void *bpf_map_area_mmapable_alloc(u64 size, int numa_node);
void bpf_map_area_free(void *base);
void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr);
int generic_map_lookup_batch(struct bpf_map *map,
         const union bpf_attr *attr,
         union bpf_attr *uattr);
int generic_map_update_batch(struct bpf_map *map,
         const union bpf_attr *attr,
         union bpf_attr *uattr);
int generic_map_delete_batch(struct bpf_map *map,
         const union bpf_attr *attr,
         union bpf_attr *uattr);

extern int sysctl_unprivileged_bpf_disabled;

int bpf_map_new_fd(struct bpf_map *map, int flags);
int bpf_prog_new_fd(struct bpf_prog *prog);

int bpf_obj_pin_user(u32 ufd, const char *pathname);
int bpf_obj_get_user(const char *pathname, int flags);

int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,
      u64 flags);
int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,
       u64 flags);

int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value);

int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,
     void *key, void *value, u64 map_flags);
int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);
int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
    void *key, void *value, u64 map_flags);
int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);

int bpf_get_file_flag(int flags);
int bpf_check_uarg_tail_zero(void *uaddr, size_t expected_size,
        size_t actual_size);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_long_memcpy(void *dst, const void *src, u32 size)
{
 const long *lsrc = src;
 long *ldst = dst;

 size /= sizeof(long);
 while (size--)
  *ldst++ = *lsrc++;
}


int bpf_check(struct bpf_prog **fp, union bpf_attr *attr,
       union bpf_attr *uattr);
void bpf_patch_call_args(struct bpf_insn *insn, u32 stack_depth);


struct xdp_buff;
struct sk_buff;

struct bpf_dtab_netdev *__dev_map_lookup_elem(struct bpf_map *map, u32 key);
struct bpf_dtab_netdev *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key);
void __dev_flush(void);
int dev_xdp_enqueue(struct net_device *dev, struct xdp_buff *xdp,
      struct net_device *dev_rx);
int dev_map_enqueue(struct bpf_dtab_netdev *dst, struct xdp_buff *xdp,
      struct net_device *dev_rx);
int dev_map_generic_redirect(struct bpf_dtab_netdev *dst, struct sk_buff *skb,
        struct bpf_prog *xdp_prog);

struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key);
void __cpu_map_flush(void);
int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu, struct xdp_buff *xdp,
      struct net_device *dev_rx);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bpf_map_attr_numa_node(const union bpf_attr *attr)
{
 return (attr->map_flags & (1U << 2)) ?
  attr->numa_node : (-1);
}

struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type);
int array_map_alloc_check(union bpf_attr *attr);

int bpf_prog_test_run_xdp(struct bpf_prog *prog, const union bpf_attr *kattr,
     union bpf_attr *uattr);
int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
     union bpf_attr *uattr);
int bpf_prog_test_run_flow_dissector(struct bpf_prog *prog,
         const union bpf_attr *kattr,
         union bpf_attr *uattr);
bool btf_ctx_access(int off, int size, enum bpf_access_type type,
      const struct bpf_prog *prog,
      struct bpf_insn_access_aux *info);
int btf_struct_access(struct bpf_verifier_log *log,
        const struct btf_type *t, int off, int size,
        enum bpf_access_type atype,
        u32 *next_btf_id);
int btf_resolve_helper_id(struct bpf_verifier_log *log,
     const struct bpf_func_proto *fn, int);

int btf_distill_func_proto(struct bpf_verifier_log *log,
      struct btf *btf,
      const struct btf_type *func_proto,
      const char *func_name,
      struct btf_func_model *m);

struct bpf_reg_state;
int btf_check_func_arg_match(struct bpf_verifier_env *env, int subprog,
        struct bpf_reg_state *regs);
int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,
     struct bpf_reg_state *reg);
int btf_check_type_match(struct bpf_verifier_env *env, struct bpf_prog *prog,
    struct btf *btf, const struct btf_type *t);

struct bpf_prog *bpf_prog_by_id(u32 id);
# 1279 "/home/nathan/src/linux-next/include/linux/bpf.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bpf_prog *bpf_prog_get_type(u32 ufd,
       enum bpf_prog_type type)
{
 return bpf_prog_get_type_dev(ufd, type, false);
}

bool bpf_prog_get_ok(struct bpf_prog *, enum bpf_prog_type *, bool);

int bpf_prog_offload_compile(struct bpf_prog *prog);
void bpf_prog_offload_destroy(struct bpf_prog *prog);
int bpf_prog_offload_info_fill(struct bpf_prog_info *info,
          struct bpf_prog *prog);

int bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map);

int bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value);
int bpf_map_offload_update_elem(struct bpf_map *map,
    void *key, void *value, u64 flags);
int bpf_map_offload_delete_elem(struct bpf_map *map, void *key);
int bpf_map_offload_get_next_key(struct bpf_map *map,
     void *key, void *next_key);

bool bpf_offload_prog_map_match(struct bpf_prog *prog, struct bpf_map *map);

struct bpf_offload_dev *
bpf_offload_dev_create(const struct bpf_prog_offload_ops *ops, void *priv);
void bpf_offload_dev_destroy(struct bpf_offload_dev *offdev);
void *bpf_offload_dev_priv(struct bpf_offload_dev *offdev);
int bpf_offload_dev_netdev_register(struct bpf_offload_dev *offdev,
        struct net_device *netdev);
void bpf_offload_dev_netdev_unregister(struct bpf_offload_dev *offdev,
           struct net_device *netdev);
bool bpf_offload_dev_match(struct bpf_prog *prog, struct net_device *netdev);


int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_prog_is_dev_bound(const struct bpf_prog_aux *aux)
{
 return aux->offload_requested;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_map_is_dev_bound(struct bpf_map *map)
{
 return __builtin_expect(!!(map->ops == &bpf_map_offload_ops), 0);
}

struct bpf_map *bpf_map_offload_map_alloc(union bpf_attr *attr);
void bpf_map_offload_map_free(struct bpf_map *map);
# 1359 "/home/nathan/src/linux-next/include/linux/bpf.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sock_map_prog_update(struct bpf_map *map,
           struct bpf_prog *prog, u32 which)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sock_map_get_from_fd(const union bpf_attr *attr,
           struct bpf_prog *prog)
{
 return -22;
}



void bpf_sk_reuseport_detach(struct sock *sk);
int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,
           void *value);
int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,
           void *value, u64 map_flags);
# 1400 "/home/nathan/src/linux-next/include/linux/bpf.h"
extern const struct bpf_func_proto bpf_map_lookup_elem_proto;
extern const struct bpf_func_proto bpf_map_update_elem_proto;
extern const struct bpf_func_proto bpf_map_delete_elem_proto;
extern const struct bpf_func_proto bpf_map_push_elem_proto;
extern const struct bpf_func_proto bpf_map_pop_elem_proto;
extern const struct bpf_func_proto bpf_map_peek_elem_proto;

extern const struct bpf_func_proto bpf_get_prandom_u32_proto;
extern const struct bpf_func_proto bpf_get_smp_processor_id_proto;
extern const struct bpf_func_proto bpf_get_numa_node_id_proto;
extern const struct bpf_func_proto bpf_tail_call_proto;
extern const struct bpf_func_proto bpf_ktime_get_ns_proto;
extern const struct bpf_func_proto bpf_get_current_pid_tgid_proto;
extern const struct bpf_func_proto bpf_get_current_uid_gid_proto;
extern const struct bpf_func_proto bpf_get_current_comm_proto;
extern const struct bpf_func_proto bpf_get_stackid_proto;
extern const struct bpf_func_proto bpf_get_stack_proto;
extern const struct bpf_func_proto bpf_sock_map_update_proto;
extern const struct bpf_func_proto bpf_sock_hash_update_proto;
extern const struct bpf_func_proto bpf_get_current_cgroup_id_proto;
extern const struct bpf_func_proto bpf_msg_redirect_hash_proto;
extern const struct bpf_func_proto bpf_msg_redirect_map_proto;
extern const struct bpf_func_proto bpf_sk_redirect_hash_proto;
extern const struct bpf_func_proto bpf_sk_redirect_map_proto;
extern const struct bpf_func_proto bpf_spin_lock_proto;
extern const struct bpf_func_proto bpf_spin_unlock_proto;
extern const struct bpf_func_proto bpf_get_local_storage_proto;
extern const struct bpf_func_proto bpf_strtol_proto;
extern const struct bpf_func_proto bpf_strtoul_proto;
extern const struct bpf_func_proto bpf_tcp_sock_proto;
extern const struct bpf_func_proto bpf_jiffies64_proto;


void bpf_user_rnd_init_once(void);
u64 bpf_user_rnd_u32(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);


bool bpf_sock_common_is_valid_access(int off, int size,
         enum bpf_access_type type,
         struct bpf_insn_access_aux *info);
bool bpf_sock_is_valid_access(int off, int size, enum bpf_access_type type,
         struct bpf_insn_access_aux *info);
u32 bpf_sock_convert_ctx_access(enum bpf_access_type type,
    const struct bpf_insn *si,
    struct bpf_insn *insn_buf,
    struct bpf_prog *prog,
    u32 *target_size);
# 1471 "/home/nathan/src/linux-next/include/linux/bpf.h"
struct sk_reuseport_kern {
 struct sk_buff *skb;
 struct sock *sk;
 struct sock *selected_sk;
 void *data_end;
 u32 hash;
 u32 reuseport_id;
 bool bind_inany;
};
bool bpf_tcp_sock_is_valid_access(int off, int size, enum bpf_access_type type,
      struct bpf_insn_access_aux *info);

u32 bpf_tcp_sock_convert_ctx_access(enum bpf_access_type type,
        const struct bpf_insn *si,
        struct bpf_insn *insn_buf,
        struct bpf_prog *prog,
        u32 *target_size);

bool bpf_xdp_sock_is_valid_access(int off, int size, enum bpf_access_type type,
      struct bpf_insn_access_aux *info);

u32 bpf_xdp_sock_convert_ctx_access(enum bpf_access_type type,
        const struct bpf_insn *si,
        struct bpf_insn *insn_buf,
        struct bpf_prog *prog,
        u32 *target_size);
# 1530 "/home/nathan/src/linux-next/include/linux/bpf.h"
enum bpf_text_poke_type {
 BPF_MOD_CALL,
 BPF_MOD_JUMP,
};

int bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,
         void *addr1, void *addr2);
# 6 "/home/nathan/src/linux-next/include/linux/bpf-cgroup.h" 2







struct sock;
struct sockaddr;
struct cgroup;
struct sk_buff;
struct bpf_map;
struct bpf_prog;
struct bpf_sock_ops_kern;
struct bpf_cgroup_storage;
struct ctl_table;
struct ctl_table_header;



extern struct static_key_false cgroup_bpf_enabled_key;


extern __attribute__((section(".data..percpu" ""))) __typeof__(struct bpf_cgroup_storage*) bpf_cgroup_storage[__BPF_CGROUP_STORAGE_MAX];





struct bpf_cgroup_storage_map;

struct bpf_storage_buffer {
 struct callback_head rcu;
 char data[0];
};

struct bpf_cgroup_storage {
 union {
  struct bpf_storage_buffer *buf;
  void *percpu_buf;
 };
 struct bpf_cgroup_storage_map *map;
 struct bpf_cgroup_storage_key key;
 struct list_head list;
 struct rb_node node;
 struct callback_head rcu;
};

struct bpf_prog_list {
 struct list_head node;
 struct bpf_prog *prog;
 struct bpf_cgroup_storage *storage[__BPF_CGROUP_STORAGE_MAX];
};

struct bpf_prog_array;

struct cgroup_bpf {

 struct bpf_prog_array *effective[__MAX_BPF_ATTACH_TYPE];






 struct list_head progs[__MAX_BPF_ATTACH_TYPE];
 u32 flags[__MAX_BPF_ATTACH_TYPE];


 struct bpf_prog_array *inactive;


 struct percpu_ref refcnt;


 struct work_struct release_work;
};

int cgroup_bpf_inherit(struct cgroup *cgrp);
void cgroup_bpf_offline(struct cgroup *cgrp);

int __cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,
   struct bpf_prog *replace_prog,
   enum bpf_attach_type type, u32 flags);
int __cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,
   enum bpf_attach_type type);
int __cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,
         union bpf_attr *uattr);


int cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,
        struct bpf_prog *replace_prog, enum bpf_attach_type type,
        u32 flags);
int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,
        enum bpf_attach_type type, u32 flags);
int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,
       union bpf_attr *uattr);

int __cgroup_bpf_run_filter_skb(struct sock *sk,
    struct sk_buff *skb,
    enum bpf_attach_type type);

int __cgroup_bpf_run_filter_sk(struct sock *sk,
          enum bpf_attach_type type);

int __cgroup_bpf_run_filter_sock_addr(struct sock *sk,
          struct sockaddr *uaddr,
          enum bpf_attach_type type,
          void *t_ctx);

int __cgroup_bpf_run_filter_sock_ops(struct sock *sk,
         struct bpf_sock_ops_kern *sock_ops,
         enum bpf_attach_type type);

int __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,
          short access, enum bpf_attach_type type);

int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
       struct ctl_table *table, int write,
       void *buf, size_t *pcount,
       loff_t *ppos, void **new_buf,
       enum bpf_attach_type type);

int __cgroup_bpf_run_filter_setsockopt(struct sock *sock, int *level,
           int *optname, char *optval,
           int *optlen, char **kernel_optval);
int __cgroup_bpf_run_filter_getsockopt(struct sock *sk, int level,
           int optname, char *optval,
           int *optlen, int max_optlen,
           int retval);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum bpf_cgroup_storage_type cgroup_storage_type(
 struct bpf_map *map)
{
 if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)
  return BPF_CGROUP_STORAGE_PERCPU;

 return BPF_CGROUP_STORAGE_SHARED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_cgroup_storage_set(struct bpf_cgroup_storage
       *storage[__BPF_CGROUP_STORAGE_MAX])
{
 enum bpf_cgroup_storage_type stype;

 for (stype = 0; stype < __BPF_CGROUP_STORAGE_MAX; stype++)
  do { do { const void *__vpp_verify = (typeof((&(bpf_cgroup_storage[stype])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(bpf_cgroup_storage[stype])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(bpf_cgroup_storage[stype])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype]))); (typeof((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype])))) (__ptr + ((local_paca->data_offset))); }); }) = storage[stype]; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(bpf_cgroup_storage[stype])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype]))); (typeof((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype])))) (__ptr + ((local_paca->data_offset))); }); }) = storage[stype]; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(bpf_cgroup_storage[stype])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype]))); (typeof((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype])))) (__ptr + ((local_paca->data_offset))); }); }) = storage[stype]; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(bpf_cgroup_storage[stype])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype]))); (typeof((typeof(*(&(bpf_cgroup_storage[stype]))) *)(&(bpf_cgroup_storage[stype])))) (__ptr + ((local_paca->data_offset))); }); }) = storage[stype]; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

struct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,
     enum bpf_cgroup_storage_type stype);
void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage);
void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,
        struct cgroup *cgroup,
        enum bpf_attach_type type);
void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage);
int bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *map);
void bpf_cgroup_storage_release(struct bpf_prog_aux *aux, struct bpf_map *map);

int bpf_percpu_cgroup_storage_copy(struct bpf_map *map, void *key, void *value);
int bpf_percpu_cgroup_storage_update(struct bpf_map *map, void *key,
         void *value, u64 flags);
# 331 "/home/nathan/src/linux-next/include/linux/bpf-cgroup.h"
int cgroup_bpf_prog_attach(const union bpf_attr *attr,
      enum bpf_prog_type ptype, struct bpf_prog *prog);
int cgroup_bpf_prog_detach(const union bpf_attr *attr,
      enum bpf_prog_type ptype);
int cgroup_bpf_prog_query(const union bpf_attr *attr,
     union bpf_attr *uattr);
# 23 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/psi_types.h" 1



# 1 "/home/nathan/src/linux-next/include/linux/kthread.h" 1







__attribute__((__format__(printf, 4, 5)))
struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
        void *data,
        int node,
        const char namefmt[], ...);
# 29 "/home/nathan/src/linux-next/include/linux/kthread.h"
struct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),
       void *data,
       unsigned int cpu,
       const char *namefmt);
# 52 "/home/nathan/src/linux-next/include/linux/kthread.h"
void free_kthread_struct(struct task_struct *k);
void kthread_bind(struct task_struct *k, unsigned int cpu);
void kthread_bind_mask(struct task_struct *k, const struct cpumask *mask);
int kthread_stop(struct task_struct *k);
bool kthread_should_stop(void);
bool kthread_should_park(void);
bool __kthread_should_park(struct task_struct *k);
bool kthread_freezable_should_stop(bool *was_frozen);
void *kthread_data(struct task_struct *k);
void *kthread_probe_data(struct task_struct *k);
int kthread_park(struct task_struct *k);
void kthread_unpark(struct task_struct *k);
void kthread_parkme(void);

int kthreadd(void *unused);
extern struct task_struct *kthreadd_task;
extern int tsk_fork_get_node(struct task_struct *tsk);
# 78 "/home/nathan/src/linux-next/include/linux/kthread.h"
struct kthread_work;
typedef void (*kthread_work_func_t)(struct kthread_work *work);
void kthread_delayed_work_timer_fn(struct timer_list *t);

enum {
 KTW_FREEZABLE = 1 << 0,
};

struct kthread_worker {
 unsigned int flags;
 raw_spinlock_t lock;
 struct list_head work_list;
 struct list_head delayed_work_list;
 struct task_struct *task;
 struct kthread_work *current_work;
};

struct kthread_work {
 struct list_head node;
 kthread_work_func_t func;
 struct kthread_worker *worker;

 int canceling;
};

struct kthread_delayed_work {
 struct kthread_work work;
 struct timer_list timer;
};
# 148 "/home/nathan/src/linux-next/include/linux/kthread.h"
extern void __kthread_init_worker(struct kthread_worker *worker,
   const char *name, struct lock_class_key *key);
# 171 "/home/nathan/src/linux-next/include/linux/kthread.h"
int kthread_worker_fn(void *worker_ptr);

__attribute__((__format__(printf, 2, 3)))
struct kthread_worker *
kthread_create_worker(unsigned int flags, const char namefmt[], ...);

__attribute__((__format__(printf, 3, 4))) struct kthread_worker *
kthread_create_worker_on_cpu(int cpu, unsigned int flags,
        const char namefmt[], ...);

bool kthread_queue_work(struct kthread_worker *worker,
   struct kthread_work *work);

bool kthread_queue_delayed_work(struct kthread_worker *worker,
    struct kthread_delayed_work *dwork,
    unsigned long delay);

bool kthread_mod_delayed_work(struct kthread_worker *worker,
         struct kthread_delayed_work *dwork,
         unsigned long delay);

void kthread_flush_work(struct kthread_work *work);
void kthread_flush_worker(struct kthread_worker *worker);

bool kthread_cancel_work_sync(struct kthread_work *work);
bool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *work);

void kthread_destroy_worker(struct kthread_worker *worker);

struct cgroup_subsys_state;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kthread_associate_blkcg(struct cgroup_subsys_state *css) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup_subsys_state *kthread_blkcg(void)
{
 return ((void *)0);
}
# 5 "/home/nathan/src/linux-next/include/linux/psi_types.h" 2
# 169 "/home/nathan/src/linux-next/include/linux/psi_types.h"
struct psi_group { };
# 24 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h" 2



struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct kernfs_node;
struct kernfs_ops;
struct kernfs_open_file;
struct seq_file;
struct poll_table_struct;







enum cgroup_subsys_id {

# 1 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h"
cpuset_cgrp_id,



cpu_cgrp_id,



cpuacct_cgrp_id,







memory_cgrp_id,



devices_cgrp_id,



freezer_cgrp_id,







perf_event_cgrp_id,
# 45 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h" 2
 CGROUP_SUBSYS_COUNT,
};



enum {
 CSS_NO_REF = (1 << 0),
 CSS_ONLINE = (1 << 1),
 CSS_RELEASED = (1 << 2),
 CSS_VISIBLE = (1 << 3),
 CSS_DYING = (1 << 4),
};


enum {

 CGRP_NOTIFY_ON_RELEASE,





 CGRP_CPUSET_CLONE_CHILDREN,


 CGRP_FREEZE,


 CGRP_FROZEN,
};


enum {
 CGRP_ROOT_NOPREFIX = (1 << 1),
 CGRP_ROOT_XATTR = (1 << 2),






 CGRP_ROOT_NS_DELEGATE = (1 << 3),




 CGRP_ROOT_CPUSET_V2_MODE = (1 << 4),




 CGRP_ROOT_MEMORY_LOCAL_EVENTS = (1 << 5),
};


enum {
 CFTYPE_ONLY_ON_ROOT = (1 << 0),
 CFTYPE_NOT_ON_ROOT = (1 << 1),
 CFTYPE_NS_DELEGATABLE = (1 << 2),

 CFTYPE_NO_PREFIX = (1 << 3),
 CFTYPE_WORLD_WRITABLE = (1 << 4),
 CFTYPE_DEBUG = (1 << 5),


 __CFTYPE_ONLY_ON_DFL = (1 << 16),
 __CFTYPE_NOT_ON_DFL = (1 << 17),
};






struct cgroup_file {

 struct kernfs_node *kn;
 unsigned long notified_at;
 struct timer_list notify_timer;
};
# 133 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
struct cgroup_subsys_state {

 struct cgroup *cgroup;


 struct cgroup_subsys *ss;


 struct percpu_ref refcnt;


 struct list_head sibling;
 struct list_head children;


 struct list_head rstat_css_node;





 int id;

 unsigned int flags;







 u64 serial_nr;





 atomic_t online_cnt;


 struct work_struct destroy_work;
 struct rcu_work destroy_rwork;





 struct cgroup_subsys_state *parent;
};
# 190 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
struct css_set {





 struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];


 refcount_t refcount;







 struct css_set *dom_cset;


 struct cgroup *dfl_cgrp;


 int nr_tasks;
# 222 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct list_head tasks;
 struct list_head mg_tasks;
 struct list_head dying_tasks;


 struct list_head task_iters;
# 236 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct list_head e_cset_node[CGROUP_SUBSYS_COUNT];


 struct list_head threaded_csets;
 struct list_head threaded_csets_node;





 struct hlist_node hlist;





 struct list_head cgrp_links;





 struct list_head mg_preload_node;
 struct list_head mg_node;
# 268 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct cgroup *mg_src_cgrp;
 struct cgroup *mg_dst_cgrp;
 struct css_set *mg_dst_cset;


 bool dead;


 struct callback_head callback_head;
};

struct cgroup_base_stat {
 struct task_cputime cputime;
};
# 303 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
struct cgroup_rstat_cpu {




 struct u64_stats_sync bsync;
 struct cgroup_base_stat bstat;





 struct cgroup_base_stat last_bstat;
# 328 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct cgroup *updated_children;
 struct cgroup *updated_next;
};

struct cgroup_freezer_state {

 bool freeze;


 int e_freeze;




 int nr_frozen_descendants;





 int nr_frozen_tasks;
};

struct cgroup {

 struct cgroup_subsys_state self;

 unsigned long flags;







 int level;


 int max_depth;
# 379 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 int nr_descendants;
 int nr_dying_descendants;
 int max_descendants;
# 394 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 int nr_populated_csets;
 int nr_populated_domain_children;
 int nr_populated_threaded_children;

 int nr_threaded_children;

 struct kernfs_node *kn;
 struct cgroup_file procs_file;
 struct cgroup_file events_file;
# 411 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 u16 subtree_control;
 u16 subtree_ss_mask;
 u16 old_subtree_control;
 u16 old_subtree_ss_mask;


 struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];

 struct cgroup_root *root;





 struct list_head cset_links;
# 434 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct list_head e_csets[CGROUP_SUBSYS_COUNT];
# 443 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 struct cgroup *dom_cgrp;
 struct cgroup *old_dom_cgrp;


 struct cgroup_rstat_cpu *rstat_cpu;
 struct list_head rstat_css_list;


 struct cgroup_base_stat last_bstat;
 struct cgroup_base_stat bstat;
 struct prev_cputime prev_cputime;





 struct list_head pidlists;
 struct mutex pidlist_mutex;


 wait_queue_head_t offline_waitq;


 struct work_struct release_agent_work;


 struct psi_group psi;


 struct cgroup_bpf bpf;


 atomic_t congestion_count;


 struct cgroup_freezer_state freezer;


 u64 ancestor_ids[];
};






struct cgroup_root {
 struct kernfs_root *kf_root;


 unsigned int subsys_mask;


 int hierarchy_id;


 struct cgroup cgrp;


 u64 cgrp_ancestor_id_storage;


 atomic_t nr_cgrps;


 struct list_head root_list;


 unsigned int flags;


 char release_agent_path[4096];


 char name[64];
};
# 527 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
struct cftype {





 char name[64];
 unsigned long private;





 size_t max_write_len;


 unsigned int flags;







 unsigned int file_offset;





 struct cgroup_subsys *ss;
 struct list_head node;
 struct kernfs_ops *kf_ops;

 int (*open)(struct kernfs_open_file *of);
 void (*release)(struct kernfs_open_file *of);





 u64 (*read_u64)(struct cgroup_subsys_state *css, struct cftype *cft);



 s64 (*read_s64)(struct cgroup_subsys_state *css, struct cftype *cft);


 int (*seq_show)(struct seq_file *sf, void *v);


 void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
 void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
 void (*seq_stop)(struct seq_file *sf, void *v);






 int (*write_u64)(struct cgroup_subsys_state *css, struct cftype *cft,
    u64 val);



 int (*write_s64)(struct cgroup_subsys_state *css, struct cftype *cft,
    s64 val);







 ssize_t (*write)(struct kernfs_open_file *of,
    char *buf, size_t nbytes, loff_t off);

 __poll_t (*poll)(struct kernfs_open_file *of,
    struct poll_table_struct *pt);




};





struct cgroup_subsys {
 struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *parent_css);
 int (*css_online)(struct cgroup_subsys_state *css);
 void (*css_offline)(struct cgroup_subsys_state *css);
 void (*css_released)(struct cgroup_subsys_state *css);
 void (*css_free)(struct cgroup_subsys_state *css);
 void (*css_reset)(struct cgroup_subsys_state *css);
 void (*css_rstat_flush)(struct cgroup_subsys_state *css, int cpu);
 int (*css_extra_stat_show)(struct seq_file *seq,
       struct cgroup_subsys_state *css);

 int (*can_attach)(struct cgroup_taskset *tset);
 void (*cancel_attach)(struct cgroup_taskset *tset);
 void (*attach)(struct cgroup_taskset *tset);
 void (*post_attach)(void);
 int (*can_fork)(struct task_struct *task);
 void (*cancel_fork)(struct task_struct *task);
 void (*fork)(struct task_struct *task);
 void (*exit)(struct task_struct *task);
 void (*release)(struct task_struct *task);
 void (*bind)(struct cgroup_subsys_state *root_css);

 bool early_init:1;
# 651 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 bool implicit_on_dfl:1;
# 663 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 bool threaded:1;
# 677 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 bool broken_hierarchy:1;
 bool warned_broken_hierarchy:1;


 int id;
 const char *name;


 const char *legacy_name;


 struct cgroup_root *root;


 struct idr css_idr;





 struct list_head cfts;





 struct cftype *dfl_cftypes;
 struct cftype *legacy_cftypes;
# 713 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
 unsigned int depends_on;
};

extern struct percpu_rw_semaphore cgroup_threadgroup_rwsem;
# 725 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_threadgroup_change_begin(struct task_struct *tsk)
{
 percpu_down_read(&cgroup_threadgroup_rwsem);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_threadgroup_change_end(struct task_struct *tsk)
{
 percpu_up_read(&cgroup_threadgroup_rwsem);
}
# 783 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
struct sock_cgroup_data {
 union {
# 793 "/home/nathan/src/linux-next/include/linux/cgroup-defs.h"
  struct {
   u32 classid;
   u16 prioidx;
   u8 padding;
   u8 is_data;
  } __attribute__((__packed__));

  u64 val;
 };
};






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 sock_cgroup_prioidx(const struct sock_cgroup_data *skcd)
{

 return (skcd->is_data & 1) ? skcd->prioidx : 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 sock_cgroup_classid(const struct sock_cgroup_data *skcd)
{

 return (skcd->is_data & 1) ? skcd->classid : 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_cgroup_set_prioidx(struct sock_cgroup_data *skcd,
        u16 prioidx)
{
 struct sock_cgroup_data skcd_buf = {{ .val = ({ union { typeof(skcd->val) __val; char __c[1]; } __u; if (1) __read_once_size(&(skcd->val), __u.__c, sizeof(skcd->val)); else __read_once_size_nocheck(&(skcd->val), __u.__c, sizeof(skcd->val)); do { } while (0); __u.__val; }) }};

 if (sock_cgroup_prioidx(&skcd_buf) == prioidx)
  return;

 if (!(skcd_buf.is_data & 1)) {
  skcd_buf.val = 0;
  skcd_buf.is_data = 1;
 }

 skcd_buf.prioidx = prioidx;
 ({ union { typeof(skcd->val) __val; char __c[1]; } __u = { .__val = ( typeof(skcd->val)) (skcd_buf.val) }; __write_once_size(&(skcd->val), __u.__c, sizeof(skcd->val)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_cgroup_set_classid(struct sock_cgroup_data *skcd,
        u32 classid)
{
 struct sock_cgroup_data skcd_buf = {{ .val = ({ union { typeof(skcd->val) __val; char __c[1]; } __u; if (1) __read_once_size(&(skcd->val), __u.__c, sizeof(skcd->val)); else __read_once_size_nocheck(&(skcd->val), __u.__c, sizeof(skcd->val)); do { } while (0); __u.__val; }) }};

 if (sock_cgroup_classid(&skcd_buf) == classid)
  return;

 if (!(skcd_buf.is_data & 1)) {
  skcd_buf.val = 0;
  skcd_buf.is_data = 1;
 }

 skcd_buf.classid = classid;
 ({ union { typeof(skcd->val) __val; char __c[1]; } __u = { .__val = ( typeof(skcd->val)) (skcd_buf.val) }; __write_once_size(&(skcd->val), __u.__c, sizeof(skcd->val)); __u.__val; });
}
# 29 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2
# 50 "/home/nathan/src/linux-next/include/linux/cgroup.h"
struct css_task_iter {
 struct cgroup_subsys *ss;
 unsigned int flags;

 struct list_head *cset_pos;
 struct list_head *cset_head;

 struct list_head *tcset_pos;
 struct list_head *tcset_head;

 struct list_head *task_pos;
 struct list_head *tasks_head;
 struct list_head *mg_tasks_head;
 struct list_head *dying_tasks_head;

 struct css_set *cur_cset;
 struct css_set *cur_dcset;
 struct task_struct *cur_task;
 struct list_head iters_node;
};

extern struct cgroup_root cgrp_dfl_root;
extern struct css_set init_css_set;



# 1 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h"
extern struct cgroup_subsys cpuset_cgrp_subsys;



extern struct cgroup_subsys cpu_cgrp_subsys;



extern struct cgroup_subsys cpuacct_cgrp_subsys;







extern struct cgroup_subsys memory_cgrp_subsys;



extern struct cgroup_subsys devices_cgrp_subsys;



extern struct cgroup_subsys freezer_cgrp_subsys;







extern struct cgroup_subsys perf_event_cgrp_subsys;
# 76 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/cgroup_subsys.h"
extern struct static_key_true cpuset_cgrp_subsys_enabled_key; extern struct static_key_true cpuset_cgrp_subsys_on_dfl_key;



extern struct static_key_true cpu_cgrp_subsys_enabled_key; extern struct static_key_true cpu_cgrp_subsys_on_dfl_key;



extern struct static_key_true cpuacct_cgrp_subsys_enabled_key; extern struct static_key_true cpuacct_cgrp_subsys_on_dfl_key;







extern struct static_key_true memory_cgrp_subsys_enabled_key; extern struct static_key_true memory_cgrp_subsys_on_dfl_key;



extern struct static_key_true devices_cgrp_subsys_enabled_key; extern struct static_key_true devices_cgrp_subsys_on_dfl_key;



extern struct static_key_true freezer_cgrp_subsys_enabled_key; extern struct static_key_true freezer_cgrp_subsys_on_dfl_key;







extern struct static_key_true perf_event_cgrp_subsys_enabled_key; extern struct static_key_true perf_event_cgrp_subsys_on_dfl_key;
# 82 "/home/nathan/src/linux-next/include/linux/cgroup.h" 2
# 98 "/home/nathan/src/linux-next/include/linux/cgroup.h"
bool css_has_online_children(struct cgroup_subsys_state *css);
struct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss);
struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgroup,
      struct cgroup_subsys *ss);
struct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgroup,
          struct cgroup_subsys *ss);
struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,
             struct cgroup_subsys *ss);

struct cgroup *cgroup_get_from_path(const char *path);
struct cgroup *cgroup_get_from_fd(int fd);

int cgroup_attach_task_all(struct task_struct *from, struct task_struct *);
int cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from);

int cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);
int cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);
int cgroup_rm_cftypes(struct cftype *cfts);
void cgroup_file_notify(struct cgroup_file *cfile);

int task_cgroup_path(struct task_struct *task, char *buf, size_t buflen);
int cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry);
int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,
       struct pid *pid, struct task_struct *tsk);

void cgroup_fork(struct task_struct *p);
extern int cgroup_can_fork(struct task_struct *p);
extern void cgroup_cancel_fork(struct task_struct *p);
extern void cgroup_post_fork(struct task_struct *p);
void cgroup_exit(struct task_struct *p);
void cgroup_release(struct task_struct *p);
void cgroup_free(struct task_struct *p);

int cgroup_init_early(void);
int cgroup_init(void);

int cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v);





struct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,
        struct cgroup_subsys_state *parent);
struct cgroup_subsys_state *css_next_descendant_pre(struct cgroup_subsys_state *pos,
          struct cgroup_subsys_state *css);
struct cgroup_subsys_state *css_rightmost_descendant(struct cgroup_subsys_state *pos);
struct cgroup_subsys_state *css_next_descendant_post(struct cgroup_subsys_state *pos,
           struct cgroup_subsys_state *css);

struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,
      struct cgroup_subsys_state **dst_cssp);
struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,
     struct cgroup_subsys_state **dst_cssp);

void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
    struct css_task_iter *it);
struct task_struct *css_task_iter_next(struct css_task_iter *it);
void css_task_iter_end(struct css_task_iter *it);
# 307 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 cgroup_id(struct cgroup *cgrp)
{
 return cgrp->kn->id;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void css_get(struct cgroup_subsys_state *css)
{
 if (!(css->flags & CSS_NO_REF))
  percpu_ref_get(&css->refcnt);
}
# 331 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void css_get_many(struct cgroup_subsys_state *css, unsigned int n)
{
 if (!(css->flags & CSS_NO_REF))
  percpu_ref_get_many(&css->refcnt, n);
}
# 348 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool css_tryget(struct cgroup_subsys_state *css)
{
 if (!(css->flags & CSS_NO_REF))
  return percpu_ref_tryget(&css->refcnt);
 return true;
}
# 365 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool css_tryget_online(struct cgroup_subsys_state *css)
{
 if (!(css->flags & CSS_NO_REF))
  return percpu_ref_tryget_live(&css->refcnt);
 return true;
}
# 387 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool css_is_dying(struct cgroup_subsys_state *css)
{
 return !(css->flags & CSS_NO_REF) && percpu_ref_is_dying(&css->refcnt);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void css_put(struct cgroup_subsys_state *css)
{
 if (!(css->flags & CSS_NO_REF))
  percpu_ref_put(&css->refcnt);
}
# 411 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void css_put_many(struct cgroup_subsys_state *css, unsigned int n)
{
 if (!(css->flags & CSS_NO_REF))
  percpu_ref_put_many(&css->refcnt, n);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_get(struct cgroup *cgrp)
{
 css_get(&cgrp->self);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cgroup_tryget(struct cgroup *cgrp)
{
 return css_tryget(&cgrp->self);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_put(struct cgroup *cgrp)
{
 css_put(&cgrp->self);
}
# 476 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct css_set *task_css_set(struct task_struct *task)
{
 return ({ typeof(*((task)->cgroups)) *________p1 = (typeof(*((task)->cgroups)) *)({ union { typeof(((task)->cgroups)) __val; char __c[1]; } __u; if (1) __read_once_size(&(((task)->cgroups)), __u.__c, sizeof(((task)->cgroups))); else __read_once_size_nocheck(&(((task)->cgroups)), __u.__c, sizeof(((task)->cgroups))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*((task)->cgroups)) *)(________p1)); });
}
# 488 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup_subsys_state *task_css(struct task_struct *task,
         int subsys_id)
{
 return ({ typeof(*(((task))->cgroups)) *________p1 = (typeof(*(((task))->cgroups)) *)({ union { typeof((((task))->cgroups)) __val; char __c[1]; } __u; if (1) __read_once_size(&((((task))->cgroups)), __u.__c, sizeof((((task))->cgroups))); else __read_once_size_nocheck(&((((task))->cgroups)), __u.__c, sizeof((((task))->cgroups))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(((task))->cgroups)) *)(________p1)); })->subsys[(subsys_id)];
}
# 503 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup_subsys_state *
task_get_css(struct task_struct *task, int subsys_id)
{
 struct cgroup_subsys_state *css;

 rcu_read_lock();
 while (true) {
  css = task_css(task, subsys_id);






  if (__builtin_expect(!!(css_tryget(css)), 1))
   break;
  do { asm volatile("or 1,1,1	     # low priority"); asm volatile("or 2,2,2	     # medium priority"); __asm__ __volatile__("" : : : "memory"); } while (0);
 }
 rcu_read_unlock();
 return css;
}
# 533 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_css_is_root(struct task_struct *task, int subsys_id)
{
 return ({ typeof(*(((task))->cgroups)) *________p1 = (typeof(*(((task))->cgroups)) *)({ union { typeof((((task))->cgroups)) __val; char __c[1]; } __u; if (1) __read_once_size(&((((task))->cgroups)), __u.__c, sizeof((((task))->cgroups))); else __read_once_size_nocheck(&((((task))->cgroups)), __u.__c, sizeof((((task))->cgroups))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(((task))->cgroups)) *)(________p1)); })->subsys[(subsys_id)] ==
  init_css_set.subsys[subsys_id];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup *task_cgroup(struct task_struct *task,
      int subsys_id)
{
 return task_css(task, subsys_id)->cgroup;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup *task_dfl_cgroup(struct task_struct *task)
{
 return task_css_set(task)->dfl_cgrp;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup *cgroup_parent(struct cgroup *cgrp)
{
 struct cgroup_subsys_state *parent_css = cgrp->self.parent;

 if (parent_css)
  return ({ void *__mptr = (void *)(parent_css); do { extern void __compiletime_assert_555(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(parent_css)), typeof(((struct cgroup *)0)->self)) && !__builtin_types_compatible_p(typeof(*(parent_css)), typeof(void))))) __compiletime_assert_555(); } while (0); ((struct cgroup *)(__mptr - __builtin_offsetof(struct cgroup, self))); });
 return ((void *)0);
}
# 568 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cgroup_is_descendant(struct cgroup *cgrp,
     struct cgroup *ancestor)
{
 if (cgrp->root != ancestor->root || cgrp->level < ancestor->level)
  return false;
 return cgrp->ancestor_ids[ancestor->level] == cgroup_id(ancestor);
}
# 587 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup *cgroup_ancestor(struct cgroup *cgrp,
          int ancestor_level)
{
 if (cgrp->level < ancestor_level)
  return ((void *)0);
 while (cgrp && cgrp->level > ancestor_level)
  cgrp = cgroup_parent(cgrp);
 return cgrp;
}
# 606 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_under_cgroup_hierarchy(struct task_struct *task,
            struct cgroup *ancestor)
{
 struct css_set *cset = task_css_set(task);

 return cgroup_is_descendant(cset->dfl_cgrp, ancestor);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cgroup_is_populated(struct cgroup *cgrp)
{
 return cgrp->nr_populated_csets + cgrp->nr_populated_domain_children +
  cgrp->nr_populated_threaded_children;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ino_t cgroup_ino(struct cgroup *cgrp)
{
 return kernfs_ino(cgrp->kn);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cftype *of_cft(struct kernfs_open_file *of)
{
 return of->kn->priv;
}

struct cgroup_subsys_state *of_css(struct kernfs_open_file *of);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cftype *seq_cft(struct seq_file *seq)
{
 return of_cft(seq->private);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup_subsys_state *seq_css(struct seq_file *seq)
{
 return of_css(seq->private);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cgroup_name(struct cgroup *cgrp, char *buf, size_t buflen)
{
 return kernfs_name(cgrp->kn, buf, buflen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int cgroup_path(struct cgroup *cgrp, char *buf, size_t buflen)
{
 return kernfs_path(cgrp->kn, buf, buflen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pr_cont_cgroup_name(struct cgroup *cgrp)
{
 pr_cont_kernfs_name(cgrp->kn);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void pr_cont_cgroup_path(struct cgroup *cgrp)
{
 pr_cont_kernfs_path(cgrp->kn);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct psi_group *cgroup_psi(struct cgroup *cgrp)
{
 return &cgrp->psi;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_init_kthreadd(void)
{





 get_current()->no_cgroup_migration = 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_kthread_ready(void)
{




 get_current()->no_cgroup_migration = 0;
}

void cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen);
# 746 "/home/nathan/src/linux-next/include/linux/cgroup.h"
void cgroup_rstat_updated(struct cgroup *cgrp, int cpu);
void cgroup_rstat_flush(struct cgroup *cgrp);
void cgroup_rstat_flush_irqsafe(struct cgroup *cgrp);
void cgroup_rstat_flush_hold(struct cgroup *cgrp);
void cgroup_rstat_flush_release(void);





void cpuacct_charge(struct task_struct *tsk, u64 cputime);
void cpuacct_account_field(struct task_struct *tsk, int index, u64 val);






void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec);
void __cgroup_account_cputime_field(struct cgroup *cgrp,
        enum cpu_usage_stat index, u64 delta_exec);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_account_cputime(struct task_struct *task,
       u64 delta_exec)
{
 struct cgroup *cgrp;

 cpuacct_charge(task, delta_exec);

 rcu_read_lock();
 cgrp = task_dfl_cgroup(task);
 if (cgroup_parent(cgrp))
  __cgroup_account_cputime(cgrp, delta_exec);
 rcu_read_unlock();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_account_cputime_field(struct task_struct *task,
      enum cpu_usage_stat index,
      u64 delta_exec)
{
 struct cgroup *cgrp;

 cpuacct_account_field(task, index, delta_exec);

 rcu_read_lock();
 cgrp = task_dfl_cgroup(task);
 if (cgroup_parent(cgrp))
  __cgroup_account_cputime_field(cgrp, index, delta_exec);
 rcu_read_unlock();
}
# 817 "/home/nathan/src/linux-next/include/linux/cgroup.h"
void cgroup_sk_alloc_disable(void);
void cgroup_sk_alloc(struct sock_cgroup_data *skcd);
void cgroup_sk_free(struct sock_cgroup_data *skcd);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)
{
# 837 "/home/nathan/src/linux-next/include/linux/cgroup.h"
 return (struct cgroup *)(unsigned long)skcd->val;

}
# 848 "/home/nathan/src/linux-next/include/linux/cgroup.h"
struct cgroup_namespace {
 refcount_t count;
 struct ns_common ns;
 struct user_namespace *user_ns;
 struct ucounts *ucounts;
 struct css_set *root_cset;
};

extern struct cgroup_namespace init_cgroup_ns;



void free_cgroup_ns(struct cgroup_namespace *ns);

struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,
     struct user_namespace *user_ns,
     struct cgroup_namespace *old_ns);

int cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,
     struct cgroup_namespace *ns);
# 881 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void get_cgroup_ns(struct cgroup_namespace *ns)
{
 if (ns)
  refcount_inc(&ns->count);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_cgroup_ns(struct cgroup_namespace *ns)
{
 if (ns && refcount_dec_and_test(&ns->count))
  free_cgroup_ns(ns);
}



void cgroup_enter_frozen(void);
void cgroup_leave_frozen(bool always_leave);
void cgroup_update_frozen(struct cgroup *cgrp);
void cgroup_freeze(struct cgroup *cgrp, bool freeze);
void cgroup_freezer_migrate_task(struct task_struct *task, struct cgroup *src,
     struct cgroup *dst);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cgroup_task_freeze(struct task_struct *task)
{
 bool ret;

 if (task->flags & 0x00200000)
  return false;

 rcu_read_lock();
 ret = test_bit(CGRP_FREEZE, &task_dfl_cgroup(task)->flags);
 rcu_read_unlock();

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool cgroup_task_frozen(struct task_struct *task)
{
 return task->frozen;
}
# 937 "/home/nathan/src/linux-next/include/linux/cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_bpf_get(struct cgroup *cgrp)
{
 percpu_ref_get(&cgrp->bpf.refcnt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_bpf_put(struct cgroup *cgrp)
{
 percpu_ref_put(&cgrp->bpf.refcnt);
}
# 12 "/home/nathan/src/linux-next/include/net/netprio_cgroup.h" 2
# 44 "/home/nathan/src/linux-next/include/net/netprio_cgroup.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 task_netprioidx(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_update_netprioidx(struct sock_cgroup_data *skcd)
{
}
# 43 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/net/xdp.h" 1
# 36 "/home/nathan/src/linux-next/include/net/xdp.h"
enum xdp_mem_type {
 MEM_TYPE_PAGE_SHARED = 0,
 MEM_TYPE_PAGE_ORDER0,
 MEM_TYPE_PAGE_POOL,
 MEM_TYPE_ZERO_COPY,
 MEM_TYPE_MAX,
};





struct xdp_mem_info {
 u32 type;
 u32 id;
};

struct page_pool;

struct zero_copy_allocator {
 void (*free)(struct zero_copy_allocator *zca, unsigned long handle);
};

struct xdp_rxq_info {
 struct net_device *dev;
 u32 queue_index;
 u32 reg_state;
 struct xdp_mem_info mem;
} __attribute__((__aligned__((1 << 7))));

struct xdp_buff {
 void *data;
 void *data_end;
 void *data_meta;
 void *data_hard_start;
 unsigned long handle;
 struct xdp_rxq_info *rxq;
};

struct xdp_frame {
 void *data;
 u16 len;
 u16 headroom;
 u16 metasize;



 struct xdp_mem_info mem;
 struct net_device *dev_rx;
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xdp_scrub_frame(struct xdp_frame *frame)
{
 frame->data = ((void *)0);
 frame->dev_rx = ((void *)0);
}

struct xdp_frame *xdp_convert_zc_to_xdp_frame(struct xdp_buff *xdp);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct xdp_frame *convert_to_xdp_frame(struct xdp_buff *xdp)
{
 struct xdp_frame *xdp_frame;
 int metasize;
 int headroom;

 if (xdp->rxq->mem.type == MEM_TYPE_ZERO_COPY)
  return xdp_convert_zc_to_xdp_frame(xdp);


 headroom = xdp->data - xdp->data_hard_start;
 metasize = xdp->data - xdp->data_meta;
 metasize = metasize > 0 ? metasize : 0;
 if (__builtin_expect(!!((headroom - metasize) < sizeof(*xdp_frame)), 0))
  return ((void *)0);


 xdp_frame = xdp->data_hard_start;

 xdp_frame->data = xdp->data;
 xdp_frame->len = xdp->data_end - xdp->data;
 xdp_frame->headroom = headroom - sizeof(*xdp_frame);
 xdp_frame->metasize = metasize;


 xdp_frame->mem = xdp->rxq->mem;

 return xdp_frame;
}

void xdp_return_frame(struct xdp_frame *xdpf);
void xdp_return_frame_rx_napi(struct xdp_frame *xdpf);
void xdp_return_buff(struct xdp_buff *xdp);






void __xdp_release_frame(void *data, struct xdp_mem_info *mem);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xdp_release_frame(struct xdp_frame *xdpf)
{
 struct xdp_mem_info *mem = &xdpf->mem;


 if (mem->type == MEM_TYPE_PAGE_POOL)
  __xdp_release_frame(xdpf->data, mem);
}

int xdp_rxq_info_reg(struct xdp_rxq_info *xdp_rxq,
       struct net_device *dev, u32 queue_index);
void xdp_rxq_info_unreg(struct xdp_rxq_info *xdp_rxq);
void xdp_rxq_info_unused(struct xdp_rxq_info *xdp_rxq);
bool xdp_rxq_info_is_reg(struct xdp_rxq_info *xdp_rxq);
int xdp_rxq_info_reg_mem_model(struct xdp_rxq_info *xdp_rxq,
          enum xdp_mem_type type, void *allocator);
void xdp_rxq_info_unreg_mem_model(struct xdp_rxq_info *xdp_rxq);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void
xdp_set_data_meta_invalid(struct xdp_buff *xdp)
{
 xdp->data_meta = xdp->data + 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) bool
xdp_data_meta_unsupported(const struct xdp_buff *xdp)
{
 return __builtin_expect(!!(xdp->data_meta > xdp->data), 0);
}

struct xdp_attachment_info {
 struct bpf_prog *prog;
 u32 flags;
};

struct netdev_bpf;
int xdp_attachment_query(struct xdp_attachment_info *info,
    struct netdev_bpf *bpf);
bool xdp_attachment_flags_ok(struct xdp_attachment_info *info,
        struct netdev_bpf *bpf);
void xdp_attachment_setup(struct xdp_attachment_info *info,
     struct netdev_bpf *bpf);
# 44 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2


# 1 "/home/nathan/src/linux-next/include/uapi/linux/neighbour.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/netlink.h" 1








# 1 "/home/nathan/src/linux-next/include/net/scm.h" 1







# 1 "/home/nathan/src/linux-next/include/linux/security.h" 1
# 35 "/home/nathan/src/linux-next/include/linux/security.h"
struct linux_binprm;
struct cred;
struct rlimit;
struct kernel_siginfo;
struct sembuf;
struct kern_ipc_perm;
struct audit_context;
struct super_block;
struct inode;
struct dentry;
struct file;
struct vfsmount;
struct path;
struct qstr;
struct iattr;
struct fown_struct;
struct file_operations;
struct msg_msg;
struct xattr;
struct kernfs_node;
struct xfrm_sec_ctx;
struct mm_struct;
struct fs_context;
struct fs_parameter;
enum fs_value_type;
# 71 "/home/nathan/src/linux-next/include/linux/security.h"
struct ctl_table;
struct audit_krule;
struct user_namespace;
struct timezone;

enum lsm_event {
 LSM_POLICY_CHANGE,
};
# 104 "/home/nathan/src/linux-next/include/linux/security.h"
enum lockdown_reason {
 LOCKDOWN_NONE,
 LOCKDOWN_MODULE_SIGNATURE,
 LOCKDOWN_DEV_MEM,
 LOCKDOWN_EFI_TEST,
 LOCKDOWN_KEXEC,
 LOCKDOWN_HIBERNATION,
 LOCKDOWN_PCI_ACCESS,
 LOCKDOWN_IOPORT,
 LOCKDOWN_MSR,
 LOCKDOWN_ACPI_TABLES,
 LOCKDOWN_PCMCIA_CIS,
 LOCKDOWN_TIOCSSERIAL,
 LOCKDOWN_MODULE_PARAMETERS,
 LOCKDOWN_MMIOTRACE,
 LOCKDOWN_DEBUGFS,
 LOCKDOWN_XMON_WR,
 LOCKDOWN_INTEGRITY_MAX,
 LOCKDOWN_KCORE,
 LOCKDOWN_KPROBES,
 LOCKDOWN_BPF_READ,
 LOCKDOWN_PERF,
 LOCKDOWN_TRACEFS,
 LOCKDOWN_XMON_RW,
 LOCKDOWN_CONFIDENTIALITY_MAX,
};

extern const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1];


extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
         int cap, unsigned int opts);
extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
extern int cap_ptrace_traceme(struct task_struct *parent);
extern int cap_capget(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted);
extern int cap_capset(struct cred *new, const struct cred *old,
        const kernel_cap_t *effective,
        const kernel_cap_t *inheritable,
        const kernel_cap_t *permitted);
extern int cap_bprm_set_creds(struct linux_binprm *bprm);
extern int cap_inode_setxattr(struct dentry *dentry, const char *name,
         const void *value, size_t size, int flags);
extern int cap_inode_removexattr(struct dentry *dentry, const char *name);
extern int cap_inode_need_killpriv(struct dentry *dentry);
extern int cap_inode_killpriv(struct dentry *dentry);
extern int cap_inode_getsecurity(struct inode *inode, const char *name,
     void **buffer, bool alloc);
extern int cap_mmap_addr(unsigned long addr);
extern int cap_mmap_file(struct file *file, unsigned long reqprot,
    unsigned long prot, unsigned long flags);
extern int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags);
extern int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,
     unsigned long arg4, unsigned long arg5);
extern int cap_task_setscheduler(struct task_struct *p);
extern int cap_task_setioprio(struct task_struct *p, int ioprio);
extern int cap_task_setnice(struct task_struct *p, int nice);
extern int cap_vm_enough_memory(struct mm_struct *mm, long pages);

struct msghdr;
struct sk_buff;
struct sock;
struct sockaddr;
struct socket;
struct flowi;
struct dst_entry;
struct xfrm_selector;
struct xfrm_policy;
struct xfrm_state;
struct xfrm_user_sec_ctx;
struct seq_file;
struct sctp_endpoint;


extern unsigned long mmap_min_addr;
extern unsigned long dac_mmap_min_addr;
# 205 "/home/nathan/src/linux-next/include/linux/security.h"
struct sched_param;
struct request_sock;







extern int mmap_min_addr_handler(struct ctl_table *table, int write,
     void *buffer, size_t *lenp, loff_t *ppos);



typedef int (*initxattrs) (struct inode *inode,
      const struct xattr *xattr_array, void *fs_data);






enum kernel_load_data_id {
 LOADING_UNKNOWN, LOADING_FIRMWARE, LOADING_FIRMWARE_PREALLOC_BUFFER, LOADING_MODULE, LOADING_KEXEC_IMAGE, LOADING_KEXEC_INITRAMFS, LOADING_POLICY, LOADING_X509_CERTIFICATE, LOADING_MAX_ID,
};

static const char * const kernel_load_data_str[] = {
 "unknown", "firmware", "firmware", "kernel-module", "kexec-image", "kexec-initramfs", "security-policy", "x509-certificate", "",
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *kernel_load_data_id_str(enum kernel_load_data_id id)
{
 if ((unsigned)id >= LOADING_MAX_ID)
  return kernel_load_data_str[LOADING_UNKNOWN];

 return kernel_load_data_str[id];
}
# 452 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int call_blocking_lsm_notifier(enum lsm_event event, void *data)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int register_blocking_lsm_notifier(struct notifier_block *nb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unregister_blocking_lsm_notifier(struct notifier_block *nb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_free_mnt_opts(void **mnt_opts)
{
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_init(void)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int early_security_init(void)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_binder_set_context_mgr(struct task_struct *mgr)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_binder_transaction(struct task_struct *from,
           struct task_struct *to)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_binder_transfer_binder(struct task_struct *from,
        struct task_struct *to)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_binder_transfer_file(struct task_struct *from,
      struct task_struct *to,
      struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ptrace_access_check(struct task_struct *child,
          unsigned int mode)
{
 return cap_ptrace_access_check(child, mode);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ptrace_traceme(struct task_struct *parent)
{
 return cap_ptrace_traceme(parent);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_capget(struct task_struct *target,
       kernel_cap_t *effective,
       kernel_cap_t *inheritable,
       kernel_cap_t *permitted)
{
 return cap_capget(target, effective, inheritable, permitted);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_capset(struct cred *new,
       const struct cred *old,
       const kernel_cap_t *effective,
       const kernel_cap_t *inheritable,
       const kernel_cap_t *permitted)
{
 return cap_capset(new, old, effective, inheritable, permitted);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_capable(const struct cred *cred,
       struct user_namespace *ns,
       int cap,
       unsigned int opts)
{
 return cap_capable(cred, ns, cap, opts);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_quotactl(int cmds, int type, int id,
         struct super_block *sb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_quota_on(struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_syslog(int type)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_settime64(const struct timespec64 *ts,
         const struct timezone *tz)
{
 return cap_settime(ts, tz);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
{
 return __vm_enough_memory(mm, pages, cap_vm_enough_memory(mm, pages));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bprm_set_creds(struct linux_binprm *bprm)
{
 return cap_bprm_set_creds(bprm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bprm_check(struct linux_binprm *bprm)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_bprm_committing_creds(struct linux_binprm *bprm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_bprm_committed_creds(struct linux_binprm *bprm)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_fs_context_dup(struct fs_context *fc,
       struct fs_context *src_fc)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_fs_context_parse_param(struct fs_context *fc,
        struct fs_parameter *param)
{
 return -519;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_alloc(struct super_block *sb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sb_free(struct super_block *sb)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_eat_lsm_opts(char *options,
        void **mnt_opts)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_remount(struct super_block *sb,
          void *mnt_opts)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_kern_mount(struct super_block *sb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_show_options(struct seq_file *m,
        struct super_block *sb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_statfs(struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_mount(const char *dev_name, const struct path *path,
        const char *type, unsigned long flags,
        void *data)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_umount(struct vfsmount *mnt, int flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_pivotroot(const struct path *old_path,
     const struct path *new_path)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_set_mnt_opts(struct super_block *sb,
        void *mnt_opts,
        unsigned long kern_flags,
        unsigned long *set_kern_flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sb_clone_mnt_opts(const struct super_block *oldsb,
           struct super_block *newsb,
           unsigned long kern_flags,
           unsigned long *set_kern_flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_add_mnt_opt(const char *option, const char *val,
     int len, void **mnt_opts)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_move_mount(const struct path *from_path,
          const struct path *to_path)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_notify(const struct path *path, u64 mask,
    unsigned int obj_type)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_alloc(struct inode *inode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inode_free(struct inode *inode)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_dentry_init_security(struct dentry *dentry,
       int mode,
       const struct qstr *name,
       void **ctx,
       u32 *ctxlen)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_dentry_create_files_as(struct dentry *dentry,
        int mode, struct qstr *name,
        const struct cred *old,
        struct cred *new)
{
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_init_security(struct inode *inode,
      struct inode *dir,
      const struct qstr *qstr,
      const initxattrs xattrs,
      void *fs_data)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_old_inode_init_security(struct inode *inode,
         struct inode *dir,
         const struct qstr *qstr,
         const char **name,
         void **value, size_t *len)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_create(struct inode *dir,
      struct dentry *dentry,
      umode_t mode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_link(struct dentry *old_dentry,
           struct inode *dir,
           struct dentry *new_dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_unlink(struct inode *dir,
      struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_symlink(struct inode *dir,
       struct dentry *dentry,
       const char *old_name)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_mkdir(struct inode *dir,
     struct dentry *dentry,
     int mode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_rmdir(struct inode *dir,
     struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_mknod(struct inode *dir,
     struct dentry *dentry,
     int mode, dev_t dev)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_rename(struct inode *old_dir,
      struct dentry *old_dentry,
      struct inode *new_dir,
      struct dentry *new_dentry,
      unsigned int flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_readlink(struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_follow_link(struct dentry *dentry,
          struct inode *inode,
          bool rcu)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_permission(struct inode *inode, int mask)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_setattr(struct dentry *dentry,
       struct iattr *attr)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_getattr(const struct path *path)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_setxattr(struct dentry *dentry,
  const char *name, const void *value, size_t size, int flags)
{
 return cap_inode_setxattr(dentry, name, value, size, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inode_post_setxattr(struct dentry *dentry,
  const char *name, const void *value, size_t size, int flags)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_getxattr(struct dentry *dentry,
   const char *name)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_listxattr(struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_removexattr(struct dentry *dentry,
   const char *name)
{
 return cap_inode_removexattr(dentry, name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_need_killpriv(struct dentry *dentry)
{
 return cap_inode_need_killpriv(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_killpriv(struct dentry *dentry)
{
 return cap_inode_killpriv(dentry);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inode_getsecid(struct inode *inode, u32 *secid)
{
 *secid = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_copy_up(struct dentry *src, struct cred **new)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernfs_init_security(struct kernfs_node *kn_dir,
      struct kernfs_node *kn)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_copy_up_xattr(const char *name)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_permission(struct file *file, int mask)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_alloc(struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_file_free(struct file *file)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_ioctl(struct file *file, unsigned int cmd,
          unsigned long arg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_mmap_file(struct file *file, unsigned long prot,
         unsigned long flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_mmap_addr(unsigned long addr)
{
 return cap_mmap_addr(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_mprotect(struct vm_area_struct *vma,
      unsigned long reqprot,
      unsigned long prot)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_lock(struct file *file, unsigned int cmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_fcntl(struct file *file, unsigned int cmd,
          unsigned long arg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_file_set_fowner(struct file *file)
{
 return;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_send_sigiotask(struct task_struct *tsk,
            struct fown_struct *fown,
            int sig)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_receive(struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_file_open(struct file *file)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_alloc(struct task_struct *task,
          unsigned long clone_flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_task_free(struct task_struct *task)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_cred_free(struct cred *cred)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_prepare_creds(struct cred *new,
      const struct cred *old,
      gfp_t gfp)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_transfer_creds(struct cred *new,
        const struct cred *old)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_act_as(struct cred *cred, u32 secid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_create_files_as(struct cred *cred,
        struct inode *inode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_module_request(char *kmod_name)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_load_data(enum kernel_load_data_id id)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_read_file(struct file *file,
         enum kernel_read_file_id id)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_kernel_post_read_file(struct file *file,
       char *buf, loff_t size,
       enum kernel_read_file_id id)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_fix_setuid(struct cred *new,
        const struct cred *old,
        int flags)
{
 return cap_task_fix_setuid(new, old, flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_setpgid(struct task_struct *p, pid_t pgid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_getpgid(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_getsid(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_task_getsecid(struct task_struct *p, u32 *secid)
{
 *secid = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_setnice(struct task_struct *p, int nice)
{
 return cap_task_setnice(p, nice);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_setioprio(struct task_struct *p, int ioprio)
{
 return cap_task_setioprio(p, ioprio);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_getioprio(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_prlimit(const struct cred *cred,
     const struct cred *tcred,
     unsigned int flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_setrlimit(struct task_struct *p,
       unsigned int resource,
       struct rlimit *new_rlim)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_setscheduler(struct task_struct *p)
{
 return cap_task_setscheduler(p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_getscheduler(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_movememory(struct task_struct *p)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_kill(struct task_struct *p,
         struct kernel_siginfo *info, int sig,
         const struct cred *cred)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_task_prctl(int option, unsigned long arg2,
          unsigned long arg3,
          unsigned long arg4,
          unsigned long arg5)
{
 return cap_task_prctl(option, arg2, arg3, arg4, arg5);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_task_to_inode(struct task_struct *p, struct inode *inode)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ipc_permission(struct kern_ipc_perm *ipcp,
       short flag)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
{
 *secid = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_msg_alloc(struct msg_msg *msg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_msg_msg_free(struct msg_msg *msg)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_queue_alloc(struct kern_ipc_perm *msq)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_msg_queue_free(struct kern_ipc_perm *msq)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_queue_associate(struct kern_ipc_perm *msq,
            int msqflg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,
         struct msg_msg *msg, int msqflg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_msg_queue_msgrcv(struct kern_ipc_perm *msq,
         struct msg_msg *msg,
         struct task_struct *target,
         long type, int mode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_shm_alloc(struct kern_ipc_perm *shp)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_shm_free(struct kern_ipc_perm *shp)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_shm_associate(struct kern_ipc_perm *shp,
      int shmflg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_shm_shmctl(struct kern_ipc_perm *shp, int cmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_shm_shmat(struct kern_ipc_perm *shp,
         char *shmaddr, int shmflg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sem_alloc(struct kern_ipc_perm *sma)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sem_free(struct kern_ipc_perm *sma)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sem_associate(struct kern_ipc_perm *sma, int semflg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sem_semctl(struct kern_ipc_perm *sma, int cmd)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sem_semop(struct kern_ipc_perm *sma,
         struct sembuf *sops, unsigned nsops,
         int alter)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_d_instantiate(struct dentry *dentry,
       struct inode *inode)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_getprocattr(struct task_struct *p, const char *lsm,
           char *name, char **value)
{
 return -22;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_setprocattr(const char *lsm, char *name,
           void *value, size_t size)
{
 return -22;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_netlink_send(struct sock *sk, struct sk_buff *skb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ismaclabel(const char *name)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_secctx_to_secid(const char *secdata,
        u32 seclen,
        u32 *secid)
{
 return -95;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_release_secctx(char *secdata, u32 seclen)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inode_invalidate_secctx(struct inode *inode)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
{
 return -95;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
{
 return -95;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
{
 return -95;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_locked_down(enum lockdown_reason what)
{
 return 0;
}
# 1331 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_unix_stream_connect(struct sock *sock,
            struct sock *other,
            struct sock *newsk)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_unix_may_send(struct socket *sock,
      struct socket *other)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_create(int family, int type,
      int protocol, int kern)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_post_create(struct socket *sock,
           int family,
           int type,
           int protocol, int kern)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_socketpair(struct socket *socka,
          struct socket *sockb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_bind(struct socket *sock,
           struct sockaddr *address,
           int addrlen)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_connect(struct socket *sock,
       struct sockaddr *address,
       int addrlen)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_listen(struct socket *sock, int backlog)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_accept(struct socket *sock,
      struct socket *newsock)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_sendmsg(struct socket *sock,
       struct msghdr *msg, int size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_recvmsg(struct socket *sock,
       struct msghdr *msg, int size,
       int flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_getsockname(struct socket *sock)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_getpeername(struct socket *sock)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_getsockopt(struct socket *sock,
          int level, int optname)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_setsockopt(struct socket *sock,
          int level, int optname)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_shutdown(struct socket *sock, int how)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sock_rcv_skb(struct sock *sk,
     struct sk_buff *skb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_getpeersec_stream(struct socket *sock, char *optval,
          int *optlen, unsigned len)
{
 return -92;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
{
 return -92;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sk_free(struct sock *sk)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sk_clone(const struct sock *sk, struct sock *newsk)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_req_classify_flow(const struct request_sock *req, struct flowi *fl)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sock_graft(struct sock *sk, struct socket *parent)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_inet_conn_request(struct sock *sk,
   struct sk_buff *skb, struct request_sock *req)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inet_csk_clone(struct sock *newsk,
   const struct request_sock *req)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_inet_conn_established(struct sock *sk,
   struct sk_buff *skb)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_secmark_relabel_packet(u32 secid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_secmark_refcount_inc(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_secmark_refcount_dec(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_tun_dev_alloc_security(void **security)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_tun_dev_free_security(void *security)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_tun_dev_create(void)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_tun_dev_attach_queue(void *security)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_tun_dev_attach(struct sock *sk, void *security)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_tun_dev_open(void *security)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sctp_assoc_request(struct sctp_endpoint *ep,
           struct sk_buff *skb)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_sctp_bind_connect(struct sock *sk, int optname,
          struct sockaddr *address,
          int addrlen)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_sctp_sk_clone(struct sctp_endpoint *ep,
       struct sock *sk,
       struct sock *newsk)
{
}
# 1554 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ib_endport_manage_subnet(void *sec, const char *dev_name, u8 port_num)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_ib_alloc_security(void **sec)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_ib_free_security(void *sec)
{
}
# 1595 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
          struct xfrm_user_sec_ctx *sec_ctx,
          gfp_t gfp)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_policy_clone(struct xfrm_sec_ctx *old, struct xfrm_sec_ctx **new_ctxp)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_state_alloc(struct xfrm_state *x,
     struct xfrm_user_sec_ctx *sec_ctx)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_state_alloc_acquire(struct xfrm_state *x,
     struct xfrm_sec_ctx *polsec, u32 secid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_xfrm_state_free(struct xfrm_state *x)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_state_delete(struct xfrm_state *x)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
   struct xfrm_policy *xp, const struct flowi *fl)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_skb_classify_flow(struct sk_buff *skb, struct flowi *fl)
{
}
# 1677 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_unlink(const struct path *dir, struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_mkdir(const struct path *dir, struct dentry *dentry,
          umode_t mode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_rmdir(const struct path *dir, struct dentry *dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_mknod(const struct path *dir, struct dentry *dentry,
          umode_t mode, unsigned int dev)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_truncate(const struct path *path)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_symlink(const struct path *dir, struct dentry *dentry,
     const char *old_name)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_link(struct dentry *old_dentry,
         const struct path *new_dir,
         struct dentry *new_dentry)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_rename(const struct path *old_dir,
           struct dentry *old_dentry,
           const struct path *new_dir,
           struct dentry *new_dentry,
           unsigned int flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_chmod(const struct path *path, umode_t mode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_path_chroot(const struct path *path)
{
 return 0;
}
# 1753 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_key_alloc(struct key *key,
         const struct cred *cred,
         unsigned long flags)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_key_free(struct key *key)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_key_permission(key_ref_t key_ref,
       const struct cred *cred,
       unsigned perm)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_key_getsecurity(struct key *key, char **_buffer)
{
 *_buffer = ((void *)0);
 return 0;
}
# 1826 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *securityfs_create_dir(const char *name,
         struct dentry *parent)
{
 return ERR_PTR(-19);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *securityfs_create_file(const char *name,
          umode_t mode,
          struct dentry *parent,
          void *data,
          const struct file_operations *fops)
{
 return ERR_PTR(-19);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dentry *securityfs_create_symlink(const char *name,
     struct dentry *parent,
     const char *target,
     const struct inode_operations *iops)
{
 return ERR_PTR(-19);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void securityfs_remove(struct dentry *dentry)
{}




union bpf_attr;
struct bpf_map;
struct bpf_prog;
struct bpf_prog_aux;
# 1868 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bpf(int cmd, union bpf_attr *attr,
          unsigned int size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bpf_map(struct bpf_map *map, fmode_t fmode)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bpf_prog(struct bpf_prog *prog)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bpf_map_alloc(struct bpf_map *map)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_bpf_map_free(struct bpf_map *map)
{ }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_bpf_prog_alloc(struct bpf_prog_aux *aux)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_bpf_prog_free(struct bpf_prog_aux *aux)
{ }




struct perf_event_attr;
struct perf_event;
# 1913 "/home/nathan/src/linux-next/include/linux/security.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_perf_event_open(struct perf_event_attr *attr,
        int type)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_perf_event_alloc(struct perf_event *event)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void security_perf_event_free(struct perf_event *event)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_perf_event_read(struct perf_event *event)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int security_perf_event_write(struct perf_event *event)
{
 return 0;
}
# 9 "/home/nathan/src/linux-next/include/net/scm.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 1





# 1 "/home/nathan/src/linux-next/include/linux/signal.h" 1








struct task_struct;


extern int print_fatal_signals;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_siginfo(kernel_siginfo_t *to,
    const kernel_siginfo_t *from)
{
 memcpy(to, from, sizeof(*to));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_siginfo(kernel_siginfo_t *info)
{
 memset(info, 0, sizeof(*info));
}



int copy_siginfo_to_user(siginfo_t *to, const kernel_siginfo_t *from);
int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t *from);

enum siginfo_layout {
 SIL_KILL,
 SIL_TIMER,
 SIL_POLL,
 SIL_FAULT,
 SIL_FAULT_MCEERR,
 SIL_FAULT_BNDERR,
 SIL_FAULT_PKUERR,
 SIL_CHLD,
 SIL_RT,
 SIL_SYS,
};

enum siginfo_layout siginfo_layout(unsigned sig, int si_code);
# 54 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigaddset(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  set->sig[0] |= 1UL << sig;
 else
  set->sig[sig / 64] |= 1UL << (sig % 64);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigdelset(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  set->sig[0] &= ~(1UL << sig);
 else
  set->sig[sig / 64] &= ~(1UL << (sig % 64));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigismember(sigset_t *set, int _sig)
{
 unsigned long sig = _sig - 1;
 if ((64 / 64) == 1)
  return 1 & (set->sig[0] >> sig);
 else
  return 1 & (set->sig[sig / 64] >> (sig % 64));
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigisemptyset(sigset_t *set)
{
 switch ((64 / 64)) {
 case 4:
  return (set->sig[3] | set->sig[2] |
   set->sig[1] | set->sig[0]) == 0;
 case 2:
  return (set->sig[1] | set->sig[0]) == 0;
 case 1:
  return set->sig[0] == 0;
 default:
  do { extern void __compiletime_assert_94(void) ; if (!(!(1))) __compiletime_assert_94(); } while (0);
  return 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigequalsets(const sigset_t *set1, const sigset_t *set2)
{
 switch ((64 / 64)) {
 case 4:
  return (set1->sig[3] == set2->sig[3]) &&
   (set1->sig[2] == set2->sig[2]) &&
   (set1->sig[1] == set2->sig[1]) &&
   (set1->sig[0] == set2->sig[0]);
 case 2:
  return (set1->sig[1] == set2->sig[1]) &&
   (set1->sig[0] == set2->sig[0]);
 case 1:
  return set1->sig[0] == set2->sig[0];
 }
 return 0;
}
# 147 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) | (b3)); r->sig[2] = ((a2) | (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) | (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) | (b0)); break; default: do { extern void __compiletime_assert_147(void) ; if (!(!(1))) __compiletime_assert_147(); } while (0); } }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & (b3)); r->sig[2] = ((a2) & (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & (b0)); break; default: do { extern void __compiletime_assert_150(void) ; if (!(!(1))) __compiletime_assert_150(); } while (0); } }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigandnsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 64)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & ~(b3)); r->sig[2] = ((a2) & ~(b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & ~(b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & ~(b0)); break; default: do { extern void __compiletime_assert_153(void) ; if (!(!(1))) __compiletime_assert_153(); } while (0); } }
# 177 "/home/nathan/src/linux-next/include/linux/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signotset(sigset_t *set) { switch ((64 / 64)) { case 4: set->sig[3] = (~(set->sig[3])); set->sig[2] = (~(set->sig[2])); case 2: set->sig[1] = (~(set->sig[1])); case 1: set->sig[0] = (~(set->sig[0])); break; default: do { extern void __compiletime_assert_177(void) ; if (!(!(1))) __compiletime_assert_177(); } while (0); } }




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigemptyset(sigset_t *set)
{
 switch ((64 / 64)) {
 default:
  memset(set, 0, sizeof(sigset_t));
  break;
 case 2: set->sig[1] = 0;

 case 1: set->sig[0] = 0;
  break;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigfillset(sigset_t *set)
{
 switch ((64 / 64)) {
 default:
  memset(set, -1, sizeof(sigset_t));
  break;
 case 2: set->sig[1] = -1;

 case 1: set->sig[0] = -1;
  break;
 }
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigaddsetmask(sigset_t *set, unsigned long mask)
{
 set->sig[0] |= mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sigdelsetmask(sigset_t *set, unsigned long mask)
{
 set->sig[0] &= ~mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sigtestsetmask(sigset_t *set, unsigned long mask)
{
 return (set->sig[0] & mask) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void siginitset(sigset_t *set, unsigned long mask)
{
 set->sig[0] = mask;
 switch ((64 / 64)) {
 default:
  memset(&set->sig[1], 0, sizeof(long)*((64 / 64)-1));
  break;
 case 2: set->sig[1] = 0;
 case 1: ;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void siginitsetinv(sigset_t *set, unsigned long mask)
{
 set->sig[0] = ~mask;
 switch ((64 / 64)) {
 default:
  memset(&set->sig[1], -1, sizeof(long)*((64 / 64)-1));
  break;
 case 2: set->sig[1] = -1;
 case 1: ;
 }
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_sigpending(struct sigpending *sig)
{
 sigemptyset(&sig->signal);
 INIT_LIST_HEAD(&sig->list);
}

extern void flush_sigqueue(struct sigpending *queue);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int valid_signal(unsigned long sig)
{
 return sig <= 64 ? 1 : 0;
}

struct timespec;
struct pt_regs;
enum pid_type;

extern int next_signal(struct sigpending *pending, sigset_t *mask);
extern int do_send_sig_info(int sig, struct kernel_siginfo *info,
    struct task_struct *p, enum pid_type type);
extern int group_send_sig_info(int sig, struct kernel_siginfo *info,
          struct task_struct *p, enum pid_type type);
extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
extern int sigprocmask(int, sigset_t *, sigset_t *);
extern void set_current_blocked(sigset_t *);
extern void __set_current_blocked(const sigset_t *);
extern int show_unhandled_signals;

extern bool get_signal(struct ksignal *ksig);
extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
extern void exit_signals(struct task_struct *tsk);
extern void kernel_sigaction(int, __sighandler_t);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_signal(int sig)
{





 kernel_sigaction(sig, (( __sighandler_t)2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void allow_kernel_signal(int sig)
{





 kernel_sigaction(sig, (( __sighandler_t)3));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disallow_signal(int sig)
{
 kernel_sigaction(sig, (( __sighandler_t)1));
}

extern struct kmem_cache *sighand_cachep;

extern bool unhandled_signal(struct task_struct *tsk, int sig);
# 442 "/home/nathan/src/linux-next/include/linux/signal.h"
void signals_init(void);

int restore_altstack(const stack_t *);
int __save_altstack(stack_t *, unsigned long);
# 458 "/home/nathan/src/linux-next/include/linux/signal.h"
struct seq_file;
extern void render_sigset_t(struct seq_file *, const char *, sigset_t *);
# 7 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/sched/jobctl.h" 1






struct task_struct;
# 35 "/home/nathan/src/linux-next/include/linux/sched/jobctl.h"
extern bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask);
extern void task_clear_jobctl_trapping(struct task_struct *task);
extern void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask);
# 9 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/sched/task.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/sched/task.h"
struct task_struct;
struct rusage;
union thread_union;




struct kernel_clone_args {
 u64 flags;
 int *pidfd;
 int *child_tid;
 int *parent_tid;
 int exit_signal;
 unsigned long stack;
 unsigned long stack_size;
 unsigned long tls;
 pid_t *set_tid;

 size_t set_tid_size;
};







extern rwlock_t tasklist_lock;
extern spinlock_t mmlist_lock;

extern union thread_union init_thread_union;
extern struct task_struct init_task;





extern void schedule_tail(struct task_struct *prev);
extern void init_idle(struct task_struct *idle, int cpu);

extern int sched_fork(unsigned long clone_flags, struct task_struct *p);
extern void sched_dead(struct task_struct *p);

void __attribute__((__noreturn__)) do_task_dead(void);

extern void proc_caches_init(void);

extern void fork_init(void);

extern void release_task(struct task_struct * p);


extern int copy_thread_tls(unsigned long, unsigned long, unsigned long,
   struct task_struct *, unsigned long);
# 80 "/home/nathan/src/linux-next/include/linux/sched/task.h"
extern void flush_thread(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void exit_thread(struct task_struct *tsk)
{
}

extern void do_group_exit(int);

extern void exit_files(struct task_struct *);
extern void exit_itimers(struct signal_struct *);

extern long _do_fork(struct kernel_clone_args *kargs);
extern bool legacy_clone_args_valid(const struct kernel_clone_args *kargs);
extern long do_fork(unsigned long, unsigned long, unsigned long, int *, int *);
struct task_struct *fork_idle(int);
struct mm_struct *copy_init_mm(void);
extern pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
extern long kernel_wait4(pid_t, int *, int, struct rusage *);

extern void free_task(struct task_struct *tsk);



extern void sched_exec(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *get_task_struct(struct task_struct *t)
{
 refcount_inc(&t->usage);
 return t;
}

extern void __put_task_struct(struct task_struct *t);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_task_struct(struct task_struct *t)
{
 if (refcount_dec_and_test(&t->usage))
  __put_task_struct(t);
}

void put_task_struct_rcu_user(struct task_struct *task);
# 138 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void arch_thread_struct_whitelist(unsigned long *offset,
      unsigned long *size)
{
 *offset = 0;

 *size = (sizeof(struct task_struct)) - __builtin_offsetof(struct task_struct, thread);
}
# 153 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vm_struct *task_stack_vm_area(const struct task_struct *t)
{
 return ((void *)0);
}
# 169 "/home/nathan/src/linux-next/include/linux/sched/task.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_lock(struct task_struct *p)
{
 spin_lock(&p->alloc_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void task_unlock(struct task_struct *p)
{
 spin_unlock(&p->alloc_lock);
}
# 10 "/home/nathan/src/linux-next/include/linux/sched/signal.h" 2








struct sighand_struct {
 spinlock_t siglock;
 refcount_t count;
 wait_queue_head_t signalfd_wqh;
 struct k_sigaction action[64];
};




struct pacct_struct {
 int ac_flag;
 long ac_exitcode;
 unsigned long ac_mem;
 u64 ac_utime, ac_stime;
 unsigned long ac_minflt, ac_majflt;
};

struct cpu_itimer {
 u64 expires;
 u64 incr;
};





struct task_cputime_atomic {
 atomic64_t utime;
 atomic64_t stime;
 atomic64_t sum_exec_runtime;
};
# 64 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
struct thread_group_cputimer {
 struct task_cputime_atomic cputime_atomic;
};

struct multiprocess_signals {
 sigset_t signal;
 struct hlist_node node;
};
# 80 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
struct signal_struct {
 refcount_t sigcnt;
 atomic_t live;
 int nr_threads;
 struct list_head thread_head;

 wait_queue_head_t wait_chldexit;


 struct task_struct *curr_target;


 struct sigpending shared_pending;


 struct hlist_head multiprocess;


 int group_exit_code;





 int notify_count;
 struct task_struct *group_exit_task;


 int group_stop_count;
 unsigned int flags;
# 120 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 unsigned int is_child_subreaper:1;
 unsigned int has_child_subreaper:1;




 int posix_timer_id;
 struct list_head posix_timers;


 struct hrtimer real_timer;
 ktime_t it_real_incr;






 struct cpu_itimer it[2];





 struct thread_group_cputimer cputimer;



 struct posix_cputimers posix_cputimers;


 struct pid *pids[PIDTYPE_MAX];





 struct pid *tty_old_pgrp;


 int leader;

 struct tty_struct *tty;
# 173 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 seqlock_t stats_lock;
 u64 utime, stime, cutime, cstime;
 u64 gtime;
 u64 cgtime;
 struct prev_cputime prev_cputime;
 unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
 unsigned long inblock, oublock, cinblock, coublock;
 unsigned long maxrss, cmaxrss;
 struct task_io_accounting ioac;







 unsigned long long sum_sched_runtime;
# 201 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 struct rlimit rlim[16];





 struct taskstats *stats;
# 218 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 bool oom_flag_origin;
 short oom_score_adj;
 short oom_score_adj_min;

 struct mm_struct *oom_mm;


 struct mutex cred_guard_mutex;


} ;
# 249 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signal_set_stop_flags(struct signal_struct *sig,
      unsigned int flags)
{
 ({ int __ret_warn_on = !!(sig->flags & (0x00000004|0x00000008)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (252), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (252), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 sig->flags = (sig->flags & ~((0x00000010|0x00000020) | 0x00000001 | 0x00000002)) | flags;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_group_exit(const struct signal_struct *sig)
{
 return (sig->flags & 0x00000004) ||
  (sig->group_exit_task != ((void *)0));
}

extern void flush_signals(struct task_struct *);
extern void ignore_signals(struct task_struct *);
extern void flush_signal_handlers(struct task_struct *, int force_default);
extern int dequeue_signal(struct task_struct *task,
     sigset_t *mask, kernel_siginfo_t *info);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kernel_dequeue_signal(void)
{
 struct task_struct *task = get_current();
 kernel_siginfo_t __info;
 int ret;

 spin_lock_irq(&task->sighand->siglock);
 ret = dequeue_signal(task, &task->blocked, &__info);
 spin_unlock_irq(&task->sighand->siglock);

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kernel_signal_stop(void)
{
 spin_lock_irq(&get_current()->sighand->siglock);
 if (get_current()->jobctl & (1UL << 16))
  do { unsigned long flags; do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = _raw_spin_lock_irqsave(&get_current()->pi_lock); } while (0); get_current()->state = ((0x0100 | 0x0004)); do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); _raw_spin_unlock_irqrestore(&get_current()->pi_lock, flags); } while (0); } while (0);
 spin_unlock_irq(&get_current()->sighand->siglock);

 schedule();
}
# 302 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
int force_sig_fault_to_task(int sig, int code, void *addr


 , struct task_struct *t);
int force_sig_fault(int sig, int code, void *addr

                                                                );
int send_sig_fault(int sig, int code, void *addr


 , struct task_struct *t);

int force_sig_mceerr(int code, void *, short);
int send_sig_mceerr(int code, void *, short, struct task_struct *);

int force_sig_bnderr(void *addr, void *lower, void *upper);
int force_sig_pkuerr(void *addr, u32 pkey);

int force_sig_ptrace_errno_trap(int errno, void *addr);

extern int send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
extern void force_sigsegv(int sig);
extern int force_sig_info(struct kernel_siginfo *);
extern int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp);
extern int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid);
extern int kill_pid_usb_asyncio(int sig, int errno, sigval_t addr, struct pid *,
    const struct cred *);
extern int kill_pgrp(struct pid *pid, int sig, int priv);
extern int kill_pid(struct pid *pid, int sig, int priv);
extern __attribute__((__warn_unused_result__)) bool do_notify_parent(struct task_struct *, int);
extern void __wake_up_parent(struct task_struct *p, struct task_struct *parent);
extern void force_sig(int);
extern int send_sig(int, struct task_struct *, int);
extern int zap_other_threads(struct task_struct *p);
extern struct sigqueue *sigqueue_alloc(void);
extern void sigqueue_free(struct sigqueue *);
extern int send_sigqueue(struct sigqueue *, struct pid *, enum pid_type);
extern int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int restart_syscall(void)
{
 set_tsk_thread_flag(get_current(), 1);
 return -513;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_pending(struct task_struct *p)
{
 return __builtin_expect(!!(test_tsk_thread_flag(p,1)), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __fatal_signal_pending(struct task_struct *p)
{
 return __builtin_expect(!!(sigismember(&p->pending.signal, 9)), 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fatal_signal_pending(struct task_struct *p)
{
 return signal_pending(p) && __fatal_signal_pending(p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int signal_pending_state(long state, struct task_struct *p)
{
 if (!(state & (0x0001 | 0x0100)))
  return 0;
 if (!signal_pending(p))
  return 0;

 return (state & 0x0001) || __fatal_signal_pending(p);
}







extern void recalc_sigpending_and_wake(struct task_struct *t);
extern void recalc_sigpending(void);
extern void calculate_sigpending(void);

extern void signal_wake_up_state(struct task_struct *t, unsigned int state);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void signal_wake_up(struct task_struct *t, bool resume)
{
 signal_wake_up_state(t, resume ? 0x0100 : 0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ptrace_signal_wake_up(struct task_struct *t, bool resume)
{
 signal_wake_up_state(t, resume ? 0x0008 : 0);
}

void task_join_group_stop(struct task_struct *task);
# 442 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_restore_sigmask(void)
{
 get_current()->restore_sigmask = true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_tsk_restore_sigmask(struct task_struct *task)
{
 task->restore_sigmask = false;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_restore_sigmask(void)
{
 get_current()->restore_sigmask = false;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_restore_sigmask(void)
{
 return get_current()->restore_sigmask;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_tsk_restore_sigmask(struct task_struct *task)
{
 return task->restore_sigmask;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool test_and_clear_restore_sigmask(void)
{
 if (!get_current()->restore_sigmask)
  return false;
 get_current()->restore_sigmask = false;
 return true;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_saved_sigmask(void)
{
 if (test_and_clear_restore_sigmask())
  __set_current_blocked(&get_current()->saved_sigmask);
}

extern int set_user_sigmask(const sigset_t *umask, size_t sigsetsize);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void restore_saved_sigmask_unless(bool interrupted)
{
 if (interrupted)
  ({ int __ret_warn_on = !!(!test_ti_thread_flag(((struct thread_info *)get_current()), 1)); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (482), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/sched/signal.h"), "i" (482), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 else
  restore_saved_sigmask();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sigset_t *sigmask_to_save(void)
{
 sigset_t *res = &get_current()->blocked;
 if (__builtin_expect(!!(test_restore_sigmask()), 0))
  res = &get_current()->saved_sigmask;
 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int kill_cad_pid(int sig, int priv)
{
 return kill_pid(cad_pid, sig, priv);
}
# 507 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int on_sig_stack(unsigned long sp)
{
# 518 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
 if (get_current()->sas_ss_flags & (1U << 31))
  return 0;





 return sp > get_current()->sas_ss_sp &&
  sp - get_current()->sas_ss_sp <= get_current()->sas_ss_size;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sas_ss_flags(unsigned long sp)
{
 if (!get_current()->sas_ss_size)
  return 2;

 return on_sig_stack(sp) ? 1 : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sas_ss_reset(struct task_struct *p)
{
 p->sas_ss_sp = 0;
 p->sas_ss_size = 0;
 p->sas_ss_flags = 2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long sigsp(unsigned long sp, struct ksignal *ksig)
{
 if (__builtin_expect(!!((ksig->ka.sa.sa_flags & 0x08000000U)), 0) && ! sas_ss_flags(sp))



  return get_current()->sas_ss_sp + get_current()->sas_ss_size;

 return sp;
}

extern void __cleanup_sighand(struct sighand_struct *);
extern void flush_itimer_signals(void);
# 568 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
extern bool current_is_single_threaded(void);
# 590 "/home/nathan/src/linux-next/include/linux/sched/signal.h"
typedef int (*proc_visitor)(struct task_struct *p, void *data);
void walk_process_tree(struct task_struct *top, proc_visitor, void *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct pid *task_pid_type(struct task_struct *task, enum pid_type type)
{
 struct pid *pid;
 if (type == PIDTYPE_PID)
  pid = task_pid(task);
 else
  pid = task->signal->pids[type];
 return pid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_tgid(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_TGID];
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_pgrp(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_PGID];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct pid *task_session(struct task_struct *task)
{
 return task->signal->pids[PIDTYPE_SID];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_nr_threads(struct task_struct *task)
{
 return task->signal->nr_threads;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool thread_group_leader(struct task_struct *p)
{
 return p->exit_signal >= 0;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool has_group_leader_pid(struct task_struct *p)
{
 return task_pid(p) == task_tgid(p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
bool same_thread_group(struct task_struct *p1, struct task_struct *p2)
{
 return p1->signal == p2->signal;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct task_struct *next_thread(const struct task_struct *p)
{
 return ({ void *__mptr = (void *)(({ union { typeof(p->thread_group.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); else __read_once_size_nocheck(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); do { } while (0); __u.__val; })); do { extern void __compiletime_assert_654(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(({ union { typeof(p->thread_group.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); else __read_once_size_nocheck(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); do { } while (0); __u.__val; }))), typeof(((struct task_struct *)0)->thread_group)) && !__builtin_types_compatible_p(typeof(*(({ union { typeof(p->thread_group.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); else __read_once_size_nocheck(&(p->thread_group.next), __u.__c, sizeof(p->thread_group.next)); do { } while (0); __u.__val; }))), typeof(void))))) __compiletime_assert_654(); } while (0); ((struct task_struct *)(__mptr - __builtin_offsetof(struct task_struct, thread_group))); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int thread_group_empty(struct task_struct *p)
{
 return list_empty(&p->thread_group);
}




extern struct sighand_struct *__lock_task_sighand(struct task_struct *task,
       unsigned long *flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sighand_struct *lock_task_sighand(struct task_struct *task,
             unsigned long *flags)
{
 struct sighand_struct *ret;

 ret = __lock_task_sighand(task, flags);
 (void)(ret);
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unlock_task_sighand(struct task_struct *task,
      unsigned long *flags)
{
 spin_unlock_irqrestore(&task->sighand->siglock, *flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long task_rlimit(const struct task_struct *task,
  unsigned int limit)
{
 return ({ union { typeof(task->signal->rlim[limit].rlim_cur) __val; char __c[1]; } __u; if (1) __read_once_size(&(task->signal->rlim[limit].rlim_cur), __u.__c, sizeof(task->signal->rlim[limit].rlim_cur)); else __read_once_size_nocheck(&(task->signal->rlim[limit].rlim_cur), __u.__c, sizeof(task->signal->rlim[limit].rlim_cur)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long task_rlimit_max(const struct task_struct *task,
  unsigned int limit)
{
 return ({ union { typeof(task->signal->rlim[limit].rlim_max) __val; char __c[1]; } __u; if (1) __read_once_size(&(task->signal->rlim[limit].rlim_max), __u.__c, sizeof(task->signal->rlim[limit].rlim_max)); else __read_once_size_nocheck(&(task->signal->rlim[limit].rlim_max), __u.__c, sizeof(task->signal->rlim[limit].rlim_max)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long rlimit(unsigned int limit)
{
 return task_rlimit(get_current(), limit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long rlimit_max(unsigned int limit)
{
 return task_rlimit_max(get_current(), limit);
}
# 12 "/home/nathan/src/linux-next/include/net/scm.h" 2






struct scm_creds {
 u32 pid;
 kuid_t uid;
 kgid_t gid;
};

struct scm_fp_list {
 short count;
 short max;
 struct user_struct *user;
 struct file *fp[253];
};

struct scm_cookie {
 struct pid *pid;
 struct scm_fp_list *fp;
 struct scm_creds creds;



};

void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm);
void scm_detach_fds_compat(struct msghdr *msg, struct scm_cookie *scm);
int __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm);
void __scm_destroy(struct scm_cookie *scm);
struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unix_get_peersec_dgram(struct socket *sock, struct scm_cookie *scm)
{ }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void scm_set_cred(struct scm_cookie *scm,
        struct pid *pid, kuid_t uid, kgid_t gid)
{
 scm->pid = get_pid(pid);
 scm->creds.pid = pid_vnr(pid);
 scm->creds.uid = uid;
 scm->creds.gid = gid;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void scm_destroy_cred(struct scm_cookie *scm)
{
 put_pid(scm->pid);
 scm->pid = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void scm_destroy(struct scm_cookie *scm)
{
 scm_destroy_cred(scm);
 if (scm->fp)
  __scm_destroy(scm);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int scm_send(struct socket *sock, struct msghdr *msg,
          struct scm_cookie *scm, bool forcecreds)
{
 memset(scm, 0, sizeof(*scm));
 scm->creds.uid = (kuid_t){ -1 };
 scm->creds.gid = (kgid_t){ -1 };
 if (forcecreds)
  scm_set_cred(scm, task_tgid(get_current()), (({ ({ do { } while (0); ; ((typeof(*(get_current()->cred)) *)((get_current()->cred))); })->uid; })), (({ ({ do { } while (0); ; ((typeof(*(get_current()->cred)) *)((get_current()->cred))); })->gid; })));
 unix_get_peersec_dgram(sock, scm);
 if (msg->msg_controllen <= 0)
  return 0;
 return __scm_send(sock, msg, scm);
}
# 109 "/home/nathan/src/linux-next/include/net/scm.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void scm_passec(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm)
{ }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void scm_recv(struct socket *sock, struct msghdr *msg,
    struct scm_cookie *scm, int flags)
{
 if (!msg->msg_control) {
  if (test_bit(3, &sock->flags) || scm->fp)
   msg->msg_flags |= 8;
  scm_destroy(scm);
  return;
 }

 if (test_bit(3, &sock->flags)) {
  struct user_namespace *current_ns = current_user_ns();
  struct ucred ucreds = {
   .pid = scm->creds.pid,
   .uid = from_kuid_munged(current_ns, scm->creds.uid),
   .gid = from_kgid_munged(current_ns, scm->creds.gid),
  };
  put_cmsg(msg, 1, 0x02, sizeof(ucreds), &ucreds);
 }

 scm_destroy_cred(scm);

 scm_passec(sock, msg, scm);

 if (!scm->fp)
  return;

 scm_detach_fds(msg, scm);
}
# 10 "/home/nathan/src/linux-next/include/linux/netlink.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h" 1
# 37 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
struct sockaddr_nl {
 __kernel_sa_family_t nl_family;
 unsigned short nl_pad;
 __u32 nl_pid;
        __u32 nl_groups;
};

struct nlmsghdr {
 __u32 nlmsg_len;
 __u16 nlmsg_type;
 __u16 nlmsg_flags;
 __u32 nlmsg_seq;
 __u32 nlmsg_pid;
};
# 109 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
struct nlmsgerr {
 int error;
 struct nlmsghdr msg;
# 121 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
};
# 135 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
enum nlmsgerr_attrs {
 NLMSGERR_ATTR_UNUSED,
 NLMSGERR_ATTR_MSG,
 NLMSGERR_ATTR_OFFS,
 NLMSGERR_ATTR_COOKIE,

 __NLMSGERR_ATTR_MAX,
 NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1
};
# 160 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
struct nl_pktinfo {
 __u32 group;
};

struct nl_mmap_req {
 unsigned int nm_block_size;
 unsigned int nm_block_nr;
 unsigned int nm_frame_size;
 unsigned int nm_frame_nr;
};

struct nl_mmap_hdr {
 unsigned int nm_status;
 unsigned int nm_len;
 __u32 nm_group;

 __u32 nm_pid;
 __u32 nm_uid;
 __u32 nm_gid;
};
# 197 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
enum {
 NETLINK_UNCONNECTED = 0,
 NETLINK_CONNECTED,
};
# 211 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
struct nlattr {
 __u16 nla_len;
 __u16 nla_type;
};
# 247 "/home/nathan/src/linux-next/include/uapi/linux/netlink.h"
struct nla_bitfield32 {
 __u32 value;
 __u32 selector;
};
# 11 "/home/nathan/src/linux-next/include/linux/netlink.h" 2

struct net;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
{
 return (struct nlmsghdr *)skb->data;
}

enum netlink_skb_flags {
 NETLINK_SKB_DST = 0x8,
};

struct netlink_skb_parms {
 struct scm_creds creds;
 __u32 portid;
 __u32 dst_group;
 __u32 flags;
 struct sock *sk;
 bool nsid_is_set;
 int nsid;
};





void netlink_table_grab(void);
void netlink_table_ungrab(void);





struct netlink_kernel_cfg {
 unsigned int groups;
 unsigned int flags;
 void (*input)(struct sk_buff *skb);
 struct mutex *cb_mutex;
 int (*bind)(struct net *net, int group);
 void (*unbind)(struct net *net, int group);
 bool (*compare)(struct net *net, struct sock *sk);
};

struct sock *__netlink_kernel_create(struct net *net, int unit,
         struct module *module,
         struct netlink_kernel_cfg *cfg);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *
netlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)
{
 return __netlink_kernel_create(net, unit, (&__this_module), cfg);
}
# 74 "/home/nathan/src/linux-next/include/linux/netlink.h"
struct netlink_ext_ack {
 const char *_msg;
 const struct nlattr *bad_attr;
 u8 cookie[20];
 u8 cookie_len;
};
# 113 "/home/nathan/src/linux-next/include/linux/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
         u64 cookie)
{
 u64 __cookie = cookie;

 memcpy(extack->cookie, &__cookie, sizeof(__cookie));
 extack->cookie_len = sizeof(__cookie);
}

void netlink_kernel_release(struct sock *sk);
int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
int netlink_change_ngroups(struct sock *sk, unsigned int groups);
void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
   const struct netlink_ext_ack *extack);
int netlink_has_listeners(struct sock *sk, unsigned int group);
bool netlink_strict_get_check(struct sk_buff *skb);

int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
        __u32 group, gfp_t allocation);
int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
          __u32 portid, __u32 group, gfp_t allocation,
          int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),
          void *filter_data);
int netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);
int netlink_register_notifier(struct notifier_block *nb);
int netlink_unregister_notifier(struct notifier_block *nb);


struct sock *netlink_getsockbyfilp(struct file *filp);
int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
        long *timeo, struct sock *ssk);
void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
int netlink_sendskb(struct sock *sk, struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *
netlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
{
 struct sk_buff *nskb;

 nskb = skb_clone(skb, gfp_mask);
 if (!nskb)
  return ((void *)0);


 if (is_vmalloc_addr(skb->head))
  nskb->destructor = skb->destructor;

 return nskb;
}
# 180 "/home/nathan/src/linux-next/include/linux/netlink.h"
struct netlink_callback {
 struct sk_buff *skb;
 const struct nlmsghdr *nlh;
 int (*dump)(struct sk_buff * skb,
     struct netlink_callback *cb);
 int (*done)(struct netlink_callback *cb);
 void *data;

 struct module *module;
 struct netlink_ext_ack *extack;
 u16 family;
 u16 min_dump_alloc;
 bool strict_check;
 u16 answer_flags;
 unsigned int prev_seq, seq;
 union {
  u8 ctx[48];




  long args[6];
 };
};

struct netlink_notify {
 struct net *net;
 u32 portid;
 int protocol;
};

struct nlmsghdr *
__nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);

struct netlink_dump_control {
 int (*start)(struct netlink_callback *);
 int (*dump)(struct sk_buff *skb, struct netlink_callback *);
 int (*done)(struct netlink_callback *);
 void *data;
 struct module *module;
 u16 min_dump_alloc;
};

int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
    const struct nlmsghdr *nlh,
    struct netlink_dump_control *control);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
         const struct nlmsghdr *nlh,
         struct netlink_dump_control *control)
{
 if (!control->module)
  control->module = (&__this_module);

 return __netlink_dump_start(ssk, skb, nlh, control);
}

struct netlink_tap {
 struct net_device *dev;
 struct module *module;
 struct list_head list;
};

int netlink_add_tap(struct netlink_tap *nt);
int netlink_remove_tap(struct netlink_tap *nt);

bool __netlink_ns_capable(const struct netlink_skb_parms *nsp,
     struct user_namespace *ns, int cap);
bool netlink_ns_capable(const struct sk_buff *skb,
   struct user_namespace *ns, int cap);
bool netlink_capable(const struct sk_buff *skb, int cap);
bool netlink_net_capable(const struct sk_buff *skb, int cap);
# 7 "/home/nathan/src/linux-next/include/uapi/linux/neighbour.h" 2

struct ndmsg {
 __u8 ndm_family;
 __u8 ndm_pad1;
 __u16 ndm_pad2;
 __s32 ndm_ifindex;
 __u16 ndm_state;
 __u8 ndm_flags;
 __u8 ndm_type;
};

enum {
 NDA_UNSPEC,
 NDA_DST,
 NDA_LLADDR,
 NDA_CACHEINFO,
 NDA_PROBES,
 NDA_VLAN,
 NDA_PORT,
 NDA_VNI,
 NDA_IFINDEX,
 NDA_MASTER,
 NDA_LINK_NETNSID,
 NDA_SRC_VNI,
 NDA_PROTOCOL,
 __NDA_MAX
};
# 71 "/home/nathan/src/linux-next/include/uapi/linux/neighbour.h"
struct nda_cacheinfo {
 __u32 ndm_confirmed;
 __u32 ndm_used;
 __u32 ndm_updated;
 __u32 ndm_refcnt;
};
# 103 "/home/nathan/src/linux-next/include/uapi/linux/neighbour.h"
struct ndt_stats {
 __u64 ndts_allocs;
 __u64 ndts_destroys;
 __u64 ndts_hash_grows;
 __u64 ndts_res_failed;
 __u64 ndts_lookups;
 __u64 ndts_hits;
 __u64 ndts_rcv_probes_mcast;
 __u64 ndts_rcv_probes_ucast;
 __u64 ndts_periodic_gc_runs;
 __u64 ndts_forced_gc_runs;
 __u64 ndts_table_fulls;
};

enum {
 NDTPA_UNSPEC,
 NDTPA_IFINDEX,
 NDTPA_REFCNT,
 NDTPA_REACHABLE_TIME,
 NDTPA_BASE_REACHABLE_TIME,
 NDTPA_RETRANS_TIME,
 NDTPA_GC_STALETIME,
 NDTPA_DELAY_PROBE_TIME,
 NDTPA_QUEUE_LEN,
 NDTPA_APP_PROBES,
 NDTPA_UCAST_PROBES,
 NDTPA_MCAST_PROBES,
 NDTPA_ANYCAST_DELAY,
 NDTPA_PROXY_DELAY,
 NDTPA_PROXY_QLEN,
 NDTPA_LOCKTIME,
 NDTPA_QUEUE_LENBYTES,
 NDTPA_MCAST_REPROBES,
 NDTPA_PAD,
 __NDTPA_MAX
};


struct ndtmsg {
 __u8 ndtm_family;
 __u8 ndtm_pad1;
 __u16 ndtm_pad2;
};

struct ndt_config {
 __u16 ndtc_key_len;
 __u16 ndtc_entry_size;
 __u32 ndtc_entries;
 __u32 ndtc_last_flush;
 __u32 ndtc_last_rand;
 __u32 ndtc_hash_rnd;
 __u32 ndtc_hash_mask;
 __u32 ndtc_hash_chain_gc;
 __u32 ndtc_proxy_qlen;
};

enum {
 NDTA_UNSPEC,
 NDTA_NAME,
 NDTA_THRESH1,
 NDTA_THRESH2,
 NDTA_THRESH3,
 NDTA_CONFIG,
 NDTA_PARMS,
 NDTA_STATS,
 NDTA_GC_INTERVAL,
 NDTA_PAD,
 __NDTA_MAX
};
# 47 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/netdevice.h" 1
# 32 "/home/nathan/src/linux-next/include/uapi/linux/netdevice.h"
# 1 "/home/nathan/src/linux-next/include/linux/if_link.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h" 1








struct rtnl_link_stats {
 __u32 rx_packets;
 __u32 tx_packets;
 __u32 rx_bytes;
 __u32 tx_bytes;
 __u32 rx_errors;
 __u32 tx_errors;
 __u32 rx_dropped;
 __u32 tx_dropped;
 __u32 multicast;
 __u32 collisions;


 __u32 rx_length_errors;
 __u32 rx_over_errors;
 __u32 rx_crc_errors;
 __u32 rx_frame_errors;
 __u32 rx_fifo_errors;
 __u32 rx_missed_errors;


 __u32 tx_aborted_errors;
 __u32 tx_carrier_errors;
 __u32 tx_fifo_errors;
 __u32 tx_heartbeat_errors;
 __u32 tx_window_errors;


 __u32 rx_compressed;
 __u32 tx_compressed;

 __u32 rx_nohandler;
};


struct rtnl_link_stats64 {
 __u64 rx_packets;
 __u64 tx_packets;
 __u64 rx_bytes;
 __u64 tx_bytes;
 __u64 rx_errors;
 __u64 tx_errors;
 __u64 rx_dropped;
 __u64 tx_dropped;
 __u64 multicast;
 __u64 collisions;


 __u64 rx_length_errors;
 __u64 rx_over_errors;
 __u64 rx_crc_errors;
 __u64 rx_frame_errors;
 __u64 rx_fifo_errors;
 __u64 rx_missed_errors;


 __u64 tx_aborted_errors;
 __u64 tx_carrier_errors;
 __u64 tx_fifo_errors;
 __u64 tx_heartbeat_errors;
 __u64 tx_window_errors;


 __u64 rx_compressed;
 __u64 tx_compressed;

 __u64 rx_nohandler;
};


struct rtnl_link_ifmap {
 __u64 mem_start;
 __u64 mem_end;
 __u64 base_addr;
 __u16 irq;
 __u8 dma;
 __u8 port;
};
# 106 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 IFLA_UNSPEC,
 IFLA_ADDRESS,
 IFLA_BROADCAST,
 IFLA_IFNAME,
 IFLA_MTU,
 IFLA_LINK,
 IFLA_QDISC,
 IFLA_STATS,
 IFLA_COST,

 IFLA_PRIORITY,

 IFLA_MASTER,

 IFLA_WIRELESS,

 IFLA_PROTINFO,

 IFLA_TXQLEN,

 IFLA_MAP,

 IFLA_WEIGHT,

 IFLA_OPERSTATE,
 IFLA_LINKMODE,
 IFLA_LINKINFO,

 IFLA_NET_NS_PID,
 IFLA_IFALIAS,
 IFLA_NUM_VF,
 IFLA_VFINFO_LIST,
 IFLA_STATS64,
 IFLA_VF_PORTS,
 IFLA_PORT_SELF,
 IFLA_AF_SPEC,
 IFLA_GROUP,
 IFLA_NET_NS_FD,
 IFLA_EXT_MASK,
 IFLA_PROMISCUITY,

 IFLA_NUM_TX_QUEUES,
 IFLA_NUM_RX_QUEUES,
 IFLA_CARRIER,
 IFLA_PHYS_PORT_ID,
 IFLA_CARRIER_CHANGES,
 IFLA_PHYS_SWITCH_ID,
 IFLA_LINK_NETNSID,
 IFLA_PHYS_PORT_NAME,
 IFLA_PROTO_DOWN,
 IFLA_GSO_MAX_SEGS,
 IFLA_GSO_MAX_SIZE,
 IFLA_PAD,
 IFLA_XDP,
 IFLA_EVENT,
 IFLA_NEW_NETNSID,
 IFLA_IF_NETNSID,
 IFLA_TARGET_NETNSID = IFLA_IF_NETNSID,
 IFLA_CARRIER_UP_COUNT,
 IFLA_CARRIER_DOWN_COUNT,
 IFLA_NEW_IFINDEX,
 IFLA_MIN_MTU,
 IFLA_MAX_MTU,
 IFLA_PROP_LIST,
 IFLA_ALT_IFNAME,
 IFLA_PERM_ADDRESS,
 __IFLA_MAX
};
# 185 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 IFLA_INET_UNSPEC,
 IFLA_INET_CONF,
 __IFLA_INET_MAX,
};
# 223 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 IFLA_INET6_UNSPEC,
 IFLA_INET6_FLAGS,
 IFLA_INET6_CONF,
 IFLA_INET6_STATS,
 IFLA_INET6_MCAST,
 IFLA_INET6_CACHEINFO,
 IFLA_INET6_ICMP6STATS,
 IFLA_INET6_TOKEN,
 IFLA_INET6_ADDR_GEN_MODE,
 __IFLA_INET6_MAX
};



enum in6_addr_gen_mode {
 IN6_ADDR_GEN_MODE_EUI64,
 IN6_ADDR_GEN_MODE_NONE,
 IN6_ADDR_GEN_MODE_STABLE_PRIVACY,
 IN6_ADDR_GEN_MODE_RANDOM,
};



enum {
 IFLA_BR_UNSPEC,
 IFLA_BR_FORWARD_DELAY,
 IFLA_BR_HELLO_TIME,
 IFLA_BR_MAX_AGE,
 IFLA_BR_AGEING_TIME,
 IFLA_BR_STP_STATE,
 IFLA_BR_PRIORITY,
 IFLA_BR_VLAN_FILTERING,
 IFLA_BR_VLAN_PROTOCOL,
 IFLA_BR_GROUP_FWD_MASK,
 IFLA_BR_ROOT_ID,
 IFLA_BR_BRIDGE_ID,
 IFLA_BR_ROOT_PORT,
 IFLA_BR_ROOT_PATH_COST,
 IFLA_BR_TOPOLOGY_CHANGE,
 IFLA_BR_TOPOLOGY_CHANGE_DETECTED,
 IFLA_BR_HELLO_TIMER,
 IFLA_BR_TCN_TIMER,
 IFLA_BR_TOPOLOGY_CHANGE_TIMER,
 IFLA_BR_GC_TIMER,
 IFLA_BR_GROUP_ADDR,
 IFLA_BR_FDB_FLUSH,
 IFLA_BR_MCAST_ROUTER,
 IFLA_BR_MCAST_SNOOPING,
 IFLA_BR_MCAST_QUERY_USE_IFADDR,
 IFLA_BR_MCAST_QUERIER,
 IFLA_BR_MCAST_HASH_ELASTICITY,
 IFLA_BR_MCAST_HASH_MAX,
 IFLA_BR_MCAST_LAST_MEMBER_CNT,
 IFLA_BR_MCAST_STARTUP_QUERY_CNT,
 IFLA_BR_MCAST_LAST_MEMBER_INTVL,
 IFLA_BR_MCAST_MEMBERSHIP_INTVL,
 IFLA_BR_MCAST_QUERIER_INTVL,
 IFLA_BR_MCAST_QUERY_INTVL,
 IFLA_BR_MCAST_QUERY_RESPONSE_INTVL,
 IFLA_BR_MCAST_STARTUP_QUERY_INTVL,
 IFLA_BR_NF_CALL_IPTABLES,
 IFLA_BR_NF_CALL_IP6TABLES,
 IFLA_BR_NF_CALL_ARPTABLES,
 IFLA_BR_VLAN_DEFAULT_PVID,
 IFLA_BR_PAD,
 IFLA_BR_VLAN_STATS_ENABLED,
 IFLA_BR_MCAST_STATS_ENABLED,
 IFLA_BR_MCAST_IGMP_VERSION,
 IFLA_BR_MCAST_MLD_VERSION,
 IFLA_BR_VLAN_STATS_PER_PORT,
 IFLA_BR_MULTI_BOOLOPT,
 __IFLA_BR_MAX,
};



struct ifla_bridge_id {
 __u8 prio[2];
 __u8 addr[6];
};

enum {
 BRIDGE_MODE_UNSPEC,
 BRIDGE_MODE_HAIRPIN,
};

enum {
 IFLA_BRPORT_UNSPEC,
 IFLA_BRPORT_STATE,
 IFLA_BRPORT_PRIORITY,
 IFLA_BRPORT_COST,
 IFLA_BRPORT_MODE,
 IFLA_BRPORT_GUARD,
 IFLA_BRPORT_PROTECT,
 IFLA_BRPORT_FAST_LEAVE,
 IFLA_BRPORT_LEARNING,
 IFLA_BRPORT_UNICAST_FLOOD,
 IFLA_BRPORT_PROXYARP,
 IFLA_BRPORT_LEARNING_SYNC,
 IFLA_BRPORT_PROXYARP_WIFI,
 IFLA_BRPORT_ROOT_ID,
 IFLA_BRPORT_BRIDGE_ID,
 IFLA_BRPORT_DESIGNATED_PORT,
 IFLA_BRPORT_DESIGNATED_COST,
 IFLA_BRPORT_ID,
 IFLA_BRPORT_NO,
 IFLA_BRPORT_TOPOLOGY_CHANGE_ACK,
 IFLA_BRPORT_CONFIG_PENDING,
 IFLA_BRPORT_MESSAGE_AGE_TIMER,
 IFLA_BRPORT_FORWARD_DELAY_TIMER,
 IFLA_BRPORT_HOLD_TIMER,
 IFLA_BRPORT_FLUSH,
 IFLA_BRPORT_MULTICAST_ROUTER,
 IFLA_BRPORT_PAD,
 IFLA_BRPORT_MCAST_FLOOD,
 IFLA_BRPORT_MCAST_TO_UCAST,
 IFLA_BRPORT_VLAN_TUNNEL,
 IFLA_BRPORT_BCAST_FLOOD,
 IFLA_BRPORT_GROUP_FWD_MASK,
 IFLA_BRPORT_NEIGH_SUPPRESS,
 IFLA_BRPORT_ISOLATED,
 IFLA_BRPORT_BACKUP_PORT,
 __IFLA_BRPORT_MAX
};


struct ifla_cacheinfo {
 __u32 max_reasm_len;
 __u32 tstamp;
 __u32 reachable_time;
 __u32 retrans_time;
};

enum {
 IFLA_INFO_UNSPEC,
 IFLA_INFO_KIND,
 IFLA_INFO_DATA,
 IFLA_INFO_XSTATS,
 IFLA_INFO_SLAVE_KIND,
 IFLA_INFO_SLAVE_DATA,
 __IFLA_INFO_MAX,
};





enum {
 IFLA_VLAN_UNSPEC,
 IFLA_VLAN_ID,
 IFLA_VLAN_FLAGS,
 IFLA_VLAN_EGRESS_QOS,
 IFLA_VLAN_INGRESS_QOS,
 IFLA_VLAN_PROTOCOL,
 __IFLA_VLAN_MAX,
};



struct ifla_vlan_flags {
 __u32 flags;
 __u32 mask;
};

enum {
 IFLA_VLAN_QOS_UNSPEC,
 IFLA_VLAN_QOS_MAPPING,
 __IFLA_VLAN_QOS_MAX
};



struct ifla_vlan_qos_mapping {
 __u32 from;
 __u32 to;
};


enum {
 IFLA_MACVLAN_UNSPEC,
 IFLA_MACVLAN_MODE,
 IFLA_MACVLAN_FLAGS,
 IFLA_MACVLAN_MACADDR_MODE,
 IFLA_MACVLAN_MACADDR,
 IFLA_MACVLAN_MACADDR_DATA,
 IFLA_MACVLAN_MACADDR_COUNT,
 __IFLA_MACVLAN_MAX,
};



enum macvlan_mode {
 MACVLAN_MODE_PRIVATE = 1,
 MACVLAN_MODE_VEPA = 2,
 MACVLAN_MODE_BRIDGE = 4,
 MACVLAN_MODE_PASSTHRU = 8,
 MACVLAN_MODE_SOURCE = 16,
};

enum macvlan_macaddr_mode {
 MACVLAN_MACADDR_ADD,
 MACVLAN_MACADDR_DEL,
 MACVLAN_MACADDR_FLUSH,
 MACVLAN_MACADDR_SET,
};




enum {
 IFLA_VRF_UNSPEC,
 IFLA_VRF_TABLE,
 __IFLA_VRF_MAX
};



enum {
 IFLA_VRF_PORT_UNSPEC,
 IFLA_VRF_PORT_TABLE,
 __IFLA_VRF_PORT_MAX
};




enum {
 IFLA_MACSEC_UNSPEC,
 IFLA_MACSEC_SCI,
 IFLA_MACSEC_PORT,
 IFLA_MACSEC_ICV_LEN,
 IFLA_MACSEC_CIPHER_SUITE,
 IFLA_MACSEC_WINDOW,
 IFLA_MACSEC_ENCODING_SA,
 IFLA_MACSEC_ENCRYPT,
 IFLA_MACSEC_PROTECT,
 IFLA_MACSEC_INC_SCI,
 IFLA_MACSEC_ES,
 IFLA_MACSEC_SCB,
 IFLA_MACSEC_REPLAY_PROTECT,
 IFLA_MACSEC_VALIDATION,
 IFLA_MACSEC_PAD,
 __IFLA_MACSEC_MAX,
};




enum {
 IFLA_XFRM_UNSPEC,
 IFLA_XFRM_LINK,
 IFLA_XFRM_IF_ID,
 __IFLA_XFRM_MAX
};



enum macsec_validation_type {
 MACSEC_VALIDATE_DISABLED = 0,
 MACSEC_VALIDATE_CHECK = 1,
 MACSEC_VALIDATE_STRICT = 2,
 __MACSEC_VALIDATE_END,
 MACSEC_VALIDATE_MAX = __MACSEC_VALIDATE_END - 1,
};

enum macsec_offload {
 MACSEC_OFFLOAD_OFF = 0,
 MACSEC_OFFLOAD_PHY = 1,
 __MACSEC_OFFLOAD_END,
 MACSEC_OFFLOAD_MAX = __MACSEC_OFFLOAD_END - 1,
};


enum {
 IFLA_IPVLAN_UNSPEC,
 IFLA_IPVLAN_MODE,
 IFLA_IPVLAN_FLAGS,
 __IFLA_IPVLAN_MAX
};



enum ipvlan_mode {
 IPVLAN_MODE_L2 = 0,
 IPVLAN_MODE_L3,
 IPVLAN_MODE_L3S,
 IPVLAN_MODE_MAX
};





enum {
 IFLA_VXLAN_UNSPEC,
 IFLA_VXLAN_ID,
 IFLA_VXLAN_GROUP,
 IFLA_VXLAN_LINK,
 IFLA_VXLAN_LOCAL,
 IFLA_VXLAN_TTL,
 IFLA_VXLAN_TOS,
 IFLA_VXLAN_LEARNING,
 IFLA_VXLAN_AGEING,
 IFLA_VXLAN_LIMIT,
 IFLA_VXLAN_PORT_RANGE,
 IFLA_VXLAN_PROXY,
 IFLA_VXLAN_RSC,
 IFLA_VXLAN_L2MISS,
 IFLA_VXLAN_L3MISS,
 IFLA_VXLAN_PORT,
 IFLA_VXLAN_GROUP6,
 IFLA_VXLAN_LOCAL6,
 IFLA_VXLAN_UDP_CSUM,
 IFLA_VXLAN_UDP_ZERO_CSUM6_TX,
 IFLA_VXLAN_UDP_ZERO_CSUM6_RX,
 IFLA_VXLAN_REMCSUM_TX,
 IFLA_VXLAN_REMCSUM_RX,
 IFLA_VXLAN_GBP,
 IFLA_VXLAN_REMCSUM_NOPARTIAL,
 IFLA_VXLAN_COLLECT_METADATA,
 IFLA_VXLAN_LABEL,
 IFLA_VXLAN_GPE,
 IFLA_VXLAN_TTL_INHERIT,
 IFLA_VXLAN_DF,
 __IFLA_VXLAN_MAX
};


struct ifla_vxlan_port_range {
 __be16 low;
 __be16 high;
};

enum ifla_vxlan_df {
 VXLAN_DF_UNSET = 0,
 VXLAN_DF_SET,
 VXLAN_DF_INHERIT,
 __VXLAN_DF_END,
 VXLAN_DF_MAX = __VXLAN_DF_END - 1,
};


enum {
 IFLA_GENEVE_UNSPEC,
 IFLA_GENEVE_ID,
 IFLA_GENEVE_REMOTE,
 IFLA_GENEVE_TTL,
 IFLA_GENEVE_TOS,
 IFLA_GENEVE_PORT,
 IFLA_GENEVE_COLLECT_METADATA,
 IFLA_GENEVE_REMOTE6,
 IFLA_GENEVE_UDP_CSUM,
 IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
 IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
 IFLA_GENEVE_LABEL,
 IFLA_GENEVE_TTL_INHERIT,
 IFLA_GENEVE_DF,
 __IFLA_GENEVE_MAX
};


enum ifla_geneve_df {
 GENEVE_DF_UNSET = 0,
 GENEVE_DF_SET,
 GENEVE_DF_INHERIT,
 __GENEVE_DF_END,
 GENEVE_DF_MAX = __GENEVE_DF_END - 1,
};


enum {
 IFLA_PPP_UNSPEC,
 IFLA_PPP_DEV_FD,
 __IFLA_PPP_MAX
};




enum ifla_gtp_role {
 GTP_ROLE_GGSN = 0,
 GTP_ROLE_SGSN,
};

enum {
 IFLA_GTP_UNSPEC,
 IFLA_GTP_FD0,
 IFLA_GTP_FD1,
 IFLA_GTP_PDP_HASHSIZE,
 IFLA_GTP_ROLE,
 __IFLA_GTP_MAX,
};




enum {
 IFLA_BOND_UNSPEC,
 IFLA_BOND_MODE,
 IFLA_BOND_ACTIVE_SLAVE,
 IFLA_BOND_MIIMON,
 IFLA_BOND_UPDELAY,
 IFLA_BOND_DOWNDELAY,
 IFLA_BOND_USE_CARRIER,
 IFLA_BOND_ARP_INTERVAL,
 IFLA_BOND_ARP_IP_TARGET,
 IFLA_BOND_ARP_VALIDATE,
 IFLA_BOND_ARP_ALL_TARGETS,
 IFLA_BOND_PRIMARY,
 IFLA_BOND_PRIMARY_RESELECT,
 IFLA_BOND_FAIL_OVER_MAC,
 IFLA_BOND_XMIT_HASH_POLICY,
 IFLA_BOND_RESEND_IGMP,
 IFLA_BOND_NUM_PEER_NOTIF,
 IFLA_BOND_ALL_SLAVES_ACTIVE,
 IFLA_BOND_MIN_LINKS,
 IFLA_BOND_LP_INTERVAL,
 IFLA_BOND_PACKETS_PER_SLAVE,
 IFLA_BOND_AD_LACP_RATE,
 IFLA_BOND_AD_SELECT,
 IFLA_BOND_AD_INFO,
 IFLA_BOND_AD_ACTOR_SYS_PRIO,
 IFLA_BOND_AD_USER_PORT_KEY,
 IFLA_BOND_AD_ACTOR_SYSTEM,
 IFLA_BOND_TLB_DYNAMIC_LB,
 IFLA_BOND_PEER_NOTIF_DELAY,
 __IFLA_BOND_MAX,
};



enum {
 IFLA_BOND_AD_INFO_UNSPEC,
 IFLA_BOND_AD_INFO_AGGREGATOR,
 IFLA_BOND_AD_INFO_NUM_PORTS,
 IFLA_BOND_AD_INFO_ACTOR_KEY,
 IFLA_BOND_AD_INFO_PARTNER_KEY,
 IFLA_BOND_AD_INFO_PARTNER_MAC,
 __IFLA_BOND_AD_INFO_MAX,
};



enum {
 IFLA_BOND_SLAVE_UNSPEC,
 IFLA_BOND_SLAVE_STATE,
 IFLA_BOND_SLAVE_MII_STATUS,
 IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
 IFLA_BOND_SLAVE_PERM_HWADDR,
 IFLA_BOND_SLAVE_QUEUE_ID,
 IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
 IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE,
 IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE,
 __IFLA_BOND_SLAVE_MAX,
};





enum {
 IFLA_VF_INFO_UNSPEC,
 IFLA_VF_INFO,
 __IFLA_VF_INFO_MAX,
};



enum {
 IFLA_VF_UNSPEC,
 IFLA_VF_MAC,
 IFLA_VF_VLAN,
 IFLA_VF_TX_RATE,
 IFLA_VF_SPOOFCHK,
 IFLA_VF_LINK_STATE,
 IFLA_VF_RATE,
 IFLA_VF_RSS_QUERY_EN,


 IFLA_VF_STATS,
 IFLA_VF_TRUST,
 IFLA_VF_IB_NODE_GUID,
 IFLA_VF_IB_PORT_GUID,
 IFLA_VF_VLAN_LIST,
 IFLA_VF_BROADCAST,
 __IFLA_VF_MAX,
};



struct ifla_vf_mac {
 __u32 vf;
 __u8 mac[32];
};

struct ifla_vf_broadcast {
 __u8 broadcast[32];
};

struct ifla_vf_vlan {
 __u32 vf;
 __u32 vlan;
 __u32 qos;
};

enum {
 IFLA_VF_VLAN_INFO_UNSPEC,
 IFLA_VF_VLAN_INFO,
 __IFLA_VF_VLAN_INFO_MAX,
};




struct ifla_vf_vlan_info {
 __u32 vf;
 __u32 vlan;
 __u32 qos;
 __be16 vlan_proto;
};

struct ifla_vf_tx_rate {
 __u32 vf;
 __u32 rate;
};

struct ifla_vf_rate {
 __u32 vf;
 __u32 min_tx_rate;
 __u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
 __u32 vf;
 __u32 setting;
};

struct ifla_vf_guid {
 __u32 vf;
 __u64 guid;
};

enum {
 IFLA_VF_LINK_STATE_AUTO,
 IFLA_VF_LINK_STATE_ENABLE,
 IFLA_VF_LINK_STATE_DISABLE,
 __IFLA_VF_LINK_STATE_MAX,
};

struct ifla_vf_link_state {
 __u32 vf;
 __u32 link_state;
};

struct ifla_vf_rss_query_en {
 __u32 vf;
 __u32 setting;
};

enum {
 IFLA_VF_STATS_RX_PACKETS,
 IFLA_VF_STATS_TX_PACKETS,
 IFLA_VF_STATS_RX_BYTES,
 IFLA_VF_STATS_TX_BYTES,
 IFLA_VF_STATS_BROADCAST,
 IFLA_VF_STATS_MULTICAST,
 IFLA_VF_STATS_PAD,
 IFLA_VF_STATS_RX_DROPPED,
 IFLA_VF_STATS_TX_DROPPED,
 __IFLA_VF_STATS_MAX,
};



struct ifla_vf_trust {
 __u32 vf;
 __u32 setting;
};
# 818 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 IFLA_VF_PORT_UNSPEC,
 IFLA_VF_PORT,
 __IFLA_VF_PORT_MAX,
};



enum {
 IFLA_PORT_UNSPEC,
 IFLA_PORT_VF,
 IFLA_PORT_PROFILE,
 IFLA_PORT_VSI_TYPE,
 IFLA_PORT_INSTANCE_UUID,
 IFLA_PORT_HOST_UUID,
 IFLA_PORT_REQUEST,
 IFLA_PORT_RESPONSE,
 __IFLA_PORT_MAX,
};







enum {
 PORT_REQUEST_PREASSOCIATE = 0,
 PORT_REQUEST_PREASSOCIATE_RR,
 PORT_REQUEST_ASSOCIATE,
 PORT_REQUEST_DISASSOCIATE,
};

enum {
 PORT_VDP_RESPONSE_SUCCESS = 0,
 PORT_VDP_RESPONSE_INVALID_FORMAT,
 PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES,
 PORT_VDP_RESPONSE_UNUSED_VTID,
 PORT_VDP_RESPONSE_VTID_VIOLATION,
 PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION,
 PORT_VDP_RESPONSE_OUT_OF_SYNC,

 PORT_PROFILE_RESPONSE_SUCCESS = 0x100,
 PORT_PROFILE_RESPONSE_INPROGRESS,
 PORT_PROFILE_RESPONSE_INVALID,
 PORT_PROFILE_RESPONSE_BADSTATE,
 PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES,
 PORT_PROFILE_RESPONSE_ERROR,
};

struct ifla_port_vsi {
 __u8 vsi_mgr_id;
 __u8 vsi_type_id[3];
 __u8 vsi_type_version;
 __u8 pad[3];
};




enum {
 IFLA_IPOIB_UNSPEC,
 IFLA_IPOIB_PKEY,
 IFLA_IPOIB_MODE,
 IFLA_IPOIB_UMCAST,
 __IFLA_IPOIB_MAX
};

enum {
 IPOIB_MODE_DATAGRAM = 0,
 IPOIB_MODE_CONNECTED = 1,
};






enum {
 IFLA_HSR_UNSPEC,
 IFLA_HSR_SLAVE1,
 IFLA_HSR_SLAVE2,
 IFLA_HSR_MULTICAST_SPEC,
 IFLA_HSR_SUPERVISION_ADDR,
 IFLA_HSR_SEQ_NR,
 IFLA_HSR_VERSION,
 __IFLA_HSR_MAX,
};





struct if_stats_msg {
 __u8 family;
 __u8 pad1;
 __u16 pad2;
 __u32 ifindex;
 __u32 filter_mask;
};




enum {
 IFLA_STATS_UNSPEC,
 IFLA_STATS_LINK_64,
 IFLA_STATS_LINK_XSTATS,
 IFLA_STATS_LINK_XSTATS_SLAVE,
 IFLA_STATS_LINK_OFFLOAD_XSTATS,
 IFLA_STATS_AF_SPEC,
 __IFLA_STATS_MAX,
};
# 941 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 LINK_XSTATS_TYPE_UNSPEC,
 LINK_XSTATS_TYPE_BRIDGE,
 LINK_XSTATS_TYPE_BOND,
 __LINK_XSTATS_TYPE_MAX
};



enum {
 IFLA_OFFLOAD_XSTATS_UNSPEC,
 IFLA_OFFLOAD_XSTATS_CPU_HIT,
 __IFLA_OFFLOAD_XSTATS_MAX
};
# 970 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 XDP_ATTACHED_NONE = 0,
 XDP_ATTACHED_DRV,
 XDP_ATTACHED_SKB,
 XDP_ATTACHED_HW,
 XDP_ATTACHED_MULTI,
};

enum {
 IFLA_XDP_UNSPEC,
 IFLA_XDP_FD,
 IFLA_XDP_ATTACHED,
 IFLA_XDP_FLAGS,
 IFLA_XDP_PROG_ID,
 IFLA_XDP_DRV_PROG_ID,
 IFLA_XDP_SKB_PROG_ID,
 IFLA_XDP_HW_PROG_ID,
 __IFLA_XDP_MAX,
};



enum {
 IFLA_EVENT_NONE,
 IFLA_EVENT_REBOOT,
 IFLA_EVENT_FEATURES,
 IFLA_EVENT_BONDING_FAILOVER,
 IFLA_EVENT_NOTIFY_PEERS,
 IFLA_EVENT_IGMP_RESEND,
 IFLA_EVENT_BONDING_OPTIONS,
};



enum {
 IFLA_TUN_UNSPEC,
 IFLA_TUN_OWNER,
 IFLA_TUN_GROUP,
 IFLA_TUN_TYPE,
 IFLA_TUN_PI,
 IFLA_TUN_VNET_HDR,
 IFLA_TUN_PERSIST,
 IFLA_TUN_MULTI_QUEUE,
 IFLA_TUN_NUM_QUEUES,
 IFLA_TUN_NUM_DISABLED_QUEUES,
 __IFLA_TUN_MAX,
};
# 1027 "/home/nathan/src/linux-next/include/uapi/linux/if_link.h"
enum {
 IFLA_RMNET_UNSPEC,
 IFLA_RMNET_MUX_ID,
 IFLA_RMNET_FLAGS,
 __IFLA_RMNET_MAX,
};



struct ifla_rmnet_flags {
 __u32 flags;
 __u32 mask;
};
# 6 "/home/nathan/src/linux-next/include/linux/if_link.h" 2



struct ifla_vf_stats {
 __u64 rx_packets;
 __u64 tx_packets;
 __u64 rx_bytes;
 __u64 tx_bytes;
 __u64 broadcast;
 __u64 multicast;
 __u64 rx_dropped;
 __u64 tx_dropped;
};

struct ifla_vf_info {
 __u32 vf;
 __u8 mac[32];
 __u32 vlan;
 __u32 qos;
 __u32 spoofchk;
 __u32 linkstate;
 __u32 min_tx_rate;
 __u32 max_tx_rate;
 __u32 rss_query_en;
 __u32 trusted;
 __be16 vlan_proto;
};
# 33 "/home/nathan/src/linux-next/include/uapi/linux/netdevice.h" 2
# 49 "/home/nathan/src/linux-next/include/uapi/linux/netdevice.h"
enum {
        IF_PORT_UNKNOWN = 0,
        IF_PORT_10BASE2,
        IF_PORT_10BASET,
        IF_PORT_AUI,
        IF_PORT_100BASET,
        IF_PORT_100BASETX,
        IF_PORT_100BASEFX
};
# 48 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_bonding.h" 1
# 108 "/home/nathan/src/linux-next/include/uapi/linux/if_bonding.h"
typedef struct ifbond {
 __s32 bond_mode;
 __s32 num_slaves;
 __s32 miimon;
} ifbond;

typedef struct ifslave {
 __s32 slave_id;
 char slave_name[16];
 __s8 link;
 __s8 state;
 __u32 link_failure_count;
} ifslave;

struct ad_info {
 __u16 aggregator_id;
 __u16 ports;
 __u16 actor_key;
 __u16 partner_key;
 __u8 partner_system[6];
};


enum {
 BOND_XSTATS_UNSPEC,
 BOND_XSTATS_3AD,
 __BOND_XSTATS_MAX
};



enum {
 BOND_3AD_STAT_LACPDU_RX,
 BOND_3AD_STAT_LACPDU_TX,
 BOND_3AD_STAT_LACPDU_UNKNOWN_RX,
 BOND_3AD_STAT_LACPDU_ILLEGAL_RX,
 BOND_3AD_STAT_MARKER_RX,
 BOND_3AD_STAT_MARKER_TX,
 BOND_3AD_STAT_MARKER_RESP_RX,
 BOND_3AD_STAT_MARKER_RESP_TX,
 BOND_3AD_STAT_MARKER_UNKNOWN_RX,
 BOND_3AD_STAT_PAD,
 __BOND_3AD_STAT_MAX
};
# 49 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h" 1





# 1 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h" 1
# 34 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
struct tc_stats {
 __u64 bytes;
 __u32 packets;
 __u32 drops;
 __u32 overlimits;

 __u32 bps;
 __u32 pps;
 __u32 qlen;
 __u32 backlog;
};

struct tc_estimator {
 signed char interval;
 unsigned char ewma_log;
};
# 84 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
enum tc_link_layer {
 TC_LINKLAYER_UNAWARE,
 TC_LINKLAYER_ETHERNET,
 TC_LINKLAYER_ATM,
};


struct tc_ratespec {
 unsigned char cell_log;
 __u8 linklayer;
 unsigned short overhead;
 short cell_align;
 unsigned short mpu;
 __u32 rate;
};



struct tc_sizespec {
 unsigned char cell_log;
 unsigned char size_log;
 short cell_align;
 int overhead;
 unsigned int linklayer;
 unsigned int mpu;
 unsigned int mtu;
 unsigned int tsize;
};

enum {
 TCA_STAB_UNSPEC,
 TCA_STAB_BASE,
 TCA_STAB_DATA,
 __TCA_STAB_MAX
};





struct tc_fifo_qopt {
 __u32 limit;
};
# 139 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
struct tc_skbprio_qopt {
 __u32 limit;
};






struct tc_prio_qopt {
 int bands;
 __u8 priomap[15 +1];
};



struct tc_multiq_qopt {
 __u16 bands;
 __u16 max_bands;
};
# 167 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
struct tc_plug_qopt {
# 177 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
 int action;
 __u32 limit;
};



struct tc_tbf_qopt {
 struct tc_ratespec rate;
 struct tc_ratespec peakrate;
 __u32 limit;
 __u32 buffer;
 __u32 mtu;
};

enum {
 TCA_TBF_UNSPEC,
 TCA_TBF_PARMS,
 TCA_TBF_RTAB,
 TCA_TBF_PTAB,
 TCA_TBF_RATE64,
 TCA_TBF_PRATE64,
 TCA_TBF_BURST,
 TCA_TBF_PBURST,
 TCA_TBF_PAD,
 __TCA_TBF_MAX,
};
# 213 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
struct tc_sfq_qopt {
 unsigned quantum;
 int perturb_period;
 __u32 limit;
 unsigned divisor;
 unsigned flows;
};

struct tc_sfqred_stats {
 __u32 prob_drop;
 __u32 forced_drop;
 __u32 prob_mark;
 __u32 forced_mark;
 __u32 prob_mark_head;
 __u32 forced_mark_head;
};

struct tc_sfq_qopt_v1 {
 struct tc_sfq_qopt v0;
 unsigned int depth;
 unsigned int headdrop;

 __u32 limit;
 __u32 qth_min;
 __u32 qth_max;
 unsigned char Wlog;
 unsigned char Plog;
 unsigned char Scell_log;
 unsigned char flags;
 __u32 max_P;

 struct tc_sfqred_stats stats;
};


struct tc_sfq_xstats {
 __s32 allot;
};



enum {
 TCA_RED_UNSPEC,
 TCA_RED_PARMS,
 TCA_RED_STAB,
 TCA_RED_MAX_P,
 __TCA_RED_MAX,
};



struct tc_red_qopt {
 __u32 limit;
 __u32 qth_min;
 __u32 qth_max;
 unsigned char Wlog;
 unsigned char Plog;
 unsigned char Scell_log;
 unsigned char flags;



};

struct tc_red_xstats {
 __u32 early;
 __u32 pdrop;
 __u32 other;
 __u32 marked;
};





enum {
       TCA_GRED_UNSPEC,
       TCA_GRED_PARMS,
       TCA_GRED_STAB,
       TCA_GRED_DPS,
       TCA_GRED_MAX_P,
       TCA_GRED_LIMIT,
       TCA_GRED_VQ_LIST,
       __TCA_GRED_MAX,
};



enum {
 TCA_GRED_VQ_ENTRY_UNSPEC,
 TCA_GRED_VQ_ENTRY,
 __TCA_GRED_VQ_ENTRY_MAX,
};


enum {
 TCA_GRED_VQ_UNSPEC,
 TCA_GRED_VQ_PAD,
 TCA_GRED_VQ_DP,
 TCA_GRED_VQ_STAT_BYTES,
 TCA_GRED_VQ_STAT_PACKETS,
 TCA_GRED_VQ_STAT_BACKLOG,
 TCA_GRED_VQ_STAT_PROB_DROP,
 TCA_GRED_VQ_STAT_PROB_MARK,
 TCA_GRED_VQ_STAT_FORCED_DROP,
 TCA_GRED_VQ_STAT_FORCED_MARK,
 TCA_GRED_VQ_STAT_PDROP,
 TCA_GRED_VQ_STAT_OTHER,
 TCA_GRED_VQ_FLAGS,
 __TCA_GRED_VQ_MAX
};



struct tc_gred_qopt {
 __u32 limit;
 __u32 qth_min;
 __u32 qth_max;
 __u32 DP;
 __u32 backlog;
 __u32 qave;
 __u32 forced;
 __u32 early;
 __u32 other;
 __u32 pdrop;
 __u8 Wlog;
 __u8 Plog;
 __u8 Scell_log;
 __u8 prio;
 __u32 packets;
 __u32 bytesin;
};


struct tc_gred_sopt {
 __u32 DPs;
 __u32 def_DP;
 __u8 grio;
 __u8 flags;
 __u16 pad1;
};



enum {
 TCA_CHOKE_UNSPEC,
 TCA_CHOKE_PARMS,
 TCA_CHOKE_STAB,
 TCA_CHOKE_MAX_P,
 __TCA_CHOKE_MAX,
};



struct tc_choke_qopt {
 __u32 limit;
 __u32 qth_min;
 __u32 qth_max;
 unsigned char Wlog;
 unsigned char Plog;
 unsigned char Scell_log;
 unsigned char flags;
};

struct tc_choke_xstats {
 __u32 early;
 __u32 pdrop;
 __u32 other;
 __u32 marked;
 __u32 matched;
};






struct tc_htb_opt {
 struct tc_ratespec rate;
 struct tc_ratespec ceil;
 __u32 buffer;
 __u32 cbuffer;
 __u32 quantum;
 __u32 level;
 __u32 prio;
};
struct tc_htb_glob {
 __u32 version;
     __u32 rate2quantum;
     __u32 defcls;
 __u32 debug;


 __u32 direct_pkts;
};
enum {
 TCA_HTB_UNSPEC,
 TCA_HTB_PARMS,
 TCA_HTB_INIT,
 TCA_HTB_CTAB,
 TCA_HTB_RTAB,
 TCA_HTB_DIRECT_QLEN,
 TCA_HTB_RATE64,
 TCA_HTB_CEIL64,
 TCA_HTB_PAD,
 __TCA_HTB_MAX,
};



struct tc_htb_xstats {
 __u32 lends;
 __u32 borrows;
 __u32 giants;
 __s32 tokens;
 __s32 ctokens;
};



struct tc_hfsc_qopt {
 __u16 defcls;
};

struct tc_service_curve {
 __u32 m1;
 __u32 d;
 __u32 m2;
};

struct tc_hfsc_stats {
 __u64 work;
 __u64 rtwork;
 __u32 period;
 __u32 level;
};

enum {
 TCA_HFSC_UNSPEC,
 TCA_HFSC_RSC,
 TCA_HFSC_FSC,
 TCA_HFSC_USC,
 __TCA_HFSC_MAX,
};
# 467 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
struct tc_cbq_lssopt {
 unsigned char change;
 unsigned char flags;


 unsigned char ewma_log;
 unsigned char level;






 __u32 maxidle;
 __u32 minidle;
 __u32 offtime;
 __u32 avpkt;
};

struct tc_cbq_wrropt {
 unsigned char flags;
 unsigned char priority;
 unsigned char cpriority;
 unsigned char __reserved;
 __u32 allot;
 __u32 weight;
};

struct tc_cbq_ovl {
 unsigned char strategy;





 unsigned char priority2;
 __u16 pad;
 __u32 penalty;
};

struct tc_cbq_police {
 unsigned char police;
 unsigned char __res1;
 unsigned short __res2;
};

struct tc_cbq_fopt {
 __u32 split;
 __u32 defmap;
 __u32 defchange;
};

struct tc_cbq_xstats {
 __u32 borrows;
 __u32 overactions;
 __s32 avgidle;
 __s32 undertime;
};

enum {
 TCA_CBQ_UNSPEC,
 TCA_CBQ_LSSOPT,
 TCA_CBQ_WRROPT,
 TCA_CBQ_FOPT,
 TCA_CBQ_OVL_STRATEGY,
 TCA_CBQ_RATE,
 TCA_CBQ_RTAB,
 TCA_CBQ_POLICE,
 __TCA_CBQ_MAX,
};





enum {
 TCA_DSMARK_UNSPEC,
 TCA_DSMARK_INDICES,
 TCA_DSMARK_DEFAULT_INDEX,
 TCA_DSMARK_SET_TC_INDEX,
 TCA_DSMARK_MASK,
 TCA_DSMARK_VALUE,
 __TCA_DSMARK_MAX,
};





enum {
 TCA_ATM_UNSPEC,
 TCA_ATM_FD,
 TCA_ATM_PTR,
 TCA_ATM_HDR,
 TCA_ATM_EXCESS,
 TCA_ATM_ADDR,
 TCA_ATM_STATE,
 __TCA_ATM_MAX,
};





enum {
 TCA_NETEM_UNSPEC,
 TCA_NETEM_CORR,
 TCA_NETEM_DELAY_DIST,
 TCA_NETEM_REORDER,
 TCA_NETEM_CORRUPT,
 TCA_NETEM_LOSS,
 TCA_NETEM_RATE,
 TCA_NETEM_ECN,
 TCA_NETEM_RATE64,
 TCA_NETEM_PAD,
 TCA_NETEM_LATENCY64,
 TCA_NETEM_JITTER64,
 TCA_NETEM_SLOT,
 TCA_NETEM_SLOT_DIST,
 __TCA_NETEM_MAX,
};



struct tc_netem_qopt {
 __u32 latency;
 __u32 limit;
 __u32 loss;
 __u32 gap;
 __u32 duplicate;
 __u32 jitter;
};

struct tc_netem_corr {
 __u32 delay_corr;
 __u32 loss_corr;
 __u32 dup_corr;
};

struct tc_netem_reorder {
 __u32 probability;
 __u32 correlation;
};

struct tc_netem_corrupt {
 __u32 probability;
 __u32 correlation;
};

struct tc_netem_rate {
 __u32 rate;
 __s32 packet_overhead;
 __u32 cell_size;
 __s32 cell_overhead;
};

struct tc_netem_slot {
 __s64 min_delay;
 __s64 max_delay;
 __s32 max_packets;
 __s32 max_bytes;
 __s64 dist_delay;
 __s64 dist_jitter;
};

enum {
 NETEM_LOSS_UNSPEC,
 NETEM_LOSS_GI,
 NETEM_LOSS_GE,
 __NETEM_LOSS_MAX
};



struct tc_netem_gimodel {
 __u32 p13;
 __u32 p31;
 __u32 p32;
 __u32 p14;
 __u32 p23;
};


struct tc_netem_gemodel {
 __u32 p;
 __u32 r;
 __u32 h;
 __u32 k1;
};






enum {
 TCA_DRR_UNSPEC,
 TCA_DRR_QUANTUM,
 __TCA_DRR_MAX
};



struct tc_drr_stats {
 __u32 deficit;
};





enum {
 TC_MQPRIO_HW_OFFLOAD_NONE,
 TC_MQPRIO_HW_OFFLOAD_TCS,
 __TC_MQPRIO_HW_OFFLOAD_MAX
};



enum {
 TC_MQPRIO_MODE_DCB,
 TC_MQPRIO_MODE_CHANNEL,
 __TC_MQPRIO_MODE_MAX
};



enum {
 TC_MQPRIO_SHAPER_DCB,
 TC_MQPRIO_SHAPER_BW_RATE,
 __TC_MQPRIO_SHAPER_MAX
};



struct tc_mqprio_qopt {
 __u8 num_tc;
 __u8 prio_tc_map[15 + 1];
 __u8 hw;
 __u16 count[16];
 __u16 offset[16];
};






enum {
 TCA_MQPRIO_UNSPEC,
 TCA_MQPRIO_MODE,
 TCA_MQPRIO_SHAPER,
 TCA_MQPRIO_MIN_RATE64,
 TCA_MQPRIO_MAX_RATE64,
 __TCA_MQPRIO_MAX,
};





enum {
 TCA_SFB_UNSPEC,
 TCA_SFB_PARMS,
 __TCA_SFB_MAX,
};






struct tc_sfb_qopt {
 __u32 rehash_interval;
 __u32 warmup_time;
 __u32 max;
 __u32 bin_size;
 __u32 increment;
 __u32 decrement;
 __u32 limit;
 __u32 penalty_rate;
 __u32 penalty_burst;
};

struct tc_sfb_xstats {
 __u32 earlydrop;
 __u32 penaltydrop;
 __u32 bucketdrop;
 __u32 queuedrop;
 __u32 childdrop;
 __u32 marked;
 __u32 maxqlen;
 __u32 maxprob;
 __u32 avgprob;
};




enum {
 TCA_QFQ_UNSPEC,
 TCA_QFQ_WEIGHT,
 TCA_QFQ_LMAX,
 __TCA_QFQ_MAX
};



struct tc_qfq_stats {
 __u32 weight;
 __u32 lmax;
};



enum {
 TCA_CODEL_UNSPEC,
 TCA_CODEL_TARGET,
 TCA_CODEL_LIMIT,
 TCA_CODEL_INTERVAL,
 TCA_CODEL_ECN,
 TCA_CODEL_CE_THRESHOLD,
 __TCA_CODEL_MAX
};



struct tc_codel_xstats {
 __u32 maxpacket;
 __u32 count;


 __u32 lastcount;
 __u32 ldelay;
 __s32 drop_next;
 __u32 drop_overlimit;
 __u32 ecn_mark;
 __u32 dropping;
 __u32 ce_mark;
};



enum {
 TCA_FQ_CODEL_UNSPEC,
 TCA_FQ_CODEL_TARGET,
 TCA_FQ_CODEL_LIMIT,
 TCA_FQ_CODEL_INTERVAL,
 TCA_FQ_CODEL_ECN,
 TCA_FQ_CODEL_FLOWS,
 TCA_FQ_CODEL_QUANTUM,
 TCA_FQ_CODEL_CE_THRESHOLD,
 TCA_FQ_CODEL_DROP_BATCH_SIZE,
 TCA_FQ_CODEL_MEMORY_LIMIT,
 __TCA_FQ_CODEL_MAX
};



enum {
 TCA_FQ_CODEL_XSTATS_QDISC,
 TCA_FQ_CODEL_XSTATS_CLASS,
};

struct tc_fq_codel_qd_stats {
 __u32 maxpacket;
 __u32 drop_overlimit;


 __u32 ecn_mark;


 __u32 new_flow_count;


 __u32 new_flows_len;
 __u32 old_flows_len;
 __u32 ce_mark;
 __u32 memory_usage;
 __u32 drop_overmemory;
};

struct tc_fq_codel_cl_stats {
 __s32 deficit;
 __u32 ldelay;


 __u32 count;
 __u32 lastcount;
 __u32 dropping;
 __s32 drop_next;
};

struct tc_fq_codel_xstats {
 __u32 type;
 union {
  struct tc_fq_codel_qd_stats qdisc_stats;
  struct tc_fq_codel_cl_stats class_stats;
 };
};



enum {
 TCA_FQ_UNSPEC,

 TCA_FQ_PLIMIT,

 TCA_FQ_FLOW_PLIMIT,

 TCA_FQ_QUANTUM,

 TCA_FQ_INITIAL_QUANTUM,

 TCA_FQ_RATE_ENABLE,

 TCA_FQ_FLOW_DEFAULT_RATE,

 TCA_FQ_FLOW_MAX_RATE,

 TCA_FQ_BUCKETS_LOG,

 TCA_FQ_FLOW_REFILL_DELAY,

 TCA_FQ_ORPHAN_MASK,

 TCA_FQ_LOW_RATE_THRESHOLD,

 TCA_FQ_CE_THRESHOLD,

 __TCA_FQ_MAX
};



struct tc_fq_qd_stats {
 __u64 gc_flows;
 __u64 highprio_packets;
 __u64 tcp_retrans;
 __u64 throttled;
 __u64 flows_plimit;
 __u64 pkts_too_long;
 __u64 allocation_errors;
 __s64 time_next_delayed_flow;
 __u32 flows;
 __u32 inactive_flows;
 __u32 throttled_flows;
 __u32 unthrottle_latency_ns;
 __u64 ce_mark;
};



enum {
 TCA_HHF_UNSPEC,
 TCA_HHF_BACKLOG_LIMIT,
 TCA_HHF_QUANTUM,
 TCA_HHF_HH_FLOWS_LIMIT,
 TCA_HHF_RESET_TIMEOUT,
 TCA_HHF_ADMIT_BYTES,
 TCA_HHF_EVICT_TIMEOUT,
 TCA_HHF_NON_HH_WEIGHT,
 __TCA_HHF_MAX
};



struct tc_hhf_xstats {
 __u32 drop_overlimit;


 __u32 hh_overlimit;
 __u32 hh_tot_count;
 __u32 hh_cur_count;
};


enum {
 TCA_PIE_UNSPEC,
 TCA_PIE_TARGET,
 TCA_PIE_LIMIT,
 TCA_PIE_TUPDATE,
 TCA_PIE_ALPHA,
 TCA_PIE_BETA,
 TCA_PIE_ECN,
 TCA_PIE_BYTEMODE,
 TCA_PIE_DQ_RATE_ESTIMATOR,
 __TCA_PIE_MAX
};


struct tc_pie_xstats {
 __u64 prob;
 __u32 delay;
 __u32 avg_dq_rate;


 __u32 dq_rate_estimating;
 __u32 packets_in;
 __u32 dropped;
 __u32 overlimit;


 __u32 maxq;
 __u32 ecn_mark;
};


enum {
 TCA_FQ_PIE_UNSPEC,
 TCA_FQ_PIE_LIMIT,
 TCA_FQ_PIE_FLOWS,
 TCA_FQ_PIE_TARGET,
 TCA_FQ_PIE_TUPDATE,
 TCA_FQ_PIE_ALPHA,
 TCA_FQ_PIE_BETA,
 TCA_FQ_PIE_QUANTUM,
 TCA_FQ_PIE_MEMORY_LIMIT,
 TCA_FQ_PIE_ECN_PROB,
 TCA_FQ_PIE_ECN,
 TCA_FQ_PIE_BYTEMODE,
 TCA_FQ_PIE_DQ_RATE_ESTIMATOR,
 __TCA_FQ_PIE_MAX
};


struct tc_fq_pie_xstats {
 __u32 packets_in;
 __u32 dropped;
 __u32 overlimit;
 __u32 overmemory;
 __u32 ecn_mark;
 __u32 new_flow_count;
 __u32 new_flows_len;
 __u32 old_flows_len;
 __u32 memory_usage;
};


struct tc_cbs_qopt {
 __u8 offload;
 __u8 _pad[3];
 __s32 hicredit;
 __s32 locredit;
 __s32 idleslope;
 __s32 sendslope;
};

enum {
 TCA_CBS_UNSPEC,
 TCA_CBS_PARMS,
 __TCA_CBS_MAX,
};





struct tc_etf_qopt {
 __s32 delta;
 __s32 clockid;
 __u32 flags;



};

enum {
 TCA_ETF_UNSPEC,
 TCA_ETF_PARMS,
 __TCA_ETF_MAX,
};





enum {
 TCA_CAKE_UNSPEC,
 TCA_CAKE_PAD,
 TCA_CAKE_BASE_RATE64,
 TCA_CAKE_DIFFSERV_MODE,
 TCA_CAKE_ATM,
 TCA_CAKE_FLOW_MODE,
 TCA_CAKE_OVERHEAD,
 TCA_CAKE_RTT,
 TCA_CAKE_TARGET,
 TCA_CAKE_AUTORATE,
 TCA_CAKE_MEMORY,
 TCA_CAKE_NAT,
 TCA_CAKE_RAW,
 TCA_CAKE_WASH,
 TCA_CAKE_MPU,
 TCA_CAKE_INGRESS,
 TCA_CAKE_ACK_FILTER,
 TCA_CAKE_SPLIT_GSO,
 TCA_CAKE_FWMARK,
 __TCA_CAKE_MAX
};


enum {
 __TCA_CAKE_STATS_INVALID,
 TCA_CAKE_STATS_PAD,
 TCA_CAKE_STATS_CAPACITY_ESTIMATE64,
 TCA_CAKE_STATS_MEMORY_LIMIT,
 TCA_CAKE_STATS_MEMORY_USED,
 TCA_CAKE_STATS_AVG_NETOFF,
 TCA_CAKE_STATS_MIN_NETLEN,
 TCA_CAKE_STATS_MAX_NETLEN,
 TCA_CAKE_STATS_MIN_ADJLEN,
 TCA_CAKE_STATS_MAX_ADJLEN,
 TCA_CAKE_STATS_TIN_STATS,
 TCA_CAKE_STATS_DEFICIT,
 TCA_CAKE_STATS_COBALT_COUNT,
 TCA_CAKE_STATS_DROPPING,
 TCA_CAKE_STATS_DROP_NEXT_US,
 TCA_CAKE_STATS_P_DROP,
 TCA_CAKE_STATS_BLUE_TIMER_US,
 __TCA_CAKE_STATS_MAX
};


enum {
 __TCA_CAKE_TIN_STATS_INVALID,
 TCA_CAKE_TIN_STATS_PAD,
 TCA_CAKE_TIN_STATS_SENT_PACKETS,
 TCA_CAKE_TIN_STATS_SENT_BYTES64,
 TCA_CAKE_TIN_STATS_DROPPED_PACKETS,
 TCA_CAKE_TIN_STATS_DROPPED_BYTES64,
 TCA_CAKE_TIN_STATS_ACKS_DROPPED_PACKETS,
 TCA_CAKE_TIN_STATS_ACKS_DROPPED_BYTES64,
 TCA_CAKE_TIN_STATS_ECN_MARKED_PACKETS,
 TCA_CAKE_TIN_STATS_ECN_MARKED_BYTES64,
 TCA_CAKE_TIN_STATS_BACKLOG_PACKETS,
 TCA_CAKE_TIN_STATS_BACKLOG_BYTES,
 TCA_CAKE_TIN_STATS_THRESHOLD_RATE64,
 TCA_CAKE_TIN_STATS_TARGET_US,
 TCA_CAKE_TIN_STATS_INTERVAL_US,
 TCA_CAKE_TIN_STATS_WAY_INDIRECT_HITS,
 TCA_CAKE_TIN_STATS_WAY_MISSES,
 TCA_CAKE_TIN_STATS_WAY_COLLISIONS,
 TCA_CAKE_TIN_STATS_PEAK_DELAY_US,
 TCA_CAKE_TIN_STATS_AVG_DELAY_US,
 TCA_CAKE_TIN_STATS_BASE_DELAY_US,
 TCA_CAKE_TIN_STATS_SPARSE_FLOWS,
 TCA_CAKE_TIN_STATS_BULK_FLOWS,
 TCA_CAKE_TIN_STATS_UNRESPONSIVE_FLOWS,
 TCA_CAKE_TIN_STATS_MAX_SKBLEN,
 TCA_CAKE_TIN_STATS_FLOW_QUANTUM,
 __TCA_CAKE_TIN_STATS_MAX
};



enum {
 CAKE_FLOW_NONE = 0,
 CAKE_FLOW_SRC_IP,
 CAKE_FLOW_DST_IP,
 CAKE_FLOW_HOSTS,
 CAKE_FLOW_FLOWS,
 CAKE_FLOW_DUAL_SRC,
 CAKE_FLOW_DUAL_DST,
 CAKE_FLOW_TRIPLE,
 CAKE_FLOW_MAX,
};

enum {
 CAKE_DIFFSERV_DIFFSERV3 = 0,
 CAKE_DIFFSERV_DIFFSERV4,
 CAKE_DIFFSERV_DIFFSERV8,
 CAKE_DIFFSERV_BESTEFFORT,
 CAKE_DIFFSERV_PRECEDENCE,
 CAKE_DIFFSERV_MAX
};

enum {
 CAKE_ACK_NONE = 0,
 CAKE_ACK_FILTER,
 CAKE_ACK_AGGRESSIVE,
 CAKE_ACK_MAX
};

enum {
 CAKE_ATM_NONE = 0,
 CAKE_ATM_ATM,
 CAKE_ATM_PTM,
 CAKE_ATM_MAX
};



enum {
 TC_TAPRIO_CMD_SET_GATES = 0x00,
 TC_TAPRIO_CMD_SET_AND_HOLD = 0x01,
 TC_TAPRIO_CMD_SET_AND_RELEASE = 0x02,
};

enum {
 TCA_TAPRIO_SCHED_ENTRY_UNSPEC,
 TCA_TAPRIO_SCHED_ENTRY_INDEX,
 TCA_TAPRIO_SCHED_ENTRY_CMD,
 TCA_TAPRIO_SCHED_ENTRY_GATE_MASK,
 TCA_TAPRIO_SCHED_ENTRY_INTERVAL,
 __TCA_TAPRIO_SCHED_ENTRY_MAX,
};
# 1182 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
enum {
 TCA_TAPRIO_SCHED_UNSPEC,
 TCA_TAPRIO_SCHED_ENTRY,
 __TCA_TAPRIO_SCHED_MAX,
};
# 1203 "/home/nathan/src/linux-next/include/uapi/linux/pkt_sched.h"
enum {
 TCA_TAPRIO_ATTR_UNSPEC,
 TCA_TAPRIO_ATTR_PRIOMAP,
 TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST,
 TCA_TAPRIO_ATTR_SCHED_BASE_TIME,
 TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY,
 TCA_TAPRIO_ATTR_SCHED_CLOCKID,
 TCA_TAPRIO_PAD,
 TCA_TAPRIO_ATTR_ADMIN_SCHED,
 TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME,
 TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION,
 TCA_TAPRIO_ATTR_FLAGS,
 TCA_TAPRIO_ATTR_TXTIME_DELAY,
 __TCA_TAPRIO_ATTR_MAX,
};







enum {
 TCA_ETS_UNSPEC,
 TCA_ETS_NBANDS,
 TCA_ETS_NSTRICT,
 TCA_ETS_QUANTA,
 TCA_ETS_QUANTA_BAND,
 TCA_ETS_PRIOMAP,
 TCA_ETS_PRIOMAP_BAND,
 __TCA_ETS_MAX,
};
# 7 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h" 2




enum {
 TCA_ACT_UNSPEC,
 TCA_ACT_KIND,
 TCA_ACT_OPTIONS,
 TCA_ACT_INDEX,
 TCA_ACT_STATS,
 TCA_ACT_PAD,
 TCA_ACT_COOKIE,
 TCA_ACT_FLAGS,
 __TCA_ACT_MAX
};
# 93 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum tca_id {
 TCA_ID_UNSPEC = 0,
 TCA_ID_POLICE = 1,
 TCA_ID_GACT = 5,
 TCA_ID_IPT = 6,
 TCA_ID_PEDIT = 7,
 TCA_ID_MIRRED = 8,
 TCA_ID_NAT = 9,
 TCA_ID_XT = 10,
 TCA_ID_SKBEDIT = 11,
 TCA_ID_VLAN = 12,
 TCA_ID_BPF = 13,
 TCA_ID_CONNMARK = 14,
 TCA_ID_SKBMOD = 15,
 TCA_ID_CSUM = 16,
 TCA_ID_TUNNEL_KEY = 17,
 TCA_ID_SIMP = 22,
 TCA_ID_IFE = 25,
 TCA_ID_SAMPLE = 26,
 TCA_ID_CTINFO,
 TCA_ID_MPLS,
 TCA_ID_CT,

 __TCA_ID_MAX = 255
};



struct tc_police {
 __u32 index;
 int action;






 __u32 limit;
 __u32 burst;
 __u32 mtu;
 struct tc_ratespec rate;
 struct tc_ratespec peakrate;
 int refcnt;
 int bindcnt;
 __u32 capab;
};

struct tcf_t {
 __u64 install;
 __u64 lastuse;
 __u64 expires;
 __u64 firstuse;
};

struct tc_cnt {
 int refcnt;
 int bindcnt;
};
# 159 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum {
 TCA_POLICE_UNSPEC,
 TCA_POLICE_TBF,
 TCA_POLICE_RATE,
 TCA_POLICE_PEAKRATE,
 TCA_POLICE_AVRATE,
 TCA_POLICE_RESULT,
 TCA_POLICE_TM,
 TCA_POLICE_PAD,
 TCA_POLICE_RATE64,
 TCA_POLICE_PEAKRATE64,
 __TCA_POLICE_MAX

};
# 193 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum {
 TCA_U32_UNSPEC,
 TCA_U32_CLASSID,
 TCA_U32_HASH,
 TCA_U32_LINK,
 TCA_U32_DIVISOR,
 TCA_U32_SEL,
 TCA_U32_POLICE,
 TCA_U32_ACT,
 TCA_U32_INDEV,
 TCA_U32_PCNT,
 TCA_U32_MARK,
 TCA_U32_FLAGS,
 TCA_U32_PAD,
 __TCA_U32_MAX
};



struct tc_u32_key {
 __be32 mask;
 __be32 val;
 int off;
 int offmask;
};

struct tc_u32_sel {
 unsigned char flags;
 unsigned char offshift;
 unsigned char nkeys;

 __be16 offmask;
 __u16 off;
 short offoff;

 short hoff;
 __be32 hmask;
 struct tc_u32_key keys[0];
};

struct tc_u32_mark {
 __u32 val;
 __u32 mask;
 __u32 success;
};

struct tc_u32_pcnt {
 __u64 rcnt;
 __u64 rhit;
 __u64 kcnts[0];
};
# 257 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum {
 TCA_RSVP_UNSPEC,
 TCA_RSVP_CLASSID,
 TCA_RSVP_DST,
 TCA_RSVP_SRC,
 TCA_RSVP_PINFO,
 TCA_RSVP_POLICE,
 TCA_RSVP_ACT,
 __TCA_RSVP_MAX
};



struct tc_rsvp_gpi {
 __u32 key;
 __u32 mask;
 int offset;
};

struct tc_rsvp_pinfo {
 struct tc_rsvp_gpi dpi;
 struct tc_rsvp_gpi spi;
 __u8 protocol;
 __u8 tunnelid;
 __u8 tunnelhdr;
 __u8 pad;
};



enum {
 TCA_ROUTE4_UNSPEC,
 TCA_ROUTE4_CLASSID,
 TCA_ROUTE4_TO,
 TCA_ROUTE4_FROM,
 TCA_ROUTE4_IIF,
 TCA_ROUTE4_POLICE,
 TCA_ROUTE4_ACT,
 __TCA_ROUTE4_MAX
};






enum {
 TCA_FW_UNSPEC,
 TCA_FW_CLASSID,
 TCA_FW_POLICE,
 TCA_FW_INDEV,
 TCA_FW_ACT,
 TCA_FW_MASK,
 __TCA_FW_MAX
};





enum {
 TCA_TCINDEX_UNSPEC,
 TCA_TCINDEX_HASH,
 TCA_TCINDEX_MASK,
 TCA_TCINDEX_SHIFT,
 TCA_TCINDEX_FALL_THROUGH,
 TCA_TCINDEX_CLASSID,
 TCA_TCINDEX_POLICE,
 TCA_TCINDEX_ACT,
 __TCA_TCINDEX_MAX
};





enum {
 FLOW_KEY_SRC,
 FLOW_KEY_DST,
 FLOW_KEY_PROTO,
 FLOW_KEY_PROTO_SRC,
 FLOW_KEY_PROTO_DST,
 FLOW_KEY_IIF,
 FLOW_KEY_PRIORITY,
 FLOW_KEY_MARK,
 FLOW_KEY_NFCT,
 FLOW_KEY_NFCT_SRC,
 FLOW_KEY_NFCT_DST,
 FLOW_KEY_NFCT_PROTO_SRC,
 FLOW_KEY_NFCT_PROTO_DST,
 FLOW_KEY_RTCLASSID,
 FLOW_KEY_SKUID,
 FLOW_KEY_SKGID,
 FLOW_KEY_VLAN_TAG,
 FLOW_KEY_RXHASH,
 __FLOW_KEY_MAX,
};



enum {
 FLOW_MODE_MAP,
 FLOW_MODE_HASH,
};

enum {
 TCA_FLOW_UNSPEC,
 TCA_FLOW_KEYS,
 TCA_FLOW_MODE,
 TCA_FLOW_BASECLASS,
 TCA_FLOW_RSHIFT,
 TCA_FLOW_ADDEND,
 TCA_FLOW_MASK,
 TCA_FLOW_XOR,
 TCA_FLOW_DIVISOR,
 TCA_FLOW_ACT,
 TCA_FLOW_POLICE,
 TCA_FLOW_EMATCHES,
 TCA_FLOW_PERTURB,
 __TCA_FLOW_MAX
};





struct tc_basic_pcnt {
 __u64 rcnt;
 __u64 rhit;
};

enum {
 TCA_BASIC_UNSPEC,
 TCA_BASIC_CLASSID,
 TCA_BASIC_EMATCHES,
 TCA_BASIC_ACT,
 TCA_BASIC_POLICE,
 TCA_BASIC_PCNT,
 TCA_BASIC_PAD,
 __TCA_BASIC_MAX
};






enum {
 TCA_CGROUP_UNSPEC,
 TCA_CGROUP_ACT,
 TCA_CGROUP_POLICE,
 TCA_CGROUP_EMATCHES,
 __TCA_CGROUP_MAX,
};







enum {
 TCA_BPF_UNSPEC,
 TCA_BPF_ACT,
 TCA_BPF_POLICE,
 TCA_BPF_CLASSID,
 TCA_BPF_OPS_LEN,
 TCA_BPF_OPS,
 TCA_BPF_FD,
 TCA_BPF_NAME,
 TCA_BPF_FLAGS,
 TCA_BPF_FLAGS_GEN,
 TCA_BPF_TAG,
 TCA_BPF_ID,
 __TCA_BPF_MAX,
};





enum {
 TCA_FLOWER_UNSPEC,
 TCA_FLOWER_CLASSID,
 TCA_FLOWER_INDEV,
 TCA_FLOWER_ACT,
 TCA_FLOWER_KEY_ETH_DST,
 TCA_FLOWER_KEY_ETH_DST_MASK,
 TCA_FLOWER_KEY_ETH_SRC,
 TCA_FLOWER_KEY_ETH_SRC_MASK,
 TCA_FLOWER_KEY_ETH_TYPE,
 TCA_FLOWER_KEY_IP_PROTO,
 TCA_FLOWER_KEY_IPV4_SRC,
 TCA_FLOWER_KEY_IPV4_SRC_MASK,
 TCA_FLOWER_KEY_IPV4_DST,
 TCA_FLOWER_KEY_IPV4_DST_MASK,
 TCA_FLOWER_KEY_IPV6_SRC,
 TCA_FLOWER_KEY_IPV6_SRC_MASK,
 TCA_FLOWER_KEY_IPV6_DST,
 TCA_FLOWER_KEY_IPV6_DST_MASK,
 TCA_FLOWER_KEY_TCP_SRC,
 TCA_FLOWER_KEY_TCP_DST,
 TCA_FLOWER_KEY_UDP_SRC,
 TCA_FLOWER_KEY_UDP_DST,

 TCA_FLOWER_FLAGS,
 TCA_FLOWER_KEY_VLAN_ID,
 TCA_FLOWER_KEY_VLAN_PRIO,
 TCA_FLOWER_KEY_VLAN_ETH_TYPE,

 TCA_FLOWER_KEY_ENC_KEY_ID,
 TCA_FLOWER_KEY_ENC_IPV4_SRC,
 TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK,
 TCA_FLOWER_KEY_ENC_IPV4_DST,
 TCA_FLOWER_KEY_ENC_IPV4_DST_MASK,
 TCA_FLOWER_KEY_ENC_IPV6_SRC,
 TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK,
 TCA_FLOWER_KEY_ENC_IPV6_DST,
 TCA_FLOWER_KEY_ENC_IPV6_DST_MASK,

 TCA_FLOWER_KEY_TCP_SRC_MASK,
 TCA_FLOWER_KEY_TCP_DST_MASK,
 TCA_FLOWER_KEY_UDP_SRC_MASK,
 TCA_FLOWER_KEY_UDP_DST_MASK,
 TCA_FLOWER_KEY_SCTP_SRC_MASK,
 TCA_FLOWER_KEY_SCTP_DST_MASK,

 TCA_FLOWER_KEY_SCTP_SRC,
 TCA_FLOWER_KEY_SCTP_DST,

 TCA_FLOWER_KEY_ENC_UDP_SRC_PORT,
 TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK,
 TCA_FLOWER_KEY_ENC_UDP_DST_PORT,
 TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK,

 TCA_FLOWER_KEY_FLAGS,
 TCA_FLOWER_KEY_FLAGS_MASK,

 TCA_FLOWER_KEY_ICMPV4_CODE,
 TCA_FLOWER_KEY_ICMPV4_CODE_MASK,
 TCA_FLOWER_KEY_ICMPV4_TYPE,
 TCA_FLOWER_KEY_ICMPV4_TYPE_MASK,
 TCA_FLOWER_KEY_ICMPV6_CODE,
 TCA_FLOWER_KEY_ICMPV6_CODE_MASK,
 TCA_FLOWER_KEY_ICMPV6_TYPE,
 TCA_FLOWER_KEY_ICMPV6_TYPE_MASK,

 TCA_FLOWER_KEY_ARP_SIP,
 TCA_FLOWER_KEY_ARP_SIP_MASK,
 TCA_FLOWER_KEY_ARP_TIP,
 TCA_FLOWER_KEY_ARP_TIP_MASK,
 TCA_FLOWER_KEY_ARP_OP,
 TCA_FLOWER_KEY_ARP_OP_MASK,
 TCA_FLOWER_KEY_ARP_SHA,
 TCA_FLOWER_KEY_ARP_SHA_MASK,
 TCA_FLOWER_KEY_ARP_THA,
 TCA_FLOWER_KEY_ARP_THA_MASK,

 TCA_FLOWER_KEY_MPLS_TTL,
 TCA_FLOWER_KEY_MPLS_BOS,
 TCA_FLOWER_KEY_MPLS_TC,
 TCA_FLOWER_KEY_MPLS_LABEL,

 TCA_FLOWER_KEY_TCP_FLAGS,
 TCA_FLOWER_KEY_TCP_FLAGS_MASK,

 TCA_FLOWER_KEY_IP_TOS,
 TCA_FLOWER_KEY_IP_TOS_MASK,
 TCA_FLOWER_KEY_IP_TTL,
 TCA_FLOWER_KEY_IP_TTL_MASK,

 TCA_FLOWER_KEY_CVLAN_ID,
 TCA_FLOWER_KEY_CVLAN_PRIO,
 TCA_FLOWER_KEY_CVLAN_ETH_TYPE,

 TCA_FLOWER_KEY_ENC_IP_TOS,
 TCA_FLOWER_KEY_ENC_IP_TOS_MASK,
 TCA_FLOWER_KEY_ENC_IP_TTL,
 TCA_FLOWER_KEY_ENC_IP_TTL_MASK,

 TCA_FLOWER_KEY_ENC_OPTS,
 TCA_FLOWER_KEY_ENC_OPTS_MASK,

 TCA_FLOWER_IN_HW_COUNT,

 TCA_FLOWER_KEY_PORT_SRC_MIN,
 TCA_FLOWER_KEY_PORT_SRC_MAX,
 TCA_FLOWER_KEY_PORT_DST_MIN,
 TCA_FLOWER_KEY_PORT_DST_MAX,

 TCA_FLOWER_KEY_CT_STATE,
 TCA_FLOWER_KEY_CT_STATE_MASK,
 TCA_FLOWER_KEY_CT_ZONE,
 TCA_FLOWER_KEY_CT_ZONE_MASK,
 TCA_FLOWER_KEY_CT_MARK,
 TCA_FLOWER_KEY_CT_MARK_MASK,
 TCA_FLOWER_KEY_CT_LABELS,
 TCA_FLOWER_KEY_CT_LABELS_MASK,

 __TCA_FLOWER_MAX,
};



enum {
 TCA_FLOWER_KEY_CT_FLAGS_NEW = 1 << 0,
 TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 1 << 1,
 TCA_FLOWER_KEY_CT_FLAGS_RELATED = 1 << 2,
 TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 1 << 3,
};

enum {
 TCA_FLOWER_KEY_ENC_OPTS_UNSPEC,
 TCA_FLOWER_KEY_ENC_OPTS_GENEVE,



 TCA_FLOWER_KEY_ENC_OPTS_VXLAN,



 TCA_FLOWER_KEY_ENC_OPTS_ERSPAN,



 __TCA_FLOWER_KEY_ENC_OPTS_MAX,
};



enum {
 TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC,
 TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS,
 TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE,
 TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA,

 __TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,
};




enum {
 TCA_FLOWER_KEY_ENC_OPT_VXLAN_UNSPEC,
 TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP,
 __TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX,
};




enum {
 TCA_FLOWER_KEY_ENC_OPT_ERSPAN_UNSPEC,
 TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER,
 TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX,
 TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR,
 TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID,
 __TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX,
};




enum {
 TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = (1 << 0),
 TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = (1 << 1),
};





struct tc_matchall_pcnt {
 __u64 rhit;
};

enum {
 TCA_MATCHALL_UNSPEC,
 TCA_MATCHALL_CLASSID,
 TCA_MATCHALL_ACT,
 TCA_MATCHALL_FLAGS,
 TCA_MATCHALL_PCNT,
 TCA_MATCHALL_PAD,
 __TCA_MATCHALL_MAX,
};





struct tcf_ematch_tree_hdr {
 __u16 nmatches;
 __u16 progid;
};

enum {
 TCA_EMATCH_TREE_UNSPEC,
 TCA_EMATCH_TREE_HDR,
 TCA_EMATCH_TREE_LIST,
 __TCA_EMATCH_TREE_MAX
};


struct tcf_ematch_hdr {
 __u16 matchid;
 __u16 kind;
 __u16 flags;
 __u16 pad;
};
# 690 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum {
 TCF_LAYER_LINK,
 TCF_LAYER_NETWORK,
 TCF_LAYER_TRANSPORT,
 __TCF_LAYER_MAX
};
# 714 "/home/nathan/src/linux-next/include/uapi/linux/pkt_cls.h"
enum {
 TCF_EM_PROG_TC
};

enum {
 TCF_EM_OPND_EQ,
 TCF_EM_OPND_GT,
 TCF_EM_OPND_LT
};
# 50 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/hashtable.h" 1
# 34 "/home/nathan/src/linux-next/include/linux/hashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __hash_init(struct hlist_head *ht, unsigned int sz)
{
 unsigned int i;

 for (i = 0; i < sz; i++)
  ((&ht[i])->first = ((void *)0));
}
# 76 "/home/nathan/src/linux-next/include/linux/hashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hash_hashed(struct hlist_node *node)
{
 return !hlist_unhashed(node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __hash_empty(struct hlist_head *ht, unsigned int sz)
{
 unsigned int i;

 for (i = 0; i < sz; i++)
  if (!hlist_empty(&ht[i]))
   return false;

 return true;
}
# 105 "/home/nathan/src/linux-next/include/linux/hashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash_del(struct hlist_node *node)
{
 hlist_del_init(node);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hash_del_rcu(struct hlist_node *node)
{
 hlist_del_init_rcu(node);
}
# 51 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2

struct netpoll_info;
struct device;
struct phy_device;
struct dsa_port;

struct sfp_bus;

struct wireless_dev;

struct wpan_dev;
struct mpls_dev;

struct udp_tunnel_info;
struct bpf_prog;
struct xdp_buff;

void netdev_set_default_ethtool_ops(struct net_device *dev,
        const struct ethtool_ops *ops);
# 107 "/home/nathan/src/linux-next/include/linux/netdevice.h"
enum netdev_tx {
 __NETDEV_TX_MIN = (-((int)(~0U >> 1)) - 1),
 NETDEV_TX_OK = 0x00,
 NETDEV_TX_BUSY = 0x10,
};
typedef enum netdev_tx netdev_tx_t;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_xmit_complete(int rc)
{






 if (__builtin_expect(!!(rc < 0x0f), 1))
  return true;

 return false;
}
# 161 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct net_device_stats {
 unsigned long rx_packets;
 unsigned long tx_packets;
 unsigned long rx_bytes;
 unsigned long tx_bytes;
 unsigned long rx_errors;
 unsigned long tx_errors;
 unsigned long rx_dropped;
 unsigned long tx_dropped;
 unsigned long multicast;
 unsigned long collisions;
 unsigned long rx_length_errors;
 unsigned long rx_over_errors;
 unsigned long rx_crc_errors;
 unsigned long rx_frame_errors;
 unsigned long rx_fifo_errors;
 unsigned long rx_missed_errors;
 unsigned long tx_aborted_errors;
 unsigned long tx_carrier_errors;
 unsigned long tx_fifo_errors;
 unsigned long tx_heartbeat_errors;
 unsigned long tx_window_errors;
 unsigned long rx_compressed;
 unsigned long tx_compressed;
};







# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 193 "/home/nathan/src/linux-next/include/linux/netdevice.h" 2
extern struct static_key_false rps_needed;
extern struct static_key_false rfs_needed;


struct neighbour;
struct neigh_parms;
struct sk_buff;

struct netdev_hw_addr {
 struct list_head list;
 unsigned char addr[32];
 unsigned char type;





 bool global_use;
 int sync_cnt;
 int refcount;
 int synced;
 struct callback_head callback_head;
};

struct netdev_hw_addr_list {
 struct list_head list;
 int count;
};
# 237 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct hh_cache {
 unsigned int hh_len;
 seqlock_t hh_lock;







 unsigned long hh_data[(((96)+(16 -1))&~(16 - 1)) / sizeof(long)];
};
# 263 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct header_ops {
 int (*create) (struct sk_buff *skb, struct net_device *dev,
      unsigned short type, const void *daddr,
      const void *saddr, unsigned int len);
 int (*parse)(const struct sk_buff *skb, unsigned char *haddr);
 int (*cache)(const struct neighbour *neigh, struct hh_cache *hh, __be16 type);
 void (*cache_update)(struct hh_cache *hh,
    const struct net_device *dev,
    const unsigned char *haddr);
 bool (*validate)(const char *ll_header, unsigned int len);
 __be16 (*parse_protocol)(const struct sk_buff *skb);
};






enum netdev_state_t {
 __LINK_STATE_START,
 __LINK_STATE_PRESENT,
 __LINK_STATE_NOCARRIER,
 __LINK_STATE_LINKWATCH_PENDING,
 __LINK_STATE_DORMANT,
};






struct netdev_boot_setup {
 char name[16];
 struct ifmap map;
};


int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) netdev_boot_setup(char *str);

struct gro_list {
 struct list_head list;
 int count;
};
# 316 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct napi_struct {






 struct list_head poll_list;

 unsigned long state;
 int weight;
 unsigned long gro_bitmask;
 int (*poll)(struct napi_struct *, int);

 int poll_owner;

 struct net_device *dev;
 struct gro_list gro_hash[8];
 struct sk_buff *skb;
 struct list_head rx_list;
 int rx_count;
 struct hrtimer timer;
 struct list_head dev_list;
 struct hlist_node napi_hash_node;
 unsigned int napi_id;
};

enum {
 NAPI_STATE_SCHED,
 NAPI_STATE_MISSED,
 NAPI_STATE_DISABLE,
 NAPI_STATE_NPSVC,
 NAPI_STATE_HASHED,
 NAPI_STATE_NO_BUSY_POLL,
 NAPI_STATE_IN_BUSY_POLL,
};

enum {
 NAPIF_STATE_SCHED = ((((1UL))) << (NAPI_STATE_SCHED)),
 NAPIF_STATE_MISSED = ((((1UL))) << (NAPI_STATE_MISSED)),
 NAPIF_STATE_DISABLE = ((((1UL))) << (NAPI_STATE_DISABLE)),
 NAPIF_STATE_NPSVC = ((((1UL))) << (NAPI_STATE_NPSVC)),
 NAPIF_STATE_HASHED = ((((1UL))) << (NAPI_STATE_HASHED)),
 NAPIF_STATE_NO_BUSY_POLL = ((((1UL))) << (NAPI_STATE_NO_BUSY_POLL)),
 NAPIF_STATE_IN_BUSY_POLL = ((((1UL))) << (NAPI_STATE_IN_BUSY_POLL)),
};

enum gro_result {
 GRO_MERGED,
 GRO_MERGED_FREE,
 GRO_HELD,
 GRO_NORMAL,
 GRO_DROP,
 GRO_CONSUMED,
};
typedef enum gro_result gro_result_t;
# 414 "/home/nathan/src/linux-next/include/linux/netdevice.h"
enum rx_handler_result {
 RX_HANDLER_CONSUMED,
 RX_HANDLER_ANOTHER,
 RX_HANDLER_EXACT,
 RX_HANDLER_PASS,
};
typedef enum rx_handler_result rx_handler_result_t;
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **pskb);

void __napi_schedule(struct napi_struct *n);
void __napi_schedule_irqoff(struct napi_struct *n);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool napi_disable_pending(struct napi_struct *n)
{
 return test_bit(NAPI_STATE_DISABLE, &n->state);
}

bool napi_schedule_prep(struct napi_struct *n);
# 440 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void napi_schedule(struct napi_struct *n)
{
 if (napi_schedule_prep(n))
  __napi_schedule(n);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void napi_schedule_irqoff(struct napi_struct *n)
{
 if (napi_schedule_prep(n))
  __napi_schedule_irqoff(n);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool napi_reschedule(struct napi_struct *napi)
{
 if (napi_schedule_prep(napi)) {
  __napi_schedule(napi);
  return true;
 }
 return false;
}

bool napi_complete_done(struct napi_struct *n, int work_done);
# 477 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool napi_complete(struct napi_struct *n)
{
 return napi_complete_done(n, 0);
}
# 494 "/home/nathan/src/linux-next/include/linux/netdevice.h"
bool napi_hash_del(struct napi_struct *napi);
# 503 "/home/nathan/src/linux-next/include/linux/netdevice.h"
void napi_disable(struct napi_struct *n);
# 512 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void napi_enable(struct napi_struct *n)
{
 do { if (__builtin_constant_p(!test_bit(NAPI_STATE_SCHED, &n->state))) { if (!test_bit(NAPI_STATE_SCHED, &n->state)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (514), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (514), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!test_bit(NAPI_STATE_SCHED, &n->state)))); } } while (0);
 __asm__ __volatile__ ("sync" : : : "memory");
 clear_bit(NAPI_STATE_SCHED, &n->state);
 clear_bit(NAPI_STATE_NPSVC, &n->state);
}
# 528 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void napi_synchronize(const struct napi_struct *n)
{
 if (1)
  while (test_bit(NAPI_STATE_SCHED, &n->state))
   msleep(1);
 else
  __asm__ __volatile__("" : : : "memory");
}
# 545 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool napi_if_scheduled_mark_missed(struct napi_struct *n)
{
 unsigned long val, new;

 do {
  val = ({ union { typeof(n->state) __val; char __c[1]; } __u; if (1) __read_once_size(&(n->state), __u.__c, sizeof(n->state)); else __read_once_size_nocheck(&(n->state), __u.__c, sizeof(n->state)); do { } while (0); __u.__val; });
  if (val & NAPIF_STATE_DISABLE)
   return true;

  if (!(val & NAPIF_STATE_SCHED))
   return false;

  new = val | NAPIF_STATE_MISSED;
 } while (({ __typeof__(*(&n->state)) _o_ = (val); __typeof__(*(&n->state)) _n_ = (new); (__typeof__(*(&n->state))) __cmpxchg((&n->state), (unsigned long)_o_, (unsigned long)_n_, sizeof(*(&n->state))); }) != val);

 return true;
}

enum netdev_queue_state_t {
 __QUEUE_STATE_DRV_XOFF,
 __QUEUE_STATE_STACK_XOFF,
 __QUEUE_STATE_FROZEN,
};
# 589 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct netdev_queue {



 struct net_device *dev;
 struct Qdisc *qdisc;
 struct Qdisc *qdisc_sleeping;

 struct kobject kobj;


 int numa_node;

 unsigned long tx_maxrate;




 unsigned long trans_timeout;


 struct net_device *sb_dev;






 spinlock_t _xmit_lock __attribute__((__aligned__((1 << 7))));
 int xmit_lock_owner;



 unsigned long trans_start;

 unsigned long state;


 struct dql dql;

} __attribute__((__aligned__((1 << 7))));

extern int sysctl_fb_tunnels_only_for_init_net;
extern int sysctl_devconf_inherit_init_net;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool net_has_fallback_tunnels(const struct net *net)
{
 return net == &init_net ||
        !1 ||
        !sysctl_fb_tunnels_only_for_init_net;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int netdev_queue_numa_node_read(const struct netdev_queue *q)
{

 return q->numa_node;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_queue_numa_node_write(struct netdev_queue *q, int node)
{

 q->numa_node = node;

}






struct rps_map {
 unsigned int len;
 struct callback_head rcu;
 u16 cpus[0];
};







struct rps_dev_flow {
 u16 cpu;
 u16 filter;
 unsigned int last_qtail;
};





struct rps_dev_flow_table {
 unsigned int mask;
 struct callback_head rcu;
 struct rps_dev_flow flows[0];
};
# 702 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct rps_sock_flow_table {
 u32 mask;

 u32 ents[0] __attribute__((__aligned__((1 << 7))));
};




extern u32 rps_cpu_mask;
extern struct rps_sock_flow_table *rps_sock_flow_table;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rps_record_sock_flow(struct rps_sock_flow_table *table,
     u32 hash)
{
 if (table && hash) {
  unsigned int index = hash & table->mask;
  u32 val = hash & ~rps_cpu_mask;


  val |= (local_paca->paca_index);

  if (table->ents[index] != val)
   table->ents[index] = val;
 }
}


bool rps_may_expire_flow(struct net_device *dev, u16 rxq_index, u32 flow_id,
    u16 filter_id);




struct netdev_rx_queue {

 struct rps_map *rps_map;
 struct rps_dev_flow_table *rps_flow_table;

 struct kobject kobj;
 struct net_device *dev;
 struct xdp_rxq_info xdp_rxq;



} __attribute__((__aligned__((1 << 7))));




struct rx_queue_attribute {
 struct attribute attr;
 ssize_t (*show)(struct netdev_rx_queue *queue, char *buf);
 ssize_t (*store)(struct netdev_rx_queue *queue,
    const char *buf, size_t len);
};






struct xps_map {
 unsigned int len;
 unsigned int alloc_len;
 struct callback_head rcu;
 u16 queues[0];
};







struct xps_dev_maps {
 struct callback_head rcu;
 struct xps_map *attr_map[0];
};
# 793 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct netdev_tc_txq {
 u16 count;
 u16 offset;
};
# 820 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct netdev_phys_item_id {
 unsigned char id[32];
 unsigned char id_len;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netdev_phys_item_id_same(struct netdev_phys_item_id *a,
         struct netdev_phys_item_id *b)
{
 return a->id_len == b->id_len &&
        memcmp(a->id, b->id, a->id_len) == 0;
}

typedef u16 (*select_queue_fallback_t)(struct net_device *dev,
           struct sk_buff *skb,
           struct net_device *sb_dev);

enum tc_setup_type {
 TC_SETUP_QDISC_MQPRIO,
 TC_SETUP_CLSU32,
 TC_SETUP_CLSFLOWER,
 TC_SETUP_CLSMATCHALL,
 TC_SETUP_CLSBPF,
 TC_SETUP_BLOCK,
 TC_SETUP_QDISC_CBS,
 TC_SETUP_QDISC_RED,
 TC_SETUP_QDISC_PRIO,
 TC_SETUP_QDISC_MQ,
 TC_SETUP_QDISC_ETF,
 TC_SETUP_ROOT_QDISC,
 TC_SETUP_QDISC_GRED,
 TC_SETUP_QDISC_TAPRIO,
 TC_SETUP_FT,
 TC_SETUP_QDISC_ETS,
 TC_SETUP_QDISC_TBF,
};




enum bpf_netdev_command {







 XDP_SETUP_PROG,
 XDP_SETUP_PROG_HW,
 XDP_QUERY_PROG,
 XDP_QUERY_PROG_HW,

 BPF_OFFLOAD_MAP_ALLOC,
 BPF_OFFLOAD_MAP_FREE,
 XDP_SETUP_XSK_UMEM,
};

struct bpf_prog_offload_ops;
struct netlink_ext_ack;
struct xdp_umem;
struct xdp_dev_bulk_queue;

struct netdev_bpf {
 enum bpf_netdev_command command;
 union {

  struct {
   u32 flags;
   struct bpf_prog *prog;
   struct netlink_ext_ack *extack;
  };

  struct {
   u32 prog_id;

   u32 prog_flags;
  };

  struct {
   struct bpf_offloaded_map *offmap;
  };

  struct {
   struct xdp_umem *umem;
   u16 queue_id;
  } xsk;
 };
};
# 924 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct dev_ifalias {
 struct callback_head rcuhead;
 char ifalias[];
};

struct devlink;
struct tlsdev_ops;

struct netdev_name_node {
 struct hlist_node hlist;
 struct list_head list;
 struct net_device *dev;
 const char *name;
};

int netdev_name_node_alt_create(struct net_device *dev, const char *name);
int netdev_name_node_alt_destroy(struct net_device *dev, const char *name);

struct netdev_net_notifier {
 struct list_head list;
 struct notifier_block *nb;
};
# 1265 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct net_device_ops {
 int (*ndo_init)(struct net_device *dev);
 void (*ndo_uninit)(struct net_device *dev);
 int (*ndo_open)(struct net_device *dev);
 int (*ndo_stop)(struct net_device *dev);
 netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
        struct net_device *dev);
 netdev_features_t (*ndo_features_check)(struct sk_buff *skb,
            struct net_device *dev,
            netdev_features_t features);
 u16 (*ndo_select_queue)(struct net_device *dev,
          struct sk_buff *skb,
          struct net_device *sb_dev);
 void (*ndo_change_rx_flags)(struct net_device *dev,
             int flags);
 void (*ndo_set_rx_mode)(struct net_device *dev);
 int (*ndo_set_mac_address)(struct net_device *dev,
             void *addr);
 int (*ndo_validate_addr)(struct net_device *dev);
 int (*ndo_do_ioctl)(struct net_device *dev,
             struct ifreq *ifr, int cmd);
 int (*ndo_set_config)(struct net_device *dev,
               struct ifmap *map);
 int (*ndo_change_mtu)(struct net_device *dev,
        int new_mtu);
 int (*ndo_neigh_setup)(struct net_device *dev,
         struct neigh_parms *);
 void (*ndo_tx_timeout) (struct net_device *dev,
         unsigned int txqueue);

 void (*ndo_get_stats64)(struct net_device *dev,
         struct rtnl_link_stats64 *storage);
 bool (*ndo_has_offload_stats)(const struct net_device *dev, int attr_id);
 int (*ndo_get_offload_stats)(int attr_id,
        const struct net_device *dev,
        void *attr_data);
 struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);

 int (*ndo_vlan_rx_add_vid)(struct net_device *dev,
             __be16 proto, u16 vid);
 int (*ndo_vlan_rx_kill_vid)(struct net_device *dev,
              __be16 proto, u16 vid);

 void (*ndo_poll_controller)(struct net_device *dev);
 int (*ndo_netpoll_setup)(struct net_device *dev,
           struct netpoll_info *info);
 void (*ndo_netpoll_cleanup)(struct net_device *dev);

 int (*ndo_set_vf_mac)(struct net_device *dev,
        int queue, u8 *mac);
 int (*ndo_set_vf_vlan)(struct net_device *dev,
         int queue, u16 vlan,
         u8 qos, __be16 proto);
 int (*ndo_set_vf_rate)(struct net_device *dev,
         int vf, int min_tx_rate,
         int max_tx_rate);
 int (*ndo_set_vf_spoofchk)(struct net_device *dev,
             int vf, bool setting);
 int (*ndo_set_vf_trust)(struct net_device *dev,
          int vf, bool setting);
 int (*ndo_get_vf_config)(struct net_device *dev,
           int vf,
           struct ifla_vf_info *ivf);
 int (*ndo_set_vf_link_state)(struct net_device *dev,
        int vf, int link_state);
 int (*ndo_get_vf_stats)(struct net_device *dev,
          int vf,
          struct ifla_vf_stats
          *vf_stats);
 int (*ndo_set_vf_port)(struct net_device *dev,
         int vf,
         struct nlattr *port[]);
 int (*ndo_get_vf_port)(struct net_device *dev,
         int vf, struct sk_buff *skb);
 int (*ndo_get_vf_guid)(struct net_device *dev,
         int vf,
         struct ifla_vf_guid *node_guid,
         struct ifla_vf_guid *port_guid);
 int (*ndo_set_vf_guid)(struct net_device *dev,
         int vf, u64 guid,
         int guid_type);
 int (*ndo_set_vf_rss_query_en)(
         struct net_device *dev,
         int vf, bool setting);
 int (*ndo_setup_tc)(struct net_device *dev,
      enum tc_setup_type type,
      void *type_data);
# 1377 "/home/nathan/src/linux-next/include/linux/netdevice.h"
 int (*ndo_rx_flow_steer)(struct net_device *dev,
           const struct sk_buff *skb,
           u16 rxq_index,
           u32 flow_id);

 int (*ndo_add_slave)(struct net_device *dev,
       struct net_device *slave_dev,
       struct netlink_ext_ack *extack);
 int (*ndo_del_slave)(struct net_device *dev,
       struct net_device *slave_dev);
 netdev_features_t (*ndo_fix_features)(struct net_device *dev,
          netdev_features_t features);
 int (*ndo_set_features)(struct net_device *dev,
          netdev_features_t features);
 int (*ndo_neigh_construct)(struct net_device *dev,
             struct neighbour *n);
 void (*ndo_neigh_destroy)(struct net_device *dev,
           struct neighbour *n);

 int (*ndo_fdb_add)(struct ndmsg *ndm,
            struct nlattr *tb[],
            struct net_device *dev,
            const unsigned char *addr,
            u16 vid,
            u16 flags,
            struct netlink_ext_ack *extack);
 int (*ndo_fdb_del)(struct ndmsg *ndm,
            struct nlattr *tb[],
            struct net_device *dev,
            const unsigned char *addr,
            u16 vid);
 int (*ndo_fdb_dump)(struct sk_buff *skb,
      struct netlink_callback *cb,
      struct net_device *dev,
      struct net_device *filter_dev,
      int *idx);
 int (*ndo_fdb_get)(struct sk_buff *skb,
            struct nlattr *tb[],
            struct net_device *dev,
            const unsigned char *addr,
            u16 vid, u32 portid, u32 seq,
            struct netlink_ext_ack *extack);
 int (*ndo_bridge_setlink)(struct net_device *dev,
            struct nlmsghdr *nlh,
            u16 flags,
            struct netlink_ext_ack *extack);
 int (*ndo_bridge_getlink)(struct sk_buff *skb,
            u32 pid, u32 seq,
            struct net_device *dev,
            u32 filter_mask,
            int nlflags);
 int (*ndo_bridge_dellink)(struct net_device *dev,
            struct nlmsghdr *nlh,
            u16 flags);
 int (*ndo_change_carrier)(struct net_device *dev,
            bool new_carrier);
 int (*ndo_get_phys_port_id)(struct net_device *dev,
       struct netdev_phys_item_id *ppid);
 int (*ndo_get_port_parent_id)(struct net_device *dev,
         struct netdev_phys_item_id *ppid);
 int (*ndo_get_phys_port_name)(struct net_device *dev,
         char *name, size_t len);
 void (*ndo_udp_tunnel_add)(struct net_device *dev,
            struct udp_tunnel_info *ti);
 void (*ndo_udp_tunnel_del)(struct net_device *dev,
            struct udp_tunnel_info *ti);
 void* (*ndo_dfwd_add_station)(struct net_device *pdev,
       struct net_device *dev);
 void (*ndo_dfwd_del_station)(struct net_device *pdev,
       void *priv);

 int (*ndo_set_tx_maxrate)(struct net_device *dev,
            int queue_index,
            u32 maxrate);
 int (*ndo_get_iflink)(const struct net_device *dev);
 int (*ndo_change_proto_down)(struct net_device *dev,
        bool proto_down);
 int (*ndo_fill_metadata_dst)(struct net_device *dev,
             struct sk_buff *skb);
 void (*ndo_set_rx_headroom)(struct net_device *dev,
             int needed_headroom);
 int (*ndo_bpf)(struct net_device *dev,
        struct netdev_bpf *bpf);
 int (*ndo_xdp_xmit)(struct net_device *dev, int n,
      struct xdp_frame **xdp,
      u32 flags);
 int (*ndo_xsk_wakeup)(struct net_device *dev,
        u32 queue_id, u32 flags);
 struct devlink_port * (*ndo_get_devlink_port)(struct net_device *dev);
};
# 1514 "/home/nathan/src/linux-next/include/linux/netdevice.h"
enum netdev_priv_flags {
 IFF_802_1Q_VLAN = 1<<0,
 IFF_EBRIDGE = 1<<1,
 IFF_BONDING = 1<<2,
 IFF_ISATAP = 1<<3,
 IFF_WAN_HDLC = 1<<4,
 IFF_XMIT_DST_RELEASE = 1<<5,
 IFF_DONT_BRIDGE = 1<<6,
 IFF_DISABLE_NETPOLL = 1<<7,
 IFF_MACVLAN_PORT = 1<<8,
 IFF_BRIDGE_PORT = 1<<9,
 IFF_OVS_DATAPATH = 1<<10,
 IFF_TX_SKB_SHARING = 1<<11,
 IFF_UNICAST_FLT = 1<<12,
 IFF_TEAM_PORT = 1<<13,
 IFF_SUPP_NOFCS = 1<<14,
 IFF_LIVE_ADDR_CHANGE = 1<<15,
 IFF_MACVLAN = 1<<16,
 IFF_XMIT_DST_RELEASE_PERM = 1<<17,
 IFF_L3MDEV_MASTER = 1<<18,
 IFF_NO_QUEUE = 1<<19,
 IFF_OPENVSWITCH = 1<<20,
 IFF_L3MDEV_SLAVE = 1<<21,
 IFF_TEAM = 1<<22,
 IFF_RXFH_CONFIGURED = 1<<23,
 IFF_PHONY_HEADROOM = 1<<24,
 IFF_MACSEC = 1<<25,
 IFF_NO_RX_HANDLER = 1<<26,
 IFF_FAILOVER = 1<<27,
 IFF_FAILOVER_SLAVE = 1<<28,
 IFF_L3MDEV_RX_HANDLER = 1<<29,
 IFF_LIVE_RENAME_OK = 1<<30,
};
# 1809 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct net_device {
 char name[16];
 struct netdev_name_node *name_node;
 struct dev_ifalias *ifalias;




 unsigned long mem_end;
 unsigned long mem_start;
 unsigned long base_addr;
 int irq;







 unsigned long state;

 struct list_head dev_list;
 struct list_head napi_list;
 struct list_head unreg_list;
 struct list_head close_list;
 struct list_head ptype_all;
 struct list_head ptype_specific;

 struct {
  struct list_head upper;
  struct list_head lower;
 } adj_list;

 netdev_features_t features;
 netdev_features_t hw_features;
 netdev_features_t wanted_features;
 netdev_features_t vlan_features;
 netdev_features_t hw_enc_features;
 netdev_features_t mpls_features;
 netdev_features_t gso_partial_features;

 int ifindex;
 int group;

 struct net_device_stats stats;

 atomic_long_t rx_dropped;
 atomic_long_t tx_dropped;
 atomic_long_t rx_nohandler;


 atomic_t carrier_up_count;
 atomic_t carrier_down_count;


 const struct iw_handler_def *wireless_handlers;
 struct iw_public_data *wireless_data;

 const struct net_device_ops *netdev_ops;
 const struct ethtool_ops *ethtool_ops;




 const struct ndisc_ops *ndisc_ops;
# 1884 "/home/nathan/src/linux-next/include/linux/netdevice.h"
 const struct header_ops *header_ops;

 unsigned int flags;
 unsigned int priv_flags;

 unsigned short gflags;
 unsigned short padded;

 unsigned char operstate;
 unsigned char link_mode;

 unsigned char if_port;
 unsigned char dma;






 unsigned int mtu;
 unsigned int min_mtu;
 unsigned int max_mtu;
 unsigned short type;
 unsigned short hard_header_len;
 unsigned char min_header_len;

 unsigned short needed_headroom;
 unsigned short needed_tailroom;


 unsigned char perm_addr[32];
 unsigned char addr_assign_type;
 unsigned char addr_len;
 unsigned char upper_level;
 unsigned char lower_level;
 unsigned short neigh_priv_len;
 unsigned short dev_id;
 unsigned short dev_port;
 spinlock_t addr_list_lock;
 unsigned char name_assign_type;
 bool uc_promisc;
 struct netdev_hw_addr_list uc;
 struct netdev_hw_addr_list mc;
 struct netdev_hw_addr_list dev_addrs;


 struct kset *queues_kset;

 unsigned int promiscuity;
 unsigned int allmulti;
# 1950 "/home/nathan/src/linux-next/include/linux/netdevice.h"
 struct in_device *ip_ptr;



 struct inet6_dev *ip6_ptr;



 struct wireless_dev *ieee80211_ptr;
 struct wpan_dev *ieee802154_ptr;
# 1968 "/home/nathan/src/linux-next/include/linux/netdevice.h"
 unsigned char *dev_addr;

 struct netdev_rx_queue *_rx;
 unsigned int num_rx_queues;
 unsigned int real_num_rx_queues;

 struct bpf_prog *xdp_prog;
 unsigned long gro_flush_timeout;
 rx_handler_func_t *rx_handler;
 void *rx_handler_data;


 struct mini_Qdisc *miniq_ingress;

 struct netdev_queue *ingress_queue;

 struct nf_hook_entries *nf_hooks_ingress;


 unsigned char broadcast[32];

 struct cpu_rmap *rx_cpu_rmap;

 struct hlist_node index_hlist;




 struct netdev_queue *_tx __attribute__((__aligned__((1 << 7))));
 unsigned int num_tx_queues;
 unsigned int real_num_tx_queues;
 struct Qdisc *qdisc;
 unsigned int tx_queue_len;
 spinlock_t tx_global_lock;

 struct xdp_dev_bulk_queue *xdp_bulkq;


 struct xps_dev_maps *xps_cpus_map;
 struct xps_dev_maps *xps_rxqs_map;


 struct mini_Qdisc *miniq_egress;



 struct hlist_head qdisc_hash[1 << (4)];


 struct timer_list watchdog_timer;
 int watchdog_timeo;

 struct list_head todo_list;
 int *pcpu_refcnt;

 struct list_head link_watch_list;

 enum { NETREG_UNINITIALIZED=0,
        NETREG_REGISTERED,
        NETREG_UNREGISTERING,
        NETREG_UNREGISTERED,
        NETREG_RELEASED,
        NETREG_DUMMY,
 } reg_state:8;

 bool dismantle;

 enum {
  RTNL_LINK_INITIALIZED,
  RTNL_LINK_INITIALIZING,
 } rtnl_link_state:16;

 bool needs_free_netdev;
 void (*priv_destructor)(struct net_device *dev);


 struct netpoll_info *npinfo;


 possible_net_t nd_net;


 union {
  void *ml_priv;
  struct pcpu_lstats *lstats;
  struct pcpu_sw_netstats *tstats;
  struct pcpu_dstats *dstats;
 };
# 2064 "/home/nathan/src/linux-next/include/linux/netdevice.h"
 struct device dev;
 const struct attribute_group *sysfs_groups[4];
 const struct attribute_group *sysfs_rx_queue_group;

 const struct rtnl_link_ops *rtnl_link_ops;



 unsigned int gso_max_size;

 u16 gso_max_segs;




 s16 num_tc;
 struct netdev_tc_txq tc_to_txq[16];
 u8 prio_tc_map[15 + 1];







 struct phy_device *phydev;
 struct sfp_bus *sfp_bus;
 struct lock_class_key qdisc_tx_busylock_key;
 struct lock_class_key qdisc_running_key;
 struct lock_class_key qdisc_xmit_lock_key;
 struct lock_class_key addr_list_lock_key;
 bool proto_down;
 unsigned wol_enabled:1;

 struct list_head net_notifier_list;
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_elide_gro(const struct net_device *dev)
{
 if (!(dev->features & ((netdev_features_t)1 << (NETIF_F_GRO_BIT))) || dev->xdp_prog)
  return true;
 return false;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int netdev_get_prio_tc_map(const struct net_device *dev, u32 prio)
{
 return dev->prio_tc_map[prio & 15];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)
{
 if (tc >= dev->num_tc)
  return -22;

 dev->prio_tc_map[prio & 15] = tc & 15;
 return 0;
}

int netdev_txq_to_tc(struct net_device *dev, unsigned int txq);
void netdev_reset_tc(struct net_device *dev);
int netdev_set_tc_queue(struct net_device *dev, u8 tc, u16 count, u16 offset);
int netdev_set_num_tc(struct net_device *dev, u8 num_tc);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int netdev_get_num_tc(struct net_device *dev)
{
 return dev->num_tc;
}

void netdev_unbind_sb_channel(struct net_device *dev,
         struct net_device *sb_dev);
int netdev_bind_sb_channel_queue(struct net_device *dev,
     struct net_device *sb_dev,
     u8 tc, u16 count, u16 offset);
int netdev_set_sb_channel(struct net_device *dev, u16 channel);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int netdev_get_sb_channel(struct net_device *dev)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((int)(-dev->num_tc)) *)1 == (typeof((int)(0)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(-dev->num_tc)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(0)) * 0l)) : (int *)8))))), (((int)(-dev->num_tc)) > ((int)(0)) ? ((int)(-dev->num_tc)) : ((int)(0))), ({ typeof((int)(-dev->num_tc)) __UNIQUE_ID___x28 = ((int)(-dev->num_tc)); typeof((int)(0)) __UNIQUE_ID___y29 = ((int)(0)); ((__UNIQUE_ID___x28) > (__UNIQUE_ID___y29) ? (__UNIQUE_ID___x28) : (__UNIQUE_ID___y29)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,
      unsigned int index)
{
 return &dev->_tx[index];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct netdev_queue *skb_get_tx_queue(const struct net_device *dev,
          const struct sk_buff *skb)
{
 return netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_for_each_tx_queue(struct net_device *dev,
         void (*f)(struct net_device *,
            struct netdev_queue *,
            void *),
         void *arg)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++)
  f(dev, &dev->_tx[i], arg);
}

u16 netdev_pick_tx(struct net_device *dev, struct sk_buff *skb,
       struct net_device *sb_dev);
struct netdev_queue *netdev_core_pick_tx(struct net_device *dev,
      struct sk_buff *skb,
      struct net_device *sb_dev);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned netdev_get_fwd_headroom(struct net_device *dev)
{
 return dev->priv_flags & IFF_PHONY_HEADROOM ? 0 : dev->needed_headroom;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_set_rx_headroom(struct net_device *dev, int new_hr)
{
 if (dev->netdev_ops->ndo_set_rx_headroom)
  dev->netdev_ops->ndo_set_rx_headroom(dev, new_hr);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_reset_rx_headroom(struct net_device *dev)
{
 netdev_set_rx_headroom(dev, -1);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct net *dev_net(const struct net_device *dev)
{
 return read_pnet(&dev->nd_net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void dev_net_set(struct net_device *dev, struct net *net)
{
 write_pnet(&dev->nd_net, net);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *netdev_priv(const struct net_device *dev)
{
 return (char *)dev + ((((sizeof(struct net_device))) + ((typeof((sizeof(struct net_device))))((32)) - 1)) & ~((typeof((sizeof(struct net_device))))((32)) - 1));
}
# 2252 "/home/nathan/src/linux-next/include/linux/netdevice.h"
void netif_napi_add(struct net_device *dev, struct napi_struct *napi,
      int (*poll)(struct napi_struct *, int), int weight);
# 2266 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_napi_add(struct net_device *dev,
         struct napi_struct *napi,
         int (*poll)(struct napi_struct *, int),
         int weight)
{
 set_bit(NAPI_STATE_NO_BUSY_POLL, &napi->state);
 netif_napi_add(dev, napi, poll, weight);
}







void netif_napi_del(struct napi_struct *napi);

struct napi_gro_cb {

 void *frag0;


 unsigned int frag0_len;


 int data_offset;


 u16 flush;


 u16 flush_id;


 u16 count;


 u16 gro_remcsum_start;


 unsigned long age;


 u16 proto;


 u8 same_flow:1;


 u8 encap_mark:1;


 u8 csum_valid:1;


 u8 csum_cnt:3;


 u8 free:2;




 u8 is_ipv6:1;


 u8 is_fou:1;


 u8 is_atomic:1;


 u8 recursion_counter:4;


 u8 is_flist:1;


 __wsum csum;


 struct sk_buff *last;
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int gro_recursion_inc_test(struct sk_buff *skb)
{
 return ++((struct napi_gro_cb *)(skb)->cb)->recursion_counter == 15;
}

typedef struct sk_buff *(*gro_receive_t)(struct list_head *, struct sk_buff *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *call_gro_receive(gro_receive_t cb,
            struct list_head *head,
            struct sk_buff *skb)
{
 if (__builtin_expect(!!(gro_recursion_inc_test(skb)), 0)) {
  ((struct napi_gro_cb *)(skb)->cb)->flush |= 1;
  return ((void *)0);
 }

 return cb(head, skb);
}

typedef struct sk_buff *(*gro_receive_sk_t)(struct sock *, struct list_head *,
         struct sk_buff *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *call_gro_receive_sk(gro_receive_sk_t cb,
        struct sock *sk,
        struct list_head *head,
        struct sk_buff *skb)
{
 if (__builtin_expect(!!(gro_recursion_inc_test(skb)), 0)) {
  ((struct napi_gro_cb *)(skb)->cb)->flush |= 1;
  return ((void *)0);
 }

 return cb(sk, head, skb);
}

struct packet_type {
 __be16 type;
 bool ignore_outgoing;
 struct net_device *dev;
 int (*func) (struct sk_buff *,
      struct net_device *,
      struct packet_type *,
      struct net_device *);
 void (*list_func) (struct list_head *,
           struct packet_type *,
           struct net_device *);
 bool (*id_match)(struct packet_type *ptype,
         struct sock *sk);
 void *af_packet_priv;
 struct list_head list;
};

struct offload_callbacks {
 struct sk_buff *(*gso_segment)(struct sk_buff *skb,
      netdev_features_t features);
 struct sk_buff *(*gro_receive)(struct list_head *head,
      struct sk_buff *skb);
 int (*gro_complete)(struct sk_buff *skb, int nhoff);
};

struct packet_offload {
 __be16 type;
 u16 priority;
 struct offload_callbacks callbacks;
 struct list_head list;
};


struct pcpu_sw_netstats {
 u64 rx_packets;
 u64 rx_bytes;
 u64 tx_packets;
 u64 tx_bytes;
 struct u64_stats_sync syncp;
} __attribute__((__aligned__(4 * sizeof(u64))));

struct pcpu_lstats {
 u64_stats_t packets;
 u64_stats_t bytes;
 struct u64_stats_sync syncp;
} __attribute__((__aligned__(2 * sizeof(u64))));

void dev_lstats_read(struct net_device *dev, u64 *packets, u64 *bytes);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_lstats_add(struct net_device *dev, unsigned int len)
{
 struct pcpu_lstats *lstats = ({ do { const void *__vpp_verify = (typeof((dev->lstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(dev->lstats)) *)(dev->lstats)); (typeof((typeof(*(dev->lstats)) *)(dev->lstats))) (__ptr + ((local_paca->data_offset))); }); });

 u64_stats_update_begin(&lstats->syncp);
 u64_stats_add(&lstats->bytes, len);
 u64_stats_inc(&lstats->packets);
 u64_stats_update_end(&lstats->syncp);
}
# 2462 "/home/nathan/src/linux-next/include/linux/netdevice.h"
enum netdev_lag_tx_type {
 NETDEV_LAG_TX_TYPE_UNKNOWN,
 NETDEV_LAG_TX_TYPE_RANDOM,
 NETDEV_LAG_TX_TYPE_BROADCAST,
 NETDEV_LAG_TX_TYPE_ROUNDROBIN,
 NETDEV_LAG_TX_TYPE_ACTIVEBACKUP,
 NETDEV_LAG_TX_TYPE_HASH,
};

enum netdev_lag_hash {
 NETDEV_LAG_HASH_NONE,
 NETDEV_LAG_HASH_L2,
 NETDEV_LAG_HASH_L34,
 NETDEV_LAG_HASH_L23,
 NETDEV_LAG_HASH_E23,
 NETDEV_LAG_HASH_E34,
 NETDEV_LAG_HASH_UNKNOWN,
};

struct netdev_lag_upper_info {
 enum netdev_lag_tx_type tx_type;
 enum netdev_lag_hash hash_type;
};

struct netdev_lag_lower_state_info {
 u8 link_up : 1,
    tx_enabled : 1;
};







enum netdev_cmd {
 NETDEV_UP = 1,
 NETDEV_DOWN,
 NETDEV_REBOOT,



 NETDEV_CHANGE,
 NETDEV_REGISTER,
 NETDEV_UNREGISTER,
 NETDEV_CHANGEMTU,
 NETDEV_CHANGEADDR,
 NETDEV_PRE_CHANGEADDR,
 NETDEV_GOING_DOWN,
 NETDEV_CHANGENAME,
 NETDEV_FEAT_CHANGE,
 NETDEV_BONDING_FAILOVER,
 NETDEV_PRE_UP,
 NETDEV_PRE_TYPE_CHANGE,
 NETDEV_POST_TYPE_CHANGE,
 NETDEV_POST_INIT,
 NETDEV_RELEASE,
 NETDEV_NOTIFY_PEERS,
 NETDEV_JOIN,
 NETDEV_CHANGEUPPER,
 NETDEV_RESEND_IGMP,
 NETDEV_PRECHANGEMTU,
 NETDEV_CHANGEINFODATA,
 NETDEV_BONDING_INFO,
 NETDEV_PRECHANGEUPPER,
 NETDEV_CHANGELOWERSTATE,
 NETDEV_UDP_TUNNEL_PUSH_INFO,
 NETDEV_UDP_TUNNEL_DROP_INFO,
 NETDEV_CHANGE_TX_QUEUE_LEN,
 NETDEV_CVLAN_FILTER_PUSH_INFO,
 NETDEV_CVLAN_FILTER_DROP_INFO,
 NETDEV_SVLAN_FILTER_PUSH_INFO,
 NETDEV_SVLAN_FILTER_DROP_INFO,
};
const char *netdev_cmd_to_name(enum netdev_cmd cmd);

int register_netdevice_notifier(struct notifier_block *nb);
int unregister_netdevice_notifier(struct notifier_block *nb);
int register_netdevice_notifier_net(struct net *net, struct notifier_block *nb);
int unregister_netdevice_notifier_net(struct net *net,
          struct notifier_block *nb);
int register_netdevice_notifier_dev_net(struct net_device *dev,
     struct notifier_block *nb,
     struct netdev_net_notifier *nn);
int unregister_netdevice_notifier_dev_net(struct net_device *dev,
       struct notifier_block *nb,
       struct netdev_net_notifier *nn);

struct netdev_notifier_info {
 struct net_device *dev;
 struct netlink_ext_ack *extack;
};

struct netdev_notifier_info_ext {
 struct netdev_notifier_info info;
 union {
  u32 mtu;
 } ext;
};

struct netdev_notifier_change_info {
 struct netdev_notifier_info info;
 unsigned int flags_changed;
};

struct netdev_notifier_changeupper_info {
 struct netdev_notifier_info info;
 struct net_device *upper_dev;
 bool master;
 bool linking;
 void *upper_info;
};

struct netdev_notifier_changelowerstate_info {
 struct netdev_notifier_info info;
 void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
 struct netdev_notifier_info info;
 const unsigned char *dev_addr;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_notifier_info_init(struct netdev_notifier_info *info,
          struct net_device *dev)
{
 info->dev = dev;
 info->extack = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *
netdev_notifier_info_to_dev(const struct netdev_notifier_info *info)
{
 return info->dev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct netlink_ext_ack *
netdev_notifier_info_to_extack(const struct netdev_notifier_info *info)
{
 return info->extack;
}

int call_netdevice_notifiers(unsigned long val, struct net_device *dev);


extern rwlock_t dev_base_lock;
# 2629 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *next_net_device(struct net_device *dev)
{
 struct list_head *lh;
 struct net *net;

 net = dev_net(dev);
 lh = dev->dev_list.next;
 return lh == &net->dev_base_head ? ((void *)0) : ({ void *__mptr = (void *)(lh); do { extern void __compiletime_assert_2636(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lh)), typeof(((struct net_device *)0)->dev_list)) && !__builtin_types_compatible_p(typeof(*(lh)), typeof(void))))) __compiletime_assert_2636(); } while (0); ((struct net_device *)(__mptr - __builtin_offsetof(struct net_device, dev_list))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *next_net_device_rcu(struct net_device *dev)
{
 struct list_head *lh;
 struct net *net;

 net = dev_net(dev);
 lh = ({ typeof(*((*((struct list_head **)(&(&dev->dev_list)->next))))) *________p1 = (typeof(*((*((struct list_head **)(&(&dev->dev_list)->next))))) *)({ union { typeof(((*((struct list_head **)(&(&dev->dev_list)->next))))) __val; char __c[1]; } __u; if (1) __read_once_size(&(((*((struct list_head **)(&(&dev->dev_list)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(&dev->dev_list)->next)))))); else __read_once_size_nocheck(&(((*((struct list_head **)(&(&dev->dev_list)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(&dev->dev_list)->next)))))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*((*((struct list_head **)(&(&dev->dev_list)->next))))) *)(________p1)); });
 return lh == &net->dev_base_head ? ((void *)0) : ({ void *__mptr = (void *)(lh); do { extern void __compiletime_assert_2646(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lh)), typeof(((struct net_device *)0)->dev_list)) && !__builtin_types_compatible_p(typeof(*(lh)), typeof(void))))) __compiletime_assert_2646(); } while (0); ((struct net_device *)(__mptr - __builtin_offsetof(struct net_device, dev_list))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *first_net_device(struct net *net)
{
 return list_empty(&net->dev_base_head) ? ((void *)0) :
  ({ void *__mptr = (void *)(net->dev_base_head.next); do { extern void __compiletime_assert_2652(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(net->dev_base_head.next)), typeof(((struct net_device *)0)->dev_list)) && !__builtin_types_compatible_p(typeof(*(net->dev_base_head.next)), typeof(void))))) __compiletime_assert_2652(); } while (0); ((struct net_device *)(__mptr - __builtin_offsetof(struct net_device, dev_list))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *first_net_device_rcu(struct net *net)
{
 struct list_head *lh = ({ typeof(*((*((struct list_head **)(&(&net->dev_base_head)->next))))) *________p1 = (typeof(*((*((struct list_head **)(&(&net->dev_base_head)->next))))) *)({ union { typeof(((*((struct list_head **)(&(&net->dev_base_head)->next))))) __val; char __c[1]; } __u; if (1) __read_once_size(&(((*((struct list_head **)(&(&net->dev_base_head)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(&net->dev_base_head)->next)))))); else __read_once_size_nocheck(&(((*((struct list_head **)(&(&net->dev_base_head)->next))))), __u.__c, sizeof(((*((struct list_head **)(&(&net->dev_base_head)->next)))))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*((*((struct list_head **)(&(&net->dev_base_head)->next))))) *)(________p1)); });

 return lh == &net->dev_base_head ? ((void *)0) : ({ void *__mptr = (void *)(lh); do { extern void __compiletime_assert_2659(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lh)), typeof(((struct net_device *)0)->dev_list)) && !__builtin_types_compatible_p(typeof(*(lh)), typeof(void))))) __compiletime_assert_2659(); } while (0); ((struct net_device *)(__mptr - __builtin_offsetof(struct net_device, dev_list))); });
}

int netdev_boot_setup_check(struct net_device *dev);
unsigned long netdev_boot_base(const char *prefix, int unit);
struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
           const char *hwaddr);
struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
void dev_add_pack(struct packet_type *pt);
void dev_remove_pack(struct packet_type *pt);
void __dev_remove_pack(struct packet_type *pt);
void dev_add_offload(struct packet_offload *po);
void dev_remove_offload(struct packet_offload *po);

int dev_get_iflink(const struct net_device *dev);
int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);
struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
          unsigned short mask);
struct net_device *dev_get_by_name(struct net *net, const char *name);
struct net_device *dev_get_by_name_rcu(struct net *net, const char *name);
struct net_device *__dev_get_by_name(struct net *net, const char *name);
int dev_alloc_name(struct net_device *dev, const char *name);
int dev_open(struct net_device *dev, struct netlink_ext_ack *extack);
void dev_close(struct net_device *dev);
void dev_close_many(struct list_head *head, bool unlink);
void dev_disable_lro(struct net_device *dev);
int dev_loopback_xmit(struct net *net, struct sock *sk, struct sk_buff *newskb);
u16 dev_pick_tx_zero(struct net_device *dev, struct sk_buff *skb,
       struct net_device *sb_dev);
u16 dev_pick_tx_cpu_id(struct net_device *dev, struct sk_buff *skb,
         struct net_device *sb_dev);
int dev_queue_xmit(struct sk_buff *skb);
int dev_queue_xmit_accel(struct sk_buff *skb, struct net_device *sb_dev);
int dev_direct_xmit(struct sk_buff *skb, u16 queue_id);
int register_netdevice(struct net_device *dev);
void unregister_netdevice_queue(struct net_device *dev, struct list_head *head);
void unregister_netdevice_many(struct list_head *head);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unregister_netdevice(struct net_device *dev)
{
 unregister_netdevice_queue(dev, ((void *)0));
}

int netdev_refcnt_read(const struct net_device *dev);
void free_netdev(struct net_device *dev);
void netdev_freemem(struct net_device *dev);
void synchronize_net(void);
int init_dummy_netdev(struct net_device *dev);

struct net_device *dev_get_by_index(struct net *net, int ifindex);
struct net_device *__dev_get_by_index(struct net *net, int ifindex);
struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex);
struct net_device *dev_get_by_napi_id(unsigned int napi_id);
int netdev_get_name(struct net *net, char *name, int ifindex);
int dev_restart(struct net_device *dev);
int skb_gro_receive(struct sk_buff *p, struct sk_buff *skb);
int skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_gro_offset(const struct sk_buff *skb)
{
 return ((struct napi_gro_cb *)(skb)->cb)->data_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int skb_gro_len(const struct sk_buff *skb)
{
 return skb->len - ((struct napi_gro_cb *)(skb)->cb)->data_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_pull(struct sk_buff *skb, unsigned int len)
{
 ((struct napi_gro_cb *)(skb)->cb)->data_offset += len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_gro_header_fast(struct sk_buff *skb,
     unsigned int offset)
{
 return ((struct napi_gro_cb *)(skb)->cb)->frag0 + offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)
{
 return ((struct napi_gro_cb *)(skb)->cb)->frag0_len < hlen;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_frag0_invalidate(struct sk_buff *skb)
{
 ((struct napi_gro_cb *)(skb)->cb)->frag0 = ((void *)0);
 ((struct napi_gro_cb *)(skb)->cb)->frag0_len = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,
     unsigned int offset)
{
 if (!pskb_may_pull(skb, hlen))
  return ((void *)0);

 skb_gro_frag0_invalidate(skb);
 return skb->data + offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_gro_network_header(struct sk_buff *skb)
{
 return (((struct napi_gro_cb *)(skb)->cb)->frag0 ?: skb->data) +
        skb_network_offset(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_postpull_rcsum(struct sk_buff *skb,
     const void *start, unsigned int len)
{
 if (((struct napi_gro_cb *)(skb)->cb)->csum_valid)
  ((struct napi_gro_cb *)(skb)->cb)->csum = csum_sub(((struct napi_gro_cb *)(skb)->cb)->csum,
        csum_partial(start, len, 0));
}






__sum16 __skb_gro_checksum_complete(struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_at_gro_remcsum_start(struct sk_buff *skb)
{
 return (((struct napi_gro_cb *)(skb)->cb)->gro_remcsum_start == skb_gro_offset(skb));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_gro_checksum_validate_needed(struct sk_buff *skb,
            bool zero_okay,
            __sum16 check)
{
 return ((skb->ip_summed != 3 ||
  skb_checksum_start_offset(skb) <
   skb_gro_offset(skb)) &&
  !skb_at_gro_remcsum_start(skb) &&
  ((struct napi_gro_cb *)(skb)->cb)->csum_cnt == 0 &&
  (!zero_okay || check));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 __skb_gro_checksum_validate_complete(struct sk_buff *skb,
          __wsum psum)
{
 if (((struct napi_gro_cb *)(skb)->cb)->csum_valid &&
     !csum_fold(csum_add(psum, ((struct napi_gro_cb *)(skb)->cb)->csum)))
  return 0;

 ((struct napi_gro_cb *)(skb)->cb)->csum = psum;

 return __skb_gro_checksum_complete(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_incr_csum_unnecessary(struct sk_buff *skb)
{
 if (((struct napi_gro_cb *)(skb)->cb)->csum_cnt > 0) {

  ((struct napi_gro_cb *)(skb)->cb)->csum_cnt--;
 } else {




  __skb_incr_checksum_unnecessary(skb);
 }
}
# 2845 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __skb_gro_checksum_convert_check(struct sk_buff *skb)
{
 return (((struct napi_gro_cb *)(skb)->cb)->csum_cnt == 0 &&
  !((struct napi_gro_cb *)(skb)->cb)->csum_valid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_gro_checksum_convert(struct sk_buff *skb,
           __wsum pseudo)
{
 ((struct napi_gro_cb *)(skb)->cb)->csum = ~pseudo;
 ((struct napi_gro_cb *)(skb)->cb)->csum_valid = 1;
}
# 2865 "/home/nathan/src/linux-next/include/linux/netdevice.h"
struct gro_remcsum {
 int offset;
 __wsum delta;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_remcsum_init(struct gro_remcsum *grc)
{
 grc->offset = 0;
 grc->delta = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *skb_gro_remcsum_process(struct sk_buff *skb, void *ptr,
         unsigned int off, size_t hdrlen,
         int start, int offset,
         struct gro_remcsum *grc,
         bool nopartial)
{
 __wsum delta;
 size_t plen = hdrlen + __builtin_choose_expr(((!!(sizeof((typeof((size_t)(offset + sizeof(u16))) *)1 == (typeof((size_t)(start)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((size_t)(offset + sizeof(u16))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((size_t)(start)) * 0l)) : (int *)8))))), (((size_t)(offset + sizeof(u16))) > ((size_t)(start)) ? ((size_t)(offset + sizeof(u16))) : ((size_t)(start))), ({ typeof((size_t)(offset + sizeof(u16))) __UNIQUE_ID___x30 = ((size_t)(offset + sizeof(u16))); typeof((size_t)(start)) __UNIQUE_ID___y31 = ((size_t)(start)); ((__UNIQUE_ID___x30) > (__UNIQUE_ID___y31) ? (__UNIQUE_ID___x30) : (__UNIQUE_ID___y31)); }));

 do { if (__builtin_constant_p(!((struct napi_gro_cb *)(skb)->cb)->csum_valid)) { if (!((struct napi_gro_cb *)(skb)->cb)->csum_valid) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (2885), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (2885), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!((struct napi_gro_cb *)(skb)->cb)->csum_valid))); } } while (0);

 if (!nopartial) {
  ((struct napi_gro_cb *)(skb)->cb)->gro_remcsum_start = off + hdrlen + start;
  return ptr;
 }

 ptr = skb_gro_header_fast(skb, off);
 if (skb_gro_header_hard(skb, off + plen)) {
  ptr = skb_gro_header_slow(skb, off + plen, off);
  if (!ptr)
   return ((void *)0);
 }

 delta = remcsum_adjust(ptr + hdrlen, ((struct napi_gro_cb *)(skb)->cb)->csum,
          start, offset);


 ((struct napi_gro_cb *)(skb)->cb)->csum = csum_add(((struct napi_gro_cb *)(skb)->cb)->csum, delta);

 grc->offset = off + hdrlen + offset;
 grc->delta = delta;

 return ptr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_remcsum_cleanup(struct sk_buff *skb,
        struct gro_remcsum *grc)
{
 void *ptr;
 size_t plen = grc->offset + sizeof(u16);

 if (!grc->delta)
  return;

 ptr = skb_gro_header_fast(skb, grc->offset);
 if (skb_gro_header_hard(skb, grc->offset + sizeof(u16))) {
  ptr = skb_gro_header_slow(skb, plen, grc->offset);
  if (!ptr)
   return;
 }

 remcsum_unadjust((__sum16 *)ptr, grc->delta);
}
# 2948 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_flush_final(struct sk_buff *skb, struct sk_buff *pp, int flush)
{
 ((struct napi_gro_cb *)(skb)->cb)->flush |= flush;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gro_flush_final_remcsum(struct sk_buff *skb,
            struct sk_buff *pp,
            int flush,
            struct gro_remcsum *grc)
{
 ((struct napi_gro_cb *)(skb)->cb)->flush |= flush;
 skb_gro_remcsum_cleanup(skb, grc);
 skb->remcsum_offload = 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_hard_header(struct sk_buff *skb, struct net_device *dev,
      unsigned short type,
      const void *daddr, const void *saddr,
      unsigned int len)
{
 if (!dev->header_ops || !dev->header_ops->create)
  return 0;

 return dev->header_ops->create(skb, dev, type, daddr, saddr, len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_parse_header(const struct sk_buff *skb,
       unsigned char *haddr)
{
 const struct net_device *dev = skb->dev;

 if (!dev->header_ops || !dev->header_ops->parse)
  return 0;
 return dev->header_ops->parse(skb, haddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be16 dev_parse_header_protocol(const struct sk_buff *skb)
{
 const struct net_device *dev = skb->dev;

 if (!dev->header_ops || !dev->header_ops->parse_protocol)
  return 0;
 return dev->header_ops->parse_protocol(skb);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_validate_header(const struct net_device *dev,
           char *ll_header, int len)
{
 if (__builtin_expect(!!(len >= dev->hard_header_len), 1))
  return true;
 if (len < dev->min_header_len)
  return false;

 if (capable(17)) {
  memset(ll_header + len, 0, dev->hard_header_len - len);
  return true;
 }

 if (dev->header_ops && dev->header_ops->validate)
  return dev->header_ops->validate(ll_header, len);

 return false;
}

typedef int gifconf_func_t(struct net_device * dev, char * bufptr,
      int len, int size);
int register_gifconf(unsigned int family, gifconf_func_t *gifconf);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int unregister_gifconf(unsigned int family)
{
 return register_gifconf(family, ((void *)0));
}



struct sd_flow_limit {
 u64 count;
 unsigned int num_buckets;
 unsigned int history_head;
 u16 history[(1 << 7)];
 u8 buckets[];
};

extern int netdev_flow_limit_table_len;





struct softnet_data {
 struct list_head poll_list;
 struct sk_buff_head process_queue;


 unsigned int processed;
 unsigned int time_squeeze;
 unsigned int received_rps;

 struct softnet_data *rps_ipi_list;


 struct sd_flow_limit *flow_limit;

 struct Qdisc *output_queue;
 struct Qdisc **output_queue_tailp;
 struct sk_buff *completion_queue;




 struct {
  u16 recursion;
  u8 more;
 } xmit;




 unsigned int input_queue_head __attribute__((__aligned__((1 << 7))));


 call_single_data_t csd __attribute__((__aligned__((1 << 7))));
 struct softnet_data *rps_ipi_next;
 unsigned int cpu;
 unsigned int input_queue_tail;

 unsigned int dropped;
 struct sk_buff_head input_pkt_queue;
 struct napi_struct backlog;

};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void input_queue_head_incr(struct softnet_data *sd)
{

 sd->input_queue_head++;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void input_queue_tail_incr_save(struct softnet_data *sd,
           unsigned int *qtail)
{

 *qtail = ++sd->input_queue_tail;

}

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct softnet_data) softnet_data __attribute__((__aligned__((1 << 7))));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dev_recursion_level(void)
{
 return ({ typeof(softnet_data.xmit.recursion) pscr_ret__; do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.recursion)) { case 1: pscr_ret__ = ({ typeof(softnet_data.xmit.recursion) __ret; if ((sizeof(softnet_data.xmit.recursion) == sizeof(char) || sizeof(softnet_data.xmit.recursion) == sizeof(short) || sizeof(softnet_data.xmit.recursion) == sizeof(int) || sizeof(softnet_data.xmit.recursion) == sizeof(long))) __ret = ({ typeof(softnet_data.xmit.recursion) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(softnet_data.xmit.recursion) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 2: pscr_ret__ = ({ typeof(softnet_data.xmit.recursion) __ret; if ((sizeof(softnet_data.xmit.recursion) == sizeof(char) || sizeof(softnet_data.xmit.recursion) == sizeof(short) || sizeof(softnet_data.xmit.recursion) == sizeof(int) || sizeof(softnet_data.xmit.recursion) == sizeof(long))) __ret = ({ typeof(softnet_data.xmit.recursion) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(softnet_data.xmit.recursion) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 4: pscr_ret__ = ({ typeof(softnet_data.xmit.recursion) __ret; if ((sizeof(softnet_data.xmit.recursion) == sizeof(char) || sizeof(softnet_data.xmit.recursion) == sizeof(short) || sizeof(softnet_data.xmit.recursion) == sizeof(int) || sizeof(softnet_data.xmit.recursion) == sizeof(long))) __ret = ({ typeof(softnet_data.xmit.recursion) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(softnet_data.xmit.recursion) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 8: pscr_ret__ = ({ typeof(softnet_data.xmit.recursion) __ret; if ((sizeof(softnet_data.xmit.recursion) == sizeof(char) || sizeof(softnet_data.xmit.recursion) == sizeof(short) || sizeof(softnet_data.xmit.recursion) == sizeof(int) || sizeof(softnet_data.xmit.recursion) == sizeof(long))) __ret = ({ typeof(softnet_data.xmit.recursion) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(softnet_data.xmit.recursion) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_xmit_recursion(void)
{
 return __builtin_expect(!!(({ __this_cpu_preempt_check("read"); ({ typeof(softnet_data.xmit.recursion) pscr_ret__; do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.recursion)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }); }) > 10), 0);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_xmit_recursion_inc(void)
{
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.recursion)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_xmit_recursion_dec(void)
{
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.recursion)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(softnet_data.xmit.recursion))(1); } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(softnet_data.xmit.recursion))(1); } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(softnet_data.xmit.recursion))(1); } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.recursion)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion))); (typeof((typeof(*(&(softnet_data.xmit.recursion))) *)(&(softnet_data.xmit.recursion)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(softnet_data.xmit.recursion))(1); } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
}

void __netif_schedule(struct Qdisc *q);
void netif_schedule_queue(struct netdev_queue *txq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_schedule_all(struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++)
  netif_schedule_queue(netdev_get_tx_queue(dev, i));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
 clear_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_start_queue(struct net_device *dev)
{
 netif_tx_start_queue(netdev_get_tx_queue(dev, 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_start_all_queues(struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
  netif_tx_start_queue(txq);
 }
}

void netif_tx_wake_queue(struct netdev_queue *dev_queue);
# 3165 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_wake_queue(struct net_device *dev)
{
 netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_wake_all_queues(struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
  netif_tx_wake_queue(txq);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
 set_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);
}
# 3192 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_stop_queue(struct net_device *dev)
{
 netif_tx_stop_queue(netdev_get_tx_queue(dev, 0));
}

void netif_tx_stop_all_queues(struct net_device *dev);
void netdev_update_lockdep_key(struct net_device *dev);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_tx_queue_stopped(const struct netdev_queue *dev_queue)
{
 return test_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_queue_stopped(const struct net_device *dev)
{
 return netif_tx_queue_stopped(netdev_get_tx_queue(dev, 0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_xmit_stopped(const struct netdev_queue *dev_queue)
{
 return dev_queue->state & ((1 << __QUEUE_STATE_DRV_XOFF) | (1 << __QUEUE_STATE_STACK_XOFF));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
netif_xmit_frozen_or_stopped(const struct netdev_queue *dev_queue)
{
 return dev_queue->state & (((1 << __QUEUE_STATE_DRV_XOFF) | (1 << __QUEUE_STATE_STACK_XOFF)) | (1 << __QUEUE_STATE_FROZEN));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
netif_xmit_frozen_or_drv_stopped(const struct netdev_queue *dev_queue)
{
 return dev_queue->state & ((1 << __QUEUE_STATE_DRV_XOFF) | (1 << __QUEUE_STATE_FROZEN));
}
# 3240 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_txq_bql_enqueue_prefetchw(struct netdev_queue *dev_queue)
{

 prefetchw(&dev_queue->dql.num_queued);

}
# 3254 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_txq_bql_complete_prefetchw(struct netdev_queue *dev_queue)
{

 prefetchw(&dev_queue->dql.limit);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_tx_sent_queue(struct netdev_queue *dev_queue,
     unsigned int bytes)
{

 dql_queued(&dev_queue->dql, bytes);

 if (__builtin_expect(!!(dql_avail(&dev_queue->dql) >= 0), 1))
  return;

 set_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state);






 __asm__ __volatile__ ("sync" : : : "memory");


 if (__builtin_expect(!!(dql_avail(&dev_queue->dql) >= 0), 0))
  clear_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state);

}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __netdev_tx_sent_queue(struct netdev_queue *dev_queue,
       unsigned int bytes,
       bool xmit_more)
{
 if (xmit_more) {

  dql_queued(&dev_queue->dql, bytes);

  return netif_tx_queue_stopped(dev_queue);
 }
 netdev_tx_sent_queue(dev_queue, bytes);
 return true;
}
# 3314 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_sent_queue(struct net_device *dev, unsigned int bytes)
{
 netdev_tx_sent_queue(netdev_get_tx_queue(dev, 0), bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __netdev_sent_queue(struct net_device *dev,
           unsigned int bytes,
           bool xmit_more)
{
 return __netdev_tx_sent_queue(netdev_get_tx_queue(dev, 0), bytes,
          xmit_more);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
          unsigned int pkts, unsigned int bytes)
{

 if (__builtin_expect(!!(!bytes), 0))
  return;

 dql_completed(&dev_queue->dql, bytes);






 __asm__ __volatile__ ("sync" : : : "memory");

 if (__builtin_expect(!!(dql_avail(&dev_queue->dql) < 0), 0))
  return;

 if (test_and_clear_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state))
  netif_schedule_queue(dev_queue);

}
# 3361 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_completed_queue(struct net_device *dev,
       unsigned int pkts, unsigned int bytes)
{
 netdev_tx_completed_queue(netdev_get_tx_queue(dev, 0), pkts, bytes);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_tx_reset_queue(struct netdev_queue *q)
{

 clear_bit(__QUEUE_STATE_STACK_XOFF, &q->state);
 dql_reset(&q->dql);

}
# 3382 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_reset_queue(struct net_device *dev_queue)
{
 netdev_tx_reset_queue(netdev_get_tx_queue(dev_queue, 0));
}
# 3395 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 netdev_cap_txqueue(struct net_device *dev, u16 queue_index)
{
 if (__builtin_expect(!!(queue_index >= dev->real_num_tx_queues), 0)) {
  do { if (net_ratelimit()) printk("\001" "4" "%s selects TX queue %d, but real number of TX queues is %d\n", dev->name, queue_index, dev->real_num_tx_queues); } while (0);


  return 0;
 }

 return queue_index;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_running(const struct net_device *dev)
{
 return test_bit(__LINK_STATE_START, &dev->state);
}
# 3432 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
 struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);

 netif_tx_start_queue(txq);
}
# 3446 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_stop_subqueue(struct net_device *dev, u16 queue_index)
{
 struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
 netif_tx_stop_queue(txq);
}
# 3459 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __netif_subqueue_stopped(const struct net_device *dev,
         u16 queue_index)
{
 struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);

 return netif_tx_queue_stopped(txq);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_subqueue_stopped(const struct net_device *dev,
       struct sk_buff *skb)
{
 return __netif_subqueue_stopped(dev, skb_get_queue_mapping(skb));
}
# 3480 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_wake_subqueue(struct net_device *dev, u16 queue_index)
{
 struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);

 netif_tx_wake_queue(txq);
}


int netif_set_xps_queue(struct net_device *dev, const struct cpumask *mask,
   u16 index);
int __netif_set_xps_queue(struct net_device *dev, const unsigned long *mask,
     u16 index, bool is_rxqs_map);
# 3501 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_attr_test_mask(unsigned long j,
     const unsigned long *mask,
     unsigned int nr_bits)
{
 cpu_max_bits_warn(j, nr_bits);
 return test_bit(j, mask);
}
# 3517 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_attr_test_online(unsigned long j,
       const unsigned long *online_mask,
       unsigned int nr_bits)
{
 cpu_max_bits_warn(j, nr_bits);

 if (online_mask)
  return test_bit(j, online_mask);

 return (j < nr_bits);
}
# 3537 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int netif_attrmask_next(int n, const unsigned long *srcp,
            unsigned int nr_bits)
{

 if (n != -1)
  cpu_max_bits_warn(n, nr_bits);

 if (srcp)
  return find_next_bit(srcp, nr_bits, n + 1);

 return n + 1;
}
# 3559 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int netif_attrmask_next_and(int n, const unsigned long *src1p,
       const unsigned long *src2p,
       unsigned int nr_bits)
{

 if (n != -1)
  cpu_max_bits_warn(n, nr_bits);

 if (src1p && src2p)
  return find_next_and_bit(src1p, src2p, nr_bits, n + 1);
 else if (src1p)
  return find_next_bit(src1p, nr_bits, n + 1);
 else if (src2p)
  return find_next_bit(src2p, nr_bits, n + 1);

 return n + 1;
}
# 3598 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_multiqueue(const struct net_device *dev)
{
 return dev->num_tx_queues > 1;
}

int netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq);


int netif_set_real_num_rx_queues(struct net_device *dev, unsigned int rxq);
# 3616 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct netdev_rx_queue *
__netif_get_rx_queue(struct net_device *dev, unsigned int rxq)
{
 return dev->_rx + rxq;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int get_netdev_rx_queue_index(
  struct netdev_rx_queue *queue)
{
 struct net_device *dev = queue->dev;
 int index = queue - dev->_rx;

 do { if (__builtin_constant_p(index >= dev->num_rx_queues)) { if (index >= dev->num_rx_queues) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (3629), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (3629), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(index >= dev->num_rx_queues))); } } while (0);
 return index;
}



int netif_get_num_default_rss_queues(void);

enum skb_free_reason {
 SKB_REASON_CONSUMED,
 SKB_REASON_DROPPED,
};

void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason);
void __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason);
# 3664 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_kfree_skb_irq(struct sk_buff *skb)
{
 __dev_kfree_skb_irq(skb, SKB_REASON_DROPPED);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_consume_skb_irq(struct sk_buff *skb)
{
 __dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_kfree_skb_any(struct sk_buff *skb)
{
 __dev_kfree_skb_any(skb, SKB_REASON_DROPPED);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_consume_skb_any(struct sk_buff *skb)
{
 __dev_kfree_skb_any(skb, SKB_REASON_CONSUMED);
}

void generic_xdp_tx(struct sk_buff *skb, struct bpf_prog *xdp_prog);
int do_xdp_generic(struct bpf_prog *xdp_prog, struct sk_buff *skb);
int netif_rx(struct sk_buff *skb);
int netif_rx_ni(struct sk_buff *skb);
int netif_receive_skb(struct sk_buff *skb);
int netif_receive_skb_core(struct sk_buff *skb);
void netif_receive_skb_list(struct list_head *head);
gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);
void napi_gro_flush(struct napi_struct *napi, bool flush_old);
struct sk_buff *napi_get_frags(struct napi_struct *napi);
gro_result_t napi_gro_frags(struct napi_struct *napi);
struct packet_offload *gro_find_receive_by_type(__be16 type);
struct packet_offload *gro_find_complete_by_type(__be16 type);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void napi_free_frags(struct napi_struct *napi)
{
 kfree_skb(napi->skb);
 napi->skb = ((void *)0);
}

bool netdev_is_rx_handler_busy(struct net_device *dev);
int netdev_rx_handler_register(struct net_device *dev,
          rx_handler_func_t *rx_handler,
          void *rx_handler_data);
void netdev_rx_handler_unregister(struct net_device *dev);

bool dev_valid_name(const char *name);
int dev_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr,
  bool *need_copyout);
int dev_ifconf(struct net *net, struct ifconf *, int);
int dev_ethtool(struct net *net, struct ifreq *);
unsigned int dev_get_flags(const struct net_device *);
int __dev_change_flags(struct net_device *dev, unsigned int flags,
         struct netlink_ext_ack *extack);
int dev_change_flags(struct net_device *dev, unsigned int flags,
       struct netlink_ext_ack *extack);
void __dev_notify_flags(struct net_device *, unsigned int old_flags,
   unsigned int gchanges);
int dev_change_name(struct net_device *, const char *);
int dev_set_alias(struct net_device *, const char *, size_t);
int dev_get_alias(const struct net_device *, char *, size_t);
int dev_change_net_namespace(struct net_device *, struct net *, const char *);
int __dev_set_mtu(struct net_device *, int);
int dev_validate_mtu(struct net_device *dev, int mtu,
       struct netlink_ext_ack *extack);
int dev_set_mtu_ext(struct net_device *dev, int mtu,
      struct netlink_ext_ack *extack);
int dev_set_mtu(struct net_device *, int);
int dev_change_tx_queue_len(struct net_device *, unsigned long);
void dev_set_group(struct net_device *, int);
int dev_pre_changeaddr_notify(struct net_device *dev, const char *addr,
         struct netlink_ext_ack *extack);
int dev_set_mac_address(struct net_device *dev, struct sockaddr *sa,
   struct netlink_ext_ack *extack);
int dev_change_carrier(struct net_device *, bool new_carrier);
int dev_get_phys_port_id(struct net_device *dev,
    struct netdev_phys_item_id *ppid);
int dev_get_phys_port_name(struct net_device *dev,
      char *name, size_t len);
int dev_get_port_parent_id(struct net_device *dev,
      struct netdev_phys_item_id *ppid, bool recurse);
bool netdev_port_same_parent_id(struct net_device *a, struct net_device *b);
int dev_change_proto_down(struct net_device *dev, bool proto_down);
int dev_change_proto_down_generic(struct net_device *dev, bool proto_down);
struct sk_buff *validate_xmit_skb_list(struct sk_buff *skb, struct net_device *dev, bool *again);
struct sk_buff *dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
        struct netdev_queue *txq, int *ret);

typedef int (*bpf_op_t)(struct net_device *dev, struct netdev_bpf *bpf);
int dev_change_xdp_fd(struct net_device *dev, struct netlink_ext_ack *extack,
        int fd, u32 flags);
u32 __dev_xdp_query(struct net_device *dev, bpf_op_t xdp_op,
      enum bpf_netdev_command cmd);
int xdp_umem_query(struct net_device *dev, u16 queue_id);

int __dev_forward_skb(struct net_device *dev, struct sk_buff *skb);
int dev_forward_skb(struct net_device *dev, struct sk_buff *skb);
bool is_skb_forwardable(const struct net_device *dev,
   const struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) int ____dev_forward_skb(struct net_device *dev,
            struct sk_buff *skb)
{
 if (skb_orphan_frags(skb, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u))) ||
     __builtin_expect(!!(!is_skb_forwardable(dev, skb)), 0)) {
  atomic_long_inc(&dev->rx_dropped);
  kfree_skb(skb);
  return 1;
 }

 skb_scrub_packet(skb, true);
 skb->priority = 0;
 return 0;
}

bool dev_nit_active(struct net_device *dev);
void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev);

extern int netdev_budget;
extern unsigned int netdev_budget_usecs;


void netdev_run_todo(void);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_put(struct net_device *dev)
{
 do { do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*dev->pcpu_refcnt)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*dev->pcpu_refcnt))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*dev->pcpu_refcnt))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*dev->pcpu_refcnt))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(*dev->pcpu_refcnt))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dev_hold(struct net_device *dev)
{
 do { do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(*dev->pcpu_refcnt)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(*dev->pcpu_refcnt)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt))); (typeof((typeof(*(&(*dev->pcpu_refcnt))) *)(&(*dev->pcpu_refcnt)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}
# 3819 "/home/nathan/src/linux-next/include/linux/netdevice.h"
void linkwatch_init_dev(struct net_device *dev);
void linkwatch_fire_event(struct net_device *dev);
void linkwatch_forget_dev(struct net_device *dev);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_carrier_ok(const struct net_device *dev)
{
 return !test_bit(__LINK_STATE_NOCARRIER, &dev->state);
}

unsigned long dev_trans_start(struct net_device *dev);

void __netdev_watchdog_up(struct net_device *dev);

void netif_carrier_on(struct net_device *dev);

void netif_carrier_off(struct net_device *dev);
# 3854 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_dormant_on(struct net_device *dev)
{
 if (!test_and_set_bit(__LINK_STATE_DORMANT, &dev->state))
  linkwatch_fire_event(dev);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_dormant_off(struct net_device *dev)
{
 if (test_and_clear_bit(__LINK_STATE_DORMANT, &dev->state))
  linkwatch_fire_event(dev);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_dormant(const struct net_device *dev)
{
 return test_bit(__LINK_STATE_DORMANT, &dev->state);
}
# 3890 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_oper_up(const struct net_device *dev)
{
 return (dev->operstate == IF_OPER_UP ||
  dev->operstate == IF_OPER_UNKNOWN );
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_device_present(struct net_device *dev)
{
 return test_bit(__LINK_STATE_PRESENT, &dev->state);
}

void netif_device_detach(struct net_device *dev);

void netif_device_attach(struct net_device *dev);





enum {
 NETIF_MSG_DRV_BIT,
 NETIF_MSG_PROBE_BIT,
 NETIF_MSG_LINK_BIT,
 NETIF_MSG_TIMER_BIT,
 NETIF_MSG_IFDOWN_BIT,
 NETIF_MSG_IFUP_BIT,
 NETIF_MSG_RX_ERR_BIT,
 NETIF_MSG_TX_ERR_BIT,
 NETIF_MSG_TX_QUEUED_BIT,
 NETIF_MSG_INTR_BIT,
 NETIF_MSG_TX_DONE_BIT,
 NETIF_MSG_RX_STATUS_BIT,
 NETIF_MSG_PKTDATA_BIT,
 NETIF_MSG_HW_BIT,
 NETIF_MSG_WOL_BIT,




 NETIF_MSG_CLASS_COUNT,
};

_Static_assert(NETIF_MSG_CLASS_COUNT <= 32, "NETIF_MSG_CLASS_COUNT <= 32");
# 3975 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{

 if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
  return default_msg_enable_bits;
 if (debug_value == 0)
  return 0;

 return (1U << debug_value) - 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
 spin_lock(&txq->_xmit_lock);
 txq->xmit_lock_owner = cpu;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __netif_tx_acquire(struct netdev_queue *txq)
{
 (void)0;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __netif_tx_release(struct netdev_queue *txq)
{
 (void)0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __netif_tx_lock_bh(struct netdev_queue *txq)
{
 spin_lock_bh(&txq->_xmit_lock);
 txq->xmit_lock_owner = (local_paca->paca_index);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __netif_tx_trylock(struct netdev_queue *txq)
{
 bool ok = spin_trylock(&txq->_xmit_lock);
 if (__builtin_expect(!!(ok), 1))
  txq->xmit_lock_owner = (local_paca->paca_index);
 return ok;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __netif_tx_unlock(struct netdev_queue *txq)
{
 txq->xmit_lock_owner = -1;
 spin_unlock(&txq->_xmit_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __netif_tx_unlock_bh(struct netdev_queue *txq)
{
 txq->xmit_lock_owner = -1;
 spin_unlock_bh(&txq->_xmit_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void txq_trans_update(struct netdev_queue *txq)
{
 if (txq->xmit_lock_owner != -1)
  txq->trans_start = jiffies;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_trans_update(struct net_device *dev)
{
 struct netdev_queue *txq = netdev_get_tx_queue(dev, 0);

 if (txq->trans_start != jiffies)
  txq->trans_start = jiffies;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_lock(struct net_device *dev)
{
 unsigned int i;
 int cpu;

 spin_lock(&dev->tx_global_lock);
 cpu = (local_paca->paca_index);
 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);







  __netif_tx_lock(txq, cpu);
  set_bit(__QUEUE_STATE_FROZEN, &txq->state);
  __netif_tx_unlock(txq);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_lock_bh(struct net_device *dev)
{
 local_bh_disable();
 netif_tx_lock(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_unlock(struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);





  clear_bit(__QUEUE_STATE_FROZEN, &txq->state);
  netif_schedule_queue(txq);
 }
 spin_unlock(&dev->tx_global_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_unlock_bh(struct net_device *dev)
{
 netif_tx_unlock(dev);
 local_bh_enable();
}
# 4122 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_tx_disable(struct net_device *dev)
{
 unsigned int i;
 int cpu;

 local_bh_disable();
 cpu = (local_paca->paca_index);
 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);

  __netif_tx_lock(txq, cpu);
  netif_tx_stop_queue(txq);
  __netif_tx_unlock(txq);
 }
 local_bh_enable();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_addr_lock(struct net_device *dev)
{
 spin_lock(&dev->addr_list_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_addr_lock_bh(struct net_device *dev)
{
 spin_lock_bh(&dev->addr_list_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_addr_unlock(struct net_device *dev)
{
 spin_unlock(&dev->addr_list_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_addr_unlock_bh(struct net_device *dev)
{
 spin_unlock_bh(&dev->addr_list_lock);
}
# 4168 "/home/nathan/src/linux-next/include/linux/netdevice.h"
void ether_setup(struct net_device *dev);


struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
        unsigned char name_assign_type,
        void (*setup)(struct net_device *),
        unsigned int txqs, unsigned int rxqs);







int register_netdev(struct net_device *dev);
void unregister_netdev(struct net_device *dev);


int __hw_addr_sync(struct netdev_hw_addr_list *to_list,
     struct netdev_hw_addr_list *from_list, int addr_len);
void __hw_addr_unsync(struct netdev_hw_addr_list *to_list,
        struct netdev_hw_addr_list *from_list, int addr_len);
int __hw_addr_sync_dev(struct netdev_hw_addr_list *list,
         struct net_device *dev,
         int (*sync)(struct net_device *, const unsigned char *),
         int (*unsync)(struct net_device *,
         const unsigned char *));
int __hw_addr_ref_sync_dev(struct netdev_hw_addr_list *list,
      struct net_device *dev,
      int (*sync)(struct net_device *,
           const unsigned char *, int),
      int (*unsync)(struct net_device *,
      const unsigned char *, int));
void __hw_addr_ref_unsync_dev(struct netdev_hw_addr_list *list,
         struct net_device *dev,
         int (*unsync)(struct net_device *,
         const unsigned char *, int));
void __hw_addr_unsync_dev(struct netdev_hw_addr_list *list,
     struct net_device *dev,
     int (*unsync)(struct net_device *,
     const unsigned char *));
void __hw_addr_init(struct netdev_hw_addr_list *list);


int dev_addr_add(struct net_device *dev, const unsigned char *addr,
   unsigned char addr_type);
int dev_addr_del(struct net_device *dev, const unsigned char *addr,
   unsigned char addr_type);
void dev_addr_flush(struct net_device *dev);
int dev_addr_init(struct net_device *dev);


int dev_uc_add(struct net_device *dev, const unsigned char *addr);
int dev_uc_add_excl(struct net_device *dev, const unsigned char *addr);
int dev_uc_del(struct net_device *dev, const unsigned char *addr);
int dev_uc_sync(struct net_device *to, struct net_device *from);
int dev_uc_sync_multiple(struct net_device *to, struct net_device *from);
void dev_uc_unsync(struct net_device *to, struct net_device *from);
void dev_uc_flush(struct net_device *dev);
void dev_uc_init(struct net_device *dev);
# 4238 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __dev_uc_sync(struct net_device *dev,
    int (*sync)(struct net_device *,
         const unsigned char *),
    int (*unsync)(struct net_device *,
           const unsigned char *))
{
 return __hw_addr_sync_dev(&dev->uc, dev, sync, unsync);
}
# 4254 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dev_uc_unsync(struct net_device *dev,
       int (*unsync)(struct net_device *,
       const unsigned char *))
{
 __hw_addr_unsync_dev(&dev->uc, dev, unsync);
}


int dev_mc_add(struct net_device *dev, const unsigned char *addr);
int dev_mc_add_global(struct net_device *dev, const unsigned char *addr);
int dev_mc_add_excl(struct net_device *dev, const unsigned char *addr);
int dev_mc_del(struct net_device *dev, const unsigned char *addr);
int dev_mc_del_global(struct net_device *dev, const unsigned char *addr);
int dev_mc_sync(struct net_device *to, struct net_device *from);
int dev_mc_sync_multiple(struct net_device *to, struct net_device *from);
void dev_mc_unsync(struct net_device *to, struct net_device *from);
void dev_mc_flush(struct net_device *dev);
void dev_mc_init(struct net_device *dev);
# 4282 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __dev_mc_sync(struct net_device *dev,
    int (*sync)(struct net_device *,
         const unsigned char *),
    int (*unsync)(struct net_device *,
           const unsigned char *))
{
 return __hw_addr_sync_dev(&dev->mc, dev, sync, unsync);
}
# 4298 "/home/nathan/src/linux-next/include/linux/netdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dev_mc_unsync(struct net_device *dev,
       int (*unsync)(struct net_device *,
       const unsigned char *))
{
 __hw_addr_unsync_dev(&dev->mc, dev, unsync);
}


void dev_set_rx_mode(struct net_device *dev);
void __dev_set_rx_mode(struct net_device *dev);
int dev_set_promiscuity(struct net_device *dev, int inc);
int dev_set_allmulti(struct net_device *dev, int inc);
void netdev_state_change(struct net_device *dev);
void netdev_notify_peers(struct net_device *dev);
void netdev_features_change(struct net_device *dev);

void dev_load(struct net *net, const char *name);
struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,
     struct rtnl_link_stats64 *storage);
void netdev_stats_to_stats64(struct rtnl_link_stats64 *stats64,
        const struct net_device_stats *netdev_stats);

extern int netdev_max_backlog;
extern int netdev_tstamp_prequeue;
extern int weight_p;
extern int dev_weight_rx_bias;
extern int dev_weight_tx_bias;
extern int dev_rx_weight;
extern int dev_tx_weight;
extern int gro_normal_batch;

bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
struct net_device *netdev_upper_get_next_dev_rcu(struct net_device *dev,
           struct list_head **iter);
struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
           struct list_head **iter);
# 4342 "/home/nathan/src/linux-next/include/linux/netdevice.h"
int netdev_walk_all_upper_dev_rcu(struct net_device *dev,
      int (*fn)(struct net_device *upper_dev,
         void *data),
      void *data);

bool netdev_has_upper_dev_all_rcu(struct net_device *dev,
      struct net_device *upper_dev);

bool netdev_has_any_upper_dev(struct net_device *dev);

void *netdev_lower_get_next_private(struct net_device *dev,
        struct list_head **iter);
void *netdev_lower_get_next_private_rcu(struct net_device *dev,
     struct list_head **iter);
# 4369 "/home/nathan/src/linux-next/include/linux/netdevice.h"
void *netdev_lower_get_next(struct net_device *dev,
    struct list_head **iter);







struct net_device *netdev_all_lower_get_next(struct net_device *dev,
          struct list_head **iter);
struct net_device *netdev_all_lower_get_next_rcu(struct net_device *dev,
       struct list_head **iter);

int netdev_walk_all_lower_dev(struct net_device *dev,
         int (*fn)(struct net_device *lower_dev,
     void *data),
         void *data);
int netdev_walk_all_lower_dev_rcu(struct net_device *dev,
      int (*fn)(struct net_device *lower_dev,
         void *data),
      void *data);

void *netdev_adjacent_get_private(struct list_head *adj_list);
void *netdev_lower_get_first_private_rcu(struct net_device *dev);
struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev,
     struct netlink_ext_ack *extack);
int netdev_master_upper_dev_link(struct net_device *dev,
     struct net_device *upper_dev,
     void *upper_priv, void *upper_info,
     struct netlink_ext_ack *extack);
void netdev_upper_dev_unlink(struct net_device *dev,
        struct net_device *upper_dev);
int netdev_adjacent_change_prepare(struct net_device *old_dev,
       struct net_device *new_dev,
       struct net_device *dev,
       struct netlink_ext_ack *extack);
void netdev_adjacent_change_commit(struct net_device *old_dev,
       struct net_device *new_dev,
       struct net_device *dev);
void netdev_adjacent_change_abort(struct net_device *old_dev,
      struct net_device *new_dev,
      struct net_device *dev);
void netdev_adjacent_rename_links(struct net_device *dev, char *oldname);
void *netdev_lower_dev_get_private(struct net_device *dev,
       struct net_device *lower_dev);
void netdev_lower_state_changed(struct net_device *lower_dev,
    void *lower_state_info);



extern u8 netdev_rss_key[52] __attribute__((__section__(".data..read_mostly")));
void netdev_rss_key_fill(void *buffer, size_t len);

int skb_checksum_help(struct sk_buff *skb);
int skb_crc32c_csum_help(struct sk_buff *skb);
int skb_csum_hwoffload_help(struct sk_buff *skb,
       const netdev_features_t features);

struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
      netdev_features_t features, bool tx_path);
struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
        netdev_features_t features);

struct netdev_bonding_info {
 ifslave slave;
 ifbond master;
};

struct netdev_notifier_bonding_info {
 struct netdev_notifier_info info;
 struct netdev_bonding_info bonding_info;
};

void netdev_bonding_info_change(struct net_device *dev,
    struct netdev_bonding_info *bonding_info);


void ethtool_notify(struct net_device *dev, unsigned int cmd, const void *data);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
{
 return __skb_gso_segment(skb, features, true);
}
__be16 skb_network_protocol(struct sk_buff *skb, int *depth);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool can_checksum_protocol(netdev_features_t features,
      __be16 protocol)
{
 if (protocol == (( __be16)(__u16)(0x8906)))
  return !!(features & ((netdev_features_t)1 << (NETIF_F_FCOE_CRC_BIT)));



 if (features & ((netdev_features_t)1 << (NETIF_F_HW_CSUM_BIT))) {

  return true;
 }

 switch (protocol) {
 case (( __be16)(__u16)(0x0800)):
  return !!(features & ((netdev_features_t)1 << (NETIF_F_IP_CSUM_BIT)));
 case (( __be16)(__u16)(0x86DD)):
  return !!(features & ((netdev_features_t)1 << (NETIF_F_IPV6_CSUM_BIT)));
 default:
  return false;
 }
}


void netdev_rx_csum_fault(struct net_device *dev, struct sk_buff *skb);







void net_enable_timestamp(void);
void net_disable_timestamp(void);


int __attribute__((__section__(".init.text"))) __attribute__((__cold__)) dev_proc_init(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_tx_t __netdev_start_xmit(const struct net_device_ops *ops,
           struct sk_buff *skb, struct net_device *dev,
           bool more)
{
 ({ __this_cpu_preempt_check("write"); do { do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.more)) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }) = more; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }) = more; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }) = more; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }) = more; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 return ops->ndo_start_xmit(skb, dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netdev_xmit_more(void)
{
 return ({ __this_cpu_preempt_check("read"); ({ typeof(softnet_data.xmit.more) pscr_ret__; do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(softnet_data.xmit.more)) { case 1: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 2: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 4: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; case 8: pscr_ret__ = ({ *({ do { const void *__vpp_verify = (typeof((&(softnet_data.xmit.more)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more))); (typeof((typeof(*(&(softnet_data.xmit.more))) *)(&(softnet_data.xmit.more)))) (__ptr + ((local_paca->data_offset))); }); }); }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_tx_t netdev_start_xmit(struct sk_buff *skb, struct net_device *dev,
         struct netdev_queue *txq, bool more)
{
 const struct net_device_ops *ops = dev->netdev_ops;
 netdev_tx_t rc;

 rc = __netdev_start_xmit(ops, skb, dev, more);
 if (rc == NETDEV_TX_OK)
  txq_trans_update(txq);

 return rc;
}

int netdev_class_create_file_ns(const struct class_attribute *class_attr,
    const void *ns);
void netdev_class_remove_file_ns(const struct class_attribute *class_attr,
     const void *ns);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int netdev_class_create_file(const struct class_attribute *class_attr)
{
 return netdev_class_create_file_ns(class_attr, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netdev_class_remove_file(const struct class_attribute *class_attr)
{
 netdev_class_remove_file_ns(class_attr, ((void *)0));
}

extern const struct kobj_ns_type_operations net_ns_type_operations;

const char *netdev_drivername(const struct net_device *dev);

void linkwatch_run_queue(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_features_t netdev_intersect_features(netdev_features_t f1,
         netdev_features_t f2)
{
 if ((f1 ^ f2) & ((netdev_features_t)1 << (NETIF_F_HW_CSUM_BIT))) {
  if (f1 & ((netdev_features_t)1 << (NETIF_F_HW_CSUM_BIT)))
   f1 |= (((netdev_features_t)1 << (NETIF_F_IP_CSUM_BIT))|((netdev_features_t)1 << (NETIF_F_IPV6_CSUM_BIT)));
  else
   f2 |= (((netdev_features_t)1 << (NETIF_F_IP_CSUM_BIT))|((netdev_features_t)1 << (NETIF_F_IPV6_CSUM_BIT)));
 }

 return f1 & f2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_features_t netdev_get_wanted_features(
 struct net_device *dev)
{
 return (dev->features & ~dev->hw_features) | dev->wanted_features;
}
netdev_features_t netdev_increment_features(netdev_features_t all,
 netdev_features_t one, netdev_features_t mask);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_features_t netdev_add_tso_features(netdev_features_t features,
       netdev_features_t mask)
{
 return netdev_increment_features(features, (((netdev_features_t)1 << (NETIF_F_TSO_BIT)) | ((netdev_features_t)1 << (NETIF_F_TSO6_BIT)) | ((netdev_features_t)1 << (NETIF_F_TSO_ECN_BIT)) | ((netdev_features_t)1 << (NETIF_F_TSO_MANGLEID_BIT))), mask);
}

int __netdev_update_features(struct net_device *dev);
void netdev_update_features(struct net_device *dev);
void netdev_change_features(struct net_device *dev);

void netif_stacked_transfer_operstate(const struct net_device *rootdev,
     struct net_device *dev);

netdev_features_t passthru_features_check(struct sk_buff *skb,
       struct net_device *dev,
       netdev_features_t features);
netdev_features_t netif_skb_features(struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool net_gso_ok(netdev_features_t features, int gso_type)
{
 netdev_features_t feature = (netdev_features_t)gso_type << NETIF_F_GSO_SHIFT;


 do { extern void __compiletime_assert_4600(void) ; if (!(!(SKB_GSO_TCPV4 != (((netdev_features_t)1 << (NETIF_F_TSO_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4600(); } while (0);
 do { extern void __compiletime_assert_4601(void) ; if (!(!(SKB_GSO_DODGY != (((netdev_features_t)1 << (NETIF_F_GSO_ROBUST_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4601(); } while (0);
 do { extern void __compiletime_assert_4602(void) ; if (!(!(SKB_GSO_TCP_ECN != (((netdev_features_t)1 << (NETIF_F_TSO_ECN_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4602(); } while (0);
 do { extern void __compiletime_assert_4603(void) ; if (!(!(SKB_GSO_TCP_FIXEDID != (((netdev_features_t)1 << (NETIF_F_TSO_MANGLEID_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4603(); } while (0);
 do { extern void __compiletime_assert_4604(void) ; if (!(!(SKB_GSO_TCPV6 != (((netdev_features_t)1 << (NETIF_F_TSO6_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4604(); } while (0);
 do { extern void __compiletime_assert_4605(void) ; if (!(!(SKB_GSO_FCOE != (((netdev_features_t)1 << (NETIF_F_FSO_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4605(); } while (0);
 do { extern void __compiletime_assert_4606(void) ; if (!(!(SKB_GSO_GRE != (((netdev_features_t)1 << (NETIF_F_GSO_GRE_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4606(); } while (0);
 do { extern void __compiletime_assert_4607(void) ; if (!(!(SKB_GSO_GRE_CSUM != (((netdev_features_t)1 << (NETIF_F_GSO_GRE_CSUM_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4607(); } while (0);
 do { extern void __compiletime_assert_4608(void) ; if (!(!(SKB_GSO_IPXIP4 != (((netdev_features_t)1 << (NETIF_F_GSO_IPXIP4_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4608(); } while (0);
 do { extern void __compiletime_assert_4609(void) ; if (!(!(SKB_GSO_IPXIP6 != (((netdev_features_t)1 << (NETIF_F_GSO_IPXIP6_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4609(); } while (0);
 do { extern void __compiletime_assert_4610(void) ; if (!(!(SKB_GSO_UDP_TUNNEL != (((netdev_features_t)1 << (NETIF_F_GSO_UDP_TUNNEL_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4610(); } while (0);
 do { extern void __compiletime_assert_4611(void) ; if (!(!(SKB_GSO_UDP_TUNNEL_CSUM != (((netdev_features_t)1 << (NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4611(); } while (0);
 do { extern void __compiletime_assert_4612(void) ; if (!(!(SKB_GSO_PARTIAL != (((netdev_features_t)1 << (NETIF_F_GSO_PARTIAL_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4612(); } while (0);
 do { extern void __compiletime_assert_4613(void) ; if (!(!(SKB_GSO_TUNNEL_REMCSUM != (((netdev_features_t)1 << (NETIF_F_GSO_TUNNEL_REMCSUM_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4613(); } while (0);
 do { extern void __compiletime_assert_4614(void) ; if (!(!(SKB_GSO_SCTP != (((netdev_features_t)1 << (NETIF_F_GSO_SCTP_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4614(); } while (0);
 do { extern void __compiletime_assert_4615(void) ; if (!(!(SKB_GSO_ESP != (((netdev_features_t)1 << (NETIF_F_GSO_ESP_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4615(); } while (0);
 do { extern void __compiletime_assert_4616(void) ; if (!(!(SKB_GSO_UDP != (((netdev_features_t)1 << (NETIF_F_GSO_UDP_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4616(); } while (0);
 do { extern void __compiletime_assert_4617(void) ; if (!(!(SKB_GSO_UDP_L4 != (((netdev_features_t)1 << (NETIF_F_GSO_UDP_L4_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4617(); } while (0);
 do { extern void __compiletime_assert_4618(void) ; if (!(!(SKB_GSO_FRAGLIST != (((netdev_features_t)1 << (NETIF_F_GSO_FRAGLIST_BIT)) >> NETIF_F_GSO_SHIFT)))) __compiletime_assert_4618(); } while (0);

 return (features & feature) == feature;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_gso_ok(struct sk_buff *skb, netdev_features_t features)
{
 return net_gso_ok(features, ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type) &&
        (!skb_has_frag_list(skb) || (features & ((netdev_features_t)1 << (NETIF_F_FRAGLIST_BIT))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_needs_gso(struct sk_buff *skb,
       netdev_features_t features)
{
 return skb_is_gso(skb) && (!skb_gso_ok(skb, features) ||
  __builtin_expect(!!((skb->ip_summed != 3) && (skb->ip_summed != 1)), 0));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_set_gso_max_size(struct net_device *dev,
       unsigned int size)
{
 dev->gso_max_size = size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_gso_error_unwind(struct sk_buff *skb, __be16 protocol,
     int pulled_hlen, u16 mac_offset,
     int mac_len)
{
 skb->protocol = protocol;
 skb->encapsulation = 1;
 skb_push(skb, pulled_hlen);
 skb_reset_transport_header(skb);
 skb->mac_header = mac_offset;
 skb->network_header = skb->mac_header + mac_len;
 skb->mac_len = mac_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_macsec(const struct net_device *dev)
{
 return dev->priv_flags & IFF_MACSEC;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_macvlan(const struct net_device *dev)
{
 return dev->priv_flags & IFF_MACVLAN;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_macvlan_port(const struct net_device *dev)
{
 return dev->priv_flags & IFF_MACVLAN_PORT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_bond_master(const struct net_device *dev)
{
 return dev->flags & IFF_MASTER && dev->priv_flags & IFF_BONDING;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_bond_slave(const struct net_device *dev)
{
 return dev->flags & IFF_SLAVE && dev->priv_flags & IFF_BONDING;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_supports_nofcs(struct net_device *dev)
{
 return dev->priv_flags & IFF_SUPP_NOFCS;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_has_l3_rx_handler(const struct net_device *dev)
{
 return dev->priv_flags & IFF_L3MDEV_RX_HANDLER;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_l3_master(const struct net_device *dev)
{
 return dev->priv_flags & IFF_L3MDEV_MASTER;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_l3_slave(const struct net_device *dev)
{
 return dev->priv_flags & IFF_L3MDEV_SLAVE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_bridge_master(const struct net_device *dev)
{
 return dev->priv_flags & IFF_EBRIDGE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_bridge_port(const struct net_device *dev)
{
 return dev->priv_flags & IFF_BRIDGE_PORT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_ovs_master(const struct net_device *dev)
{
 return dev->priv_flags & IFF_OPENVSWITCH;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_ovs_port(const struct net_device *dev)
{
 return dev->priv_flags & IFF_OVS_DATAPATH;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_team_master(const struct net_device *dev)
{
 return dev->priv_flags & IFF_TEAM;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_team_port(const struct net_device *dev)
{
 return dev->priv_flags & IFF_TEAM_PORT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_lag_master(const struct net_device *dev)
{
 return netif_is_bond_master(dev) || netif_is_team_master(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_lag_port(const struct net_device *dev)
{
 return netif_is_bond_slave(dev) || netif_is_team_port(dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_rxfh_configured(const struct net_device *dev)
{
 return dev->priv_flags & IFF_RXFH_CONFIGURED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_failover(const struct net_device *dev)
{
 return dev->priv_flags & IFF_FAILOVER;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_is_failover_slave(const struct net_device *dev)
{
 return dev->priv_flags & IFF_FAILOVER_SLAVE;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void netif_keep_dst(struct net_device *dev)
{
 dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_reduces_vlan_mtu(struct net_device *dev)
{

 return dev->priv_flags & IFF_MACSEC;
}

extern struct pernet_operations loopback_net_ops;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *netdev_name(const struct net_device *dev)
{
 if (!dev->name[0] || strchr(dev->name, '%'))
  return "(unnamed net_device)";
 return dev->name;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netdev_unregistering(const struct net_device *dev)
{
 return dev->reg_state == NETREG_UNREGISTERING;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *netdev_reg_state(const struct net_device *dev)
{
 switch (dev->reg_state) {
 case NETREG_UNINITIALIZED: return " (uninitialized)";
 case NETREG_REGISTERED: return "";
 case NETREG_UNREGISTERING: return " (unregistering)";
 case NETREG_UNREGISTERED: return " (unregistered)";
 case NETREG_RELEASED: return " (released)";
 case NETREG_DUMMY: return " (dummy)";
 }

 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(1); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("%s: unknown reg_state %d\n", dev->name, dev->reg_state); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/netdevice.h"), "i" (4798), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return " (unknown)";
}

__attribute__((__format__(printf, 3, 4))) __attribute__((__cold__))
void netdev_printk(const char *level, const struct net_device *dev,
     const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_emerg(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_alert(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_crit(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_err(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_warn(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_notice(const struct net_device *dev, const char *format, ...);
__attribute__((__format__(printf, 2, 3))) __attribute__((__cold__))
void netdev_info(const struct net_device *dev, const char *format, ...);
# 4978 "/home/nathan/src/linux-next/include/linux/netdevice.h"
extern struct net_device *blackhole_netdev;
# 22 "/home/nathan/src/linux-next/include/linux/etherdevice.h" 2

# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unaligned.h" 1
# 10 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unaligned.h"
# 1 "/home/nathan/src/linux-next/include/linux/unaligned/access_ok.h" 1







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u16 get_unaligned_le16(const void *p)
{
 return __le16_to_cpup((__le16 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32 get_unaligned_le32(const void *p)
{
 return __le32_to_cpup((__le32 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u64 get_unaligned_le64(const void *p)
{
 return __le64_to_cpup((__le64 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u16 get_unaligned_be16(const void *p)
{
 return __be16_to_cpup((__be16 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32 get_unaligned_be32(const void *p)
{
 return __be32_to_cpup((__be32 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u64 get_unaligned_be64(const void *p)
{
 return __be64_to_cpup((__be64 *)p);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_le16(u16 val, void *p)
{
 *((__le16 *)p) = (( __le16)(__builtin_constant_p((__u16)((val))) ? ((__u16)( (((__u16)((val)) & (__u16)0x00ffU) << 8) | (((__u16)((val)) & (__u16)0xff00U) >> 8))) : __fswab16((val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_le32(u32 val, void *p)
{
 *((__le32 *)p) = (( __le32)(__builtin_constant_p((__u32)((val))) ? ((__u32)( (((__u32)((val)) & (__u32)0x000000ffUL) << 24) | (((__u32)((val)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((val)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((val)) & (__u32)0xff000000UL) >> 24))) : __fswab32((val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_le64(u64 val, void *p)
{
 *((__le64 *)p) = (( __le64)(__builtin_constant_p((__u64)((val))) ? ((__u64)( (((__u64)((val)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((val)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((val)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((val)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((val)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((val)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((val)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((val)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((val))));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_be16(u16 val, void *p)
{
 *((__be16 *)p) = (( __be16)(__u16)(val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_be32(u32 val, void *p)
{
 *((__be32 *)p) = (( __be32)(__u32)(val));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void put_unaligned_be64(u64 val, void *p)
{
 *((__be64 *)p) = (( __be64)(__u64)(val));
}
# 11 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unaligned.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/unaligned/generic.h" 1








extern void __bad_unaligned_access_size(void);
# 12 "/home/nathan/src/linux-next/arch/powerpc/include/asm/unaligned.h" 2
# 24 "/home/nathan/src/linux-next/include/linux/etherdevice.h" 2



struct device;
int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr);
unsigned char *arch_get_platform_mac_address(void);
int nvmem_get_mac_address(struct device *dev, void *addrbuf);
u32 eth_get_headlen(const struct net_device *dev, void *data, unsigned int len);
__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev);
extern const struct header_ops eth_header_ops;

int eth_header(struct sk_buff *skb, struct net_device *dev, unsigned short type,
        const void *daddr, const void *saddr, unsigned len);
int eth_header_parse(const struct sk_buff *skb, unsigned char *haddr);
int eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh,
       __be16 type);
void eth_header_cache_update(struct hh_cache *hh, const struct net_device *dev,
        const unsigned char *haddr);
__be16 eth_header_parse_protocol(const struct sk_buff *skb);
int eth_prepare_mac_addr_change(struct net_device *dev, void *p);
void eth_commit_mac_addr_change(struct net_device *dev, void *p);
int eth_mac_addr(struct net_device *dev, void *p);
int eth_validate_addr(struct net_device *dev);

struct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,
         unsigned int rxqs);



struct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,
        unsigned int txqs,
        unsigned int rxqs);


struct sk_buff *eth_gro_receive(struct list_head *head, struct sk_buff *skb);
int eth_gro_complete(struct sk_buff *skb, int nhoff);


static const u8 eth_reserved_addr_base[6] __attribute__((__aligned__(2))) =
{ 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
# 75 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_link_local_ether_addr(const u8 *addr)
{
 __be16 *a = (__be16 *)addr;
 static const __be16 *b = (const __be16 *)eth_reserved_addr_base;
 static const __be16 m = (( __be16)(__u16)(0xfff0));


 return (((*(const u32 *)addr) ^ (*(const u32 *)b)) |
  ( int)((a[2] ^ b[2]) & m)) == 0;



}
# 97 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_zero_ether_addr(const u8 *addr)
{

 return ((*(const u32 *)addr) | (*(const u16 *)(addr + 4))) == 0;





}
# 115 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_multicast_ether_addr(const u8 *addr)
{

 u32 a = *(const u32 *)addr;




 return 0x01 & (a >> ((sizeof(a) * 8) - 8));



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_multicast_ether_addr_64bits(const u8 addr[6+2])
{


 return 0x01 & ((*(const u64 *)addr) >> 56);






}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_local_ether_addr(const u8 *addr)
{
 return 0x02 & addr[0];
}
# 161 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_broadcast_ether_addr(const u8 *addr)
{
 return (*(const u16 *)(addr + 0) &
  *(const u16 *)(addr + 2) &
  *(const u16 *)(addr + 4)) == 0xffff;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_unicast_ether_addr(const u8 *addr)
{
 return !is_multicast_ether_addr(addr);
}
# 190 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_valid_ether_addr(const u8 *addr)
{


 return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
}
# 205 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eth_proto_is_802_3(__be16 proto)
{





 return ( u16)proto >= ( u16)(( __be16)(__u16)(0x0600));
}
# 222 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_random_addr(u8 *addr)
{
 get_random_bytes(addr, 6);
 addr[0] &= 0xfe;
 addr[0] |= 0x02;
}
# 237 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_broadcast_addr(u8 *addr)
{
 memset(addr, 0xff, 6);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_zero_addr(u8 *addr)
{
 memset(addr, 0x00, 6);
}
# 262 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_hw_addr_random(struct net_device *dev)
{
 dev->addr_assign_type = 1;
 eth_random_addr(dev->dev_addr);
}
# 275 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ether_addr_copy(u8 *dst, const u8 *src)
{

 *(u32 *)dst = *(const u32 *)src;
 *(u16 *)(dst + 4) = *(const u16 *)(src + 4);
# 288 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
}
# 298 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_hw_addr_inherit(struct net_device *dst,
           struct net_device *src)
{
 dst->addr_assign_type = src->addr_assign_type;
 ether_addr_copy(dst->dev_addr, src->dev_addr);
}
# 314 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ether_addr_equal(const u8 *addr1, const u8 *addr2)
{

 u32 fold = ((*(const u32 *)addr1) ^ (*(const u32 *)addr2)) |
     ((*(const u16 *)(addr1 + 4)) ^ (*(const u16 *)(addr2 + 4)));

 return fold == 0;






}
# 343 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ether_addr_equal_64bits(const u8 addr1[6+2],
        const u8 addr2[6+2])
{

 u64 fold = (*(const u64 *)addr1) ^ (*(const u64 *)addr2);


 return (fold >> 16) == 0;






}
# 368 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
{

 return ether_addr_equal(addr1, addr2);



}
# 387 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ether_addr_equal_masked(const u8 *addr1, const u8 *addr2,
        const u8 *mask)
{
 int i;

 for (i = 0; i < 6; i++) {
  if ((addr1[i] ^ addr2[i]) & mask[i])
   return false;
 }

 return true;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 ether_addr_to_u64(const u8 *addr)
{
 u64 u = 0;
 int i;

 for (i = 0; i < 6; i++)
  u = u << 8 | addr[i];

 return u;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void u64_to_ether_addr(u64 u, u8 *addr)
{
 int i;

 for (i = 6 - 1; i >= 0; i--) {
  addr[i] = u & 0xff;
  u = u >> 8;
 }
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_addr_dec(u8 *addr)
{
 u64 u = ether_addr_to_u64(addr);

 u--;
 u64_to_ether_addr(u, addr);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void eth_addr_inc(u8 *addr)
{
 u64 u = ether_addr_to_u64(addr);

 u++;
 u64_to_ether_addr(u, addr);
}
# 468 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_etherdev_addr(const struct net_device *dev,
        const u8 addr[6 + 2])
{
 struct netdev_hw_addr *ha;
 bool res = false;

 rcu_read_lock();
 for (({ ; }), ha = ({ void *__mptr = (void *)(({ union { typeof((&dev->dev_addrs.list)->next) __val; char __c[1]; } __u; if (1) __read_once_size(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); else __read_once_size_nocheck(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); do { } while (0); __u.__val; })); do { extern void __compiletime_assert_475(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(({ union { typeof((&dev->dev_addrs.list)->next) __val; char __c[1]; } __u; if (1) __read_once_size(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); else __read_once_size_nocheck(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); do { } while (0); __u.__val; }))), typeof(((typeof(*ha) *)0)->list)) && !__builtin_types_compatible_p(typeof(*(({ union { typeof((&dev->dev_addrs.list)->next) __val; char __c[1]; } __u; if (1) __read_once_size(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); else __read_once_size_nocheck(&((&dev->dev_addrs.list)->next), __u.__c, sizeof((&dev->dev_addrs.list)->next)); do { } while (0); __u.__val; }))), typeof(void))))) __compiletime_assert_475(); } while (0); ((typeof(*ha) *)(__mptr - __builtin_offsetof(typeof(*ha), list))); }); &ha->list != (&dev->dev_addrs.list); ha = ({ void *__mptr = (void *)(({ union { typeof(ha->list.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(ha->list.next), __u.__c, sizeof(ha->list.next)); else __read_once_size_nocheck(&(ha->list.next), __u.__c, sizeof(ha->list.next)); do { } while (0); __u.__val; })); do { extern void __compiletime_assert_475(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(({ union { typeof(ha->list.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(ha->list.next), __u.__c, sizeof(ha->list.next)); else __read_once_size_nocheck(&(ha->list.next), __u.__c, sizeof(ha->list.next)); do { } while (0); __u.__val; }))), typeof(((typeof(*ha) *)0)->list)) && !__builtin_types_compatible_p(typeof(*(({ union { typeof(ha->list.next) __val; char __c[1]; } __u; if (1) __read_once_size(&(ha->list.next), __u.__c, sizeof(ha->list.next)); else __read_once_size_nocheck(&(ha->list.next), __u.__c, sizeof(ha->list.next)); do { } while (0); __u.__val; }))), typeof(void))))) __compiletime_assert_475(); } while (0); ((typeof(*ha) *)(__mptr - __builtin_offsetof(typeof(*ha), list))); })) {
  res = ether_addr_equal_64bits(addr, ha->addr);
  if (res)
   break;
 }
 rcu_read_unlock();
 return res;
}
# 497 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long compare_ether_header(const void *a, const void *b)
{

 unsigned long fold;
# 510 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
 fold = *(unsigned long *)a ^ *(unsigned long *)b;
 fold |= *(unsigned long *)(a + 6) ^ *(unsigned long *)(b + 6);
 return fold;







}
# 529 "/home/nathan/src/linux-next/include/linux/etherdevice.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int eth_skb_pad(struct sk_buff *skb)
{
 return skb_put_padto(skb, 60);
}
# 19 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2

# 1 "/home/nathan/src/linux-next/include/net/tcp.h" 1
# 20 "/home/nathan/src/linux-next/include/net/tcp.h"
# 1 "/home/nathan/src/linux-next/include/linux/tcp.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/tcp.h"
# 1 "/home/nathan/src/linux-next/include/linux/win_minmax.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/win_minmax.h"
struct minmax_sample {
 u32 t;
 u32 v;
};


struct minmax {
 struct minmax_sample s[3];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 minmax_get(const struct minmax *m)
{
 return m->s[0].v;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 minmax_reset(struct minmax *m, u32 t, u32 meas)
{
 struct minmax_sample val = { .t = t, .v = meas };

 m->s[2] = m->s[1] = m->s[0] = val;
 return m->s[0].v;
}

u32 minmax_running_max(struct minmax *m, u32 win, u32 t, u32 meas);
u32 minmax_running_min(struct minmax *m, u32 win, u32 t, u32 meas);
# 19 "/home/nathan/src/linux-next/include/linux/tcp.h" 2
# 1 "/home/nathan/src/linux-next/include/net/sock.h" 1
# 52 "/home/nathan/src/linux-next/include/net/sock.h"
# 1 "/home/nathan/src/linux-next/include/linux/page_counter.h" 1








struct page_counter {
 atomic_long_t usage;
 unsigned long min;
 unsigned long low;
 unsigned long max;
 struct page_counter *parent;


 unsigned long emin;
 atomic_long_t min_usage;
 atomic_long_t children_min_usage;


 unsigned long elow;
 atomic_long_t low_usage;
 atomic_long_t children_low_usage;


 unsigned long watermark;
 unsigned long failcnt;
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_counter_init(struct page_counter *counter,
         struct page_counter *parent)
{
 atomic_long_set(&counter->usage, 0);
 counter->max = (((long)(~0UL >> 1)) / (1UL << 16));
 counter->parent = parent;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long page_counter_read(struct page_counter *counter)
{
 return atomic_long_read(&counter->usage);
}

void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages);
void page_counter_charge(struct page_counter *counter, unsigned long nr_pages);
bool page_counter_try_charge(struct page_counter *counter,
        unsigned long nr_pages,
        struct page_counter **fail);
void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages);
void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages);
void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages);
int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages);
int page_counter_memparse(const char *buf, const char *max,
     unsigned long *nr_pages);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void page_counter_reset_watermark(struct page_counter *counter)
{
 counter->watermark = page_counter_read(counter);
}
# 53 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/memcontrol.h" 1
# 18 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
# 1 "/home/nathan/src/linux-next/include/linux/vmpressure.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/vmpressure.h"
# 1 "/home/nathan/src/linux-next/include/linux/eventfd.h" 1
# 32 "/home/nathan/src/linux-next/include/linux/eventfd.h"
struct eventfd_ctx;
struct file;



void eventfd_ctx_put(struct eventfd_ctx *ctx);
struct file *eventfd_fget(int fd);
struct eventfd_ctx *eventfd_ctx_fdget(int fd);
struct eventfd_ctx *eventfd_ctx_fileget(struct file *file);
__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n);
int eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_entry_t *wait,
      __u64 *cnt);

extern __attribute__((section(".data..percpu" ""))) __typeof__(int) eventfd_wake_count;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eventfd_signal_count(void)
{
 return ({ typeof(eventfd_wake_count) pscr_ret__; do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(eventfd_wake_count)) { case 1: pscr_ret__ = ({ typeof(eventfd_wake_count) __ret; if ((sizeof(eventfd_wake_count) == sizeof(char) || sizeof(eventfd_wake_count) == sizeof(short) || sizeof(eventfd_wake_count) == sizeof(int) || sizeof(eventfd_wake_count) == sizeof(long))) __ret = ({ typeof(eventfd_wake_count) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(eventfd_wake_count) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 2: pscr_ret__ = ({ typeof(eventfd_wake_count) __ret; if ((sizeof(eventfd_wake_count) == sizeof(char) || sizeof(eventfd_wake_count) == sizeof(short) || sizeof(eventfd_wake_count) == sizeof(int) || sizeof(eventfd_wake_count) == sizeof(long))) __ret = ({ typeof(eventfd_wake_count) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(eventfd_wake_count) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 4: pscr_ret__ = ({ typeof(eventfd_wake_count) __ret; if ((sizeof(eventfd_wake_count) == sizeof(char) || sizeof(eventfd_wake_count) == sizeof(short) || sizeof(eventfd_wake_count) == sizeof(int) || sizeof(eventfd_wake_count) == sizeof(long))) __ret = ({ typeof(eventfd_wake_count) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(eventfd_wake_count) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; case 8: pscr_ret__ = ({ typeof(eventfd_wake_count) __ret; if ((sizeof(eventfd_wake_count) == sizeof(char) || sizeof(eventfd_wake_count) == sizeof(short) || sizeof(eventfd_wake_count) == sizeof(int) || sizeof(eventfd_wake_count) == sizeof(long))) __ret = ({ typeof(eventfd_wake_count) __ret; __asm__ __volatile__("" : : : "memory"); __ret = ({ union { typeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })) __val; char __c[1]; } __u; if (1) __read_once_size(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); else __read_once_size_nocheck(&(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); })), __u.__c, sizeof(*({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }))); do { } while (0); __u.__val; }); __asm__ __volatile__("" : : : "memory"); __ret; }); else __ret = ({ typeof(eventfd_wake_count) __ret; unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); __ret = ({ *({ do { const void *__vpp_verify = (typeof((&(eventfd_wake_count)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count))); (typeof((typeof(*(&(eventfd_wake_count))) *)(&(eventfd_wake_count)))) (__ptr + ((local_paca->data_offset))); }); }); }); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); __ret; }); __ret; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; });
}
# 12 "/home/nathan/src/linux-next/include/linux/vmpressure.h" 2

struct vmpressure {
 unsigned long scanned;
 unsigned long reclaimed;

 unsigned long tree_scanned;
 unsigned long tree_reclaimed;

 spinlock_t sr_lock;


 struct list_head events;

 struct mutex events_lock;

 struct work_struct work;
};

struct mem_cgroup;


extern void vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,
         unsigned long scanned, unsigned long reclaimed);
extern void vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio);

extern void vmpressure_init(struct vmpressure *vmpr);
extern void vmpressure_cleanup(struct vmpressure *vmpr);
extern struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg);
extern struct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr);
extern int vmpressure_register_event(struct mem_cgroup *memcg,
         struct eventfd_ctx *eventfd,
         const char *args);
extern void vmpressure_unregister_event(struct mem_cgroup *memcg,
     struct eventfd_ctx *eventfd);
# 19 "/home/nathan/src/linux-next/include/linux/memcontrol.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/writeback.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/writeback.h"
# 1 "/home/nathan/src/linux-next/include/linux/flex_proportions.h" 1
# 28 "/home/nathan/src/linux-next/include/linux/flex_proportions.h"
struct fprop_global {

 struct percpu_counter events;

 unsigned int period;

 seqcount_t sequence;
};

int fprop_global_init(struct fprop_global *p, gfp_t gfp);
void fprop_global_destroy(struct fprop_global *p);
bool fprop_new_period(struct fprop_global *p, int periods);




struct fprop_local_single {

 unsigned long events;

 unsigned int period;
 raw_spinlock_t lock;
};





int fprop_local_init_single(struct fprop_local_single *pl);
void fprop_local_destroy_single(struct fprop_local_single *pl);
void __fprop_inc_single(struct fprop_global *p, struct fprop_local_single *pl);
void fprop_fraction_single(struct fprop_global *p,
 struct fprop_local_single *pl, unsigned long *numerator,
 unsigned long *denominator);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void fprop_inc_single(struct fprop_global *p, struct fprop_local_single *pl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __fprop_inc_single(p, pl);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}




struct fprop_local_percpu {

 struct percpu_counter events;

 unsigned int period;
 raw_spinlock_t lock;
};

int fprop_local_init_percpu(struct fprop_local_percpu *pl, gfp_t gfp);
void fprop_local_destroy_percpu(struct fprop_local_percpu *pl);
void __fprop_inc_percpu(struct fprop_global *p, struct fprop_local_percpu *pl);
void __fprop_inc_percpu_max(struct fprop_global *p, struct fprop_local_percpu *pl,
       int max_frac);
void fprop_fraction_percpu(struct fprop_global *p,
 struct fprop_local_percpu *pl, unsigned long *numerator,
 unsigned long *denominator);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void fprop_inc_percpu(struct fprop_global *p, struct fprop_local_percpu *pl)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __fprop_inc_percpu(p, pl);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}
# 12 "/home/nathan/src/linux-next/include/linux/writeback.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
struct page;
struct device;
struct dentry;




enum wb_state {
 WB_registered,
 WB_writeback_running,
 WB_has_dirty_io,
 WB_start_all,
};

enum wb_congested_state {
 WB_async_congested,
 WB_sync_congested,
};

typedef int (congested_fn)(void *, int);

enum wb_stat_item {
 WB_RECLAIMABLE,
 WB_WRITEBACK,
 WB_DIRTIED,
 WB_WRITTEN,
 NR_WB_STAT_ITEMS
};






enum wb_reason {
 WB_REASON_BACKGROUND,
 WB_REASON_VMSCAN,
 WB_REASON_SYNC,
 WB_REASON_PERIODIC,
 WB_REASON_LAPTOP_TIMER,
 WB_REASON_FREE_MORE_MEM,
 WB_REASON_FS_FREE_SPACE,






 WB_REASON_FORKER_THREAD,
 WB_REASON_FOREIGN_FLUSH,

 WB_REASON_MAX,
};

struct wb_completion {
 atomic_t cnt;
 wait_queue_head_t *waitq;
};
# 98 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
 unsigned long state;
 refcount_t refcnt;
# 109 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
};
# 130 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
struct bdi_writeback {
 struct backing_dev_info *bdi;

 unsigned long state;
 unsigned long last_old_flush;

 struct list_head b_dirty;
 struct list_head b_io;
 struct list_head b_more_io;
 struct list_head b_dirty_time;
 spinlock_t list_lock;

 struct percpu_counter stat[NR_WB_STAT_ITEMS];

 struct bdi_writeback_congested *congested;

 unsigned long bw_time_stamp;
 unsigned long dirtied_stamp;
 unsigned long written_stamp;
 unsigned long write_bandwidth;
 unsigned long avg_write_bandwidth;







 unsigned long dirty_ratelimit;
 unsigned long balanced_dirty_ratelimit;

 struct fprop_local_percpu completions;
 int dirty_exceeded;
 enum wb_reason start_all_reason;

 spinlock_t work_lock;
 struct list_head work_list;
 struct delayed_work dwork;

 unsigned long dirty_sleep;

 struct list_head bdi_node;
# 186 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
};

struct backing_dev_info {
 u64 id;
 struct rb_node rb_node;
 struct list_head bdi_list;
 unsigned long ra_pages;
 unsigned long io_pages;
 congested_fn *congested_fn;
 void *congested_data;

 const char *name;

 struct kref refcnt;
 unsigned int capabilities;
 unsigned int min_ratio;
 unsigned int max_ratio, max_prop_frac;





 atomic_long_t tot_write_bandwidth;

 struct bdi_writeback wb;
 struct list_head wb_list;






 struct bdi_writeback_congested *wb_congested;

 wait_queue_head_t wb_waitq;

 struct device *dev;
 struct device *owner;

 struct timer_list laptop_mode_wb_timer;


 struct dentry *debug_dir;

};

enum {
 BLK_RW_ASYNC = 0,
 BLK_RW_SYNC = 1,
};

void clear_wb_congested(struct bdi_writeback_congested *congested, int sync);
void set_wb_congested(struct bdi_writeback_congested *congested, int sync);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_bdi_congested(struct backing_dev_info *bdi, int sync)
{
 clear_wb_congested(bdi->wb.congested, sync);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_bdi_congested(struct backing_dev_info *bdi, int sync)
{
 set_wb_congested(bdi->wb.congested, sync);
}

struct wb_lock_cookie {
 bool locked;
 unsigned long flags;
};
# 309 "/home/nathan/src/linux-next/include/linux/backing-dev-defs.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wb_tryget(struct bdi_writeback *wb)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wb_get(struct bdi_writeback *wb)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wb_put(struct bdi_writeback *wb)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool wb_dying(struct bdi_writeback *wb)
{
 return false;
}
# 13 "/home/nathan/src/linux-next/include/linux/writeback.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/blk_types.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/blk_types.h"
struct bio_set;
struct bio;
struct bio_integrity_payload;
struct page;
struct block_device;
struct io_context;
struct cgroup_subsys_state;
typedef void (bio_end_io_t) (struct bio *);
# 29 "/home/nathan/src/linux-next/include/linux/blk_types.h"
typedef u8 blk_status_t;
# 78 "/home/nathan/src/linux-next/include/linux/blk_types.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_path_error(blk_status_t error)
{
 switch (error) {
 case (( blk_status_t)1):
 case (( blk_status_t)3):
 case (( blk_status_t)5):
 case (( blk_status_t)6):
 case (( blk_status_t)7):
 case (( blk_status_t)8):
  return false;
 }


 return true;
}
# 112 "/home/nathan/src/linux-next/include/linux/blk_types.h"
struct bio_issue {
 u64 value;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 __bio_issue_time(u64 time)
{
 return time & ((1ULL << ((64 - 1) - 12)) - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 bio_issue_time(struct bio_issue *issue)
{
 return __bio_issue_time(issue->value);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t bio_issue_size(struct bio_issue *issue)
{
 return ((issue->value & (((1ULL << 12) - 1) << ((64 - 1) - 12))) >> ((64 - 1) - 12));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_issue_init(struct bio_issue *issue,
           sector_t size)
{
 size &= (1ULL << 12) - 1;
 issue->value = ((issue->value & (~((1ULL << (64 - 1)) - 1))) |
   (ktime_get_ns() & ((1ULL << ((64 - 1) - 12)) - 1)) |
   ((u64)size << ((64 - 1) - 12)));
}





struct bio {
 struct bio *bi_next;
 struct gendisk *bi_disk;
 unsigned int bi_opf;



 unsigned short bi_flags;
 unsigned short bi_ioprio;
 unsigned short bi_write_hint;
 blk_status_t bi_status;
 u8 bi_partno;
 atomic_t __bi_remaining;

 struct bvec_iter bi_iter;

 bio_end_io_t *bi_end_io;

 void *bi_private;
# 176 "/home/nathan/src/linux-next/include/linux/blk_types.h"
 union {



 };

 unsigned short bi_vcnt;





 unsigned short bi_max_vecs;

 atomic_t __bi_cnt;

 struct bio_vec *bi_io_vec;

 struct bio_set *bi_pool;






 struct bio_vec bi_inline_vecs[0];
};






enum {
 BIO_NO_PAGE_REF,
 BIO_CLONED,
 BIO_BOUNCED,
 BIO_USER_MAPPED,
 BIO_NULL_MAPPED,
 BIO_WORKINGSET,
 BIO_QUIET,
 BIO_CHAIN,
 BIO_REFFED,
 BIO_THROTTLED,

 BIO_TRACE_COMPLETION,

 BIO_QUEUE_ENTERED,
 BIO_TRACKED,
 BIO_FLAG_LAST
};
# 255 "/home/nathan/src/linux-next/include/linux/blk_types.h"
typedef __u32 blk_mq_req_flags_t;
# 274 "/home/nathan/src/linux-next/include/linux/blk_types.h"
enum req_opf {

 REQ_OP_READ = 0,

 REQ_OP_WRITE = 1,

 REQ_OP_FLUSH = 2,

 REQ_OP_DISCARD = 3,

 REQ_OP_SECURE_ERASE = 5,

 REQ_OP_ZONE_RESET = 6,

 REQ_OP_WRITE_SAME = 7,

 REQ_OP_ZONE_RESET_ALL = 8,

 REQ_OP_WRITE_ZEROES = 9,

 REQ_OP_ZONE_OPEN = 10,

 REQ_OP_ZONE_CLOSE = 11,

 REQ_OP_ZONE_FINISH = 12,


 REQ_OP_SCSI_IN = 32,
 REQ_OP_SCSI_OUT = 33,

 REQ_OP_DRV_IN = 34,
 REQ_OP_DRV_OUT = 35,

 REQ_OP_LAST,
};

enum req_flag_bits {
 __REQ_FAILFAST_DEV =
  8,
 __REQ_FAILFAST_TRANSPORT,
 __REQ_FAILFAST_DRIVER,
 __REQ_SYNC,
 __REQ_META,
 __REQ_PRIO,
 __REQ_NOMERGE,
 __REQ_IDLE,
 __REQ_INTEGRITY,
 __REQ_FUA,
 __REQ_PREFLUSH,
 __REQ_RAHEAD,
 __REQ_BACKGROUND,
 __REQ_NOWAIT,
 __REQ_NOWAIT_INLINE,







 __REQ_CGROUP_PUNT,


 __REQ_NOUNMAP,

 __REQ_HIPRI,


 __REQ_DRV,
 __REQ_SWAP,
 __REQ_NR_BITS,
};
# 376 "/home/nathan/src/linux-next/include/linux/blk_types.h"
enum stat_group {
 STAT_READ,
 STAT_WRITE,
 STAT_DISCARD,
 STAT_FLUSH,

 NR_STAT_GROUPS
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_set_op_attrs(struct bio *bio, unsigned op,
  unsigned op_flags)
{
 bio->bi_opf = op | op_flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool op_is_write(unsigned int op)
{
 return (op & 1);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool op_is_flush(unsigned int op)
{
 return op & ((1ULL << __REQ_FUA) | (1ULL << __REQ_PREFLUSH));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool op_is_sync(unsigned int op)
{
 return (op & ((1 << 8) - 1)) == REQ_OP_READ ||
  (op & ((1ULL << __REQ_SYNC) | (1ULL << __REQ_FUA) | (1ULL << __REQ_PREFLUSH)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool op_is_discard(unsigned int op)
{
 return (op & ((1 << 8) - 1)) == REQ_OP_DISCARD;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool op_is_zone_mgmt(enum req_opf op)
{
 switch (op & ((1 << 8) - 1)) {
 case REQ_OP_ZONE_RESET:
 case REQ_OP_ZONE_OPEN:
 case REQ_OP_ZONE_CLOSE:
 case REQ_OP_ZONE_FINISH:
  return true;
 default:
  return false;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int op_stat_group(unsigned int op)
{
 if (op_is_discard(op))
  return STAT_DISCARD;
 return op_is_write(op);
}

typedef unsigned int blk_qc_t;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_qc_t_valid(blk_qc_t cookie)
{
 return cookie != -1U && cookie != -2U;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_qc_t_to_queue_num(blk_qc_t cookie)
{
 return (cookie & ~(1U << 31)) >> 16;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_qc_t_to_tag(blk_qc_t cookie)
{
 return cookie & ((1u << 16) - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_qc_t_is_internal(blk_qc_t cookie)
{
 return (cookie & (1U << 31)) != 0;
}

struct blk_rq_stat {
 u64 mean;
 u64 min;
 u64 max;
 u32 nr_samples;
 u64 batch;
};
# 14 "/home/nathan/src/linux-next/include/linux/writeback.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/blk-cgroup.h" 1
# 23 "/home/nathan/src/linux-next/include/linux/blk-cgroup.h"
# 1 "/home/nathan/src/linux-next/include/linux/blkdev.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/blkdev.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/major.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/genhd.h" 1
# 29 "/home/nathan/src/linux-next/include/linux/genhd.h"
extern struct device_type part_type;
extern struct kobject *block_depr;
extern struct class block_class;

enum {


 DOS_EXTENDED_PARTITION = 5,
 LINUX_EXTENDED_PARTITION = 0x85,
 WIN98_EXTENDED_PARTITION = 0x0f,

 SUN_WHOLE_DISK = DOS_EXTENDED_PARTITION,

 LINUX_SWAP_PARTITION = 0x82,
 LINUX_DATA_PARTITION = 0x83,
 LINUX_LVM_PARTITION = 0x8e,
 LINUX_RAID_PARTITION = 0xfd,

 SOLARIS_X86_PARTITION = LINUX_SWAP_PARTITION,
 NEW_SOLARIS_X86_PARTITION = 0xbf,

 DM6_AUX1PARTITION = 0x51,
 DM6_AUX3PARTITION = 0x53,
 DM6_PARTITION = 0x54,
 EZD_PARTITION = 0x55,

 FREEBSD_PARTITION = 0xa5,
 OPENBSD_PARTITION = 0xa6,
 NETBSD_PARTITION = 0xa9,
 BSDI_PARTITION = 0xb7,
 MINIX_PARTITION = 0x81,
 UNIXWARE_PARTITION = 0x63,
};
# 73 "/home/nathan/src/linux-next/include/linux/genhd.h"
struct partition {
 unsigned char boot_ind;
 unsigned char head;
 unsigned char sector;
 unsigned char cyl;
 unsigned char sys_ind;
 unsigned char end_head;
 unsigned char end_sector;
 unsigned char end_cyl;
 __le32 start_sect;
 __le32 nr_sects;
} __attribute__((packed));

struct disk_stats {
 u64 nsecs[NR_STAT_GROUPS];
 unsigned long sectors[NR_STAT_GROUPS];
 unsigned long ios[NR_STAT_GROUPS];
 unsigned long merges[NR_STAT_GROUPS];
 unsigned long io_ticks;
 unsigned long time_in_queue;
 local_t in_flight[2];
};
# 103 "/home/nathan/src/linux-next/include/linux/genhd.h"
struct partition_meta_info {
 char uuid[(36 + 1)];
 u8 volname[64];
};

struct hd_struct {
 sector_t start_sect;





 sector_t nr_sects;
 seqcount_t nr_sects_seq;
 sector_t alignment_offset;
 unsigned int discard_alignment;
 struct device __dev;
 struct kobject *holder_dir;
 int policy, partno;
 struct partition_meta_info *info;



 unsigned long stamp;

 struct disk_stats *dkstats;



 struct percpu_ref ref;
 struct rcu_work rcu_work;
};
# 148 "/home/nathan/src/linux-next/include/linux/genhd.h"
enum {
 DISK_EVENT_MEDIA_CHANGE = 1 << 0,
 DISK_EVENT_EJECT_REQUEST = 1 << 1,
};

enum {

 DISK_EVENT_FLAG_POLL = 1 << 0,

 DISK_EVENT_FLAG_UEVENT = 1 << 1,
};

struct disk_part_tbl {
 struct callback_head callback_head;
 int len;
 struct hd_struct *last_lookup;
 struct hd_struct *part[];
};

struct disk_events;
struct badblocks;
# 182 "/home/nathan/src/linux-next/include/linux/genhd.h"
struct gendisk {



 int major;
 int first_minor;
 int minors;


 char disk_name[32];
 char *(*devnode)(struct gendisk *gd, umode_t *mode);

 unsigned short events;
 unsigned short event_flags;






 struct disk_part_tbl *part_tbl;
 struct hd_struct part0;

 const struct block_device_operations *fops;
 struct request_queue *queue;
 void *private_data;

 int flags;
 struct rw_semaphore lookup_sem;
 struct kobject *slave_dir;

 struct timer_rand_state *random;
 atomic_t sync_io;
 struct disk_events *ev;



 int node_id;
 struct badblocks *bb;
 struct lockdep_map lockdep_map;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct gendisk *part_to_disk(struct hd_struct *part)
{
 if (__builtin_expect(!!(part), 1)) {
  if (part->partno)
   return ({ void *__mptr = (void *)(((&((part)->__dev))->parent)); do { extern void __compiletime_assert_228(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(((&((part)->__dev))->parent))), typeof(((struct gendisk *)0)->part0.__dev)) && !__builtin_types_compatible_p(typeof(*(((&((part)->__dev))->parent))), typeof(void))))) __compiletime_assert_228(); } while (0); ((struct gendisk *)(__mptr - __builtin_offsetof(struct gendisk, part0.__dev))); });
  else
   return ({ void *__mptr = (void *)(((&((part)->__dev)))); do { extern void __compiletime_assert_230(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(((&((part)->__dev))))), typeof(((struct gendisk *)0)->part0.__dev)) && !__builtin_types_compatible_p(typeof(*(((&((part)->__dev))))), typeof(void))))) __compiletime_assert_230(); } while (0); ((struct gendisk *)(__mptr - __builtin_offsetof(struct gendisk, part0.__dev))); });
 }
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int disk_max_parts(struct gendisk *disk)
{
 if (disk->flags & 64)
  return 256;
 return disk->minors;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool disk_part_scan_enabled(struct gendisk *disk)
{
 return disk_max_parts(disk) > 1 &&
  !(disk->flags & 512);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool disk_has_partitions(struct gendisk *disk)
{
 bool ret = false;

 rcu_read_lock();
 if (({ typeof(*(disk->part_tbl)) *________p1 = (typeof(*(disk->part_tbl)) *)({ union { typeof((disk->part_tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((disk->part_tbl)), __u.__c, sizeof((disk->part_tbl))); else __read_once_size_nocheck(&((disk->part_tbl)), __u.__c, sizeof((disk->part_tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(disk->part_tbl)) *)(________p1)); })->len > 1)
  ret = true;
 rcu_read_unlock();

 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t disk_devt(struct gendisk *disk)
{
 return (((disk->major) << 20) | (disk->first_minor));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) dev_t part_devt(struct hd_struct *part)
{
 return (&((part)->__dev))->devt;
}

extern struct hd_struct *__disk_get_part(struct gendisk *disk, int partno);
extern struct hd_struct *disk_get_part(struct gendisk *disk, int partno);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void disk_put_part(struct hd_struct *part)
{
 if (__builtin_expect(!!(part), 1))
  put_device((&((part)->__dev)));
}
# 287 "/home/nathan/src/linux-next/include/linux/genhd.h"
struct disk_part_iter {
 struct gendisk *disk;
 struct hd_struct *part;
 int idx;
 unsigned int flags;
};

extern void disk_part_iter_init(struct disk_part_iter *piter,
     struct gendisk *disk, unsigned int flags);
extern struct hd_struct *disk_part_iter_next(struct disk_part_iter *piter);
extern void disk_part_iter_exit(struct disk_part_iter *piter);

extern struct hd_struct *disk_map_sector_rcu(struct gendisk *disk,
          sector_t sector);
# 333 "/home/nathan/src/linux-next/include/linux/genhd.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void part_stat_set_all(struct hd_struct *part, int value)
{
 int i;

 for (((i)) = -1; ((i)) = cpumask_next(((i)), (((const struct cpumask *)&__cpu_possible_mask))), ((i)) < nr_cpu_ids;)
  memset(({ do { const void *__vpp_verify = (typeof((part->dkstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((part->dkstats))) *)((part->dkstats))); (typeof((typeof(*((part->dkstats))) *)((part->dkstats)))) (__ptr + (((__per_cpu_offset[(i)])))); }); }), value,
    sizeof(struct disk_stats));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int init_part_stats(struct hd_struct *part)
{
 part->dkstats = (typeof(struct disk_stats) *)__alloc_percpu(sizeof(struct disk_stats), __alignof__(struct disk_stats));
 if (!part->dkstats)
  return 0;
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_part_stats(struct hd_struct *part)
{
 free_percpu(part->dkstats);
}
# 413 "/home/nathan/src/linux-next/include/linux/genhd.h"
unsigned int part_in_flight(struct request_queue *q, struct hd_struct *part);
void part_in_flight_rw(struct request_queue *q, struct hd_struct *part,
         unsigned int inflight[2]);
void part_dec_in_flight(struct request_queue *q, struct hd_struct *part,
   int rw);
void part_inc_in_flight(struct request_queue *q, struct hd_struct *part,
   int rw);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct partition_meta_info *alloc_part_info(struct gendisk *disk)
{
 if (disk)
  return kzalloc_node(sizeof(struct partition_meta_info),
        ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)), disk->node_id);
 return kzalloc(sizeof(struct partition_meta_info), ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void free_part_info(struct hd_struct *part)
{
 kfree(part->info);
}

void update_io_ticks(struct hd_struct *part, unsigned long now);


extern void device_add_disk(struct device *parent, struct gendisk *disk,
       const struct attribute_group **groups);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_disk(struct gendisk *disk)
{
 device_add_disk(((void *)0), disk, ((void *)0));
}
extern void device_add_disk_no_queue_reg(struct device *parent, struct gendisk *disk);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void add_disk_no_queue_reg(struct gendisk *disk)
{
 device_add_disk_no_queue_reg(((void *)0), disk);
}

extern void del_gendisk(struct gendisk *gp);
extern struct gendisk *get_gendisk(dev_t dev, int *partno);
extern struct block_device *bdget_disk(struct gendisk *disk, int partno);

extern void set_device_ro(struct block_device *bdev, int flag);
extern void set_disk_ro(struct gendisk *disk, int flag);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int get_disk_ro(struct gendisk *disk)
{
 return disk->part0.policy;
}

extern void disk_block_events(struct gendisk *disk);
extern void disk_unblock_events(struct gendisk *disk);
extern void disk_flush_events(struct gendisk *disk, unsigned int mask);
extern unsigned int disk_clear_events(struct gendisk *disk, unsigned int mask);


extern void add_disk_randomness(struct gendisk *disk) ;
extern void rand_initialize_disk(struct gendisk *disk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t get_start_sect(struct block_device *bdev)
{
 return bdev->bd_part->start_sect;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t get_capacity(struct gendisk *disk)
{
 return disk->part0.nr_sects;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_capacity(struct gendisk *disk, sector_t size)
{
 disk->part0.nr_sects = size;
}
# 630 "/home/nathan/src/linux-next/include/linux/genhd.h"
extern int blk_alloc_devt(struct hd_struct *part, dev_t *devt);
extern void blk_free_devt(dev_t devt);
extern void blk_invalidate_devt(dev_t devt);
extern dev_t blk_lookup_devt(const char *name, int partno);
extern char *disk_name (struct gendisk *hd, int partno, char *buf);

int bdev_disk_changed(struct block_device *bdev, bool invalidate);
int blk_add_partitions(struct gendisk *disk, struct block_device *bdev);
int blk_drop_partitions(struct gendisk *disk, struct block_device *bdev);
extern int disk_expand_part_tbl(struct gendisk *disk, int target);
extern struct hd_struct * __attribute__((__warn_unused_result__)) add_partition(struct gendisk *disk,
           int partno, sector_t start,
           sector_t len, int flags,
           struct partition_meta_info
             *info);
extern void __delete_partition(struct percpu_ref *);
extern void delete_partition(struct gendisk *, int);
extern void printk_all_partitions(void);

extern struct gendisk *__alloc_disk_node(int minors, int node_id);
extern struct kobject *get_disk_and_module(struct gendisk *disk);
extern void put_disk(struct gendisk *disk);
extern void put_disk_and_module(struct gendisk *disk);
extern void blk_register_region(dev_t devt, unsigned long range,
   struct module *module,
   struct kobject *(*probe)(dev_t, int *, void *),
   int (*lock)(dev_t, void *),
   void *data);
extern void blk_unregister_region(dev_t devt, unsigned long range);

extern ssize_t part_size_show(struct device *dev,
         struct device_attribute *attr, char *buf);
extern ssize_t part_stat_show(struct device *dev,
         struct device_attribute *attr, char *buf);
extern ssize_t part_inflight_show(struct device *dev,
         struct device_attribute *attr, char *buf);
# 692 "/home/nathan/src/linux-next/include/linux/genhd.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hd_ref_init(struct hd_struct *part)
{
 if (percpu_ref_init(&part->ref, __delete_partition, 0,
    ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u))))
  return -12;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hd_struct_get(struct hd_struct *part)
{
 percpu_ref_get(&part->ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int hd_struct_try_get(struct hd_struct *part)
{
 return percpu_ref_tryget_live(&part->ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hd_struct_put(struct hd_struct *part)
{
 percpu_ref_put(&part->ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hd_struct_kill(struct hd_struct *part)
{
 percpu_ref_kill(&part->ref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hd_free_part(struct hd_struct *part)
{
 free_part_stats(part);
 free_part_info(part);
 percpu_ref_exit(&part->ref);
}
# 736 "/home/nathan/src/linux-next/include/linux/genhd.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t part_nr_sects_read(struct hd_struct *part)
{
# 754 "/home/nathan/src/linux-next/include/linux/genhd.h"
 return part->nr_sects;

}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void part_nr_sects_write(struct hd_struct *part, sector_t size)
{
# 774 "/home/nathan/src/linux-next/include/linux/genhd.h"
 part->nr_sects = size;

}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_integrity_add(struct gendisk *disk) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_integrity_del(struct gendisk *disk) { }
# 12 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/pagemap.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/pagemap.h"
# 1 "/home/nathan/src/linux-next/include/linux/highmem.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/highmem.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cacheflush.h" 1
# 32 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cacheflush.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_cache_vmap(unsigned long start, unsigned long end)
{
 asm volatile("ptesync" ::: "memory");
}





extern void flush_dcache_page(struct page *page);



void flush_icache_range(unsigned long start, unsigned long stop);
extern void flush_icache_user_range(struct vm_area_struct *vma,
        struct page *page, unsigned long addr,
        int len);
extern void flush_dcache_icache_page(struct page *page);
void __flush_dcache_icache(void *page);
# 60 "/home/nathan/src/linux-next/arch/powerpc/include/asm/cacheflush.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_dcache_range(unsigned long start, unsigned long stop)
{
 unsigned long shift = l1_dcache_shift();
 unsigned long bytes = l1_dcache_bytes();
 void *addr = (void *)(start & ~(bytes - 1));
 unsigned long size = stop - (unsigned long)addr + (bytes - 1);
 unsigned long i;

 if (1) {
  __asm__ __volatile__ ("sync" : : : "memory");
  isync();
 }

 for (i = 0; i < size >> shift; i++, addr += bytes)
  dcbf(addr);
 __asm__ __volatile__ ("sync" : : : "memory");

 if (1)
  isync();
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clean_dcache_range(unsigned long start, unsigned long stop)
{
 unsigned long shift = l1_dcache_shift();
 unsigned long bytes = l1_dcache_bytes();
 void *addr = (void *)(start & ~(bytes - 1));
 unsigned long size = stop - (unsigned long)addr + (bytes - 1);
 unsigned long i;

 for (i = 0; i < size >> shift; i++, addr += bytes)
  dcbst(addr);
 __asm__ __volatile__ ("sync" : : : "memory");
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void invalidate_dcache_range(unsigned long start,
        unsigned long stop)
{
 unsigned long shift = l1_dcache_shift();
 unsigned long bytes = l1_dcache_bytes();
 void *addr = (void *)(start & ~(bytes - 1));
 unsigned long size = stop - (unsigned long)addr + (bytes - 1);
 unsigned long i;

 for (i = 0; i < size >> shift; i++, addr += bytes)
  dcbi(addr);
 __asm__ __volatile__ ("sync" : : : "memory");
}
# 13 "/home/nathan/src/linux-next/include/linux/highmem.h" 2


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)
{
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_kernel_dcache_page(struct page *page)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flush_kernel_vmap_range(void *vaddr, int size)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void invalidate_kernel_vmap_range(void *vaddr, int size)
{
}



# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/kmap_types.h" 1
# 33 "/home/nathan/src/linux-next/include/linux/highmem.h" 2
# 71 "/home/nathan/src/linux-next/include/linux/highmem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int nr_free_highpages(void) { return 0; }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *kmap_to_page(void *addr)
{
 return (vmemmap + ((({ do { } while (0); (unsigned long)(addr) & 0x0fffffffffffffffUL; }) >> 16)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long totalhigh_pages(void) { return 0UL; }


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmap(struct page *page)
{
 do { do { } while (0); } while (0);
 return lowmem_page_address(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void kunmap(struct page *page)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *kmap_atomic(struct page *page)
{
 __asm__ __volatile__("" : : : "memory");
 pagefault_disable();
 return lowmem_page_address(page);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __kunmap_atomic(void *addr)
{
 pagefault_enable();
 __asm__ __volatile__("" : : : "memory");
}
# 158 "/home/nathan/src/linux-next/include/linux/highmem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_user_highpage(struct page *page, unsigned long vaddr)
{
 void *addr = kmap_atomic(page);
 clear_user_page(addr, vaddr, page);
 do { do { extern void __compiletime_assert_162(void) ; if (!(!(__builtin_types_compatible_p(typeof((addr)), typeof(struct page *))))) __compiletime_assert_162(); } while (0); __kunmap_atomic(addr); } while (0);
}
# 181 "/home/nathan/src/linux-next/include/linux/highmem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
__alloc_zeroed_user_highpage(gfp_t movableflags,
   struct vm_area_struct *vma,
   unsigned long vaddr)
{
 struct page *page = alloc_pages_vma((((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | (( gfp_t)0x100000u)) | (( gfp_t)0x02u)) | movableflags, 0, vma, vaddr, numa_node_id(), false);


 if (page)
  clear_user_highpage(page, vaddr);

 return page;
}
# 204 "/home/nathan/src/linux-next/include/linux/highmem.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *
alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
     unsigned long vaddr)
{
 return __alloc_zeroed_user_highpage((( gfp_t)0x08u), vma, vaddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void clear_highpage(struct page *page)
{
 void *kaddr = kmap_atomic(page);
 clear_page(kaddr);
 do { do { extern void __compiletime_assert_215(void) ; if (!(!(__builtin_types_compatible_p(typeof((kaddr)), typeof(struct page *))))) __compiletime_assert_215(); } while (0); __kunmap_atomic(kaddr); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zero_user_segments(struct page *page,
 unsigned start1, unsigned end1,
 unsigned start2, unsigned end2)
{
 void *kaddr = kmap_atomic(page);

 do { if (__builtin_constant_p(end1 > (1UL << 16) || end2 > (1UL << 16))) { if (end1 > (1UL << 16) || end2 > (1UL << 16)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/highmem.h"), "i" (224), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/highmem.h"), "i" (224), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(end1 > (1UL << 16) || end2 > (1UL << 16)))); } } while (0);

 if (end1 > start1)
  memset(kaddr + start1, 0, end1 - start1);

 if (end2 > start2)
  memset(kaddr + start2, 0, end2 - start2);

 do { do { extern void __compiletime_assert_232(void) ; if (!(!(__builtin_types_compatible_p(typeof((kaddr)), typeof(struct page *))))) __compiletime_assert_232(); } while (0); __kunmap_atomic(kaddr); } while (0);
 flush_dcache_page(page);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zero_user_segment(struct page *page,
 unsigned start, unsigned end)
{
 zero_user_segments(page, start, end, 0, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zero_user(struct page *page,
 unsigned start, unsigned size)
{
 zero_user_segments(page, start, start + size, 0, 0);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_user_highpage(struct page *to, struct page *from,
 unsigned long vaddr, struct vm_area_struct *vma)
{
 char *vfrom, *vto;

 vfrom = kmap_atomic(from);
 vto = kmap_atomic(to);
 copy_user_page(vto, vfrom, vaddr, to);
 do { do { extern void __compiletime_assert_258(void) ; if (!(!(__builtin_types_compatible_p(typeof((vto)), typeof(struct page *))))) __compiletime_assert_258(); } while (0); __kunmap_atomic(vto); } while (0);
 do { do { extern void __compiletime_assert_259(void) ; if (!(!(__builtin_types_compatible_p(typeof((vfrom)), typeof(struct page *))))) __compiletime_assert_259(); } while (0); __kunmap_atomic(vfrom); } while (0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void copy_highpage(struct page *to, struct page *from)
{
 char *vfrom, *vto;

 vfrom = kmap_atomic(from);
 vto = kmap_atomic(to);
 copy_page(vto, vfrom);
 do { do { extern void __compiletime_assert_273(void) ; if (!(!(__builtin_types_compatible_p(typeof((vto)), typeof(struct page *))))) __compiletime_assert_273(); } while (0); __kunmap_atomic(vto); } while (0);
 do { do { extern void __compiletime_assert_274(void) ; if (!(!(__builtin_types_compatible_p(typeof((vfrom)), typeof(struct page *))))) __compiletime_assert_274(); } while (0); __kunmap_atomic(vfrom); } while (0);
}
# 12 "/home/nathan/src/linux-next/include/linux/pagemap.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/hugetlb_inline.h" 1








static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_vm_hugetlb_page(struct vm_area_struct *vma)
{
 return !!(vma->vm_flags & 0x00400000);
}
# 18 "/home/nathan/src/linux-next/include/linux/pagemap.h" 2

struct pagevec;




enum mapping_flags {
 AS_EIO = 0,
 AS_ENOSPC = 1,
 AS_MM_ALL_LOCKS = 2,
 AS_UNEVICTABLE = 3,
 AS_EXITING = 4,

 AS_NO_WRITEBACK_TAGS = 5,
};
# 48 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_set_error(struct address_space *mapping, int error)
{
 if (__builtin_expect(!!(!error), 1))
  return;


 filemap_set_wb_err(mapping, error);


 if (error == -28)
  set_bit(AS_ENOSPC, &mapping->flags);
 else
  set_bit(AS_EIO, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_set_unevictable(struct address_space *mapping)
{
 set_bit(AS_UNEVICTABLE, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_clear_unevictable(struct address_space *mapping)
{
 clear_bit(AS_UNEVICTABLE, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_unevictable(struct address_space *mapping)
{
 if (mapping)
  return test_bit(AS_UNEVICTABLE, &mapping->flags);
 return !!mapping;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_set_exiting(struct address_space *mapping)
{
 set_bit(AS_EXITING, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_exiting(struct address_space *mapping)
{
 return test_bit(AS_EXITING, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_set_no_writeback_tags(struct address_space *mapping)
{
 set_bit(AS_NO_WRITEBACK_TAGS, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mapping_use_writeback_tags(struct address_space *mapping)
{
 return !test_bit(AS_NO_WRITEBACK_TAGS, &mapping->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gfp_t mapping_gfp_mask(struct address_space * mapping)
{
 return mapping->gfp_mask;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gfp_t mapping_gfp_constraint(struct address_space *mapping,
  gfp_t gfp_mask)
{
 return mapping_gfp_mask(mapping) & gfp_mask;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mapping_set_gfp_mask(struct address_space *m, gfp_t mask)
{
 m->gfp_mask = mask;
}

void release_pages(struct page **pages, int nr);
# 167 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __page_cache_add_speculative(struct page *page, int count)
{
# 186 "/home/nathan/src/linux-next/include/linux/pagemap.h"
 if (__builtin_expect(!!(!page_ref_add_unless(page, count, 0)), 0)) {





  return 0;
 }

 ((void)(sizeof(( long)(PageTail(page)))));

 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_cache_get_speculative(struct page *page)
{
 return __page_cache_add_speculative(page, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_cache_add_speculative(struct page *page, int count)
{
 return __page_cache_add_speculative(page, count);
}


extern struct page *__page_cache_alloc(gfp_t gfp);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *page_cache_alloc(struct address_space *x)
{
 return __page_cache_alloc(mapping_gfp_mask(x));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gfp_t readahead_gfp_mask(struct address_space *x)
{
 return mapping_gfp_mask(x) | (( gfp_t)0x10000u) | (( gfp_t)0x2000u);
}

typedef int filler_t(void *, struct page *);

unsigned long page_cache_next_miss(struct address_space *mapping,
        unsigned long index, unsigned long max_scan);
unsigned long page_cache_prev_miss(struct address_space *mapping,
        unsigned long index, unsigned long max_scan);
# 244 "/home/nathan/src/linux-next/include/linux/pagemap.h"
struct page *pagecache_get_page(struct address_space *mapping, unsigned long offset,
  int fgp_flags, gfp_t cache_gfp_mask);
# 257 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *find_get_page(struct address_space *mapping,
     unsigned long offset)
{
 return pagecache_get_page(mapping, offset, 0, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *find_get_page_flags(struct address_space *mapping,
     unsigned long offset, int fgp_flags)
{
 return pagecache_get_page(mapping, offset, fgp_flags, 0);
}
# 282 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *find_lock_page(struct address_space *mapping,
     unsigned long offset)
{
 return pagecache_get_page(mapping, offset, 0x00000002, 0);
}
# 307 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *find_or_create_page(struct address_space *mapping,
     unsigned long offset, gfp_t gfp_mask)
{
 return pagecache_get_page(mapping, offset,
     0x00000002|0x00000001|0x00000004,
     gfp_mask);
}
# 328 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *grab_cache_page_nowait(struct address_space *mapping,
    unsigned long index)
{
 return pagecache_get_page(mapping, index,
   0x00000002|0x00000004|0x00000010|0x00000020,
   mapping_gfp_mask(mapping));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *find_subpage(struct page *page, unsigned long offset)
{
 if (PageHuge(page))
  return page;

 ((void)(sizeof(( long)(PageTail(page)))));

 return page + (offset & (compound_nr(page) - 1));
}

struct page *find_get_entry(struct address_space *mapping, unsigned long offset);
struct page *find_lock_entry(struct address_space *mapping, unsigned long offset);
unsigned find_get_entries(struct address_space *mapping, unsigned long start,
     unsigned int nr_entries, struct page **entries,
     unsigned long *indices);
unsigned find_get_pages_range(struct address_space *mapping, unsigned long *start,
   unsigned long end, unsigned int nr_pages,
   struct page **pages);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned find_get_pages(struct address_space *mapping,
   unsigned long *start, unsigned int nr_pages,
   struct page **pages)
{
 return find_get_pages_range(mapping, start, (unsigned long)-1, nr_pages,
        pages);
}
unsigned find_get_pages_contig(struct address_space *mapping, unsigned long start,
          unsigned int nr_pages, struct page **pages);
unsigned find_get_pages_range_tag(struct address_space *mapping, unsigned long *index,
   unsigned long end, xa_mark_t tag, unsigned int nr_pages,
   struct page **pages);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned find_get_pages_tag(struct address_space *mapping,
   unsigned long *index, xa_mark_t tag, unsigned int nr_pages,
   struct page **pages)
{
 return find_get_pages_range_tag(mapping, index, (unsigned long)-1, tag,
     nr_pages, pages);
}

struct page *grab_cache_page_write_begin(struct address_space *mapping,
   unsigned long index, unsigned flags);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *grab_cache_page(struct address_space *mapping,
        unsigned long index)
{
 return find_or_create_page(mapping, index, mapping_gfp_mask(mapping));
}

extern struct page * read_cache_page(struct address_space *mapping,
    unsigned long index, filler_t *filler, void *data);
extern struct page * read_cache_page_gfp(struct address_space *mapping,
    unsigned long index, gfp_t gfp_mask);
extern int read_cache_pages(struct address_space *mapping,
  struct list_head *pages, filler_t *filler, void *data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *read_mapping_page(struct address_space *mapping,
    unsigned long index, void *data)
{
 return read_cache_page(mapping, index, ((void *)0), data);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long page_to_index(struct page *page)
{
 unsigned long pgoff;

 if (__builtin_expect(!!(!PageTransTail(page)), 1))
  return page->index;





 pgoff = compound_head(page)->index;
 pgoff += page - compound_head(page);
 return pgoff;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long page_to_pgoff(struct page *page)
{
 if (__builtin_expect(!!(PageHeadHuge(page)), 0))
  return page->index << compound_order(page);

 return page_to_index(page);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t page_offset(struct page *page)
{
 return ((loff_t)page->index) << 16;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) loff_t page_file_offset(struct page *page)
{
 return ((loff_t)page_index(page)) << 16;
}

extern unsigned long linear_hugepage_index(struct vm_area_struct *vma,
         unsigned long address);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long linear_page_index(struct vm_area_struct *vma,
     unsigned long address)
{
 unsigned long pgoff;
 if (__builtin_expect(!!(is_vm_hugetlb_page(vma)), 0))
  return linear_hugepage_index(vma, address);
 pgoff = (address - vma->vm_start) >> 16;
 pgoff += vma->vm_pgoff;
 return pgoff;
}

extern void __lock_page(struct page *page);
extern int __lock_page_killable(struct page *page);
extern int __lock_page_or_retry(struct page *page, struct mm_struct *mm,
    unsigned int flags);
extern void unlock_page(struct page *page);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int trylock_page(struct page *page)
{
 page = compound_head(page);
 return (__builtin_expect(!!(!test_and_set_bit_lock(PG_locked, &page->flags)), 1));
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lock_page(struct page *page)
{
 do { do { } while (0); } while (0);
 if (!trylock_page(page))
  __lock_page(page);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int lock_page_killable(struct page *page)
{
 do { do { } while (0); } while (0);
 if (!trylock_page(page))
  return __lock_page_killable(page);
 return 0;
}
# 503 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int lock_page_or_retry(struct page *page, struct mm_struct *mm,
         unsigned int flags)
{
 do { do { } while (0); } while (0);
 return trylock_page(page) || __lock_page_or_retry(page, mm, flags);
}





extern void wait_on_page_bit(struct page *page, int bit_nr);
extern int wait_on_page_bit_killable(struct page *page, int bit_nr);
# 524 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wait_on_page_locked(struct page *page)
{
 if (PageLocked(page))
  wait_on_page_bit(compound_head(page), PG_locked);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int wait_on_page_locked_killable(struct page *page)
{
 if (!PageLocked(page))
  return 0;
 return wait_on_page_bit_killable(compound_head(page), PG_locked);
}

extern void put_and_wait_on_page_locked(struct page *page);

void wait_on_page_writeback(struct page *page);
extern void end_page_writeback(struct page *page);
void wait_for_stable_page(struct page *page);

void page_endio(struct page *page, bool is_write, int err);




extern void add_page_wait_queue(struct page *page, wait_queue_entry_t *waiter);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fault_in_pages_writeable(char *uaddr, int size)
{
 char *end = uaddr + size - 1;

 if (__builtin_expect(!!(size == 0), 0))
  return 0;

 if (__builtin_expect(!!(uaddr > end), 0))
  return -14;




 do {
  if (__builtin_expect(!!(({ long __pu_err; __typeof__(*((uaddr))) *__pu_addr = ((uaddr)); if (!(((unsigned long)__pu_addr) >= 0xc000000000000000UL)) might_fault(); (void)0; if (true) do { allow_write_to_user(__pu_addr, (sizeof(*(uaddr)))); do { __pu_err = 0; switch ((sizeof(*(uaddr)))) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default: __put_user_bad(); } } while (0); prevent_write_to_user(__pu_addr, (sizeof(*(uaddr)))); } while (0); else do { __pu_err = 0; switch ((sizeof(*(uaddr)))) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(uaddr)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }) != 0), 0))
   return -14;
  uaddr += (1UL << 16);
 } while (uaddr <= end);


 if (((unsigned long)uaddr & (~((1 << 16) - 1))) ==
   ((unsigned long)end & (~((1 << 16) - 1))))
  return ({ long __pu_err; __typeof__(*((end))) *__pu_addr = ((end)); if (!(((unsigned long)__pu_addr) >= 0xc000000000000000UL)) might_fault(); (void)0; if (true) do { allow_write_to_user(__pu_addr, (sizeof(*(end)))); do { __pu_err = 0; switch ((sizeof(*(end)))) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default: __put_user_bad(); } } while (0); prevent_write_to_user(__pu_addr, (sizeof(*(end)))); } while (0); else do { __pu_err = 0; switch ((sizeof(*(end)))) { case 1: __asm__ __volatile__( "1:	" "stb" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 2: __asm__ __volatile__( "1:	" "sth" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 4: __asm__ __volatile__( "1:	" "stw" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; case 8: __asm__ __volatile__( "1:	" "std" " %1,0(%2)	# put_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__pu_err) : "r" (((__typeof__(*(end)))(0))), "b" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; });

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fault_in_pages_readable(const char *uaddr, int size)
{
 volatile char c;
 const char *end = uaddr + size - 1;

 if (__builtin_expect(!!(size == 0), 0))
  return 0;

 if (__builtin_expect(!!(uaddr > end), 0))
  return -14;

 do {
  if (__builtin_expect(!!(({ long __gu_err; __typeof__(__builtin_choose_expr(sizeof(*((uaddr))) > sizeof(0UL), 0ULL, 0UL)) __gu_val; __typeof__(*((uaddr))) *__gu_addr = ((uaddr)); (void)0; if (!(((unsigned long)__gu_addr) >= 0xc000000000000000UL)) might_fault(); asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory"); if (true) do { allow_read_from_user(__gu_addr, (sizeof(*(uaddr)))); do { __gu_err = 0; (void)0; if ((sizeof(*(uaddr))) > sizeof(__gu_val)) (__gu_val) = __get_user_bad(); switch ((sizeof(*(uaddr)))) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); prevent_read_from_user(__gu_addr, (sizeof(*(uaddr)))); } while (0); else do { __gu_err = 0; (void)0; if ((sizeof(*(uaddr))) > sizeof(__gu_val)) (__gu_val) = __get_user_bad(); switch ((sizeof(*(uaddr)))) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((c)) = (__typeof__(*((uaddr))))__gu_val; __gu_err; }) != 0), 0))
   return -14;
  uaddr += (1UL << 16);
 } while (uaddr <= end);


 if (((unsigned long)uaddr & (~((1 << 16) - 1))) ==
   ((unsigned long)end & (~((1 << 16) - 1)))) {
  return ({ long __gu_err; __typeof__(__builtin_choose_expr(sizeof(*((end))) > sizeof(0UL), 0ULL, 0UL)) __gu_val; __typeof__(*((end))) *__gu_addr = ((end)); (void)0; if (!(((unsigned long)__gu_addr) >= 0xc000000000000000UL)) might_fault(); asm ("953: .pushsection __barrier_nospec_fixup,\"a\"; .align 2; 954: .8byte 953b-954b; .popsection;; nop" " " ::: "memory"); if (true) do { allow_read_from_user(__gu_addr, (sizeof(*(end)))); do { __gu_err = 0; (void)0; if ((sizeof(*(end))) > sizeof(__gu_val)) (__gu_val) = __get_user_bad(); switch ((sizeof(*(end)))) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); prevent_read_from_user(__gu_addr, (sizeof(*(end)))); } while (0); else do { __gu_err = 0; (void)0; if ((sizeof(*(end))) > sizeof(__gu_val)) (__gu_val) = __get_user_bad(); switch ((sizeof(*(end)))) { case 1: __asm__ __volatile__( "1:	""lbz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 2: __asm__ __volatile__( "1:	""lhz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 4: __asm__ __volatile__( "1:	""lwz"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; case 8: __asm__ __volatile__( "1:	""ld"" %1,0(%2)	# get_user\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	li %0,%3\n" "	li %1,0\n" "	b 2b\n" ".previous\n" ".section __ex_table,\"a\";" " " ".balign 4;" " " ".long (1b) - . ;" " " ".long (3b) - . ;" " " ".previous" " " : "=r" (__gu_err), "=r" (__gu_val) : "b" (__gu_addr), "i" (-14), "0" (__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((c)) = (__typeof__(*((end))))__gu_val; __gu_err; });
 }

 (void)c;
 return 0;
}

int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
    unsigned long index, gfp_t gfp_mask);
int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
    unsigned long index, gfp_t gfp_mask);
extern void delete_from_page_cache(struct page *page);
extern void __delete_from_page_cache(struct page *page, void *shadow);
int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask);
void delete_from_page_cache_batch(struct address_space *mapping,
      struct pagevec *pvec);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int add_to_page_cache(struct page *page,
  struct address_space *mapping, unsigned long offset, gfp_t gfp_mask)
{
 int error;

 __SetPageLocked(page);
 error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
 if (__builtin_expect(!!(error), 0))
  __ClearPageLocked(page);
 return error;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long dir_pages(struct inode *inode)
{
 return (unsigned long)(inode->i_size + (1UL << 16) - 1) >>
          16;
}
# 647 "/home/nathan/src/linux-next/include/linux/pagemap.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int page_mkwrite_check_truncate(struct page *page,
           struct inode *inode)
{
 loff_t size = i_size_read(inode);
 unsigned long index = size >> 16;
 int offset = ((unsigned long)(size) & ~(~((1 << 16) - 1)));

 if (page->mapping != inode->i_mapping)
  return -14;


 if (page->index < index)
  return (1UL << 16);

 if (page->index > index || !offset)
  return -14;

 return offset;
}
# 17 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/mempool.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/mempool.h"
struct kmem_cache;

typedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);
typedef void (mempool_free_t)(void *element, void *pool_data);

typedef struct mempool_s {
 spinlock_t lock;
 int min_nr;
 int curr_nr;
 void **elements;

 void *pool_data;
 mempool_alloc_t *alloc;
 mempool_free_t *free;
 wait_queue_head_t wait;
} mempool_t;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mempool_initialized(mempool_t *pool)
{
 return pool->elements != ((void *)0);
}

void mempool_exit(mempool_t *pool);
int mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,
        mempool_free_t *free_fn, void *pool_data,
        gfp_t gfp_mask, int node_id);
int mempool_init(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,
   mempool_free_t *free_fn, void *pool_data);

extern mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
   mempool_free_t *free_fn, void *pool_data);
extern mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,
   mempool_free_t *free_fn, void *pool_data,
   gfp_t gfp_mask, int nid);

extern int mempool_resize(mempool_t *pool, int new_min_nr);
extern void mempool_destroy(mempool_t *pool);
extern void *mempool_alloc(mempool_t *pool, gfp_t gfp_mask) __attribute__((__malloc__));
extern void mempool_free(void *element, mempool_t *pool);






void *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data);
void mempool_free_slab(void *element, void *pool_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
mempool_init_slab_pool(mempool_t *pool, int min_nr, struct kmem_cache *kc)
{
 return mempool_init(pool, min_nr, mempool_alloc_slab,
       mempool_free_slab, (void *) kc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) mempool_t *
mempool_create_slab_pool(int min_nr, struct kmem_cache *kc)
{
 return mempool_create(min_nr, mempool_alloc_slab, mempool_free_slab,
         (void *) kc);
}





void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data);
void mempool_kfree(void *element, void *pool_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mempool_init_kmalloc_pool(mempool_t *pool, int min_nr, size_t size)
{
 return mempool_init(pool, min_nr, mempool_kmalloc,
       mempool_kfree, (void *) size);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size)
{
 return mempool_create(min_nr, mempool_kmalloc, mempool_kfree,
         (void *) size);
}





void *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data);
void mempool_free_pages(void *element, void *pool_data);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mempool_init_page_pool(mempool_t *pool, int min_nr, int order)
{
 return mempool_init(pool, min_nr, mempool_alloc_pages,
       mempool_free_pages, (void *)(long)order);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) mempool_t *mempool_create_page_pool(int min_nr, int order)
{
 return mempool_create(min_nr, mempool_alloc_pages, mempool_free_pages,
         (void *)(long)order);
}
# 20 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/bio.h" 1
# 61 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_has_data(struct bio *bio)
{
 if (bio &&
     bio->bi_iter.bi_size &&
     ((bio)->bi_opf & ((1 << 8) - 1)) != REQ_OP_DISCARD &&
     ((bio)->bi_opf & ((1 << 8) - 1)) != REQ_OP_SECURE_ERASE &&
     ((bio)->bi_opf & ((1 << 8) - 1)) != REQ_OP_WRITE_ZEROES)
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_no_advance_iter(struct bio *bio)
{
 return ((bio)->bi_opf & ((1 << 8) - 1)) == REQ_OP_DISCARD ||
        ((bio)->bi_opf & ((1 << 8) - 1)) == REQ_OP_SECURE_ERASE ||
        ((bio)->bi_opf & ((1 << 8) - 1)) == REQ_OP_WRITE_SAME ||
        ((bio)->bi_opf & ((1 << 8) - 1)) == REQ_OP_WRITE_ZEROES;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_mergeable(struct bio *bio)
{
 if (bio->bi_opf & ((1ULL << __REQ_NOMERGE) | (1ULL << __REQ_PREFLUSH) | (1ULL << __REQ_FUA)))
  return false;

 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bio_cur_bytes(struct bio *bio)
{
 if (bio_has_data(bio))
  return ((struct bio_vec) { .bv_page = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_page) + (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) / (1UL << 16))), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))) *)1 == (typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) * 0l)) : (int *)8))))), (((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))) < ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) ? ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))) : ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16))))), ({ typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))) __UNIQUE_ID___x34 = ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x32 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y33 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x32) < (__UNIQUE_ID___y33) ? (__UNIQUE_ID___x32) : (__UNIQUE_ID___y33)); })))); typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) __UNIQUE_ID___y35 = ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))); ((__UNIQUE_ID___x34) < (__UNIQUE_ID___y35) ? (__UNIQUE_ID___x34) : (__UNIQUE_ID___y35)); })), .bv_offset = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_offset + (((((bio)->bi_iter)))).bi_bvec_done) % (1UL << 16)), }).bv_len;
 else
  return bio->bi_iter.bi_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *bio_data(struct bio *bio)
{
 if (bio_has_data(bio))
  return lowmem_page_address((((&(((((bio))->bi_io_vec)))[(((((bio)->bi_iter)))).bi_idx])->bv_page) + (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_offset + (((((bio)->bi_iter)))).bi_bvec_done) / (1UL << 16)))) + (((&(((((bio))->bi_io_vec)))[(((((bio)->bi_iter)))).bi_idx])->bv_offset + ((((bio)->bi_iter))).bi_bvec_done) % (1UL << 16));

 return ((void *)0);
}
# 113 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_full(struct bio *bio, unsigned len)
{
 if (bio->bi_vcnt >= bio->bi_max_vecs)
  return true;

 if (bio->bi_iter.bi_size > (~0U) - len)
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_next_segment(const struct bio *bio,
        struct bvec_iter_all *iter)
{
 if (iter->idx >= bio->bi_vcnt)
  return false;

 bvec_advance(&bio->bi_io_vec[iter->idx], iter);
 return true;
}
# 141 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_advance_iter(struct bio *bio, struct bvec_iter *iter,
        unsigned bytes)
{
 iter->bi_sector += bytes >> 9;

 if (bio_no_advance_iter(bio))
  iter->bi_size -= bytes;
 else
  bvec_iter_advance(bio->bi_io_vec, iter, bytes);

}
# 174 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned bio_segments(struct bio *bio)
{
 unsigned segs = 0;
 struct bio_vec bv;
 struct bvec_iter iter;






 switch (((bio)->bi_opf & ((1 << 8) - 1))) {
 case REQ_OP_DISCARD:
 case REQ_OP_SECURE_ERASE:
 case REQ_OP_WRITE_ZEROES:
  return 0;
 case REQ_OP_WRITE_SAME:
  return 1;
 default:
  break;
 }

 for (iter = ((bio)->bi_iter); (iter).bi_size && ((bv = ((struct bio_vec) { .bv_page = (((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_page) + (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) / (1UL << 16))), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))) *)1 == (typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16)))) * 0l)) : (int *)8))))), (((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))) < ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16)))) ? ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))) : ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16))))), ({ typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))) __UNIQUE_ID___x38 = ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((iter))))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((iter))))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((iter))))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) ? ((((((iter))))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done)), ({ typeof((((((iter))))).bi_size) __UNIQUE_ID___x36 = ((((((iter))))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done) __UNIQUE_ID___y37 = ((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_len - (((((iter))))).bi_bvec_done); ((__UNIQUE_ID___x36) < (__UNIQUE_ID___y37) ? (__UNIQUE_ID___x36) : (__UNIQUE_ID___y37)); })))); typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16)))) __UNIQUE_ID___y39 = ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((iter))))))).bi_idx])->bv_offset + ((((((iter)))))).bi_bvec_done) % (1UL << 16)))); ((__UNIQUE_ID___x38) < (__UNIQUE_ID___y39) ? (__UNIQUE_ID___x38) : (__UNIQUE_ID___y39)); })), .bv_offset = (((&((((((bio))->bi_io_vec))))[((((((iter)))))).bi_idx])->bv_offset + (((((iter))))).bi_bvec_done) % (1UL << 16)), })), 1); bio_advance_iter((bio), &(iter), (bv).bv_len))
  segs++;

 return segs;
}
# 216 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_get(struct bio *bio)
{
 bio->bi_flags |= (1 << BIO_REFFED);
 __asm__ __volatile__ ("sync" : : : "memory");
 atomic_inc(&bio->__bi_cnt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_cnt_set(struct bio *bio, unsigned int count)
{
 if (count != 1) {
  bio->bi_flags |= (1 << BIO_REFFED);
  __asm__ __volatile__ ("sync" : : : "memory");
 }
 atomic_set(&bio->__bi_cnt, count);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_flagged(struct bio *bio, unsigned int bit)
{
 return (bio->bi_flags & (1U << bit)) != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_set_flag(struct bio *bio, unsigned int bit)
{
 bio->bi_flags |= (1U << bit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_clear_flag(struct bio *bio, unsigned int bit)
{
 bio->bi_flags &= ~(1U << bit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_get_first_bvec(struct bio *bio, struct bio_vec *bv)
{
 *bv = ((struct bio_vec) { .bv_page = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_page) + (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) / (1UL << 16))), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))) *)1 == (typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) * 0l)) : (int *)8))))), (((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))) < ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) ? ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))) : ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16))))), ({ typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))) __UNIQUE_ID___x42 = ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x40 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y41 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x40) < (__UNIQUE_ID___y41) ? (__UNIQUE_ID___x40) : (__UNIQUE_ID___y41)); })))); typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) __UNIQUE_ID___y43 = ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))); ((__UNIQUE_ID___x42) < (__UNIQUE_ID___y43) ? (__UNIQUE_ID___x42) : (__UNIQUE_ID___y43)); })), .bv_offset = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_offset + (((((bio)->bi_iter)))).bi_bvec_done) % (1UL << 16)), });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_get_last_bvec(struct bio *bio, struct bio_vec *bv)
{
 struct bvec_iter iter = bio->bi_iter;
 int idx;

 if (__builtin_expect(!!(!((bio)->bi_iter.bi_size != ((struct bio_vec) { .bv_page = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_page) + (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) / (1UL << 16))), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))) *)1 == (typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) * 0l)) : (int *)8))))), (((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))) < ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) ? ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))) : ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16))))), ({ typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))) __UNIQUE_ID___x46 = ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x44 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y45 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x44) < (__UNIQUE_ID___y45) ? (__UNIQUE_ID___x44) : (__UNIQUE_ID___y45)); })))); typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) __UNIQUE_ID___y47 = ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))); ((__UNIQUE_ID___x46) < (__UNIQUE_ID___y47) ? (__UNIQUE_ID___x46) : (__UNIQUE_ID___y47)); })), .bv_offset = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_offset + (((((bio)->bi_iter)))).bi_bvec_done) % (1UL << 16)), }).bv_len)), 0)) {
  *bv = ((struct bio_vec) { .bv_page = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_page) + (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) / (1UL << 16))), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))) *)1 == (typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) * 0l)) : (int *)8))))), (((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))) < ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) ? ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))) : ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16))))), ({ typeof((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))) __UNIQUE_ID___x50 = ((unsigned)(__builtin_choose_expr(((!!(sizeof((typeof((((((bio)->bi_iter)))).bi_size) *)1 == (typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((((((bio)->bi_iter)))).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) * 0l)) : (int *)8))))), (((((((bio)->bi_iter)))).bi_size) < ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) ? ((((((bio)->bi_iter)))).bi_size) : ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done)), ({ typeof((((((bio)->bi_iter)))).bi_size) __UNIQUE_ID___x48 = ((((((bio)->bi_iter)))).bi_size); typeof((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done) __UNIQUE_ID___y49 = ((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_len - (((((bio)->bi_iter)))).bi_bvec_done); ((__UNIQUE_ID___x48) < (__UNIQUE_ID___y49) ? (__UNIQUE_ID___x48) : (__UNIQUE_ID___y49)); })))); typeof((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))) __UNIQUE_ID___y51 = ((unsigned)((1UL << 16) - (((&(((((((bio))->bi_io_vec)))))[(((((((bio)->bi_iter)))))).bi_idx])->bv_offset + ((((((bio)->bi_iter))))).bi_bvec_done) % (1UL << 16)))); ((__UNIQUE_ID___x50) < (__UNIQUE_ID___y51) ? (__UNIQUE_ID___x50) : (__UNIQUE_ID___y51)); })), .bv_offset = (((&((((((bio))->bi_io_vec))))[((((((bio)->bi_iter))))).bi_idx])->bv_offset + (((((bio)->bi_iter)))).bi_bvec_done) % (1UL << 16)), });
  return;
 }

 bio_advance_iter(bio, &iter, iter.bi_size);

 if (!iter.bi_bvec_done)
  idx = iter.bi_idx - 1;
 else
  idx = iter.bi_idx;

 *bv = bio->bi_io_vec[idx];





 if (iter.bi_bvec_done)
  bv->bv_len = iter.bi_bvec_done;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio_vec *bio_first_bvec_all(struct bio *bio)
{
 ({ int __ret_warn_on = !!(bio_flagged(bio, BIO_CLONED)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/bio.h"), "i" (281), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return bio->bi_io_vec;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page *bio_first_page_all(struct bio *bio)
{
 return bio_first_bvec_all(bio)->bv_page;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio_vec *bio_last_bvec_all(struct bio *bio)
{
 ({ int __ret_warn_on = !!(bio_flagged(bio, BIO_CLONED)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/bio.h"), "i" (292), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 return &bio->bi_io_vec[bio->bi_vcnt - 1];
}

enum bip_flags {
 BIP_BLOCK_INTEGRITY = 1 << 0,
 BIP_MAPPED_INTEGRITY = 1 << 1,
 BIP_CTRL_NOCHECK = 1 << 2,
 BIP_DISK_NOCHECK = 1 << 3,
 BIP_IP_CHECKSUM = 1 << 4,
};




struct bio_integrity_payload {
 struct bio *bip_bio;

 struct bvec_iter bip_iter;

 unsigned short bip_slab;
 unsigned short bip_vcnt;
 unsigned short bip_max_vcnt;
 unsigned short bip_flags;

 struct bvec_iter bio_iter;

 struct work_struct bip_work;

 struct bio_vec *bip_vec;
 struct bio_vec bip_inline_vecs[0];
};
# 358 "/home/nathan/src/linux-next/include/linux/bio.h"
extern void bio_trim(struct bio *bio, int offset, int size);
extern struct bio *bio_split(struct bio *bio, int sectors,
        gfp_t gfp, struct bio_set *bs);
# 372 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_next_split(struct bio *bio, int sectors,
      gfp_t gfp, struct bio_set *bs)
{
 if (sectors >= (((bio)->bi_iter).bi_size >> 9))
  return bio;

 return bio_split(bio, sectors, gfp, bs);
}

enum {
 BIOSET_NEED_BVECS = ((((1UL))) << (0)),
 BIOSET_NEED_RESCUER = ((((1UL))) << (1)),
};
extern int bioset_init(struct bio_set *, unsigned int, unsigned int, int flags);
extern void bioset_exit(struct bio_set *);
extern int biovec_init_pool(mempool_t *pool, int pool_entries);
extern int bioset_init_from_src(struct bio_set *bs, struct bio_set *src);

extern struct bio *bio_alloc_bioset(gfp_t, unsigned int, struct bio_set *);
extern void bio_put(struct bio *);

extern void __bio_clone_fast(struct bio *, struct bio *);
extern struct bio *bio_clone_fast(struct bio *, gfp_t, struct bio_set *);

extern struct bio_set fs_bio_set;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
 return bio_alloc_bioset(gfp_mask, nr_iovecs, &fs_bio_set);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_kmalloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
 return bio_alloc_bioset(gfp_mask, nr_iovecs, ((void *)0));
}

extern blk_qc_t submit_bio(struct bio *);

extern void bio_endio(struct bio *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_io_error(struct bio *bio)
{
 bio->bi_status = (( blk_status_t)10);
 bio_endio(bio);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_wouldblock_error(struct bio *bio)
{
 bio->bi_status = (( blk_status_t)12);
 bio_endio(bio);
}

struct request_queue;

extern int submit_bio_wait(struct bio *bio);
extern void bio_advance(struct bio *, unsigned);

extern void bio_init(struct bio *bio, struct bio_vec *table,
       unsigned short max_vecs);
extern void bio_uninit(struct bio *);
extern void bio_reset(struct bio *);
void bio_chain(struct bio *, struct bio *);

extern int bio_add_page(struct bio *, struct page *, unsigned int,unsigned int);
extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
      unsigned int, unsigned int);
bool __bio_try_merge_page(struct bio *bio, struct page *page,
  unsigned int len, unsigned int off, bool *same_page);
void __bio_add_page(struct bio *bio, struct page *page,
  unsigned int len, unsigned int off);
int bio_iov_iter_get_pages(struct bio *bio, struct iov_iter *iter);
void bio_release_pages(struct bio *bio, bool mark_dirty);
struct rq_map_data;
extern struct bio *bio_map_user_iov(struct request_queue *,
        struct iov_iter *, gfp_t);
extern void bio_unmap_user(struct bio *);
extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
    gfp_t);
extern struct bio *bio_copy_kern(struct request_queue *, void *, unsigned int,
     gfp_t, int);
extern void bio_set_pages_dirty(struct bio *bio);
extern void bio_check_pages_dirty(struct bio *bio);

void generic_start_io_acct(struct request_queue *q, int op,
    unsigned long sectors, struct hd_struct *part);
void generic_end_io_acct(struct request_queue *q, int op,
    struct hd_struct *part,
    unsigned long start_time);

extern void bio_copy_data_iter(struct bio *dst, struct bvec_iter *dst_iter,
          struct bio *src, struct bvec_iter *src_iter);
extern void bio_copy_data(struct bio *dst, struct bio *src);
extern void bio_list_copy_data(struct bio *dst, struct bio *src);
extern void bio_free_pages(struct bio *bio);

extern struct bio *bio_copy_user_iov(struct request_queue *,
         struct rq_map_data *,
         struct iov_iter *,
         gfp_t);
extern int bio_uncopy_user(struct bio *);
void zero_fill_bio_iter(struct bio *bio, struct bvec_iter iter);
void bio_truncate(struct bio *bio, unsigned new_size);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void zero_fill_bio(struct bio *bio)
{
 zero_fill_bio_iter(bio, bio->bi_iter);
}

extern struct bio_vec *bvec_alloc(gfp_t, int, unsigned long *, mempool_t *);
extern void bvec_free(mempool_t *, struct bio_vec *, unsigned int);
extern unsigned int bvec_nr_vecs(unsigned short idx);
extern const char *bio_devname(struct bio *bio, char *buffer);
# 507 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_associate_blkg_from_page(struct bio *bio,
      struct page *page) { }
# 518 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_disassociate_blkg(struct bio *bio) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_associate_blkg(struct bio *bio) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_associate_blkg_from_css(struct bio *bio,
            struct cgroup_subsys_state *css)
{ }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_clone_blkg_association(struct bio *dst,
           struct bio *src) { }
# 557 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *bvec_kmap_irq(struct bio_vec *bvec, unsigned long *flags)
{
 return lowmem_page_address(bvec->bv_page) + bvec->bv_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bvec_kunmap_irq(char *buffer, unsigned long *flags)
{
 *flags = 0;
}
# 575 "/home/nathan/src/linux-next/include/linux/bio.h"
struct bio_list {
 struct bio *head;
 struct bio *tail;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bio_list_empty(const struct bio_list *bl)
{
 return bl->head == ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_list_init(struct bio_list *bl)
{
 bl->head = bl->tail = ((void *)0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned bio_list_size(const struct bio_list *bl)
{
 unsigned sz = 0;
 struct bio *bio;

 for (bio = (bl)->head; bio; bio = bio->bi_next)
  sz++;

 return sz;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_list_add(struct bio_list *bl, struct bio *bio)
{
 bio->bi_next = ((void *)0);

 if (bl->tail)
  bl->tail->bi_next = bio;
 else
  bl->head = bio;

 bl->tail = bio;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_list_add_head(struct bio_list *bl, struct bio *bio)
{
 bio->bi_next = bl->head;

 bl->head = bio;

 if (!bl->tail)
  bl->tail = bio;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
{
 if (!bl2->head)
  return;

 if (bl->tail)
  bl->tail->bi_next = bl2->head;
 else
  bl->head = bl2->head;

 bl->tail = bl2->tail;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_list_merge_head(struct bio_list *bl,
           struct bio_list *bl2)
{
 if (!bl2->head)
  return;

 if (bl->head)
  bl2->tail->bi_next = bl->head;
 else
  bl->tail = bl2->tail;

 bl->head = bl2->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_list_peek(struct bio_list *bl)
{
 return bl->head;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_list_pop(struct bio_list *bl)
{
 struct bio *bio = bl->head;

 if (bio) {
  bl->head = bl->head->bi_next;
  if (!bl->head)
   bl->tail = ((void *)0);

  bio->bi_next = ((void *)0);
 }

 return bio;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio *bio_list_get(struct bio_list *bl)
{
 struct bio *bio = bl->head;

 bl->head = bl->tail = ((void *)0);

 return bio;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_inc_remaining(struct bio *bio)
{
 bio_set_flag(bio, BIO_CHAIN);
 __asm__ __volatile__ ("sync" : : : "memory");
 atomic_inc(&bio->__bi_remaining);
}
# 703 "/home/nathan/src/linux-next/include/linux/bio.h"
struct bio_set {
 struct kmem_cache *bio_slab;
 unsigned int front_pad;

 mempool_t bio_pool;
 mempool_t bvec_pool;
# 718 "/home/nathan/src/linux-next/include/linux/bio.h"
 spinlock_t rescue_lock;
 struct bio_list rescue_list;
 struct work_struct rescue_work;
 struct workqueue_struct *rescue_workqueue;
};

struct biovec_slab {
 int nr_vecs;
 char *name;
 struct kmem_cache *slab;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bioset_initialized(struct bio_set *bs)
{
 return bs->bio_slab != ((void *)0);
}
# 762 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *bio_integrity(struct bio *bio)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bioset_integrity_create(struct bio_set *bs, int pool_size)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bioset_integrity_free (struct bio_set *bs)
{
 return;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_integrity_prep(struct bio *bio)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bio_integrity_clone(struct bio *bio, struct bio *bio_src,
          gfp_t gfp_mask)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_integrity_advance(struct bio *bio,
      unsigned int bytes_done)
{
 return;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_integrity_trim(struct bio *bio)
{
 return;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_integrity_init(void)
{
 return;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_integrity_flagged(struct bio *bio, enum bip_flags flag)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *bio_integrity_alloc(struct bio * bio, gfp_t gfp,
        unsigned int nr)
{
 return ERR_PTR(-22);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bio_integrity_add_page(struct bio *bio, struct page *page,
     unsigned int len, unsigned int offset)
{
 return 0;
}
# 830 "/home/nathan/src/linux-next/include/linux/bio.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bio_set_polled(struct bio *bio, struct kiocb *kiocb)
{
 bio->bi_opf |= (1ULL << __REQ_HIPRI);
 if (!is_sync_kiocb(kiocb))
  bio->bi_opf |= (1ULL << __REQ_NOWAIT);
}
# 22 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2


# 1 "/home/nathan/src/linux-next/include/linux/bsg.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/bsg.h" 1
# 22 "/home/nathan/src/linux-next/include/uapi/linux/bsg.h"
struct sg_io_v4 {
 __s32 guard;
 __u32 protocol;
 __u32 subprotocol;


 __u32 request_len;
 __u64 request;
 __u64 request_tag;
 __u32 request_attr;
 __u32 request_priority;
 __u32 request_extra;
 __u32 max_response_len;
 __u64 response;


 __u32 dout_iovec_count;

 __u32 dout_xfer_len;
 __u32 din_iovec_count;
 __u32 din_xfer_len;
 __u64 dout_xferp;
 __u64 din_xferp;

 __u32 timeout;
 __u32 flags;
 __u64 usr_ptr;
 __u32 spare_in;

 __u32 driver_status;
 __u32 transport_status;
 __u32 device_status;
 __u32 retry_delay;
 __u32 info;
 __u32 duration;
 __u32 response_len;
 __s32 din_resid;
 __s32 dout_resid;
 __u64 generated_tag;
 __u32 spare_out;

 __u32 padding;
};
# 6 "/home/nathan/src/linux-next/include/linux/bsg.h" 2

struct request;


struct bsg_ops {
 int (*check_proto)(struct sg_io_v4 *hdr);
 int (*fill_hdr)(struct request *rq, struct sg_io_v4 *hdr,
    fmode_t mode);
 int (*complete_rq)(struct request *rq, struct sg_io_v4 *hdr);
 void (*free_rq)(struct request *rq);
};

struct bsg_class_device {
 struct device *class_dev;
 int minor;
 struct request_queue *queue;
 const struct bsg_ops *ops;
};

int bsg_register_queue(struct request_queue *q, struct device *parent,
  const char *name, const struct bsg_ops *ops);
int bsg_scsi_register_queue(struct request_queue *q, struct device *parent);
void bsg_unregister_queue(struct request_queue *q);
# 25 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2




# 1 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h" 1
# 32 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h"
enum blk_zone_type {
 BLK_ZONE_TYPE_CONVENTIONAL = 0x1,
 BLK_ZONE_TYPE_SEQWRITE_REQ = 0x2,
 BLK_ZONE_TYPE_SEQWRITE_PREF = 0x3,
};
# 65 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h"
enum blk_zone_cond {
 BLK_ZONE_COND_NOT_WP = 0x0,
 BLK_ZONE_COND_EMPTY = 0x1,
 BLK_ZONE_COND_IMP_OPEN = 0x2,
 BLK_ZONE_COND_EXP_OPEN = 0x3,
 BLK_ZONE_COND_CLOSED = 0x4,
 BLK_ZONE_COND_READONLY = 0xD,
 BLK_ZONE_COND_FULL = 0xE,
 BLK_ZONE_COND_OFFLINE = 0xF,
};
# 94 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h"
struct blk_zone {
 __u64 start;
 __u64 len;
 __u64 wp;
 __u8 type;
 __u8 cond;
 __u8 non_seq;
 __u8 reset;
 __u8 reserved[36];
};
# 115 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h"
struct blk_zone_report {
 __u64 sector;
 __u32 nr_zones;
 __u8 reserved[4];
 struct blk_zone zones[0];
};
# 129 "/home/nathan/src/linux-next/include/uapi/linux/blkzoned.h"
struct blk_zone_range {
 __u64 sector;
 __u64 nr_sectors;
};
# 30 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2

struct module;
struct scsi_ioctl_command;

struct request_queue;
struct elevator_queue;
struct blk_trace;
struct request;
struct sg_io_hdr;
struct bsg_job;
struct blkcg_gq;
struct blk_flush_queue;
struct pr_ops;
struct rq_qos;
struct blk_queue_stats;
struct blk_stat_callback;
# 62 "/home/nathan/src/linux-next/include/linux/blkdev.h"
typedef void (rq_end_io_fn)(struct request *, blk_status_t);



typedef __u32 req_flags_t;
# 120 "/home/nathan/src/linux-next/include/linux/blkdev.h"
enum mq_rq_state {
 MQ_RQ_IDLE = 0,
 MQ_RQ_IN_FLIGHT = 1,
 MQ_RQ_COMPLETE = 2,
};







struct request {
 struct request_queue *q;
 struct blk_mq_ctx *mq_ctx;
 struct blk_mq_hw_ctx *mq_hctx;

 unsigned int cmd_flags;
 req_flags_t rq_flags;

 int tag;
 int internal_tag;


 unsigned int __data_len;
 sector_t __sector;

 struct bio *bio;
 struct bio *biotail;

 struct list_head queuelist;
# 159 "/home/nathan/src/linux-next/include/linux/blkdev.h"
 union {
  struct hlist_node hash;
  struct list_head ipi_list;
 };






 union {
  struct rb_node rb_node;
  struct bio_vec special_vec;
  void *completion_data;
  int error_count;
 };







 union {
  struct {
   struct io_cq *icq;
   void *priv[2];
  } elv;

  struct {
   unsigned int seq;
   struct list_head list;
   rq_end_io_fn *saved_end_io;
  } flush;
 };

 struct gendisk *rq_disk;
 struct hd_struct *part;





 u64 start_time_ns;

 u64 io_start_time_ns;
# 214 "/home/nathan/src/linux-next/include/linux/blkdev.h"
 unsigned short stats_sectors;





 unsigned short nr_phys_segments;





 unsigned short write_hint;
 unsigned short ioprio;

 unsigned int extra_len;

 enum mq_rq_state state;
 refcount_t ref;

 unsigned int timeout;
 unsigned long deadline;

 union {
  struct __call_single_data csd;
  u64 fifo_time;
 };




 rq_end_io_fn *end_io;
 void *end_io_data;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_op_is_scsi(unsigned int op)
{
 return op == REQ_OP_SCSI_IN || op == REQ_OP_SCSI_OUT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_op_is_private(unsigned int op)
{
 return op == REQ_OP_DRV_IN || op == REQ_OP_DRV_OUT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_rq_is_scsi(struct request *rq)
{
 return blk_op_is_scsi(((rq)->cmd_flags & ((1 << 8) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_rq_is_private(struct request *rq)
{
 return blk_op_is_private(((rq)->cmd_flags & ((1 << 8) - 1)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_rq_is_passthrough(struct request *rq)
{
 return blk_rq_is_scsi(rq) || blk_rq_is_private(rq);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bio_is_passthrough(struct bio *bio)
{
 unsigned op = ((bio)->bi_opf & ((1 << 8) - 1));

 return blk_op_is_scsi(op) || blk_op_is_private(op);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short req_get_ioprio(struct request *req)
{
 return req->ioprio;
}


# 1 "/home/nathan/src/linux-next/include/linux/elevator.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/elevator.h"
struct io_cq;
struct elevator_type;

struct blk_mq_debugfs_attr;





enum elv_merge {
 ELEVATOR_NO_MERGE = 0,
 ELEVATOR_FRONT_MERGE = 1,
 ELEVATOR_BACK_MERGE = 2,
 ELEVATOR_DISCARD_MERGE = 3,
};

struct blk_mq_alloc_data;
struct blk_mq_hw_ctx;

struct elevator_mq_ops {
 int (*init_sched)(struct request_queue *, struct elevator_type *);
 void (*exit_sched)(struct elevator_queue *);
 int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
 void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
 void (*depth_updated)(struct blk_mq_hw_ctx *);

 bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
 bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int);
 int (*request_merge)(struct request_queue *q, struct request **, struct bio *);
 void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
 void (*requests_merged)(struct request_queue *, struct request *, struct request *);
 void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
 void (*prepare_request)(struct request *, struct bio *bio);
 void (*finish_request)(struct request *);
 void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
 struct request *(*dispatch_request)(struct blk_mq_hw_ctx *);
 bool (*has_work)(struct blk_mq_hw_ctx *);
 void (*completed_request)(struct request *, u64);
 void (*requeue_request)(struct request *);
 struct request *(*former_request)(struct request_queue *, struct request *);
 struct request *(*next_request)(struct request_queue *, struct request *);
 void (*init_icq)(struct io_cq *);
 void (*exit_icq)(struct io_cq *);
};



struct elv_fs_entry {
 struct attribute attr;
 ssize_t (*show)(struct elevator_queue *, char *);
 ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};




struct elevator_type
{

 struct kmem_cache *icq_cache;


 struct elevator_mq_ops ops;

 size_t icq_size;
 size_t icq_align;
 struct elv_fs_entry *elevator_attrs;
 const char *elevator_name;
 const char *elevator_alias;
 const unsigned int elevator_features;
 struct module *elevator_owner;

 const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
 const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;



 char icq_cache_name[(16) + 6];
 struct list_head list;
};



void elv_rqhash_del(struct request_queue *q, struct request *rq);
void elv_rqhash_add(struct request_queue *q, struct request *rq);
void elv_rqhash_reposition(struct request_queue *q, struct request *rq);
struct request *elv_rqhash_find(struct request_queue *q, sector_t offset);




struct elevator_queue
{
 struct elevator_type *type;
 void *elevator_data;
 struct kobject kobj;
 struct mutex sysfs_lock;
 unsigned int registered:1;
 struct hlist_head hash[1 << (6)];
};




extern enum elv_merge elv_merge(struct request_queue *, struct request **,
  struct bio *);
extern void elv_merge_requests(struct request_queue *, struct request *,
          struct request *);
extern void elv_merged_request(struct request_queue *, struct request *,
  enum elv_merge);
extern bool elv_attempt_insert_merge(struct request_queue *, struct request *);
extern struct request *elv_former_request(struct request_queue *, struct request *);
extern struct request *elv_latter_request(struct request_queue *, struct request *);




extern int elv_register(struct elevator_type *);
extern void elv_unregister(struct elevator_type *);




extern ssize_t elv_iosched_show(struct request_queue *, char *);
extern ssize_t elv_iosched_store(struct request_queue *, const char *, size_t);

extern bool elv_bio_merge_ok(struct request *, struct bio *);
extern struct elevator_queue *elevator_alloc(struct request_queue *,
     struct elevator_type *);




extern struct request *elv_rb_former_request(struct request_queue *, struct request *);
extern struct request *elv_rb_latter_request(struct request_queue *, struct request *);




extern void elv_rb_add(struct rb_root *, struct request *);
extern void elv_rb_del(struct rb_root *, struct request *);
extern struct request *elv_rb_find(struct rb_root *, sector_t);
# 287 "/home/nathan/src/linux-next/include/linux/blkdev.h" 2

struct blk_queue_ctx;

typedef blk_qc_t (make_request_fn) (struct request_queue *q, struct bio *bio);

struct bio_vec;
typedef int (dma_drain_needed_fn)(struct request *);

enum blk_eh_timer_return {
 BLK_EH_DONE,
 BLK_EH_RESET_TIMER,
};

enum blk_queue_state {
 Queue_down,
 Queue_up,
};
# 314 "/home/nathan/src/linux-next/include/linux/blkdev.h"
enum blk_zoned_model {
 BLK_ZONED_NONE,
 BLK_ZONED_HA,
 BLK_ZONED_HM,
};

struct queue_limits {
 unsigned long bounce_pfn;
 unsigned long seg_boundary_mask;
 unsigned long virt_boundary_mask;

 unsigned int max_hw_sectors;
 unsigned int max_dev_sectors;
 unsigned int chunk_sectors;
 unsigned int max_sectors;
 unsigned int max_segment_size;
 unsigned int physical_block_size;
 unsigned int logical_block_size;
 unsigned int alignment_offset;
 unsigned int io_min;
 unsigned int io_opt;
 unsigned int max_discard_sectors;
 unsigned int max_hw_discard_sectors;
 unsigned int max_write_same_sectors;
 unsigned int max_write_zeroes_sectors;
 unsigned int discard_granularity;
 unsigned int discard_alignment;

 unsigned short max_segments;
 unsigned short max_integrity_segments;
 unsigned short max_discard_segments;

 unsigned char misaligned;
 unsigned char discard_misaligned;
 unsigned char raid_partial_stripes_expensive;
 enum blk_zoned_model zoned;
};

typedef int (*report_zones_cb)(struct blk_zone *zone, unsigned int idx,
          void *data);
# 373 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blkdev_nr_zones(struct gendisk *disk)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blkdev_report_zones_ioctl(struct block_device *bdev,
         fmode_t mode, unsigned int cmd,
         unsigned long arg)
{
 return -25;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blkdev_zone_mgmt_ioctl(struct block_device *bdev,
      fmode_t mode, unsigned int cmd,
      unsigned long arg)
{
 return -25;
}



struct request_queue {
 struct request *last_merge;
 struct elevator_queue *elevator;

 struct blk_queue_stats *stats;
 struct rq_qos *rq_qos;

 make_request_fn *make_request_fn;
 dma_drain_needed_fn *dma_drain_needed;

 const struct blk_mq_ops *mq_ops;


 struct blk_mq_ctx *queue_ctx;

 unsigned int queue_depth;


 struct blk_mq_hw_ctx **queue_hw_ctx;
 unsigned int nr_hw_queues;

 struct backing_dev_info *backing_dev_info;





 void *queuedata;




 unsigned long queue_flags;





 atomic_t pm_only;





 int id;




 gfp_t bounce_gfp;

 spinlock_t queue_lock;




 struct kobject kobj;




 struct kobject *mq_kobj;






 struct device *dev;
 int rpm_status;
 unsigned int nr_pending;





 unsigned long nr_requests;

 unsigned int dma_drain_size;
 void *dma_drain_buffer;
 unsigned int dma_pad_mask;
 unsigned int dma_alignment;

 unsigned int rq_timeout;
 int poll_nsec;

 struct blk_stat_callback *poll_cb;
 struct blk_rq_stat poll_stat[16];

 struct timer_list timeout;
 struct work_struct timeout_work;

 struct list_head icq_list;






 struct queue_limits limits;

 unsigned int required_elevator_features;
# 523 "/home/nathan/src/linux-next/include/linux/blkdev.h"
 unsigned int sg_timeout;
 unsigned int sg_reserved_size;
 int node;

 struct blk_trace *blk_trace;
 struct mutex blk_trace_mutex;




 struct blk_flush_queue *fq;

 struct list_head requeue_list;
 spinlock_t requeue_lock;
 struct delayed_work requeue_work;

 struct mutex sysfs_lock;
 struct mutex sysfs_dir_lock;





 struct list_head unused_hctx_list;
 spinlock_t unused_hctx_lock;

 int mq_freeze_depth;


 struct bsg_class_device bsg_dev;






 struct callback_head callback_head;
 wait_queue_head_t mq_freeze_wq;




 struct mutex mq_freeze_lock;
 struct percpu_ref q_usage_counter;

 struct blk_mq_tag_set *tag_set;
 struct list_head tag_set_list;
 struct bio_set bio_split;


 struct dentry *debugfs_dir;
 struct dentry *sched_debugfs_dir;
 struct dentry *rqos_debugfs_dir;


 bool mq_sysfs_init_done;

 size_t cmd_size;

 struct work_struct release_work;


 u64 write_hints[5];
};
# 619 "/home/nathan/src/linux-next/include/linux/blkdev.h"
void blk_queue_flag_set(unsigned int flag, struct request_queue *q);
void blk_queue_flag_clear(unsigned int flag, struct request_queue *q);
bool blk_queue_flag_test_and_set(unsigned int flag, struct request_queue *q);
# 658 "/home/nathan/src/linux-next/include/linux/blkdev.h"
extern void blk_set_pm_only(struct request_queue *q);
extern void blk_clear_pm_only(struct request_queue *q);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_account_rq(struct request *rq)
{
 return (rq->rq_flags & (( req_flags_t)(1 << 1))) && !blk_rq_is_passthrough(rq);
}
# 677 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool queue_is_mq(struct request_queue *q)
{
 return q->mq_ops;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum blk_zoned_model
blk_queue_zoned_model(struct request_queue *q)
{
 return q->limits.zoned;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_queue_is_zoned(struct request_queue *q)
{
 switch (blk_queue_zoned_model(q)) {
 case BLK_ZONED_HA:
 case BLK_ZONED_HM:
  return true;
 default:
  return false;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t blk_queue_zone_sectors(struct request_queue *q)
{
 return blk_queue_is_zoned(q) ? q->limits.chunk_sectors : 0;
}
# 728 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_queue_nr_zones(struct request_queue *q)
{
 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rq_is_sync(struct request *rq)
{
 return op_is_sync(rq->cmd_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rq_mergeable(struct request *rq)
{
 if (blk_rq_is_passthrough(rq))
  return false;

 if (((rq)->cmd_flags & ((1 << 8) - 1)) == REQ_OP_FLUSH)
  return false;

 if (((rq)->cmd_flags & ((1 << 8) - 1)) == REQ_OP_WRITE_ZEROES)
  return false;

 if (rq->cmd_flags & ((1ULL << __REQ_NOMERGE) | (1ULL << __REQ_PREFLUSH) | (1ULL << __REQ_FUA)))
  return false;
 if (rq->rq_flags & ((( req_flags_t)(1 << 1)) | (( req_flags_t)(1 << 3)) | (( req_flags_t)(1 << 4)) | (( req_flags_t)(1 << 18))))
  return false;

 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_write_same_mergeable(struct bio *a, struct bio *b)
{
 if ((((&(((((a))->bi_io_vec)))[(((((a)->bi_iter)))).bi_idx])->bv_page) + (((&((((((a))->bi_io_vec))))[((((((a)->bi_iter))))).bi_idx])->bv_offset + (((((a)->bi_iter)))).bi_bvec_done) / (1UL << 16))) == (((&(((((b))->bi_io_vec)))[(((((b)->bi_iter)))).bi_idx])->bv_page) + (((&((((((b))->bi_io_vec))))[((((((b)->bi_iter))))).bi_idx])->bv_offset + (((((b)->bi_iter)))).bi_bvec_done) / (1UL << 16))) &&
     (((&(((((a))->bi_io_vec)))[(((((a)->bi_iter)))).bi_idx])->bv_offset + ((((a)->bi_iter))).bi_bvec_done) % (1UL << 16)) == (((&(((((b))->bi_io_vec)))[(((((b)->bi_iter)))).bi_idx])->bv_offset + ((((b)->bi_iter))).bi_bvec_done) % (1UL << 16)))
  return true;

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_queue_depth(struct request_queue *q)
{
 if (q->queue_depth)
  return q->queue_depth;

 return q->nr_requests;
}

extern unsigned long blk_max_low_pfn, blk_max_pfn;
# 799 "/home/nathan/src/linux-next/include/linux/blkdev.h"
struct rq_map_data {
 struct page **pages;
 int page_order;
 int nr_entries;
 unsigned long offset;
 int null_mapped;
 int from_user;
};

struct req_iterator {
 struct bvec_iter iter;
 struct bio *bio;
};
# 836 "/home/nathan/src/linux-next/include/linux/blkdev.h"
extern void rq_flush_dcache_pages(struct request *rq);






extern int blk_register_queue(struct gendisk *disk);
extern void blk_unregister_queue(struct gendisk *disk);
extern blk_qc_t generic_make_request(struct bio *bio);
extern blk_qc_t direct_make_request(struct bio *bio);
extern void blk_rq_init(struct request_queue *q, struct request *rq);
extern void blk_put_request(struct request *);
extern struct request *blk_get_request(struct request_queue *, unsigned int op,
           blk_mq_req_flags_t flags);
extern int blk_lld_busy(struct request_queue *q);
extern int blk_rq_prep_clone(struct request *rq, struct request *rq_src,
        struct bio_set *bs, gfp_t gfp_mask,
        int (*bio_ctr)(struct bio *, struct bio *, void *),
        void *data);
extern void blk_rq_unprep_clone(struct request *rq);
extern blk_status_t blk_insert_cloned_request(struct request_queue *q,
         struct request *rq);
extern int blk_rq_append_bio(struct request *rq, struct bio **bio);
extern void blk_queue_split(struct request_queue *, struct bio **);
extern int scsi_verify_blk_ioctl(struct block_device *, unsigned int);
extern int scsi_cmd_blk_ioctl(struct block_device *, fmode_t,
         unsigned int, void *);
extern int scsi_cmd_ioctl(struct request_queue *, struct gendisk *, fmode_t,
     unsigned int, void *);
extern int sg_scsi_ioctl(struct request_queue *, struct gendisk *, fmode_t,
    struct scsi_ioctl_command *);
extern int get_sg_io_hdr(struct sg_io_hdr *hdr, const void *argp);
extern int put_sg_io_hdr(const struct sg_io_hdr *hdr, void *argp);

extern int blk_queue_enter(struct request_queue *q, blk_mq_req_flags_t flags);
extern void blk_queue_exit(struct request_queue *q);
extern void blk_sync_queue(struct request_queue *q);
extern int blk_rq_map_user(struct request_queue *, struct request *,
      struct rq_map_data *, void *, unsigned long,
      gfp_t);
extern int blk_rq_unmap_user(struct bio *);
extern int blk_rq_map_kern(struct request_queue *, struct request *, void *, unsigned int, gfp_t);
extern int blk_rq_map_user_iov(struct request_queue *, struct request *,
          struct rq_map_data *, const struct iov_iter *,
          gfp_t);
extern void blk_execute_rq(struct request_queue *, struct gendisk *,
     struct request *, int);
extern void blk_execute_rq_nowait(struct request_queue *, struct gendisk *,
      struct request *, int, rq_end_io_fn *);


extern const char *blk_op_str(unsigned int op);

int blk_status_to_errno(blk_status_t status);
blk_status_t errno_to_blk_status(int errno);

int blk_poll(struct request_queue *q, blk_qc_t cookie, bool spin);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct request_queue *bdev_get_queue(struct block_device *bdev)
{
 return bdev->bd_disk->queue;
}
# 922 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t blk_rq_pos(const struct request *rq)
{
 return rq->__sector;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_bytes(const struct request *rq)
{
 return rq->__data_len;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_rq_cur_bytes(const struct request *rq)
{
 return rq->bio ? bio_cur_bytes(rq->bio) : 0;
}

extern unsigned int blk_rq_err_bytes(const struct request *rq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_sectors(const struct request *rq)
{
 return blk_rq_bytes(rq) >> 9;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_cur_sectors(const struct request *rq)
{
 return blk_rq_cur_bytes(rq) >> 9;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_stats_sectors(const struct request *rq)
{
 return rq->stats_sectors;
}
# 972 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_payload_bytes(struct request *rq)
{
 if (rq->rq_flags & (( req_flags_t)(1 << 18)))
  return rq->special_vec.bv_len;
 return blk_rq_bytes(rq);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio_vec req_bvec(struct request *rq)
{
 if (rq->rq_flags & (( req_flags_t)(1 << 18)))
  return rq->special_vec;
 return ((struct bio_vec) { .bv_page = ((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_page), .bv_len = __builtin_choose_expr(((!!(sizeof((typeof(((rq->bio->bi_iter)).bi_size) *)1 == (typeof((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(((rq->bio->bi_iter)).bi_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done) * 0l)) : (int *)8))))), ((((rq->bio->bi_iter)).bi_size) < ((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done) ? (((rq->bio->bi_iter)).bi_size) : ((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done)), ({ typeof(((rq->bio->bi_iter)).bi_size) __UNIQUE_ID___x52 = (((rq->bio->bi_iter)).bi_size); typeof((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done) __UNIQUE_ID___y53 = ((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_len - ((rq->bio->bi_iter)).bi_bvec_done); ((__UNIQUE_ID___x52) < (__UNIQUE_ID___y53) ? (__UNIQUE_ID___x52) : (__UNIQUE_ID___y53)); })), .bv_offset = ((&(((rq->bio->bi_io_vec)))[(((rq->bio->bi_iter))).bi_idx])->bv_offset + ((rq->bio->bi_iter)).bi_bvec_done), });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_queue_get_max_sectors(struct request_queue *q,
           int op)
{
 if (__builtin_expect(!!(op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE), 0))
  return __builtin_choose_expr(((!!(sizeof((typeof(q->limits.max_discard_sectors) *)1 == (typeof((~0U) >> 9) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(q->limits.max_discard_sectors) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((~0U) >> 9) * 0l)) : (int *)8))))), ((q->limits.max_discard_sectors) < ((~0U) >> 9) ? (q->limits.max_discard_sectors) : ((~0U) >> 9)), ({ typeof(q->limits.max_discard_sectors) __UNIQUE_ID___x54 = (q->limits.max_discard_sectors); typeof((~0U) >> 9) __UNIQUE_ID___y55 = ((~0U) >> 9); ((__UNIQUE_ID___x54) < (__UNIQUE_ID___y55) ? (__UNIQUE_ID___x54) : (__UNIQUE_ID___y55)); }));


 if (__builtin_expect(!!(op == REQ_OP_WRITE_SAME), 0))
  return q->limits.max_write_same_sectors;

 if (__builtin_expect(!!(op == REQ_OP_WRITE_ZEROES), 0))
  return q->limits.max_write_zeroes_sectors;

 return q->limits.max_sectors;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_max_size_offset(struct request_queue *q,
            sector_t offset)
{
 if (!q->limits.chunk_sectors)
  return q->limits.max_sectors;

 return __builtin_choose_expr(((!!(sizeof((typeof(q->limits.max_sectors) *)1 == (typeof((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(q->limits.max_sectors) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1)))) * 0l)) : (int *)8))))), ((q->limits.max_sectors) < ((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1)))) ? (q->limits.max_sectors) : ((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1))))), ({ typeof(q->limits.max_sectors) __UNIQUE_ID___x56 = (q->limits.max_sectors); typeof((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1)))) __UNIQUE_ID___y57 = ((unsigned int)(q->limits.chunk_sectors - (offset & (q->limits.chunk_sectors - 1)))); ((__UNIQUE_ID___x56) < (__UNIQUE_ID___y57) ? (__UNIQUE_ID___x56) : (__UNIQUE_ID___y57)); }));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_get_max_sectors(struct request *rq,
        sector_t offset)
{
 struct request_queue *q = rq->q;

 if (blk_rq_is_passthrough(rq))
  return q->limits.max_hw_sectors;

 if (!q->limits.chunk_sectors ||
     ((rq)->cmd_flags & ((1 << 8) - 1)) == REQ_OP_DISCARD ||
     ((rq)->cmd_flags & ((1 << 8) - 1)) == REQ_OP_SECURE_ERASE)
  return blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)));

 return __builtin_choose_expr(((!!(sizeof((typeof(blk_max_size_offset(q, offset)) *)1 == (typeof(blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(blk_max_size_offset(q, offset)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)))) * 0l)) : (int *)8))))), ((blk_max_size_offset(q, offset)) < (blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)))) ? (blk_max_size_offset(q, offset)) : (blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1))))), ({ typeof(blk_max_size_offset(q, offset)) __UNIQUE_ID___x58 = (blk_max_size_offset(q, offset)); typeof(blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)))) __UNIQUE_ID___y59 = (blk_queue_get_max_sectors(q, ((rq)->cmd_flags & ((1 << 8) - 1)))); ((__UNIQUE_ID___x58) < (__UNIQUE_ID___y59) ? (__UNIQUE_ID___x58) : (__UNIQUE_ID___y59)); }));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blk_rq_count_bios(struct request *rq)
{
 unsigned int nr_bios = 0;
 struct bio *bio;

 if ((rq->bio)) for (bio = (rq)->bio; bio; bio = bio->bi_next)
  nr_bios++;

 return nr_bios;
}

void blk_steal_bios(struct bio_list *list, struct request *rq);







extern bool blk_update_request(struct request *rq, blk_status_t error,
          unsigned int nr_bytes);

extern void __blk_complete_request(struct request *);
extern void blk_abort_request(struct request *);




extern void blk_cleanup_queue(struct request_queue *);
extern void blk_queue_make_request(struct request_queue *, make_request_fn *);
extern void blk_queue_bounce_limit(struct request_queue *, u64);
extern void blk_queue_max_hw_sectors(struct request_queue *, unsigned int);
extern void blk_queue_chunk_sectors(struct request_queue *, unsigned int);
extern void blk_queue_max_segments(struct request_queue *, unsigned short);
extern void blk_queue_max_discard_segments(struct request_queue *,
  unsigned short);
extern void blk_queue_max_segment_size(struct request_queue *, unsigned int);
extern void blk_queue_max_discard_sectors(struct request_queue *q,
  unsigned int max_discard_sectors);
extern void blk_queue_max_write_same_sectors(struct request_queue *q,
  unsigned int max_write_same_sectors);
extern void blk_queue_max_write_zeroes_sectors(struct request_queue *q,
  unsigned int max_write_same_sectors);
extern void blk_queue_logical_block_size(struct request_queue *, unsigned int);
extern void blk_queue_physical_block_size(struct request_queue *, unsigned int);
extern void blk_queue_alignment_offset(struct request_queue *q,
           unsigned int alignment);
extern void blk_limits_io_min(struct queue_limits *limits, unsigned int min);
extern void blk_queue_io_min(struct request_queue *q, unsigned int min);
extern void blk_limits_io_opt(struct queue_limits *limits, unsigned int opt);
extern void blk_queue_io_opt(struct request_queue *q, unsigned int opt);
extern void blk_set_queue_depth(struct request_queue *q, unsigned int depth);
extern void blk_set_default_limits(struct queue_limits *lim);
extern void blk_set_stacking_limits(struct queue_limits *lim);
extern int blk_stack_limits(struct queue_limits *t, struct queue_limits *b,
       sector_t offset);
extern int bdev_stack_limits(struct queue_limits *t, struct block_device *bdev,
       sector_t offset);
extern void disk_stack_limits(struct gendisk *disk, struct block_device *bdev,
         sector_t offset);
extern void blk_queue_stack_limits(struct request_queue *t, struct request_queue *b);
extern void blk_queue_update_dma_pad(struct request_queue *, unsigned int);
extern int blk_queue_dma_drain(struct request_queue *q,
          dma_drain_needed_fn *dma_drain_needed,
          void *buf, unsigned int size);
extern void blk_queue_segment_boundary(struct request_queue *, unsigned long);
extern void blk_queue_virt_boundary(struct request_queue *, unsigned long);
extern void blk_queue_dma_alignment(struct request_queue *, int);
extern void blk_queue_update_dma_alignment(struct request_queue *, int);
extern void blk_queue_rq_timeout(struct request_queue *, unsigned int);
extern void blk_queue_write_cache(struct request_queue *q, bool enabled, bool fua);
extern void blk_queue_required_elevator_features(struct request_queue *q,
       unsigned int features);
extern bool blk_queue_can_use_dma_map_merging(struct request_queue *q,
           struct device *dev);
# 1122 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short blk_rq_nr_phys_segments(struct request *rq)
{
 if (rq->rq_flags & (( req_flags_t)(1 << 18)))
  return 1;
 return rq->nr_phys_segments;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short blk_rq_nr_discard_segments(struct request *rq)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((unsigned short)(rq->nr_phys_segments)) *)1 == (typeof((unsigned short)(1)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned short)(rq->nr_phys_segments)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned short)(1)) * 0l)) : (int *)8))))), (((unsigned short)(rq->nr_phys_segments)) > ((unsigned short)(1)) ? ((unsigned short)(rq->nr_phys_segments)) : ((unsigned short)(1))), ({ typeof((unsigned short)(rq->nr_phys_segments)) __UNIQUE_ID___x60 = ((unsigned short)(rq->nr_phys_segments)); typeof((unsigned short)(1)) __UNIQUE_ID___y61 = ((unsigned short)(1)); ((__UNIQUE_ID___x60) > (__UNIQUE_ID___y61) ? (__UNIQUE_ID___x60) : (__UNIQUE_ID___y61)); }));
}

extern int blk_rq_map_sg(struct request_queue *, struct request *, struct scatterlist *);
extern void blk_dump_rq_flags(struct request *, char *);
extern long nr_blockdev_pages(void);

bool __attribute__((__warn_unused_result__)) blk_get_queue(struct request_queue *);
struct request_queue *blk_alloc_queue(gfp_t);
struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id);
extern void blk_put_queue(struct request_queue *);
extern void blk_set_queue_dying(struct request_queue *);
# 1160 "/home/nathan/src/linux-next/include/linux/blkdev.h"
struct blk_plug {
 struct list_head mq_list;
 struct list_head cb_list;
 unsigned short rq_count;
 bool multiple_queues;
};



struct blk_plug_cb;
typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);
struct blk_plug_cb {
 struct list_head list;
 blk_plug_cb_fn callback;
 void *data;
};
extern struct blk_plug_cb *blk_check_plugged(blk_plug_cb_fn unplug,
          void *data, int size);
extern void blk_start_plug(struct blk_plug *);
extern void blk_finish_plug(struct blk_plug *);
extern void blk_flush_plug_list(struct blk_plug *, bool);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_flush_plug(struct task_struct *tsk)
{
 struct blk_plug *plug = tsk->plug;

 if (plug)
  blk_flush_plug_list(plug, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_schedule_flush_plug(struct task_struct *tsk)
{
 struct blk_plug *plug = tsk->plug;

 if (plug)
  blk_flush_plug_list(plug, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_needs_flush_plug(struct task_struct *tsk)
{
 struct blk_plug *plug = tsk->plug;

 return plug &&
   (!list_empty(&plug->mq_list) ||
   !list_empty(&plug->cb_list));
}

extern int blkdev_issue_flush(struct block_device *, gfp_t, sector_t *);
extern int blkdev_issue_write_same(struct block_device *bdev, sector_t sector,
  sector_t nr_sects, gfp_t gfp_mask, struct page *page);



extern int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
  sector_t nr_sects, gfp_t gfp_mask, unsigned long flags);
extern int __blkdev_issue_discard(struct block_device *bdev, sector_t sector,
  sector_t nr_sects, gfp_t gfp_mask, int flags,
  struct bio **biop);




extern int __blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,
  sector_t nr_sects, gfp_t gfp_mask, struct bio **biop,
  unsigned flags);
extern int blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,
  sector_t nr_sects, gfp_t gfp_mask, unsigned flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_issue_discard(struct super_block *sb, sector_t block,
  sector_t nr_blocks, gfp_t gfp_mask, unsigned long flags)
{
 return blkdev_issue_discard(sb->s_bdev,
        block << (sb->s_blocksize_bits -
           9),
        nr_blocks << (sb->s_blocksize_bits -
        9),
        gfp_mask, flags);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sb_issue_zeroout(struct super_block *sb, sector_t block,
  sector_t nr_blocks, gfp_t gfp_mask)
{
 return blkdev_issue_zeroout(sb->s_bdev,
        block << (sb->s_blocksize_bits -
           9),
        nr_blocks << (sb->s_blocksize_bits -
        9),
        gfp_mask, 0);
}

extern int blk_verify_command(unsigned char *cmd, fmode_t mode);

enum blk_default_limits {
 BLK_MAX_SEGMENTS = 128,
 BLK_SAFE_MAX_SECTORS = 255,
 BLK_DEF_MAX_SECTORS = 2560,
 BLK_MAX_SEGMENT_SIZE = 65536,
 BLK_SEG_BOUNDARY_MASK = 0xFFFFFFFFUL,
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long queue_segment_boundary(const struct request_queue *q)
{
 return q->limits.seg_boundary_mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long queue_virt_boundary(const struct request_queue *q)
{
 return q->limits.virt_boundary_mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_max_sectors(const struct request_queue *q)
{
 return q->limits.max_sectors;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_max_hw_sectors(const struct request_queue *q)
{
 return q->limits.max_hw_sectors;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short queue_max_segments(const struct request_queue *q)
{
 return q->limits.max_segments;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short queue_max_discard_segments(const struct request_queue *q)
{
 return q->limits.max_discard_segments;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_max_segment_size(const struct request_queue *q)
{
 return q->limits.max_segment_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned queue_logical_block_size(const struct request_queue *q)
{
 int retval = 512;

 if (q && q->limits.logical_block_size)
  retval = q->limits.logical_block_size;

 return retval;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bdev_logical_block_size(struct block_device *bdev)
{
 return queue_logical_block_size(bdev_get_queue(bdev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_physical_block_size(const struct request_queue *q)
{
 return q->limits.physical_block_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bdev_physical_block_size(struct block_device *bdev)
{
 return queue_physical_block_size(bdev_get_queue(bdev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_io_min(const struct request_queue *q)
{
 return q->limits.io_min;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bdev_io_min(struct block_device *bdev)
{
 return queue_io_min(bdev_get_queue(bdev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int queue_io_opt(const struct request_queue *q)
{
 return q->limits.io_opt;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bdev_io_opt(struct block_device *bdev)
{
 return queue_io_opt(bdev_get_queue(bdev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int queue_alignment_offset(const struct request_queue *q)
{
 if (q->limits.misaligned)
  return -1;

 return q->limits.alignment_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int queue_limit_alignment_offset(struct queue_limits *lim, sector_t sector)
{
 unsigned int granularity = __builtin_choose_expr(((!!(sizeof((typeof(lim->physical_block_size) *)1 == (typeof(lim->io_min) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(lim->physical_block_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(lim->io_min) * 0l)) : (int *)8))))), ((lim->physical_block_size) > (lim->io_min) ? (lim->physical_block_size) : (lim->io_min)), ({ typeof(lim->physical_block_size) __UNIQUE_ID___x62 = (lim->physical_block_size); typeof(lim->io_min) __UNIQUE_ID___y63 = (lim->io_min); ((__UNIQUE_ID___x62) > (__UNIQUE_ID___y63) ? (__UNIQUE_ID___x62) : (__UNIQUE_ID___y63)); }));
 unsigned int alignment = ({ uint32_t __base = (granularity >> 9); uint32_t __rem; __rem = ((uint64_t)(sector)) % __base; (sector) = ((uint64_t)(sector)) / __base; __rem; })
  << 9;

 return (granularity + lim->alignment_offset - alignment) % granularity;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bdev_alignment_offset(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q->limits.misaligned)
  return -1;

 if (bdev != bdev->bd_contains)
  return bdev->bd_part->alignment_offset;

 return q->limits.alignment_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int queue_discard_alignment(const struct request_queue *q)
{
 if (q->limits.discard_misaligned)
  return -1;

 return q->limits.discard_alignment;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int queue_limit_discard_alignment(struct queue_limits *lim, sector_t sector)
{
 unsigned int alignment, granularity, offset;

 if (!lim->max_discard_sectors)
  return 0;


 alignment = lim->discard_alignment >> 9;
 granularity = lim->discard_granularity >> 9;
 if (!granularity)
  return 0;


 offset = ({ uint32_t __base = (granularity); uint32_t __rem; __rem = ((uint64_t)(sector)) % __base; (sector) = ((uint64_t)(sector)) / __base; __rem; });


 offset = (granularity + alignment - offset) % granularity;


 return offset << 9;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bdev_discard_alignment(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (bdev != bdev->bd_contains)
  return bdev->bd_part->discard_alignment;

 return q->limits.discard_alignment;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bdev_write_same(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q)
  return q->limits.max_write_same_sectors;

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bdev_write_zeroes_sectors(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q)
  return q->limits.max_write_zeroes_sectors;

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) enum blk_zoned_model bdev_zoned_model(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q)
  return blk_queue_zoned_model(q);

 return BLK_ZONED_NONE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bdev_is_zoned(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q)
  return blk_queue_is_zoned(q);

 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) sector_t bdev_zone_sectors(struct block_device *bdev)
{
 struct request_queue *q = bdev_get_queue(bdev);

 if (q)
  return blk_queue_zone_sectors(q);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int queue_dma_alignment(const struct request_queue *q)
{
 return q ? q->dma_alignment : 511;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_rq_aligned(struct request_queue *q, unsigned long addr,
     unsigned int len)
{
 unsigned int alignment = queue_dma_alignment(q) | q->dma_pad_mask;
 return !(addr & alignment) && !(len & alignment);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int blksize_bits(unsigned int size)
{
 unsigned int bits = 8;
 do {
  bits++;
  size >>= 1;
 } while (size > 256);
 return bits;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int block_size(struct block_device *bdev)
{
 return bdev->bd_block_size;
}

typedef struct {struct page *v;} Sector;

unsigned char *read_dev_sector(struct block_device *, sector_t, Sector *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void put_dev_sector(Sector p)
{
 put_page(p.v);
}

int kblockd_schedule_work(struct work_struct *work);
int kblockd_schedule_work_on(int cpu, struct work_struct *work);
int kblockd_mod_delayed_work_on(int cpu, struct delayed_work *dwork, unsigned long delay);
# 1614 "/home/nathan/src/linux-next/include/linux/blkdev.h"
struct bio;
struct block_device;
struct gendisk;
struct blk_integrity;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_integrity_rq(struct request *rq)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_rq_count_integrity_sg(struct request_queue *q,
         struct bio *b)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_rq_map_integrity_sg(struct request_queue *q,
       struct bio *b,
       struct scatterlist *s)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blk_integrity *bdev_get_integrity(struct block_device *b)
{
 return ((void *)0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blk_integrity *blk_get_integrity(struct gendisk *disk)
{
 return ((void *)0);
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blk_integrity_compare(struct gendisk *a, struct gendisk *b)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_integrity_register(struct gendisk *d,
      struct blk_integrity *b)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_integrity_unregister(struct gendisk *d)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_queue_max_integrity_segments(struct request_queue *q,
          unsigned int segs)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short queue_max_integrity_segments(const struct request_queue *q)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_integrity_merge_rq(struct request_queue *rq,
       struct request *r1,
       struct request *r2)
{
 return true;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_integrity_merge_bio(struct request_queue *rq,
        struct request *r,
        struct bio *b)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bio_integrity_intervals(struct blk_integrity *bi,
         unsigned int sectors)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bio_integrity_bytes(struct blk_integrity *bi,
            unsigned int sectors)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bio_vec *rq_integrity_vec(struct request *rq)
{
 return ((void *)0);
}



struct block_device_operations {
 int (*open) (struct block_device *, fmode_t);
 void (*release) (struct gendisk *, fmode_t);
 int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
 int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
 int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
 unsigned int (*check_events) (struct gendisk *disk,
          unsigned int clearing);

 int (*media_changed) (struct gendisk *);
 void (*unlock_native_capacity) (struct gendisk *);
 int (*revalidate_disk) (struct gendisk *);
 int (*getgeo)(struct block_device *, struct hd_geometry *);

 void (*swap_slot_free_notify) (struct block_device *, unsigned long);
 int (*report_zones)(struct gendisk *, sector_t sector,
   unsigned int nr_zones, report_zones_cb cb, void *data);
 struct module *owner;
 const struct pr_ops *pr_ops;
};


extern int blkdev_compat_ptr_ioctl(struct block_device *, fmode_t,
          unsigned int, unsigned long);




extern int __blkdev_driver_ioctl(struct block_device *, fmode_t, unsigned int,
     unsigned long);
extern int bdev_read_page(struct block_device *, sector_t, struct page *);
extern int bdev_write_page(struct block_device *, sector_t, struct page *,
      struct writeback_control *);
# 1757 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_req_needs_zone_write_lock(struct request *rq)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_req_zone_write_lock(struct request *rq)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_req_zone_write_unlock(struct request *rq)
{
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_req_zone_is_write_locked(struct request *rq)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_req_can_dispatch_to_zone(struct request *rq)
{
 return true;
}
# 1827 "/home/nathan/src/linux-next/include/linux/blkdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blk_wake_io_task(struct task_struct *waiter)
{





 if (waiter == get_current())
  get_current()->state = (0x0000);
 else
  wake_up_process(waiter);
}
# 24 "/home/nathan/src/linux-next/include/linux/blk-cgroup.h" 2
# 694 "/home/nathan/src/linux-next/include/linux/blk-cgroup.h"
struct blkcg {
};

struct blkg_policy_data {
};

struct blkcg_policy_data {
};

struct blkcg_gq {
};

struct blkcg_policy {
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_maybe_throttle_current(void) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blk_cgroup_congested(void) { return false; }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_schedule_throttle(struct request_queue *q, bool use_memdelay) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkcg_gq *blkg_lookup(struct blkcg *blkcg, void *key) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkcg_gq *blk_queue_root_blkg(struct request_queue *q)
{ return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blkcg_init_queue(struct request_queue *q) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_exit_queue(struct request_queue *q) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blkcg_policy_register(struct blkcg_policy *pol) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_policy_unregister(struct blkcg_policy *pol) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int blkcg_activate_policy(struct request_queue *q,
     const struct blkcg_policy *pol) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_deactivate_policy(struct request_queue *q,
        const struct blkcg_policy *pol) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkcg *__bio_blkcg(struct bio *bio) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkcg *bio_blkcg(struct bio *bio) { return ((void *)0); }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkg_policy_data *blkg_to_pd(struct blkcg_gq *blkg,
        struct blkcg_policy *pol) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct blkcg_gq *pd_to_blkg(struct blkg_policy_data *pd) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char *blkg_path(struct blkcg_gq *blkg) { return ((void *)0); }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkg_get(struct blkcg_gq *blkg) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkg_put(struct blkcg_gq *blkg) { }

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blkcg_punt_bio_submit(struct bio *bio) { return false; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void blkcg_bio_issue_init(struct bio *bio) { }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool blkcg_bio_issue_check(struct request_queue *q,
      struct bio *bio) { return true; }
# 15 "/home/nathan/src/linux-next/include/linux/writeback.h" 2

struct bio;

extern __attribute__((section(".data..percpu" ""))) __typeof__(int) dirty_throttle_leaks;
# 36 "/home/nathan/src/linux-next/include/linux/writeback.h"
struct backing_dev_info;




enum writeback_sync_modes {
 WB_SYNC_NONE,
 WB_SYNC_ALL,
};






struct writeback_control {
 long nr_to_write;

 long pages_skipped;






 loff_t range_start;
 loff_t range_end;

 enum writeback_sync_modes sync_mode;

 unsigned for_kupdate:1;
 unsigned for_background:1;
 unsigned tagged_writepages:1;
 unsigned for_reclaim:1;
 unsigned range_cyclic:1;
 unsigned for_sync:1;







 unsigned no_cgroup_owner:1;

 unsigned punt_to_cgroup:1;
# 95 "/home/nathan/src/linux-next/include/linux/writeback.h"
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int wbc_to_write_flags(struct writeback_control *wbc)
{
 int flags = 0;

 if (wbc->punt_to_cgroup)
  flags = (1ULL << __REQ_CGROUP_PUNT);

 if (wbc->sync_mode == WB_SYNC_ALL)
  flags |= (1ULL << __REQ_SYNC);
 else if (wbc->for_kupdate || wbc->for_background)
  flags |= (1ULL << __REQ_BACKGROUND);

 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct cgroup_subsys_state *
wbc_blkcg_css(struct writeback_control *wbc)
{




 return ((struct cgroup_subsys_state *)ERR_PTR(-22));
}
# 129 "/home/nathan/src/linux-next/include/linux/writeback.h"
struct wb_domain {
 spinlock_t lock;
# 149 "/home/nathan/src/linux-next/include/linux/writeback.h"
 struct fprop_global completions;
 struct timer_list period_timer;
 unsigned long period_time;
# 163 "/home/nathan/src/linux-next/include/linux/writeback.h"
 unsigned long dirty_limit_tstamp;
 unsigned long dirty_limit;
};
# 179 "/home/nathan/src/linux-next/include/linux/writeback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wb_domain_size_changed(struct wb_domain *dom)
{
 spin_lock(&dom->lock);
 dom->dirty_limit_tstamp = jiffies;
 dom->dirty_limit = 0;
 spin_unlock(&dom->lock);
}




struct bdi_writeback;
void writeback_inodes_sb(struct super_block *, enum wb_reason reason);
void writeback_inodes_sb_nr(struct super_block *, unsigned long nr,
       enum wb_reason reason);
void try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason);
void sync_inodes_sb(struct super_block *);
void wakeup_flusher_threads(enum wb_reason reason);
void wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,
    enum wb_reason reason);
void inode_wait_for_writeback(struct inode *inode);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wait_on_inode(struct inode *inode)
{
 do { do { } while (0); } while (0);
 wait_on_bit(&inode->i_state, 3, 0x0002);
}
# 295 "/home/nathan/src/linux-next/include/linux/writeback.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_attach_wb(struct inode *inode, struct page *page)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inode_detach_wb(struct inode *inode)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wbc_attach_and_unlock_inode(struct writeback_control *wbc,
            struct inode *inode)

{
 spin_unlock(&inode->i_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wbc_attach_fdatawrite_inode(struct writeback_control *wbc,
            struct inode *inode)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wbc_detach_inode(struct writeback_control *wbc)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wbc_init_bio(struct writeback_control *wbc, struct bio *bio)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void wbc_account_cgroup_owner(struct writeback_control *wbc,
         struct page *page, size_t bytes)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void cgroup_writeback_umount(void)
{
}







void laptop_io_completion(struct backing_dev_info *info);
void laptop_sync_completion(void);
void laptop_mode_sync(struct work_struct *work);
void laptop_mode_timer_fn(struct timer_list *t);



bool node_dirty_ok(struct pglist_data *pgdat);
int wb_domain_init(struct wb_domain *dom, gfp_t gfp);




extern struct wb_domain global_wb_domain;


extern int dirty_background_ratio;
extern unsigned long dirty_background_bytes;
extern int vm_dirty_ratio;
extern unsigned long vm_dirty_bytes;
extern unsigned int dirty_writeback_interval;
extern unsigned int dirty_expire_interval;
extern unsigned int dirtytime_expire_interval;
extern int vm_highmem_is_dirtyable;
extern int block_dump;
extern int laptop_mode;

extern int dirty_background_ratio_handler(struct ctl_table *table, int write,
  void *buffer, size_t *lenp,
  loff_t *ppos);
extern int dirty_background_bytes_handler(struct ctl_table *table, int write,
  void *buffer, size_t *lenp,
  loff_t *ppos);
extern int dirty_ratio_handler(struct ctl_table *table, int write,
  void *buffer, size_t *lenp,
  loff_t *ppos);
extern int dirty_bytes_handler(struct ctl_table *table, int write,
  void *buffer, size_t *lenp,
  loff_t *ppos);
int dirtytime_interval_handler(struct ctl_table *table, int write,
          void *buffer, size_t *lenp, loff_t *ppos);

struct ctl_table;
int dirty_writeback_centisecs_handler(struct ctl_table *, int,
          void *, size_t *, loff_t *);

void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty);
unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh);

void wb_update_bandwidth(struct bdi_writeback *wb, unsigned long start_time);
void balance_dirty_pages_ratelimited(struct address_space *mapping);
bool wb_over_bg_thresh(struct bdi_writeback *wb);

typedef int (*writepage_t)(struct page *page, struct writeback_control *wbc,
    void *data);

int generic_writepages(struct address_space *mapping,
         struct writeback_control *wbc);
void tag_pages_for_writeback(struct address_space *mapping,
        unsigned long start, unsigned long end);
int write_cache_pages(struct address_space *mapping,
        struct writeback_control *wbc, writepage_t writepage,
        void *data);
int do_writepages(struct address_space *mapping, struct writeback_control *wbc);
void writeback_set_ratelimit(void);
void tag_pages_for_writeback(struct address_space *mapping,
        unsigned long start, unsigned long end);

void account_page_redirty(struct page *page);

void sb_mark_inode_writeback(struct inode *inode);
void sb_clear_inode_writeback(struct inode *inode);
# 23 "/home/nathan/src/linux-next/include/linux/memcontrol.h" 2


struct mem_cgroup;
struct page;
struct mm_struct;
struct kmem_cache;


enum memcg_stat_item {
 MEMCG_CACHE = NR_VM_NODE_STAT_ITEMS,
 MEMCG_RSS,
 MEMCG_RSS_HUGE,
 MEMCG_SWAP,
 MEMCG_SOCK,

 MEMCG_KERNEL_STACK_KB,
 MEMCG_NR_STAT,
};

enum memcg_memory_event {
 MEMCG_LOW,
 MEMCG_HIGH,
 MEMCG_MAX,
 MEMCG_OOM,
 MEMCG_OOM_KILL,
 MEMCG_SWAP_MAX,
 MEMCG_SWAP_FAIL,
 MEMCG_NR_MEMORY_EVENTS,
};

enum mem_cgroup_protection {
 MEMCG_PROT_NONE,
 MEMCG_PROT_LOW,
 MEMCG_PROT_MIN,
};

struct mem_cgroup_reclaim_cookie {
 pg_data_t *pgdat;
 unsigned int generation;
};






struct mem_cgroup_id {
 int id;
 refcount_t ref;
};







enum mem_cgroup_events_target {
 MEM_CGROUP_TARGET_THRESH,
 MEM_CGROUP_TARGET_SOFTLIMIT,
 MEM_CGROUP_NTARGETS,
};

struct memcg_vmstats_percpu {
 long stat[MEMCG_NR_STAT];
 unsigned long events[NR_VM_EVENT_ITEMS];
 unsigned long nr_page_events;
 unsigned long targets[MEM_CGROUP_NTARGETS];
};

struct mem_cgroup_reclaim_iter {
 struct mem_cgroup *position;

 unsigned int generation;
};

struct lruvec_stat {
 long count[NR_VM_NODE_STAT_ITEMS];
};





struct memcg_shrinker_map {
 struct callback_head rcu;
 unsigned long map[0];
};




struct mem_cgroup_per_node {
 struct lruvec lruvec;


 struct lruvec_stat *lruvec_stat_local;


 struct lruvec_stat *lruvec_stat_cpu;
 atomic_long_t lruvec_stat[NR_VM_NODE_STAT_ITEMS];

 unsigned long lru_zone_size[2][NR_LRU_LISTS];

 struct mem_cgroup_reclaim_iter iter;

 struct memcg_shrinker_map *shrinker_map;

 struct rb_node tree_node;
 unsigned long usage_in_excess;

 bool on_tree;
 struct mem_cgroup *memcg;

};

struct mem_cgroup_threshold {
 struct eventfd_ctx *eventfd;
 unsigned long threshold;
};


struct mem_cgroup_threshold_ary {

 int current_threshold;

 unsigned int size;

 struct mem_cgroup_threshold entries[0];
};

struct mem_cgroup_thresholds {

 struct mem_cgroup_threshold_ary *primary;





 struct mem_cgroup_threshold_ary *spare;
};

enum memcg_kmem_state {
 KMEM_NONE,
 KMEM_ALLOCATED,
 KMEM_ONLINE,
};


struct memcg_padding {
 char x[0];
} __attribute__((__aligned__(1 << (7))));
# 190 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
struct memcg_cgwb_frn {
 u64 bdi_id;
 int memcg_id;
 u64 at;
 struct wb_completion done;
};







struct mem_cgroup {
 struct cgroup_subsys_state css;


 struct mem_cgroup_id id;


 struct page_counter memory;
 struct page_counter swap;


 struct page_counter memsw;
 struct page_counter kmem;
 struct page_counter tcpmem;


 unsigned long high;


 struct work_struct high_work;

 unsigned long soft_limit;


 struct vmpressure vmpressure;




 bool use_hierarchy;




 bool oom_group;


 bool oom_lock;
 int under_oom;

 int swappiness;

 int oom_kill_disable;


 struct cgroup_file events_file;
 struct cgroup_file events_local_file;


 struct cgroup_file swap_events_file;


 struct mutex thresholds_lock;


 struct mem_cgroup_thresholds thresholds;


 struct mem_cgroup_thresholds memsw_thresholds;


 struct list_head oom_notify;





 unsigned long move_charge_at_immigrate;

 spinlock_t move_lock;
 unsigned long move_lock_flags;

 struct memcg_padding _pad1_;;




 atomic_t moving_account;
 struct task_struct *move_lock_task;


 struct memcg_vmstats_percpu *vmstats_local;


 struct memcg_vmstats_percpu *vmstats_percpu;

 struct memcg_padding _pad2_;;

 atomic_long_t vmstats[MEMCG_NR_STAT];
 atomic_long_t vmevents[NR_VM_EVENT_ITEMS];


 atomic_long_t memory_events[MEMCG_NR_MEMORY_EVENTS];
 atomic_long_t memory_events_local[MEMCG_NR_MEMORY_EVENTS];

 unsigned long socket_pressure;


 bool tcpmem_active;
 int tcpmem_pressure;



 int kmemcg_id;
 enum memcg_kmem_state kmem_state;
 struct list_head kmem_caches;
# 318 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
 struct list_head event_list;
 spinlock_t event_list_lock;


 struct deferred_split deferred_split_queue;


 struct mem_cgroup_per_node *nodeinfo[0];

};







extern struct mem_cgroup *root_mem_cgroup;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_cgroup_is_root(struct mem_cgroup *memcg)
{
 return (memcg == root_mem_cgroup);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_cgroup_disabled(void)
{
 return !({ bool branch; if (__builtin_types_compatible_p(typeof(*&memory_cgrp_subsys_enabled_key), struct static_key_true)) branch = !arch_static_branch(&(&memory_cgrp_subsys_enabled_key)->key, true); else if (__builtin_types_compatible_p(typeof(*&memory_cgrp_subsys_enabled_key), struct static_key_false)) branch = !arch_static_branch_jump(&(&memory_cgrp_subsys_enabled_key)->key, true); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 1); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long mem_cgroup_protection(struct mem_cgroup *memcg,
        bool in_low_reclaim)
{
 if (mem_cgroup_disabled())
  return 0;

 if (in_low_reclaim)
  return ({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; });

 return __builtin_choose_expr(((!!(sizeof((typeof(({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })) *)1 == (typeof(({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; })) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; })) * 0l)) : (int *)8))))), ((({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })) > (({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; })) ? (({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })) : (({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; }))), ({ typeof(({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })) __UNIQUE_ID___x64 = (({ union { typeof(memcg->memory.emin) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); else __read_once_size_nocheck(&(memcg->memory.emin), __u.__c, sizeof(memcg->memory.emin)); do { } while (0); __u.__val; })); typeof(({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; })) __UNIQUE_ID___y65 = (({ union { typeof(memcg->memory.elow) __val; char __c[1]; } __u; if (1) __read_once_size(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); else __read_once_size_nocheck(&(memcg->memory.elow), __u.__c, sizeof(memcg->memory.elow)); do { } while (0); __u.__val; })); ((__UNIQUE_ID___x64) > (__UNIQUE_ID___y65) ? (__UNIQUE_ID___x64) : (__UNIQUE_ID___y65)); }));

}

enum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,
      struct mem_cgroup *memcg);

int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,
     gfp_t gfp_mask, struct mem_cgroup **memcgp,
     bool compound);
int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,
     gfp_t gfp_mask, struct mem_cgroup **memcgp,
     bool compound);
void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,
         bool lrucare, bool compound);
void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,
  bool compound);
void mem_cgroup_uncharge(struct page *page);
void mem_cgroup_uncharge_list(struct list_head *page_list);

void mem_cgroup_migrate(struct page *oldpage, struct page *newpage);

static struct mem_cgroup_per_node *
mem_cgroup_nodeinfo(struct mem_cgroup *memcg, int nid)
{
 return memcg->nodeinfo[nid];
}
# 392 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct lruvec *mem_cgroup_lruvec(struct mem_cgroup *memcg,
            struct pglist_data *pgdat)
{
 struct mem_cgroup_per_node *mz;
 struct lruvec *lruvec;

 if (mem_cgroup_disabled()) {
  lruvec = &pgdat->__lruvec;
  goto out;
 }

 if (!memcg)
  memcg = root_mem_cgroup;

 mz = mem_cgroup_nodeinfo(memcg, pgdat->node_id);
 lruvec = &mz->lruvec;
out:





 if (__builtin_expect(!!(lruvec->pgdat != pgdat), 0))
  lruvec->pgdat = pgdat;
 return lruvec;
}

struct lruvec *mem_cgroup_page_lruvec(struct page *, struct pglist_data *);

struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p);

struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm);

struct mem_cgroup *get_mem_cgroup_from_page(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct mem_cgroup *mem_cgroup_from_css(struct cgroup_subsys_state *css){
 return css ? ({ void *__mptr = (void *)(css); do { extern void __compiletime_assert_429(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(css)), typeof(((struct mem_cgroup *)0)->css)) && !__builtin_types_compatible_p(typeof(*(css)), typeof(void))))) __compiletime_assert_429(); } while (0); ((struct mem_cgroup *)(__mptr - __builtin_offsetof(struct mem_cgroup, css))); }) : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_put(struct mem_cgroup *memcg)
{
 if (memcg)
  css_put(&memcg->css);
}




struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *,
       struct mem_cgroup *,
       struct mem_cgroup_reclaim_cookie *);
void mem_cgroup_iter_break(struct mem_cgroup *, struct mem_cgroup *);
int mem_cgroup_scan_tasks(struct mem_cgroup *,
     int (*)(struct task_struct *, void *), void *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned short mem_cgroup_id(struct mem_cgroup *memcg)
{
 if (mem_cgroup_disabled())
  return 0;

 return memcg->id.id;
}
struct mem_cgroup *mem_cgroup_from_id(unsigned short id);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_cgroup *mem_cgroup_from_seq(struct seq_file *m)
{
 return mem_cgroup_from_css(seq_css(m));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_cgroup *lruvec_memcg(struct lruvec *lruvec)
{
 struct mem_cgroup_per_node *mz;

 if (mem_cgroup_disabled())
  return ((void *)0);

 mz = ({ void *__mptr = (void *)(lruvec); do { extern void __compiletime_assert_469(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lruvec)), typeof(((struct mem_cgroup_per_node *)0)->lruvec)) && !__builtin_types_compatible_p(typeof(*(lruvec)), typeof(void))))) __compiletime_assert_469(); } while (0); ((struct mem_cgroup_per_node *)(__mptr - __builtin_offsetof(struct mem_cgroup_per_node, lruvec))); });
 return mz->memcg;
}
# 480 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct mem_cgroup *parent_mem_cgroup(struct mem_cgroup *memcg)
{
 if (!memcg->memory.parent)
  return ((void *)0);
 return ({ void *__mptr = (void *)(memcg->memory.parent); do { extern void __compiletime_assert_484(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(memcg->memory.parent)), typeof(((struct mem_cgroup *)0)->memory)) && !__builtin_types_compatible_p(typeof(*(memcg->memory.parent)), typeof(void))))) __compiletime_assert_484(); } while (0); ((struct mem_cgroup *)(__mptr - __builtin_offsetof(struct mem_cgroup, memory))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_cgroup_is_descendant(struct mem_cgroup *memcg,
         struct mem_cgroup *root)
{
 if (root == memcg)
  return true;
 if (!root->use_hierarchy)
  return false;
 return cgroup_is_descendant(memcg->css.cgroup, root->css.cgroup);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mm_match_cgroup(struct mm_struct *mm,
       struct mem_cgroup *memcg)
{
 struct mem_cgroup *task_memcg;
 bool match = false;

 rcu_read_lock();
 task_memcg = mem_cgroup_from_task(({ typeof(*(mm->owner)) *________p1 = (typeof(*(mm->owner)) *)({ union { typeof((mm->owner)) __val; char __c[1]; } __u; if (1) __read_once_size(&((mm->owner)), __u.__c, sizeof((mm->owner))); else __read_once_size_nocheck(&((mm->owner)), __u.__c, sizeof((mm->owner))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(mm->owner)) *)(________p1)); }));
 if (task_memcg)
  match = mem_cgroup_is_descendant(task_memcg, memcg);
 rcu_read_unlock();
 return match;
}

struct cgroup_subsys_state *mem_cgroup_css_from_page(struct page *page);
ino_t page_cgroup_ino(struct page *page);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_cgroup_online(struct mem_cgroup *memcg)
{
 if (mem_cgroup_disabled())
  return true;
 return !!(memcg->css.flags & CSS_ONLINE);
}




int mem_cgroup_select_victim_node(struct mem_cgroup *memcg);

void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,
  int zid, int nr_pages);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
unsigned long mem_cgroup_get_zone_lru_size(struct lruvec *lruvec,
  enum lru_list lru, int zone_idx)
{
 struct mem_cgroup_per_node *mz;

 mz = ({ void *__mptr = (void *)(lruvec); do { extern void __compiletime_assert_535(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lruvec)), typeof(((struct mem_cgroup_per_node *)0)->lruvec)) && !__builtin_types_compatible_p(typeof(*(lruvec)), typeof(void))))) __compiletime_assert_535(); } while (0); ((struct mem_cgroup_per_node *)(__mptr - __builtin_offsetof(struct mem_cgroup_per_node, lruvec))); });
 return mz->lru_zone_size[zone_idx][lru];
}

void mem_cgroup_handle_over_high(void);

unsigned long mem_cgroup_get_max(struct mem_cgroup *memcg);

unsigned long mem_cgroup_size(struct mem_cgroup *memcg);

void mem_cgroup_print_oom_context(struct mem_cgroup *memcg,
    struct task_struct *p);

void mem_cgroup_print_oom_meminfo(struct mem_cgroup *memcg);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_enter_user_fault(void)
{
 ({ int __ret_warn_on = !!(get_current()->in_user_fault); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/memcontrol.h"), "i" (552), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/memcontrol.h"), "i" (552), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 get_current()->in_user_fault = 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_exit_user_fault(void)
{
 ({ int __ret_warn_on = !!(!get_current()->in_user_fault); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/memcontrol.h"), "i" (558), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/memcontrol.h"), "i" (558), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 get_current()->in_user_fault = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool task_in_memcg_oom(struct task_struct *p)
{
 return p->memcg_in_oom;
}

bool mem_cgroup_oom_synchronize(bool wait);
struct mem_cgroup *mem_cgroup_get_oom_group(struct task_struct *victim,
         struct mem_cgroup *oom_domain);
void mem_cgroup_print_oom_group(struct mem_cgroup *memcg);





struct mem_cgroup *lock_page_memcg(struct page *page);
void __unlock_page_memcg(struct mem_cgroup *memcg);
void unlock_page_memcg(struct page *page);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long memcg_page_state(struct mem_cgroup *memcg, int idx)
{
 long x = atomic_long_read(&memcg->vmstats[idx]);

 if (x < 0)
  x = 0;

 return x;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long memcg_page_state_local(struct mem_cgroup *memcg,
         int idx)
{
 long x = 0;
 int cpu;

 for (((cpu)) = -1; ((cpu)) = cpumask_next(((cpu)), (((const struct cpumask *)&__cpu_possible_mask))), ((cpu)) < nr_cpu_ids;)
  x += (*({ do { const void *__vpp_verify = (typeof((&(memcg->vmstats_local->stat[idx])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(memcg->vmstats_local->stat[idx])))) *)((&(memcg->vmstats_local->stat[idx])))); (typeof((typeof(*((&(memcg->vmstats_local->stat[idx])))) *)((&(memcg->vmstats_local->stat[idx]))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));

 if (x < 0)
  x = 0;

 return x;
}

void __mod_memcg_state(struct mem_cgroup *memcg, int idx, int val);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mod_memcg_state(struct mem_cgroup *memcg,
       int idx, int val)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __mod_memcg_state(memcg, idx, val);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}
# 643 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __mod_memcg_page_state(struct page *page,
       int idx, int val)
{
 if (page->mem_cgroup)
  __mod_memcg_state(page->mem_cgroup, idx, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mod_memcg_page_state(struct page *page,
     int idx, int val)
{
 if (page->mem_cgroup)
  mod_memcg_state(page->mem_cgroup, idx, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long lruvec_page_state(struct lruvec *lruvec,
           enum node_stat_item idx)
{
 struct mem_cgroup_per_node *pn;
 long x;

 if (mem_cgroup_disabled())
  return node_page_state(lruvec_pgdat(lruvec), idx);

 pn = ({ void *__mptr = (void *)(lruvec); do { extern void __compiletime_assert_666(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lruvec)), typeof(((struct mem_cgroup_per_node *)0)->lruvec)) && !__builtin_types_compatible_p(typeof(*(lruvec)), typeof(void))))) __compiletime_assert_666(); } while (0); ((struct mem_cgroup_per_node *)(__mptr - __builtin_offsetof(struct mem_cgroup_per_node, lruvec))); });
 x = atomic_long_read(&pn->lruvec_stat[idx]);

 if (x < 0)
  x = 0;

 return x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long lruvec_page_state_local(struct lruvec *lruvec,
          enum node_stat_item idx)
{
 struct mem_cgroup_per_node *pn;
 long x = 0;
 int cpu;

 if (mem_cgroup_disabled())
  return node_page_state(lruvec_pgdat(lruvec), idx);

 pn = ({ void *__mptr = (void *)(lruvec); do { extern void __compiletime_assert_685(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(lruvec)), typeof(((struct mem_cgroup_per_node *)0)->lruvec)) && !__builtin_types_compatible_p(typeof(*(lruvec)), typeof(void))))) __compiletime_assert_685(); } while (0); ((struct mem_cgroup_per_node *)(__mptr - __builtin_offsetof(struct mem_cgroup_per_node, lruvec))); });
 for (((cpu)) = -1; ((cpu)) = cpumask_next(((cpu)), (((const struct cpumask *)&__cpu_possible_mask))), ((cpu)) < nr_cpu_ids;)
  x += (*({ do { const void *__vpp_verify = (typeof((&(pn->lruvec_stat_local->count[idx])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&(pn->lruvec_stat_local->count[idx])))) *)((&(pn->lruvec_stat_local->count[idx])))); (typeof((typeof(*((&(pn->lruvec_stat_local->count[idx])))) *)((&(pn->lruvec_stat_local->count[idx]))))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); }));

 if (x < 0)
  x = 0;

 return x;
}

void __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
   int val);
void __mod_lruvec_slab_state(void *p, enum node_stat_item idx, int val);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mod_lruvec_state(struct lruvec *lruvec,
        enum node_stat_item idx, int val)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __mod_lruvec_state(lruvec, idx, val);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __mod_lruvec_page_state(struct page *page,
        enum node_stat_item idx, int val)
{
 pg_data_t *pgdat = page_pgdat(page);
 struct lruvec *lruvec;


 if (!page->mem_cgroup) {
  __mod_node_page_state(pgdat, idx, val);
  return;
 }

 lruvec = mem_cgroup_lruvec(page->mem_cgroup, pgdat);
 __mod_lruvec_state(lruvec, idx, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mod_lruvec_page_state(struct page *page,
      enum node_stat_item idx, int val)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __mod_lruvec_page_state(page, idx, val);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}

unsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,
      gfp_t gfp_mask,
      unsigned long *total_scanned);

void __count_memcg_events(struct mem_cgroup *memcg, enum vm_event_item idx,
     unsigned long count);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void count_memcg_events(struct mem_cgroup *memcg,
          enum vm_event_item idx,
          unsigned long count)
{
 unsigned long flags;

 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); flags = arch_local_irq_save(); } while (0); } while (0);
 __count_memcg_events(memcg, idx, count);
 do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(flags); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void count_memcg_page_event(struct page *page,
       enum vm_event_item idx)
{
 if (page->mem_cgroup)
  count_memcg_events(page->mem_cgroup, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void count_memcg_event_mm(struct mm_struct *mm,
     enum vm_event_item idx)
{
 struct mem_cgroup *memcg;

 if (mem_cgroup_disabled())
  return;

 rcu_read_lock();
 memcg = mem_cgroup_from_task(({ typeof(*(mm->owner)) *________p1 = (typeof(*(mm->owner)) *)({ union { typeof((mm->owner)) __val; char __c[1]; } __u; if (1) __read_once_size(&((mm->owner)), __u.__c, sizeof((mm->owner))); else __read_once_size_nocheck(&((mm->owner)), __u.__c, sizeof((mm->owner))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(mm->owner)) *)(________p1)); }));
 if (__builtin_expect(!!(memcg), 1))
  count_memcg_events(memcg, idx, 1);
 rcu_read_unlock();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcg_memory_event(struct mem_cgroup *memcg,
          enum memcg_memory_event event)
{
 atomic_long_inc(&memcg->memory_events_local[event]);
 cgroup_file_notify(&memcg->events_local_file);

 do {
  atomic_long_inc(&memcg->memory_events[event]);
  cgroup_file_notify(&memcg->events_file);

  if (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)
   break;
 } while ((memcg = parent_mem_cgroup(memcg)) &&
   !mem_cgroup_is_root(memcg));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcg_memory_event_mm(struct mm_struct *mm,
      enum memcg_memory_event event)
{
 struct mem_cgroup *memcg;

 if (mem_cgroup_disabled())
  return;

 rcu_read_lock();
 memcg = mem_cgroup_from_task(({ typeof(*(mm->owner)) *________p1 = (typeof(*(mm->owner)) *)({ union { typeof((mm->owner)) __val; char __c[1]; } __u; if (1) __read_once_size(&((mm->owner)), __u.__c, sizeof((mm->owner))); else __read_once_size_nocheck(&((mm->owner)), __u.__c, sizeof((mm->owner))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(mm->owner)) *)(________p1)); }));
 if (__builtin_expect(!!(memcg), 1))
  memcg_memory_event(memcg, event);
 rcu_read_unlock();
}


void mem_cgroup_split_huge_fixup(struct page *head);
# 1162 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inc_memcg_state(struct mem_cgroup *memcg,
         int idx)
{
 __mod_memcg_state(memcg, idx, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dec_memcg_state(struct mem_cgroup *memcg,
         int idx)
{
 __mod_memcg_state(memcg, idx, -1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inc_memcg_page_state(struct page *page,
       int idx)
{
 __mod_memcg_page_state(page, idx, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dec_memcg_page_state(struct page *page,
       int idx)
{
 __mod_memcg_page_state(page, idx, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inc_lruvec_state(struct lruvec *lruvec,
          enum node_stat_item idx)
{
 __mod_lruvec_state(lruvec, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dec_lruvec_state(struct lruvec *lruvec,
          enum node_stat_item idx)
{
 __mod_lruvec_state(lruvec, idx, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inc_lruvec_page_state(struct page *page,
        enum node_stat_item idx)
{
 __mod_lruvec_page_state(page, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dec_lruvec_page_state(struct page *page,
        enum node_stat_item idx)
{
 __mod_lruvec_page_state(page, idx, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inc_lruvec_slab_state(void *p, enum node_stat_item idx)
{
 __mod_lruvec_slab_state(p, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __dec_lruvec_slab_state(void *p, enum node_stat_item idx)
{
 __mod_lruvec_slab_state(p, idx, -1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_memcg_state(struct mem_cgroup *memcg,
       int idx)
{
 mod_memcg_state(memcg, idx, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_memcg_state(struct mem_cgroup *memcg,
       int idx)
{
 mod_memcg_state(memcg, idx, -1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_memcg_page_state(struct page *page,
     int idx)
{
 mod_memcg_page_state(page, idx, 1);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_memcg_page_state(struct page *page,
     int idx)
{
 mod_memcg_page_state(page, idx, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_lruvec_state(struct lruvec *lruvec,
        enum node_stat_item idx)
{
 mod_lruvec_state(lruvec, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_lruvec_state(struct lruvec *lruvec,
        enum node_stat_item idx)
{
 mod_lruvec_state(lruvec, idx, -1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inc_lruvec_page_state(struct page *page,
      enum node_stat_item idx)
{
 mod_lruvec_page_state(page, idx, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dec_lruvec_page_state(struct page *page,
      enum node_stat_item idx)
{
 mod_lruvec_page_state(page, idx, -1);
}
# 1299 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct wb_domain *mem_cgroup_wb_domain(struct bdi_writeback *wb)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_wb_stats(struct bdi_writeback *wb,
           unsigned long *pfilepages,
           unsigned long *pheadroom,
           unsigned long *pdirty,
           unsigned long *pwriteback)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_track_foreign_dirty(struct page *page,
        struct bdi_writeback *wb)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mem_cgroup_flush_foreign(struct bdi_writeback *wb)
{
}



struct sock;
bool mem_cgroup_charge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages);
void mem_cgroup_uncharge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages);

extern struct static_key_false memcg_sockets_enabled_key;

void mem_cgroup_sk_alloc(struct sock *sk);
void mem_cgroup_sk_free(struct sock *sk);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mem_cgroup_under_socket_pressure(struct mem_cgroup *memcg)
{
 if (!({ bool branch; if (__builtin_types_compatible_p(typeof(*&memory_cgrp_subsys_on_dfl_key), struct static_key_true)) branch = !arch_static_branch(&(&memory_cgrp_subsys_on_dfl_key)->key, true); else if (__builtin_types_compatible_p(typeof(*&memory_cgrp_subsys_on_dfl_key), struct static_key_false)) branch = !arch_static_branch_jump(&(&memory_cgrp_subsys_on_dfl_key)->key, true); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 1); }) && memcg->tcpmem_pressure)
  return true;
 do {
  if ((({ unsigned long __dummy; typeof(memcg->socket_pressure) __dummy2; (void)(&__dummy == &__dummy2); 1; }) && ({ unsigned long __dummy; typeof(jiffies) __dummy2; (void)(&__dummy == &__dummy2); 1; }) && ((long)((jiffies) - (memcg->socket_pressure)) < 0)))
   return true;
 } while ((memcg = parent_mem_cgroup(memcg)));
 return false;
}

extern int memcg_expand_shrinker_maps(int new_id);

extern void memcg_set_shrinker_bit(struct mem_cgroup *memcg,
       int nid, int shrinker_id);
# 1361 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
struct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep);
void memcg_kmem_put_cache(struct kmem_cache *cachep);


int __memcg_kmem_charge(struct page *page, gfp_t gfp, int order);
void __memcg_kmem_uncharge(struct page *page, int order);
int __memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,
         struct mem_cgroup *memcg);
void __memcg_kmem_uncharge_memcg(struct mem_cgroup *memcg,
     unsigned int nr_pages);

extern struct static_key_false memcg_kmem_enabled_key;
extern struct workqueue_struct *memcg_kmem_cache_wq;

extern int memcg_nr_cache_ids;
void memcg_get_cache_ids(void);
void memcg_put_cache_ids(void);
# 1387 "/home/nathan/src/linux-next/include/linux/memcontrol.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool memcg_kmem_enabled(void)
{
 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&memcg_kmem_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&memcg_kmem_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&memcg_kmem_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&memcg_kmem_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int memcg_kmem_charge(struct page *page, gfp_t gfp, int order)
{
 if (memcg_kmem_enabled())
  return __memcg_kmem_charge(page, gfp, order);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcg_kmem_uncharge(struct page *page, int order)
{
 if (memcg_kmem_enabled())
  __memcg_kmem_uncharge(page, order);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int memcg_kmem_charge_memcg(struct page *page, gfp_t gfp,
       int order, struct mem_cgroup *memcg)
{
 if (memcg_kmem_enabled())
  return __memcg_kmem_charge_memcg(page, gfp, order, memcg);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void memcg_kmem_uncharge_memcg(struct page *page, int order,
          struct mem_cgroup *memcg)
{
 if (memcg_kmem_enabled())
  __memcg_kmem_uncharge_memcg(memcg, 1 << order);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int memcg_cache_id(struct mem_cgroup *memcg)
{
 return memcg ? memcg->kmemcg_id : -1;
}
# 54 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/static_key.h" 1
# 55 "/home/nathan/src/linux-next/include/net/sock.h" 2




# 1 "/home/nathan/src/linux-next/include/linux/filter.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/filter.h"
# 1 "/home/nathan/src/linux-next/include/linux/cryptohash.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/cryptohash.h"
void sha_init(__u32 *buf);
void sha_transform(__u32 *digest, const char *data, __u32 *W);
# 20 "/home/nathan/src/linux-next/include/linux/filter.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/set_memory.h" 1
# 11 "/home/nathan/src/linux-next/include/linux/set_memory.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_memory_ro(unsigned long addr, int numpages) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_memory_rw(unsigned long addr, int numpages) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_memory_x(unsigned long addr, int numpages) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_memory_nx(unsigned long addr, int numpages) { return 0; }



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_direct_map_invalid_noflush(struct page *page)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_direct_map_default_noflush(struct page *page)
{
 return 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int set_mce_nospec(unsigned long pfn)
{
 return 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int clear_mce_nospec(unsigned long pfn)
{
 return 0;
}
# 21 "/home/nathan/src/linux-next/include/linux/filter.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/kallsyms.h" 1
# 21 "/home/nathan/src/linux-next/include/linux/kallsyms.h"
struct module;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_kernel_inittext(unsigned long addr)
{
 if (addr >= (unsigned long)_sinittext
     && addr <= (unsigned long)_einittext)
  return 1;
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_kernel_text(unsigned long addr)
{
 if ((addr >= (unsigned long)_stext && addr <= (unsigned long)_etext) ||
     arch_is_kernel_text(addr))
  return 1;
 return in_gate_area_no_mm(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_kernel(unsigned long addr)
{
 if (addr >= (unsigned long)_stext && addr <= (unsigned long)_end)
  return 1;
 return in_gate_area_no_mm(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int is_ksym_addr(unsigned long addr)
{
 if (0)
  return is_kernel(addr);

 return is_kernel_text(addr) || is_kernel_inittext(addr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *dereference_symbol_descriptor(void *ptr)
{

 struct module *mod;

 ptr = dereference_kernel_function_descriptor(ptr);
 if (is_ksym_addr((unsigned long)ptr))
  return ptr;

 __asm__ __volatile__("" : : : "memory");
 mod = __module_address((unsigned long)ptr);
 __asm__ __volatile__("" : : : "memory");

 if (mod)
  ptr = dereference_module_function_descriptor(mod, ptr);

 return ptr;
}



unsigned long kallsyms_lookup_name(const char *name);


int kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,
          unsigned long),
       void *data);

extern int kallsyms_lookup_size_offset(unsigned long addr,
      unsigned long *symbolsize,
      unsigned long *offset);


const char *kallsyms_lookup(unsigned long addr,
       unsigned long *symbolsize,
       unsigned long *offset,
       char **modname, char *namebuf);


extern int sprint_symbol(char *buffer, unsigned long address);
extern int sprint_symbol_no_offset(char *buffer, unsigned long address);
extern int sprint_backtrace(char *buffer, unsigned long address);

int lookup_symbol_name(unsigned long addr, char *symname);
int lookup_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name);


extern int kallsyms_show_value(void);
# 168 "/home/nathan/src/linux-next/include/linux/kallsyms.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void print_ip_sym(unsigned long ip)
{
 printk("[<%px>] %pS\n", (void *) ip, (void *) ip);
}
# 22 "/home/nathan/src/linux-next/include/linux/filter.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/if_vlan.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
# 1 "/home/nathan/src/linux-next/include/linux/rtnetlink.h" 1
# 10 "/home/nathan/src/linux-next/include/linux/rtnetlink.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h" 1







# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_addr.h" 1







struct ifaddrmsg {
 __u8 ifa_family;
 __u8 ifa_prefixlen;
 __u8 ifa_flags;
 __u8 ifa_scope;
 __u32 ifa_index;
};
# 26 "/home/nathan/src/linux-next/include/uapi/linux/if_addr.h"
enum {
 IFA_UNSPEC,
 IFA_ADDRESS,
 IFA_LOCAL,
 IFA_LABEL,
 IFA_BROADCAST,
 IFA_ANYCAST,
 IFA_CACHEINFO,
 IFA_MULTICAST,
 IFA_FLAGS,
 IFA_RT_PRIORITY,
 IFA_TARGET_NETNSID,
 __IFA_MAX,
};
# 59 "/home/nathan/src/linux-next/include/uapi/linux/if_addr.h"
struct ifa_cacheinfo {
 __u32 ifa_prefered;
 __u32 ifa_valid;
 __u32 cstamp;
 __u32 tstamp;
};
# 9 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h" 2
# 24 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
enum {
 RTM_BASE = 16,


 RTM_NEWLINK = 16,

 RTM_DELLINK,

 RTM_GETLINK,

 RTM_SETLINK,


 RTM_NEWADDR = 20,

 RTM_DELADDR,

 RTM_GETADDR,


 RTM_NEWROUTE = 24,

 RTM_DELROUTE,

 RTM_GETROUTE,


 RTM_NEWNEIGH = 28,

 RTM_DELNEIGH,

 RTM_GETNEIGH,


 RTM_NEWRULE = 32,

 RTM_DELRULE,

 RTM_GETRULE,


 RTM_NEWQDISC = 36,

 RTM_DELQDISC,

 RTM_GETQDISC,


 RTM_NEWTCLASS = 40,

 RTM_DELTCLASS,

 RTM_GETTCLASS,


 RTM_NEWTFILTER = 44,

 RTM_DELTFILTER,

 RTM_GETTFILTER,


 RTM_NEWACTION = 48,

 RTM_DELACTION,

 RTM_GETACTION,


 RTM_NEWPREFIX = 52,


 RTM_GETMULTICAST = 58,


 RTM_GETANYCAST = 62,


 RTM_NEWNEIGHTBL = 64,

 RTM_GETNEIGHTBL = 66,

 RTM_SETNEIGHTBL,


 RTM_NEWNDUSEROPT = 68,


 RTM_NEWADDRLABEL = 72,

 RTM_DELADDRLABEL,

 RTM_GETADDRLABEL,


 RTM_GETDCB = 78,

 RTM_SETDCB,


 RTM_NEWNETCONF = 80,

 RTM_DELNETCONF,

 RTM_GETNETCONF = 82,


 RTM_NEWMDB = 84,

 RTM_DELMDB = 85,

 RTM_GETMDB = 86,


 RTM_NEWNSID = 88,

 RTM_DELNSID = 89,

 RTM_GETNSID = 90,


 RTM_NEWSTATS = 92,

 RTM_GETSTATS = 94,


 RTM_NEWCACHEREPORT = 96,


 RTM_NEWCHAIN = 100,

 RTM_DELCHAIN,

 RTM_GETCHAIN,


 RTM_NEWNEXTHOP = 104,

 RTM_DELNEXTHOP,

 RTM_GETNEXTHOP,


 RTM_NEWLINKPROP = 108,

 RTM_DELLINKPROP,

 RTM_GETLINKPROP,


 RTM_NEWVLAN = 112,

 RTM_DELVLAN,

 RTM_GETVLAN,


 __RTM_MAX,

};
# 195 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct rtattr {
 unsigned short rta_len;
 unsigned short rta_type;
};
# 221 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct rtmsg {
 unsigned char rtm_family;
 unsigned char rtm_dst_len;
 unsigned char rtm_src_len;
 unsigned char rtm_tos;

 unsigned char rtm_table;
 unsigned char rtm_protocol;
 unsigned char rtm_scope;
 unsigned char rtm_type;

 unsigned rtm_flags;
};



enum {
 RTN_UNSPEC,
 RTN_UNICAST,
 RTN_LOCAL,
 RTN_BROADCAST,

 RTN_ANYCAST,

 RTN_MULTICAST,
 RTN_BLACKHOLE,
 RTN_UNREACHABLE,
 RTN_PROHIBIT,
 RTN_THROW,
 RTN_NAT,
 RTN_XRESOLVE,
 __RTN_MAX
};
# 302 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
enum rt_scope_t {
 RT_SCOPE_UNIVERSE=0,

 RT_SCOPE_SITE=200,
 RT_SCOPE_LINK=253,
 RT_SCOPE_HOST=254,
 RT_SCOPE_NOWHERE=255
};
# 324 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
enum rt_class_t {
 RT_TABLE_UNSPEC=0,

 RT_TABLE_COMPAT=252,
 RT_TABLE_DEFAULT=253,
 RT_TABLE_MAIN=254,
 RT_TABLE_LOCAL=255,
 RT_TABLE_MAX=0xFFFFFFFF
};




enum rtattr_type_t {
 RTA_UNSPEC,
 RTA_DST,
 RTA_SRC,
 RTA_IIF,
 RTA_OIF,
 RTA_GATEWAY,
 RTA_PRIORITY,
 RTA_PREFSRC,
 RTA_METRICS,
 RTA_MULTIPATH,
 RTA_PROTOINFO,
 RTA_FLOW,
 RTA_CACHEINFO,
 RTA_SESSION,
 RTA_MP_ALGO,
 RTA_TABLE,
 RTA_MARK,
 RTA_MFC_STATS,
 RTA_VIA,
 RTA_NEWDST,
 RTA_PREF,
 RTA_ENCAP_TYPE,
 RTA_ENCAP,
 RTA_EXPIRES,
 RTA_PAD,
 RTA_UID,
 RTA_TTL_PROPAGATE,
 RTA_IP_PROTO,
 RTA_SPORT,
 RTA_DPORT,
 RTA_NH_ID,
 __RTA_MAX
};
# 386 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct rtnexthop {
 unsigned short rtnh_len;
 unsigned char rtnh_flags;
 unsigned char rtnh_hops;
 int rtnh_ifindex;
};
# 416 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct rtvia {
 __kernel_sa_family_t rtvia_family;
 __u8 rtvia_addr[0];
};



struct rta_cacheinfo {
 __u32 rta_clntref;
 __u32 rta_lastuse;
 __s32 rta_expires;
 __u32 rta_error;
 __u32 rta_used;


 __u32 rta_id;
 __u32 rta_ts;
 __u32 rta_tsage;
};



enum {
 RTAX_UNSPEC,

 RTAX_LOCK,

 RTAX_MTU,

 RTAX_WINDOW,

 RTAX_RTT,

 RTAX_RTTVAR,

 RTAX_SSTHRESH,

 RTAX_CWND,

 RTAX_ADVMSS,

 RTAX_REORDERING,

 RTAX_HOPLIMIT,

 RTAX_INITCWND,

 RTAX_FEATURES,

 RTAX_RTO_MIN,

 RTAX_INITRWND,

 RTAX_QUICKACK,

 RTAX_CC_ALGO,

 RTAX_FASTOPEN_NO_COOKIE,

 __RTAX_MAX
};
# 488 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct rta_session {
 __u8 proto;
 __u8 pad1;
 __u16 pad2;

 union {
  struct {
   __u16 sport;
   __u16 dport;
  } ports;

  struct {
   __u8 type;
   __u8 code;
   __u16 ident;
  } icmpt;

  __u32 spi;
 } u;
};

struct rta_mfc_stats {
 __u64 mfcs_packets;
 __u64 mfcs_bytes;
 __u64 mfcs_wrong_if;
};





struct rtgenmsg {
 unsigned char rtgen_family;
};
# 532 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct ifinfomsg {
 unsigned char ifi_family;
 unsigned char __ifi_pad;
 unsigned short ifi_type;
 int ifi_index;
 unsigned ifi_flags;
 unsigned ifi_change;
};





struct prefixmsg {
 unsigned char prefix_family;
 unsigned char prefix_pad1;
 unsigned short prefix_pad2;
 int prefix_ifindex;
 unsigned char prefix_type;
 unsigned char prefix_len;
 unsigned char prefix_flags;
 unsigned char prefix_pad3;
};

enum
{
 PREFIX_UNSPEC,
 PREFIX_ADDRESS,
 PREFIX_CACHEINFO,
 __PREFIX_MAX
};



struct prefix_cacheinfo {
 __u32 preferred_time;
 __u32 valid_time;
};






struct tcmsg {
 unsigned char tcm_family;
 unsigned char tcm__pad1;
 unsigned short tcm__pad2;
 int tcm_ifindex;
 __u32 tcm_handle;
 __u32 tcm_parent;




 __u32 tcm_info;
};







enum {
 TCA_UNSPEC,
 TCA_KIND,
 TCA_OPTIONS,
 TCA_STATS,
 TCA_XSTATS,
 TCA_RATE,
 TCA_FCNT,
 TCA_STATS2,
 TCA_STAB,
 TCA_PAD,
 TCA_DUMP_INVISIBLE,
 TCA_CHAIN,
 TCA_HW_OFFLOAD,
 TCA_INGRESS_BLOCK,
 TCA_EGRESS_BLOCK,
 __TCA_MAX
};
# 624 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
struct nduseroptmsg {
 unsigned char nduseropt_family;
 unsigned char nduseropt_pad1;
 unsigned short nduseropt_opts_len;
 int nduseropt_ifindex;
 __u8 nduseropt_icmp_type;
 __u8 nduseropt_icmp_code;
 unsigned short nduseropt_pad2;
 unsigned int nduseropt_pad3;

};

enum {
 NDUSEROPT_UNSPEC,
 NDUSEROPT_SRCADDR,
 __NDUSEROPT_MAX
};
# 668 "/home/nathan/src/linux-next/include/uapi/linux/rtnetlink.h"
enum rtnetlink_groups {
 RTNLGRP_NONE,

 RTNLGRP_LINK,

 RTNLGRP_NOTIFY,

 RTNLGRP_NEIGH,

 RTNLGRP_TC,

 RTNLGRP_IPV4_IFADDR,

 RTNLGRP_IPV4_MROUTE,

 RTNLGRP_IPV4_ROUTE,

 RTNLGRP_IPV4_RULE,

 RTNLGRP_IPV6_IFADDR,

 RTNLGRP_IPV6_MROUTE,

 RTNLGRP_IPV6_ROUTE,

 RTNLGRP_IPV6_IFINFO,

 RTNLGRP_DECnet_IFADDR,

 RTNLGRP_NOP2,
 RTNLGRP_DECnet_ROUTE,

 RTNLGRP_DECnet_RULE,

 RTNLGRP_NOP4,
 RTNLGRP_IPV6_PREFIX,

 RTNLGRP_IPV6_RULE,

 RTNLGRP_ND_USEROPT,

 RTNLGRP_PHONET_IFADDR,

 RTNLGRP_PHONET_ROUTE,

 RTNLGRP_DCB,

 RTNLGRP_IPV4_NETCONF,

 RTNLGRP_IPV6_NETCONF,

 RTNLGRP_MDB,

 RTNLGRP_MPLS_ROUTE,

 RTNLGRP_NSID,

 RTNLGRP_MPLS_NETCONF,

 RTNLGRP_IPV4_MROUTE_R,

 RTNLGRP_IPV6_MROUTE_R,

 RTNLGRP_NEXTHOP,

 RTNLGRP_BRVLAN,

 __RTNLGRP_MAX
};



struct tcamsg {
 unsigned char tca_family;
 unsigned char tca__pad1;
 unsigned short tca__pad2;
};

enum {
 TCA_ROOT_UNSPEC,
 TCA_ROOT_TAB,


 TCA_ROOT_FLAGS,
 TCA_ROOT_COUNT,
 TCA_ROOT_TIME_DELTA,
 __TCA_ROOT_MAX,

};
# 11 "/home/nathan/src/linux-next/include/linux/rtnetlink.h" 2

extern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);
extern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);
extern void rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid,
   u32 group, struct nlmsghdr *nlh, gfp_t flags);
extern void rtnl_set_sk_err(struct net *net, u32 group, int error);
extern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);
extern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,
         u32 id, long expires, u32 error);

void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change, gfp_t flags);
void rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,
    gfp_t flags, int *new_nsid, int new_ifindex);
struct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,
           unsigned change, u32 event,
           gfp_t flags, int *new_nsid,
           int new_ifindex);
void rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev,
         gfp_t flags);



extern void rtnl_lock(void);
extern void rtnl_unlock(void);
extern int rtnl_trylock(void);
extern int rtnl_is_locked(void);
extern int rtnl_lock_killable(void);
extern bool refcount_dec_and_rtnl_lock(refcount_t *r);

extern wait_queue_head_t netdev_unregistering_wq;
extern struct rw_semaphore pernet_ops_rwsem;
extern struct rw_semaphore net_rwsem;




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lockdep_rtnl_is_held(void)
{
 return true;
}
# 83 "/home/nathan/src/linux-next/include/linux/rtnetlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct netdev_queue *dev_ingress_queue(struct net_device *dev)
{
 return ({ do { } while (0); ; ((typeof(*(dev->ingress_queue)) *)((dev->ingress_queue))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct netdev_queue *dev_ingress_queue_rcu(struct net_device *dev)
{
 return ({ typeof(*(dev->ingress_queue)) *________p1 = (typeof(*(dev->ingress_queue)) *)({ union { typeof((dev->ingress_queue)) __val; char __c[1]; } __u; if (1) __read_once_size(&((dev->ingress_queue)), __u.__c, sizeof((dev->ingress_queue))); else __read_once_size_nocheck(&((dev->ingress_queue)), __u.__c, sizeof((dev->ingress_queue))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(dev->ingress_queue)) *)(________p1)); });
}

struct netdev_queue *dev_ingress_queue_create(struct net_device *dev);


void net_inc_ingress_queue(void);
void net_dec_ingress_queue(void);







void rtnetlink_init(void);
void __rtnl_unlock(void);
void rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail);





extern int ndo_dflt_fdb_dump(struct sk_buff *skb,
        struct netlink_callback *cb,
        struct net_device *dev,
        struct net_device *filter_dev,
        int *idx);
extern int ndo_dflt_fdb_add(struct ndmsg *ndm,
       struct nlattr *tb[],
       struct net_device *dev,
       const unsigned char *addr,
       u16 vid,
       u16 flags);
extern int ndo_dflt_fdb_del(struct ndmsg *ndm,
       struct nlattr *tb[],
       struct net_device *dev,
       const unsigned char *addr,
       u16 vid);

extern int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
       struct net_device *dev, u16 mode,
       u32 flags, u32 mask, int nlflags,
       u32 filter_mask,
       int (*vlan_fill)(struct sk_buff *skb,
          struct net_device *dev,
          u32 filter_mask));
# 13 "/home/nathan/src/linux-next/include/linux/if_vlan.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_vlan.h" 1
# 21 "/home/nathan/src/linux-next/include/uapi/linux/if_vlan.h"
enum vlan_ioctl_cmds {
 ADD_VLAN_CMD,
 DEL_VLAN_CMD,
 SET_VLAN_INGRESS_PRIORITY_CMD,
 SET_VLAN_EGRESS_PRIORITY_CMD,
 GET_VLAN_INGRESS_PRIORITY_CMD,
 GET_VLAN_EGRESS_PRIORITY_CMD,
 SET_VLAN_NAME_TYPE_CMD,
 SET_VLAN_FLAG_CMD,
 GET_VLAN_REALDEV_NAME_CMD,
 GET_VLAN_VID_CMD
};

enum vlan_flags {
 VLAN_FLAG_REORDER_HDR = 0x1,
 VLAN_FLAG_GVRP = 0x2,
 VLAN_FLAG_LOOSE_BINDING = 0x4,
 VLAN_FLAG_MVRP = 0x8,
 VLAN_FLAG_BRIDGE_BINDING = 0x10,
};

enum vlan_name_types {
 VLAN_NAME_TYPE_PLUS_VID,
 VLAN_NAME_TYPE_RAW_PLUS_VID,
 VLAN_NAME_TYPE_PLUS_VID_NO_PAD,
 VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD,
 VLAN_NAME_TYPE_HIGHEST
};

struct vlan_ioctl_args {
 int cmd;
 char device1[24];

        union {
  char device2[24];
  int VID;
  unsigned int skb_priority;
  unsigned int name_type;
  unsigned int bind_type;
  unsigned int flag;
        } u;

 short vlan_qos;
};
# 15 "/home/nathan/src/linux-next/include/linux/if_vlan.h" 2
# 33 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
struct vlan_hdr {
 __be16 h_vlan_TCI;
 __be16 h_vlan_encapsulated_proto;
};
# 46 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
struct vlan_ethhdr {
 unsigned char h_dest[6];
 unsigned char h_source[6];
 __be16 h_vlan_proto;
 __be16 h_vlan_TCI;
 __be16 h_vlan_encapsulated_proto;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct vlan_ethhdr *vlan_eth_hdr(const struct sk_buff *skb)
{
 return (struct vlan_ethhdr *)skb_mac_header(skb);
}
# 68 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
extern void vlan_ioctl_set(int (*hook)(struct net *, void *));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_vlan_dev(const struct net_device *dev)
{
        return dev->priv_flags & IFF_802_1Q_VLAN;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vlan_get_rx_ctag_filter_info(struct net_device *dev)
{
 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/linux/if_vlan.h", 83); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (83), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return notifier_to_errno(call_netdevice_notifiers(NETDEV_CVLAN_FILTER_PUSH_INFO, dev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vlan_drop_rx_ctag_filter_info(struct net_device *dev)
{
 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/linux/if_vlan.h", 89); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (89), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 call_netdevice_notifiers(NETDEV_CVLAN_FILTER_DROP_INFO, dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vlan_get_rx_stag_filter_info(struct net_device *dev)
{
 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/linux/if_vlan.h", 95); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (95), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return notifier_to_errno(call_netdevice_notifiers(NETDEV_SVLAN_FILTER_PUSH_INFO, dev));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vlan_drop_rx_stag_filter_info(struct net_device *dev)
{
 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/linux/if_vlan.h", 101); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (101), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 call_netdevice_notifiers(NETDEV_SVLAN_FILTER_DROP_INFO, dev);
}
# 116 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
struct vlan_pcpu_stats {
 u64 rx_packets;
 u64 rx_bytes;
 u64 rx_multicast;
 u64 tx_packets;
 u64 tx_bytes;
 struct u64_stats_sync syncp;
 u32 rx_errors;
 u32 tx_dropped;
};
# 224 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *
__vlan_find_dev_deep_rcu(struct net_device *real_dev,
       __be16 vlan_proto, u16 vlan_id)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
vlan_for_each(struct net_device *dev,
       int (*action)(struct net_device *dev, int vid, void *arg),
       void *arg)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *vlan_dev_real_dev(const struct net_device *dev)
{
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (241), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 vlan_dev_vlan_id(const struct net_device *dev)
{
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (247), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be16 vlan_dev_vlan_proto(const struct net_device *dev)
{
 do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (253), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 vlan_dev_get_egress_qos_mask(struct net_device *dev,
            u32 skprio)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vlan_do_receive(struct sk_buff **skb)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vlan_vid_add(struct net_device *dev, __be16 proto, u16 vid)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vlan_vid_del(struct net_device *dev, __be16 proto, u16 vid)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vlan_vids_add_by_dev(struct net_device *dev,
           const struct net_device *by_dev)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vlan_vids_del_by_dev(struct net_device *dev,
     const struct net_device *by_dev)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vlan_uses_dev(const struct net_device *dev)
{
 return false;
}
# 300 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool eth_type_vlan(__be16 ethertype)
{
 switch (ethertype) {
 case (( __be16)(__u16)(0x8100)):
 case (( __be16)(__u16)(0x88A8)):
  return true;
 default:
  return false;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool vlan_hw_offload_capable(netdev_features_t features,
        __be16 proto)
{
 if (proto == (( __be16)(__u16)(0x8100)) && features & ((netdev_features_t)1 << (NETIF_F_HW_VLAN_CTAG_TX_BIT)))
  return true;
 if (proto == (( __be16)(__u16)(0x88A8)) && features & ((netdev_features_t)1 << (NETIF_F_HW_VLAN_STAG_TX_BIT)))
  return true;
 return false;
}
# 333 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __vlan_insert_inner_tag(struct sk_buff *skb,
       __be16 vlan_proto, u16 vlan_tci,
       unsigned int mac_len)
{
 struct vlan_ethhdr *veth;

 if (skb_cow_head(skb, 4) < 0)
  return -12;

 skb_push(skb, 4);


 if (__builtin_expect(!!(mac_len > 2), 1))
  memmove(skb->data, skb->data + 4, mac_len - 2);
 skb->mac_header -= 4;

 veth = (struct vlan_ethhdr *)(skb->data + mac_len - 14);


 if (__builtin_expect(!!(mac_len >= 2), 1)) {



  veth->h_vlan_proto = vlan_proto;
 } else {



  veth->h_vlan_encapsulated_proto = skb->protocol;
 }


 veth->h_vlan_TCI = (( __be16)(__u16)(vlan_tci));

 return 0;
}
# 381 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __vlan_insert_tag(struct sk_buff *skb,
        __be16 vlan_proto, u16 vlan_tci)
{
 return __vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, 14);
}
# 402 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *vlan_insert_inner_tag(struct sk_buff *skb,
          __be16 vlan_proto,
          u16 vlan_tci,
          unsigned int mac_len)
{
 int err;

 err = __vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, mac_len);
 if (err) {
  dev_kfree_skb_any(skb);
  return ((void *)0);
 }
 return skb;
}
# 431 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *vlan_insert_tag(struct sk_buff *skb,
           __be16 vlan_proto, u16 vlan_tci)
{
 return vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, 14);
}
# 449 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *vlan_insert_tag_set_proto(struct sk_buff *skb,
       __be16 vlan_proto,
       u16 vlan_tci)
{
 skb = vlan_insert_tag(skb, vlan_proto, vlan_tci);
 if (skb)
  skb->protocol = vlan_proto;
 return skb;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __vlan_hwaccel_clear_tag(struct sk_buff *skb)
{
 skb->vlan_present = 0;
}
# 477 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __vlan_hwaccel_copy_tag(struct sk_buff *dst, const struct sk_buff *src)
{
 dst->vlan_present = src->vlan_present;
 dst->vlan_proto = src->vlan_proto;
 dst->vlan_tci = src->vlan_tci;
}
# 493 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__vlan_hwaccel_push_inside(struct sk_buff *skb)
{
 skb = vlan_insert_tag_set_proto(skb, skb->vlan_proto,
     ((skb)->vlan_tci));
 if (__builtin_expect(!!(skb), 1))
  __vlan_hwaccel_clear_tag(skb);
 return skb;
}
# 510 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __vlan_hwaccel_put_tag(struct sk_buff *skb,
       __be16 vlan_proto, u16 vlan_tci)
{
 skb->vlan_proto = vlan_proto;
 skb->vlan_tci = vlan_tci;
 skb->vlan_present = 1;
}
# 525 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __vlan_get_tag(const struct sk_buff *skb, u16 *vlan_tci)
{
 struct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb->data;

 if (!eth_type_vlan(veth->h_vlan_proto))
  return -22;

 *vlan_tci = (( __u16)(__be16)(veth->h_vlan_TCI));
 return 0;
}
# 543 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __vlan_hwaccel_get_tag(const struct sk_buff *skb,
      u16 *vlan_tci)
{
 if (((skb)->vlan_present)) {
  *vlan_tci = ((skb)->vlan_tci);
  return 0;
 } else {
  *vlan_tci = 0;
  return -22;
 }
}
# 562 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int vlan_get_tag(const struct sk_buff *skb, u16 *vlan_tci)
{
 if (skb->dev->features & ((netdev_features_t)1 << (NETIF_F_HW_VLAN_CTAG_TX_BIT))) {
  return __vlan_hwaccel_get_tag(skb, vlan_tci);
 } else {
  return __vlan_get_tag(skb, vlan_tci);
 }
}
# 580 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type,
      int *depth)
{
 unsigned int vlan_depth = skb->mac_len;





 if (eth_type_vlan(type)) {
  if (vlan_depth) {
   if (({ int __ret_warn_on = !!(vlan_depth < 4); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (591), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/if_vlan.h"), "i" (591), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); }))
    return 0;
   vlan_depth -= 4;
  } else {
   vlan_depth = 14;
  }
  do {
   struct vlan_hdr *vh;

   if (__builtin_expect(!!(!pskb_may_pull(skb, vlan_depth + 4)), 0))

    return 0;

   vh = (struct vlan_hdr *)(skb->data + vlan_depth);
   type = vh->h_vlan_encapsulated_proto;
   vlan_depth += 4;
  } while (eth_type_vlan(type));
 }

 if (depth)
  *depth = vlan_depth;

 return type;
}
# 623 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be16 vlan_get_protocol(struct sk_buff *skb)
{
 return __vlan_get_protocol(skb, skb->protocol, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void vlan_set_encap_proto(struct sk_buff *skb,
     struct vlan_hdr *vhdr)
{
 __be16 proto;
 unsigned short *rawp;






 proto = vhdr->h_vlan_encapsulated_proto;
 if (eth_proto_is_802_3(proto)) {
  skb->protocol = proto;
  return;
 }

 rawp = (unsigned short *)(vhdr + 1);
 if (*rawp == 0xFFFF)







  skb->protocol = (( __be16)(__u16)(0x0001));
 else



  skb->protocol = (( __be16)(__u16)(0x0004));
}
# 669 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_vlan_tagged(const struct sk_buff *skb)
{
 if (!((skb)->vlan_present) &&
     __builtin_expect(!!(!eth_type_vlan(skb->protocol)), 1))
  return false;

 return true;
}
# 685 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_vlan_tagged_multi(struct sk_buff *skb)
{
 __be16 protocol = skb->protocol;

 if (!((skb)->vlan_present)) {
  struct vlan_ethhdr *veh;

  if (__builtin_expect(!!(!eth_type_vlan(protocol)), 1))
   return false;

  if (__builtin_expect(!!(!pskb_may_pull(skb, 18)), 0))
   return false;

  veh = (struct vlan_ethhdr *)skb->data;
  protocol = veh->h_vlan_encapsulated_proto;
 }

 if (!eth_type_vlan(protocol))
  return false;

 return true;
}
# 715 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) netdev_features_t vlan_features_check(struct sk_buff *skb,
          netdev_features_t features)
{
 if (skb_vlan_tagged_multi(skb)) {





  features &= ((netdev_features_t)1 << (NETIF_F_SG_BIT)) | ((netdev_features_t)1 << (NETIF_F_HIGHDMA_BIT)) | ((netdev_features_t)1 << (NETIF_F_HW_CSUM_BIT)) |
       ((netdev_features_t)1 << (NETIF_F_FRAGLIST_BIT)) | ((netdev_features_t)1 << (NETIF_F_HW_VLAN_CTAG_TX_BIT)) |
       ((netdev_features_t)1 << (NETIF_F_HW_VLAN_STAG_TX_BIT));
 }

 return features;
}
# 741 "/home/nathan/src/linux-next/include/linux/if_vlan.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long compare_vlan_header(const struct vlan_hdr *h1,
      const struct vlan_hdr *h2)
{

 return *(u32 *)h1 ^ *(u32 *)h2;





}
# 23 "/home/nathan/src/linux-next/include/linux/filter.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/vmalloc.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
# 1 "/home/nathan/src/linux-next/arch/powerpc/include/asm/vmalloc.h" 1
# 14 "/home/nathan/src/linux-next/include/linux/vmalloc.h" 2

struct vm_area_struct;
struct notifier_block;
# 55 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
struct vm_struct {
 struct vm_struct *next;
 void *addr;
 unsigned long size;
 unsigned long flags;
 struct page **pages;
 unsigned int nr_pages;
 phys_addr_t phys_addr;
 const void *caller;
};

struct vmap_area {
 unsigned long va_start;
 unsigned long va_end;

 struct rb_node rb_node;
 struct list_head list;
# 80 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
 union {
  unsigned long subtree_max_size;
  struct vm_struct *vm;
  struct llist_node purge_list;
 };
};




extern void vm_unmap_ram(const void *mem, unsigned int count);
extern void *vm_map_ram(struct page **pages, unsigned int count,
    int node, pgprot_t prot);
extern void vm_unmap_aliases(void);


extern void __attribute__((__section__(".init.text"))) __attribute__((__cold__)) vmalloc_init(void);
extern unsigned long vmalloc_nr_pages(void);







extern void *vmalloc(unsigned long size);
extern void *vzalloc(unsigned long size);
extern void *vmalloc_user(unsigned long size);
extern void *vmalloc_node(unsigned long size, int node);
extern void *vzalloc_node(unsigned long size, int node);
extern void *vmalloc_user_node_flags(unsigned long size, int node, gfp_t flags);
extern void *vmalloc_exec(unsigned long size);
extern void *vmalloc_32(unsigned long size);
extern void *vmalloc_32_user(unsigned long size);
extern void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot);
extern void *__vmalloc_node_range(unsigned long size, unsigned long align,
   unsigned long start, unsigned long end, gfp_t gfp_mask,
   pgprot_t prot, unsigned long vm_flags, int node,
   const void *caller);
# 127 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
extern void *__vmalloc_node_flags_caller(unsigned long size,
      int node, gfp_t flags, void *caller);


extern void vfree(const void *addr);
extern void vfree_atomic(const void *addr);

extern void *vmap(struct page **pages, unsigned int count,
   unsigned long flags, pgprot_t prot);
extern void vunmap(const void *addr);

extern int remap_vmalloc_range_partial(struct vm_area_struct *vma,
           unsigned long uaddr, void *kaddr,
           unsigned long size);

extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,
       unsigned long pgoff);
void vmalloc_sync_all(void);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) size_t get_vm_area_size(const struct vm_struct *area)
{
 if (!(area->flags & 0x00000040))

  return area->size - (1UL << 16);
 else
  return area->size;

}

extern struct vm_struct *get_vm_area(unsigned long size, unsigned long flags);
extern struct vm_struct *get_vm_area_caller(unsigned long size,
     unsigned long flags, const void *caller);
extern struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,
     unsigned long start, unsigned long end);
extern struct vm_struct *__get_vm_area_caller(unsigned long size,
     unsigned long flags,
     unsigned long start, unsigned long end,
     const void *caller);
extern struct vm_struct *remove_vm_area(const void *addr);
extern struct vm_struct *find_vm_area(const void *addr);

extern int map_vm_area(struct vm_struct *area, pgprot_t prot,
   struct page **pages);

extern int map_kernel_range_noflush(unsigned long start, unsigned long size,
        pgprot_t prot, struct page **pages);
extern void unmap_kernel_range_noflush(unsigned long addr, unsigned long size);
extern void unmap_kernel_range(unsigned long addr, unsigned long size);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void set_vm_flush_reset_perms(void *addr)
{
 struct vm_struct *vm = find_vm_area(addr);

 if (vm)
  vm->flags |= 0x00000100;
}
# 207 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
extern struct vm_struct *alloc_vm_area(size_t size, pte_t **ptes);
extern void free_vm_area(struct vm_struct *area);


extern long vread(char *buf, char *addr, unsigned long count);
extern long vwrite(char *buf, char *addr, unsigned long count);




extern struct list_head vmap_area_list;
extern __attribute__((__section__(".init.text"))) __attribute__((__cold__)) void vm_area_add_early(struct vm_struct *vm);
extern __attribute__((__section__(".init.text"))) __attribute__((__cold__)) void vm_area_register_early(struct vm_struct *vm, size_t align);



struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,
         const size_t *sizes, int nr_vms,
         size_t align);

void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms);
# 250 "/home/nathan/src/linux-next/include/linux/vmalloc.h"
int register_vmap_purge_notifier(struct notifier_block *nb);
int unregister_vmap_purge_notifier(struct notifier_block *nb);
# 24 "/home/nathan/src/linux-next/include/linux/filter.h" 2

# 1 "/home/nathan/src/linux-next/include/net/sch_generic.h" 1
# 19 "/home/nathan/src/linux-next/include/net/sch_generic.h"
# 1 "/home/nathan/src/linux-next/include/net/gen_stats.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/gen_stats.h" 1






enum {
 TCA_STATS_UNSPEC,
 TCA_STATS_BASIC,
 TCA_STATS_RATE_EST,
 TCA_STATS_QUEUE,
 TCA_STATS_APP,
 TCA_STATS_RATE_EST64,
 TCA_STATS_PAD,
 TCA_STATS_BASIC_HW,
 TCA_STATS_PKT64,
 __TCA_STATS_MAX,
};







struct gnet_stats_basic {
 __u64 bytes;
 __u32 packets;
};






struct gnet_stats_rate_est {
 __u32 bps;
 __u32 pps;
};






struct gnet_stats_rate_est64 {
 __u64 bps;
 __u64 pps;
};
# 59 "/home/nathan/src/linux-next/include/uapi/linux/gen_stats.h"
struct gnet_stats_queue {
 __u32 qlen;
 __u32 backlog;
 __u32 drops;
 __u32 requeues;
 __u32 overlimits;
};






struct gnet_estimator {
 signed char interval;
 unsigned char ewma_log;
};
# 6 "/home/nathan/src/linux-next/include/net/gen_stats.h" 2





struct gnet_stats_basic_packed {
 __u64 bytes;
 __u64 packets;
};

struct gnet_stats_basic_cpu {
 struct gnet_stats_basic_packed bstats;
 struct u64_stats_sync syncp;
} __attribute__((__aligned__(2 * sizeof(u64))));

struct net_rate_estimator;

struct gnet_dump {
 spinlock_t * lock;
 struct sk_buff * skb;
 struct nlattr * tail;


 int compat_tc_stats;
 int compat_xstats;
 int padattr;
 void * xstats;
 int xstats_len;
 struct tc_stats tc_stats;
};

int gnet_stats_start_copy(struct sk_buff *skb, int type, spinlock_t *lock,
     struct gnet_dump *d, int padattr);

int gnet_stats_start_copy_compat(struct sk_buff *skb, int type,
     int tc_stats_type, int xstats_type,
     spinlock_t *lock, struct gnet_dump *d,
     int padattr);

int gnet_stats_copy_basic(const seqcount_t *running,
     struct gnet_dump *d,
     struct gnet_stats_basic_cpu *cpu,
     struct gnet_stats_basic_packed *b);
void __gnet_stats_copy_basic(const seqcount_t *running,
        struct gnet_stats_basic_packed *bstats,
        struct gnet_stats_basic_cpu *cpu,
        struct gnet_stats_basic_packed *b);
int gnet_stats_copy_basic_hw(const seqcount_t *running,
        struct gnet_dump *d,
        struct gnet_stats_basic_cpu *cpu,
        struct gnet_stats_basic_packed *b);
int gnet_stats_copy_rate_est(struct gnet_dump *d,
        struct net_rate_estimator **ptr);
int gnet_stats_copy_queue(struct gnet_dump *d,
     struct gnet_stats_queue *cpu_q,
     struct gnet_stats_queue *q, __u32 qlen);
void __gnet_stats_copy_queue(struct gnet_stats_queue *qstats,
        const struct gnet_stats_queue *cpu_q,
        const struct gnet_stats_queue *q, __u32 qlen);
int gnet_stats_copy_app(struct gnet_dump *d, void *st, int len);

int gnet_stats_finish_copy(struct gnet_dump *d);

int gen_new_estimator(struct gnet_stats_basic_packed *bstats,
        struct gnet_stats_basic_cpu *cpu_bstats,
        struct net_rate_estimator **rate_est,
        spinlock_t *lock,
        seqcount_t *running, struct nlattr *opt);
void gen_kill_estimator(struct net_rate_estimator **ptr);
int gen_replace_estimator(struct gnet_stats_basic_packed *bstats,
     struct gnet_stats_basic_cpu *cpu_bstats,
     struct net_rate_estimator **ptr,
     spinlock_t *lock,
     seqcount_t *running, struct nlattr *opt);
bool gen_estimator_active(struct net_rate_estimator **ptr);
bool gen_estimator_read(struct net_rate_estimator **ptr,
   struct gnet_stats_rate_est64 *sample);
# 20 "/home/nathan/src/linux-next/include/net/sch_generic.h" 2
# 1 "/home/nathan/src/linux-next/include/net/rtnetlink.h" 1





# 1 "/home/nathan/src/linux-next/include/net/netlink.h" 1
# 165 "/home/nathan/src/linux-next/include/net/netlink.h"
enum {
 NLA_UNSPEC,
 NLA_U8,
 NLA_U16,
 NLA_U32,
 NLA_U64,
 NLA_STRING,
 NLA_FLAG,
 NLA_MSECS,
 NLA_NESTED,
 NLA_NESTED_ARRAY,
 NLA_NUL_STRING,
 NLA_BINARY,
 NLA_S8,
 NLA_S16,
 NLA_S32,
 NLA_S64,
 NLA_BITFIELD32,
 NLA_REJECT,
 NLA_EXACT_LEN,
 NLA_EXACT_LEN_WARN,
 NLA_MIN_LEN,
 __NLA_TYPE_MAX,
};



enum nla_policy_validation {
 NLA_VALIDATE_NONE,
 NLA_VALIDATE_RANGE,
 NLA_VALIDATE_MIN,
 NLA_VALIDATE_MAX,
 NLA_VALIDATE_FUNCTION,
};
# 291 "/home/nathan/src/linux-next/include/net/netlink.h"
struct nla_policy {
 u8 type;
 u8 validation_type;
 u16 len;
 union {
  const void *validation_data;
  struct {
   s16 min, max;
  };
  int (*validate)(const struct nlattr *attr,
    struct netlink_ext_ack *extack);
# 319 "/home/nathan/src/linux-next/include/net/netlink.h"
  u16 strict_start_type;
 };
};
# 386 "/home/nathan/src/linux-next/include/net/netlink.h"
struct nl_info {
 struct nlmsghdr *nlh;
 struct net *nl_net;
 u32 portid;
 u8 skip_notify:1,
    skip_notify_kernel:1;
};
# 411 "/home/nathan/src/linux-next/include/net/netlink.h"
enum netlink_validation {
 NL_VALIDATE_LIBERAL = 0,
 NL_VALIDATE_TRAILING = ((((1UL))) << (0)),
 NL_VALIDATE_MAXTYPE = ((((1UL))) << (1)),
 NL_VALIDATE_UNSPEC = ((((1UL))) << (2)),
 NL_VALIDATE_STRICT_ATTRS = ((((1UL))) << (3)),
 NL_VALIDATE_NESTED = ((((1UL))) << (4)),
};
# 428 "/home/nathan/src/linux-next/include/net/netlink.h"
int netlink_rcv_skb(struct sk_buff *skb,
      int (*cb)(struct sk_buff *, struct nlmsghdr *,
         struct netlink_ext_ack *));
int nlmsg_notify(struct sock *sk, struct sk_buff *skb, u32 portid,
   unsigned int group, int report, gfp_t flags);

int __nla_validate(const struct nlattr *head, int len, int maxtype,
     const struct nla_policy *policy, unsigned int validate,
     struct netlink_ext_ack *extack);
int __nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,
  int len, const struct nla_policy *policy, unsigned int validate,
  struct netlink_ext_ack *extack);
int nla_policy_len(const struct nla_policy *, int);
struct nlattr *nla_find(const struct nlattr *head, int len, int attrtype);
size_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize);
char *nla_strdup(const struct nlattr *nla, gfp_t flags);
int nla_memcpy(void *dest, const struct nlattr *src, int count);
int nla_memcmp(const struct nlattr *nla, const void *data, size_t size);
int nla_strcmp(const struct nlattr *nla, const char *str);
struct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);
struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
       int attrlen, int padattr);
void *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen);
struct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);
struct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype,
     int attrlen, int padattr);
void *nla_reserve_nohdr(struct sk_buff *skb, int attrlen);
void __nla_put(struct sk_buff *skb, int attrtype, int attrlen,
        const void *data);
void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
       const void *data, int padattr);
void __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);
int nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data);
int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
    const void *data, int padattr);
int nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);
int nla_append(struct sk_buff *skb, int attrlen, const void *data);
# 474 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_msg_size(int payload)
{
 return ((int) ( ((sizeof(struct nlmsghdr))+4U -1) & ~(4U -1) )) + payload;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_total_size(int payload)
{
 return ( ((nlmsg_msg_size(payload))+4U -1) & ~(4U -1) );
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_padlen(int payload)
{
 return nlmsg_total_size(payload) - nlmsg_msg_size(payload);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *nlmsg_data(const struct nlmsghdr *nlh)
{
 return (unsigned char *) nlh + ((int) ( ((sizeof(struct nlmsghdr))+4U -1) & ~(4U -1) ));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_len(const struct nlmsghdr *nlh)
{
 return nlh->nlmsg_len - ((int) ( ((sizeof(struct nlmsghdr))+4U -1) & ~(4U -1) ));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *nlmsg_attrdata(const struct nlmsghdr *nlh,
         int hdrlen)
{
 unsigned char *data = nlmsg_data(nlh);
 return (struct nlattr *) (data + ( ((hdrlen)+4U -1) & ~(4U -1) ));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_attrlen(const struct nlmsghdr *nlh, int hdrlen)
{
 return nlmsg_len(nlh) - ( ((hdrlen)+4U -1) & ~(4U -1) );
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_ok(const struct nlmsghdr *nlh, int remaining)
{
 return (remaining >= (int) sizeof(struct nlmsghdr) &&
  nlh->nlmsg_len >= sizeof(struct nlmsghdr) &&
  nlh->nlmsg_len <= remaining);
}
# 557 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlmsghdr *
nlmsg_next(const struct nlmsghdr *nlh, int *remaining)
{
 int totlen = ( ((nlh->nlmsg_len)+4U -1) & ~(4U -1) );

 *remaining -= totlen;

 return (struct nlmsghdr *) ((unsigned char *) nlh + totlen);
}
# 583 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_parse(struct nlattr **tb, int maxtype,
       const struct nlattr *head, int len,
       const struct nla_policy *policy,
       struct netlink_ext_ack *extack)
{
 return __nla_parse(tb, maxtype, head, len, policy,
      (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE | NL_VALIDATE_UNSPEC | NL_VALIDATE_STRICT_ATTRS | NL_VALIDATE_NESTED), extack);
}
# 608 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_parse_deprecated(struct nlattr **tb, int maxtype,
           const struct nlattr *head, int len,
           const struct nla_policy *policy,
           struct netlink_ext_ack *extack)
{
 return __nla_parse(tb, maxtype, head, len, policy,
      NL_VALIDATE_LIBERAL, extack);
}
# 633 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_parse_deprecated_strict(struct nlattr **tb, int maxtype,
           const struct nlattr *head,
           int len,
           const struct nla_policy *policy,
           struct netlink_ext_ack *extack)
{
 return __nla_parse(tb, maxtype, head, len, policy,
      (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE), extack);
}
# 655 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,
    struct nlattr *tb[], int maxtype,
    const struct nla_policy *policy,
    unsigned int validate,
    struct netlink_ext_ack *extack)
{
 if (nlh->nlmsg_len < nlmsg_msg_size(hdrlen)) {
  do { static const char __msg[] = "Invalid header length"; struct netlink_ext_ack *__extack = (extack); if (__extack) __extack->_msg = __msg; } while (0);
  return -22;
 }

 return __nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
      nlmsg_attrlen(nlh, hdrlen), policy, validate,
      extack);
}
# 682 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,
         struct nlattr *tb[], int maxtype,
         const struct nla_policy *policy,
         struct netlink_ext_ack *extack)
{
 return __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,
        (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE | NL_VALIDATE_UNSPEC | NL_VALIDATE_STRICT_ATTRS | NL_VALIDATE_NESTED), extack);
}
# 701 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_parse_deprecated(const struct nlmsghdr *nlh, int hdrlen,
      struct nlattr *tb[], int maxtype,
      const struct nla_policy *policy,
      struct netlink_ext_ack *extack)
{
 return __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,
        NL_VALIDATE_LIBERAL, extack);
}
# 720 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
nlmsg_parse_deprecated_strict(const struct nlmsghdr *nlh, int hdrlen,
         struct nlattr *tb[], int maxtype,
         const struct nla_policy *policy,
         struct netlink_ext_ack *extack)
{
 return __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,
        (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE), extack);
}
# 738 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *nlmsg_find_attr(const struct nlmsghdr *nlh,
          int hdrlen, int attrtype)
{
 return nla_find(nlmsg_attrdata(nlh, hdrlen),
   nlmsg_attrlen(nlh, hdrlen), attrtype);
}
# 760 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_validate_deprecated(const struct nlattr *head, int len,
       int maxtype,
       const struct nla_policy *policy,
       struct netlink_ext_ack *extack)
{
 return __nla_validate(head, len, maxtype, policy, NL_VALIDATE_LIBERAL,
         extack);
}
# 784 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_validate(const struct nlattr *head, int len, int maxtype,
          const struct nla_policy *policy,
          struct netlink_ext_ack *extack)
{
 return __nla_validate(head, len, maxtype, policy, (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE | NL_VALIDATE_UNSPEC | NL_VALIDATE_STRICT_ATTRS | NL_VALIDATE_NESTED),
         extack);
}
# 800 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_validate_deprecated(const struct nlmsghdr *nlh,
         int hdrlen, int maxtype,
         const struct nla_policy *policy,
         struct netlink_ext_ack *extack)
{
 if (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))
  return -22;

 return __nla_validate(nlmsg_attrdata(nlh, hdrlen),
         nlmsg_attrlen(nlh, hdrlen), maxtype,
         policy, NL_VALIDATE_LIBERAL, extack);
}
# 821 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_report(const struct nlmsghdr *nlh)
{
 return !!(nlh->nlmsg_flags & 0x08);
}
# 849 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlmsghdr *nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,
      int type, int payload, int flags)
{
 if (__builtin_expect(!!(skb_tailroom(skb) < nlmsg_total_size(payload)), 0))
  return ((void *)0);

 return __nlmsg_put(skb, portid, seq, type, payload, flags);
}
# 869 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlmsghdr *nlmsg_put_answer(struct sk_buff *skb,
      struct netlink_callback *cb,
      int type, int payload,
      int flags)
{
 return nlmsg_put(skb, (*(struct netlink_skb_parms*)&((cb->skb)->cb)).portid, cb->nlh->nlmsg_seq,
    type, payload, flags);
}
# 886 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *nlmsg_new(size_t payload, gfp_t flags)
{
 return alloc_skb(nlmsg_total_size(payload), flags);
}
# 900 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nlmsg_end(struct sk_buff *skb, struct nlmsghdr *nlh)
{
 nlh->nlmsg_len = skb_tail_pointer(skb) - (unsigned char *)nlh;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *nlmsg_get_pos(struct sk_buff *skb)
{
 return skb_tail_pointer(skb);
}
# 923 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nlmsg_trim(struct sk_buff *skb, const void *mark)
{
 if (mark) {
  ({ int __ret_warn_on = !!((unsigned char *) mark < skb->data); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/netlink.h"), "i" (926), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/netlink.h"), "i" (926), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
  skb_trim(skb, (unsigned char *) mark - skb->data);
 }
}
# 939 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nlmsg_cancel(struct sk_buff *skb, struct nlmsghdr *nlh)
{
 nlmsg_trim(skb, nlh);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nlmsg_free(struct sk_buff *skb)
{
 kfree_skb(skb);
}
# 961 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_multicast(struct sock *sk, struct sk_buff *skb,
      u32 portid, unsigned int group, gfp_t flags)
{
 int err;

 (*(struct netlink_skb_parms*)&((skb)->cb)).dst_group = group;

 err = netlink_broadcast(sk, skb, portid, group, flags);
 if (err > 0)
  err = 0;

 return err;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nlmsg_unicast(struct sock *sk, struct sk_buff *skb, u32 portid)
{
 int err;

 err = netlink_unicast(sk, skb, portid, 0x40);
 if (err > 0)
  err = 0;

 return err;
}
# 1019 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
nl_dump_check_consistent(struct netlink_callback *cb,
    struct nlmsghdr *nlh)
{
 if (cb->prev_seq && cb->seq != cb->prev_seq)
  nlh->nlmsg_flags |= 0x10;
 cb->prev_seq = cb->seq;
}
# 1036 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_attr_size(int payload)
{
 return ((int) (((sizeof(struct nlattr)) + 4 - 1) & ~(4 - 1))) + payload;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_total_size(int payload)
{
 return (((nla_attr_size(payload)) + 4 - 1) & ~(4 - 1));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_padlen(int payload)
{
 return nla_total_size(payload) - nla_attr_size(payload);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_type(const struct nlattr *nla)
{
 return nla->nla_type & ~((1 << 15) | (1 << 14));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *nla_data(const struct nlattr *nla)
{
 return (char *) nla + ((int) (((sizeof(struct nlattr)) + 4 - 1) & ~(4 - 1)));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_len(const struct nlattr *nla)
{
 return nla->nla_len - ((int) (((sizeof(struct nlattr)) + 4 - 1) & ~(4 - 1)));
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_ok(const struct nlattr *nla, int remaining)
{
 return remaining >= (int) sizeof(*nla) &&
        nla->nla_len >= sizeof(*nla) &&
        nla->nla_len <= remaining;
}
# 1106 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *nla_next(const struct nlattr *nla, int *remaining)
{
 unsigned int totlen = (((nla->nla_len) + 4 - 1) & ~(4 - 1));

 *remaining -= totlen;
 return (struct nlattr *) ((char *) nla + totlen);
}
# 1121 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *
nla_find_nested(const struct nlattr *nla, int attrtype)
{
 return nla_find(nla_data(nla), nla_len(nla), attrtype);
}
# 1137 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_parse_nested(struct nlattr *tb[], int maxtype,
       const struct nlattr *nla,
       const struct nla_policy *policy,
       struct netlink_ext_ack *extack)
{
 if (!(nla->nla_type & (1 << 15))) {
  do { static const char __msg[] = "NLA_F_NESTED is missing"; struct netlink_ext_ack *__extack = (extack); if (__extack) { __extack->_msg = __msg; __extack->bad_attr = (nla); } } while (0);
  return -22;
 }

 return __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,
      (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE | NL_VALIDATE_UNSPEC | NL_VALIDATE_STRICT_ATTRS | NL_VALIDATE_NESTED), extack);
}
# 1161 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,
           const struct nlattr *nla,
           const struct nla_policy *policy,
           struct netlink_ext_ack *extack)
{
 return __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,
      NL_VALIDATE_LIBERAL, extack);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_u8(struct sk_buff *skb, int attrtype, u8 value)
{

 u8 tmp = value;

 return nla_put(skb, attrtype, sizeof(u8), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_u16(struct sk_buff *skb, int attrtype, u16 value)
{
 u16 tmp = value;

 return nla_put(skb, attrtype, sizeof(u16), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)
{
 __be16 tmp = value;

 return nla_put(skb, attrtype, sizeof(__be16), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_net16(struct sk_buff *skb, int attrtype, __be16 value)
{
 __be16 tmp = value;

 return nla_put_be16(skb, attrtype | (1 << 14), tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_le16(struct sk_buff *skb, int attrtype, __le16 value)
{
 __le16 tmp = value;

 return nla_put(skb, attrtype, sizeof(__le16), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)
{
 u32 tmp = value;

 return nla_put(skb, attrtype, sizeof(u32), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)
{
 __be32 tmp = value;

 return nla_put(skb, attrtype, sizeof(__be32), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_net32(struct sk_buff *skb, int attrtype, __be32 value)
{
 __be32 tmp = value;

 return nla_put_be32(skb, attrtype | (1 << 14), tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_le32(struct sk_buff *skb, int attrtype, __le32 value)
{
 __le32 tmp = value;

 return nla_put(skb, attrtype, sizeof(__le32), &tmp);
}
# 1295 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
        u64 value, int padattr)
{
 u64 tmp = value;

 return nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);
}
# 1310 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value,
          int padattr)
{
 __be64 tmp = value;

 return nla_put_64bit(skb, attrtype, sizeof(__be64), &tmp, padattr);
}
# 1325 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_net64(struct sk_buff *skb, int attrtype, __be64 value,
    int padattr)
{
 __be64 tmp = value;

 return nla_put_be64(skb, attrtype | (1 << 14), tmp,
       padattr);
}
# 1341 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_le64(struct sk_buff *skb, int attrtype, __le64 value,
          int padattr)
{
 __le64 tmp = value;

 return nla_put_64bit(skb, attrtype, sizeof(__le64), &tmp, padattr);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_s8(struct sk_buff *skb, int attrtype, s8 value)
{
 s8 tmp = value;

 return nla_put(skb, attrtype, sizeof(s8), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_s16(struct sk_buff *skb, int attrtype, s16 value)
{
 s16 tmp = value;

 return nla_put(skb, attrtype, sizeof(s16), &tmp);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_s32(struct sk_buff *skb, int attrtype, s32 value)
{
 s32 tmp = value;

 return nla_put(skb, attrtype, sizeof(s32), &tmp);
}
# 1395 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value,
         int padattr)
{
 s64 tmp = value;

 return nla_put_64bit(skb, attrtype, sizeof(s64), &tmp, padattr);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_string(struct sk_buff *skb, int attrtype,
     const char *str)
{
 return nla_put(skb, attrtype, strlen(str) + 1, str);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_flag(struct sk_buff *skb, int attrtype)
{
 return nla_put(skb, attrtype, 0, ((void *)0));
}
# 1432 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_msecs(struct sk_buff *skb, int attrtype,
    unsigned long njiffies, int padattr)
{
 u64 tmp = jiffies_to_msecs(njiffies);

 return nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);
}
# 1447 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_in_addr(struct sk_buff *skb, int attrtype,
      __be32 addr)
{
 __be32 tmp = addr;

 return nla_put_be32(skb, attrtype, tmp);
}
# 1462 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_put_in6_addr(struct sk_buff *skb, int attrtype,
       const struct in6_addr *addr)
{
 return nla_put(skb, attrtype, sizeof(*addr), addr);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 nla_get_u32(const struct nlattr *nla)
{
 return *(u32 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 nla_get_be32(const struct nlattr *nla)
{
 return *(__be32 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __le32 nla_get_le32(const struct nlattr *nla)
{
 return *(__le32 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 nla_get_u16(const struct nlattr *nla)
{
 return *(u16 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be16 nla_get_be16(const struct nlattr *nla)
{
 return *(__be16 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __le16 nla_get_le16(const struct nlattr *nla)
{
 return *(__le16 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 nla_get_u8(const struct nlattr *nla)
{
 return *(u8 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 nla_get_u64(const struct nlattr *nla)
{
 u64 tmp;

 nla_memcpy(&tmp, nla, sizeof(tmp));

 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be64 nla_get_be64(const struct nlattr *nla)
{
 __be64 tmp;

 nla_memcpy(&tmp, nla, sizeof(tmp));

 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __le64 nla_get_le64(const struct nlattr *nla)
{
 return *(__le64 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s32 nla_get_s32(const struct nlattr *nla)
{
 return *(s32 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s16 nla_get_s16(const struct nlattr *nla)
{
 return *(s16 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s8 nla_get_s8(const struct nlattr *nla)
{
 return *(s8 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 nla_get_s64(const struct nlattr *nla)
{
 s64 tmp;

 nla_memcpy(&tmp, nla, sizeof(tmp));

 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_get_flag(const struct nlattr *nla)
{
 return !!nla;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long nla_get_msecs(const struct nlattr *nla)
{
 u64 msecs = nla_get_u64(nla);

 return msecs_to_jiffies((unsigned long) msecs);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 nla_get_in_addr(const struct nlattr *nla)
{
 return *(__be32 *) nla_data(nla);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct in6_addr nla_get_in6_addr(const struct nlattr *nla)
{
 struct in6_addr tmp;

 nla_memcpy(&tmp, nla, sizeof(tmp));
 return tmp;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nla_bitfield32 nla_get_bitfield32(const struct nlattr *nla)
{
 struct nla_bitfield32 tmp;

 nla_memcpy(&tmp, nla, sizeof(tmp));
 return tmp;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *nla_memdup(const struct nlattr *src, gfp_t gfp)
{
 return kmemdup(nla_data(src), nla_len(src), gfp);
}
# 1682 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *nla_nest_start_noflag(struct sk_buff *skb,
         int attrtype)
{
 struct nlattr *start = (struct nlattr *)skb_tail_pointer(skb);

 if (nla_put(skb, attrtype, 0, ((void *)0)) < 0)
  return ((void *)0);

 return start;
}
# 1703 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct nlattr *nla_nest_start(struct sk_buff *skb, int attrtype)
{
 return nla_nest_start_noflag(skb, attrtype | (1 << 15));
}
# 1718 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_nest_end(struct sk_buff *skb, struct nlattr *start)
{
 start->nla_len = skb_tail_pointer(skb) - (unsigned char *)start;
 return skb->len;
}
# 1732 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void nla_nest_cancel(struct sk_buff *skb, struct nlattr *start)
{
 nlmsg_trim(skb, start);
}
# 1751 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __nla_validate_nested(const struct nlattr *start, int maxtype,
     const struct nla_policy *policy,
     unsigned int validate,
     struct netlink_ext_ack *extack)
{
 return __nla_validate(nla_data(start), nla_len(start), maxtype, policy,
         validate, extack);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
nla_validate_nested(const struct nlattr *start, int maxtype,
      const struct nla_policy *policy,
      struct netlink_ext_ack *extack)
{
 return __nla_validate_nested(start, maxtype, policy,
         (NL_VALIDATE_TRAILING | NL_VALIDATE_MAXTYPE | NL_VALIDATE_UNSPEC | NL_VALIDATE_STRICT_ATTRS | NL_VALIDATE_NESTED), extack);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
nla_validate_nested_deprecated(const struct nlattr *start, int maxtype,
          const struct nla_policy *policy,
          struct netlink_ext_ack *extack)
{
 return __nla_validate_nested(start, maxtype, policy,
         NL_VALIDATE_LIBERAL, extack);
}
# 1785 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool nla_need_padding_for_64bit(struct sk_buff *skb)
{
# 1796 "/home/nathan/src/linux-next/include/net/netlink.h"
 return false;
}
# 1811 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_align_64bit(struct sk_buff *skb, int padattr)
{
 if (nla_need_padding_for_64bit(skb) &&
     !nla_reserve(skb, padattr, 0))
  return -90;

 return 0;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int nla_total_size_64bit(int payload)
{
 return (((nla_attr_size(payload)) + 4 - 1) & ~(4 - 1))



  ;
}
# 1859 "/home/nathan/src/linux-next/include/net/netlink.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool nla_is_last(const struct nlattr *nla, int rem)
{
 return nla->nla_len == rem;
}
# 7 "/home/nathan/src/linux-next/include/net/rtnetlink.h" 2

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *,
         struct netlink_ext_ack *);
typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

enum rtnl_link_flags {
 RTNL_FLAG_DOIT_UNLOCKED = 1,
};

void rtnl_register(int protocol, int msgtype,
     rtnl_doit_func, rtnl_dumpit_func, unsigned int flags);
int rtnl_register_module(struct module *owner, int protocol, int msgtype,
    rtnl_doit_func, rtnl_dumpit_func, unsigned int flags);
int rtnl_unregister(int protocol, int msgtype);
void rtnl_unregister_all(int protocol);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rtnl_msg_family(const struct nlmsghdr *nlh)
{
 if (nlmsg_len(nlh) >= sizeof(struct rtgenmsg))
  return ((struct rtgenmsg *) nlmsg_data(nlh))->rtgen_family;
 else
  return 0;
}
# 59 "/home/nathan/src/linux-next/include/net/rtnetlink.h"
struct rtnl_link_ops {
 struct list_head list;

 const char *kind;

 size_t priv_size;
 void (*setup)(struct net_device *dev);

 unsigned int maxtype;
 const struct nla_policy *policy;
 int (*validate)(struct nlattr *tb[],
         struct nlattr *data[],
         struct netlink_ext_ack *extack);

 int (*newlink)(struct net *src_net,
        struct net_device *dev,
        struct nlattr *tb[],
        struct nlattr *data[],
        struct netlink_ext_ack *extack);
 int (*changelink)(struct net_device *dev,
           struct nlattr *tb[],
           struct nlattr *data[],
           struct netlink_ext_ack *extack);
 void (*dellink)(struct net_device *dev,
        struct list_head *head);

 size_t (*get_size)(const struct net_device *dev);
 int (*fill_info)(struct sk_buff *skb,
          const struct net_device *dev);

 size_t (*get_xstats_size)(const struct net_device *dev);
 int (*fill_xstats)(struct sk_buff *skb,
            const struct net_device *dev);
 unsigned int (*get_num_tx_queues)(void);
 unsigned int (*get_num_rx_queues)(void);

 unsigned int slave_maxtype;
 const struct nla_policy *slave_policy;
 int (*slave_changelink)(struct net_device *dev,
          struct net_device *slave_dev,
          struct nlattr *tb[],
          struct nlattr *data[],
          struct netlink_ext_ack *extack);
 size_t (*get_slave_size)(const struct net_device *dev,
        const struct net_device *slave_dev);
 int (*fill_slave_info)(struct sk_buff *skb,
         const struct net_device *dev,
         const struct net_device *slave_dev);
 struct net *(*get_link_net)(const struct net_device *dev);
 size_t (*get_linkxstats_size)(const struct net_device *dev,
             int attr);
 int (*fill_linkxstats)(struct sk_buff *skb,
         const struct net_device *dev,
         int *prividx, int attr);
};

int __rtnl_link_register(struct rtnl_link_ops *ops);
void __rtnl_link_unregister(struct rtnl_link_ops *ops);

int rtnl_link_register(struct rtnl_link_ops *ops);
void rtnl_link_unregister(struct rtnl_link_ops *ops);
# 135 "/home/nathan/src/linux-next/include/net/rtnetlink.h"
struct rtnl_af_ops {
 struct list_head list;
 int family;

 int (*fill_link_af)(struct sk_buff *skb,
      const struct net_device *dev,
      u32 ext_filter_mask);
 size_t (*get_link_af_size)(const struct net_device *dev,
          u32 ext_filter_mask);

 int (*validate_link_af)(const struct net_device *dev,
          const struct nlattr *attr);
 int (*set_link_af)(struct net_device *dev,
            const struct nlattr *attr);

 int (*fill_stats_af)(struct sk_buff *skb,
       const struct net_device *dev);
 size_t (*get_stats_af_size)(const struct net_device *dev);
};

void rtnl_af_register(struct rtnl_af_ops *ops);
void rtnl_af_unregister(struct rtnl_af_ops *ops);

struct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[]);
struct net_device *rtnl_create_link(struct net *net, const char *ifname,
        unsigned char name_assign_type,
        const struct rtnl_link_ops *ops,
        struct nlattr *tb[],
        struct netlink_ext_ack *extack);
int rtnl_delete_link(struct net_device *dev);
int rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm);

int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len,
   struct netlink_ext_ack *exterr);
struct net *rtnl_get_net_ns_capable(struct sock *sk, int netnsid);
# 21 "/home/nathan/src/linux-next/include/net/sch_generic.h" 2
# 1 "/home/nathan/src/linux-next/include/net/flow_offload.h" 1






# 1 "/home/nathan/src/linux-next/include/linux/rhashtable.h" 1
# 23 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
# 1 "/home/nathan/src/linux-next/include/linux/jhash.h" 1
# 27 "/home/nathan/src/linux-next/include/linux/jhash.h"
# 1 "/home/nathan/src/linux-next/include/linux/unaligned/packed_struct.h" 1





struct __una_u16 { u16 x; } __attribute__((__packed__));
struct __una_u32 { u32 x; } __attribute__((__packed__));
struct __una_u64 { u64 x; } __attribute__((__packed__));

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 __get_unaligned_cpu16(const void *p)
{
 const struct __una_u16 *ptr = (const struct __una_u16 *)p;
 return ptr->x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __get_unaligned_cpu32(const void *p)
{
 const struct __una_u32 *ptr = (const struct __una_u32 *)p;
 return ptr->x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 __get_unaligned_cpu64(const void *p)
{
 const struct __una_u64 *ptr = (const struct __una_u64 *)p;
 return ptr->x;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __put_unaligned_cpu16(u16 val, void *p)
{
 struct __una_u16 *ptr = (struct __una_u16 *)p;
 ptr->x = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __put_unaligned_cpu32(u32 val, void *p)
{
 struct __una_u32 *ptr = (struct __una_u32 *)p;
 ptr->x = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __put_unaligned_cpu64(u64 val, void *p)
{
 struct __una_u64 *ptr = (struct __una_u64 *)p;
 ptr->x = val;
}
# 28 "/home/nathan/src/linux-next/include/linux/jhash.h" 2
# 70 "/home/nathan/src/linux-next/include/linux/jhash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 jhash(const void *key, u32 length, u32 initval)
{
 u32 a, b, c;
 const u8 *k = key;


 a = b = c = 0xdeadbeef + length + initval;


 while (length > 12) {
  a += __get_unaligned_cpu32(k);
  b += __get_unaligned_cpu32(k + 4);
  c += __get_unaligned_cpu32(k + 8);
  { a -= c; a ^= rol32(c, 4); c += b; b -= a; b ^= rol32(a, 6); a += c; c -= b; c ^= rol32(b, 8); b += a; a -= c; a ^= rol32(c, 16); c += b; b -= a; b ^= rol32(a, 19); a += c; c -= b; c ^= rol32(b, 4); b += a; };
  length -= 12;
  k += 12;
 }

 switch (length) {
 case 12: c += (u32)k[11]<<24;
 case 11: c += (u32)k[10]<<16;
 case 10: c += (u32)k[9]<<8;
 case 9: c += k[8];
 case 8: b += (u32)k[7]<<24;
 case 7: b += (u32)k[6]<<16;
 case 6: b += (u32)k[5]<<8;
 case 5: b += k[4];
 case 4: a += (u32)k[3]<<24;
 case 3: a += (u32)k[2]<<16;
 case 2: a += (u32)k[1]<<8;
 case 1: a += k[0];
   { c ^= b; c -= rol32(b, 14); a ^= c; a -= rol32(c, 11); b ^= a; b -= rol32(a, 25); c ^= b; c -= rol32(b, 16); a ^= c; a -= rol32(c, 4); b ^= a; b -= rol32(a, 14); c ^= b; c -= rol32(b, 24); };
 case 0:
  break;
 }

 return c;
}
# 116 "/home/nathan/src/linux-next/include/linux/jhash.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 jhash2(const u32 *k, u32 length, u32 initval)
{
 u32 a, b, c;


 a = b = c = 0xdeadbeef + (length<<2) + initval;


 while (length > 3) {
  a += k[0];
  b += k[1];
  c += k[2];
  { a -= c; a ^= rol32(c, 4); c += b; b -= a; b ^= rol32(a, 6); a += c; c -= b; c ^= rol32(b, 8); b += a; a -= c; a ^= rol32(c, 16); c += b; b -= a; b ^= rol32(a, 19); a += c; c -= b; c ^= rol32(b, 4); b += a; };
  length -= 3;
  k += 3;
 }


 switch (length) {
 case 3: c += k[2];
 case 2: b += k[1];
 case 1: a += k[0];
  { c ^= b; c -= rol32(b, 14); a ^= c; a -= rol32(c, 11); b ^= a; b -= rol32(a, 25); c ^= b; c -= rol32(b, 16); a ^= c; a -= rol32(c, 4); b ^= a; b -= rol32(a, 14); c ^= b; c -= rol32(b, 24); };
 case 0:
  break;
 }

 return c;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)
{
 a += initval;
 b += initval;
 c += initval;

 { c ^= b; c -= rol32(b, 14); a ^= c; a -= rol32(c, 11); b ^= a; b -= rol32(a, 25); c ^= b; c -= rol32(b, 16); a ^= c; a -= rol32(c, 4); b ^= a; b -= rol32(a, 14); c ^= b; c -= rol32(b, 24); };

 return c;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)
{
 return __jhash_nwords(a, b, c, initval + 0xdeadbeef + (3 << 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 jhash_2words(u32 a, u32 b, u32 initval)
{
 return __jhash_nwords(a, b, 0, initval + 0xdeadbeef + (2 << 2));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 jhash_1word(u32 a, u32 initval)
{
 return __jhash_nwords(a, 0, 0, initval + 0xdeadbeef + (1 << 2));
}
# 24 "/home/nathan/src/linux-next/include/linux/rhashtable.h" 2
# 47 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
struct rhash_lock_head {};
# 76 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
struct bucket_table {
 unsigned int size;
 unsigned int nest;
 u32 hash_rnd;
 struct list_head walkers;
 struct callback_head rcu;

 struct bucket_table *future_tbl;

 struct lockdep_map dep_map;

 struct rhash_lock_head *buckets[] __attribute__((__aligned__((1 << 7))));
};
# 108 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rht_is_a_nulls(const struct rhash_head *ptr)
{
 return ((unsigned long) ptr & 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *rht_obj(const struct rhashtable *ht,
       const struct rhash_head *he)
{
 return (char *)he - ht->p.head_offset;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int rht_bucket_index(const struct bucket_table *tbl,
         unsigned int hash)
{
 return hash & (tbl->size - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int rht_key_get_hash(struct rhashtable *ht,
 const void *key, const struct rhashtable_params params,
 unsigned int hash_rnd)
{
 unsigned int hash;


 if (!__builtin_constant_p(params.key_len))
  hash = ht->p.hashfn(key, ht->key_len, hash_rnd);
 else if (params.key_len) {
  unsigned int key_len = params.key_len;

  if (params.hashfn)
   hash = params.hashfn(key, key_len, hash_rnd);
  else if (key_len & (sizeof(u32) - 1))
   hash = jhash(key, key_len, hash_rnd);
  else
   hash = jhash2(key, key_len / sizeof(u32), hash_rnd);
 } else {
  unsigned int key_len = ht->p.key_len;

  if (params.hashfn)
   hash = params.hashfn(key, key_len, hash_rnd);
  else
   hash = jhash(key, key_len, hash_rnd);
 }

 return hash;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int rht_key_hashfn(
 struct rhashtable *ht, const struct bucket_table *tbl,
 const void *key, const struct rhashtable_params params)
{
 unsigned int hash = rht_key_get_hash(ht, key, params, tbl->hash_rnd);

 return rht_bucket_index(tbl, hash);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int rht_head_hashfn(
 struct rhashtable *ht, const struct bucket_table *tbl,
 const struct rhash_head *he, const struct rhashtable_params params)
{
 const char *ptr = rht_obj(ht, he);

 return __builtin_expect(!!(params.obj_hashfn), 1) ?
        rht_bucket_index(tbl, params.obj_hashfn(ptr, params.key_len ?:
           ht->p.key_len,
             tbl->hash_rnd)) :
        rht_key_hashfn(ht, tbl, ptr + params.key_offset, params);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rht_grow_above_75(const struct rhashtable *ht,
         const struct bucket_table *tbl)
{

 return atomic_read(&ht->nelems) > (tbl->size / 4 * 3) &&
        (!ht->p.max_size || tbl->size < ht->p.max_size);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rht_shrink_below_30(const struct rhashtable *ht,
           const struct bucket_table *tbl)
{

 return atomic_read(&ht->nelems) < (tbl->size * 3 / 10) &&
        tbl->size > ht->p.min_size;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rht_grow_above_100(const struct rhashtable *ht,
          const struct bucket_table *tbl)
{
 return atomic_read(&ht->nelems) > tbl->size &&
  (!ht->p.max_size || tbl->size < ht->p.max_size);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rht_grow_above_max(const struct rhashtable *ht,
          const struct bucket_table *tbl)
{
 return atomic_read(&ht->nelems) >= ht->max_elems;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int lockdep_rht_mutex_is_held(struct rhashtable *ht)
{
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int lockdep_rht_bucket_is_held(const struct bucket_table *tbl,
          u32 hash)
{
 return 1;
}


void *rhashtable_insert_slow(struct rhashtable *ht, const void *key,
        struct rhash_head *obj);

void rhashtable_walk_enter(struct rhashtable *ht,
      struct rhashtable_iter *iter);
void rhashtable_walk_exit(struct rhashtable_iter *iter);
int rhashtable_walk_start_check(struct rhashtable_iter *iter) ;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rhashtable_walk_start(struct rhashtable_iter *iter)
{
 (void)rhashtable_walk_start_check(iter);
}

void *rhashtable_walk_next(struct rhashtable_iter *iter);
void *rhashtable_walk_peek(struct rhashtable_iter *iter);
void rhashtable_walk_stop(struct rhashtable_iter *iter) ;

void rhashtable_free_and_destroy(struct rhashtable *ht,
     void (*free_fn)(void *ptr, void *arg),
     void *arg);
void rhashtable_destroy(struct rhashtable *ht);

struct rhash_lock_head **rht_bucket_nested(const struct bucket_table *tbl,
        unsigned int hash);
struct rhash_lock_head **__rht_bucket_nested(const struct bucket_table *tbl,
          unsigned int hash);
struct rhash_lock_head **rht_bucket_nested_insert(struct rhashtable *ht,
        struct bucket_table *tbl,
        unsigned int hash);
# 287 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_lock_head *const *rht_bucket(
 const struct bucket_table *tbl, unsigned int hash)
{
 return __builtin_expect(!!(tbl->nest), 0) ? rht_bucket_nested(tbl, hash) :
         &tbl->buckets[hash];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_lock_head **rht_bucket_var(
 struct bucket_table *tbl, unsigned int hash)
{
 return __builtin_expect(!!(tbl->nest), 0) ? __rht_bucket_nested(tbl, hash) :
         &tbl->buckets[hash];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_lock_head **rht_bucket_insert(
 struct rhashtable *ht, struct bucket_table *tbl, unsigned int hash)
{
 return __builtin_expect(!!(tbl->nest), 0) ? rht_bucket_nested_insert(ht, tbl, hash) :
         &tbl->buckets[hash];
}
# 327 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rht_lock(struct bucket_table *tbl,
       struct rhash_lock_head **bkt)
{
 local_bh_disable();
 bit_spin_lock(0, (unsigned long *)bkt);
 do { } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rht_lock_nested(struct bucket_table *tbl,
       struct rhash_lock_head **bucket,
       unsigned int subclass)
{
 local_bh_disable();
 bit_spin_lock(0, (unsigned long *)bucket);
 do { } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rht_unlock(struct bucket_table *tbl,
         struct rhash_lock_head **bkt)
{
 do { } while (0);
 bit_spin_unlock(0, (unsigned long *)bkt);
 local_bh_enable();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_head *__rht_ptr(
 struct rhash_lock_head *const *bkt)
{
 return (struct rhash_head *)
  ((unsigned long)*bkt & ~((((1UL))) << (0)) ?:
   (unsigned long)((void *)(1UL | (((long)((unsigned long) (bkt)) >> 1) << 1))));
}
# 367 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_head *rht_ptr_rcu(
 struct rhash_lock_head *const *bkt)
{
 struct rhash_head *p = __rht_ptr(bkt);

 return ({ typeof(*(p)) *________p1 = (typeof(*(p)) *)({ union { typeof((p)) __val; char __c[1]; } __u; if (1) __read_once_size(&((p)), __u.__c, sizeof((p))); else __read_once_size_nocheck(&((p)), __u.__c, sizeof((p))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(p)) *)(________p1)); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_head *rht_ptr(
 struct rhash_lock_head *const *bkt,
 struct bucket_table *tbl,
 unsigned int hash)
{
 return ({ do { } while (0); ; ((typeof(*(__rht_ptr(bkt))) *)((__rht_ptr(bkt)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_head *rht_ptr_exclusive(
 struct rhash_lock_head *const *bkt)
{
 return ({ do { } while (0); ; ((typeof(*(__rht_ptr(bkt))) *)((__rht_ptr(bkt)))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rht_assign_locked(struct rhash_lock_head **bkt,
         struct rhash_head *obj)
{
 struct rhash_head **p = (struct rhash_head **)bkt;

 if (rht_is_a_nulls(obj))
  obj = ((void *)0);
 do { uintptr_t _r_a_p__v = (uintptr_t)((void *)((unsigned long)obj | ((((1UL))) << (0)))); ; if (__builtin_constant_p((void *)((unsigned long)obj | ((((1UL))) << (0)))) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*p)) __val; char __c[1]; } __u = { .__val = ( typeof((*p))) ((typeof(*p))(_r_a_p__v)) }; __write_once_size(&((*p)), __u.__c, sizeof((*p))); __u.__val; }); else do { do { extern void __compiletime_assert_396(void) ; if (!((sizeof(*&*p) == sizeof(char) || sizeof(*&*p) == sizeof(short) || sizeof(*&*p) == sizeof(int) || sizeof(*&*p) == sizeof(long)))) __compiletime_assert_396(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*p) __val; char __c[1]; } __u = { .__val = ( typeof(*&*p)) ((typeof(*((typeof(*p))_r_a_p__v)) *)((typeof(*p))_r_a_p__v)) }; __write_once_size(&(*&*p), __u.__c, sizeof(*&*p)); __u.__val; }); } while (0); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rht_assign_unlock(struct bucket_table *tbl,
         struct rhash_lock_head **bkt,
         struct rhash_head *obj)
{
 struct rhash_head **p = (struct rhash_head **)bkt;

 if (rht_is_a_nulls(obj))
  obj = ((void *)0);
 do { } while (0);
 do { uintptr_t _r_a_p__v = (uintptr_t)(obj); ; if (__builtin_constant_p(obj) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*p)) __val; char __c[1]; } __u = { .__val = ( typeof((*p))) ((typeof(*p))(_r_a_p__v)) }; __write_once_size(&((*p)), __u.__c, sizeof((*p))); __u.__val; }); else do { do { extern void __compiletime_assert_408(void) ; if (!((sizeof(*&*p) == sizeof(char) || sizeof(*&*p) == sizeof(short) || sizeof(*&*p) == sizeof(int) || sizeof(*&*p) == sizeof(long)))) __compiletime_assert_408(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*p) __val; char __c[1]; } __u = { .__val = ( typeof(*&*p)) ((typeof(*((typeof(*p))_r_a_p__v)) *)((typeof(*p))_r_a_p__v)) }; __write_once_size(&(*&*p), __u.__c, sizeof(*&*p)); __u.__val; }); } while (0); } while (0);
 __asm__ __volatile__("" : : : "memory");
 (void)0;
 local_bh_enable();
}
# 578 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_compare(struct rhashtable_compare_arg *arg,
         const void *obj)
{
 struct rhashtable *ht = arg->ht;
 const char *ptr = obj;

 return memcmp(ptr + ht->p.key_offset, arg->key, ht->p.key_len);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhash_head *__rhashtable_lookup(
 struct rhashtable *ht, const void *key,
 const struct rhashtable_params params)
{
 struct rhashtable_compare_arg arg = {
  .ht = ht,
  .key = key,
 };
 struct rhash_lock_head *const *bkt;
 struct bucket_table *tbl;
 struct rhash_head *he;
 unsigned int hash;

 tbl = ({ typeof(*(ht->tbl)) *________p1 = (typeof(*(ht->tbl)) *)({ union { typeof((ht->tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); else __read_once_size_nocheck(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(ht->tbl)) *)(________p1)); });
restart:
 hash = rht_key_hashfn(ht, tbl, key, params);
 bkt = rht_bucket(tbl, hash);
 do {
  for (({__asm__ __volatile__("" : : : "memory"); }), he = rht_ptr_rcu(bkt); !rht_is_a_nulls(he); he = ({ typeof(he->next) ________p1 = ({ union { typeof(he->next) __val; char __c[1]; } __u; if (1) __read_once_size(&(he->next), __u.__c, sizeof(he->next)); else __read_once_size_nocheck(&(he->next), __u.__c, sizeof(he->next)); do { } while (0); __u.__val; }); ((typeof(*he->next) *)(________p1)); })) {
   if (params.obj_cmpfn ?
       params.obj_cmpfn(&arg, rht_obj(ht, he)) :
       rhashtable_compare(&arg, rht_obj(ht, he)))
    continue;
   return he;
  }



 } while (he != ((void *)(1UL | (((long)((unsigned long) (bkt)) >> 1) << 1))));


 __asm__ __volatile__ ("lwsync" " " : : :"memory");

 tbl = ({ typeof(*(tbl->future_tbl)) *________p1 = (typeof(*(tbl->future_tbl)) *)({ union { typeof((tbl->future_tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); else __read_once_size_nocheck(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(tbl->future_tbl)) *)(________p1)); });
 if (__builtin_expect(!!(tbl), 0))
  goto restart;

 return ((void *)0);
}
# 641 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *rhashtable_lookup(
 struct rhashtable *ht, const void *key,
 const struct rhashtable_params params)
{
 struct rhash_head *he = __rhashtable_lookup(ht, key, params);

 return he ? rht_obj(ht, he) : ((void *)0);
}
# 664 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *rhashtable_lookup_fast(
 struct rhashtable *ht, const void *key,
 const struct rhashtable_params params)
{
 void *obj;

 rcu_read_lock();
 obj = rhashtable_lookup(ht, key, params);
 rcu_read_unlock();

 return obj;
}
# 691 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rhlist_head *rhltable_lookup(
 struct rhltable *hlt, const void *key,
 const struct rhashtable_params params)
{
 struct rhash_head *he = __rhashtable_lookup(&hlt->ht, key, params);

 return he ? ({ void *__mptr = (void *)(he); do { extern void __compiletime_assert_697(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(he)), typeof(((struct rhlist_head *)0)->rhead)) && !__builtin_types_compatible_p(typeof(*(he)), typeof(void))))) __compiletime_assert_697(); } while (0); ((struct rhlist_head *)(__mptr - __builtin_offsetof(struct rhlist_head, rhead))); }) : ((void *)0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *__rhashtable_insert_fast(
 struct rhashtable *ht, const void *key, struct rhash_head *obj,
 const struct rhashtable_params params, bool rhlist)
{
 struct rhashtable_compare_arg arg = {
  .ht = ht,
  .key = key,
 };
 struct rhash_lock_head **bkt;
 struct rhash_head **pprev;
 struct bucket_table *tbl;
 struct rhash_head *head;
 unsigned int hash;
 int elasticity;
 void *data;

 rcu_read_lock();

 tbl = ({ typeof(*(ht->tbl)) *________p1 = (typeof(*(ht->tbl)) *)({ union { typeof((ht->tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); else __read_once_size_nocheck(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(ht->tbl)) *)(________p1)); });
 hash = rht_head_hashfn(ht, tbl, obj, params);
 elasticity = 16u;
 bkt = rht_bucket_insert(ht, tbl, hash);
 data = ERR_PTR(-12);
 if (!bkt)
  goto out;
 pprev = ((void *)0);
 rht_lock(tbl, bkt);

 if (__builtin_expect(!!(({ typeof(*(tbl->future_tbl)) *_________p1 = (typeof(*(tbl->future_tbl)) *)({ union { typeof((tbl->future_tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); else __read_once_size_nocheck(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); do { } while (0); __u.__val; }); ; ((typeof(*(tbl->future_tbl)) *)(_________p1)); })), 0)) {
slow_path:
  rht_unlock(tbl, bkt);
  rcu_read_unlock();
  return rhashtable_insert_slow(ht, key, obj);
 }

 for (head = rht_ptr(bkt, tbl, hash); !rht_is_a_nulls(head); head = ({ do { } while (0); ; ((typeof(*((head)->next)) *)(((head)->next))); })) {
  struct rhlist_head *plist;
  struct rhlist_head *list;

  elasticity--;
  if (!key ||
      (params.obj_cmpfn ?
       params.obj_cmpfn(&arg, rht_obj(ht, head)) :
       rhashtable_compare(&arg, rht_obj(ht, head)))) {
   pprev = &head->next;
   continue;
  }

  data = rht_obj(ht, head);

  if (!rhlist)
   goto out_unlock;


  list = ({ void *__mptr = (void *)(obj); do { extern void __compiletime_assert_758(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(obj)), typeof(((struct rhlist_head *)0)->rhead)) && !__builtin_types_compatible_p(typeof(*(obj)), typeof(void))))) __compiletime_assert_758(); } while (0); ((struct rhlist_head *)(__mptr - __builtin_offsetof(struct rhlist_head, rhead))); });
  plist = ({ void *__mptr = (void *)(head); do { extern void __compiletime_assert_759(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head)), typeof(((struct rhlist_head *)0)->rhead)) && !__builtin_types_compatible_p(typeof(*(head)), typeof(void))))) __compiletime_assert_759(); } while (0); ((struct rhlist_head *)(__mptr - __builtin_offsetof(struct rhlist_head, rhead))); });

  do { ; ({ union { typeof(list->next) __val; char __c[1]; } __u = { .__val = ( typeof(list->next)) ((typeof(*(plist)) *)(plist)) }; __write_once_size(&(list->next), __u.__c, sizeof(list->next)); __u.__val; }); } while (0);
  head = ({ do { } while (0); ; ((typeof(*(head->next)) *)((head->next))); });
  do { ; ({ union { typeof(list->rhead.next) __val; char __c[1]; } __u = { .__val = ( typeof(list->rhead.next)) ((typeof(*(head)) *)(head)) }; __write_once_size(&(list->rhead.next), __u.__c, sizeof(list->rhead.next)); __u.__val; }); } while (0);
  if (pprev) {
   do { uintptr_t _r_a_p__v = (uintptr_t)(obj); ; if (__builtin_constant_p(obj) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*pprev)) __val; char __c[1]; } __u = { .__val = ( typeof((*pprev))) ((typeof(*pprev))(_r_a_p__v)) }; __write_once_size(&((*pprev)), __u.__c, sizeof((*pprev))); __u.__val; }); else do { do { extern void __compiletime_assert_765(void) ; if (!((sizeof(*&*pprev) == sizeof(char) || sizeof(*&*pprev) == sizeof(short) || sizeof(*&*pprev) == sizeof(int) || sizeof(*&*pprev) == sizeof(long)))) __compiletime_assert_765(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*&*pprev)) ((typeof(*((typeof(*pprev))_r_a_p__v)) *)((typeof(*pprev))_r_a_p__v)) }; __write_once_size(&(*&*pprev), __u.__c, sizeof(*&*pprev)); __u.__val; }); } while (0); } while (0);
   rht_unlock(tbl, bkt);
  } else
   rht_assign_unlock(tbl, bkt, obj);
  data = ((void *)0);
  goto out;
 }

 if (elasticity <= 0)
  goto slow_path;

 data = ERR_PTR(-7);
 if (__builtin_expect(!!(rht_grow_above_max(ht, tbl)), 0))
  goto out_unlock;

 if (__builtin_expect(!!(rht_grow_above_100(ht, tbl)), 0))
  goto slow_path;


 head = rht_ptr(bkt, tbl, hash);

 do { ; ({ union { typeof(obj->next) __val; char __c[1]; } __u = { .__val = ( typeof(obj->next)) ((typeof(*(head)) *)(head)) }; __write_once_size(&(obj->next), __u.__c, sizeof(obj->next)); __u.__val; }); } while (0);
 if (rhlist) {
  struct rhlist_head *list;

  list = ({ void *__mptr = (void *)(obj); do { extern void __compiletime_assert_790(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(obj)), typeof(((struct rhlist_head *)0)->rhead)) && !__builtin_types_compatible_p(typeof(*(obj)), typeof(void))))) __compiletime_assert_790(); } while (0); ((struct rhlist_head *)(__mptr - __builtin_offsetof(struct rhlist_head, rhead))); });
  do { ; ({ union { typeof(list->next) __val; char __c[1]; } __u = { .__val = ( typeof(list->next)) ((typeof(*(((void *)0))) *)(((void *)0))) }; __write_once_size(&(list->next), __u.__c, sizeof(list->next)); __u.__val; }); } while (0);
 }

 atomic_inc(&ht->nelems);
 rht_assign_unlock(tbl, bkt, obj);

 if (rht_grow_above_75(ht, tbl))
  schedule_work(&ht->run_work);

 data = ((void *)0);
out:
 rcu_read_unlock();

 return data;

out_unlock:
 rht_unlock(tbl, bkt);
 goto out;
}
# 826 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_insert_fast(
 struct rhashtable *ht, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 void *ret;

 ret = __rhashtable_insert_fast(ht, ((void *)0), obj, params, false);
 if (IS_ERR(ret))
  return PTR_ERR(ret);

 return ret == ((void *)0) ? 0 : -17;
}
# 855 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhltable_insert_key(
 struct rhltable *hlt, const void *key, struct rhlist_head *list,
 const struct rhashtable_params params)
{
 return PTR_ERR(__rhashtable_insert_fast(&hlt->ht, key, &list->rhead,
      params, true));
}
# 878 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhltable_insert(
 struct rhltable *hlt, struct rhlist_head *list,
 const struct rhashtable_params params)
{
 const char *key = rht_obj(&hlt->ht, &list->rhead);

 key += params.key_offset;

 return rhltable_insert_key(hlt, key, list, params);
}
# 903 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_lookup_insert_fast(
 struct rhashtable *ht, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 const char *key = rht_obj(ht, obj);
 void *ret;

 do { if (__builtin_constant_p(ht->p.obj_hashfn)) { if (ht->p.obj_hashfn) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (910), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (910), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(ht->p.obj_hashfn))); } } while (0);

 ret = __rhashtable_insert_fast(ht, key + ht->p.key_offset, obj, params,
           false);
 if (IS_ERR(ret))
  return PTR_ERR(ret);

 return ret == ((void *)0) ? 0 : -17;
}
# 930 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *rhashtable_lookup_get_insert_fast(
 struct rhashtable *ht, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 const char *key = rht_obj(ht, obj);

 do { if (__builtin_constant_p(ht->p.obj_hashfn)) { if (ht->p.obj_hashfn) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (936), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (936), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(ht->p.obj_hashfn))); } } while (0);

 return __rhashtable_insert_fast(ht, key + ht->p.key_offset, obj, params,
     false);
}
# 957 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_lookup_insert_key(
 struct rhashtable *ht, const void *key, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 void *ret;

 do { if (__builtin_constant_p(!ht->p.obj_hashfn || !key)) { if (!ht->p.obj_hashfn || !key) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (963), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (963), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!ht->p.obj_hashfn || !key))); } } while (0);

 ret = __rhashtable_insert_fast(ht, key, obj, params, false);
 if (IS_ERR(ret))
  return PTR_ERR(ret);

 return ret == ((void *)0) ? 0 : -17;
}
# 983 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *rhashtable_lookup_get_insert_key(
 struct rhashtable *ht, const void *key, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 do { if (__builtin_constant_p(!ht->p.obj_hashfn || !key)) { if (!ht->p.obj_hashfn || !key) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (987), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/rhashtable.h"), "i" (987), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!ht->p.obj_hashfn || !key))); } } while (0);

 return __rhashtable_insert_fast(ht, key, obj, params, false);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __rhashtable_remove_fast_one(
 struct rhashtable *ht, struct bucket_table *tbl,
 struct rhash_head *obj, const struct rhashtable_params params,
 bool rhlist)
{
 struct rhash_lock_head **bkt;
 struct rhash_head **pprev;
 struct rhash_head *he;
 unsigned int hash;
 int err = -2;

 hash = rht_head_hashfn(ht, tbl, obj, params);
 bkt = rht_bucket_var(tbl, hash);
 if (!bkt)
  return -2;
 pprev = ((void *)0);
 rht_lock(tbl, bkt);

 for (he = rht_ptr(bkt, tbl, hash); !rht_is_a_nulls(he); he = ({ do { } while (0); ; ((typeof(*((he)->next)) *)(((he)->next))); })) {
  struct rhlist_head *list;

  list = ({ void *__mptr = (void *)(he); do { extern void __compiletime_assert_1014(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(he)), typeof(((struct rhlist_head *)0)->rhead)) && !__builtin_types_compatible_p(typeof(*(he)), typeof(void))))) __compiletime_assert_1014(); } while (0); ((struct rhlist_head *)(__mptr - __builtin_offsetof(struct rhlist_head, rhead))); });

  if (he != obj) {
   struct rhlist_head **lpprev;

   pprev = &he->next;

   if (!rhlist)
    continue;

   do {
    lpprev = &list->next;
    list = ({ do { } while (0); ; ((typeof(*(list->next)) *)((list->next))); });

   } while (list && obj != &list->rhead);

   if (!list)
    continue;

   list = ({ do { } while (0); ; ((typeof(*(list->next)) *)((list->next))); });
   do { ; ({ union { typeof(*lpprev) __val; char __c[1]; } __u = { .__val = ( typeof(*lpprev)) ((typeof(*(list)) *)(list)) }; __write_once_size(&(*lpprev), __u.__c, sizeof(*lpprev)); __u.__val; }); } while (0);
   err = 0;
   break;
  }

  obj = ({ do { } while (0); ; ((typeof(*(obj->next)) *)((obj->next))); });
  err = 1;

  if (rhlist) {
   list = ({ do { } while (0); ; ((typeof(*(list->next)) *)((list->next))); });
   if (list) {
    do { ; ({ union { typeof(list->rhead.next) __val; char __c[1]; } __u = { .__val = ( typeof(list->rhead.next)) ((typeof(*(obj)) *)(obj)) }; __write_once_size(&(list->rhead.next), __u.__c, sizeof(list->rhead.next)); __u.__val; }); } while (0);
    obj = &list->rhead;
    err = 0;
   }
  }

  if (pprev) {
   do { uintptr_t _r_a_p__v = (uintptr_t)(obj); ; if (__builtin_constant_p(obj) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*pprev)) __val; char __c[1]; } __u = { .__val = ( typeof((*pprev))) ((typeof(*pprev))(_r_a_p__v)) }; __write_once_size(&((*pprev)), __u.__c, sizeof((*pprev))); __u.__val; }); else do { do { extern void __compiletime_assert_1052(void) ; if (!((sizeof(*&*pprev) == sizeof(char) || sizeof(*&*pprev) == sizeof(short) || sizeof(*&*pprev) == sizeof(int) || sizeof(*&*pprev) == sizeof(long)))) __compiletime_assert_1052(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*&*pprev)) ((typeof(*((typeof(*pprev))_r_a_p__v)) *)((typeof(*pprev))_r_a_p__v)) }; __write_once_size(&(*&*pprev), __u.__c, sizeof(*&*pprev)); __u.__val; }); } while (0); } while (0);
   rht_unlock(tbl, bkt);
  } else {
   rht_assign_unlock(tbl, bkt, obj);
  }
  goto unlocked;
 }

 rht_unlock(tbl, bkt);
unlocked:
 if (err > 0) {
  atomic_dec(&ht->nelems);
  if (__builtin_expect(!!(ht->p.automatic_shrinking && rht_shrink_below_30(ht, tbl)), 0))

   schedule_work(&ht->run_work);
  err = 0;
 }

 return err;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __rhashtable_remove_fast(
 struct rhashtable *ht, struct rhash_head *obj,
 const struct rhashtable_params params, bool rhlist)
{
 struct bucket_table *tbl;
 int err;

 rcu_read_lock();

 tbl = ({ typeof(*(ht->tbl)) *________p1 = (typeof(*(ht->tbl)) *)({ union { typeof((ht->tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); else __read_once_size_nocheck(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(ht->tbl)) *)(________p1)); });






 while ((err = __rhashtable_remove_fast_one(ht, tbl, obj, params,
         rhlist)) &&
        (tbl = ({ typeof(*(tbl->future_tbl)) *________p1 = (typeof(*(tbl->future_tbl)) *)({ union { typeof((tbl->future_tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); else __read_once_size_nocheck(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(tbl->future_tbl)) *)(________p1)); })))
  ;

 rcu_read_unlock();

 return err;
}
# 1115 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_remove_fast(
 struct rhashtable *ht, struct rhash_head *obj,
 const struct rhashtable_params params)
{
 return __rhashtable_remove_fast(ht, obj, params, false);
}
# 1137 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhltable_remove(
 struct rhltable *hlt, struct rhlist_head *list,
 const struct rhashtable_params params)
{
 return __rhashtable_remove_fast(&hlt->ht, &list->rhead, params, true);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __rhashtable_replace_fast(
 struct rhashtable *ht, struct bucket_table *tbl,
 struct rhash_head *obj_old, struct rhash_head *obj_new,
 const struct rhashtable_params params)
{
 struct rhash_lock_head **bkt;
 struct rhash_head **pprev;
 struct rhash_head *he;
 unsigned int hash;
 int err = -2;




 hash = rht_head_hashfn(ht, tbl, obj_old, params);
 if (hash != rht_head_hashfn(ht, tbl, obj_new, params))
  return -22;

 bkt = rht_bucket_var(tbl, hash);
 if (!bkt)
  return -2;

 pprev = ((void *)0);
 rht_lock(tbl, bkt);

 for (he = rht_ptr(bkt, tbl, hash); !rht_is_a_nulls(he); he = ({ do { } while (0); ; ((typeof(*((he)->next)) *)(((he)->next))); })) {
  if (he != obj_old) {
   pprev = &he->next;
   continue;
  }

  do { uintptr_t _r_a_p__v = (uintptr_t)(obj_old->next); ; if (__builtin_constant_p(obj_old->next) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((obj_new->next)) __val; char __c[1]; } __u = { .__val = ( typeof((obj_new->next))) ((typeof(obj_new->next))(_r_a_p__v)) }; __write_once_size(&((obj_new->next)), __u.__c, sizeof((obj_new->next))); __u.__val; }); else do { do { extern void __compiletime_assert_1176(void) ; if (!((sizeof(*&obj_new->next) == sizeof(char) || sizeof(*&obj_new->next) == sizeof(short) || sizeof(*&obj_new->next) == sizeof(int) || sizeof(*&obj_new->next) == sizeof(long)))) __compiletime_assert_1176(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&obj_new->next) __val; char __c[1]; } __u = { .__val = ( typeof(*&obj_new->next)) ((typeof(*((typeof(obj_new->next))_r_a_p__v)) *)((typeof(obj_new->next))_r_a_p__v)) }; __write_once_size(&(*&obj_new->next), __u.__c, sizeof(*&obj_new->next)); __u.__val; }); } while (0); } while (0);
  if (pprev) {
   do { uintptr_t _r_a_p__v = (uintptr_t)(obj_new); ; if (__builtin_constant_p(obj_new) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((*pprev)) __val; char __c[1]; } __u = { .__val = ( typeof((*pprev))) ((typeof(*pprev))(_r_a_p__v)) }; __write_once_size(&((*pprev)), __u.__c, sizeof((*pprev))); __u.__val; }); else do { do { extern void __compiletime_assert_1178(void) ; if (!((sizeof(*&*pprev) == sizeof(char) || sizeof(*&*pprev) == sizeof(short) || sizeof(*&*pprev) == sizeof(int) || sizeof(*&*pprev) == sizeof(long)))) __compiletime_assert_1178(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&*pprev) __val; char __c[1]; } __u = { .__val = ( typeof(*&*pprev)) ((typeof(*((typeof(*pprev))_r_a_p__v)) *)((typeof(*pprev))_r_a_p__v)) }; __write_once_size(&(*&*pprev), __u.__c, sizeof(*&*pprev)); __u.__val; }); } while (0); } while (0);
   rht_unlock(tbl, bkt);
  } else {
   rht_assign_unlock(tbl, bkt, obj_new);
  }
  err = 0;
  goto unlocked;
 }

 rht_unlock(tbl, bkt);

unlocked:
 return err;
}
# 1207 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int rhashtable_replace_fast(
 struct rhashtable *ht, struct rhash_head *obj_old,
 struct rhash_head *obj_new,
 const struct rhashtable_params params)
{
 struct bucket_table *tbl;
 int err;

 rcu_read_lock();

 tbl = ({ typeof(*(ht->tbl)) *________p1 = (typeof(*(ht->tbl)) *)({ union { typeof((ht->tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); else __read_once_size_nocheck(&((ht->tbl)), __u.__c, sizeof((ht->tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(ht->tbl)) *)(________p1)); });






 while ((err = __rhashtable_replace_fast(ht, tbl, obj_old,
      obj_new, params)) &&
        (tbl = ({ typeof(*(tbl->future_tbl)) *________p1 = (typeof(*(tbl->future_tbl)) *)({ union { typeof((tbl->future_tbl)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); else __read_once_size_nocheck(&((tbl->future_tbl)), __u.__c, sizeof((tbl->future_tbl))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(tbl->future_tbl)) *)(________p1)); })))
  ;

 rcu_read_unlock();

 return err;
}
# 1255 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rhltable_walk_enter(struct rhltable *hlt,
           struct rhashtable_iter *iter)
{
 return rhashtable_walk_enter(&hlt->ht, iter);
}
# 1269 "/home/nathan/src/linux-next/include/linux/rhashtable.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rhltable_free_and_destroy(struct rhltable *hlt,
          void (*free_fn)(void *ptr,
            void *arg),
          void *arg)
{
 return rhashtable_free_and_destroy(&hlt->ht, free_fn, arg);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rhltable_destroy(struct rhltable *hlt)
{
 return rhltable_free_and_destroy(hlt, ((void *)0), ((void *)0));
}
# 8 "/home/nathan/src/linux-next/include/net/flow_offload.h" 2

struct flow_match {
 struct flow_dissector *dissector;
 void *mask;
 void *key;
};

struct flow_match_meta {
 struct flow_dissector_key_meta *key, *mask;
};

struct flow_match_basic {
 struct flow_dissector_key_basic *key, *mask;
};

struct flow_match_control {
 struct flow_dissector_key_control *key, *mask;
};

struct flow_match_eth_addrs {
 struct flow_dissector_key_eth_addrs *key, *mask;
};

struct flow_match_vlan {
 struct flow_dissector_key_vlan *key, *mask;
};

struct flow_match_ipv4_addrs {
 struct flow_dissector_key_ipv4_addrs *key, *mask;
};

struct flow_match_ipv6_addrs {
 struct flow_dissector_key_ipv6_addrs *key, *mask;
};

struct flow_match_ip {
 struct flow_dissector_key_ip *key, *mask;
};

struct flow_match_ports {
 struct flow_dissector_key_ports *key, *mask;
};

struct flow_match_icmp {
 struct flow_dissector_key_icmp *key, *mask;
};

struct flow_match_tcp {
 struct flow_dissector_key_tcp *key, *mask;
};

struct flow_match_mpls {
 struct flow_dissector_key_mpls *key, *mask;
};

struct flow_match_enc_keyid {
 struct flow_dissector_key_keyid *key, *mask;
};

struct flow_match_enc_opts {
 struct flow_dissector_key_enc_opts *key, *mask;
};

struct flow_rule;

void flow_rule_match_meta(const struct flow_rule *rule,
     struct flow_match_meta *out);
void flow_rule_match_basic(const struct flow_rule *rule,
      struct flow_match_basic *out);
void flow_rule_match_control(const struct flow_rule *rule,
        struct flow_match_control *out);
void flow_rule_match_eth_addrs(const struct flow_rule *rule,
          struct flow_match_eth_addrs *out);
void flow_rule_match_vlan(const struct flow_rule *rule,
     struct flow_match_vlan *out);
void flow_rule_match_cvlan(const struct flow_rule *rule,
      struct flow_match_vlan *out);
void flow_rule_match_ipv4_addrs(const struct flow_rule *rule,
    struct flow_match_ipv4_addrs *out);
void flow_rule_match_ipv6_addrs(const struct flow_rule *rule,
    struct flow_match_ipv6_addrs *out);
void flow_rule_match_ip(const struct flow_rule *rule,
   struct flow_match_ip *out);
void flow_rule_match_ports(const struct flow_rule *rule,
      struct flow_match_ports *out);
void flow_rule_match_tcp(const struct flow_rule *rule,
    struct flow_match_tcp *out);
void flow_rule_match_icmp(const struct flow_rule *rule,
     struct flow_match_icmp *out);
void flow_rule_match_mpls(const struct flow_rule *rule,
     struct flow_match_mpls *out);
void flow_rule_match_enc_control(const struct flow_rule *rule,
     struct flow_match_control *out);
void flow_rule_match_enc_ipv4_addrs(const struct flow_rule *rule,
        struct flow_match_ipv4_addrs *out);
void flow_rule_match_enc_ipv6_addrs(const struct flow_rule *rule,
        struct flow_match_ipv6_addrs *out);
void flow_rule_match_enc_ip(const struct flow_rule *rule,
       struct flow_match_ip *out);
void flow_rule_match_enc_ports(const struct flow_rule *rule,
          struct flow_match_ports *out);
void flow_rule_match_enc_keyid(const struct flow_rule *rule,
          struct flow_match_enc_keyid *out);
void flow_rule_match_enc_opts(const struct flow_rule *rule,
         struct flow_match_enc_opts *out);

enum flow_action_id {
 FLOW_ACTION_ACCEPT = 0,
 FLOW_ACTION_DROP,
 FLOW_ACTION_TRAP,
 FLOW_ACTION_GOTO,
 FLOW_ACTION_REDIRECT,
 FLOW_ACTION_MIRRED,
 FLOW_ACTION_REDIRECT_INGRESS,
 FLOW_ACTION_MIRRED_INGRESS,
 FLOW_ACTION_VLAN_PUSH,
 FLOW_ACTION_VLAN_POP,
 FLOW_ACTION_VLAN_MANGLE,
 FLOW_ACTION_TUNNEL_ENCAP,
 FLOW_ACTION_TUNNEL_DECAP,
 FLOW_ACTION_MANGLE,
 FLOW_ACTION_ADD,
 FLOW_ACTION_CSUM,
 FLOW_ACTION_MARK,
 FLOW_ACTION_PTYPE,
 FLOW_ACTION_WAKE,
 FLOW_ACTION_QUEUE,
 FLOW_ACTION_SAMPLE,
 FLOW_ACTION_POLICE,
 FLOW_ACTION_CT,
 FLOW_ACTION_MPLS_PUSH,
 FLOW_ACTION_MPLS_POP,
 FLOW_ACTION_MPLS_MANGLE,
 NUM_FLOW_ACTIONS,
};





enum flow_action_mangle_base {
 FLOW_ACT_MANGLE_UNSPEC = 0,
 FLOW_ACT_MANGLE_HDR_TYPE_ETH,
 FLOW_ACT_MANGLE_HDR_TYPE_IP4,
 FLOW_ACT_MANGLE_HDR_TYPE_IP6,
 FLOW_ACT_MANGLE_HDR_TYPE_TCP,
 FLOW_ACT_MANGLE_HDR_TYPE_UDP,
};

typedef void (*action_destr)(void *priv);

struct flow_action_entry {
 enum flow_action_id id;
 action_destr destructor;
 void *destructor_priv;
 union {
  u32 chain_index;
  struct net_device *dev;
  struct {
   u16 vid;
   __be16 proto;
   u8 prio;
  } vlan;
  struct {
   enum flow_action_mangle_base htype;
   u32 offset;
   u32 mask;
   u32 val;
  } mangle;
  struct ip_tunnel_info *tunnel;
  u32 csum_flags;
  u32 mark;
  u16 ptype;
  struct {
   u32 ctx;
   u32 index;
   u8 vf;
  } queue;
  struct {
   struct psample_group *psample_group;
   u32 rate;
   u32 trunc_size;
   bool truncate;
  } sample;
  struct {
   s64 burst;
   u64 rate_bytes_ps;
  } police;
  struct {
   int action;
   u16 zone;
  } ct;
  struct {
   u32 label;
   __be16 proto;
   u8 tc;
   u8 bos;
   u8 ttl;
  } mpls_push;
  struct {
   __be16 proto;
  } mpls_pop;
  struct {
   u32 label;
   u8 tc;
   u8 bos;
   u8 ttl;
  } mpls_mangle;
 };
};

struct flow_action {
 unsigned int num_entries;
 struct flow_action_entry entries[0];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool flow_action_has_entries(const struct flow_action *action)
{
 return action->num_entries;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool flow_offload_has_one_action(const struct flow_action *action)
{
 return action->num_entries == 1;
}




struct flow_rule {
 struct flow_match match;
 struct flow_action action;
};

struct flow_rule *flow_rule_alloc(unsigned int num_actions);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool flow_rule_match_key(const struct flow_rule *rule,
           enum flow_dissector_key_id key)
{
 return dissector_uses_key(rule->match.dissector, key);
}

struct flow_stats {
 u64 pkts;
 u64 bytes;
 u64 lastused;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flow_stats_update(struct flow_stats *flow_stats,
         u64 bytes, u64 pkts, u64 lastused)
{
 flow_stats->pkts += pkts;
 flow_stats->bytes += bytes;
 flow_stats->lastused = __builtin_choose_expr(((!!(sizeof((typeof((u64)(flow_stats->lastused)) *)1 == (typeof((u64)(lastused)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(flow_stats->lastused)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(lastused)) * 0l)) : (int *)8))))), (((u64)(flow_stats->lastused)) > ((u64)(lastused)) ? ((u64)(flow_stats->lastused)) : ((u64)(lastused))), ({ typeof((u64)(flow_stats->lastused)) __UNIQUE_ID___x66 = ((u64)(flow_stats->lastused)); typeof((u64)(lastused)) __UNIQUE_ID___y67 = ((u64)(lastused)); ((__UNIQUE_ID___x66) > (__UNIQUE_ID___y67) ? (__UNIQUE_ID___x66) : (__UNIQUE_ID___y67)); }));
}

enum flow_block_command {
 FLOW_BLOCK_BIND,
 FLOW_BLOCK_UNBIND,
};

enum flow_block_binder_type {
 FLOW_BLOCK_BINDER_TYPE_UNSPEC,
 FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS,
 FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS,
};

struct flow_block {
 struct list_head cb_list;
};

struct netlink_ext_ack;

struct flow_block_offload {
 enum flow_block_command command;
 enum flow_block_binder_type binder_type;
 bool block_shared;
 bool unlocked_driver_cb;
 struct net *net;
 struct flow_block *block;
 struct list_head cb_list;
 struct list_head *driver_block_list;
 struct netlink_ext_ack *extack;
};

enum tc_setup_type;
typedef int flow_setup_cb_t(enum tc_setup_type type, void *type_data,
       void *cb_priv);

struct flow_block_cb {
 struct list_head driver_list;
 struct list_head list;
 flow_setup_cb_t *cb;
 void *cb_ident;
 void *cb_priv;
 void (*release)(void *cb_priv);
 unsigned int refcnt;
};

struct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,
       void *cb_ident, void *cb_priv,
       void (*release)(void *cb_priv));
void flow_block_cb_free(struct flow_block_cb *block_cb);

struct flow_block_cb *flow_block_cb_lookup(struct flow_block *block,
        flow_setup_cb_t *cb, void *cb_ident);

void *flow_block_cb_priv(struct flow_block_cb *block_cb);
void flow_block_cb_incref(struct flow_block_cb *block_cb);
unsigned int flow_block_cb_decref(struct flow_block_cb *block_cb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flow_block_cb_add(struct flow_block_cb *block_cb,
         struct flow_block_offload *offload)
{
 list_add_tail(&block_cb->list, &offload->cb_list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flow_block_cb_remove(struct flow_block_cb *block_cb,
     struct flow_block_offload *offload)
{
 list_move(&block_cb->list, &offload->cb_list);
}

bool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,
      struct list_head *driver_block_list);

int flow_block_cb_setup_simple(struct flow_block_offload *f,
          struct list_head *driver_list,
          flow_setup_cb_t *cb,
          void *cb_ident, void *cb_priv, bool ingress_only);

enum flow_cls_command {
 FLOW_CLS_REPLACE,
 FLOW_CLS_DESTROY,
 FLOW_CLS_STATS,
 FLOW_CLS_TMPLT_CREATE,
 FLOW_CLS_TMPLT_DESTROY,
};

struct flow_cls_common_offload {
 u32 chain_index;
 __be16 protocol;
 u32 prio;
 struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
 struct flow_cls_common_offload common;
 enum flow_cls_command command;
 unsigned long cookie;
 struct flow_rule *rule;
 struct flow_stats stats;
 u32 classid;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct flow_rule *
flow_cls_offload_flow_rule(struct flow_cls_offload *flow_cmd)
{
 return flow_cmd->rule;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void flow_block_init(struct flow_block *flow_block)
{
 INIT_LIST_HEAD(&flow_block->cb_list);
}

typedef int flow_indr_block_bind_cb_t(struct net_device *dev, void *cb_priv,
          enum tc_setup_type type, void *type_data);

typedef void flow_indr_block_cmd_t(struct net_device *dev,
       flow_indr_block_bind_cb_t *cb, void *cb_priv,
       enum flow_block_command command);

struct flow_indr_block_entry {
 flow_indr_block_cmd_t *cb;
 struct list_head list;
};

void flow_indr_add_block_cb(struct flow_indr_block_entry *entry);

void flow_indr_del_block_cb(struct flow_indr_block_entry *entry);

int __flow_indr_block_cb_register(struct net_device *dev, void *cb_priv,
      flow_indr_block_bind_cb_t *cb,
      void *cb_ident);

void __flow_indr_block_cb_unregister(struct net_device *dev,
         flow_indr_block_bind_cb_t *cb,
         void *cb_ident);

int flow_indr_block_cb_register(struct net_device *dev, void *cb_priv,
    flow_indr_block_bind_cb_t *cb, void *cb_ident);

void flow_indr_block_cb_unregister(struct net_device *dev,
       flow_indr_block_bind_cb_t *cb,
       void *cb_ident);

void flow_indr_block_call(struct net_device *dev,
     struct flow_block_offload *bo,
     enum flow_block_command command);
# 22 "/home/nathan/src/linux-next/include/net/sch_generic.h" 2

struct Qdisc_ops;
struct qdisc_walker;
struct tcf_walker;
struct module;
struct bpf_flow_keys;

struct qdisc_rate_table {
 struct tc_ratespec rate;
 u32 data[256];
 struct qdisc_rate_table *next;
 int refcnt;
};

enum qdisc_state_t {
 __QDISC_STATE_SCHED,
 __QDISC_STATE_DEACTIVATED,
};

struct qdisc_size_table {
 struct callback_head rcu;
 struct list_head list;
 struct tc_sizespec szopts;
 int refcnt;
 u16 data[];
};


struct qdisc_skb_head {
 struct sk_buff *head;
 struct sk_buff *tail;
 __u32 qlen;
 spinlock_t lock;
};

struct Qdisc {
 int (*enqueue)(struct sk_buff *skb,
        struct Qdisc *sch,
        struct sk_buff **to_free);
 struct sk_buff * (*dequeue)(struct Qdisc *sch);
 unsigned int flags;
# 82 "/home/nathan/src/linux-next/include/net/sch_generic.h"
 u32 limit;
 const struct Qdisc_ops *ops;
 struct qdisc_size_table *stab;
 struct hlist_node hash;
 u32 handle;
 u32 parent;

 struct netdev_queue *dev_queue;

 struct net_rate_estimator *rate_est;
 struct gnet_stats_basic_cpu *cpu_bstats;
 struct gnet_stats_queue *cpu_qstats;
 int padded;
 refcount_t refcnt;




 struct sk_buff_head gso_skb __attribute__((__aligned__((1 << 7))));
 struct qdisc_skb_head q;
 struct gnet_stats_basic_packed bstats;
 seqcount_t running;
 struct gnet_stats_queue qstats;
 unsigned long state;
 struct Qdisc *next_sched;
 struct sk_buff_head skb_bad_txq;

 spinlock_t busylock __attribute__((__aligned__((1 << 7))));
 spinlock_t seqlock;


 bool empty;
 struct callback_head rcu;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_refcount_inc(struct Qdisc *qdisc)
{
 if (qdisc->flags & 1)
  return;
 refcount_inc(&qdisc->refcnt);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc *qdisc_refcount_inc_nz(struct Qdisc *qdisc)
{
 if (qdisc->flags & 1)
  return qdisc;
 if (refcount_inc_not_zero(&qdisc->refcnt))
  return qdisc;
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_is_running(struct Qdisc *qdisc)
{
 if (qdisc->flags & 0x100)
  return spin_is_locked(&qdisc->seqlock);
 return (raw_read_seqcount(&qdisc->running) & 1) ? true : false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_is_percpu_stats(const struct Qdisc *q)
{
 return q->flags & 0x20;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_is_empty(const struct Qdisc *qdisc)
{
 if (qdisc_is_percpu_stats(qdisc))
  return ({ union { typeof(qdisc->empty) __val; char __c[1]; } __u; if (1) __read_once_size(&(qdisc->empty), __u.__c, sizeof(qdisc->empty)); else __read_once_size_nocheck(&(qdisc->empty), __u.__c, sizeof(qdisc->empty)); do { } while (0); __u.__val; });
 return !({ union { typeof(qdisc->q.qlen) __val; char __c[1]; } __u; if (1) __read_once_size(&(qdisc->q.qlen), __u.__c, sizeof(qdisc->q.qlen)); else __read_once_size_nocheck(&(qdisc->q.qlen), __u.__c, sizeof(qdisc->q.qlen)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_run_begin(struct Qdisc *qdisc)
{
 if (qdisc->flags & 0x100) {
  if (!spin_trylock(&qdisc->seqlock))
   return false;
  ({ union { typeof(qdisc->empty) __val; char __c[1]; } __u = { .__val = ( typeof(qdisc->empty)) (false) }; __write_once_size(&(qdisc->empty), __u.__c, sizeof(qdisc->empty)); __u.__val; });
 } else if (qdisc_is_running(qdisc)) {
  return false;
 }



 raw_write_seqcount_begin(&qdisc->running);
 do { } while (0);
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_run_end(struct Qdisc *qdisc)
{
 write_seqcount_end(&qdisc->running);
 if (qdisc->flags & 0x100)
  spin_unlock(&qdisc->seqlock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_may_bulk(const struct Qdisc *qdisc)
{
 return qdisc->flags & 0x10;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_avail_bulklimit(const struct netdev_queue *txq)
{


 return dql_avail(&txq->dql);



}

struct Qdisc_class_ops {
 unsigned int flags;

 struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
 int (*graft)(struct Qdisc *, unsigned long cl,
     struct Qdisc *, struct Qdisc **,
     struct netlink_ext_ack *extack);
 struct Qdisc * (*leaf)(struct Qdisc *, unsigned long cl);
 void (*qlen_notify)(struct Qdisc *, unsigned long);


 unsigned long (*find)(struct Qdisc *, u32 classid);
 int (*change)(struct Qdisc *, u32, u32,
     struct nlattr **, unsigned long *,
     struct netlink_ext_ack *);
 int (*delete)(struct Qdisc *, unsigned long);
 void (*walk)(struct Qdisc *, struct qdisc_walker * arg);


 struct tcf_block * (*tcf_block)(struct Qdisc *sch,
          unsigned long arg,
          struct netlink_ext_ack *extack);
 unsigned long (*bind_tcf)(struct Qdisc *, unsigned long,
     u32 classid);
 void (*unbind_tcf)(struct Qdisc *, unsigned long);


 int (*dump)(struct Qdisc *, unsigned long,
     struct sk_buff *skb, struct tcmsg*);
 int (*dump_stats)(struct Qdisc *, unsigned long,
     struct gnet_dump *);
};




enum qdisc_class_ops_flags {
 QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

struct Qdisc_ops {
 struct Qdisc_ops *next;
 const struct Qdisc_class_ops *cl_ops;
 char id[16];
 int priv_size;
 unsigned int static_flags;

 int (*enqueue)(struct sk_buff *skb,
        struct Qdisc *sch,
        struct sk_buff **to_free);
 struct sk_buff * (*dequeue)(struct Qdisc *);
 struct sk_buff * (*peek)(struct Qdisc *);

 int (*init)(struct Qdisc *sch, struct nlattr *arg,
     struct netlink_ext_ack *extack);
 void (*reset)(struct Qdisc *);
 void (*destroy)(struct Qdisc *);
 int (*change)(struct Qdisc *sch,
       struct nlattr *arg,
       struct netlink_ext_ack *extack);
 void (*attach)(struct Qdisc *sch);
 int (*change_tx_queue_len)(struct Qdisc *, unsigned int);

 int (*dump)(struct Qdisc *, struct sk_buff *);
 int (*dump_stats)(struct Qdisc *, struct gnet_dump *);

 void (*ingress_block_set)(struct Qdisc *sch,
           u32 block_index);
 void (*egress_block_set)(struct Qdisc *sch,
          u32 block_index);
 u32 (*ingress_block_get)(struct Qdisc *sch);
 u32 (*egress_block_get)(struct Qdisc *sch);

 struct module *owner;
};


struct tcf_result {
 union {
  struct {
   unsigned long class;
   u32 classid;
  };
  const struct tcf_proto *goto_tp;


  struct {
   bool ingress;
   struct gnet_stats_queue *qstats;
  };
 };
};

struct tcf_chain;

struct tcf_proto_ops {
 struct list_head head;
 char kind[16];

 int (*classify)(struct sk_buff *,
         const struct tcf_proto *,
         struct tcf_result *);
 int (*init)(struct tcf_proto*);
 void (*destroy)(struct tcf_proto *tp, bool rtnl_held,
        struct netlink_ext_ack *extack);

 void* (*get)(struct tcf_proto*, u32 handle);
 void (*put)(struct tcf_proto *tp, void *f);
 int (*change)(struct net *net, struct sk_buff *,
     struct tcf_proto*, unsigned long,
     u32 handle, struct nlattr **,
     void **, bool, bool,
     struct netlink_ext_ack *);
 int (*delete)(struct tcf_proto *tp, void *arg,
       bool *last, bool rtnl_held,
       struct netlink_ext_ack *);
 bool (*delete_empty)(struct tcf_proto *tp);
 void (*walk)(struct tcf_proto *tp,
     struct tcf_walker *arg, bool rtnl_held);
 int (*reoffload)(struct tcf_proto *tp, bool add,
          flow_setup_cb_t *cb, void *cb_priv,
          struct netlink_ext_ack *extack);
 void (*hw_add)(struct tcf_proto *tp,
       void *type_data);
 void (*hw_del)(struct tcf_proto *tp,
       void *type_data);
 void (*bind_class)(void *, u32, unsigned long,
           void *, unsigned long);
 void * (*tmplt_create)(struct net *net,
      struct tcf_chain *chain,
      struct nlattr **tca,
      struct netlink_ext_ack *extack);
 void (*tmplt_destroy)(void *tmplt_priv);


 int (*dump)(struct net*, struct tcf_proto*, void *,
     struct sk_buff *skb, struct tcmsg*,
     bool);
 int (*tmplt_dump)(struct sk_buff *skb,
           struct net *net,
           void *tmplt_priv);

 struct module *owner;
 int flags;
};





enum tcf_proto_ops_flags {
 TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

struct tcf_proto {

 struct tcf_proto *next;
 void *root;


 int (*classify)(struct sk_buff *,
         const struct tcf_proto *,
         struct tcf_result *);
 __be16 protocol;


 u32 prio;
 void *data;
 const struct tcf_proto_ops *ops;
 struct tcf_chain *chain;



 spinlock_t lock;
 bool deleting;
 refcount_t refcnt;
 struct callback_head rcu;
 struct hlist_node destroy_ht_node;
};

struct qdisc_skb_cb {
 struct {
  unsigned int pkt_len;
  u16 slave_dev_queue_mapping;
  u16 tc_classid;
 };

 unsigned char data[20];
};

typedef void tcf_chain_head_change_t(struct tcf_proto *tp_head, void *priv);

struct tcf_chain {

 struct mutex filter_chain_lock;
 struct tcf_proto *filter_chain;
 struct list_head list;
 struct tcf_block *block;
 u32 index;
 unsigned int refcnt;
 unsigned int action_refcnt;
 bool explicitly_created;
 bool flushing;
 const struct tcf_proto_ops *tmplt_ops;
 void *tmplt_priv;
 struct callback_head rcu;
};

struct tcf_block {



 struct mutex lock;
 struct list_head chain_list;
 u32 index;
 refcount_t refcnt;
 struct net *net;
 struct Qdisc *q;
 struct rw_semaphore cb_lock;
 struct flow_block flow_block;
 struct list_head owner_list;
 bool keep_dst;
 atomic_t offloadcnt;
 unsigned int nooffloaddevcnt;
 unsigned int lockeddevcnt;
 struct {
  struct tcf_chain *chain;
  struct list_head filter_chain_list;
 } chain0;
 struct callback_head rcu;
 struct hlist_head proto_destroy_ht[1 << (7)];
 struct mutex proto_destroy_lock;
};
# 440 "/home/nathan/src/linux-next/include/net/sch_generic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lockdep_tcf_chain_is_locked(struct tcf_block *chain)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool lockdep_tcf_proto_is_locked(struct tcf_proto *tp)
{
 return true;
}
# 457 "/home/nathan/src/linux-next/include/net/sch_generic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_cb_private_validate(const struct sk_buff *skb, int sz)
{
 struct qdisc_skb_cb *qcb;

 do { extern void __compiletime_assert_461(void) ; if (!(!(sizeof(skb->cb) < __builtin_offsetof(struct qdisc_skb_cb, data) + sz))) __compiletime_assert_461(); } while (0);
 do { extern void __compiletime_assert_462(void) ; if (!(!(sizeof(qcb->data) < sz))) __compiletime_assert_462(); } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_qlen_cpu(const struct Qdisc *q)
{
 return ({ do { const void *__vpp_verify = (typeof((q->cpu_qstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(q->cpu_qstats)) *)(q->cpu_qstats)); (typeof((typeof(*(q->cpu_qstats)) *)(q->cpu_qstats))) (__ptr + ((local_paca->data_offset))); }); })->qlen;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_qlen(const struct Qdisc *q)
{
 return q->q.qlen;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_qlen_sum(const struct Qdisc *q)
{
 __u32 qlen = q->qstats.qlen;
 int i;

 if (qdisc_is_percpu_stats(q)) {
  for (((i)) = -1; ((i)) = cpumask_next(((i)), (((const struct cpumask *)&__cpu_possible_mask))), ((i)) < nr_cpu_ids;)
   qlen += ({ do { const void *__vpp_verify = (typeof((q->cpu_qstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((q->cpu_qstats))) *)((q->cpu_qstats))); (typeof((typeof(*((q->cpu_qstats))) *)((q->cpu_qstats)))) (__ptr + (((__per_cpu_offset[(i)])))); }); })->qlen;
 } else {
  qlen += q->q.qlen;
 }

 return qlen;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct qdisc_skb_cb *qdisc_skb_cb(const struct sk_buff *skb)
{
 return (struct qdisc_skb_cb *)skb->cb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *qdisc_lock(struct Qdisc *qdisc)
{
 return &qdisc->q.lock;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc *qdisc_root(const struct Qdisc *qdisc)
{
 struct Qdisc *q = ({ typeof(*(qdisc->dev_queue->qdisc)) *________p1 = (typeof(*(qdisc->dev_queue->qdisc)) *)({ union { typeof((qdisc->dev_queue->qdisc)) __val; char __c[1]; } __u; if (1) __read_once_size(&((qdisc->dev_queue->qdisc)), __u.__c, sizeof((qdisc->dev_queue->qdisc))); else __read_once_size_nocheck(&((qdisc->dev_queue->qdisc)), __u.__c, sizeof((qdisc->dev_queue->qdisc))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(qdisc->dev_queue->qdisc)) *)(________p1)); });

 return q;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc *qdisc_root_bh(const struct Qdisc *qdisc)
{
 return ({ typeof(*(qdisc->dev_queue->qdisc)) *________p1 = (typeof(*(qdisc->dev_queue->qdisc)) *)({ union { typeof((qdisc->dev_queue->qdisc)) __val; char __c[1]; } __u; if (1) __read_once_size(&((qdisc->dev_queue->qdisc)), __u.__c, sizeof((qdisc->dev_queue->qdisc))); else __read_once_size_nocheck(&((qdisc->dev_queue->qdisc)), __u.__c, sizeof((qdisc->dev_queue->qdisc))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(qdisc->dev_queue->qdisc)) *)(________p1)); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc *qdisc_root_sleeping(const struct Qdisc *qdisc)
{
 return qdisc->dev_queue->qdisc_sleeping;
}
# 528 "/home/nathan/src/linux-next/include/net/sch_generic.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *qdisc_root_lock(const struct Qdisc *qdisc)
{
 struct Qdisc *root = qdisc_root(qdisc);

 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/net/sch_generic.h", 532); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sch_generic.h"), "i" (532), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return qdisc_lock(root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *qdisc_root_sleeping_lock(const struct Qdisc *qdisc)
{
 struct Qdisc *root = qdisc_root_sleeping(qdisc);

 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/net/sch_generic.h", 540); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sch_generic.h"), "i" (540), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return qdisc_lock(root);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) seqcount_t *qdisc_root_sleeping_running(const struct Qdisc *qdisc)
{
 struct Qdisc *root = qdisc_root_sleeping(qdisc);

 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/net/sch_generic.h", 548); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sch_generic.h"), "i" (548), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 return &root->running;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net_device *qdisc_dev(const struct Qdisc *qdisc)
{
 return qdisc->dev_queue->dev;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sch_tree_lock(const struct Qdisc *q)
{
 spin_lock_bh(qdisc_root_sleeping_lock(q));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sch_tree_unlock(const struct Qdisc *q)
{
 spin_unlock_bh(qdisc_root_sleeping_lock(q));
}

extern struct Qdisc noop_qdisc;
extern struct Qdisc_ops noop_qdisc_ops;
extern struct Qdisc_ops pfifo_fast_ops;
extern struct Qdisc_ops mq_qdisc_ops;
extern struct Qdisc_ops noqueue_qdisc_ops;
extern const struct Qdisc_ops *default_qdisc_ops;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct Qdisc_ops *
get_default_qdisc_ops(const struct net_device *dev, int ntx)
{
 return ntx < dev->real_num_tx_queues ?
   default_qdisc_ops : &pfifo_fast_ops;
}

struct Qdisc_class_common {
 u32 classid;
 struct hlist_node hnode;
};

struct Qdisc_class_hash {
 struct hlist_head *hash;
 unsigned int hashsize;
 unsigned int hashmask;
 unsigned int hashelems;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int qdisc_class_hash(u32 id, u32 mask)
{
 id ^= id >> 8;
 id ^= id >> 4;
 return id & mask;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc_class_common *
qdisc_class_find(const struct Qdisc_class_hash *hash, u32 id)
{
 struct Qdisc_class_common *cl;
 unsigned int h;

 if (!id)
  return ((void *)0);

 h = qdisc_class_hash(id, hash->hashmask);
 for (cl = ({ typeof((&hash->hash[h])->first) ____ptr = ((&hash->hash[h])->first); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_609(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((typeof(*(cl)) *)0)->hnode)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_609(); } while (0); ((typeof(*(cl)) *)(__mptr - __builtin_offsetof(typeof(*(cl)), hnode))); }) : ((void *)0); }); cl; cl = ({ typeof((cl)->hnode.next) ____ptr = ((cl)->hnode.next); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_609(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((typeof(*(cl)) *)0)->hnode)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_609(); } while (0); ((typeof(*(cl)) *)(__mptr - __builtin_offsetof(typeof(*(cl)), hnode))); }) : ((void *)0); })) {
  if (cl->classid == id)
   return cl;
 }
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tc_classid_to_hwtc(struct net_device *dev, u32 classid)
{
 u32 hwtc = ((classid)&(0x0000FFFFU)) - 0xFFE0U;

 return (hwtc < netdev_get_num_tc(dev)) ? hwtc : -22;
}

int qdisc_class_hash_init(struct Qdisc_class_hash *);
void qdisc_class_hash_insert(struct Qdisc_class_hash *,
        struct Qdisc_class_common *);
void qdisc_class_hash_remove(struct Qdisc_class_hash *,
        struct Qdisc_class_common *);
void qdisc_class_hash_grow(struct Qdisc *, struct Qdisc_class_hash *);
void qdisc_class_hash_destroy(struct Qdisc_class_hash *);

int dev_qdisc_change_tx_queue_len(struct net_device *dev);
void dev_init_scheduler(struct net_device *dev);
void dev_shutdown(struct net_device *dev);
void dev_activate(struct net_device *dev);
void dev_deactivate(struct net_device *dev);
void dev_deactivate_many(struct list_head *head);
struct Qdisc *dev_graft_qdisc(struct netdev_queue *dev_queue,
         struct Qdisc *qdisc);
void qdisc_reset(struct Qdisc *qdisc);
void qdisc_put(struct Qdisc *qdisc);
void qdisc_put_unlocked(struct Qdisc *qdisc);
void qdisc_tree_reduce_backlog(struct Qdisc *qdisc, int n, int len);

int qdisc_offload_dump_helper(struct Qdisc *q, enum tc_setup_type type,
         void *type_data);
void qdisc_offload_graft_helper(struct net_device *dev, struct Qdisc *sch,
    struct Qdisc *new, struct Qdisc *old,
    enum tc_setup_type type, void *type_data,
    struct netlink_ext_ack *extack);
# 667 "/home/nathan/src/linux-next/include/net/sch_generic.h"
struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
     const struct Qdisc_ops *ops,
     struct netlink_ext_ack *extack);
void qdisc_free(struct Qdisc *qdisc);
struct Qdisc *qdisc_create_dflt(struct netdev_queue *dev_queue,
    const struct Qdisc_ops *ops, u32 parentid,
    struct netlink_ext_ack *extack);
void __qdisc_calculate_pkt_len(struct sk_buff *skb,
          const struct qdisc_size_table *stab);
int skb_do_redirect(struct sk_buff *);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_reset_tc(struct sk_buff *skb)
{

 skb->tc_redirected = 0;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_tc_redirected(const struct sk_buff *skb)
{

 return skb->tc_redirected;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_at_tc_ingress(const struct sk_buff *skb)
{

 return skb->tc_at_ingress;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_skip_tc_classify(struct sk_buff *skb)
{

 if (skb->tc_skip_classify) {
  skb->tc_skip_classify = 0;
  return true;
 }

 return false;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_reset_all_tx_gt(struct net_device *dev, unsigned int i)
{
 struct Qdisc *qdisc;

 for (; i < dev->num_tx_queues; i++) {
  qdisc = ({ do { } while (0); ; ((typeof(*(netdev_get_tx_queue(dev, i)->qdisc)) *)((netdev_get_tx_queue(dev, i)->qdisc))); });
  if (qdisc) {
   spin_lock_bh(qdisc_lock(qdisc));
   qdisc_reset(qdisc);
   spin_unlock_bh(qdisc_lock(qdisc));
  }
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_reset_all_tx(struct net_device *dev)
{
 qdisc_reset_all_tx_gt(dev, 0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_all_tx_empty(const struct net_device *dev)
{
 unsigned int i;

 rcu_read_lock();
 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
  const struct Qdisc *q = ({ typeof(*(txq->qdisc)) *________p1 = (typeof(*(txq->qdisc)) *)({ union { typeof((txq->qdisc)) __val; char __c[1]; } __u; if (1) __read_once_size(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); else __read_once_size_nocheck(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(txq->qdisc)) *)(________p1)); });

  if (!qdisc_is_empty(q)) {
   rcu_read_unlock();
   return false;
  }
 }
 rcu_read_unlock();
 return true;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_tx_changing(const struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
  if (({ typeof(*(txq->qdisc)) *_________p1 = (typeof(*(txq->qdisc)) *)({ union { typeof((txq->qdisc)) __val; char __c[1]; } __u; if (1) __read_once_size(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); else __read_once_size_nocheck(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); do { } while (0); __u.__val; }); ; ((typeof(*(txq->qdisc)) *)(_________p1)); }) != txq->qdisc_sleeping)
   return true;
 }
 return false;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool qdisc_tx_is_noop(const struct net_device *dev)
{
 unsigned int i;

 for (i = 0; i < dev->num_tx_queues; i++) {
  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
  if (({ typeof(*(txq->qdisc)) *_________p1 = (typeof(*(txq->qdisc)) *)({ union { typeof((txq->qdisc)) __val; char __c[1]; } __u; if (1) __read_once_size(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); else __read_once_size_nocheck(&((txq->qdisc)), __u.__c, sizeof((txq->qdisc))); do { } while (0); __u.__val; }); ; ((typeof(*(txq->qdisc)) *)(_________p1)); }) != &noop_qdisc)
   return false;
 }
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int qdisc_pkt_len(const struct sk_buff *skb)
{
 return qdisc_skb_cb(skb)->pkt_len;
}


enum net_xmit_qdisc_t {
 __NET_XMIT_STOLEN = 0x00010000,
 __NET_XMIT_BYPASS = 0x00020000,
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_calculate_pkt_len(struct sk_buff *skb,
        const struct Qdisc *sch)
{

 struct qdisc_size_table *stab = ({ typeof(*(sch->stab)) *________p1 = (typeof(*(sch->stab)) *)({ union { typeof((sch->stab)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sch->stab)), __u.__c, sizeof((sch->stab))); else __read_once_size_nocheck(&((sch->stab)), __u.__c, sizeof((sch->stab))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sch->stab)) *)(________p1)); });

 if (stab)
  __qdisc_calculate_pkt_len(skb, stab);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
    struct sk_buff **to_free)
{
 qdisc_calculate_pkt_len(skb, sch);
 return sch->enqueue(skb, sch, to_free);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void _bstats_update(struct gnet_stats_basic_packed *bstats,
      __u64 bytes, __u32 packets)
{
 bstats->bytes += bytes;
 bstats->packets += packets;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bstats_update(struct gnet_stats_basic_packed *bstats,
     const struct sk_buff *skb)
{
 _bstats_update(bstats,
         qdisc_pkt_len(skb),
         skb_is_gso(skb) ? ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs : 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void _bstats_cpu_update(struct gnet_stats_basic_cpu *bstats,
          __u64 bytes, __u32 packets)
{
 u64_stats_update_begin(&bstats->syncp);
 _bstats_update(&bstats->bstats, bytes, packets);
 u64_stats_update_end(&bstats->syncp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bstats_cpu_update(struct gnet_stats_basic_cpu *bstats,
         const struct sk_buff *skb)
{
 u64_stats_update_begin(&bstats->syncp);
 bstats_update(&bstats->bstats, skb);
 u64_stats_update_end(&bstats->syncp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_bstats_cpu_update(struct Qdisc *sch,
        const struct sk_buff *skb)
{
 bstats_cpu_update(({ do { const void *__vpp_verify = (typeof((sch->cpu_bstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(sch->cpu_bstats)) *)(sch->cpu_bstats)); (typeof((typeof(*(sch->cpu_bstats)) *)(sch->cpu_bstats))) (__ptr + ((local_paca->data_offset))); }); }), skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_bstats_update(struct Qdisc *sch,
           const struct sk_buff *skb)
{
 bstats_update(&sch->bstats, skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_backlog_dec(struct Qdisc *sch,
         const struct sk_buff *skb)
{
 sch->qstats.backlog -= qdisc_pkt_len(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_backlog_dec(struct Qdisc *sch,
      const struct sk_buff *skb)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->backlog)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->backlog))(qdisc_pkt_len(skb)); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->backlog))(qdisc_pkt_len(skb)); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->backlog))(qdisc_pkt_len(skb)); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->backlog))(qdisc_pkt_len(skb)); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_backlog_inc(struct Qdisc *sch,
         const struct sk_buff *skb)
{
 sch->qstats.backlog += qdisc_pkt_len(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_backlog_inc(struct Qdisc *sch,
      const struct sk_buff *skb)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->backlog)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += qdisc_pkt_len(skb); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += qdisc_pkt_len(skb); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += qdisc_pkt_len(skb); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += qdisc_pkt_len(skb); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_qlen_inc(struct Qdisc *sch)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->qlen)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_qlen_dec(struct Qdisc *sch)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->qlen)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->qlen))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->qlen))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->qlen))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->qlen)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen))); (typeof((typeof(*(&(sch->cpu_qstats->qlen))) *)(&(sch->cpu_qstats->qlen)))) (__ptr + ((local_paca->data_offset))); }); }) += -(typeof(sch->cpu_qstats->qlen))(1); } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_requeues_inc(struct Qdisc *sch)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->requeues)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->requeues)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->requeues)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues))); (typeof((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->requeues)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues))); (typeof((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->requeues)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues))); (typeof((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->requeues)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues))); (typeof((typeof(*(&(sch->cpu_qstats->requeues))) *)(&(sch->cpu_qstats->requeues)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_qstats_drop(struct Qdisc *sch, int count)
{
 sch->qstats.drops += count;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qstats_drop_inc(struct gnet_stats_queue *qstats)
{
 qstats->drops++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qstats_overlimit_inc(struct gnet_stats_queue *qstats)
{
 qstats->overlimits++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_drop(struct Qdisc *sch)
{
 qstats_drop_inc(&sch->qstats);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_cpu_drop(struct Qdisc *sch)
{
 do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->drops)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops))); (typeof((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops))); (typeof((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops))); (typeof((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops))); (typeof((typeof(*(&(sch->cpu_qstats->drops))) *)(&(sch->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_overlimit(struct Qdisc *sch)
{
 sch->qstats.overlimits++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_qstats_copy(struct gnet_dump *d, struct Qdisc *sch)
{
 __u32 qlen = qdisc_qlen_sum(sch);

 return gnet_stats_copy_queue(d, sch->cpu_qstats, &sch->qstats, qlen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_qstats_qlen_backlog(struct Qdisc *sch, __u32 *qlen,
          __u32 *backlog)
{
 struct gnet_stats_queue qstats = { 0 };
 __u32 len = qdisc_qlen_sum(sch);

 __gnet_stats_copy_queue(&qstats, sch->cpu_qstats, &sch->qstats, len);
 *qlen = qstats.qlen;
 *backlog = qstats.backlog;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_tree_flush_backlog(struct Qdisc *sch)
{
 __u32 qlen, backlog;

 qdisc_qstats_qlen_backlog(sch, &qlen, &backlog);
 qdisc_tree_reduce_backlog(sch, qlen, backlog);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_purge_queue(struct Qdisc *sch)
{
 __u32 qlen, backlog;

 qdisc_qstats_qlen_backlog(sch, &qlen, &backlog);
 qdisc_reset(sch);
 qdisc_tree_reduce_backlog(sch, qlen, backlog);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_skb_head_init(struct qdisc_skb_head *qh)
{
 qh->head = ((void *)0);
 qh->tail = ((void *)0);
 qh->qlen = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_enqueue_tail(struct sk_buff *skb,
     struct qdisc_skb_head *qh)
{
 struct sk_buff *last = qh->tail;

 if (last) {
  skb->next = ((void *)0);
  last->next = skb;
  qh->tail = skb;
 } else {
  qh->tail = skb;
  qh->head = skb;
 }
 qh->qlen++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_enqueue_tail(struct sk_buff *skb, struct Qdisc *sch)
{
 __qdisc_enqueue_tail(skb, &sch->q);
 qdisc_qstats_backlog_inc(sch, skb);
 return 0x00;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_enqueue_head(struct sk_buff *skb,
     struct qdisc_skb_head *qh)
{
 skb->next = qh->head;

 if (!qh->head)
  qh->tail = skb;
 qh->head = skb;
 qh->qlen++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *__qdisc_dequeue_head(struct qdisc_skb_head *qh)
{
 struct sk_buff *skb = qh->head;

 if (__builtin_expect(!!(skb != ((void *)0)), 1)) {
  qh->head = skb->next;
  qh->qlen--;
  if (qh->head == ((void *)0))
   qh->tail = ((void *)0);
  skb->next = ((void *)0);
 }

 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *qdisc_dequeue_head(struct Qdisc *sch)
{
 struct sk_buff *skb = __qdisc_dequeue_head(&sch->q);

 if (__builtin_expect(!!(skb != ((void *)0)), 1)) {
  qdisc_qstats_backlog_dec(sch, skb);
  qdisc_bstats_update(sch, skb);
 }

 return skb;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_drop(struct sk_buff *skb, struct sk_buff **to_free)
{
 skb->next = *to_free;
 *to_free = skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_drop_all(struct sk_buff *skb,
        struct sk_buff **to_free)
{
 if (skb->prev)
  skb->prev->next = *to_free;
 else
  skb->next = *to_free;
 *to_free = skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __qdisc_queue_drop_head(struct Qdisc *sch,
         struct qdisc_skb_head *qh,
         struct sk_buff **to_free)
{
 struct sk_buff *skb = __qdisc_dequeue_head(qh);

 if (__builtin_expect(!!(skb != ((void *)0)), 1)) {
  unsigned int len = qdisc_pkt_len(skb);

  qdisc_qstats_backlog_dec(sch, skb);
  __qdisc_drop(skb, to_free);
  return len;
 }

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int qdisc_queue_drop_head(struct Qdisc *sch,
       struct sk_buff **to_free)
{
 return __qdisc_queue_drop_head(sch, &sch->q, to_free);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *qdisc_peek_head(struct Qdisc *sch)
{
 const struct qdisc_skb_head *qh = &sch->q;

 return qh->head;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *qdisc_peek_dequeued(struct Qdisc *sch)
{
 struct sk_buff *skb = skb_peek(&sch->gso_skb);


 if (!skb) {
  skb = sch->dequeue(sch);

  if (skb) {
   __skb_queue_head(&sch->gso_skb, skb);

   qdisc_qstats_backlog_inc(sch, skb);
   sch->q.qlen++;
  }
 }

 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_update_stats_at_dequeue(struct Qdisc *sch,
       struct sk_buff *skb)
{
 if (qdisc_is_percpu_stats(sch)) {
  qdisc_qstats_cpu_backlog_dec(sch, skb);
  qdisc_bstats_cpu_update(sch, skb);
  qdisc_qstats_cpu_qlen_dec(sch);
 } else {
  qdisc_qstats_backlog_dec(sch, skb);
  qdisc_bstats_update(sch, skb);
  sch->q.qlen--;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_update_stats_at_enqueue(struct Qdisc *sch,
       unsigned int pkt_len)
{
 if (qdisc_is_percpu_stats(sch)) {
  qdisc_qstats_cpu_qlen_inc(sch);
  do { do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(sch->cpu_qstats->backlog)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += pkt_len; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += pkt_len; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += pkt_len; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(sch->cpu_qstats->backlog)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog))); (typeof((typeof(*(&(sch->cpu_qstats->backlog))) *)(&(sch->cpu_qstats->backlog)))) (__ptr + ((local_paca->data_offset))); }); }) += pkt_len; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 } else {
  sch->qstats.backlog += pkt_len;
  sch->q.qlen++;
 }
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *qdisc_dequeue_peeked(struct Qdisc *sch)
{
 struct sk_buff *skb = skb_peek(&sch->gso_skb);

 if (skb) {
  skb = __skb_dequeue(&sch->gso_skb);
  if (qdisc_is_percpu_stats(sch)) {
   qdisc_qstats_cpu_backlog_dec(sch, skb);
   qdisc_qstats_cpu_qlen_dec(sch);
  } else {
   qdisc_qstats_backlog_dec(sch, skb);
   sch->q.qlen--;
  }
 } else {
  skb = sch->dequeue(sch);
 }

 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __qdisc_reset_queue(struct qdisc_skb_head *qh)
{




 ({ static bool __attribute__((__section__(".data.once"))) __warned; int __ret_warn_once = !!(!rtnl_is_locked()); if (__builtin_expect(!!(__ret_warn_once && !__warned), 0)) { __warned = true; ({ int __ret_warn_on = !!(1); if (__builtin_expect(!!(__ret_warn_on), 0)) do { __warn_printk("RTNL: assertion failed at %s (%d)\n", "include/net/sch_generic.h", 1151); __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sch_generic.h"), "i" (1151), "i" ((1 << 0) | ((1 << 3) | ((9) << 8))), "i" (sizeof(struct bug_entry))); } while (0); __builtin_expect(!!(__ret_warn_on), 0); }); } __builtin_expect(!!(__ret_warn_once), 0); });
 if (qh->qlen) {
  rtnl_kfree_skbs(qh->head, qh->tail);

  qh->head = ((void *)0);
  qh->tail = ((void *)0);
  qh->qlen = 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void qdisc_reset_queue(struct Qdisc *sch)
{
 __qdisc_reset_queue(&sch->q);
 sch->qstats.backlog = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct Qdisc *qdisc_replace(struct Qdisc *sch, struct Qdisc *new,
       struct Qdisc **pold)
{
 struct Qdisc *old;

 sch_tree_lock(sch);
 old = *pold;
 *pold = new;
 if (old != ((void *)0))
  qdisc_tree_flush_backlog(old);
 sch_tree_unlock(sch);

 return old;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void rtnl_qdisc_drop(struct sk_buff *skb, struct Qdisc *sch)
{
 rtnl_kfree_skbs(skb, skb);
 qdisc_qstats_drop(sch);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_drop_cpu(struct sk_buff *skb, struct Qdisc *sch,
     struct sk_buff **to_free)
{
 __qdisc_drop(skb, to_free);
 qdisc_qstats_cpu_drop(sch);

 return 0x01;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_drop(struct sk_buff *skb, struct Qdisc *sch,
        struct sk_buff **to_free)
{
 __qdisc_drop(skb, to_free);
 qdisc_qstats_drop(sch);

 return 0x01;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int qdisc_drop_all(struct sk_buff *skb, struct Qdisc *sch,
     struct sk_buff **to_free)
{
 __qdisc_drop_all(skb, to_free);
 qdisc_qstats_drop(sch);

 return 0x01;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 qdisc_l2t(struct qdisc_rate_table* rtab, unsigned int pktlen)
{
 int slot = pktlen + rtab->rate.cell_align + rtab->rate.overhead;
 if (slot < 0)
  slot = 0;
 slot >>= rtab->rate.cell_log;
 if (slot > 255)
  return rtab->data[255]*(slot >> 8) + rtab->data[slot & 0xFF];
 return rtab->data[slot];
}

struct psched_ratecfg {
 u64 rate_bytes_ps;
 u32 mult;
 u16 overhead;
 u8 linklayer;
 u8 shift;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 psched_l2t_ns(const struct psched_ratecfg *r,
    unsigned int len)
{
 len += r->overhead;

 if (__builtin_expect(!!(r->linklayer == TC_LINKLAYER_ATM), 0))
  return ((u64)((((len) + (48) - 1) / (48))*53) * r->mult) >> r->shift;

 return ((u64)len * r->mult) >> r->shift;
}

void psched_ratecfg_precompute(struct psched_ratecfg *r,
          const struct tc_ratespec *conf,
          u64 rate64);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void psched_ratecfg_getrate(struct tc_ratespec *res,
       const struct psched_ratecfg *r)
{
 memset(res, 0, sizeof(*res));





 res->rate = __builtin_choose_expr(((!!(sizeof((typeof((u64)(r->rate_bytes_ps)) *)1 == (typeof((u64)(~0U)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(r->rate_bytes_ps)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(~0U)) * 0l)) : (int *)8))))), (((u64)(r->rate_bytes_ps)) < ((u64)(~0U)) ? ((u64)(r->rate_bytes_ps)) : ((u64)(~0U))), ({ typeof((u64)(r->rate_bytes_ps)) __UNIQUE_ID___x68 = ((u64)(r->rate_bytes_ps)); typeof((u64)(~0U)) __UNIQUE_ID___y69 = ((u64)(~0U)); ((__UNIQUE_ID___x68) < (__UNIQUE_ID___y69) ? (__UNIQUE_ID___x68) : (__UNIQUE_ID___y69)); }));

 res->overhead = r->overhead;
 res->linklayer = (r->linklayer & 0x0F);
}




struct mini_Qdisc {
 struct tcf_proto *filter_list;
 struct gnet_stats_basic_cpu *cpu_bstats;
 struct gnet_stats_queue *cpu_qstats;
 struct callback_head rcu;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mini_qdisc_bstats_cpu_update(struct mini_Qdisc *miniq,
      const struct sk_buff *skb)
{
 bstats_cpu_update(({ do { const void *__vpp_verify = (typeof((miniq->cpu_bstats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(miniq->cpu_bstats)) *)(miniq->cpu_bstats)); (typeof((typeof(*(miniq->cpu_bstats)) *)(miniq->cpu_bstats))) (__ptr + ((local_paca->data_offset))); }); }), skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mini_qdisc_qstats_cpu_drop(struct mini_Qdisc *miniq)
{
 do { do { const void *__vpp_verify = (typeof((&(miniq->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(miniq->cpu_qstats->drops)) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(miniq->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops))); (typeof((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(miniq->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops))); (typeof((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(miniq->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops))); (typeof((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&(miniq->cpu_qstats->drops)) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops))); (typeof((typeof(*(&(miniq->cpu_qstats->drops))) *)(&(miniq->cpu_qstats->drops)))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}

struct mini_Qdisc_pair {
 struct mini_Qdisc miniq1;
 struct mini_Qdisc miniq2;
 struct mini_Qdisc **p_miniq;
};

void mini_qdisc_pair_swap(struct mini_Qdisc_pair *miniqp,
     struct tcf_proto *tp_head);
void mini_qdisc_pair_init(struct mini_Qdisc_pair *miniqp, struct Qdisc *qdisc,
     struct mini_Qdisc **p_miniq);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_tc_reinsert(struct sk_buff *skb, struct tcf_result *res)
{
 return res->ingress ? netif_receive_skb(skb) : dev_queue_xmit(skb);
}
# 26 "/home/nathan/src/linux-next/include/linux/filter.h" 2


# 1 "/home/nathan/src/linux-next/include/uapi/linux/filter.h" 1
# 24 "/home/nathan/src/linux-next/include/uapi/linux/filter.h"
struct sock_filter {
 __u16 code;
 __u8 jt;
 __u8 jf;
 __u32 k;
};

struct sock_fprog {
 unsigned short len;
 struct sock_filter *filter;
};
# 29 "/home/nathan/src/linux-next/include/linux/filter.h" 2


struct sk_buff;
struct sock;
struct seccomp_data;
struct bpf_prog_aux;
struct xdp_rxq_info;
struct xdp_buff;
struct sock_reuseport;
struct ctl_table;
struct ctl_table_header;
# 176 "/home/nathan/src/linux-next/include/linux/filter.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool insn_is_zext(const struct bpf_insn *insn)
{
 return insn->code == (0x04 | 0xb0 | 0x08) && insn->imm == 1;
}
# 507 "/home/nathan/src/linux-next/include/linux/filter.h"
struct compat_sock_fprog {
 u16 len;
 compat_uptr_t filter;
};


struct sock_fprog_kern {
 u16 len;
 struct sock_filter *filter;
};




struct bpf_binary_header {
 u32 pages;
 u8 image[] __attribute__((__aligned__(8)));
};

struct bpf_prog {
 u16 pages;
 u16 jited:1,
    jit_requested:1,
    gpl_compatible:1,
    cb_access:1,
    dst_needed:1,
    blinded:1,
    is_func:1,
    kprobe_override:1,
    has_callchain_buf:1,
    enforce_expected_attach_type:1;
 enum bpf_prog_type type;
 enum bpf_attach_type expected_attach_type;
 u32 len;
 u32 jited_len;
 u8 tag[8];
 struct bpf_prog_aux *aux;
 struct sock_fprog_kern *orig_prog;
 unsigned int (*bpf_func)(const void *ctx,
         const struct bpf_insn *insn);

 union {
  struct sock_filter insns[0];
  struct bpf_insn insnsi[0];
 };
};

struct sk_filter {
 refcount_t refcnt;
 struct callback_head rcu;
 struct bpf_prog *prog;
};

extern struct static_key_false bpf_stats_enabled_key;
# 584 "/home/nathan/src/linux-next/include/linux/filter.h"
struct bpf_skb_data_end {
 struct qdisc_skb_cb qdisc_cb;
 void *data_meta;
 void *data_end;
};

struct bpf_redirect_info {
 u32 flags;
 u32 tgt_index;
 void *tgt_value;
 struct bpf_map *map;
 u32 kern_flags;
};

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct bpf_redirect_info) bpf_redirect_info;
# 609 "/home/nathan/src/linux-next/include/linux/filter.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_compute_data_pointers(struct sk_buff *skb)
{
 struct bpf_skb_data_end *cb = (struct bpf_skb_data_end *)skb->cb;

 do { extern void __compiletime_assert_613(void) ; if (!(!(sizeof(*cb) > sizeof((((struct sk_buff *)0)->cb))))) __compiletime_assert_613(); } while (0);
 cb->data_meta = skb->data - skb_metadata_len(skb);
 cb->data_end = skb->data + skb_headlen(skb);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_compute_and_save_data_end(
 struct sk_buff *skb, void **saved_data_end)
{
 struct bpf_skb_data_end *cb = (struct bpf_skb_data_end *)skb->cb;

 *saved_data_end = cb->data_end;
 cb->data_end = skb->data + skb_headlen(skb);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_restore_data_end(
 struct sk_buff *skb, void *saved_data_end)
{
 struct bpf_skb_data_end *cb = (struct bpf_skb_data_end *)skb->cb;

 cb->data_end = saved_data_end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 *bpf_skb_cb(struct sk_buff *skb)
{
# 651 "/home/nathan/src/linux-next/include/linux/filter.h"
 do { extern void __compiletime_assert_651(void) ; if (!(!(sizeof((((struct __sk_buff *)0)->cb)) != 20))) __compiletime_assert_651(); } while (0);
 do { extern void __compiletime_assert_653(void) ; if (!(!(sizeof((((struct __sk_buff *)0)->cb)) != sizeof((((struct qdisc_skb_cb *)0)->data))))) __compiletime_assert_653(); } while (0);


 return qdisc_skb_cb(skb)->data;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __bpf_prog_run_save_cb(const struct bpf_prog *prog,
      struct sk_buff *skb)
{
 u8 *cb_data = bpf_skb_cb(skb);
 u8 cb_saved[20];
 u32 res;

 if (__builtin_expect(!!(prog->cb_access), 0)) {
  memcpy(cb_saved, cb_data, sizeof(cb_saved));
  memset(cb_data, 0, sizeof(cb_saved));
 }

 res = ({ u32 ret; do { } while (0); if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&bpf_stats_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&bpf_stats_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) { struct bpf_prog_stats *stats; u64 start = sched_clock(); ret = bpf_dispatcher_nopfunc(skb, (prog)->insnsi, (prog)->bpf_func); stats = ({ do { const void *__vpp_verify = (typeof((prog->aux->stats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(prog->aux->stats)) *)(prog->aux->stats)); (typeof((typeof(*(prog->aux->stats)) *)(prog->aux->stats))) (__ptr + ((local_paca->data_offset))); }); }); u64_stats_update_begin(&stats->syncp); stats->cnt++; stats->nsecs += sched_clock() - start; u64_stats_update_end(&stats->syncp); } else { ret = bpf_dispatcher_nopfunc(skb, (prog)->insnsi, (prog)->bpf_func); } ret; });

 if (__builtin_expect(!!(prog->cb_access), 0))
  memcpy(cb_data, cb_saved, sizeof(cb_saved));

 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_prog_run_save_cb(const struct bpf_prog *prog,
           struct sk_buff *skb)
{
 u32 res;

 __asm__ __volatile__("" : : : "memory");
 res = __bpf_prog_run_save_cb(prog, skb);
 __asm__ __volatile__("" : : : "memory");
 return res;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_prog_run_clear_cb(const struct bpf_prog *prog,
     struct sk_buff *skb)
{
 u8 *cb_data = bpf_skb_cb(skb);
 u32 res;

 if (__builtin_expect(!!(prog->cb_access), 0))
  memset(cb_data, 0, 20);

 __asm__ __volatile__("" : : : "memory");
 res = ({ u32 ret; do { } while (0); if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&bpf_stats_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&bpf_stats_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) { struct bpf_prog_stats *stats; u64 start = sched_clock(); ret = bpf_dispatcher_nopfunc(skb, (prog)->insnsi, (prog)->bpf_func); stats = ({ do { const void *__vpp_verify = (typeof((prog->aux->stats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(prog->aux->stats)) *)(prog->aux->stats)); (typeof((typeof(*(prog->aux->stats)) *)(prog->aux->stats))) (__ptr + ((local_paca->data_offset))); }); }); u64_stats_update_begin(&stats->syncp); stats->cnt++; stats->nsecs += sched_clock() - start; u64_stats_update_end(&stats->syncp); } else { ret = bpf_dispatcher_nopfunc(skb, (prog)->insnsi, (prog)->bpf_func); } ret; });
 __asm__ __volatile__("" : : : "memory");
 return res;
}

unsigned int bpf_dispatcher_xdpfunc( const void *ctx, const struct bpf_insn *insnsi, unsigned int (*bpf_func)(const void *, const struct bpf_insn *)); extern struct bpf_dispatcher bpf_dispatcher_xdp;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) u32 bpf_prog_run_xdp(const struct bpf_prog *prog,
         struct xdp_buff *xdp)
{






 return ({ u32 ret; do { } while (0); if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&bpf_stats_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&bpf_stats_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&bpf_stats_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) { struct bpf_prog_stats *stats; u64 start = sched_clock(); ret = bpf_dispatcher_xdpfunc(xdp, (prog)->insnsi, (prog)->bpf_func); stats = ({ do { const void *__vpp_verify = (typeof((prog->aux->stats) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(prog->aux->stats)) *)(prog->aux->stats)); (typeof((typeof(*(prog->aux->stats)) *)(prog->aux->stats))) (__ptr + ((local_paca->data_offset))); }); }); u64_stats_update_begin(&stats->syncp); stats->cnt++; stats->nsecs += sched_clock() - start; u64_stats_update_end(&stats->syncp); } else { ret = bpf_dispatcher_xdpfunc(xdp, (prog)->insnsi, (prog)->bpf_func); } ret; });

}

void bpf_prog_change_xdp(struct bpf_prog *prev_prog, struct bpf_prog *prog);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_prog_insn_size(const struct bpf_prog *prog)
{
 return prog->len * sizeof(struct bpf_insn);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_prog_tag_scratch_size(const struct bpf_prog *prog)
{
 return ((((bpf_prog_insn_size(prog) + sizeof(__be64) + 1)-1) | ((__typeof__(bpf_prog_insn_size(prog) + sizeof(__be64) + 1))(((512 / 8))-1)))+1);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int bpf_prog_size(unsigned int proglen)
{
 return __builtin_choose_expr(((!!(sizeof((typeof(sizeof(struct bpf_prog)) *)1 == (typeof(__builtin_offsetof(struct bpf_prog, insns[proglen])) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(sizeof(struct bpf_prog)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(__builtin_offsetof(struct bpf_prog, insns[proglen])) * 0l)) : (int *)8))))), ((sizeof(struct bpf_prog)) > (__builtin_offsetof(struct bpf_prog, insns[proglen])) ? (sizeof(struct bpf_prog)) : (__builtin_offsetof(struct bpf_prog, insns[proglen]))), ({ typeof(sizeof(struct bpf_prog)) __UNIQUE_ID___x70 = (sizeof(struct bpf_prog)); typeof(__builtin_offsetof(struct bpf_prog, insns[proglen])) __UNIQUE_ID___y71 = (__builtin_offsetof(struct bpf_prog, insns[proglen])); ((__UNIQUE_ID___x70) > (__UNIQUE_ID___y71) ? (__UNIQUE_ID___x70) : (__UNIQUE_ID___y71)); }));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_prog_was_classic(const struct bpf_prog *prog)
{





 return prog->type == BPF_PROG_TYPE_UNSPEC;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 bpf_ctx_off_adjust_machine(u32 size)
{
 const u32 size_machine = sizeof(unsigned long);

 if (size > size_machine && size % size_machine == 0)
  size = size_machine;

 return size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
bpf_ctx_narrow_access_ok(u32 off, u32 size, u32 size_default)
{
 return size <= size_default && (size & (size - 1)) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8
bpf_ctx_narrow_access_offset(u32 off, u32 size, u32 size_default)
{
 u8 access_off = off & (size_default - 1);




 return size_default - (access_off + size);

}
# 784 "/home/nathan/src/linux-next/include/linux/filter.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_prog_lock_ro(struct bpf_prog *fp)
{

 if (!fp->jited) {
  set_vm_flush_reset_perms(fp);
  set_memory_ro((unsigned long)fp, fp->pages);
 }

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_jit_binary_lock_ro(struct bpf_binary_header *hdr)
{
 set_vm_flush_reset_perms(hdr);
 set_memory_ro((unsigned long)hdr, hdr->pages);
 set_memory_x((unsigned long)hdr, hdr->pages);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct bpf_binary_header *
bpf_jit_binary_hdr(const struct bpf_prog *fp)
{
 unsigned long real_start = (unsigned long)fp->bpf_func;
 unsigned long addr = real_start & (~((1 << 16) - 1));

 return (void *)addr;
}

int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_filter(struct sock *sk, struct sk_buff *skb)
{
 return sk_filter_trim_cap(sk, skb, 1);
}

struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err);
void bpf_prog_free(struct bpf_prog *fp);

bool bpf_opcode_in_insntable(u8 code);

void bpf_prog_free_linfo(struct bpf_prog *prog);
void bpf_prog_fill_jited_linfo(struct bpf_prog *prog,
          const u32 *insn_to_jit_off);
int bpf_prog_alloc_jited_linfo(struct bpf_prog *prog);
void bpf_prog_free_jited_linfo(struct bpf_prog *prog);
void bpf_prog_free_unused_jited_linfo(struct bpf_prog *prog);

struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags);
struct bpf_prog *bpf_prog_alloc_no_stats(unsigned int size, gfp_t gfp_extra_flags);
struct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,
      gfp_t gfp_extra_flags);
void __bpf_prog_free(struct bpf_prog *fp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_prog_unlock_free(struct bpf_prog *fp)
{
 __bpf_prog_free(fp);
}

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *filter,
           unsigned int flen);

int bpf_prog_create(struct bpf_prog **pfp, struct sock_fprog_kern *fprog);
int bpf_prog_create_from_user(struct bpf_prog **pfp, struct sock_fprog *fprog,
         bpf_aux_classic_check_t trans, bool save_orig);
void bpf_prog_destroy(struct bpf_prog *fp);
const struct bpf_func_proto *
bpf_base_func_proto(enum bpf_func_id func_id);

int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);
int sk_attach_bpf(u32 ufd, struct sock *sk);
int sk_reuseport_attach_filter(struct sock_fprog *fprog, struct sock *sk);
int sk_reuseport_attach_bpf(u32 ufd, struct sock *sk);
void sk_reuseport_prog_free(struct bpf_prog *prog);
int sk_detach_filter(struct sock *sk);
int sk_get_filter(struct sock *sk, struct sock_filter *filter,
    unsigned int len);

bool sk_filter_charge(struct sock *sk, struct sk_filter *fp);
void sk_filter_uncharge(struct sock *sk, struct sk_filter *fp);

u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);




struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog);
void bpf_jit_compile(struct bpf_prog *prog);
bool bpf_jit_needs_zext(void);
bool bpf_helper_changes_pkt_data(void *func);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_dump_raw_ok(void)
{



 return kallsyms_show_value() == 1;
}

struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,
           const struct bpf_insn *patch, u32 len);
int bpf_remove_insns(struct bpf_prog *prog, u32 off, u32 cnt);

void bpf_clear_redirect_map(struct bpf_map *map);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool xdp_return_frame_no_direct(void)
{
 struct bpf_redirect_info *ri = ({ do { const void *__vpp_verify = (typeof((&bpf_redirect_info) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info)); (typeof((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info))) (__ptr + ((local_paca->data_offset))); }); });

 return ri->kern_flags & ((((1UL))) << (0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xdp_set_return_frame_no_direct(void)
{
 struct bpf_redirect_info *ri = ({ do { const void *__vpp_verify = (typeof((&bpf_redirect_info) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info)); (typeof((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info))) (__ptr + ((local_paca->data_offset))); }); });

 ri->kern_flags |= ((((1UL))) << (0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void xdp_clear_return_frame_no_direct(void)
{
 struct bpf_redirect_info *ri = ({ do { const void *__vpp_verify = (typeof((&bpf_redirect_info) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info)); (typeof((typeof(*(&bpf_redirect_info)) *)(&bpf_redirect_info))) (__ptr + ((local_paca->data_offset))); }); });

 ri->kern_flags &= ~((((1UL))) << (0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int xdp_ok_fwd_dev(const struct net_device *fwd,
     unsigned int pktlen)
{
 unsigned int len;

 if (__builtin_expect(!!(!(fwd->flags & IFF_UP)), 0))
  return -100;

 len = fwd->mtu + fwd->hard_header_len + 4;
 if (pktlen > len)
  return -90;

 return 0;
}







int xdp_do_generic_redirect(struct net_device *dev, struct sk_buff *skb,
       struct xdp_buff *xdp, struct bpf_prog *prog);
int xdp_do_redirect(struct net_device *dev,
      struct xdp_buff *xdp,
      struct bpf_prog *prog);
void xdp_do_flush(void);







void bpf_warn_invalid_xdp_action(u32 act);


struct sock *bpf_run_sk_reuseport(struct sock_reuseport *reuse, struct sock *sk,
      struct bpf_prog *prog, struct sk_buff *skb,
      u32 hash);
# 957 "/home/nathan/src/linux-next/include/linux/filter.h"
extern int bpf_jit_enable;
extern int bpf_jit_harden;
extern int bpf_jit_kallsyms;
extern long bpf_jit_limit;

typedef void (*bpf_jit_fill_hole_t)(void *area, unsigned int size);

struct bpf_binary_header *
bpf_jit_binary_alloc(unsigned int proglen, u8 **image_ptr,
       unsigned int alignment,
       bpf_jit_fill_hole_t bpf_fill_ill_insns);
void bpf_jit_binary_free(struct bpf_binary_header *hdr);
u64 bpf_jit_alloc_exec_limit(void);
void *bpf_jit_alloc_exec(unsigned long size);
void bpf_jit_free_exec(void *addr);
void bpf_jit_free(struct bpf_prog *fp);

int bpf_jit_add_poke_descriptor(struct bpf_prog *prog,
    struct bpf_jit_poke_descriptor *poke);

int bpf_jit_get_func_addr(const struct bpf_prog *prog,
     const struct bpf_insn *insn, bool extra_pass,
     u64 *func_addr, bool *func_addr_fixed);

struct bpf_prog *bpf_jit_blind_constants(struct bpf_prog *fp);
void bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_jit_dump(unsigned int flen, unsigned int proglen,
    u32 pass, void *image)
{
 printk("\001" "3" "flen=%u proglen=%u pass=%u image=%pK from=%s pid=%d\n", flen, proglen, pass, image, get_current()->comm, task_pid_nr(get_current()));


 if (image)
  print_hex_dump("\001" "3", "JIT code: ", DUMP_PREFIX_OFFSET,
          16, 1, image, proglen, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_jit_is_ebpf(void)
{

 return true;



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ebpf_jit_enabled(void)
{
 return bpf_jit_enable && bpf_jit_is_ebpf();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_prog_ebpf_jited(const struct bpf_prog *fp)
{
 return fp->jited && bpf_jit_is_ebpf();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_jit_blinding_enabled(struct bpf_prog *prog)
{




 if (!bpf_jit_is_ebpf())
  return false;
 if (!prog->jit_requested)
  return false;
 if (!bpf_jit_harden)
  return false;
 if (bpf_jit_harden == 1 && capable(21))
  return false;

 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_jit_kallsyms_enabled(void)
{



 if (bpf_jit_harden)
  return false;
 if (!bpf_jit_kallsyms)
  return false;
 if (bpf_jit_kallsyms == 1)
  return true;

 return false;
}

const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,
     unsigned long *off, char *sym);
bool is_bpf_text_address(unsigned long addr);
int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
      char *sym);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const char *
bpf_address_lookup(unsigned long addr, unsigned long *size,
     unsigned long *off, char **modname, char *sym)
{
 const char *ret = __bpf_address_lookup(addr, size, off, sym);

 if (ret && modname)
  *modname = ((void *)0);
 return ret;
}

void bpf_prog_kallsyms_add(struct bpf_prog *fp);
void bpf_prog_kallsyms_del(struct bpf_prog *fp);
void bpf_get_prog_name(const struct bpf_prog *prog, char *sym);
# 1142 "/home/nathan/src/linux-next/include/linux/filter.h"
void bpf_prog_kallsyms_del_all(struct bpf_prog *fp);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool bpf_needs_clear_a(const struct sock_filter *first)
{
 switch (first->code) {
 case 0x06 | 0x00:
 case 0x00 | 0x00 | 0x80:
  return false;

 case 0x00 | 0x00 | 0x20:
 case 0x00 | 0x08 | 0x20:
 case 0x00 | 0x10 | 0x20:
  if (first->k == (-0x1000) + 40)
   return true;
  return false;

 default:
  return true;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 bpf_anc_helper(const struct sock_filter *ftest)
{
 do { if (__builtin_constant_p(ftest->code & ((((1UL))) << (15)))) { if (ftest->code & ((((1UL))) << (15))) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/filter.h"), "i" (1167), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/linux/filter.h"), "i" (1167), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(ftest->code & ((((1UL))) << (15))))); } } while (0);

 switch (ftest->code) {
 case 0x00 | 0x00 | 0x20:
 case 0x00 | 0x08 | 0x20:
 case 0x00 | 0x10 | 0x20:


  switch (ftest->k) {
  case (-0x1000) + 0: return ((((1UL))) << (15)) | 0;
  case (-0x1000) + 4: return ((((1UL))) << (15)) | 4;
  case (-0x1000) + 8: return ((((1UL))) << (15)) | 8;
  case (-0x1000) + 12: return ((((1UL))) << (15)) | 12;
  case (-0x1000) + 16: return ((((1UL))) << (15)) | 16;
  case (-0x1000) + 20: return ((((1UL))) << (15)) | 20;
  case (-0x1000) + 24: return ((((1UL))) << (15)) | 24;
  case (-0x1000) + 28: return ((((1UL))) << (15)) | 28;
  case (-0x1000) + 32: return ((((1UL))) << (15)) | 32;
  case (-0x1000) + 36: return ((((1UL))) << (15)) | 36;
  case (-0x1000) + 40: return ((((1UL))) << (15)) | 40;
  case (-0x1000) + 44: return ((((1UL))) << (15)) | 44;
  case (-0x1000) + 48: return ((((1UL))) << (15)) | 48;
  case (-0x1000) + 52: return ((((1UL))) << (15)) | 52;
  case (-0x1000) + 56: return ((((1UL))) << (15)) | 56;
  case (-0x1000) + 60: return ((((1UL))) << (15)) | 60;
  }

 default:
  return ftest->code;
 }
}

void *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb,
        int k, unsigned int size);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *bpf_load_pointer(const struct sk_buff *skb, int k,
         unsigned int size, void *buffer)
{
 if (k >= 0)
  return skb_header_pointer(skb, k, size, buffer);

 return bpf_internal_load_pointer_neg_helper(skb, k, size);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int bpf_tell_extensions(void)
{
 return 64;
}

struct bpf_sock_addr_kern {
 struct sock *sk;
 struct sockaddr *uaddr;




 u64 tmp_reg;
 void *t_ctx;
};

struct bpf_sock_ops_kern {
 struct sock *sk;
 u32 op;
 union {
  u32 args[4];
  u32 reply;
  u32 replylong[4];
 };
 u32 is_fullsock;
 u64 temp;
# 1245 "/home/nathan/src/linux-next/include/linux/filter.h"
};

struct bpf_sysctl_kern {
 struct ctl_table_header *head;
 struct ctl_table *table;
 void *cur_val;
 size_t cur_len;
 void *new_val;
 size_t new_len;
 int new_updated;
 int write;
 loff_t *ppos;

 u64 tmp_reg;
};

struct bpf_sockopt_kern {
 struct sock *sk;
 u8 *optval;
 u8 *optval_end;
 s32 level;
 s32 optname;
 s32 optlen;
 s32 retval;
};
# 60 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/rculist_nulls.h" 1
# 33 "/home/nathan/src/linux-next/include/linux/rculist_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_del_init_rcu(struct hlist_nulls_node *n)
{
 if (!hlist_nulls_unhashed(n)) {
  __hlist_nulls_del(n);
  ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (((void *)0)) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 }
}
# 74 "/home/nathan/src/linux-next/include/linux/rculist_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_del_rcu(struct hlist_nulls_node *n)
{
 __hlist_nulls_del(n);
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (((void *) 0x122 + (0x5deadbeef0000000UL))) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
}
# 99 "/home/nathan/src/linux-next/include/linux/rculist_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_add_head_rcu(struct hlist_nulls_node *n,
     struct hlist_nulls_head *h)
{
 struct hlist_nulls_node *first = h->first;

 n->next = first;
 ({ union { typeof(n->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(n->pprev)) (&h->first) }; __write_once_size(&(n->pprev), __u.__c, sizeof(n->pprev)); __u.__val; });
 do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_nulls_node **)&(h)->first)))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_nulls_node **)&(h)->first))))) ((typeof((*((struct hlist_nulls_node **)&(h)->first))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_nulls_node **)&(h)->first)))), __u.__c, sizeof(((*((struct hlist_nulls_node **)&(h)->first))))); __u.__val; }); else do { do { extern void __compiletime_assert_106(void) ; if (!((sizeof(*&(*((struct hlist_nulls_node **)&(h)->first))) == sizeof(char) || sizeof(*&(*((struct hlist_nulls_node **)&(h)->first))) == sizeof(short) || sizeof(*&(*((struct hlist_nulls_node **)&(h)->first))) == sizeof(int) || sizeof(*&(*((struct hlist_nulls_node **)&(h)->first))) == sizeof(long)))) __compiletime_assert_106(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_nulls_node **)&(h)->first))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_nulls_node **)&(h)->first)))) ((typeof(*((typeof((*((struct hlist_nulls_node **)&(h)->first))))_r_a_p__v)) *)((typeof((*((struct hlist_nulls_node **)&(h)->first))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_nulls_node **)&(h)->first))), __u.__c, sizeof(*&(*((struct hlist_nulls_node **)&(h)->first)))); __u.__val; }); } while (0); } while (0);
 if (!is_a_nulls(first))
  ({ union { typeof(first->pprev) __val; char __c[1]; } __u = { .__val = ( typeof(first->pprev)) (&n->next) }; __write_once_size(&(first->pprev), __u.__c, sizeof(first->pprev)); __u.__val; });
}
# 130 "/home/nathan/src/linux-next/include/linux/rculist_nulls.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void hlist_nulls_add_tail_rcu(struct hlist_nulls_node *n,
         struct hlist_nulls_head *h)
{
 struct hlist_nulls_node *i, *last = ((void *)0);


 for (i = h->first; !is_a_nulls(i); i = i->next)
  last = i;

 if (last) {
  n->next = last->next;
  n->pprev = &last->next;
  do { uintptr_t _r_a_p__v = (uintptr_t)(n); ; if (__builtin_constant_p(n) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof(((*((struct hlist_node **)(&(last)->next))))) __val; char __c[1]; } __u = { .__val = ( typeof(((*((struct hlist_node **)(&(last)->next)))))) ((typeof((*((struct hlist_node **)(&(last)->next)))))(_r_a_p__v)) }; __write_once_size(&(((*((struct hlist_node **)(&(last)->next))))), __u.__c, sizeof(((*((struct hlist_node **)(&(last)->next)))))); __u.__val; }); else do { do { extern void __compiletime_assert_142(void) ; if (!((sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(char) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(short) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(int) || sizeof(*&(*((struct hlist_node **)(&(last)->next)))) == sizeof(long)))) __compiletime_assert_142(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&(*((struct hlist_node **)(&(last)->next)))) __val; char __c[1]; } __u = { .__val = ( typeof(*&(*((struct hlist_node **)(&(last)->next))))) ((typeof(*((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)) *)((typeof((*((struct hlist_node **)(&(last)->next)))))_r_a_p__v)) }; __write_once_size(&(*&(*((struct hlist_node **)(&(last)->next)))), __u.__c, sizeof(*&(*((struct hlist_node **)(&(last)->next))))); __u.__val; }); } while (0); } while (0);
 } else {
  hlist_nulls_add_head_rcu(n, h);
 }
}
# 61 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/poll.h" 1
# 13 "/home/nathan/src/linux-next/include/linux/poll.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/poll.h" 1
# 1 "./arch/powerpc/include/generated/uapi/asm/poll.h" 1
# 1 "/home/nathan/src/linux-next/include/uapi/asm-generic/poll.h" 1
# 36 "/home/nathan/src/linux-next/include/uapi/asm-generic/poll.h"
struct pollfd {
 int fd;
 short events;
 short revents;
};
# 2 "./arch/powerpc/include/generated/uapi/asm/poll.h" 2
# 2 "/home/nathan/src/linux-next/include/uapi/linux/poll.h" 2
# 14 "/home/nathan/src/linux-next/include/linux/poll.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/eventpoll.h" 1
# 77 "/home/nathan/src/linux-next/include/uapi/linux/eventpoll.h"
struct epoll_event {
 __poll_t events;
 __u64 data;
} ;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ep_take_care_of_epollwakeup(struct epoll_event *epev)
{
 if ((epev->events & (( __poll_t)(1U << 29))) && !capable(36))
  epev->events &= ~(( __poll_t)(1U << 29));
}
# 15 "/home/nathan/src/linux-next/include/linux/poll.h" 2

extern struct ctl_table epoll_table[];
# 32 "/home/nathan/src/linux-next/include/linux/poll.h"
struct poll_table_struct;




typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);





typedef struct poll_table_struct {
 poll_queue_proc _qproc;
 __poll_t _key;
} poll_table;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
{
 if (p && p->_qproc && wait_address)
  p->_qproc(filp, wait_address, p);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool poll_does_not_wait(const poll_table *p)
{
 return p == ((void *)0) || p->_qproc == ((void *)0);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __poll_t poll_requested_events(const poll_table *p)
{
 return p ? p->_key : ~(__poll_t)0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
{
 pt->_qproc = qproc;
 pt->_key = ~(__poll_t)0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool file_can_poll(struct file *file)
{
 return file->f_op->poll;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt)
{
 if (__builtin_expect(!!(!file->f_op->poll), 0))
  return (( __poll_t)0x00000001 | ( __poll_t)0x00000004 | ( __poll_t)0x00000040 | ( __poll_t)0x00000100);
 return file->f_op->poll(file, pt);
}

struct poll_table_entry {
 struct file *filp;
 __poll_t key;
 wait_queue_entry_t wait;
 wait_queue_head_t *wait_address;
};




struct poll_wqueues {
 poll_table pt;
 struct poll_table_page *table;
 struct task_struct *polling_task;
 int triggered;
 int error;
 int inline_index;
 struct poll_table_entry inline_entries[((768 - 256) / sizeof(struct poll_table_entry))];
};

extern void poll_initwait(struct poll_wqueues *pwq);
extern void poll_freewait(struct poll_wqueues *pwq);
extern u64 select_estimate_accuracy(struct timespec64 *tv);



extern int core_sys_select(int n, fd_set *inp, fd_set *outp,
      fd_set *exp, struct timespec64 *end_time);

extern int poll_select_set_timeout(struct timespec64 *to, time64_t sec,
       long nsec);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u16 mangle_poll(__poll_t val)
{
 __u16 v = ( __u16)val;

 return (( __u16)( __poll_t)0x00000001 < 0x0001 ? (v & ( __u16)( __poll_t)0x00000001) * (0x0001/( __u16)( __poll_t)0x00000001) : (v & ( __u16)( __poll_t)0x00000001) / (( __u16)( __poll_t)0x00000001/0x0001)) | (( __u16)( __poll_t)0x00000004 < 0x0004 ? (v & ( __u16)( __poll_t)0x00000004) * (0x0004/( __u16)( __poll_t)0x00000004) : (v & ( __u16)( __poll_t)0x00000004) / (( __u16)( __poll_t)0x00000004/0x0004)) | (( __u16)( __poll_t)0x00000002 < 0x0002 ? (v & ( __u16)( __poll_t)0x00000002) * (0x0002/( __u16)( __poll_t)0x00000002) : (v & ( __u16)( __poll_t)0x00000002) / (( __u16)( __poll_t)0x00000002/0x0002)) | (( __u16)( __poll_t)0x00000008 < 0x0008 ? (v & ( __u16)( __poll_t)0x00000008) * (0x0008/( __u16)( __poll_t)0x00000008) : (v & ( __u16)( __poll_t)0x00000008) / (( __u16)( __poll_t)0x00000008/0x0008)) | (( __u16)( __poll_t)0x00000020 < 0x0020 ? (v & ( __u16)( __poll_t)0x00000020) * (0x0020/( __u16)( __poll_t)0x00000020) : (v & ( __u16)( __poll_t)0x00000020) / (( __u16)( __poll_t)0x00000020/0x0020)) |
  (( __u16)( __poll_t)0x00000040 < 0x0040 ? (v & ( __u16)( __poll_t)0x00000040) * (0x0040/( __u16)( __poll_t)0x00000040) : (v & ( __u16)( __poll_t)0x00000040) / (( __u16)( __poll_t)0x00000040/0x0040)) | (( __u16)( __poll_t)0x00000080 < 0x0080 ? (v & ( __u16)( __poll_t)0x00000080) * (0x0080/( __u16)( __poll_t)0x00000080) : (v & ( __u16)( __poll_t)0x00000080) / (( __u16)( __poll_t)0x00000080/0x0080)) | (( __u16)( __poll_t)0x00000100 < 0x0100 ? (v & ( __u16)( __poll_t)0x00000100) * (0x0100/( __u16)( __poll_t)0x00000100) : (v & ( __u16)( __poll_t)0x00000100) / (( __u16)( __poll_t)0x00000100/0x0100)) | (( __u16)( __poll_t)0x00000200 < 0x0200 ? (v & ( __u16)( __poll_t)0x00000200) * (0x0200/( __u16)( __poll_t)0x00000200) : (v & ( __u16)( __poll_t)0x00000200) / (( __u16)( __poll_t)0x00000200/0x0200)) |
  (( __u16)( __poll_t)0x00000010 < 0x0010 ? (v & ( __u16)( __poll_t)0x00000010) * (0x0010/( __u16)( __poll_t)0x00000010) : (v & ( __u16)( __poll_t)0x00000010) / (( __u16)( __poll_t)0x00000010/0x0010)) | (( __u16)( __poll_t)0x00002000 < 0x2000 ? (v & ( __u16)( __poll_t)0x00002000) * (0x2000/( __u16)( __poll_t)0x00002000) : (v & ( __u16)( __poll_t)0x00002000) / (( __u16)( __poll_t)0x00002000/0x2000)) | (( __u16)( __poll_t)0x00000400 < 0x0400 ? (v & ( __u16)( __poll_t)0x00000400) * (0x0400/( __u16)( __poll_t)0x00000400) : (v & ( __u16)( __poll_t)0x00000400) / (( __u16)( __poll_t)0x00000400/0x0400));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __poll_t demangle_poll(u16 val)
{

 return ( __poll_t)(0x0001 < ( __u16)( __poll_t)0x00000001 ? (val & 0x0001) * (( __u16)( __poll_t)0x00000001/0x0001) : (val & 0x0001) / (0x0001/( __u16)( __poll_t)0x00000001)) | ( __poll_t)(0x0004 < ( __u16)( __poll_t)0x00000004 ? (val & 0x0004) * (( __u16)( __poll_t)0x00000004/0x0004) : (val & 0x0004) / (0x0004/( __u16)( __poll_t)0x00000004)) | ( __poll_t)(0x0002 < ( __u16)( __poll_t)0x00000002 ? (val & 0x0002) * (( __u16)( __poll_t)0x00000002/0x0002) : (val & 0x0002) / (0x0002/( __u16)( __poll_t)0x00000002)) | ( __poll_t)(0x0008 < ( __u16)( __poll_t)0x00000008 ? (val & 0x0008) * (( __u16)( __poll_t)0x00000008/0x0008) : (val & 0x0008) / (0x0008/( __u16)( __poll_t)0x00000008)) | ( __poll_t)(0x0020 < ( __u16)( __poll_t)0x00000020 ? (val & 0x0020) * (( __u16)( __poll_t)0x00000020/0x0020) : (val & 0x0020) / (0x0020/( __u16)( __poll_t)0x00000020)) |
  ( __poll_t)(0x0040 < ( __u16)( __poll_t)0x00000040 ? (val & 0x0040) * (( __u16)( __poll_t)0x00000040/0x0040) : (val & 0x0040) / (0x0040/( __u16)( __poll_t)0x00000040)) | ( __poll_t)(0x0080 < ( __u16)( __poll_t)0x00000080 ? (val & 0x0080) * (( __u16)( __poll_t)0x00000080/0x0080) : (val & 0x0080) / (0x0080/( __u16)( __poll_t)0x00000080)) | ( __poll_t)(0x0100 < ( __u16)( __poll_t)0x00000100 ? (val & 0x0100) * (( __u16)( __poll_t)0x00000100/0x0100) : (val & 0x0100) / (0x0100/( __u16)( __poll_t)0x00000100)) | ( __poll_t)(0x0200 < ( __u16)( __poll_t)0x00000200 ? (val & 0x0200) * (( __u16)( __poll_t)0x00000200/0x0200) : (val & 0x0200) / (0x0200/( __u16)( __poll_t)0x00000200)) |
  ( __poll_t)(0x0010 < ( __u16)( __poll_t)0x00000010 ? (val & 0x0010) * (( __u16)( __poll_t)0x00000010/0x0010) : (val & 0x0010) / (0x0010/( __u16)( __poll_t)0x00000010)) | ( __poll_t)(0x2000 < ( __u16)( __poll_t)0x00002000 ? (val & 0x2000) * (( __u16)( __poll_t)0x00002000/0x2000) : (val & 0x2000) / (0x2000/( __u16)( __poll_t)0x00002000)) | ( __poll_t)(0x0400 < ( __u16)( __poll_t)0x00000400 ? (val & 0x0400) * (( __u16)( __poll_t)0x00000400/0x0400) : (val & 0x0400) / (0x0400/( __u16)( __poll_t)0x00000400));

}
# 62 "/home/nathan/src/linux-next/include/net/sock.h" 2



# 1 "/home/nathan/src/linux-next/include/net/dst.h" 1
# 19 "/home/nathan/src/linux-next/include/net/dst.h"
# 1 "/home/nathan/src/linux-next/include/net/neighbour.h" 1
# 41 "/home/nathan/src/linux-next/include/net/neighbour.h"
struct neighbour;

enum {
 NEIGH_VAR_MCAST_PROBES,
 NEIGH_VAR_UCAST_PROBES,
 NEIGH_VAR_APP_PROBES,
 NEIGH_VAR_MCAST_REPROBES,
 NEIGH_VAR_RETRANS_TIME,
 NEIGH_VAR_BASE_REACHABLE_TIME,
 NEIGH_VAR_DELAY_PROBE_TIME,
 NEIGH_VAR_GC_STALETIME,
 NEIGH_VAR_QUEUE_LEN_BYTES,
 NEIGH_VAR_PROXY_QLEN,
 NEIGH_VAR_ANYCAST_DELAY,
 NEIGH_VAR_PROXY_DELAY,
 NEIGH_VAR_LOCKTIME,


 NEIGH_VAR_QUEUE_LEN,
 NEIGH_VAR_RETRANS_TIME_MS,
 NEIGH_VAR_BASE_REACHABLE_TIME_MS,

 NEIGH_VAR_GC_INTERVAL,
 NEIGH_VAR_GC_THRESH1,
 NEIGH_VAR_GC_THRESH2,
 NEIGH_VAR_GC_THRESH3,
 NEIGH_VAR_MAX
};

struct neigh_parms {
 possible_net_t net;
 struct net_device *dev;
 struct list_head list;
 int (*neigh_setup)(struct neighbour *);
 struct neigh_table *tbl;

 void *sysctl_table;

 int dead;
 refcount_t refcnt;
 struct callback_head callback_head;

 int reachable_time;
 int data[(NEIGH_VAR_LOCKTIME + 1)];
 unsigned long data_state[((((NEIGH_VAR_LOCKTIME + 1)) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_var_set(struct neigh_parms *p, int index, int val)
{
 set_bit(index, p->data_state);
 p->data[index] = val;
}
# 102 "/home/nathan/src/linux-next/include/net/neighbour.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_parms_data_state_setall(struct neigh_parms *p)
{
 bitmap_fill(p->data_state, (NEIGH_VAR_LOCKTIME + 1));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_parms_data_state_cleanall(struct neigh_parms *p)
{
 bitmap_zero(p->data_state, (NEIGH_VAR_LOCKTIME + 1));
}

struct neigh_statistics {
 unsigned long allocs;
 unsigned long destroys;
 unsigned long hash_grows;

 unsigned long res_failed;

 unsigned long lookups;
 unsigned long hits;

 unsigned long rcv_probes_mcast;
 unsigned long rcv_probes_ucast;

 unsigned long periodic_gc_runs;
 unsigned long forced_gc_runs;

 unsigned long unres_discards;
 unsigned long table_fulls;
};



struct neighbour {
 struct neighbour *next;
 struct neigh_table *tbl;
 struct neigh_parms *parms;
 unsigned long confirmed;
 unsigned long updated;
 rwlock_t lock;
 refcount_t refcnt;
 unsigned int arp_queue_len_bytes;
 struct sk_buff_head arp_queue;
 struct timer_list timer;
 unsigned long used;
 atomic_t probes;
 __u8 flags;
 __u8 nud_state;
 __u8 type;
 __u8 dead;
 u8 protocol;
 seqlock_t ha_lock;
 unsigned char ha[((((32)) + ((typeof((32)))((sizeof(unsigned long))) - 1)) & ~((typeof((32)))((sizeof(unsigned long))) - 1))] __attribute__((__aligned__(8)));
 struct hh_cache hh;
 int (*output)(struct neighbour *, struct sk_buff *);
 const struct neigh_ops *ops;
 struct list_head gc_list;
 struct callback_head rcu;
 struct net_device *dev;
 u8 primary_key[0];
} ;

struct neigh_ops {
 int family;
 void (*solicit)(struct neighbour *, struct sk_buff *);
 void (*error_report)(struct neighbour *, struct sk_buff *);
 int (*output)(struct neighbour *, struct sk_buff *);
 int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
 struct pneigh_entry *next;
 possible_net_t net;
 struct net_device *dev;
 u8 flags;
 u8 protocol;
 u8 key[0];
};







struct neigh_hash_table {
 struct neighbour **hash_buckets;
 unsigned int hash_shift;
 __u32 hash_rnd[4];
 struct callback_head rcu;
};


struct neigh_table {
 int family;
 unsigned int entry_size;
 unsigned int key_len;
 __be16 protocol;
 __u32 (*hash)(const void *pkey,
     const struct net_device *dev,
     __u32 *hash_rnd);
 bool (*key_eq)(const struct neighbour *, const void *pkey);
 int (*constructor)(struct neighbour *);
 int (*pconstructor)(struct pneigh_entry *);
 void (*pdestructor)(struct pneigh_entry *);
 void (*proxy_redo)(struct sk_buff *skb);
 bool (*allow_add)(const struct net_device *dev,
          struct netlink_ext_ack *extack);
 char *id;
 struct neigh_parms parms;
 struct list_head parms_list;
 int gc_interval;
 int gc_thresh1;
 int gc_thresh2;
 int gc_thresh3;
 unsigned long last_flush;
 struct delayed_work gc_work;
 struct timer_list proxy_timer;
 struct sk_buff_head proxy_queue;
 atomic_t entries;
 atomic_t gc_entries;
 struct list_head gc_list;
 rwlock_t lock;
 unsigned long last_rand;
 struct neigh_statistics *stats;
 struct neigh_hash_table *nht;
 struct pneigh_entry **phash_buckets;
};

enum {
 NEIGH_ARP_TABLE = 0,
 NEIGH_ND_TABLE = 1,
 NEIGH_DN_TABLE = 2,
 NEIGH_NR_TABLES,
 NEIGH_LINK_TABLE = NEIGH_NR_TABLES
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int neigh_parms_family(struct neigh_parms *p)
{
 return p->tbl->family;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *neighbour_priv(const struct neighbour *n)
{
 return (char *)n + n->tbl->entry_size;
}
# 259 "/home/nathan/src/linux-next/include/net/neighbour.h"
extern const struct nla_policy nda_policy[];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool neigh_key_eq16(const struct neighbour *n, const void *pkey)
{
 return *(const u16 *)n->primary_key == *(const u16 *)pkey;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool neigh_key_eq32(const struct neighbour *n, const void *pkey)
{
 return *(const u32 *)n->primary_key == *(const u32 *)pkey;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool neigh_key_eq128(const struct neighbour *n, const void *pkey)
{
 const u32 *n32 = (const u32 *)n->primary_key;
 const u32 *p32 = pkey;

 return ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
  (n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *___neigh_lookup_noref(
 struct neigh_table *tbl,
 bool (*key_eq)(const struct neighbour *n, const void *pkey),
 __u32 (*hash)(const void *pkey,
        const struct net_device *dev,
        __u32 *hash_rnd),
 const void *pkey,
 struct net_device *dev)
{
 struct neigh_hash_table *nht = ({ typeof(*(tbl->nht)) *________p1 = (typeof(*(tbl->nht)) *)({ union { typeof((tbl->nht)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tbl->nht)), __u.__c, sizeof((tbl->nht))); else __read_once_size_nocheck(&((tbl->nht)), __u.__c, sizeof((tbl->nht))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(tbl->nht)) *)(________p1)); });
 struct neighbour *n;
 u32 hash_val;

 hash_val = hash(pkey, dev, nht->hash_rnd) >> (32 - nht->hash_shift);
 for (n = ({ typeof(*(nht->hash_buckets[hash_val])) *________p1 = (typeof(*(nht->hash_buckets[hash_val])) *)({ union { typeof((nht->hash_buckets[hash_val])) __val; char __c[1]; } __u; if (1) __read_once_size(&((nht->hash_buckets[hash_val])), __u.__c, sizeof((nht->hash_buckets[hash_val]))); else __read_once_size_nocheck(&((nht->hash_buckets[hash_val])), __u.__c, sizeof((nht->hash_buckets[hash_val]))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(nht->hash_buckets[hash_val])) *)(________p1)); });
      n != ((void *)0);
      n = ({ typeof(*(n->next)) *________p1 = (typeof(*(n->next)) *)({ union { typeof((n->next)) __val; char __c[1]; } __u; if (1) __read_once_size(&((n->next)), __u.__c, sizeof((n->next))); else __read_once_size_nocheck(&((n->next)), __u.__c, sizeof((n->next))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(n->next)) *)(________p1)); })) {
  if (n->dev == dev && key_eq(n, pkey))
   return n;
 }

 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *__neigh_lookup_noref(struct neigh_table *tbl,
           const void *pkey,
           struct net_device *dev)
{
 return ___neigh_lookup_noref(tbl, tbl->key_eq, tbl->hash, pkey, dev);
}

void neigh_table_init(int index, struct neigh_table *tbl);
int neigh_table_clear(int index, struct neigh_table *tbl);
struct neighbour *neigh_lookup(struct neigh_table *tbl, const void *pkey,
          struct net_device *dev);
struct neighbour *neigh_lookup_nodev(struct neigh_table *tbl, struct net *net,
         const void *pkey);
struct neighbour *__neigh_create(struct neigh_table *tbl, const void *pkey,
     struct net_device *dev, bool want_ref);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *neigh_create(struct neigh_table *tbl,
          const void *pkey,
          struct net_device *dev)
{
 return __neigh_create(tbl, pkey, dev, true);
}
void neigh_destroy(struct neighbour *neigh);
int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb);
int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags,
   u32 nlmsg_pid);
void __neigh_set_probe_once(struct neighbour *neigh);
bool neigh_remove_one(struct neighbour *ndel, struct neigh_table *tbl);
void neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
int neigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
int neigh_carrier_down(struct neigh_table *tbl, struct net_device *dev);
int neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb);
int neigh_connected_output(struct neighbour *neigh, struct sk_buff *skb);
int neigh_direct_output(struct neighbour *neigh, struct sk_buff *skb);
struct neighbour *neigh_event_ns(struct neigh_table *tbl,
      u8 *lladdr, void *saddr,
      struct net_device *dev);

struct neigh_parms *neigh_parms_alloc(struct net_device *dev,
          struct neigh_table *tbl);
void neigh_parms_release(struct neigh_table *tbl, struct neigh_parms *parms);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct net *neigh_parms_net(const struct neigh_parms *parms)
{
 return read_pnet(&parms->net);
}

unsigned long neigh_rand_reach_time(unsigned long base);

void pneigh_enqueue(struct neigh_table *tbl, struct neigh_parms *p,
      struct sk_buff *skb);
struct pneigh_entry *pneigh_lookup(struct neigh_table *tbl, struct net *net,
       const void *key, struct net_device *dev,
       int creat);
struct pneigh_entry *__pneigh_lookup(struct neigh_table *tbl, struct net *net,
         const void *key, struct net_device *dev);
int pneigh_delete(struct neigh_table *tbl, struct net *net, const void *key,
    struct net_device *dev);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *pneigh_net(const struct pneigh_entry *pneigh)
{
 return read_pnet(&pneigh->net);
}

void neigh_app_ns(struct neighbour *n);
void neigh_for_each(struct neigh_table *tbl,
      void (*cb)(struct neighbour *, void *), void *cookie);
void __neigh_for_each_release(struct neigh_table *tbl,
         int (*cb)(struct neighbour *));
int neigh_xmit(int fam, struct net_device *, const void *, struct sk_buff *);
void pneigh_for_each(struct neigh_table *tbl,
       void (*cb)(struct pneigh_entry *));

struct neigh_seq_state {
 struct seq_net_private p;
 struct neigh_table *tbl;
 struct neigh_hash_table *nht;
 void *(*neigh_sub_iter)(struct neigh_seq_state *state,
    struct neighbour *n, loff_t *pos);
 unsigned int bucket;
 unsigned int flags;



};
void *neigh_seq_start(struct seq_file *, loff_t *, struct neigh_table *,
        unsigned int);
void *neigh_seq_next(struct seq_file *, void *, loff_t *);
void neigh_seq_stop(struct seq_file *, void *);

int neigh_proc_dointvec(struct ctl_table *ctl, int write,
   void *buffer, size_t *lenp, loff_t *ppos);
int neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,
    void *buffer,
    size_t *lenp, loff_t *ppos);
int neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,
       void *buffer,
       size_t *lenp, loff_t *ppos);

int neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,
     proc_handler *proc_handler);
void neigh_sysctl_unregister(struct neigh_parms *p);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __neigh_parms_put(struct neigh_parms *parms)
{
 refcount_dec(&parms->refcnt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neigh_parms *neigh_parms_clone(struct neigh_parms *parms)
{
 refcount_inc(&parms->refcnt);
 return parms;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_release(struct neighbour *neigh)
{
 if (refcount_dec_and_test(&neigh->refcnt))
  neigh_destroy(neigh);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour * neigh_clone(struct neighbour *neigh)
{
 if (neigh)
  refcount_inc(&neigh->refcnt);
 return neigh;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
{
 unsigned long now = jiffies;

 if (({ union { typeof(neigh->used) __val; char __c[1]; } __u; if (1) __read_once_size(&(neigh->used), __u.__c, sizeof(neigh->used)); else __read_once_size_nocheck(&(neigh->used), __u.__c, sizeof(neigh->used)); do { } while (0); __u.__val; }) != now)
  ({ union { typeof(neigh->used) __val; char __c[1]; } __u = { .__val = ( typeof(neigh->used)) (now) }; __write_once_size(&(neigh->used), __u.__c, sizeof(neigh->used)); __u.__val; });
 if (!(neigh->nud_state&((0x80|0x40|0x02)|0x08|0x10)))
  return __neigh_event_send(neigh, skb);
 return 0;
}
# 462 "/home/nathan/src/linux-next/include/net/neighbour.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int neigh_hh_output(const struct hh_cache *hh, struct sk_buff *skb)
{
 unsigned int hh_alen = 0;
 unsigned int seq;
 unsigned int hh_len;

 do {
  seq = read_seqbegin(&hh->hh_lock);
  hh_len = ({ union { typeof(hh->hh_len) __val; char __c[1]; } __u; if (1) __read_once_size(&(hh->hh_len), __u.__c, sizeof(hh->hh_len)); else __read_once_size_nocheck(&(hh->hh_len), __u.__c, sizeof(hh->hh_len)); do { } while (0); __u.__val; });
  if (__builtin_expect(!!(hh_len <= 16), 1)) {
   hh_alen = 16;





   if (__builtin_expect(!!(skb_headroom(skb) >= 16), 1)) {

    memcpy(skb->data - 16, hh->hh_data,
           16);
   }
  } else {
   hh_alen = (((hh_len)+(16 -1))&~(16 - 1));

   if (__builtin_expect(!!(skb_headroom(skb) >= hh_alen), 1)) {
    memcpy(skb->data - hh_alen, hh->hh_data,
           hh_alen);
   }
  }
 } while (read_seqretry(&hh->hh_lock, seq));

 if (({ int __ret_warn_on = !!(skb_headroom(skb) < hh_alen); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/neighbour.h"), "i" (493), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); })) {
  kfree_skb(skb);
  return 0x01;
 }

 __skb_push(skb, hh_len);
 return dev_queue_xmit(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int neigh_output(struct neighbour *n, struct sk_buff *skb,
          bool skip_cache)
{
 const struct hh_cache *hh = &n->hh;

 if ((n->nud_state & (0x80|0x40|0x02)) && hh->hh_len && !skip_cache)
  return neigh_hh_output(hh, skb);
 else
  return n->output(n, skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *
__neigh_lookup(struct neigh_table *tbl, const void *pkey, struct net_device *dev, int creat)
{
 struct neighbour *n = neigh_lookup(tbl, pkey, dev);

 if (n || !creat)
  return n;

 n = neigh_create(tbl, pkey, dev);
 return IS_ERR(n) ? ((void *)0) : n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *
__neigh_lookup_errno(struct neigh_table *tbl, const void *pkey,
  struct net_device *dev)
{
 struct neighbour *n = neigh_lookup(tbl, pkey, dev);

 if (n)
  return n;

 return neigh_create(tbl, pkey, dev);
}

struct neighbour_cb {
 unsigned long sched_next;
 unsigned int flags;
};





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_ha_snapshot(char *dst, const struct neighbour *n,
         const struct net_device *dev)
{
 unsigned int seq;

 do {
  seq = read_seqbegin(&n->ha_lock);
  memcpy(dst, n->ha, dev->addr_len);
 } while (read_seqretry(&n->ha_lock, seq));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void neigh_update_is_router(struct neighbour *neigh, u32 flags,
       int *notify)
{
 u8 ndm_flags = 0;

 ndm_flags |= (flags & 0x40000000) ? 0x80 : 0;
 if ((neigh->flags ^ ndm_flags) & 0x80) {
  if (ndm_flags & 0x80)
   neigh->flags |= 0x80;
  else
   neigh->flags &= ~0x80;
  *notify = 1;
 }
}
# 20 "/home/nathan/src/linux-next/include/net/dst.h" 2


struct sk_buff;

struct dst_entry {
 struct net_device *dev;
 struct dst_ops *ops;
 unsigned long _metrics;
 unsigned long expires;

 struct xfrm_state *xfrm;



 int (*input)(struct sk_buff *);
 int (*output)(struct net *net, struct sock *sk, struct sk_buff *skb);

 unsigned short flags;
# 55 "/home/nathan/src/linux-next/include/net/dst.h"
 short obsolete;




 unsigned short header_len;
 unsigned short trailer_len;






 atomic_t __refcnt;

 int __use;
 unsigned long lastuse;
 struct lwtunnel_state *lwtstate;
 struct callback_head callback_head;
 short error;
 short __pad;
 __u32 tclassid;



};

struct dst_metrics {
 u32 metrics[(__RTAX_MAX - 1)];
 refcount_t refcnt;
} __attribute__((__aligned__(4)));
extern const struct dst_metrics dst_default_metrics;

u32 *dst_cow_metrics_generic(struct dst_entry *dst, unsigned long old);
# 97 "/home/nathan/src/linux-next/include/net/dst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dst_metrics_read_only(const struct dst_entry *dst)
{
 return dst->_metrics & 0x1UL;
}

void __dst_destroy_metrics_generic(struct dst_entry *dst, unsigned long old);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_destroy_metrics_generic(struct dst_entry *dst)
{
 unsigned long val = dst->_metrics;
 if (!(val & 0x1UL))
  __dst_destroy_metrics_generic(dst, val);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 *dst_metrics_write_ptr(struct dst_entry *dst)
{
 unsigned long p = dst->_metrics;

 do { if (__builtin_constant_p(!p)) { if (!p) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (115), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (115), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(!p))); } } while (0);

 if (p & 0x1UL)
  return dst->ops->cow_metrics(dst, p);
 return ((u32 *)((p) & ~0x3UL));
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_init_metrics(struct dst_entry *dst,
        const u32 *src_metrics,
        bool read_only)
{
 dst->_metrics = ((unsigned long) src_metrics) |
  (read_only ? 0x1UL : 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_copy_metrics(struct dst_entry *dest, const struct dst_entry *src)
{
 u32 *dst_metrics = dst_metrics_write_ptr(dest);

 if (dst_metrics) {
  u32 *src_metrics = ((u32 *)(((src)->_metrics) & ~0x3UL));

  memcpy(dst_metrics, src_metrics, (__RTAX_MAX - 1) * sizeof(u32));
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 *dst_metrics_ptr(struct dst_entry *dst)
{
 return ((u32 *)(((dst)->_metrics) & ~0x3UL));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32
dst_metric_raw(const struct dst_entry *dst, const int metric)
{
 u32 *p = ((u32 *)(((dst)->_metrics) & ~0x3UL));

 return p[metric-1];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32
dst_metric(const struct dst_entry *dst, const int metric)
{
 ({ int __ret_warn_on = !!(metric == RTAX_HOPLIMIT || metric == RTAX_ADVMSS || metric == RTAX_MTU); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (162), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });


 return dst_metric_raw(dst, metric);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32
dst_metric_advmss(const struct dst_entry *dst)
{
 u32 advmss = dst_metric_raw(dst, RTAX_ADVMSS);

 if (!advmss)
  advmss = dst->ops->default_advmss(dst);

 return advmss;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_metric_set(struct dst_entry *dst, int metric, u32 val)
{
 u32 *p = dst_metrics_write_ptr(dst);

 if (p)
  p[metric-1] = val;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32
dst_feature(const struct dst_entry *dst, u32 feature)
{
 return dst_metric(dst, RTAX_FEATURES) & feature;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 dst_mtu(const struct dst_entry *dst)
{
 return dst->ops->mtu(dst);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long dst_metric_rtt(const struct dst_entry *dst, int metric)
{
 return msecs_to_jiffies(dst_metric(dst, metric));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32
dst_allfrag(const struct dst_entry *dst)
{
 int ret = dst_feature(dst, (1 << 3));
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
dst_metric_locked(const struct dst_entry *dst, int metric)
{
 return dst_metric(dst, RTAX_LOCK) & (1<<metric);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_hold(struct dst_entry *dst)
{




 do { extern void __compiletime_assert_227(void) ; if (!(!(__builtin_offsetof(struct dst_entry, __refcnt) & 63))) __compiletime_assert_227(); } while (0);
 ({ int __ret_warn_on = !!(atomic_inc_not_zero((&dst->__refcnt)) == 0); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (228), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (228), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_use_noref(struct dst_entry *dst, unsigned long time)
{
 if (__builtin_expect(!!(time != dst->lastuse), 0)) {
  dst->__use++;
  dst->lastuse = time;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_hold_and_use(struct dst_entry *dst, unsigned long time)
{
 dst_hold(dst);
 dst_use_noref(dst, time);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dst_entry *dst_clone(struct dst_entry *dst)
{
 if (dst)
  dst_hold(dst);
 return dst;
}

void dst_release(struct dst_entry *dst);

void dst_release_immediate(struct dst_entry *dst);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void refdst_drop(unsigned long refdst)
{
 if (!(refdst & 1UL))
  dst_release((struct dst_entry *)(refdst & ~(1UL)));
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_drop(struct sk_buff *skb)
{
 if (skb->_skb_refdst) {
  refdst_drop(skb->_skb_refdst);
  skb->_skb_refdst = 0UL;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_dst_copy(struct sk_buff *nskb, unsigned long refdst)
{
 nskb->_skb_refdst = refdst;
 if (!(nskb->_skb_refdst & 1UL))
  dst_clone(skb_dst(nskb));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb)
{
 __skb_dst_copy(nskb, oskb->_skb_refdst);
}
# 295 "/home/nathan/src/linux-next/include/net/dst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dst_hold_safe(struct dst_entry *dst)
{
 return atomic_inc_not_zero((&dst->__refcnt));
}
# 307 "/home/nathan/src/linux-next/include/net/dst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_dst_force(struct sk_buff *skb)
{
 if (skb_dst_is_noref(skb)) {
  struct dst_entry *dst = skb_dst(skb);

  ({ int __ret_warn_on = !!(!rcu_read_lock_held()); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (312), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/dst.h"), "i" (312), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
  if (!dst_hold_safe(dst))
   dst = ((void *)0);

  skb->_skb_refdst = (unsigned long)dst;
 }

 return skb->_skb_refdst != 0UL;
}
# 332 "/home/nathan/src/linux-next/include/net/dst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __skb_tunnel_rx(struct sk_buff *skb, struct net_device *dev,
       struct net *net)
{
 skb->dev = dev;






 skb_clear_hash_if_not_l4(skb);
 skb_set_queue_mapping(skb, 0);
 skb_scrub_packet(skb, !net_eq(net, dev_net(dev)));
}
# 357 "/home/nathan/src/linux-next/include/net/dst.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_tunnel_rx(struct sk_buff *skb, struct net_device *dev,
     struct net *net)
{

 dev->stats.rx_packets++;
 dev->stats.rx_bytes += skb->len;
 __skb_tunnel_rx(skb, dev, net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 dst_tclassid(const struct sk_buff *skb)
{







 return 0;
}

int dst_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_discard(struct sk_buff *skb)
{
 return dst_discard_out(&init_net, skb->sk, skb);
}
void *dst_alloc(struct dst_ops *ops, struct net_device *dev, int initial_ref,
  int initial_obsolete, unsigned short flags);
void dst_init(struct dst_entry *dst, struct dst_ops *ops,
       struct net_device *dev, int initial_ref, int initial_obsolete,
       unsigned short flags);
struct dst_entry *dst_destroy(struct dst_entry *dst);
void dst_dev_put(struct dst_entry *dst);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_confirm(struct dst_entry *dst)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *dst_neigh_lookup(const struct dst_entry *dst, const void *daddr)
{
 struct neighbour *n = dst->ops->neigh_lookup(dst, ((void *)0), daddr);
 return IS_ERR(n) ? ((void *)0) : n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *dst_neigh_lookup_skb(const struct dst_entry *dst,
           struct sk_buff *skb)
{
 struct neighbour *n = dst->ops->neigh_lookup(dst, skb, ((void *)0));
 return IS_ERR(n) ? ((void *)0) : n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_confirm_neigh(const struct dst_entry *dst,
         const void *daddr)
{
 if (dst->ops->confirm_neigh)
  dst->ops->confirm_neigh(dst, daddr);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_link_failure(struct sk_buff *skb)
{
 struct dst_entry *dst = skb_dst(skb);
 if (dst && dst->ops && dst->ops->link_failure)
  dst->ops->link_failure(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_set_expires(struct dst_entry *dst, int timeout)
{
 unsigned long expires = jiffies + timeout;

 if (expires == 0)
  expires = 1;

 if (dst->expires == 0 || (({ unsigned long __dummy; typeof(dst->expires) __dummy2; (void)(&__dummy == &__dummy2); 1; }) && ({ unsigned long __dummy; typeof(expires) __dummy2; (void)(&__dummy == &__dummy2); 1; }) && ((long)((expires) - (dst->expires)) < 0)))
  dst->expires = expires;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)
{
 return skb_dst(skb)->output(net, sk, skb);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int dst_input(struct sk_buff *skb)
{
 return skb_dst(skb)->input(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dst_entry *dst_check(struct dst_entry *dst, u32 cookie)
{
 if (dst->obsolete)
  dst = dst->ops->check(dst, cookie);
 return dst;
}


enum {
 XFRM_LOOKUP_ICMP = 1 << 0,
 XFRM_LOOKUP_QUEUE = 1 << 1,
 XFRM_LOOKUP_KEEP_DST_REF = 1 << 2,
};

struct flowi;
# 493 "/home/nathan/src/linux-next/include/net/dst.h"
struct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,
         const struct flowi *fl, const struct sock *sk,
         int flags);

struct dst_entry *xfrm_lookup_with_ifid(struct net *net,
     struct dst_entry *dst_orig,
     const struct flowi *fl,
     const struct sock *sk, int flags,
     u32 if_id);

struct dst_entry *xfrm_lookup_route(struct net *net, struct dst_entry *dst_orig,
        const struct flowi *fl, const struct sock *sk,
        int flags);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct xfrm_state *dst_xfrm(const struct dst_entry *dst)
{
 return dst->xfrm;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_update_pmtu(struct sk_buff *skb, u32 mtu)
{
 struct dst_entry *dst = skb_dst(skb);

 if (dst && dst->ops->update_pmtu)
  dst->ops->update_pmtu(dst, ((void *)0), skb, mtu, true);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_dst_update_pmtu_no_confirm(struct sk_buff *skb, u32 mtu)
{
 struct dst_entry *dst = skb_dst(skb);

 if (dst && dst->ops->update_pmtu)
  dst->ops->update_pmtu(dst, ((void *)0), skb, mtu, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_tunnel_check_pmtu(struct sk_buff *skb,
      struct dst_entry *encap_dst,
      int headroom)
{
 u32 encap_mtu = dst_mtu(encap_dst);

 if (skb->len > encap_mtu - headroom)
  skb_dst_update_pmtu_no_confirm(skb, encap_mtu - headroom);
}
# 66 "/home/nathan/src/linux-next/include/net/sock.h" 2

# 1 "/home/nathan/src/linux-next/include/net/tcp_states.h" 1
# 12 "/home/nathan/src/linux-next/include/net/tcp_states.h"
enum {
 TCP_ESTABLISHED = 1,
 TCP_SYN_SENT,
 TCP_SYN_RECV,
 TCP_FIN_WAIT1,
 TCP_FIN_WAIT2,
 TCP_TIME_WAIT,
 TCP_CLOSE,
 TCP_CLOSE_WAIT,
 TCP_LAST_ACK,
 TCP_LISTEN,
 TCP_CLOSING,
 TCP_NEW_SYN_RECV,

 TCP_MAX_STATES
};





enum {
 TCPF_ESTABLISHED = (1 << TCP_ESTABLISHED),
 TCPF_SYN_SENT = (1 << TCP_SYN_SENT),
 TCPF_SYN_RECV = (1 << TCP_SYN_RECV),
 TCPF_FIN_WAIT1 = (1 << TCP_FIN_WAIT1),
 TCPF_FIN_WAIT2 = (1 << TCP_FIN_WAIT2),
 TCPF_TIME_WAIT = (1 << TCP_TIME_WAIT),
 TCPF_CLOSE = (1 << TCP_CLOSE),
 TCPF_CLOSE_WAIT = (1 << TCP_CLOSE_WAIT),
 TCPF_LAST_ACK = (1 << TCP_LAST_ACK),
 TCPF_LISTEN = (1 << TCP_LISTEN),
 TCPF_CLOSING = (1 << TCP_CLOSING),
 TCPF_NEW_SYN_RECV = (1 << TCP_NEW_SYN_RECV),
};
# 68 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/net_tstamp.h" 1
# 17 "/home/nathan/src/linux-next/include/uapi/linux/net_tstamp.h"
enum {
 SOF_TIMESTAMPING_TX_HARDWARE = (1<<0),
 SOF_TIMESTAMPING_TX_SOFTWARE = (1<<1),
 SOF_TIMESTAMPING_RX_HARDWARE = (1<<2),
 SOF_TIMESTAMPING_RX_SOFTWARE = (1<<3),
 SOF_TIMESTAMPING_SOFTWARE = (1<<4),
 SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),
 SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),
 SOF_TIMESTAMPING_OPT_ID = (1<<7),
 SOF_TIMESTAMPING_TX_SCHED = (1<<8),
 SOF_TIMESTAMPING_TX_ACK = (1<<9),
 SOF_TIMESTAMPING_OPT_CMSG = (1<<10),
 SOF_TIMESTAMPING_OPT_TSONLY = (1<<11),
 SOF_TIMESTAMPING_OPT_STATS = (1<<12),
 SOF_TIMESTAMPING_OPT_PKTINFO = (1<<13),
 SOF_TIMESTAMPING_OPT_TX_SWHW = (1<<14),

 SOF_TIMESTAMPING_LAST = SOF_TIMESTAMPING_OPT_TX_SWHW,
 SOF_TIMESTAMPING_MASK = (SOF_TIMESTAMPING_LAST - 1) |
     SOF_TIMESTAMPING_LAST
};
# 62 "/home/nathan/src/linux-next/include/uapi/linux/net_tstamp.h"
struct hwtstamp_config {
 int flags;
 int tx_type;
 int rx_filter;
};


enum hwtstamp_tx_types {





 HWTSTAMP_TX_OFF,







 HWTSTAMP_TX_ON,
# 92 "/home/nathan/src/linux-next/include/uapi/linux/net_tstamp.h"
 HWTSTAMP_TX_ONESTEP_SYNC,







 HWTSTAMP_TX_ONESTEP_P2P,
};


enum hwtstamp_rx_filters {

 HWTSTAMP_FILTER_NONE,


 HWTSTAMP_FILTER_ALL,


 HWTSTAMP_FILTER_SOME,


 HWTSTAMP_FILTER_PTP_V1_L4_EVENT,

 HWTSTAMP_FILTER_PTP_V1_L4_SYNC,

 HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ,

 HWTSTAMP_FILTER_PTP_V2_L4_EVENT,

 HWTSTAMP_FILTER_PTP_V2_L4_SYNC,

 HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ,


 HWTSTAMP_FILTER_PTP_V2_L2_EVENT,

 HWTSTAMP_FILTER_PTP_V2_L2_SYNC,

 HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ,


 HWTSTAMP_FILTER_PTP_V2_EVENT,

 HWTSTAMP_FILTER_PTP_V2_SYNC,

 HWTSTAMP_FILTER_PTP_V2_DELAY_REQ,


 HWTSTAMP_FILTER_NTP_ALL,
};


struct scm_ts_pktinfo {
 __u32 if_index;
 __u32 pkt_length;
 __u32 reserved[2];
};





enum txtime_flags {
 SOF_TXTIME_DEADLINE_MODE = (1 << 0),
 SOF_TXTIME_REPORT_ERRORS = (1 << 1),

 SOF_TXTIME_FLAGS_LAST = SOF_TXTIME_REPORT_ERRORS,
 SOF_TXTIME_FLAGS_MASK = (SOF_TXTIME_FLAGS_LAST - 1) |
     SOF_TXTIME_FLAGS_LAST
};

struct sock_txtime {
 __kernel_clockid_t clockid;
 __u32 flags;
};
# 69 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 1 "/home/nathan/src/linux-next/include/net/l3mdev.h" 1
# 11 "/home/nathan/src/linux-next/include/net/l3mdev.h"
# 1 "/home/nathan/src/linux-next/include/net/fib_rules.h" 1







# 1 "/home/nathan/src/linux-next/include/uapi/linux/fib_rules.h" 1
# 19 "/home/nathan/src/linux-next/include/uapi/linux/fib_rules.h"
struct fib_rule_hdr {
 __u8 family;
 __u8 dst_len;
 __u8 src_len;
 __u8 tos;

 __u8 table;
 __u8 res1;
 __u8 res2;
 __u8 action;

 __u32 flags;
};

struct fib_rule_uid_range {
 __u32 start;
 __u32 end;
};

struct fib_rule_port_range {
 __u16 start;
 __u16 end;
};

enum {
 FRA_UNSPEC,
 FRA_DST,
 FRA_SRC,
 FRA_IIFNAME,

 FRA_GOTO,
 FRA_UNUSED2,
 FRA_PRIORITY,
 FRA_UNUSED3,
 FRA_UNUSED4,
 FRA_UNUSED5,
 FRA_FWMARK,
 FRA_FLOW,
 FRA_TUN_ID,
 FRA_SUPPRESS_IFGROUP,
 FRA_SUPPRESS_PREFIXLEN,
 FRA_TABLE,
 FRA_FWMASK,
 FRA_OIFNAME,
 FRA_PAD,
 FRA_L3MDEV,
 FRA_UID_RANGE,
 FRA_PROTOCOL,
 FRA_IP_PROTO,
 FRA_SPORT_RANGE,
 FRA_DPORT_RANGE,
 __FRA_MAX
};



enum {
 FR_ACT_UNSPEC,
 FR_ACT_TO_TBL,
 FR_ACT_GOTO,
 FR_ACT_NOP,
 FR_ACT_RES3,
 FR_ACT_RES4,
 FR_ACT_BLACKHOLE,
 FR_ACT_UNREACHABLE,
 FR_ACT_PROHIBIT,
 __FR_ACT_MAX,
};
# 9 "/home/nathan/src/linux-next/include/net/fib_rules.h" 2



# 1 "/home/nathan/src/linux-next/include/net/fib_notifier.h" 1







struct module;

struct fib_notifier_info {
 int family;
 struct netlink_ext_ack *extack;
};

enum fib_event_type {
 FIB_EVENT_ENTRY_REPLACE,
 FIB_EVENT_ENTRY_APPEND,
 FIB_EVENT_ENTRY_ADD,
 FIB_EVENT_ENTRY_DEL,
 FIB_EVENT_RULE_ADD,
 FIB_EVENT_RULE_DEL,
 FIB_EVENT_NH_ADD,
 FIB_EVENT_NH_DEL,
 FIB_EVENT_VIF_ADD,
 FIB_EVENT_VIF_DEL,
};

struct fib_notifier_ops {
 int family;
 struct list_head list;
 unsigned int (*fib_seq_read)(struct net *net);
 int (*fib_dump)(struct net *net, struct notifier_block *nb,
   struct netlink_ext_ack *extack);
 struct module *owner;
 struct callback_head rcu;
};

int call_fib_notifier(struct notifier_block *nb,
        enum fib_event_type event_type,
        struct fib_notifier_info *info);
int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
         struct fib_notifier_info *info);
int register_fib_notifier(struct net *net, struct notifier_block *nb,
     void (*cb)(struct notifier_block *nb),
     struct netlink_ext_ack *extack);
int unregister_fib_notifier(struct net *net, struct notifier_block *nb);
struct fib_notifier_ops *
fib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net);
void fib_notifier_ops_unregister(struct fib_notifier_ops *ops);
# 13 "/home/nathan/src/linux-next/include/net/fib_rules.h" 2

struct fib_kuid_range {
 kuid_t start;
 kuid_t end;
};

struct fib_rule {
 struct list_head list;
 int iifindex;
 int oifindex;
 u32 mark;
 u32 mark_mask;
 u32 flags;
 u32 table;
 u8 action;
 u8 l3mdev;
 u8 proto;
 u8 ip_proto;
 u32 target;
 __be64 tun_id;
 struct fib_rule *ctarget;
 struct net *fr_net;

 refcount_t refcnt;
 u32 pref;
 int suppress_ifgroup;
 int suppress_prefixlen;
 char iifname[16];
 char oifname[16];
 struct fib_kuid_range uid_range;
 struct fib_rule_port_range sport_range;
 struct fib_rule_port_range dport_range;
 struct callback_head rcu;
};

struct fib_lookup_arg {
 void *lookup_ptr;
 const void *lookup_data;
 void *result;
 struct fib_rule *rule;
 u32 table;
 int flags;


};

struct fib_rules_ops {
 int family;
 struct list_head list;
 int rule_size;
 int addr_size;
 int unresolved_rules;
 int nr_goto_rules;
 unsigned int fib_rules_seq;

 int (*action)(struct fib_rule *,
       struct flowi *, int,
       struct fib_lookup_arg *);
 bool (*suppress)(struct fib_rule *,
         struct fib_lookup_arg *);
 int (*match)(struct fib_rule *,
      struct flowi *, int);
 int (*configure)(struct fib_rule *,
          struct sk_buff *,
          struct fib_rule_hdr *,
          struct nlattr **,
          struct netlink_ext_ack *);
 int (*delete)(struct fib_rule *);
 int (*compare)(struct fib_rule *,
        struct fib_rule_hdr *,
        struct nlattr **);
 int (*fill)(struct fib_rule *, struct sk_buff *,
     struct fib_rule_hdr *);
 size_t (*nlmsg_payload)(struct fib_rule *);



 void (*flush_cache)(struct fib_rules_ops *ops);

 int nlgroup;
 const struct nla_policy *policy;
 struct list_head rules_list;
 struct module *owner;
 struct net *fro_net;
 struct callback_head rcu;
};

struct fib_rule_notifier_info {
 struct fib_notifier_info info;
 struct fib_rule *rule;
};
# 124 "/home/nathan/src/linux-next/include/net/fib_rules.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fib_rule_get(struct fib_rule *rule)
{
 refcount_inc(&rule->refcnt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fib_rule_put(struct fib_rule *rule)
{
 if (refcount_dec_and_test(&rule->refcnt))
  do { typeof (rule) ___p = (rule); if (___p) do { do { extern void __compiletime_assert_132(void) ; if (!(!(!((__builtin_offsetof(typeof(*(rule)), rcu)) < 4096)))) __compiletime_assert_132(); } while (0); kfree_call_rcu(&((___p)->rcu), (rcu_callback_t)(unsigned long)(__builtin_offsetof(typeof(*(rule)), rcu))); } while (0); } while (0);
}
# 142 "/home/nathan/src/linux-next/include/net/fib_rules.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 fib_rule_get_table(struct fib_rule *rule,
         struct fib_lookup_arg *arg)
{
 return rule->table;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 frh_get_table(struct fib_rule_hdr *frh, struct nlattr **nla)
{
 if (nla[FRA_TABLE])
  return nla_get_u32(nla[FRA_TABLE]);
 return frh->table;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib_rule_port_range_set(const struct fib_rule_port_range *range)
{
 return range->start != 0 && range->end != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib_rule_port_inrange(const struct fib_rule_port_range *a,
      __be16 port)
{
 return (( __u16)(__be16)(port)) >= a->start &&
  (( __u16)(__be16)(port)) <= a->end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib_rule_port_range_valid(const struct fib_rule_port_range *a)
{
 return a->start != 0 && a->end != 0 && a->end < 0xffff &&
  a->start <= a->end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib_rule_port_range_compare(struct fib_rule_port_range *a,
            struct fib_rule_port_range *b)
{
 return a->start == b->start &&
  a->end == b->end;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib_rule_requires_fldissect(struct fib_rule *rule)
{
 return rule->iifindex != 1 && (rule->ip_proto ||
  fib_rule_port_range_set(&rule->sport_range) ||
  fib_rule_port_range_set(&rule->dport_range));
}

struct fib_rules_ops *fib_rules_register(const struct fib_rules_ops *,
      struct net *);
void fib_rules_unregister(struct fib_rules_ops *);

int fib_rules_lookup(struct fib_rules_ops *, struct flowi *, int flags,
       struct fib_lookup_arg *);
int fib_default_rule_add(struct fib_rules_ops *, u32 pref, u32 table,
    u32 flags);
bool fib_rule_matchall(const struct fib_rule *rule);
int fib_rules_dump(struct net *net, struct notifier_block *nb, int family,
     struct netlink_ext_ack *extack);
unsigned int fib_rules_seq_read(struct net *net, int family);

int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr *nlh,
     struct netlink_ext_ack *extack);
int fib_nl_delrule(struct sk_buff *skb, struct nlmsghdr *nlh,
     struct netlink_ext_ack *extack);
# 12 "/home/nathan/src/linux-next/include/net/l3mdev.h" 2
# 25 "/home/nathan/src/linux-next/include/net/l3mdev.h"
struct l3mdev_ops {
 u32 (*l3mdev_fib_table)(const struct net_device *dev);
 struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *dev,
       struct sk_buff *skb, u16 proto);
 struct sk_buff * (*l3mdev_l3_out)(struct net_device *dev,
       struct sock *sk, struct sk_buff *skb,
       u16 proto);


 struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *dev,
       struct flowi6 *fl6);
};
# 204 "/home/nathan/src/linux-next/include/net/l3mdev.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int l3mdev_master_ifindex_rcu(const struct net_device *dev)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int l3mdev_master_ifindex(struct net_device *dev)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int l3mdev_master_ifindex_by_index(struct net *net, int ifindex)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int l3mdev_master_upper_ifindex_by_index_rcu(struct net *net, int ifindex)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int l3mdev_master_upper_ifindex_by_index(struct net *net, int ifindex)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct net_device *l3mdev_master_dev_rcu(const struct net_device *dev)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l3mdev_fib_table_rcu(const struct net_device *dev)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l3mdev_fib_table(const struct net_device *dev)
{
 return 0;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 l3mdev_fib_table_by_index(struct net *net, int ifindex)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool netif_index_is_l3_master(struct net *net, int ifindex)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct dst_entry *l3mdev_link_scope_lookup(struct net *net, struct flowi6 *fl6)
{
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct sk_buff *l3mdev_ip_rcv(struct sk_buff *skb)
{
 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct sk_buff *l3mdev_ip6_rcv(struct sk_buff *skb)
{
 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct sk_buff *l3mdev_ip_out(struct sock *sk, struct sk_buff *skb)
{
 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct sk_buff *l3mdev_ip6_out(struct sock *sk, struct sk_buff *skb)
{
 return skb;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int l3mdev_fib_rule_match(struct net *net, struct flowi *fl,
     struct fib_lookup_arg *arg)
{
 return 1;
}
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void l3mdev_update_flow(struct net *net, struct flowi *fl)
{
}
# 70 "/home/nathan/src/linux-next/include/net/sock.h" 2
# 94 "/home/nathan/src/linux-next/include/net/sock.h"
typedef struct {
 spinlock_t slock;
 int owned;
 wait_queue_head_t wq;
# 107 "/home/nathan/src/linux-next/include/net/sock.h"
} socket_lock_t;

struct sock;
struct proto;
struct net;

typedef __u32 __portpair;
typedef __u64 __addrpair;
# 146 "/home/nathan/src/linux-next/include/net/sock.h"
struct sock_common {



 union {
  __addrpair skc_addrpair;
  struct {
   __be32 skc_daddr;
   __be32 skc_rcv_saddr;
  };
 };
 union {
  unsigned int skc_hash;
  __u16 skc_u16hashes[2];
 };

 union {
  __portpair skc_portpair;
  struct {
   __be16 skc_dport;
   __u16 skc_num;
  };
 };

 unsigned short skc_family;
 volatile unsigned char skc_state;
 unsigned char skc_reuse:4;
 unsigned char skc_reuseport:1;
 unsigned char skc_ipv6only:1;
 unsigned char skc_net_refcnt:1;
 int skc_bound_dev_if;
 union {
  struct hlist_node skc_bind_node;
  struct hlist_node skc_portaddr_node;
 };
 struct proto *skc_prot;
 possible_net_t skc_net;


 struct in6_addr skc_v6_daddr;
 struct in6_addr skc_v6_rcv_saddr;


 atomic64_t skc_cookie;






 union {
  unsigned long skc_flags;
  struct sock *skc_listener;
  struct inet_timewait_death_row *skc_tw_dr;
 };





 int skc_dontcopy_begin[0];

 union {
  struct hlist_node skc_node;
  struct hlist_nulls_node skc_nulls_node;
 };
 unsigned short skc_tx_queue_mapping;

 unsigned short skc_rx_queue_mapping;

 union {
  int skc_incoming_cpu;
  u32 skc_rcv_wnd;
  u32 skc_tw_rcv_nxt;
 };

 refcount_t skc_refcnt;

 int skc_dontcopy_end[0];
 union {
  u32 skc_rxhash;
  u32 skc_window_clamp;
  u32 skc_tw_snd_nxt;
 };

};

struct bpf_sk_storage;
# 323 "/home/nathan/src/linux-next/include/net/sock.h"
struct sock {




 struct sock_common __sk_common;
# 363 "/home/nathan/src/linux-next/include/net/sock.h"
 socket_lock_t sk_lock;
 atomic_t sk_drops;
 int sk_rcvlowat;
 struct sk_buff_head sk_error_queue;
 struct sk_buff *sk_rx_skb_cache;
 struct sk_buff_head sk_receive_queue;
# 377 "/home/nathan/src/linux-next/include/net/sock.h"
 struct {
  atomic_t rmem_alloc;
  int len;
  struct sk_buff *head;
  struct sk_buff *tail;
 } sk_backlog;


 int sk_forward_alloc;

 unsigned int sk_ll_usec;

 unsigned int sk_napi_id;

 int sk_rcvbuf;

 struct sk_filter *sk_filter;
 union {
  struct socket_wq *sk_wq;
  struct socket_wq *sk_wq_raw;
 };

 struct xfrm_policy *sk_policy[2];

 struct dst_entry *sk_rx_dst;
 struct dst_entry *sk_dst_cache;
 atomic_t sk_omem_alloc;
 int sk_sndbuf;


 int sk_wmem_queued;
 refcount_t sk_wmem_alloc;
 unsigned long sk_tsq_flags;
 union {
  struct sk_buff *sk_send_head;
  struct rb_root tcp_rtx_queue;
 };
 struct sk_buff *sk_tx_skb_cache;
 struct sk_buff_head sk_write_queue;
 __s32 sk_peek_off;
 int sk_write_pending;
 __u32 sk_dst_pending_confirm;
 u32 sk_pacing_status;
 long sk_sndtimeo;
 struct timer_list sk_timer;
 __u32 sk_priority;
 __u32 sk_mark;
 unsigned long sk_pacing_rate;
 unsigned long sk_max_pacing_rate;
 struct page_frag sk_frag;
 netdev_features_t sk_route_caps;
 netdev_features_t sk_route_nocaps;
 netdev_features_t sk_route_forced_caps;
 int sk_gso_type;
 unsigned int sk_gso_max_size;
 gfp_t sk_allocation;
 __u32 sk_txhash;





 u8 sk_padding : 1,
    sk_kern_sock : 1,
    sk_no_check_tx : 1,
    sk_no_check_rx : 1,
    sk_userlocks : 4;
 u8 sk_pacing_shift;
 u16 sk_type;
 u16 sk_protocol;
 u16 sk_gso_max_segs;
 unsigned long sk_lingertime;
 struct proto *sk_prot_creator;
 rwlock_t sk_callback_lock;
 int sk_err,
    sk_err_soft;
 u32 sk_ack_backlog;
 u32 sk_max_ack_backlog;
 kuid_t sk_uid;
 struct pid *sk_peer_pid;
 const struct cred *sk_peer_cred;
 long sk_rcvtimeo;
 ktime_t sk_stamp;



 u16 sk_tsflags;
 u8 sk_shutdown;
 u32 sk_tskey;
 atomic_t sk_zckey;

 u8 sk_clockid;
 u8 sk_txtime_deadline_mode : 1,
    sk_txtime_report_errors : 1,
    sk_txtime_unused : 6;

 struct socket *sk_socket;
 void *sk_user_data;



 struct sock_cgroup_data sk_cgrp_data;
 struct mem_cgroup *sk_memcg;
 void (*sk_state_change)(struct sock *sk);
 void (*sk_data_ready)(struct sock *sk);
 void (*sk_write_space)(struct sock *sk);
 void (*sk_error_report)(struct sock *sk);
 int (*sk_backlog_rcv)(struct sock *sk,
        struct sk_buff *skb);





 void (*sk_destruct)(struct sock *sk);
 struct sock_reuseport *sk_reuseport_cb;

 struct bpf_sk_storage *sk_bpf_storage;

 struct callback_head sk_rcu;
};

enum sk_pacing {
 SK_PACING_NONE = 0,
 SK_PACING_NEEDED = 1,
 SK_PACING_FQ = 2,
};
# 521 "/home/nathan/src/linux-next/include/net/sock.h"
int sk_set_peek_off(struct sock *sk, int val);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_peek_offset(struct sock *sk, int flags)
{
 if (__builtin_expect(!!(flags & 2), 0)) {
  return ({ union { typeof(sk->sk_peek_off) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_peek_off), __u.__c, sizeof(sk->sk_peek_off)); else __read_once_size_nocheck(&(sk->sk_peek_off), __u.__c, sizeof(sk->sk_peek_off)); do { } while (0); __u.__val; });
 }

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_peek_offset_bwd(struct sock *sk, int val)
{
 s32 off = ({ union { typeof(sk->sk_peek_off) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_peek_off), __u.__c, sizeof(sk->sk_peek_off)); else __read_once_size_nocheck(&(sk->sk_peek_off), __u.__c, sizeof(sk->sk_peek_off)); do { } while (0); __u.__val; });

 if (__builtin_expect(!!(off >= 0), 0)) {
  off = __builtin_choose_expr(((!!(sizeof((typeof((s32)(off - val)) *)1 == (typeof((s32)(0)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((s32)(off - val)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((s32)(0)) * 0l)) : (int *)8))))), (((s32)(off - val)) > ((s32)(0)) ? ((s32)(off - val)) : ((s32)(0))), ({ typeof((s32)(off - val)) __UNIQUE_ID___x72 = ((s32)(off - val)); typeof((s32)(0)) __UNIQUE_ID___y73 = ((s32)(0)); ((__UNIQUE_ID___x72) > (__UNIQUE_ID___y73) ? (__UNIQUE_ID___x72) : (__UNIQUE_ID___y73)); }));
  ({ union { typeof(sk->sk_peek_off) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_peek_off)) (off) }; __write_once_size(&(sk->sk_peek_off), __u.__c, sizeof(sk->sk_peek_off)); __u.__val; });
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_peek_offset_fwd(struct sock *sk, int val)
{
 sk_peek_offset_bwd(sk, -val);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_entry(const struct hlist_node *node)
{
 return ({ void *__mptr = (void *)(node); do { extern void __compiletime_assert_552(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node)), typeof(((struct sock *)0)->__sk_common.skc_node)) && !__builtin_types_compatible_p(typeof(*(node)), typeof(void))))) __compiletime_assert_552(); } while (0); ((struct sock *)(__mptr - __builtin_offsetof(struct sock, __sk_common.skc_node))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *__sk_head(const struct hlist_head *head)
{
 return ({ void *__mptr = (void *)(head->first); do { extern void __compiletime_assert_557(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->first)), typeof(((struct sock *)0)->__sk_common.skc_node)) && !__builtin_types_compatible_p(typeof(*(head->first)), typeof(void))))) __compiletime_assert_557(); } while (0); ((struct sock *)(__mptr - __builtin_offsetof(struct sock, __sk_common.skc_node))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_head(const struct hlist_head *head)
{
 return hlist_empty(head) ? ((void *)0) : __sk_head(head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *__sk_nulls_head(const struct hlist_nulls_head *head)
{
 return ({ void *__mptr = (void *)(head->first); do { extern void __compiletime_assert_567(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(head->first)), typeof(((struct sock *)0)->__sk_common.skc_nulls_node)) && !__builtin_types_compatible_p(typeof(*(head->first)), typeof(void))))) __compiletime_assert_567(); } while (0); ((struct sock *)(__mptr - __builtin_offsetof(struct sock, __sk_common.skc_nulls_node))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_nulls_head(const struct hlist_nulls_head *head)
{
 return hlist_nulls_empty(head) ? ((void *)0) : __sk_nulls_head(head);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_next(const struct sock *sk)
{
 return ({ typeof(sk->__sk_common.skc_node.next) ____ptr = (sk->__sk_common.skc_node.next); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_577(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((struct sock *)0)->__sk_common.skc_node)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_577(); } while (0); ((struct sock *)(__mptr - __builtin_offsetof(struct sock, __sk_common.skc_node))); }) : ((void *)0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_nulls_next(const struct sock *sk)
{
 return (!is_a_nulls(sk->__sk_common.skc_nulls_node.next)) ?
  ({ void *__mptr = (void *)(sk->__sk_common.skc_nulls_node.next); do { extern void __compiletime_assert_584(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(sk->__sk_common.skc_nulls_node.next)), typeof(((struct sock *)0)->__sk_common.skc_nulls_node)) && !__builtin_types_compatible_p(typeof(*(sk->__sk_common.skc_nulls_node.next)), typeof(void))))) __compiletime_assert_584(); } while (0); ((struct sock *)(__mptr - __builtin_offsetof(struct sock, __sk_common.skc_nulls_node))); }) :

  ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_unhashed(const struct sock *sk)
{
 return hlist_unhashed(&sk->__sk_common.skc_node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_hashed(const struct sock *sk)
{
 return !sk_unhashed(sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_node_init(struct hlist_node *node)
{
 node->pprev = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_nulls_node_init(struct hlist_nulls_node *node)
{
 node->pprev = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_del_node(struct sock *sk)
{
 __hlist_del(&sk->__sk_common.skc_node);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __sk_del_node_init(struct sock *sk)
{
 if (sk_hashed(sk)) {
  __sk_del_node(sk);
  sk_node_init(&sk->__sk_common.skc_node);
  return true;
 }
 return false;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void sock_hold(struct sock *sk)
{
 refcount_inc(&sk->__sk_common.skc_refcnt);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__always_inline__)) void __sock_put(struct sock *sk)
{
 refcount_dec(&sk->__sk_common.skc_refcnt);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_del_node_init(struct sock *sk)
{
 bool rc = __sk_del_node_init(sk);

 if (rc) {

  ({ int __ret_warn_on = !!(refcount_read(&sk->__sk_common.skc_refcnt) == 1); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (649), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (649), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
  __sock_put(sk);
 }
 return rc;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __sk_nulls_del_node_init_rcu(struct sock *sk)
{
 if (sk_hashed(sk)) {
  hlist_nulls_del_init_rcu(&sk->__sk_common.skc_nulls_node);
  return true;
 }
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_nulls_del_node_init_rcu(struct sock *sk)
{
 bool rc = __sk_nulls_del_node_init_rcu(sk);

 if (rc) {

  ({ int __ret_warn_on = !!(refcount_read(&sk->__sk_common.skc_refcnt) == 1); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (671), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (671), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
  __sock_put(sk);
 }
 return rc;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_add_node(struct sock *sk, struct hlist_head *list)
{
 hlist_add_head(&sk->__sk_common.skc_node, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_add_node(struct sock *sk, struct hlist_head *list)
{
 sock_hold(sk);
 __sk_add_node(sk, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_add_node_rcu(struct sock *sk, struct hlist_head *list)
{
 sock_hold(sk);
 if (1 && sk->__sk_common.skc_reuseport &&
     sk->__sk_common.skc_family == 10)
  hlist_add_tail_rcu(&sk->__sk_common.skc_node, list);
 else
  hlist_add_head_rcu(&sk->__sk_common.skc_node, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_add_node_tail_rcu(struct sock *sk, struct hlist_head *list)
{
 sock_hold(sk);
 hlist_add_tail_rcu(&sk->__sk_common.skc_node, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_nulls_add_node_rcu(struct sock *sk, struct hlist_nulls_head *list)
{
 hlist_nulls_add_head_rcu(&sk->__sk_common.skc_nulls_node, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_nulls_add_node_tail_rcu(struct sock *sk, struct hlist_nulls_head *list)
{
 hlist_nulls_add_tail_rcu(&sk->__sk_common.skc_nulls_node, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_nulls_add_node_rcu(struct sock *sk, struct hlist_nulls_head *list)
{
 sock_hold(sk);
 __sk_nulls_add_node_rcu(sk, list);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_del_bind_node(struct sock *sk)
{
 __hlist_del(&sk->__sk_common.skc_bind_node);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_add_bind_node(struct sock *sk,
     struct hlist_head *list)
{
 hlist_add_head(&sk->__sk_common.skc_bind_node, list);
}
# 763 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct user_namespace *sk_user_ns(struct sock *sk)
{




 return sk->sk_socket->file->f_cred->user_ns;
}


enum sock_flags {
 SOCK_DEAD,
 SOCK_DONE,
 SOCK_URGINLINE,
 SOCK_KEEPOPEN,
 SOCK_LINGER,
 SOCK_DESTROY,
 SOCK_BROADCAST,
 SOCK_TIMESTAMP,
 SOCK_ZAPPED,
 SOCK_USE_WRITE_QUEUE,
 SOCK_DBG,
 SOCK_RCVTSTAMP,
 SOCK_RCVTSTAMPNS,
 SOCK_LOCALROUTE,
 SOCK_QUEUE_SHRUNK,
 SOCK_MEMALLOC,
 SOCK_TIMESTAMPING_RX_SOFTWARE,
 SOCK_FASYNC,
 SOCK_RXQ_OVFL,
 SOCK_ZEROCOPY,
 SOCK_WIFI_STATUS,
 SOCK_NOFCS,



 SOCK_FILTER_LOCKED,
 SOCK_SELECT_ERR_QUEUE,
 SOCK_RCU_FREE,
 SOCK_TXTIME,
 SOCK_XDP,
 SOCK_TSTAMP_NEW,
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_copy_flags(struct sock *nsk, struct sock *osk)
{
 nsk->__sk_common.skc_flags = osk->__sk_common.skc_flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_set_flag(struct sock *sk, enum sock_flags flag)
{
 __set_bit(flag, &sk->__sk_common.skc_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_reset_flag(struct sock *sk, enum sock_flags flag)
{
 __clear_bit(flag, &sk->__sk_common.skc_flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sock_flag(const struct sock *sk, enum sock_flags flag)
{
 return test_bit(flag, &sk->__sk_common.skc_flags);
}


extern struct static_key_false memalloc_socks_key;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_memalloc_socks(void)
{
 return ({ bool branch; if (__builtin_types_compatible_p(typeof(*&memalloc_socks_key), struct static_key_true)) branch = arch_static_branch_jump(&(&memalloc_socks_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&memalloc_socks_key), struct static_key_false)) branch = arch_static_branch(&(&memalloc_socks_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); });
}
# 844 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gfp_t sk_gfp_mask(const struct sock *sk, gfp_t gfp_mask)
{
 return gfp_mask | (sk->sk_allocation & (( gfp_t)0x20000u));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_acceptq_removed(struct sock *sk)
{
 ({ union { typeof(sk->sk_ack_backlog) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_ack_backlog)) (sk->sk_ack_backlog - 1) }; __write_once_size(&(sk->sk_ack_backlog), __u.__c, sizeof(sk->sk_ack_backlog)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_acceptq_added(struct sock *sk)
{
 ({ union { typeof(sk->sk_ack_backlog) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_ack_backlog)) (sk->sk_ack_backlog + 1) }; __write_once_size(&(sk->sk_ack_backlog), __u.__c, sizeof(sk->sk_ack_backlog)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_acceptq_is_full(const struct sock *sk)
{
 return ({ union { typeof(sk->sk_ack_backlog) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_ack_backlog), __u.__c, sizeof(sk->sk_ack_backlog)); else __read_once_size_nocheck(&(sk->sk_ack_backlog), __u.__c, sizeof(sk->sk_ack_backlog)); do { } while (0); __u.__val; }) > ({ union { typeof(sk->sk_max_ack_backlog) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_max_ack_backlog), __u.__c, sizeof(sk->sk_max_ack_backlog)); else __read_once_size_nocheck(&(sk->sk_max_ack_backlog), __u.__c, sizeof(sk->sk_max_ack_backlog)); do { } while (0); __u.__val; });
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_stream_min_wspace(const struct sock *sk)
{
 return ({ union { typeof(sk->sk_wmem_queued) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); else __read_once_size_nocheck(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); do { } while (0); __u.__val; }) >> 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_stream_wspace(const struct sock *sk)
{
 return ({ union { typeof(sk->sk_sndbuf) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); else __read_once_size_nocheck(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); do { } while (0); __u.__val; }) - ({ union { typeof(sk->sk_wmem_queued) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); else __read_once_size_nocheck(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); do { } while (0); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_wmem_queued_add(struct sock *sk, int val)
{
 ({ union { typeof(sk->sk_wmem_queued) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_wmem_queued)) (sk->sk_wmem_queued + val) }; __write_once_size(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); __u.__val; });
}

void sk_stream_write_space(struct sock *sk);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __sk_add_backlog(struct sock *sk, struct sk_buff *skb)
{

 skb_dst_force(skb);

 if (!sk->sk_backlog.tail)
  ({ union { typeof(sk->sk_backlog.head) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_backlog.head)) (skb) }; __write_once_size(&(sk->sk_backlog.head), __u.__c, sizeof(sk->sk_backlog.head)); __u.__val; });
 else
  sk->sk_backlog.tail->next = skb;

 ({ union { typeof(sk->sk_backlog.tail) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_backlog.tail)) (skb) }; __write_once_size(&(sk->sk_backlog.tail), __u.__c, sizeof(sk->sk_backlog.tail)); __u.__val; });
 skb->next = ((void *)0);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_rcvqueues_full(const struct sock *sk, unsigned int limit)
{
 unsigned int qsize = sk->sk_backlog.len + atomic_read(&sk->sk_backlog.rmem_alloc);

 return qsize > limit;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __attribute__((__warn_unused_result__)) int sk_add_backlog(struct sock *sk, struct sk_buff *skb,
           unsigned int limit)
{
 if (sk_rcvqueues_full(sk, limit))
  return -105;






 if (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC))
  return -12;

 __sk_add_backlog(sk, skb);
 sk->sk_backlog.len += skb->truesize;
 return 0;
}

int __sk_backlog_rcv(struct sock *sk, struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_backlog_rcv(struct sock *sk, struct sk_buff *skb)
{
 if (sk_memalloc_socks() && skb_pfmemalloc(skb))
  return __sk_backlog_rcv(sk, skb);

 return sk->sk_backlog_rcv(sk, skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_incoming_cpu_update(struct sock *sk)
{
 int cpu = (local_paca->paca_index);

 if (__builtin_expect(!!(({ union { typeof(sk->__sk_common.skc_incoming_cpu) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->__sk_common.skc_incoming_cpu), __u.__c, sizeof(sk->__sk_common.skc_incoming_cpu)); else __read_once_size_nocheck(&(sk->__sk_common.skc_incoming_cpu), __u.__c, sizeof(sk->__sk_common.skc_incoming_cpu)); do { } while (0); __u.__val; }) != cpu), 0))
  ({ union { typeof(sk->__sk_common.skc_incoming_cpu) __val; char __c[1]; } __u = { .__val = ( typeof(sk->__sk_common.skc_incoming_cpu)) (cpu) }; __write_once_size(&(sk->__sk_common.skc_incoming_cpu), __u.__c, sizeof(sk->__sk_common.skc_incoming_cpu)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_rps_record_flow_hash(__u32 hash)
{

 struct rps_sock_flow_table *sock_flow_table;

 rcu_read_lock();
 sock_flow_table = ({ typeof(*(rps_sock_flow_table)) *________p1 = (typeof(*(rps_sock_flow_table)) *)({ union { typeof((rps_sock_flow_table)) __val; char __c[1]; } __u; if (1) __read_once_size(&((rps_sock_flow_table)), __u.__c, sizeof((rps_sock_flow_table))); else __read_once_size_nocheck(&((rps_sock_flow_table)), __u.__c, sizeof((rps_sock_flow_table))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(rps_sock_flow_table)) *)(________p1)); });
 rps_record_sock_flow(sock_flow_table, hash);
 rcu_read_unlock();

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_rps_record_flow(const struct sock *sk)
{

 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&rfs_needed), struct static_key_true)) branch = arch_static_branch_jump(&(&rfs_needed)->key, false); else if (__builtin_types_compatible_p(typeof(*&rfs_needed), struct static_key_false)) branch = arch_static_branch(&(&rfs_needed)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) {
# 975 "/home/nathan/src/linux-next/include/net/sock.h"
  if (sk->__sk_common.skc_state == TCP_ESTABLISHED)
   sock_rps_record_flow_hash(sk->__sk_common.skc_rxhash);
 }

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_rps_save_rxhash(struct sock *sk,
     const struct sk_buff *skb)
{

 if (__builtin_expect(!!(sk->__sk_common.skc_rxhash != skb->hash), 0))
  sk->__sk_common.skc_rxhash = skb->hash;

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_rps_reset_rxhash(struct sock *sk)
{

 sk->__sk_common.skc_rxhash = 0;

}
# 1012 "/home/nathan/src/linux-next/include/net/sock.h"
int sk_stream_wait_connect(struct sock *sk, long *timeo_p);
int sk_stream_wait_memory(struct sock *sk, long *timeo_p);
void sk_stream_wait_close(struct sock *sk, long timeo_p);
int sk_stream_error(struct sock *sk, int flags, int err);
void sk_stream_kill_queues(struct sock *sk);
void sk_set_memalloc(struct sock *sk);
void sk_clear_memalloc(struct sock *sk);

void __sk_flush_backlog(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_flush_backlog(struct sock *sk)
{
 if (__builtin_expect(!!(({ union { typeof(sk->sk_backlog.tail) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_backlog.tail), __u.__c, sizeof(sk->sk_backlog.tail)); else __read_once_size_nocheck(&(sk->sk_backlog.tail), __u.__c, sizeof(sk->sk_backlog.tail)); do { } while (0); __u.__val; })), 0)) {
  __sk_flush_backlog(sk);
  return true;
 }
 return false;
}

int sk_wait_data(struct sock *sk, long *timeo, const struct sk_buff *skb);

struct request_sock_ops;
struct timewait_sock_ops;
struct inet_hashinfo;
struct raw_hashinfo;
struct smc_hashinfo;
struct module;





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_prot_clear_nulls(struct sock *sk, int size)
{
 if (__builtin_offsetof(struct sock, __sk_common.skc_node.next) != 0)
  memset(sk, 0, __builtin_offsetof(struct sock, __sk_common.skc_node.next));
 memset(&sk->__sk_common.skc_node.pprev, 0,
        size - __builtin_offsetof(struct sock, __sk_common.skc_node.pprev));
}




struct proto {
 void (*close)(struct sock *sk,
     long timeout);
 int (*pre_connect)(struct sock *sk,
     struct sockaddr *uaddr,
     int addr_len);
 int (*connect)(struct sock *sk,
     struct sockaddr *uaddr,
     int addr_len);
 int (*disconnect)(struct sock *sk, int flags);

 struct sock * (*accept)(struct sock *sk, int flags, int *err,
       bool kern);

 int (*ioctl)(struct sock *sk, int cmd,
      unsigned long arg);
 int (*init)(struct sock *sk);
 void (*destroy)(struct sock *sk);
 void (*shutdown)(struct sock *sk, int how);
 int (*setsockopt)(struct sock *sk, int level,
     int optname, char *optval,
     unsigned int optlen);
 int (*getsockopt)(struct sock *sk, int level,
     int optname, char *optval,
     int *option);
 void (*keepalive)(struct sock *sk, int valbool);

 int (*compat_setsockopt)(struct sock *sk,
     int level,
     int optname, char *optval,
     unsigned int optlen);
 int (*compat_getsockopt)(struct sock *sk,
     int level,
     int optname, char *optval,
     int *option);
 int (*compat_ioctl)(struct sock *sk,
     unsigned int cmd, unsigned long arg);

 int (*sendmsg)(struct sock *sk, struct msghdr *msg,
        size_t len);
 int (*recvmsg)(struct sock *sk, struct msghdr *msg,
        size_t len, int noblock, int flags,
        int *addr_len);
 int (*sendpage)(struct sock *sk, struct page *page,
     int offset, size_t size, int flags);
 int (*bind)(struct sock *sk,
     struct sockaddr *uaddr, int addr_len);

 int (*backlog_rcv) (struct sock *sk,
      struct sk_buff *skb);

 void (*release_cb)(struct sock *sk);


 int (*hash)(struct sock *sk);
 void (*unhash)(struct sock *sk);
 void (*rehash)(struct sock *sk);
 int (*get_port)(struct sock *sk, unsigned short snum);



 unsigned int inuse_idx;


 bool (*stream_memory_free)(const struct sock *sk, int wake);
 bool (*stream_memory_read)(const struct sock *sk);

 void (*enter_memory_pressure)(struct sock *sk);
 void (*leave_memory_pressure)(struct sock *sk);
 atomic_long_t *memory_allocated;
 struct percpu_counter *sockets_allocated;






 unsigned long *memory_pressure;
 long *sysctl_mem;

 int *sysctl_wmem;
 int *sysctl_rmem;
 u32 sysctl_wmem_offset;
 u32 sysctl_rmem_offset;

 int max_header;
 bool no_autobind;

 struct kmem_cache *slab;
 unsigned int obj_size;
 slab_flags_t slab_flags;
 unsigned int useroffset;
 unsigned int usersize;

 struct percpu_counter *orphan_count;

 struct request_sock_ops *rsk_prot;
 struct timewait_sock_ops *twsk_prot;

 union {
  struct inet_hashinfo *hashinfo;
  struct udp_table *udp_table;
  struct raw_hashinfo *raw_hash;
  struct smc_hashinfo *smc_hash;
 } h;

 struct module *owner;

 char name[32];

 struct list_head node;



 int (*diag_destroy)(struct sock *sk, int err);
} ;

int proto_register(struct proto *prot, int alloc_slab);
void proto_unregister(struct proto *prot);
int sock_load_diag_module(int family, int protocol);
# 1201 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __sk_stream_memory_free(const struct sock *sk, int wake)
{
 if (({ union { typeof(sk->sk_wmem_queued) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); else __read_once_size_nocheck(&(sk->sk_wmem_queued), __u.__c, sizeof(sk->sk_wmem_queued)); do { } while (0); __u.__val; }) >= ({ union { typeof(sk->sk_sndbuf) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); else __read_once_size_nocheck(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); do { } while (0); __u.__val; }))
  return false;

 return sk->__sk_common.skc_prot->stream_memory_free ?
  sk->__sk_common.skc_prot->stream_memory_free(sk, wake) : true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_stream_memory_free(const struct sock *sk)
{
 return __sk_stream_memory_free(sk, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __sk_stream_is_writeable(const struct sock *sk, int wake)
{
 return sk_stream_wspace(sk) >= sk_stream_min_wspace(sk) &&
        __sk_stream_memory_free(sk, wake);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_stream_is_writeable(const struct sock *sk)
{
 return __sk_stream_is_writeable(sk, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_under_cgroup_hierarchy(struct sock *sk,
         struct cgroup *ancestor)
{

 return cgroup_is_descendant(sock_cgroup_ptr(&sk->sk_cgrp_data),
        ancestor);



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_has_memory_pressure(const struct sock *sk)
{
 return sk->__sk_common.skc_prot->memory_pressure != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_under_memory_pressure(const struct sock *sk)
{
 if (!sk->__sk_common.skc_prot->memory_pressure)
  return false;

 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&memcg_sockets_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&memcg_sockets_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&memcg_sockets_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&memcg_sockets_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) && sk->sk_memcg &&
     mem_cgroup_under_socket_pressure(sk->sk_memcg))
  return true;

 return !!*sk->__sk_common.skc_prot->memory_pressure;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
sk_memory_allocated(const struct sock *sk)
{
 return atomic_long_read(sk->__sk_common.skc_prot->memory_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
sk_memory_allocated_add(struct sock *sk, int amt)
{
 return atomic_long_add_return(amt, sk->__sk_common.skc_prot->memory_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
sk_memory_allocated_sub(struct sock *sk, int amt)
{
 atomic_long_sub(amt, sk->__sk_common.skc_prot->memory_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_sockets_allocated_dec(struct sock *sk)
{
 percpu_counter_dec(sk->__sk_common.skc_prot->sockets_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_sockets_allocated_inc(struct sock *sk)
{
 percpu_counter_inc(sk->__sk_common.skc_prot->sockets_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64
sk_sockets_allocated_read_positive(struct sock *sk)
{
 return percpu_counter_read_positive(sk->__sk_common.skc_prot->sockets_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int
proto_sockets_allocated_sum_positive(struct proto *prot)
{
 return percpu_counter_sum_positive(prot->sockets_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long
proto_memory_allocated(struct proto *prot)
{
 return atomic_long_read(prot->memory_allocated);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
proto_memory_pressure(struct proto *prot)
{
 if (!prot->memory_pressure)
  return false;
 return !!*prot->memory_pressure;
}




void sock_prot_inuse_add(struct net *net, struct proto *prot, int inc);
int sock_prot_inuse_get(struct net *net, struct proto *proto);
int sock_inuse_get(struct net *net);
# 1325 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __sk_prot_rehash(struct sock *sk)
{
 sk->__sk_common.skc_prot->unhash(sk);
 return sk->__sk_common.skc_prot->hash(sk);
}
# 1346 "/home/nathan/src/linux-next/include/net/sock.h"
struct socket_alloc {
 struct socket socket;
 struct inode vfs_inode;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct socket *SOCKET_I(struct inode *inode)
{
 return &({ void *__mptr = (void *)(inode); do { extern void __compiletime_assert_1353(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(inode)), typeof(((struct socket_alloc *)0)->vfs_inode)) && !__builtin_types_compatible_p(typeof(*(inode)), typeof(void))))) __compiletime_assert_1353(); } while (0); ((struct socket_alloc *)(__mptr - __builtin_offsetof(struct socket_alloc, vfs_inode))); })->socket;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inode *SOCK_INODE(struct socket *socket)
{
 return &({ void *__mptr = (void *)(socket); do { extern void __compiletime_assert_1358(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(socket)), typeof(((struct socket_alloc *)0)->socket)) && !__builtin_types_compatible_p(typeof(*(socket)), typeof(void))))) __compiletime_assert_1358(); } while (0); ((struct socket_alloc *)(__mptr - __builtin_offsetof(struct socket_alloc, socket))); })->vfs_inode;
}




int __sk_mem_raise_allocated(struct sock *sk, int size, int amt, int kind);
int __sk_mem_schedule(struct sock *sk, int size, int kind);
void __sk_mem_reduce_allocated(struct sock *sk, int amount);
void __sk_mem_reclaim(struct sock *sk, int amount);
# 1378 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long sk_prot_mem_limits(const struct sock *sk, int index)
{
 long val = sk->__sk_common.skc_prot->sysctl_mem[index];


 val <<= 16 - ( __builtin_constant_p(4096) ? ( __builtin_constant_p(4096) ? ( (4096) < 2 ? 0 : (4096) & (1ULL << 63) ? 63 : (4096) & (1ULL << 62) ? 62 : (4096) & (1ULL << 61) ? 61 : (4096) & (1ULL << 60) ? 60 : (4096) & (1ULL << 59) ? 59 : (4096) & (1ULL << 58) ? 58 : (4096) & (1ULL << 57) ? 57 : (4096) & (1ULL << 56) ? 56 : (4096) & (1ULL << 55) ? 55 : (4096) & (1ULL << 54) ? 54 : (4096) & (1ULL << 53) ? 53 : (4096) & (1ULL << 52) ? 52 : (4096) & (1ULL << 51) ? 51 : (4096) & (1ULL << 50) ? 50 : (4096) & (1ULL << 49) ? 49 : (4096) & (1ULL << 48) ? 48 : (4096) & (1ULL << 47) ? 47 : (4096) & (1ULL << 46) ? 46 : (4096) & (1ULL << 45) ? 45 : (4096) & (1ULL << 44) ? 44 : (4096) & (1ULL << 43) ? 43 : (4096) & (1ULL << 42) ? 42 : (4096) & (1ULL << 41) ? 41 : (4096) & (1ULL << 40) ? 40 : (4096) & (1ULL << 39) ? 39 : (4096) & (1ULL << 38) ? 38 : (4096) & (1ULL << 37) ? 37 : (4096) & (1ULL << 36) ? 36 : (4096) & (1ULL << 35) ? 35 : (4096) & (1ULL << 34) ? 34 : (4096) & (1ULL << 33) ? 33 : (4096) & (1ULL << 32) ? 32 : (4096) & (1ULL << 31) ? 31 : (4096) & (1ULL << 30) ? 30 : (4096) & (1ULL << 29) ? 29 : (4096) & (1ULL << 28) ? 28 : (4096) & (1ULL << 27) ? 27 : (4096) & (1ULL << 26) ? 26 : (4096) & (1ULL << 25) ? 25 : (4096) & (1ULL << 24) ? 24 : (4096) & (1ULL << 23) ? 23 : (4096) & (1ULL << 22) ? 22 : (4096) & (1ULL << 21) ? 21 : (4096) & (1ULL << 20) ? 20 : (4096) & (1ULL << 19) ? 19 : (4096) & (1ULL << 18) ? 18 : (4096) & (1ULL << 17) ? 17 : (4096) & (1ULL << 16) ? 16 : (4096) & (1ULL << 15) ? 15 : (4096) & (1ULL << 14) ? 14 : (4096) & (1ULL << 13) ? 13 : (4096) & (1ULL << 12) ? 12 : (4096) & (1ULL << 11) ? 11 : (4096) & (1ULL << 10) ? 10 : (4096) & (1ULL << 9) ? 9 : (4096) & (1ULL << 8) ? 8 : (4096) & (1ULL << 7) ? 7 : (4096) & (1ULL << 6) ? 6 : (4096) & (1ULL << 5) ? 5 : (4096) & (1ULL << 4) ? 4 : (4096) & (1ULL << 3) ? 3 : (4096) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof(4096) <= 4) ? __ilog2_u32(4096) : __ilog2_u64(4096) );



 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_mem_pages(int amt)
{
 return (amt + 4096 - 1) >> ( __builtin_constant_p(4096) ? ( __builtin_constant_p(4096) ? ( (4096) < 2 ? 0 : (4096) & (1ULL << 63) ? 63 : (4096) & (1ULL << 62) ? 62 : (4096) & (1ULL << 61) ? 61 : (4096) & (1ULL << 60) ? 60 : (4096) & (1ULL << 59) ? 59 : (4096) & (1ULL << 58) ? 58 : (4096) & (1ULL << 57) ? 57 : (4096) & (1ULL << 56) ? 56 : (4096) & (1ULL << 55) ? 55 : (4096) & (1ULL << 54) ? 54 : (4096) & (1ULL << 53) ? 53 : (4096) & (1ULL << 52) ? 52 : (4096) & (1ULL << 51) ? 51 : (4096) & (1ULL << 50) ? 50 : (4096) & (1ULL << 49) ? 49 : (4096) & (1ULL << 48) ? 48 : (4096) & (1ULL << 47) ? 47 : (4096) & (1ULL << 46) ? 46 : (4096) & (1ULL << 45) ? 45 : (4096) & (1ULL << 44) ? 44 : (4096) & (1ULL << 43) ? 43 : (4096) & (1ULL << 42) ? 42 : (4096) & (1ULL << 41) ? 41 : (4096) & (1ULL << 40) ? 40 : (4096) & (1ULL << 39) ? 39 : (4096) & (1ULL << 38) ? 38 : (4096) & (1ULL << 37) ? 37 : (4096) & (1ULL << 36) ? 36 : (4096) & (1ULL << 35) ? 35 : (4096) & (1ULL << 34) ? 34 : (4096) & (1ULL << 33) ? 33 : (4096) & (1ULL << 32) ? 32 : (4096) & (1ULL << 31) ? 31 : (4096) & (1ULL << 30) ? 30 : (4096) & (1ULL << 29) ? 29 : (4096) & (1ULL << 28) ? 28 : (4096) & (1ULL << 27) ? 27 : (4096) & (1ULL << 26) ? 26 : (4096) & (1ULL << 25) ? 25 : (4096) & (1ULL << 24) ? 24 : (4096) & (1ULL << 23) ? 23 : (4096) & (1ULL << 22) ? 22 : (4096) & (1ULL << 21) ? 21 : (4096) & (1ULL << 20) ? 20 : (4096) & (1ULL << 19) ? 19 : (4096) & (1ULL << 18) ? 18 : (4096) & (1ULL << 17) ? 17 : (4096) & (1ULL << 16) ? 16 : (4096) & (1ULL << 15) ? 15 : (4096) & (1ULL << 14) ? 14 : (4096) & (1ULL << 13) ? 13 : (4096) & (1ULL << 12) ? 12 : (4096) & (1ULL << 11) ? 11 : (4096) & (1ULL << 10) ? 10 : (4096) & (1ULL << 9) ? 9 : (4096) & (1ULL << 8) ? 8 : (4096) & (1ULL << 7) ? 7 : (4096) & (1ULL << 6) ? 6 : (4096) & (1ULL << 5) ? 5 : (4096) & (1ULL << 4) ? 4 : (4096) & (1ULL << 3) ? 3 : (4096) & (1ULL << 2) ? 2 : 1) : -1) : (sizeof(4096) <= 4) ? __ilog2_u32(4096) : __ilog2_u64(4096) );
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_has_account(struct sock *sk)
{

 return !!sk->__sk_common.skc_prot->memory_allocated;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_wmem_schedule(struct sock *sk, int size)
{
 if (!sk_has_account(sk))
  return true;
 return size <= sk->sk_forward_alloc ||
  __sk_mem_schedule(sk, size, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
sk_rmem_schedule(struct sock *sk, struct sk_buff *skb, int size)
{
 if (!sk_has_account(sk))
  return true;
 return size<= sk->sk_forward_alloc ||
  __sk_mem_schedule(sk, size, 1) ||
  skb_pfmemalloc(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_mem_reclaim(struct sock *sk)
{
 if (!sk_has_account(sk))
  return;
 if (sk->sk_forward_alloc >= 4096)
  __sk_mem_reclaim(sk, sk->sk_forward_alloc);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_mem_reclaim_partial(struct sock *sk)
{
 if (!sk_has_account(sk))
  return;
 if (sk->sk_forward_alloc > 4096)
  __sk_mem_reclaim(sk, sk->sk_forward_alloc - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_mem_charge(struct sock *sk, int size)
{
 if (!sk_has_account(sk))
  return;
 sk->sk_forward_alloc -= size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_mem_uncharge(struct sock *sk, int size)
{
 if (!sk_has_account(sk))
  return;
 sk->sk_forward_alloc += size;
# 1455 "/home/nathan/src/linux-next/include/net/sock.h"
 if (__builtin_expect(!!(sk->sk_forward_alloc >= 1 << 21), 0))
  __sk_mem_reclaim(sk, 1 << 20);
}

extern struct static_key_false tcp_tx_skb_cache_key;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_wmem_free_skb(struct sock *sk, struct sk_buff *skb)
{
 sock_set_flag(sk, SOCK_QUEUE_SHRUNK);
 sk_wmem_queued_add(sk, -skb->truesize);
 sk_mem_uncharge(sk, skb->truesize);
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&tcp_tx_skb_cache_key), struct static_key_true)) branch = arch_static_branch_jump(&(&tcp_tx_skb_cache_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&tcp_tx_skb_cache_key), struct static_key_false)) branch = arch_static_branch(&(&tcp_tx_skb_cache_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) &&
     !sk->sk_tx_skb_cache && !skb_cloned(skb)) {
  skb_ext_reset(skb);
  skb_zcopy_clear(skb, true);
  sk->sk_tx_skb_cache = skb;
  return;
 }
 __kfree_skb(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_release_ownership(struct sock *sk)
{
 if (sk->sk_lock.owned) {
  sk->sk_lock.owned = 0;


  do { } while (0);
 }
}
# 1512 "/home/nathan/src/linux-next/include/net/sock.h"
void lock_sock_nested(struct sock *sk, int subclass);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void lock_sock(struct sock *sk)
{
 lock_sock_nested(sk, 0);
}

void __release_sock(struct sock *sk);
void release_sock(struct sock *sk);
# 1529 "/home/nathan/src/linux-next/include/net/sock.h"
bool lock_sock_fast(struct sock *sk);
# 1538 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void unlock_sock_fast(struct sock *sk, bool slow)
{
 if (slow)
  release_sock(sk);
 else
  spin_unlock_bh(&sk->sk_lock.slock);
}
# 1560 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_owned_by_me(const struct sock *sk)
{



}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sock_owned_by_user(const struct sock *sk)
{
 sock_owned_by_me(sk);
 return sk->sk_lock.owned;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sock_owned_by_user_nocheck(const struct sock *sk)
{
 return sk->sk_lock.owned;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sock_allow_reclassification(const struct sock *csk)
{
 struct sock *sk = (struct sock *)csk;

 return !sk->sk_lock.owned && !spin_is_locked(&sk->sk_lock.slock);
}

struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
        struct proto *prot, int kern);
void sk_free(struct sock *sk);
void sk_destruct(struct sock *sk);
struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority);
void sk_free_unlock_clone(struct sock *sk);

struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
        gfp_t priority);
void __sock_wfree(struct sk_buff *skb);
void sock_wfree(struct sk_buff *skb);
struct sk_buff *sock_omalloc(struct sock *sk, unsigned long size,
        gfp_t priority);
void skb_orphan_partial(struct sk_buff *skb);
void sock_rfree(struct sk_buff *skb);
void sock_efree(struct sk_buff *skb);

void sock_edemux(struct sk_buff *skb);




int sock_setsockopt(struct socket *sock, int level, int op,
      char *optval, unsigned int optlen);

int sock_getsockopt(struct socket *sock, int level, int op,
      char *optval, int *optlen);
int sock_gettstamp(struct socket *sock, void *userstamp,
     bool timeval, bool time32);
struct sk_buff *sock_alloc_send_skb(struct sock *sk, unsigned long size,
        int noblock, int *errcode);
struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
         unsigned long data_len, int noblock,
         int *errcode, int max_page_order);
void *sock_kmalloc(struct sock *sk, int size, gfp_t priority);
void sock_kfree_s(struct sock *sk, void *mem, int size);
void sock_kzfree_s(struct sock *sk, void *mem, int size);
void sk_send_sigurg(struct sock *sk);

struct sockcm_cookie {
 u64 transmit_time;
 u32 mark;
 u16 tsflags;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sockcm_init(struct sockcm_cookie *sockc,
          const struct sock *sk)
{
 *sockc = (struct sockcm_cookie) { .tsflags = sk->sk_tsflags };
}

int __sock_cmsg_send(struct sock *sk, struct msghdr *msg, struct cmsghdr *cmsg,
       struct sockcm_cookie *sockc);
int sock_cmsg_send(struct sock *sk, struct msghdr *msg,
     struct sockcm_cookie *sockc);





int sock_no_bind(struct socket *, struct sockaddr *, int);
int sock_no_connect(struct socket *, struct sockaddr *, int, int);
int sock_no_socketpair(struct socket *, struct socket *);
int sock_no_accept(struct socket *, struct socket *, int, bool);
int sock_no_getname(struct socket *, struct sockaddr *, int);
int sock_no_ioctl(struct socket *, unsigned int, unsigned long);
int sock_no_listen(struct socket *, int);
int sock_no_shutdown(struct socket *, int);
int sock_no_getsockopt(struct socket *, int , int, char *, int *);
int sock_no_setsockopt(struct socket *, int, int, char *, unsigned int);
int sock_no_sendmsg(struct socket *, struct msghdr *, size_t);
int sock_no_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t len);
int sock_no_recvmsg(struct socket *, struct msghdr *, size_t, int);
int sock_no_mmap(struct file *file, struct socket *sock,
   struct vm_area_struct *vma);
ssize_t sock_no_sendpage(struct socket *sock, struct page *page, int offset,
    size_t size, int flags);
ssize_t sock_no_sendpage_locked(struct sock *sk, struct page *page,
    int offset, size_t size, int flags);





int sock_common_getsockopt(struct socket *sock, int level, int optname,
      char *optval, int *optlen);
int sock_common_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
   int flags);
int sock_common_setsockopt(struct socket *sock, int level, int optname,
      char *optval, unsigned int optlen);
int compat_sock_common_getsockopt(struct socket *sock, int level,
  int optname, char *optval, int *optlen);
int compat_sock_common_setsockopt(struct socket *sock, int level,
  int optname, char *optval, unsigned int optlen);

void sk_common_release(struct sock *sk);






void sock_init_data(struct socket *sock, struct sock *sk);
# 1716 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_put(struct sock *sk)
{
 if (refcount_dec_and_test(&sk->__sk_common.skc_refcnt))
  sk_free(sk);
}



void sock_gen_put(struct sock *sk);

int __sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested,
       unsigned int trim_cap, bool refcounted);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_receive_skb(struct sock *sk, struct sk_buff *skb,
     const int nested)
{
 return __sk_receive_skb(sk, skb, nested, 1, true);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_tx_queue_set(struct sock *sk, int tx_queue)
{

 if (({ int __ret_warn_on = !!((unsigned short)tx_queue >= ((unsigned short)~0U)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (1737), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
  return;
 sk->__sk_common.skc_tx_queue_mapping = tx_queue;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_tx_queue_clear(struct sock *sk)
{
 sk->__sk_common.skc_tx_queue_mapping = ((unsigned short)~0U);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_tx_queue_get(const struct sock *sk)
{
 if (sk && sk->__sk_common.skc_tx_queue_mapping != ((unsigned short)~0U))
  return sk->__sk_common.skc_tx_queue_mapping;

 return -1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_rx_queue_set(struct sock *sk, const struct sk_buff *skb)
{

 if (skb_rx_queue_recorded(skb)) {
  u16 rx_queue = skb_get_rx_queue(skb);

  if (({ int __ret_warn_on = !!(rx_queue == ((unsigned short)~0U)); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (1763), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); }))
   return;

  sk->__sk_common.skc_rx_queue_mapping = rx_queue;
 }

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_rx_queue_clear(struct sock *sk)
{

 sk->__sk_common.skc_rx_queue_mapping = ((unsigned short)~0U);

}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_rx_queue_get(const struct sock *sk)
{
 if (sk && sk->__sk_common.skc_rx_queue_mapping != ((unsigned short)~0U))
  return sk->__sk_common.skc_rx_queue_mapping;

 return -1;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_set_socket(struct sock *sk, struct socket *sock)
{
 sk_tx_queue_clear(sk);
 sk->sk_socket = sock;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) wait_queue_head_t *sk_sleep(struct sock *sk)
{
 do { extern void __compiletime_assert_1796(void) ; if (!(!(__builtin_offsetof(struct socket_wq, wait) != 0))) __compiletime_assert_1796(); } while (0);
 return &({ typeof(sk->sk_wq) ________p1 = ({ union { typeof(sk->sk_wq) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_wq), __u.__c, sizeof(sk->sk_wq)); else __read_once_size_nocheck(&(sk->sk_wq), __u.__c, sizeof(sk->sk_wq)); do { } while (0); __u.__val; }); ((typeof(*sk->sk_wq) *)(________p1)); })->wait;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_orphan(struct sock *sk)
{
 _raw_write_lock_bh(&sk->sk_callback_lock);
 sock_set_flag(sk, SOCK_DEAD);
 sk_set_socket(sk, ((void *)0));
 sk->sk_wq = ((void *)0);
 _raw_write_unlock_bh(&sk->sk_callback_lock);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_graft(struct sock *sk, struct socket *parent)
{
 ({ int __ret_warn_on = !!(parent->sk); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (1817), "i" ((1 << 0) | (((9) << 8))), "i" (sizeof(struct bug_entry))); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/sock.h"), "i" (1817), "i" ((1 << 0) | ((9) << 8)), "i" (sizeof(struct bug_entry)), "r" (__ret_warn_on)); } __builtin_expect(!!(__ret_warn_on), 0); });
 _raw_write_lock_bh(&sk->sk_callback_lock);
 do { uintptr_t _r_a_p__v = (uintptr_t)(&parent->wq); ; if (__builtin_constant_p(&parent->wq) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((sk->sk_wq)) __val; char __c[1]; } __u = { .__val = ( typeof((sk->sk_wq))) ((typeof(sk->sk_wq))(_r_a_p__v)) }; __write_once_size(&((sk->sk_wq)), __u.__c, sizeof((sk->sk_wq))); __u.__val; }); else do { do { extern void __compiletime_assert_1819(void) ; if (!((sizeof(*&sk->sk_wq) == sizeof(char) || sizeof(*&sk->sk_wq) == sizeof(short) || sizeof(*&sk->sk_wq) == sizeof(int) || sizeof(*&sk->sk_wq) == sizeof(long)))) __compiletime_assert_1819(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&sk->sk_wq) __val; char __c[1]; } __u = { .__val = ( typeof(*&sk->sk_wq)) ((typeof(*((typeof(sk->sk_wq))_r_a_p__v)) *)((typeof(sk->sk_wq))_r_a_p__v)) }; __write_once_size(&(*&sk->sk_wq), __u.__c, sizeof(*&sk->sk_wq)); __u.__val; }); } while (0); } while (0);
 parent->sk = sk;
 sk_set_socket(sk, parent);
 sk->sk_uid = SOCK_INODE(parent)->i_uid;
 security_sock_graft(sk, parent);
 _raw_write_unlock_bh(&sk->sk_callback_lock);
}

kuid_t sock_i_uid(struct sock *sk);
unsigned long sock_i_ino(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) kuid_t sock_net_uid(const struct net *net, const struct sock *sk)
{
 return sk ? sk->sk_uid : make_kuid(net->user_ns, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 net_tx_rndhash(void)
{
 u32 v = prandom_u32();

 return v ?: 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_set_txhash(struct sock *sk)
{
 sk->sk_txhash = net_tx_rndhash();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_rethink_txhash(struct sock *sk)
{
 if (sk->sk_txhash)
  sk_set_txhash(sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dst_entry *
__sk_dst_get(struct sock *sk)
{
 return ({ typeof(*(sk->sk_dst_cache)) *________p1 = (typeof(*(sk->sk_dst_cache)) *)({ union { typeof((sk->sk_dst_cache)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); else __read_once_size_nocheck(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_dst_cache)) *)(________p1)); });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct dst_entry *
sk_dst_get(struct sock *sk)
{
 struct dst_entry *dst;

 rcu_read_lock();
 dst = ({ typeof(*(sk->sk_dst_cache)) *________p1 = (typeof(*(sk->sk_dst_cache)) *)({ union { typeof((sk->sk_dst_cache)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); else __read_once_size_nocheck(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_dst_cache)) *)(________p1)); });
 if (dst && !atomic_inc_not_zero((&dst->__refcnt)))
  dst = ((void *)0);
 rcu_read_unlock();
 return dst;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void dst_negative_advice(struct sock *sk)
{
 struct dst_entry *ndst, *dst = __sk_dst_get(sk);

 sk_rethink_txhash(sk);

 if (dst && dst->ops->negative_advice) {
  ndst = dst->ops->negative_advice(dst);

  if (ndst != dst) {
   do { uintptr_t _r_a_p__v = (uintptr_t)(ndst); ; if (__builtin_constant_p(ndst) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((sk->sk_dst_cache)) __val; char __c[1]; } __u = { .__val = ( typeof((sk->sk_dst_cache))) ((typeof(sk->sk_dst_cache))(_r_a_p__v)) }; __write_once_size(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); __u.__val; }); else do { do { extern void __compiletime_assert_1883(void) ; if (!((sizeof(*&sk->sk_dst_cache) == sizeof(char) || sizeof(*&sk->sk_dst_cache) == sizeof(short) || sizeof(*&sk->sk_dst_cache) == sizeof(int) || sizeof(*&sk->sk_dst_cache) == sizeof(long)))) __compiletime_assert_1883(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&sk->sk_dst_cache) __val; char __c[1]; } __u = { .__val = ( typeof(*&sk->sk_dst_cache)) ((typeof(*((typeof(sk->sk_dst_cache))_r_a_p__v)) *)((typeof(sk->sk_dst_cache))_r_a_p__v)) }; __write_once_size(&(*&sk->sk_dst_cache), __u.__c, sizeof(*&sk->sk_dst_cache)); __u.__val; }); } while (0); } while (0);
   sk_tx_queue_clear(sk);
   sk->sk_dst_pending_confirm = 0;
  }
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
 struct dst_entry *old_dst;

 sk_tx_queue_clear(sk);
 sk->sk_dst_pending_confirm = 0;
 old_dst = ({ do { } while (0); ; ((typeof(*(sk->sk_dst_cache)) *)((sk->sk_dst_cache))); });

 do { uintptr_t _r_a_p__v = (uintptr_t)(dst); ; if (__builtin_constant_p(dst) && (_r_a_p__v) == (uintptr_t)((void *)0)) ({ union { typeof((sk->sk_dst_cache)) __val; char __c[1]; } __u = { .__val = ( typeof((sk->sk_dst_cache))) ((typeof(sk->sk_dst_cache))(_r_a_p__v)) }; __write_once_size(&((sk->sk_dst_cache)), __u.__c, sizeof((sk->sk_dst_cache))); __u.__val; }); else do { do { extern void __compiletime_assert_1899(void) ; if (!((sizeof(*&sk->sk_dst_cache) == sizeof(char) || sizeof(*&sk->sk_dst_cache) == sizeof(short) || sizeof(*&sk->sk_dst_cache) == sizeof(int) || sizeof(*&sk->sk_dst_cache) == sizeof(long)))) __compiletime_assert_1899(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ({ union { typeof(*&sk->sk_dst_cache) __val; char __c[1]; } __u = { .__val = ( typeof(*&sk->sk_dst_cache)) ((typeof(*((typeof(sk->sk_dst_cache))_r_a_p__v)) *)((typeof(sk->sk_dst_cache))_r_a_p__v)) }; __write_once_size(&(*&sk->sk_dst_cache), __u.__c, sizeof(*&sk->sk_dst_cache)); __u.__val; }); } while (0); } while (0);
 dst_release(old_dst);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
 struct dst_entry *old_dst;

 sk_tx_queue_clear(sk);
 sk->sk_dst_pending_confirm = 0;
 old_dst = ({ typeof(({ __typeof__(*(( struct dst_entry **)&sk->sk_dst_cache)) _x_ = (dst); (__typeof__(*(( struct dst_entry **)&sk->sk_dst_cache))) __xchg_relaxed((( struct dst_entry **)&sk->sk_dst_cache), (unsigned long)_x_, sizeof(*(( struct dst_entry **)&sk->sk_dst_cache))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(( struct dst_entry **)&sk->sk_dst_cache)) _x_ = (dst); (__typeof__(*(( struct dst_entry **)&sk->sk_dst_cache))) __xchg_relaxed((( struct dst_entry **)&sk->sk_dst_cache), (unsigned long)_x_, sizeof(*(( struct dst_entry **)&sk->sk_dst_cache))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
 dst_release(old_dst);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
__sk_dst_reset(struct sock *sk)
{
 __sk_dst_set(sk, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
sk_dst_reset(struct sock *sk)
{
 sk_dst_set(sk, ((void *)0));
}

struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie);

struct dst_entry *sk_dst_check(struct sock *sk, u32 cookie);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_dst_confirm(struct sock *sk)
{
 if (!({ union { typeof(sk->sk_dst_pending_confirm) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); else __read_once_size_nocheck(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); do { } while (0); __u.__val; }))
  ({ union { typeof(sk->sk_dst_pending_confirm) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_dst_pending_confirm)) (1) }; __write_once_size(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); __u.__val; });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_confirm_neigh(struct sk_buff *skb, struct neighbour *n)
{
 if (skb_get_dst_pending_confirm(skb)) {
  struct sock *sk = skb->sk;
  unsigned long now = jiffies;


  if (({ union { typeof(n->confirmed) __val; char __c[1]; } __u; if (1) __read_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); else __read_once_size_nocheck(&(n->confirmed), __u.__c, sizeof(n->confirmed)); do { } while (0); __u.__val; }) != now)
   ({ union { typeof(n->confirmed) __val; char __c[1]; } __u = { .__val = ( typeof(n->confirmed)) (now) }; __write_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); __u.__val; });
  if (sk && ({ union { typeof(sk->sk_dst_pending_confirm) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); else __read_once_size_nocheck(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); do { } while (0); __u.__val; }))
   ({ union { typeof(sk->sk_dst_pending_confirm) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_dst_pending_confirm)) (0) }; __write_once_size(&(sk->sk_dst_pending_confirm), __u.__c, sizeof(sk->sk_dst_pending_confirm)); __u.__val; });
 }
}

bool sk_mc_loop(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_can_gso(const struct sock *sk)
{
 return net_gso_ok(sk->sk_route_caps, sk->sk_gso_type);
}

void sk_setup_caps(struct sock *sk, struct dst_entry *dst);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_nocaps_add(struct sock *sk, netdev_features_t flags)
{
 sk->sk_route_nocaps |= flags;
 sk->sk_route_caps &= ~flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_do_copy_data_nocache(struct sock *sk, struct sk_buff *skb,
        struct iov_iter *from, char *to,
        int copy, int offset)
{
 if (skb->ip_summed == 0) {
  __wsum csum = 0;
  if (!csum_and_copy_from_iter_full(to, copy, &csum, from))
   return -14;
  skb->csum = csum_block_add(skb->csum, csum, offset);
 } else if (sk->sk_route_caps & ((netdev_features_t)1 << (NETIF_F_NOCACHE_COPY_BIT))) {
  if (!copy_from_iter_full_nocache(to, copy, from))
   return -14;
 } else if (!copy_from_iter_full(to, copy, from))
  return -14;

 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_add_data_nocache(struct sock *sk, struct sk_buff *skb,
           struct iov_iter *from, int copy)
{
 int err, offset = skb->len;

 err = skb_do_copy_data_nocache(sk, skb, from, skb_put(skb, copy),
           copy, offset);
 if (err)
  __skb_trim(skb, offset);

 return err;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int skb_copy_to_page_nocache(struct sock *sk, struct iov_iter *from,
        struct sk_buff *skb,
        struct page *page,
        int off, int copy)
{
 int err;

 err = skb_do_copy_data_nocache(sk, skb, from, lowmem_page_address(page) + off,
           copy, skb->len);
 if (err)
  return err;

 skb->len += copy;
 skb->data_len += copy;
 skb->truesize += copy;
 sk_wmem_queued_add(sk, copy);
 sk_mem_charge(sk, copy);
 return 0;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_wmem_alloc_get(const struct sock *sk)
{
 return refcount_read(&sk->sk_wmem_alloc) - 1;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_rmem_alloc_get(const struct sock *sk)
{
 return atomic_read(&sk->sk_backlog.rmem_alloc);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_has_allocations(const struct sock *sk)
{
 return sk_wmem_alloc_get(sk) || sk_rmem_alloc_get(sk);
}
# 2080 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skwq_has_sleeper(struct socket_wq *wq)
{
 return wq && wq_has_sleeper(&wq->wait);
}
# 2093 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_poll_wait(struct file *filp, struct socket *sock,
      poll_table *p)
{
 if (!poll_does_not_wait(p)) {
  poll_wait(filp, &sock->wq.wait, p);





  __asm__ __volatile__ ("sync" : : : "memory");
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_hash_from_sk(struct sk_buff *skb, struct sock *sk)
{
 if (sk->sk_txhash) {
  skb->l4_hash = 1;
  skb->hash = sk->sk_txhash;
 }
}

void skb_set_owner_w(struct sk_buff *skb, struct sock *sk);
# 2125 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
 skb_orphan(skb);
 skb->sk = sk;
 skb->destructor = sock_rfree;
 atomic_add(skb->truesize, &sk->sk_backlog.rmem_alloc);
 sk_mem_charge(sk, skb->truesize);
}

void sk_reset_timer(struct sock *sk, struct timer_list *timer,
      unsigned long expires);

void sk_stop_timer(struct sock *sk, struct timer_list *timer);

int __sk_queue_drop_skb(struct sock *sk, struct sk_buff_head *sk_queue,
   struct sk_buff *skb, unsigned int flags,
   void (*destructor)(struct sock *sk,
        struct sk_buff *skb));
int __sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);

int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb);
struct sk_buff *sock_dequeue_err_skb(struct sock *sk);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sock_error(struct sock *sk)
{
 int err;
 if (__builtin_expect(!!(!sk->sk_err), 1))
  return 0;
 err = ({ typeof(({ __typeof__(*(&sk->sk_err)) _x_ = (0); (__typeof__(*(&sk->sk_err))) __xchg_relaxed((&sk->sk_err), (unsigned long)_x_, sizeof(*(&sk->sk_err))); })) __ret; __asm__ __volatile__ ("sync" : : : "memory"); __ret = ({ __typeof__(*(&sk->sk_err)) _x_ = (0); (__typeof__(*(&sk->sk_err))) __xchg_relaxed((&sk->sk_err), (unsigned long)_x_, sizeof(*(&sk->sk_err))); }); __asm__ __volatile__ ("sync" : : : "memory"); __ret; });
 return -err;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long sock_wspace(struct sock *sk)
{
 int amt = 0;

 if (!(sk->sk_shutdown & 2)) {
  amt = sk->sk_sndbuf - refcount_read(&sk->sk_wmem_alloc);
  if (amt < 0)
   amt = 0;
 }
 return amt;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_set_bit(int nr, struct sock *sk)
{
 if ((nr == 0 || nr == 1) &&
     !sock_flag(sk, SOCK_FASYNC))
  return;

 set_bit(nr, &sk->sk_wq_raw->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_clear_bit(int nr, struct sock *sk)
{
 if ((nr == 0 || nr == 1) &&
     !sock_flag(sk, SOCK_FASYNC))
  return;

 clear_bit(nr, &sk->sk_wq_raw->flags);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_wake_async(const struct sock *sk, int how, int band)
{
 if (sock_flag(sk, SOCK_FASYNC)) {
  rcu_read_lock();
  sock_wake_async(({ typeof(*(sk->sk_wq)) *________p1 = (typeof(*(sk->sk_wq)) *)({ union { typeof((sk->sk_wq)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_wq)), __u.__c, sizeof((sk->sk_wq))); else __read_once_size_nocheck(&((sk->sk_wq)), __u.__c, sizeof((sk->sk_wq))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_wq)) *)(________p1)); }), how, band);
  rcu_read_unlock();
 }
}
# 2215 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_stream_moderate_sndbuf(struct sock *sk)
{
 u32 val;

 if (sk->sk_userlocks & 1)
  return;

 val = __builtin_choose_expr(((!!(sizeof((typeof(sk->sk_sndbuf) *)1 == (typeof(sk->sk_wmem_queued >> 1) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(sk->sk_sndbuf) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(sk->sk_wmem_queued >> 1) * 0l)) : (int *)8))))), ((sk->sk_sndbuf) < (sk->sk_wmem_queued >> 1) ? (sk->sk_sndbuf) : (sk->sk_wmem_queued >> 1)), ({ typeof(sk->sk_sndbuf) __UNIQUE_ID___x74 = (sk->sk_sndbuf); typeof(sk->sk_wmem_queued >> 1) __UNIQUE_ID___y75 = (sk->sk_wmem_queued >> 1); ((__UNIQUE_ID___x74) < (__UNIQUE_ID___y75) ? (__UNIQUE_ID___x74) : (__UNIQUE_ID___y75)); }));

 ({ union { typeof(sk->sk_sndbuf) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_sndbuf)) (__builtin_choose_expr(((!!(sizeof((typeof((u32)(val)) *)1 == (typeof((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(val)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2))) * 0l)) : (int *)8))))), (((u32)(val)) > ((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2))) ? ((u32)(val)) : ((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2)))), ({ typeof((u32)(val)) __UNIQUE_ID___x76 = ((u32)(val)); typeof((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2))) __UNIQUE_ID___y77 = ((u32)(((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2))); ((__UNIQUE_ID___x76) > (__UNIQUE_ID___y77) ? (__UNIQUE_ID___x76) : (__UNIQUE_ID___y77)); }))) }; __write_once_size(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); __u.__val; });
}

struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp,
        bool force_schedule);
# 2242 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct page_frag *sk_page_frag(struct sock *sk)
{
 if (gfpflags_normal_context(sk->sk_allocation))
  return &get_current()->task_frag;

 return &sk->sk_frag;
}

bool sk_page_frag_refill(struct sock *sk, struct page_frag *pfrag);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sock_writeable(const struct sock *sk)
{
 return refcount_read(&sk->sk_wmem_alloc) < (({ union { typeof(sk->sk_sndbuf) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); else __read_once_size_nocheck(&(sk->sk_sndbuf), __u.__c, sizeof(sk->sk_sndbuf)); do { } while (0); __u.__val; }) >> 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) gfp_t gfp_any(void)
{
 return ((preempt_count() & (((1UL << (8))-1) << (0 + 8)))) ? ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)) : ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long sock_rcvtimeo(const struct sock *sk, bool noblock)
{
 return noblock ? 0 : sk->sk_rcvtimeo;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) long sock_sndtimeo(const struct sock *sk, bool noblock)
{
 return noblock ? 0 : sk->sk_sndtimeo;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sock_rcvlowat(const struct sock *sk, int waitall, int len)
{
 int v = waitall ? len : __builtin_choose_expr(((!!(sizeof((typeof((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))) *)1 == (typeof((int)(len)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(len)) * 0l)) : (int *)8))))), (((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))) < ((int)(len)) ? ((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))) : ((int)(len))), ({ typeof((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))) __UNIQUE_ID___x78 = ((int)(({ union { typeof(sk->sk_rcvlowat) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); else __read_once_size_nocheck(&(sk->sk_rcvlowat), __u.__c, sizeof(sk->sk_rcvlowat)); do { } while (0); __u.__val; }))); typeof((int)(len)) __UNIQUE_ID___y79 = ((int)(len)); ((__UNIQUE_ID___x78) < (__UNIQUE_ID___y79) ? (__UNIQUE_ID___x78) : (__UNIQUE_ID___y79)); }));

 return v ?: 1;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sock_intr_errno(long timeo)
{
 return timeo == ((long)(~0UL >> 1)) ? -512 : -4;
}

struct sock_skb_cb {
 u32 dropcount;
};
# 2307 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
sock_skb_set_dropcount(const struct sock *sk, struct sk_buff *skb)
{
 ((struct sock_skb_cb *)((skb)->cb + ((sizeof((((struct sk_buff *)0)->cb)) - sizeof(struct sock_skb_cb)))))->dropcount = sock_flag(sk, SOCK_RXQ_OVFL) ?
      atomic_read(&sk->sk_drops) : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_drops_add(struct sock *sk, const struct sk_buff *skb)
{
 int segs = __builtin_choose_expr(((!!(sizeof((typeof((u16)(1)) *)1 == (typeof((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(1)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) * 0l)) : (int *)8))))), (((u16)(1)) > ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) ? ((u16)(1)) : ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs))), ({ typeof((u16)(1)) __UNIQUE_ID___x80 = ((u16)(1)); typeof((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) __UNIQUE_ID___y81 = ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)); ((__UNIQUE_ID___x80) > (__UNIQUE_ID___y81) ? (__UNIQUE_ID___x80) : (__UNIQUE_ID___y81)); }));

 atomic_add(segs, &sk->sk_drops);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) ktime_t sock_read_timestamp(struct sock *sk)
{
# 2334 "/home/nathan/src/linux-next/include/net/sock.h"
 return ({ union { typeof(sk->sk_stamp) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_stamp), __u.__c, sizeof(sk->sk_stamp)); else __read_once_size_nocheck(&(sk->sk_stamp), __u.__c, sizeof(sk->sk_stamp)); do { } while (0); __u.__val; });

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_write_timestamp(struct sock *sk, ktime_t kt)
{





 ({ union { typeof(sk->sk_stamp) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_stamp)) (kt) }; __write_once_size(&(sk->sk_stamp), __u.__c, sizeof(sk->sk_stamp)); __u.__val; });

}

void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
      struct sk_buff *skb);
void __sock_recv_wifi_status(struct msghdr *msg, struct sock *sk,
        struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
sock_recv_timestamp(struct msghdr *msg, struct sock *sk, struct sk_buff *skb)
{
 ktime_t kt = skb->tstamp;
 struct skb_shared_hwtstamps *hwtstamps = skb_hwtstamps(skb);







 if (sock_flag(sk, SOCK_RCVTSTAMP) ||
     (sk->sk_tsflags & SOF_TIMESTAMPING_RX_SOFTWARE) ||
     (kt && sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) ||
     (hwtstamps->hwtstamp &&
      (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE)))
  __sock_recv_timestamp(msg, sk, skb);
 else
  sock_write_timestamp(sk, kt);

 if (sock_flag(sk, SOCK_WIFI_STATUS) && skb->wifi_acked_valid)
  __sock_recv_wifi_status(msg, sk, skb);
}

void __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,
         struct sk_buff *skb);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,
       struct sk_buff *skb)
{





 if (sk->__sk_common.skc_flags & ((1UL << SOCK_RXQ_OVFL) | (1UL << SOCK_RCVTSTAMP)) || sk->sk_tsflags & (SOF_TIMESTAMPING_SOFTWARE | SOF_TIMESTAMPING_RAW_HARDWARE))
  __sock_recv_ts_and_drops(msg, sk, skb);
 else if (__builtin_expect(!!(sock_flag(sk, SOCK_TIMESTAMP)), 0))
  sock_write_timestamp(sk, skb->tstamp);
 else if (__builtin_expect(!!(sk->sk_stamp == (-1L * 1000000000L)), 0))
  sock_write_timestamp(sk, 0);
}

void __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags);
# 2410 "/home/nathan/src/linux-next/include/net/sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void _sock_tx_timestamp(struct sock *sk, __u16 tsflags,
          __u8 *tx_flags, __u32 *tskey)
{
 if (__builtin_expect(!!(tsflags), 0)) {
  __sock_tx_timestamp(tsflags, tx_flags);
  if (tsflags & SOF_TIMESTAMPING_OPT_ID && tskey &&
      tsflags & (SOF_TIMESTAMPING_TX_HARDWARE | SOF_TIMESTAMPING_TX_SOFTWARE | SOF_TIMESTAMPING_TX_SCHED | SOF_TIMESTAMPING_TX_ACK))
   *tskey = sk->sk_tskey++;
 }
 if (__builtin_expect(!!(sock_flag(sk, SOCK_WIFI_STATUS)), 0))
  *tx_flags |= SKBTX_WIFI_STATUS;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sock_tx_timestamp(struct sock *sk, __u16 tsflags,
         __u8 *tx_flags)
{
 _sock_tx_timestamp(sk, tsflags, tx_flags, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_setup_tx_timestamp(struct sk_buff *skb, __u16 tsflags)
{
 _sock_tx_timestamp(skb->sk, tsflags, &((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags,
      &((struct skb_shared_info *)(skb_end_pointer(skb)))->tskey);
}
# 2443 "/home/nathan/src/linux-next/include/net/sock.h"
extern struct static_key_false tcp_rx_skb_cache_key;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_eat_skb(struct sock *sk, struct sk_buff *skb)
{
 __skb_unlink(skb, &sk->sk_receive_queue);
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&tcp_rx_skb_cache_key), struct static_key_true)) branch = arch_static_branch_jump(&(&tcp_rx_skb_cache_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&tcp_rx_skb_cache_key), struct static_key_false)) branch = arch_static_branch(&(&tcp_rx_skb_cache_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) &&
     !sk->sk_rx_skb_cache) {
  sk->sk_rx_skb_cache = skb;
  skb_orphan(skb);
  return;
 }
 __kfree_skb(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct net *sock_net(const struct sock *sk)
{
 return read_pnet(&sk->__sk_common.skc_net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void sock_net_set(struct sock *sk, struct net *net)
{
 write_pnet(&sk->__sk_common.skc_net, net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *skb_steal_sock(struct sk_buff *skb)
{
 if (skb->sk) {
  struct sock *sk = skb->sk;

  skb->destructor = ((void *)0);
  skb->sk = ((void *)0);
  return sk;
 }
 return ((void *)0);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_fullsock(const struct sock *sk)
{
 return (1 << sk->__sk_common.skc_state) & ~(TCPF_TIME_WAIT | TCPF_NEW_SYN_RECV);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *sk_validate_xmit_skb(struct sk_buff *skb,
         struct net_device *dev)
{
# 2509 "/home/nathan/src/linux-next/include/net/sock.h"
 return skb;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_listener(const struct sock *sk)
{
 return (1 << sk->__sk_common.skc_state) & (TCPF_LISTEN | TCPF_NEW_SYN_RECV);
}

void sock_enable_timestamp(struct sock *sk, enum sock_flags flag);
int sock_recv_errqueue(struct sock *sk, struct msghdr *msg, int len, int level,
         int type);

bool sk_ns_capable(const struct sock *sk,
     struct user_namespace *user_ns, int cap);
bool sk_capable(const struct sock *sk, int cap);
bool sk_net_capable(const struct sock *sk, int cap);

void sk_get_meminfo(const struct sock *sk, u32 *meminfo);
# 2541 "/home/nathan/src/linux-next/include/net/sock.h"
extern __u32 sysctl_wmem_max;
extern __u32 sysctl_rmem_max;

extern int sysctl_tstamp_allow_data;
extern int sysctl_optmem_max;

extern __u32 sysctl_wmem_default;
extern __u32 sysctl_rmem_default;

extern struct static_key_false net_high_order_alloc_disable_key;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_get_wmem0(const struct sock *sk, const struct proto *proto)
{

 if (proto->sysctl_wmem_offset)
  return *(int *)((void *)sock_net(sk) + proto->sysctl_wmem_offset);

 return *proto->sysctl_wmem;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int sk_get_rmem0(const struct sock *sk, const struct proto *proto)
{

 if (proto->sysctl_rmem_offset)
  return *(int *)((void *)sock_net(sk) + proto->sysctl_rmem_offset);

 return *proto->sysctl_rmem;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_pacing_shift_update(struct sock *sk, int val)
{
 if (!sk || !sk_fullsock(sk) || ({ union { typeof(sk->sk_pacing_shift) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_pacing_shift), __u.__c, sizeof(sk->sk_pacing_shift)); else __read_once_size_nocheck(&(sk->sk_pacing_shift), __u.__c, sizeof(sk->sk_pacing_shift)); do { } while (0); __u.__val; }) == val)
  return;
 ({ union { typeof(sk->sk_pacing_shift) __val; char __c[1]; } __u = { .__val = ( typeof(sk->sk_pacing_shift)) (val) }; __write_once_size(&(sk->sk_pacing_shift), __u.__c, sizeof(sk->sk_pacing_shift)); __u.__val; });
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_dev_equal_l3scope(struct sock *sk, int dif)
{
 int mdif;

 if (!sk->__sk_common.skc_bound_dev_if || sk->__sk_common.skc_bound_dev_if == dif)
  return true;

 mdif = l3mdev_master_ifindex_by_index(sock_net(sk), dif);
 if (mdif && mdif == sk->__sk_common.skc_bound_dev_if)
  return true;

 return false;
}

void sock_def_readable(struct sock *sk);
# 20 "/home/nathan/src/linux-next/include/linux/tcp.h" 2
# 1 "/home/nathan/src/linux-next/include/net/inet_connection_sock.h" 1
# 20 "/home/nathan/src/linux-next/include/net/inet_connection_sock.h"
# 1 "/home/nathan/src/linux-next/include/net/inet_sock.h" 1
# 23 "/home/nathan/src/linux-next/include/net/inet_sock.h"
# 1 "/home/nathan/src/linux-next/include/net/request_sock.h" 1
# 22 "/home/nathan/src/linux-next/include/net/request_sock.h"
struct request_sock;
struct sk_buff;
struct dst_entry;
struct proto;

struct request_sock_ops {
 int family;
 unsigned int obj_size;
 struct kmem_cache *slab;
 char *slab_name;
 int (*rtx_syn_ack)(const struct sock *sk,
           struct request_sock *req);
 void (*send_ack)(const struct sock *sk, struct sk_buff *skb,
        struct request_sock *req);
 void (*send_reset)(const struct sock *sk,
          struct sk_buff *skb);
 void (*destructor)(struct request_sock *req);
 void (*syn_ack_timeout)(const struct request_sock *req);
};

int inet_rtx_syn_ack(const struct sock *parent, struct request_sock *req);



struct request_sock {
 struct sock_common __req_common;






 struct request_sock *dl_next;
 u16 mss;
 u8 num_retrans;
 u8 cookie_ts:1;
 u8 num_timeout:7;
 u32 ts_recent;
 struct timer_list rsk_timer;
 const struct request_sock_ops *rsk_ops;
 struct sock *sk;
 u32 *saved_syn;
 u32 secid;
 u32 peer_secid;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct request_sock *inet_reqsk(const struct sock *sk)
{
 return (struct request_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *req_to_sk(struct request_sock *req)
{
 return (struct sock *)req;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct request_sock *
reqsk_alloc(const struct request_sock_ops *ops, struct sock *sk_listener,
     bool attach_listener)
{
 struct request_sock *req;

 req = kmem_cache_alloc(ops->slab, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)) | (( gfp_t)0x2000u));
 if (!req)
  return ((void *)0);
 req->__req_common.skc_listener = ((void *)0);
 if (attach_listener) {
  if (__builtin_expect(!!(!refcount_inc_not_zero(&sk_listener->__sk_common.skc_refcnt)), 0)) {
   kmem_cache_free(ops->slab, req);
   return ((void *)0);
  }
  req->__req_common.skc_listener = sk_listener;
 }
 req->rsk_ops = ops;
 req_to_sk(req)->__sk_common.skc_prot = sk_listener->__sk_common.skc_prot;
 sk_node_init(&req_to_sk(req)->__sk_common.skc_node);
 sk_tx_queue_clear(req_to_sk(req));
 req->saved_syn = ((void *)0);
 req->num_timeout = 0;
 req->num_retrans = 0;
 req->sk = ((void *)0);
 refcount_set(&req->__req_common.skc_refcnt, 0);

 return req;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __reqsk_free(struct request_sock *req)
{
 req->rsk_ops->destructor(req);
 if (req->__req_common.skc_listener)
  sock_put(req->__req_common.skc_listener);
 kfree(req->saved_syn);
 kmem_cache_free(req->rsk_ops->slab, req);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reqsk_free(struct request_sock *req)
{
 ({ int __ret_warn_on = !!(refcount_read(&req->__req_common.skc_refcnt) != 0); if (__builtin_expect(!!(__ret_warn_on), 0)) __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("include/net/request_sock.h"), "i" (119), "i" ((1 << 0) | ((1 << 1) | ((9) << 8))), "i" (sizeof(struct bug_entry))); __builtin_expect(!!(__ret_warn_on), 0); });
 __reqsk_free(req);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reqsk_put(struct request_sock *req)
{
 if (refcount_dec_and_test(&req->__req_common.skc_refcnt))
  reqsk_free(req);
}
# 146 "/home/nathan/src/linux-next/include/net/request_sock.h"
struct fastopen_queue {
 struct request_sock *rskq_rst_head;
 struct request_sock *rskq_rst_tail;



 spinlock_t lock;
 int qlen;
 int max_qlen;

 struct tcp_fastopen_context *ctx;
};
# 166 "/home/nathan/src/linux-next/include/net/request_sock.h"
struct request_sock_queue {
 spinlock_t rskq_lock;
 u8 rskq_defer_accept;

 u32 synflood_warned;
 atomic_t qlen;
 atomic_t young;

 struct request_sock *rskq_accept_head;
 struct request_sock *rskq_accept_tail;
 struct fastopen_queue fastopenq;


};

void reqsk_queue_alloc(struct request_sock_queue *queue);

void reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,
      bool reset);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool reqsk_queue_empty(const struct request_sock_queue *queue)
{
 return ({ union { typeof(queue->rskq_accept_head) __val; char __c[1]; } __u; if (1) __read_once_size(&(queue->rskq_accept_head), __u.__c, sizeof(queue->rskq_accept_head)); else __read_once_size_nocheck(&(queue->rskq_accept_head), __u.__c, sizeof(queue->rskq_accept_head)); do { } while (0); __u.__val; }) == ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct request_sock *reqsk_queue_remove(struct request_sock_queue *queue,
            struct sock *parent)
{
 struct request_sock *req;

 spin_lock_bh(&queue->rskq_lock);
 req = queue->rskq_accept_head;
 if (req) {
  sk_acceptq_removed(parent);
  ({ union { typeof(queue->rskq_accept_head) __val; char __c[1]; } __u = { .__val = ( typeof(queue->rskq_accept_head)) (req->dl_next) }; __write_once_size(&(queue->rskq_accept_head), __u.__c, sizeof(queue->rskq_accept_head)); __u.__val; });
  if (queue->rskq_accept_head == ((void *)0))
   queue->rskq_accept_tail = ((void *)0);
 }
 spin_unlock_bh(&queue->rskq_lock);
 return req;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reqsk_queue_removed(struct request_sock_queue *queue,
           const struct request_sock *req)
{
 if (req->num_timeout == 0)
  atomic_dec(&queue->young);
 atomic_dec(&queue->qlen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void reqsk_queue_added(struct request_sock_queue *queue)
{
 atomic_inc(&queue->young);
 atomic_inc(&queue->qlen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int reqsk_queue_len(const struct request_sock_queue *queue)
{
 return atomic_read(&queue->qlen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int reqsk_queue_len_young(const struct request_sock_queue *queue)
{
 return atomic_read(&queue->young);
}
# 24 "/home/nathan/src/linux-next/include/net/inet_sock.h" 2
# 1 "/home/nathan/src/linux-next/include/net/netns/hash.h" 1






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 net_hash_mix(const struct net *net)
{
 return net->hash_mix;
}
# 25 "/home/nathan/src/linux-next/include/net/inet_sock.h" 2
# 39 "/home/nathan/src/linux-next/include/net/inet_sock.h"
struct ip_options {
 __be32 faddr;
 __be32 nexthop;
 unsigned char optlen;
 unsigned char srr;
 unsigned char rr;
 unsigned char ts;
 unsigned char is_strictroute:1,
   srr_is_hit:1,
   is_changed:1,
   rr_needaddr:1,
   ts_needtime:1,
   ts_needaddr:1;
 unsigned char router_alert;
 unsigned char cipso;
 unsigned char __pad2;
 unsigned char __data[0];
};

struct ip_options_rcu {
 struct callback_head rcu;
 struct ip_options opt;
};

struct ip_options_data {
 struct ip_options_rcu opt;
 char data[40];
};

struct inet_request_sock {
 struct request_sock req;
# 82 "/home/nathan/src/linux-next/include/net/inet_sock.h"
 u16 snd_wscale : 4,
    rcv_wscale : 4,
    tstamp_ok : 1,
    sack_ok : 1,
    wscale_ok : 1,
    ecn_ok : 1,
    acked : 1,
    no_srccheck: 1,
    smc_ok : 1;
 u32 ir_mark;
 union {
  struct ip_options_rcu *ireq_opt;

  struct {
   struct ipv6_txoptions *ipv6_opt;
   struct sk_buff *pktopts;
  };

 };
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_request_sock *inet_rsk(const struct request_sock *sk)
{
 return (struct inet_request_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 inet_request_mark(const struct sock *sk, struct sk_buff *skb)
{
 if (!sk->sk_mark && sock_net(sk)->ipv4.sysctl_tcp_fwmark_accept)
  return skb->mark;

 return sk->sk_mark;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_request_bound_dev_if(const struct sock *sk,
         struct sk_buff *skb)
{







 return sk->__sk_common.skc_bound_dev_if;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_sk_bound_l3mdev(const struct sock *sk)
{
# 139 "/home/nathan/src/linux-next/include/net/inet_sock.h"
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_bound_dev_eq(bool l3mdev_accept, int bound_dev_if,
         int dif, int sdif)
{
 if (!bound_dev_if)
  return !sdif || l3mdev_accept;
 return bound_dev_if == dif || bound_dev_if == sdif;
}

struct inet_cork {
 unsigned int flags;
 __be32 addr;
 struct ip_options *opt;
 unsigned int fragsize;
 int length;
 struct dst_entry *dst;
 u8 tx_flags;
 __u8 ttl;
 __s16 tos;
 char priority;
 __u16 gso_size;
 u64 transmit_time;
 u32 mark;
};

struct inet_cork_full {
 struct inet_cork base;
 struct flowi fl;
};

struct ip_mc_socklist;
struct ipv6_pinfo;
struct rtable;
# 195 "/home/nathan/src/linux-next/include/net/inet_sock.h"
struct inet_sock {

 struct sock sk;

 struct ipv6_pinfo *pinet6;







 __be32 inet_saddr;
 __s16 uc_ttl;
 __u16 cmsg_flags;
 __be16 inet_sport;
 __u16 inet_id;

 struct ip_options_rcu *inet_opt;
 int rx_dst_ifindex;
 __u8 tos;
 __u8 min_ttl;
 __u8 mc_ttl;
 __u8 pmtudisc;
 __u8 recverr:1,
    is_icsk:1,
    freebind:1,
    hdrincl:1,
    mc_loop:1,
    transparent:1,
    mc_all:1,
    nodefrag:1;
 __u8 bind_address_no_port:1,
    defer_connect:1;



 __u8 rcv_tos;
 __u8 convert_csum;
 int uc_index;
 int mc_index;
 __be32 mc_addr;
 struct ip_mc_socklist *mc_list;
 struct inet_cork_full cork;
};
# 262 "/home/nathan/src/linux-next/include/net/inet_sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *sk_to_full_sk(struct sock *sk)
{

 if (sk && sk->__sk_common.skc_state == TCP_NEW_SYN_RECV)
  sk = inet_reqsk(sk)->__req_common.skc_listener;

 return sk;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct sock *sk_const_to_full_sk(const struct sock *sk)
{

 if (sk && sk->__sk_common.skc_state == TCP_NEW_SYN_RECV)
  sk = ((const struct request_sock *)sk)->__req_common.skc_listener;

 return sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *skb_to_full_sk(const struct sk_buff *skb)
{
 return sk_to_full_sk(skb->sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_sock *inet_sk(const struct sock *sk)
{
 return (struct inet_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __inet_sk_copy_descendant(struct sock *sk_to,
          const struct sock *sk_from,
          const int ancestor_size)
{
 memcpy(inet_sk(sk_to) + 1, inet_sk(sk_from) + 1,
        sk_from->__sk_common.skc_prot->obj_size - ancestor_size);
}
# 306 "/home/nathan/src/linux-next/include/net/inet_sock.h"
int inet_sk_rebuild_header(struct sock *sk);
# 315 "/home/nathan/src/linux-next/include/net/inet_sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_sk_state_load(const struct sock *sk)
{

 return ({ typeof(*&sk->__sk_common.skc_state) ___p1 = ({ union { typeof(*&sk->__sk_common.skc_state) __val; char __c[1]; } __u; if (1) __read_once_size(&(*&sk->__sk_common.skc_state), __u.__c, sizeof(*&sk->__sk_common.skc_state)); else __read_once_size_nocheck(&(*&sk->__sk_common.skc_state), __u.__c, sizeof(*&sk->__sk_common.skc_state)); do { } while (0); __u.__val; }); do { extern void __compiletime_assert_318(void) ; if (!((sizeof(*&sk->__sk_common.skc_state) == sizeof(char) || sizeof(*&sk->__sk_common.skc_state) == sizeof(short) || sizeof(*&sk->__sk_common.skc_state) == sizeof(int) || sizeof(*&sk->__sk_common.skc_state) == sizeof(long)))) __compiletime_assert_318(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; });
}
# 329 "/home/nathan/src/linux-next/include/net/inet_sock.h"
void inet_sk_state_store(struct sock *sk, int newstate);

void inet_sk_set_state(struct sock *sk, int state);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __inet_ehashfn(const __be32 laddr,
       const __u16 lport,
       const __be32 faddr,
       const __be16 fport,
       u32 initval)
{
 return jhash_3words(( __u32) laddr,
       ( __u32) faddr,
       ((__u32) lport) << 16 | ( __u32)fport,
       initval);
}

struct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops,
          struct sock *sk_listener,
          bool attach_listener);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 inet_sk_flowi_flags(const struct sock *sk)
{
 __u8 flags = 0;

 if (inet_sk(sk)->transparent || inet_sk(sk)->hdrincl)
  flags |= 0x01;
 return flags;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_inc_convert_csum(struct sock *sk)
{
 inet_sk(sk)->convert_csum++;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_dec_convert_csum(struct sock *sk)
{
 if (inet_sk(sk)->convert_csum > 0)
  inet_sk(sk)->convert_csum--;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_get_convert_csum(struct sock *sk)
{
 return !!inet_sk(sk)->convert_csum;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_can_nonlocal_bind(struct net *net,
       struct inet_sock *inet)
{
 return net->ipv4.sysctl_ip_nonlocal_bind ||
  inet->freebind || inet->transparent;
}
# 21 "/home/nathan/src/linux-next/include/net/inet_connection_sock.h" 2





struct inet_bind_bucket;
struct tcp_congestion_ops;





struct inet_connection_sock_af_ops {
 int (*queue_xmit)(struct sock *sk, struct sk_buff *skb, struct flowi *fl);
 void (*send_check)(struct sock *sk, struct sk_buff *skb);
 int (*rebuild_header)(struct sock *sk);
 void (*sk_rx_dst_set)(struct sock *sk, const struct sk_buff *skb);
 int (*conn_request)(struct sock *sk, struct sk_buff *skb);
 struct sock *(*syn_recv_sock)(const struct sock *sk, struct sk_buff *skb,
          struct request_sock *req,
          struct dst_entry *dst,
          struct request_sock *req_unhash,
          bool *own_req);
 u16 net_header_len;
 u16 net_frag_header_len;
 u16 sockaddr_len;
 int (*setsockopt)(struct sock *sk, int level, int optname,
      char *optval, unsigned int optlen);
 int (*getsockopt)(struct sock *sk, int level, int optname,
      char *optval, int *optlen);

 int (*compat_setsockopt)(struct sock *sk,
    int level, int optname,
    char *optval, unsigned int optlen);
 int (*compat_getsockopt)(struct sock *sk,
    int level, int optname,
    char *optval, int *optlen);

 void (*addr2sockaddr)(struct sock *sk, struct sockaddr *);
 void (*mtu_reduced)(struct sock *sk);
};
# 87 "/home/nathan/src/linux-next/include/net/inet_connection_sock.h"
struct inet_connection_sock {

 struct inet_sock icsk_inet;
 struct request_sock_queue icsk_accept_queue;
 struct inet_bind_bucket *icsk_bind_hash;
 unsigned long icsk_timeout;
  struct timer_list icsk_retransmit_timer;
  struct timer_list icsk_delack_timer;
 __u32 icsk_rto;
 __u32 icsk_pmtu_cookie;
 const struct tcp_congestion_ops *icsk_ca_ops;
 const struct inet_connection_sock_af_ops *icsk_af_ops;
 const struct tcp_ulp_ops *icsk_ulp_ops;
 void *icsk_ulp_data;
 void (*icsk_clean_acked)(struct sock *sk, u32 acked_seq);
 struct hlist_node icsk_listen_portaddr_node;
 unsigned int (*icsk_sync_mss)(struct sock *sk, u32 pmtu);
 __u8 icsk_ca_state:6,
      icsk_ca_setsockopt:1,
      icsk_ca_dst_locked:1;
 __u8 icsk_retransmits;
 __u8 icsk_pending;
 __u8 icsk_backoff;
 __u8 icsk_syn_retries;
 __u8 icsk_probes_out;
 __u16 icsk_ext_hdr_len;
 struct {
  __u8 pending;
  __u8 quick;
  __u8 pingpong;
  __u8 blocked;
  __u32 ato;
  unsigned long timeout;
  __u32 lrcvtime;
  __u16 last_seg_size;
  __u16 rcv_mss;
 } icsk_ack;
 struct {
  int enabled;


  int search_high;
  int search_low;


  int probe_size;

  u32 probe_timestamp;
 } icsk_mtup;
 u32 icsk_user_timeout;

 u64 icsk_ca_priv[104 / sizeof(u64)];

};
# 149 "/home/nathan/src/linux-next/include/net/inet_connection_sock.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_connection_sock *inet_csk(const struct sock *sk)
{
 return (struct inet_connection_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *inet_csk_ca(const struct sock *sk)
{
 return (void *)inet_csk(sk)->icsk_ca_priv;
}

struct sock *inet_csk_clone_lock(const struct sock *sk,
     const struct request_sock *req,
     const gfp_t priority);

enum inet_csk_ack_state_t {
 ICSK_ACK_SCHED = 1,
 ICSK_ACK_TIMER = 2,
 ICSK_ACK_PUSHED = 4,
 ICSK_ACK_PUSHED2 = 8,
 ICSK_ACK_NOW = 16
};

void inet_csk_init_xmit_timers(struct sock *sk,
          void (*retransmit_handler)(struct timer_list *),
          void (*delack_handler)(struct timer_list *),
          void (*keepalive_handler)(struct timer_list *));
void inet_csk_clear_xmit_timers(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_schedule_ack(struct sock *sk)
{
 inet_csk(sk)->icsk_ack.pending |= ICSK_ACK_SCHED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_csk_ack_scheduled(const struct sock *sk)
{
 return inet_csk(sk)->icsk_ack.pending & ICSK_ACK_SCHED;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_delack_init(struct sock *sk)
{
 memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
}

void inet_csk_delete_keepalive_timer(struct sock *sk);
void inet_csk_reset_keepalive_timer(struct sock *sk, unsigned long timeout);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_clear_xmit_timer(struct sock *sk, const int what)
{
 struct inet_connection_sock *icsk = inet_csk(sk);

 if (what == 1 || what == 3) {
  icsk->icsk_pending = 0;



 } else if (what == 2) {
  icsk->icsk_ack.blocked = icsk->icsk_ack.pending = 0;



 } else {
  ({ if (0) printk("\001" "7" "inet_csk BUG: unknown timer value\n"); 0; });
 }
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_reset_xmit_timer(struct sock *sk, const int what,
          unsigned long when,
          const unsigned long max_when)
{
 struct inet_connection_sock *icsk = inet_csk(sk);

 if (when > max_when) {
  ({ if (0) printk("\001" "7" "reset_xmit_timer: sk=%p %d when=0x%lx, caller=%p\n", sk, what, when, (void *)({ __label__ __here; __here: (unsigned long)&&__here; })); 0; });

  when = max_when;
 }

 if (what == 1 || what == 3 ||
     what == 4 || what == 5 ||
     what == 6) {
  icsk->icsk_pending = what;
  icsk->icsk_timeout = jiffies + when;
  sk_reset_timer(sk, &icsk->icsk_retransmit_timer, icsk->icsk_timeout);
 } else if (what == 2) {
  icsk->icsk_ack.pending |= ICSK_ACK_TIMER;
  icsk->icsk_ack.timeout = jiffies + when;
  sk_reset_timer(sk, &icsk->icsk_delack_timer, icsk->icsk_ack.timeout);
 } else {
  ({ if (0) printk("\001" "7" "inet_csk BUG: unknown timer value\n"); 0; });
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long
inet_csk_rto_backoff(const struct inet_connection_sock *icsk,
       unsigned long max_when)
{
        u64 when = (u64)icsk->icsk_rto << icsk->icsk_backoff;

        return (unsigned long)__builtin_choose_expr(((!!(sizeof((typeof((u64)(when)) *)1 == (typeof((u64)(max_when)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(when)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(max_when)) * 0l)) : (int *)8))))), (((u64)(when)) < ((u64)(max_when)) ? ((u64)(when)) : ((u64)(max_when))), ({ typeof((u64)(when)) __UNIQUE_ID___x82 = ((u64)(when)); typeof((u64)(max_when)) __UNIQUE_ID___y83 = ((u64)(max_when)); ((__UNIQUE_ID___x82) < (__UNIQUE_ID___y83) ? (__UNIQUE_ID___x82) : (__UNIQUE_ID___y83)); }));
}

struct sock *inet_csk_accept(struct sock *sk, int flags, int *err, bool kern);

int inet_csk_get_port(struct sock *sk, unsigned short snum);

struct dst_entry *inet_csk_route_req(const struct sock *sk, struct flowi4 *fl4,
         const struct request_sock *req);
struct dst_entry *inet_csk_route_child_sock(const struct sock *sk,
         struct sock *newsk,
         const struct request_sock *req);

struct sock *inet_csk_reqsk_queue_add(struct sock *sk,
          struct request_sock *req,
          struct sock *child);
void inet_csk_reqsk_queue_hash_add(struct sock *sk, struct request_sock *req,
       unsigned long timeout);
struct sock *inet_csk_complete_hashdance(struct sock *sk, struct sock *child,
      struct request_sock *req,
      bool own_req);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_reqsk_queue_added(struct sock *sk)
{
 reqsk_queue_added(&inet_csk(sk)->icsk_accept_queue);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_csk_reqsk_queue_len(const struct sock *sk)
{
 return reqsk_queue_len(&inet_csk(sk)->icsk_accept_queue);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_csk_reqsk_queue_is_full(const struct sock *sk)
{
 return inet_csk_reqsk_queue_len(sk) >= sk->sk_max_ack_backlog;
}

void inet_csk_reqsk_queue_drop(struct sock *sk, struct request_sock *req);
void inet_csk_reqsk_queue_drop_and_put(struct sock *sk, struct request_sock *req);

void inet_csk_destroy_sock(struct sock *sk);
void inet_csk_prepare_forced_close(struct sock *sk);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __poll_t inet_csk_listen_poll(const struct sock *sk)
{
 return !reqsk_queue_empty(&inet_csk(sk)->icsk_accept_queue) ?
   (( __poll_t)0x00000001 | ( __poll_t)0x00000040) : 0;
}

int inet_csk_listen_start(struct sock *sk, int backlog);
void inet_csk_listen_stop(struct sock *sk);

void inet_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr);

int inet_csk_compat_getsockopt(struct sock *sk, int level, int optname,
          char *optval, int *optlen);
int inet_csk_compat_setsockopt(struct sock *sk, int level, int optname,
          char *optval, unsigned int optlen);

struct dst_entry *inet_csk_update_pmtu(struct sock *sk, u32 mtu);



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_enter_pingpong_mode(struct sock *sk)
{
 inet_csk(sk)->icsk_ack.pingpong = 3;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_exit_pingpong_mode(struct sock *sk)
{
 inet_csk(sk)->icsk_ack.pingpong = 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_csk_in_pingpong_mode(struct sock *sk)
{
 return inet_csk(sk)->icsk_ack.pingpong >= 3;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_csk_inc_pingpong_cnt(struct sock *sk)
{
 struct inet_connection_sock *icsk = inet_csk(sk);

 if (icsk->icsk_ack.pingpong < ((u8)~0U))
  icsk->icsk_ack.pingpong++;
}
# 21 "/home/nathan/src/linux-next/include/linux/tcp.h" 2
# 1 "/home/nathan/src/linux-next/include/net/inet_timewait_sock.h" 1
# 22 "/home/nathan/src/linux-next/include/net/inet_timewait_sock.h"
# 1 "/home/nathan/src/linux-next/include/net/timewait_sock.h" 1
# 14 "/home/nathan/src/linux-next/include/net/timewait_sock.h"
struct timewait_sock_ops {
 struct kmem_cache *twsk_slab;
 char *twsk_slab_name;
 unsigned int twsk_obj_size;
 int (*twsk_unique)(struct sock *sk,
           struct sock *sktw, void *twp);
 void (*twsk_destructor)(struct sock *sk);
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int twsk_unique(struct sock *sk, struct sock *sktw, void *twp)
{
 if (sk->__sk_common.skc_prot->twsk_prot->twsk_unique != ((void *)0))
  return sk->__sk_common.skc_prot->twsk_prot->twsk_unique(sk, sktw, twp);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void twsk_destructor(struct sock *sk)
{
 if (sk->__sk_common.skc_prot->twsk_prot->twsk_destructor != ((void *)0))
  sk->__sk_common.skc_prot->twsk_prot->twsk_destructor(sk);
}
# 23 "/home/nathan/src/linux-next/include/net/inet_timewait_sock.h" 2



struct inet_bind_bucket;






struct inet_timewait_sock {




 struct sock_common __tw_common;
# 60 "/home/nathan/src/linux-next/include/net/inet_timewait_sock.h"
 __u32 tw_mark;
 volatile unsigned char tw_substate;
 unsigned char tw_rcv_wscale;



 __be16 tw_sport;

 unsigned int tw_kill : 1,
    tw_transparent : 1,
    tw_flowlabel : 20,
    tw_pad : 2,
    tw_tos : 8;
 u32 tw_txhash;
 u32 tw_priority;
 struct timer_list tw_timer;
 struct inet_bind_bucket *tw_tb;
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_timewait_sock *inet_twsk(const struct sock *sk)
{
 return (struct inet_timewait_sock *)sk;
}

void inet_twsk_free(struct inet_timewait_sock *tw);
void inet_twsk_put(struct inet_timewait_sock *tw);

void inet_twsk_bind_unhash(struct inet_timewait_sock *tw,
      struct inet_hashinfo *hashinfo);

struct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk,
        struct inet_timewait_death_row *dr,
        const int state);

void inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,
    struct inet_hashinfo *hashinfo);

void __inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo,
     bool rearm);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo)
{
 __inet_twsk_schedule(tw, timeo, false);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_twsk_reschedule(struct inet_timewait_sock *tw, int timeo)
{
 __inet_twsk_schedule(tw, timeo, true);
}

void inet_twsk_deschedule_put(struct inet_timewait_sock *tw);

void inet_twsk_purge(struct inet_hashinfo *hashinfo, int family);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct net *twsk_net(const struct inet_timewait_sock *twsk)
{
 return read_pnet(&twsk->__tw_common.skc_net);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void twsk_net_set(struct inet_timewait_sock *twsk, struct net *net)
{
 write_pnet(&twsk->__tw_common.skc_net, net);
}
# 22 "/home/nathan/src/linux-next/include/linux/tcp.h" 2
# 1 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h" 1
# 25 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h"
struct tcphdr {
 __be16 source;
 __be16 dest;
 __be32 seq;
 __be32 ack_seq;
# 42 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h"
 __u16 doff:4,
  res1:4,
  cwr:1,
  ece:1,
  urg:1,
  ack:1,
  psh:1,
  rst:1,
  syn:1,
  fin:1;



 __be16 window;
 __sum16 check;
 __be16 urg_ptr;
};






union tcp_word_hdr {
 struct tcphdr hdr;
 __be32 words[5];
};



enum {
 TCP_FLAG_CWR = (( __be32)(__u32)(0x00800000)),
 TCP_FLAG_ECE = (( __be32)(__u32)(0x00400000)),
 TCP_FLAG_URG = (( __be32)(__u32)(0x00200000)),
 TCP_FLAG_ACK = (( __be32)(__u32)(0x00100000)),
 TCP_FLAG_PSH = (( __be32)(__u32)(0x00080000)),
 TCP_FLAG_RST = (( __be32)(__u32)(0x00040000)),
 TCP_FLAG_SYN = (( __be32)(__u32)(0x00020000)),
 TCP_FLAG_FIN = (( __be32)(__u32)(0x00010000)),
 TCP_RESERVED_BITS = (( __be32)(__u32)(0x0F000000)),
 TCP_DATA_OFFSET = (( __be32)(__u32)(0xF0000000))
};
# 137 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h"
struct tcp_repair_opt {
 __u32 opt_code;
 __u32 opt_val;
};

struct tcp_repair_window {
 __u32 snd_wl1;
 __u32 snd_wnd;
 __u32 max_window;

 __u32 rcv_wnd;
 __u32 rcv_wup;
};

enum {
 TCP_NO_QUEUE,
 TCP_RECV_QUEUE,
 TCP_SEND_QUEUE,
 TCP_QUEUES_NR,
};


enum tcp_fastopen_client_fail {
 TFO_STATUS_UNSPEC,
 TFO_COOKIE_UNAVAILABLE,
 TFO_DATA_NOT_ACKED,
 TFO_SYN_RETRANSMITTED,
};
# 179 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h"
enum tcp_ca_state {




 TCP_CA_Open = 0,







 TCP_CA_Disorder = 1,






 TCP_CA_CWR = 2,





 TCP_CA_Recovery = 3,




 TCP_CA_Loss = 4

};

struct tcp_info {
 __u8 tcpi_state;
 __u8 tcpi_ca_state;
 __u8 tcpi_retransmits;
 __u8 tcpi_probes;
 __u8 tcpi_backoff;
 __u8 tcpi_options;
 __u8 tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
 __u8 tcpi_delivery_rate_app_limited:1, tcpi_fastopen_client_fail:2;

 __u32 tcpi_rto;
 __u32 tcpi_ato;
 __u32 tcpi_snd_mss;
 __u32 tcpi_rcv_mss;

 __u32 tcpi_unacked;
 __u32 tcpi_sacked;
 __u32 tcpi_lost;
 __u32 tcpi_retrans;
 __u32 tcpi_fackets;


 __u32 tcpi_last_data_sent;
 __u32 tcpi_last_ack_sent;
 __u32 tcpi_last_data_recv;
 __u32 tcpi_last_ack_recv;


 __u32 tcpi_pmtu;
 __u32 tcpi_rcv_ssthresh;
 __u32 tcpi_rtt;
 __u32 tcpi_rttvar;
 __u32 tcpi_snd_ssthresh;
 __u32 tcpi_snd_cwnd;
 __u32 tcpi_advmss;
 __u32 tcpi_reordering;

 __u32 tcpi_rcv_rtt;
 __u32 tcpi_rcv_space;

 __u32 tcpi_total_retrans;

 __u64 tcpi_pacing_rate;
 __u64 tcpi_max_pacing_rate;
 __u64 tcpi_bytes_acked;
 __u64 tcpi_bytes_received;
 __u32 tcpi_segs_out;
 __u32 tcpi_segs_in;

 __u32 tcpi_notsent_bytes;
 __u32 tcpi_min_rtt;
 __u32 tcpi_data_segs_in;
 __u32 tcpi_data_segs_out;

 __u64 tcpi_delivery_rate;

 __u64 tcpi_busy_time;
 __u64 tcpi_rwnd_limited;
 __u64 tcpi_sndbuf_limited;

 __u32 tcpi_delivered;
 __u32 tcpi_delivered_ce;

 __u64 tcpi_bytes_sent;
 __u64 tcpi_bytes_retrans;
 __u32 tcpi_dsack_dups;
 __u32 tcpi_reord_seen;

 __u32 tcpi_rcv_ooopack;

 __u32 tcpi_snd_wnd;


};


enum {
 TCP_NLA_PAD,
 TCP_NLA_BUSY,
 TCP_NLA_RWND_LIMITED,
 TCP_NLA_SNDBUF_LIMITED,
 TCP_NLA_DATA_SEGS_OUT,
 TCP_NLA_TOTAL_RETRANS,
 TCP_NLA_PACING_RATE,
 TCP_NLA_DELIVERY_RATE,
 TCP_NLA_SND_CWND,
 TCP_NLA_REORDERING,
 TCP_NLA_MIN_RTT,
 TCP_NLA_RECUR_RETRANS,
 TCP_NLA_DELIVERY_RATE_APP_LMT,
 TCP_NLA_SNDQ_SIZE,
 TCP_NLA_CA_STATE,
 TCP_NLA_SND_SSTHRESH,
 TCP_NLA_DELIVERED,
 TCP_NLA_DELIVERED_CE,
 TCP_NLA_BYTES_SENT,
 TCP_NLA_BYTES_RETRANS,
 TCP_NLA_DSACK_DUPS,
 TCP_NLA_REORD_SEEN,
 TCP_NLA_SRTT,
 TCP_NLA_TIMEOUT_REHASH,
};
# 324 "/home/nathan/src/linux-next/include/uapi/linux/tcp.h"
struct tcp_md5sig {
 struct __kernel_sockaddr_storage tcpm_addr;
 __u8 tcpm_flags;
 __u8 tcpm_prefixlen;
 __u16 tcpm_keylen;
 int tcpm_ifindex;
 __u8 tcpm_key[80];
};


struct tcp_diag_md5sig {
 __u8 tcpm_family;
 __u8 tcpm_prefixlen;
 __u16 tcpm_keylen;
 __be32 tcpm_addr[4];
 __u8 tcpm_key[80];
};



struct tcp_zerocopy_receive {
 __u64 address;
 __u32 length;
 __u32 recv_skip_hint;
};
# 23 "/home/nathan/src/linux-next/include/linux/tcp.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcphdr *tcp_hdr(const struct sk_buff *skb)
{
 return (struct tcphdr *)skb_transport_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int __tcp_hdrlen(const struct tcphdr *th)
{
 return th->doff * 4;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int tcp_hdrlen(const struct sk_buff *skb)
{
 return __tcp_hdrlen(tcp_hdr(skb));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcphdr *inner_tcp_hdr(const struct sk_buff *skb)
{
 return (struct tcphdr *)skb_inner_transport_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int inner_tcp_hdrlen(const struct sk_buff *skb)
{
 return inner_tcp_hdr(skb)->doff * 4;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int tcp_optlen(const struct sk_buff *skb)
{
 return (tcp_hdr(skb)->doff - 5) * 4;
}







struct tcp_fastopen_cookie {
 __le64 val[(((16) + (sizeof(u64)) - 1) / (sizeof(u64)))];
 s8 len;
 bool exp;
};


struct tcp_sack_block_wire {
 __be32 start_seq;
 __be32 end_seq;
};

struct tcp_sack_block {
 u32 start_seq;
 u32 end_seq;
};
# 102 "/home/nathan/src/linux-next/include/linux/tcp.h"
struct tcp_options_received {

 int ts_recent_stamp;
 u32 ts_recent;
 u32 rcv_tsval;
 u32 rcv_tsecr;
 u16 saw_tstamp : 1,
  tstamp_ok : 1,
  dsack : 1,
  wscale_ok : 1,
  sack_ok : 3,
  smc_ok : 1,
  snd_wscale : 4,
  rcv_wscale : 4;
 u8 num_sacks;
 u16 user_mss;
 u16 mss_clamp;



};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_clear_options(struct tcp_options_received *rx_opt)
{
 rx_opt->tstamp_ok = rx_opt->sack_ok = 0;
 rx_opt->wscale_ok = rx_opt->snd_wscale = 0;
# 136 "/home/nathan/src/linux-next/include/linux/tcp.h"
}







struct tcp_request_sock_ops;

struct tcp_request_sock {
 struct inet_request_sock req;
 const struct tcp_request_sock_ops *af_specific;
 u64 snt_synack;
 bool tfo_listener;
 bool is_mptcp;
 u32 txhash;
 u32 rcv_isn;
 u32 snt_isn;
 u32 ts_off;
 u32 last_oow_ack_time;
 u32 rcv_nxt;



};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcp_request_sock *tcp_rsk(const struct request_sock *req)
{
 return (struct tcp_request_sock *)req;
}

struct tcp_sock {

 struct inet_connection_sock inet_conn;
 u16 tcp_header_len;
 u16 gso_segs;





 __be32 pred_flags;






 u64 bytes_received;



 u32 segs_in;


 u32 data_segs_in;


  u32 rcv_nxt;
 u32 copied_seq;
 u32 rcv_wup;
  u32 snd_nxt;
 u32 segs_out;


 u32 data_segs_out;


 u64 bytes_sent;


 u64 bytes_acked;



 u32 dsack_dups;


  u32 snd_una;
  u32 snd_sml;
 u32 rcv_tstamp;
 u32 lsndtime;
 u32 last_oow_ack_time;
 u32 compressed_ack_rcv_nxt;

 u32 tsoffset;

 struct list_head tsq_node;
 struct list_head tsorted_sent_queue;

 u32 snd_wl1;
 u32 snd_wnd;
 u32 max_window;
 u32 mss_cache;

 u32 window_clamp;
 u32 rcv_ssthresh;


 struct tcp_rack {
  u64 mstamp;
  u32 rtt_us;
  u32 end_seq;
  u32 last_delivered;
  u8 reo_wnd_steps;

  u8 reo_wnd_persist:5,
     dsack_seen:1,
     advanced:1;
 } rack;
 u16 advmss;
 u8 compressed_ack;
 u32 chrono_start;
 u32 chrono_stat[3];
 u8 chrono_type:2,
  rate_app_limited:1,
  fastopen_connect:1,
  fastopen_no_cookie:1,
  is_sack_reneg:1,
  fastopen_client_fail:2;
 u8 nonagle : 4,
  thin_lto : 1,
  recvmsg_inq : 1,
  repair : 1,
  frto : 1;
 u8 repair_queue;
 u8 syn_data:1,
  syn_fastopen:1,
  syn_fastopen_exp:1,
  syn_fastopen_ch:1,
  syn_data_acked:1,
  save_syn:1,
  is_cwnd_limited:1,
  syn_smc:1;
 u32 tlp_high_seq;

 u32 tcp_tx_delay;
 u64 tcp_wstamp_ns;
 u64 tcp_clock_cache;


 u64 tcp_mstamp;
 u32 srtt_us;
 u32 mdev_us;
 u32 mdev_max_us;
 u32 rttvar_us;
 u32 rtt_seq;
 struct minmax rtt_min;

 u32 packets_out;
 u32 retrans_out;
 u32 max_packets_out;
 u32 max_packets_seq;

 u16 urg_data;
 u8 ecn_flags;
 u8 keepalive_probes;
 u32 reordering;
 u32 reord_seen;
 u32 snd_up;




 struct tcp_options_received rx_opt;




  u32 snd_ssthresh;
  u32 snd_cwnd;
 u32 snd_cwnd_cnt;
 u32 snd_cwnd_clamp;
 u32 snd_cwnd_used;
 u32 snd_cwnd_stamp;
 u32 prior_cwnd;
 u32 prr_delivered;

 u32 prr_out;
 u32 delivered;
 u32 delivered_ce;
 u32 lost;
 u32 app_limited;
 u64 first_tx_mstamp;
 u64 delivered_mstamp;
 u32 rate_delivered;
 u32 rate_interval_us;

  u32 rcv_wnd;
 u32 write_seq;
 u32 notsent_lowat;
 u32 pushed_seq;
 u32 lost_out;
 u32 sacked_out;

 struct hrtimer pacing_timer;
 struct hrtimer compressed_ack_timer;


 struct sk_buff* lost_skb_hint;
 struct sk_buff *retransmit_skb_hint;


 struct rb_root out_of_order_queue;
 struct sk_buff *ooo_last_skb;


 struct tcp_sack_block duplicate_sack[1];
 struct tcp_sack_block selective_acks[4];

 struct tcp_sack_block recv_sack_cache[4];

 struct sk_buff *highest_sack;





 int lost_cnt_hint;

 u32 prior_ssthresh;
 u32 high_seq;

 u32 retrans_stamp;


 u32 undo_marker;
 int undo_retrans;
 u64 bytes_retrans;


 u32 total_retrans;

 u32 urg_seq;
 unsigned int keepalive_time;
 unsigned int keepalive_intvl;

 int linger2;




 u8 bpf_sock_ops_cb_flags;







 u16 timeout_rehash;

 u32 rcv_ooopack;


 u32 rcv_rtt_last_tsecr;
 struct {
  u32 rtt_us;
  u32 seq;
  u64 time;
 } rcv_rtt_est;


 struct {
  u32 space;
  u32 seq;
  u64 time;
 } rcvq_space;


 struct {
  u32 probe_seq_start;
  u32 probe_seq_end;
 } mtu_probe;
 u32 mtu_info;
# 427 "/home/nathan/src/linux-next/include/linux/tcp.h"
 struct tcp_fastopen_request *fastopen_req;



 struct request_sock *fastopen_rsk;
 u32 *saved_syn;
};

enum tsq_enum {
 TSQ_THROTTLED,
 TSQ_QUEUED,
 TCP_TSQ_DEFERRED,
 TCP_WRITE_TIMER_DEFERRED,
 TCP_DELACK_TIMER_DEFERRED,
 TCP_MTU_REDUCED_DEFERRED,


};

enum tsq_flags {
 TSQF_THROTTLED = (1UL << TSQ_THROTTLED),
 TSQF_QUEUED = (1UL << TSQ_QUEUED),
 TCPF_TSQ_DEFERRED = (1UL << TCP_TSQ_DEFERRED),
 TCPF_WRITE_TIMER_DEFERRED = (1UL << TCP_WRITE_TIMER_DEFERRED),
 TCPF_DELACK_TIMER_DEFERRED = (1UL << TCP_DELACK_TIMER_DEFERRED),
 TCPF_MTU_REDUCED_DEFERRED = (1UL << TCP_MTU_REDUCED_DEFERRED),
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcp_sock *tcp_sk(const struct sock *sk)
{
 return (struct tcp_sock *)sk;
}

struct tcp_timewait_sock {
 struct inet_timewait_sock tw_sk;


 u32 tw_rcv_wnd;
 u32 tw_ts_offset;
 u32 tw_ts_recent;


 u32 tw_last_oow_ack_time;

 int tw_ts_recent_stamp;
 u32 tw_tx_delay;



};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcp_timewait_sock *tcp_twsk(const struct sock *sk)
{
 return (struct tcp_timewait_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_passive_fastopen(const struct sock *sk)
{
 return sk->__sk_common.skc_state == TCP_SYN_RECV &&
        ({ typeof(*(tcp_sk(sk)->fastopen_rsk)) *_________p1 = (typeof(*(tcp_sk(sk)->fastopen_rsk)) *)({ union { typeof((tcp_sk(sk)->fastopen_rsk)) __val; char __c[1]; } __u; if (1) __read_once_size(&((tcp_sk(sk)->fastopen_rsk)), __u.__c, sizeof((tcp_sk(sk)->fastopen_rsk))); else __read_once_size_nocheck(&((tcp_sk(sk)->fastopen_rsk)), __u.__c, sizeof((tcp_sk(sk)->fastopen_rsk))); do { } while (0); __u.__val; }); ; ((typeof(*(tcp_sk(sk)->fastopen_rsk)) *)(_________p1)); }) != ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fastopen_queue_tune(struct sock *sk, int backlog)
{
 struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;
 int somaxconn = ({ union { typeof(sock_net(sk)->core.sysctl_somaxconn) __val; char __c[1]; } __u; if (1) __read_once_size(&(sock_net(sk)->core.sysctl_somaxconn), __u.__c, sizeof(sock_net(sk)->core.sysctl_somaxconn)); else __read_once_size_nocheck(&(sock_net(sk)->core.sysctl_somaxconn), __u.__c, sizeof(sock_net(sk)->core.sysctl_somaxconn)); do { } while (0); __u.__val; });

 queue->fastopenq.max_qlen = __builtin_choose_expr(((!!(sizeof((typeof((unsigned int)(backlog)) *)1 == (typeof((unsigned int)(somaxconn)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned int)(backlog)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned int)(somaxconn)) * 0l)) : (int *)8))))), (((unsigned int)(backlog)) < ((unsigned int)(somaxconn)) ? ((unsigned int)(backlog)) : ((unsigned int)(somaxconn))), ({ typeof((unsigned int)(backlog)) __UNIQUE_ID___x84 = ((unsigned int)(backlog)); typeof((unsigned int)(somaxconn)) __UNIQUE_ID___y85 = ((unsigned int)(somaxconn)); ((__UNIQUE_ID___x84) < (__UNIQUE_ID___y85) ? (__UNIQUE_ID___x84) : (__UNIQUE_ID___y85)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_move_syn(struct tcp_sock *tp,
    struct request_sock *req)
{
 tp->saved_syn = req->saved_syn;
 req->saved_syn = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_saved_syn_free(struct tcp_sock *tp)
{
 kfree(tp->saved_syn);
 tp->saved_syn = ((void *)0);
}

struct sk_buff *tcp_get_timestamping_opt_stats(const struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 tcp_mss_clamp(const struct tcp_sock *tp, u16 mss)
{



 u16 user_mss = ({ union { typeof(tp->rx_opt.user_mss) __val; char __c[1]; } __u; if (1) __read_once_size(&(tp->rx_opt.user_mss), __u.__c, sizeof(tp->rx_opt.user_mss)); else __read_once_size_nocheck(&(tp->rx_opt.user_mss), __u.__c, sizeof(tp->rx_opt.user_mss)); do { } while (0); __u.__val; });

 return (user_mss && user_mss < mss) ? user_mss : mss;
}

int tcp_skb_shift(struct sk_buff *to, struct sk_buff *from, int pcount,
    int shiftlen);
# 21 "/home/nathan/src/linux-next/include/net/tcp.h" 2
# 32 "/home/nathan/src/linux-next/include/net/tcp.h"
# 1 "/home/nathan/src/linux-next/include/net/inet_hashtables.h" 1
# 15 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
# 1 "/home/nathan/src/linux-next/include/linux/ip.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/ip.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/ip.h" 1
# 86 "/home/nathan/src/linux-next/include/uapi/linux/ip.h"
struct iphdr {




 __u8 version:4,
    ihl:4;



 __u8 tos;
 __be16 tot_len;
 __be16 id;
 __be16 frag_off;
 __u8 ttl;
 __u8 protocol;
 __sum16 check;
 __be32 saddr;
 __be32 daddr;

};


struct ip_auth_hdr {
 __u8 nexthdr;
 __u8 hdrlen;
 __be16 reserved;
 __be32 spi;
 __be32 seq_no;
 __u8 auth_data[0];
};

struct ip_esp_hdr {
 __be32 spi;
 __be32 seq_no;
 __u8 enc_data[0];
};

struct ip_comp_hdr {
 __u8 nexthdr;
 __u8 flags;
 __be16 cpi;
};

struct ip_beet_phdr {
 __u8 nexthdr;
 __u8 hdrlen;
 __u8 padlen;
 __u8 reserved;
};


enum
{
 IPV4_DEVCONF_FORWARDING=1,
 IPV4_DEVCONF_MC_FORWARDING,
 IPV4_DEVCONF_PROXY_ARP,
 IPV4_DEVCONF_ACCEPT_REDIRECTS,
 IPV4_DEVCONF_SECURE_REDIRECTS,
 IPV4_DEVCONF_SEND_REDIRECTS,
 IPV4_DEVCONF_SHARED_MEDIA,
 IPV4_DEVCONF_RP_FILTER,
 IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE,
 IPV4_DEVCONF_BOOTP_RELAY,
 IPV4_DEVCONF_LOG_MARTIANS,
 IPV4_DEVCONF_TAG,
 IPV4_DEVCONF_ARPFILTER,
 IPV4_DEVCONF_MEDIUM_ID,
 IPV4_DEVCONF_NOXFRM,
 IPV4_DEVCONF_NOPOLICY,
 IPV4_DEVCONF_FORCE_IGMP_VERSION,
 IPV4_DEVCONF_ARP_ANNOUNCE,
 IPV4_DEVCONF_ARP_IGNORE,
 IPV4_DEVCONF_PROMOTE_SECONDARIES,
 IPV4_DEVCONF_ARP_ACCEPT,
 IPV4_DEVCONF_ARP_NOTIFY,
 IPV4_DEVCONF_ACCEPT_LOCAL,
 IPV4_DEVCONF_SRC_VMARK,
 IPV4_DEVCONF_PROXY_ARP_PVLAN,
 IPV4_DEVCONF_ROUTE_LOCALNET,
 IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL,
 IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL,
 IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
 IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
 IPV4_DEVCONF_DROP_GRATUITOUS_ARP,
 IPV4_DEVCONF_BC_FORWARDING,
 __IPV4_DEVCONF_MAX
};
# 18 "/home/nathan/src/linux-next/include/linux/ip.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct iphdr *ip_hdr(const struct sk_buff *skb)
{
 return (struct iphdr *)skb_network_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct iphdr *inner_ip_hdr(const struct sk_buff *skb)
{
 return (struct iphdr *)skb_inner_network_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct iphdr *ipip_hdr(const struct sk_buff *skb)
{
 return (struct iphdr *)skb_transport_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ip_transport_len(const struct sk_buff *skb)
{
 return (( __u16)(__be16)(ip_hdr(skb)->tot_len)) - skb_network_header_len(skb);
}
# 16 "/home/nathan/src/linux-next/include/net/inet_hashtables.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/ipv6.h" 1




# 1 "/home/nathan/src/linux-next/include/uapi/linux/ipv6.h" 1
# 21 "/home/nathan/src/linux-next/include/uapi/linux/ipv6.h"
struct in6_pktinfo {
 struct in6_addr ipi6_addr;
 int ipi6_ifindex;
};



struct ip6_mtuinfo {
 struct sockaddr_in6 ip6m_addr;
 __u32 ip6m_mtu;
};


struct in6_ifreq {
 struct in6_addr ifr6_addr;
 __u32 ifr6_prefixlen;
 int ifr6_ifindex;
};
# 48 "/home/nathan/src/linux-next/include/uapi/linux/ipv6.h"
struct ipv6_rt_hdr {
 __u8 nexthdr;
 __u8 hdrlen;
 __u8 type;
 __u8 segments_left;





};


struct ipv6_opt_hdr {
 __u8 nexthdr;
 __u8 hdrlen;



} __attribute__((packed));
# 79 "/home/nathan/src/linux-next/include/uapi/linux/ipv6.h"
struct rt0_hdr {
 struct ipv6_rt_hdr rt_hdr;
 __u32 reserved;
 struct in6_addr addr[0];


};





struct rt2_hdr {
 struct ipv6_rt_hdr rt_hdr;
 __u32 reserved;
 struct in6_addr addr;


};





struct ipv6_destopt_hao {
 __u8 type;
 __u8 length;
 struct in6_addr addr;
} __attribute__((packed));
# 116 "/home/nathan/src/linux-next/include/uapi/linux/ipv6.h"
struct ipv6hdr {




 __u8 version:4,
    priority:4;



 __u8 flow_lbl[3];

 __be16 payload_len;
 __u8 nexthdr;
 __u8 hop_limit;

 struct in6_addr saddr;
 struct in6_addr daddr;
};



enum {
 DEVCONF_FORWARDING = 0,
 DEVCONF_HOPLIMIT,
 DEVCONF_MTU6,
 DEVCONF_ACCEPT_RA,
 DEVCONF_ACCEPT_REDIRECTS,
 DEVCONF_AUTOCONF,
 DEVCONF_DAD_TRANSMITS,
 DEVCONF_RTR_SOLICITS,
 DEVCONF_RTR_SOLICIT_INTERVAL,
 DEVCONF_RTR_SOLICIT_DELAY,
 DEVCONF_USE_TEMPADDR,
 DEVCONF_TEMP_VALID_LFT,
 DEVCONF_TEMP_PREFERED_LFT,
 DEVCONF_REGEN_MAX_RETRY,
 DEVCONF_MAX_DESYNC_FACTOR,
 DEVCONF_MAX_ADDRESSES,
 DEVCONF_FORCE_MLD_VERSION,
 DEVCONF_ACCEPT_RA_DEFRTR,
 DEVCONF_ACCEPT_RA_PINFO,
 DEVCONF_ACCEPT_RA_RTR_PREF,
 DEVCONF_RTR_PROBE_INTERVAL,
 DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN,
 DEVCONF_PROXY_NDP,
 DEVCONF_OPTIMISTIC_DAD,
 DEVCONF_ACCEPT_SOURCE_ROUTE,
 DEVCONF_MC_FORWARDING,
 DEVCONF_DISABLE_IPV6,
 DEVCONF_ACCEPT_DAD,
 DEVCONF_FORCE_TLLAO,
 DEVCONF_NDISC_NOTIFY,
 DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL,
 DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL,
 DEVCONF_SUPPRESS_FRAG_NDISC,
 DEVCONF_ACCEPT_RA_FROM_LOCAL,
 DEVCONF_USE_OPTIMISTIC,
 DEVCONF_ACCEPT_RA_MTU,
 DEVCONF_STABLE_SECRET,
 DEVCONF_USE_OIF_ADDRS_ONLY,
 DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT,
 DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
 DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
 DEVCONF_DROP_UNSOLICITED_NA,
 DEVCONF_KEEP_ADDR_ON_DOWN,
 DEVCONF_RTR_SOLICIT_MAX_INTERVAL,
 DEVCONF_SEG6_ENABLED,
 DEVCONF_SEG6_REQUIRE_HMAC,
 DEVCONF_ENHANCED_DAD,
 DEVCONF_ADDR_GEN_MODE,
 DEVCONF_DISABLE_POLICY,
 DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN,
 DEVCONF_NDISC_TCLASS,
 DEVCONF_MAX
};
# 6 "/home/nathan/src/linux-next/include/linux/ipv6.h" 2






struct ipv6_devconf {
 __s32 forwarding;
 __s32 hop_limit;
 __s32 mtu6;
 __s32 accept_ra;
 __s32 accept_redirects;
 __s32 autoconf;
 __s32 dad_transmits;
 __s32 rtr_solicits;
 __s32 rtr_solicit_interval;
 __s32 rtr_solicit_max_interval;
 __s32 rtr_solicit_delay;
 __s32 force_mld_version;
 __s32 mldv1_unsolicited_report_interval;
 __s32 mldv2_unsolicited_report_interval;
 __s32 use_tempaddr;
 __s32 temp_valid_lft;
 __s32 temp_prefered_lft;
 __s32 regen_max_retry;
 __s32 max_desync_factor;
 __s32 max_addresses;
 __s32 accept_ra_defrtr;
 __s32 accept_ra_min_hop_limit;
 __s32 accept_ra_pinfo;
 __s32 ignore_routes_with_linkdown;
# 45 "/home/nathan/src/linux-next/include/linux/ipv6.h"
 __s32 proxy_ndp;
 __s32 accept_source_route;
 __s32 accept_ra_from_local;







 __s32 disable_ipv6;
 __s32 drop_unicast_in_l2_multicast;
 __s32 accept_dad;
 __s32 force_tllao;
 __s32 ndisc_notify;
 __s32 suppress_frag_ndisc;
 __s32 accept_ra_mtu;
 __s32 drop_unsolicited_na;
 struct ipv6_stable_secret {
  bool initialized;
  struct in6_addr secret;
 } stable_secret;
 __s32 use_oif_addrs_only;
 __s32 keep_addr_on_down;
 __s32 seg6_enabled;



 __u32 enhanced_dad;
 __u32 addr_gen_mode;
 __s32 disable_policy;
 __s32 ndisc_tclass;

 struct ctl_table_header *sysctl_header;
};

struct ipv6_params {
 __s32 disable_ipv6;
 __s32 autoconf;
};
extern struct ipv6_params ipv6_defaults;

# 1 "/home/nathan/src/linux-next/include/linux/icmpv6.h" 1







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct icmp6hdr *icmp6_hdr(const struct sk_buff *skb)
{
 return (struct icmp6hdr *)skb_transport_header(skb);
}




extern void icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info);

typedef void ip6_icmp_send_t(struct sk_buff *skb, u8 type, u8 code, __u32 info,
        const struct in6_addr *force_saddr);
extern int inet6_register_icmp_sender(ip6_icmp_send_t *fn);
extern int inet6_unregister_icmp_sender(ip6_icmp_send_t *fn);
int ip6_err_gen_icmpv6_unreach(struct sk_buff *skb, int nhs, int type,
          unsigned int data_len);
# 34 "/home/nathan/src/linux-next/include/linux/icmpv6.h"
extern int icmpv6_init(void);
extern int icmpv6_err_convert(u8 type, u8 code,
          int *err);
extern void icmpv6_cleanup(void);
extern void icmpv6_param_prob(struct sk_buff *skb,
         u8 code, int pos);

struct flowi6;
struct in6_addr;
extern void icmpv6_flow_init(struct sock *sk,
        struct flowi6 *fl6,
        u8 type,
        const struct in6_addr *saddr,
        const struct in6_addr *daddr,
        int oif);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool icmpv6_is_err(int type)
{
 switch (type) {
 case 1:
 case 2:
 case 3:
 case 4:
  return true;
 }

 return false;
}
# 87 "/home/nathan/src/linux-next/include/linux/ipv6.h" 2

# 1 "/home/nathan/src/linux-next/include/linux/udp.h" 1
# 19 "/home/nathan/src/linux-next/include/linux/udp.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/udp.h" 1
# 23 "/home/nathan/src/linux-next/include/uapi/linux/udp.h"
struct udphdr {
 __be16 source;
 __be16 dest;
 __be16 len;
 __sum16 check;
};
# 20 "/home/nathan/src/linux-next/include/linux/udp.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct udphdr *udp_hdr(const struct sk_buff *skb)
{
 return (struct udphdr *)skb_transport_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct udphdr *inner_udp_hdr(const struct sk_buff *skb)
{
 return (struct udphdr *)skb_inner_transport_header(skb);
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 udp_hashfn(const struct net *net, u32 num, u32 mask)
{
 return (num + net_hash_mix(net)) & mask;
}

struct udp_sock {

 struct inet_sock inet;



 int pending;
 unsigned int corkflag;
 __u8 encap_type;
 unsigned char no_check6_tx:1,
    no_check6_rx:1,
    encap_enabled:1,




    gro_enabled:1;




 __u16 len;
 __u16 gso_size;



 __u16 pcslen;
 __u16 pcrlen;




 __u8 pcflag;
 __u8 unused[3];



 int (*encap_rcv)(struct sock *sk, struct sk_buff *skb);
 int (*encap_err_lookup)(struct sock *sk, struct sk_buff *skb);
 void (*encap_destroy)(struct sock *sk);


 struct sk_buff * (*gro_receive)(struct sock *sk,
            struct list_head *head,
            struct sk_buff *skb);
 int (*gro_complete)(struct sock *sk,
      struct sk_buff *skb,
      int nhoff);


 struct sk_buff_head reader_queue __attribute__((__aligned__((1 << 7))));


 int forward_deficit;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct udp_sock *udp_sk(const struct sock *sk)
{
 return (struct udp_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void udp_set_no_check6_tx(struct sock *sk, bool val)
{
 udp_sk(sk)->no_check6_tx = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void udp_set_no_check6_rx(struct sock *sk, bool val)
{
 udp_sk(sk)->no_check6_rx = val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool udp_get_no_check6_tx(struct sock *sk)
{
 return udp_sk(sk)->no_check6_tx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool udp_get_no_check6_rx(struct sock *sk)
{
 return udp_sk(sk)->no_check6_rx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void udp_cmsg_recv(struct msghdr *msg, struct sock *sk,
     struct sk_buff *skb)
{
 int gso_size;

 if (((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & SKB_GSO_UDP_L4) {
  gso_size = ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_size;
  put_cmsg(msg, 17, 104, sizeof(gso_size), &gso_size);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool udp_unexpected_gso(struct sock *sk, struct sk_buff *skb)
{
 return !udp_sk(sk)->gro_enabled && skb_is_gso(skb) &&
        ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & SKB_GSO_UDP_L4;
}
# 89 "/home/nathan/src/linux-next/include/linux/ipv6.h" 2



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ipv6hdr *ipv6_hdr(const struct sk_buff *skb)
{
 return (struct ipv6hdr *)skb_network_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ipv6hdr *inner_ipv6_hdr(const struct sk_buff *skb)
{
 return (struct ipv6hdr *)skb_inner_network_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ipv6hdr *ipipv6_hdr(const struct sk_buff *skb)
{
 return (struct ipv6hdr *)skb_transport_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ipv6_transport_len(const struct sk_buff *skb)
{
 return (( __u16)(__be16)(ipv6_hdr(skb)->payload_len)) + sizeof(struct ipv6hdr) -
        skb_network_header_len(skb);
}






struct inet6_skb_parm {
 int iif;
 __be16 ra;
 __u16 dst0;
 __u16 srcrt;
 __u16 dst1;
 __u16 lastopt;
 __u16 nhoff;
 __u16 flags;



 __u16 frag_max_size;
# 140 "/home/nathan/src/linux-next/include/linux/ipv6.h"
};







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_l3mdev_skb(__u16 flags)
{
 return false;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet6_iif(const struct sk_buff *skb)
{
 bool l3_slave = ipv6_l3mdev_skb(((struct inet6_skb_parm*)((skb)->cb))->flags);

 return l3_slave ? skb->skb_iif : ((struct inet6_skb_parm*)((skb)->cb))->iif;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet6_is_jumbogram(const struct sk_buff *skb)
{
 return !!(((struct inet6_skb_parm*)((skb)->cb))->flags & 128);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet6_sdif(const struct sk_buff *skb)
{




 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet6_exact_dif_match(struct net *net, struct sk_buff *skb)
{





 return false;
}

struct tcp6_request_sock {
 struct tcp_request_sock tcp6rsk_tcp;
};

struct ipv6_mc_socklist;
struct ipv6_ac_socklist;
struct ipv6_fl_socklist;

struct inet6_cork {
 struct ipv6_txoptions *opt;
 u8 hop_limit;
 u8 tclass;
};
# 212 "/home/nathan/src/linux-next/include/linux/ipv6.h"
struct ipv6_pinfo {
 struct in6_addr saddr;
 struct in6_pktinfo sticky_pktinfo;
 const struct in6_addr *daddr_cache;




 __be32 flow_label;
 __u32 frag_size;






 __s16 hop_limit:9;
 __u16 __unused_1:7;







 __s16 mcast_hops:9;
 __u16 __unused_2:6,
    mc_loop:1;





 int ucast_oif;
 int mcast_oif;


 union {
  struct {
   __u16 srcrt:1,
    osrcrt:1,
           rxinfo:1,
           rxoinfo:1,
    rxhlim:1,
    rxohlim:1,
    hopopts:1,
    ohopopts:1,
    dstopts:1,
    odstopts:1,
                                rxflow:1,
    rxtclass:1,
    rxpmtu:1,
    rxorigdstaddr:1,
    recvfragsize:1;

  } bits;
  __u16 all;
 } rxopt;


 __u16 recverr:1,
                         sndflow:1,
    repflow:1,
    pmtudisc:3,
    padding:1,
    srcprefs:3,



    dontfrag:1,
    autoflowlabel:1,
    autoflowlabel_set:1,
    mc_all:1,
    rtalert_isolate:1;
 __u8 min_hopcount;
 __u8 tclass;
 __be32 rcv_flowinfo;

 __u32 dst_cookie;
 __u32 rx_dst_cookie;

 struct ipv6_mc_socklist *ipv6_mc_list;
 struct ipv6_ac_socklist *ipv6_ac_list;
 struct ipv6_fl_socklist *ipv6_fl_list;

 struct ipv6_txoptions *opt;
 struct sk_buff *pktoptions;
 struct sk_buff *rxpmtu;
 struct inet6_cork cork;
};


struct raw6_sock {

 struct inet_sock inet;
 __u32 checksum;
 __u32 offset;
 struct icmp6_filter filter;
 __u32 ip6mr_table;

 struct ipv6_pinfo inet6;
};

struct udp6_sock {
 struct udp_sock udp;

 struct ipv6_pinfo inet6;
};

struct tcp6_sock {
 struct tcp_sock tcp;

 struct ipv6_pinfo inet6;
};

extern int inet6_sk_rebuild_header(struct sock *sk);

struct tcp6_timewait_sock {
 struct tcp_timewait_sock tcp6tw_tcp;
};


bool ipv6_mod_enabled(void);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ipv6_pinfo *inet6_sk(const struct sock *__sk)
{
 return sk_fullsock(__sk) ? inet_sk(__sk)->pinet6 : ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct raw6_sock *raw6_sk(const struct sock *sk)
{
 return (struct raw6_sock *)sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_sk_copy_descendant(struct sock *sk_to,
        const struct sock *sk_from)
{
 int ancestor_size = sizeof(struct inet_sock);

 if (sk_from->__sk_common.skc_family == 10)
  ancestor_size += sizeof(struct ipv6_pinfo);

 __inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)
{
 if (sk->__sk_common.skc_family == 10)
  return &sk->__sk_common.skc_v6_rcv_saddr;
 return ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_v6_ipv6only(const struct sock *sk)
{

 return ((sk->__sk_common.skc_ipv6only));
}
# 17 "/home/nathan/src/linux-next/include/net/inet_hashtables.h" 2
# 27 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
# 1 "/home/nathan/src/linux-next/include/net/route.h" 1
# 24 "/home/nathan/src/linux-next/include/net/route.h"
# 1 "/home/nathan/src/linux-next/include/net/inetpeer.h" 1
# 16 "/home/nathan/src/linux-next/include/net/inetpeer.h"
# 1 "/home/nathan/src/linux-next/include/net/ipv6.h" 1
# 16 "/home/nathan/src/linux-next/include/net/ipv6.h"
# 1 "/home/nathan/src/linux-next/include/linux/jump_label_ratelimit.h" 1








struct static_key_deferred {
 struct static_key key;
 unsigned long timeout;
 struct delayed_work work;
};

struct static_key_true_deferred {
 struct static_key_true key;
 unsigned long timeout;
 struct delayed_work work;
};

struct static_key_false_deferred {
 struct static_key_false key;
 unsigned long timeout;
 struct delayed_work work;
};
# 35 "/home/nathan/src/linux-next/include/linux/jump_label_ratelimit.h"
extern void
__static_key_slow_dec_deferred(struct static_key *key,
          struct delayed_work *work,
          unsigned long timeout);
extern void __static_key_deferred_flush(void *key, struct delayed_work *work);
extern void
jump_label_rate_limit(struct static_key_deferred *key, unsigned long rl);

extern void jump_label_update_timeout(struct work_struct *work);
# 17 "/home/nathan/src/linux-next/include/net/ipv6.h" 2
# 1 "/home/nathan/src/linux-next/include/net/if_inet6.h" 1
# 29 "/home/nathan/src/linux-next/include/net/if_inet6.h"
enum {
 INET6_IFADDR_STATE_PREDAD,
 INET6_IFADDR_STATE_DAD,
 INET6_IFADDR_STATE_POSTDAD,
 INET6_IFADDR_STATE_ERRDAD,
 INET6_IFADDR_STATE_DEAD,
};

struct inet6_ifaddr {
 struct in6_addr addr;
 __u32 prefix_len;
 __u32 rt_priority;


 __u32 valid_lft;
 __u32 prefered_lft;
 refcount_t refcnt;
 spinlock_t lock;

 int state;

 __u32 flags;
 __u8 dad_probes;
 __u8 stable_privacy_retry;

 __u16 scope;
 __u64 dad_nonce;

 unsigned long cstamp;
 unsigned long tstamp;

 struct delayed_work dad_work;

 struct inet6_dev *idev;
 struct fib6_info *rt;

 struct hlist_node addr_lst;
 struct list_head if_list;

 struct list_head tmp_list;
 struct inet6_ifaddr *ifpub;
 int regen_count;

 bool tokenized;

 struct callback_head rcu;
 struct in6_addr peer_addr;
};

struct ip6_sf_socklist {
 unsigned int sl_max;
 unsigned int sl_count;
 struct in6_addr sl_addr[0];
};






struct ipv6_mc_socklist {
 struct in6_addr addr;
 int ifindex;
 unsigned int sfmode;
 struct ipv6_mc_socklist *next;
 rwlock_t sflock;
 struct ip6_sf_socklist *sflist;
 struct callback_head rcu;
};

struct ip6_sf_list {
 struct ip6_sf_list *sf_next;
 struct in6_addr sf_addr;
 unsigned long sf_count[2];
 unsigned char sf_gsresp;
 unsigned char sf_oldin;
 unsigned char sf_crcount;
};







struct ifmcaddr6 {
 struct in6_addr mca_addr;
 struct inet6_dev *idev;
 struct ifmcaddr6 *next;
 struct ip6_sf_list *mca_sources;
 struct ip6_sf_list *mca_tomb;
 unsigned int mca_sfmode;
 unsigned char mca_crcount;
 unsigned long mca_sfcount[2];
 struct timer_list mca_timer;
 unsigned int mca_flags;
 int mca_users;
 refcount_t mca_refcnt;
 spinlock_t mca_lock;
 unsigned long mca_cstamp;
 unsigned long mca_tstamp;
};



struct ipv6_ac_socklist {
 struct in6_addr acl_addr;
 int acl_ifindex;
 struct ipv6_ac_socklist *acl_next;
};

struct ifacaddr6 {
 struct in6_addr aca_addr;
 struct fib6_info *aca_rt;
 struct ifacaddr6 *aca_next;
 struct hlist_node aca_addr_lst;
 int aca_users;
 refcount_t aca_refcnt;
 unsigned long aca_cstamp;
 unsigned long aca_tstamp;
 struct callback_head rcu;
};





struct ipv6_devstat {
 struct proc_dir_entry *proc_dir_entry;
 __typeof__(struct ipstats_mib) *ipv6;
 __typeof__(struct icmpv6_mib_device) *icmpv6dev;
 __typeof__(struct icmpv6msg_mib_device) *icmpv6msgdev;
};

struct inet6_dev {
 struct net_device *dev;

 struct list_head addr_list;

 struct ifmcaddr6 *mc_list;
 struct ifmcaddr6 *mc_tomb;
 spinlock_t mc_lock;

 unsigned char mc_qrv;
 unsigned char mc_gq_running;
 unsigned char mc_ifc_count;
 unsigned char mc_dad_count;

 unsigned long mc_v1_seen;
 unsigned long mc_qi;
 unsigned long mc_qri;
 unsigned long mc_maxdelay;

 struct timer_list mc_gq_timer;
 struct timer_list mc_ifc_timer;
 struct timer_list mc_dad_timer;

 struct ifacaddr6 *ac_list;
 rwlock_t lock;
 refcount_t refcnt;
 __u32 if_flags;
 int dead;

 u32 desync_factor;
 u8 rndid[8];
 struct list_head tempaddr_list;

 struct in6_addr token;

 struct neigh_parms *nd_parms;
 struct ipv6_devconf cnf;
 struct ipv6_devstat stats;

 struct timer_list rs_timer;
 __s32 rs_interval;
 __u8 rs_probes;

 unsigned long tstamp;
 struct callback_head rcu;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_eth_mc_map(const struct in6_addr *addr, char *buf)
{






 buf[0]= 0x33;
 buf[1]= 0x33;

 memcpy(buf + 2, &addr->in6_u.u6_addr32[3], sizeof(__u32));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_arcnet_mc_map(const struct in6_addr *addr, char *buf)
{
 buf[0] = 0x00;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_ib_mc_map(const struct in6_addr *addr,
      const unsigned char *broadcast, char *buf)
{
 unsigned char scope = broadcast[5] & 0xF;

 buf[0] = 0;
 buf[1] = 0xff;
 buf[2] = 0xff;
 buf[3] = 0xff;
 buf[4] = 0xff;
 buf[5] = 0x10 | scope;
 buf[6] = 0x60;
 buf[7] = 0x1b;
 buf[8] = broadcast[8];
 buf[9] = broadcast[9];
 memcpy(buf + 10, addr->in6_u.u6_addr8 + 6, 10);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_ipgre_mc_map(const struct in6_addr *addr,
        const unsigned char *broadcast, char *buf)
{
 if ((broadcast[0] | broadcast[1] | broadcast[2] | broadcast[3]) != 0) {
  memcpy(buf, broadcast, 4);
 } else {

  if ((addr->in6_u.u6_addr32[0] | addr->in6_u.u6_addr32[1] |
       (addr->in6_u.u6_addr32[2] ^ (( __be32)(__u32)(0x0000ffff)))) != 0)
   return -22;
  memcpy(buf, &addr->in6_u.u6_addr32[3], 4);
 }
 return 0;
}
# 18 "/home/nathan/src/linux-next/include/net/ipv6.h" 2
# 1 "/home/nathan/src/linux-next/include/net/ndisc.h" 1




# 1 "/home/nathan/src/linux-next/include/net/ipv6_stubs.h" 1
# 14 "/home/nathan/src/linux-next/include/net/ipv6_stubs.h"
struct fib6_info;
struct fib6_nh;
struct fib6_config;
struct fib6_result;




struct ipv6_stub {
 int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
     const struct in6_addr *addr);
 int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
     const struct in6_addr *addr);
 struct dst_entry *(*ipv6_dst_lookup_flow)(struct net *net,
        const struct sock *sk,
        struct flowi6 *fl6,
        const struct in6_addr *final_dst);
 int (*ipv6_route_input)(struct sk_buff *skb);

 struct fib6_table *(*fib6_get_table)(struct net *net, u32 id);
 int (*fib6_lookup)(struct net *net, int oif, struct flowi6 *fl6,
      struct fib6_result *res, int flags);
 int (*fib6_table_lookup)(struct net *net, struct fib6_table *table,
     int oif, struct flowi6 *fl6,
     struct fib6_result *res, int flags);
 void (*fib6_select_path)(const struct net *net, struct fib6_result *res,
     struct flowi6 *fl6, int oif, bool oif_match,
     const struct sk_buff *skb, int strict);
 u32 (*ip6_mtu_from_fib6)(const struct fib6_result *res,
     const struct in6_addr *daddr,
     const struct in6_addr *saddr);

 int (*fib6_nh_init)(struct net *net, struct fib6_nh *fib6_nh,
       struct fib6_config *cfg, gfp_t gfp_flags,
       struct netlink_ext_ack *extack);
 void (*fib6_nh_release)(struct fib6_nh *fib6_nh);
 void (*fib6_update_sernum)(struct net *net, struct fib6_info *rt);
 int (*ip6_del_rt)(struct net *net, struct fib6_info *rt);
 void (*fib6_rt_update)(struct net *net, struct fib6_info *rt,
          struct nl_info *info);

 void (*udpv6_encap_enable)(void);
 void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,
         const struct in6_addr *solicited_addr,
         bool router, bool solicited, bool override, bool inc_opt);
 struct neigh_table *nd_tbl;
};
extern const struct ipv6_stub *ipv6_stub __attribute__((__section__(".data..read_mostly")));


struct ipv6_bpf_stub {
 int (*inet6_bind)(struct sock *sk, struct sockaddr *uaddr, int addr_len,
     bool force_bind_address_no_port, bool with_lock);
 struct sock *(*udp6_lib_lookup)(struct net *net,
         const struct in6_addr *saddr, __be16 sport,
         const struct in6_addr *daddr, __be16 dport,
         int dif, int sdif, struct udp_table *tbl,
         struct sk_buff *skb);
};
extern const struct ipv6_bpf_stub *ipv6_bpf_stub __attribute__((__section__(".data..read_mostly")));
# 6 "/home/nathan/src/linux-next/include/net/ndisc.h" 2
# 30 "/home/nathan/src/linux-next/include/net/ndisc.h"
enum {
 __ND_OPT_PREFIX_INFO_END = 0,
 ND_OPT_SOURCE_LL_ADDR = 1,
 ND_OPT_TARGET_LL_ADDR = 2,
 ND_OPT_PREFIX_INFO = 3,
 ND_OPT_REDIRECT_HDR = 4,
 ND_OPT_MTU = 5,
 ND_OPT_NONCE = 14,
 __ND_OPT_ARRAY_MAX,
 ND_OPT_ROUTE_INFO = 24,
 ND_OPT_RDNSS = 25,
 ND_OPT_DNSSL = 31,
 ND_OPT_6CO = 34,
 ND_OPT_CAPTIVE_PORTAL = 37,
 __ND_OPT_MAX
};
# 56 "/home/nathan/src/linux-next/include/net/ndisc.h"
# 1 "/home/nathan/src/linux-next/include/linux/if_arp.h" 1
# 23 "/home/nathan/src/linux-next/include/linux/if_arp.h"
# 1 "/home/nathan/src/linux-next/include/uapi/linux/if_arp.h" 1
# 116 "/home/nathan/src/linux-next/include/uapi/linux/if_arp.h"
struct arpreq {
 struct sockaddr arp_pa;
 struct sockaddr arp_ha;
 int arp_flags;
 struct sockaddr arp_netmask;
 char arp_dev[16];
};

struct arpreq_old {
 struct sockaddr arp_pa;
 struct sockaddr arp_ha;
 int arp_flags;
 struct sockaddr arp_netmask;
};
# 144 "/home/nathan/src/linux-next/include/uapi/linux/if_arp.h"
struct arphdr {
 __be16 ar_hrd;
 __be16 ar_pro;
 unsigned char ar_hln;
 unsigned char ar_pln;
 __be16 ar_op;
# 161 "/home/nathan/src/linux-next/include/uapi/linux/if_arp.h"
};
# 24 "/home/nathan/src/linux-next/include/linux/if_arp.h" 2

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct arphdr *arp_hdr(const struct sk_buff *skb)
{
 return (struct arphdr *)skb_network_header(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int arp_hdr_len(const struct net_device *dev)
{
 switch (dev->type) {





 default:

  return sizeof(struct arphdr) + (dev->addr_len + sizeof(u32)) * 2;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool dev_is_mac_header_xmit(const struct net_device *dev)
{
 switch (dev->type) {
 case 768:
 case 769:
 case 776:
 case 778:
 case 0xFFFF:
 case 0xFFFE:
 case 519:
  return false;
 default:
  return true;
 }
}
# 57 "/home/nathan/src/linux-next/include/net/ndisc.h" 2
# 71 "/home/nathan/src/linux-next/include/net/ndisc.h"
struct ctl_table;
struct inet6_dev;
struct net_device;
struct net_proto_family;
struct sk_buff;
struct prefix_info;

extern struct neigh_table nd_tbl;

struct nd_msg {
        struct icmp6hdr icmph;
        struct in6_addr target;
 __u8 opt[0];
};

struct rs_msg {
 struct icmp6hdr icmph;
 __u8 opt[0];
};

struct ra_msg {
        struct icmp6hdr icmph;
 __be32 reachable_time;
 __be32 retrans_timer;
};

struct rd_msg {
 struct icmp6hdr icmph;
 struct in6_addr target;
 struct in6_addr dest;
 __u8 opt[0];
};

struct nd_opt_hdr {
 __u8 nd_opt_type;
 __u8 nd_opt_len;
} __attribute__((__packed__));


struct ndisc_options {
 struct nd_opt_hdr *nd_opt_array[__ND_OPT_ARRAY_MAX];




 struct nd_opt_hdr *nd_useropts;
 struct nd_opt_hdr *nd_useropts_end;



};
# 135 "/home/nathan/src/linux-next/include/net/ndisc.h"
struct ndisc_options *ndisc_parse_options(const struct net_device *dev,
       u8 *opt, int opt_len,
       struct ndisc_options *ndopts);

void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
         int data_len, int pad);
# 201 "/home/nathan/src/linux-next/include/net/ndisc.h"
struct ndisc_ops {
 int (*is_useropt)(u8 nd_opt_type);
 int (*parse_options)(const struct net_device *dev,
     struct nd_opt_hdr *nd_opt,
     struct ndisc_options *ndopts);
 void (*update)(const struct net_device *dev, struct neighbour *n,
     u32 flags, u8 icmp6_type,
     const struct ndisc_options *ndopts);
 int (*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
      struct neighbour *neigh, u8 *ha_buf,
      u8 **ha);
 void (*fill_addr_option)(const struct net_device *dev,
        struct sk_buff *skb, u8 icmp6_type,
        const u8 *ha);
 void (*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
           const struct prefix_info *pinfo,
           struct inet6_dev *in6_dev,
           struct in6_addr *addr,
           int addr_type, u32 addr_flags,
           bool sllao, bool tokenized,
           __u32 valid_lft, u32 prefered_lft,
           bool dev_addr_generated);
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_ops_is_useropt(const struct net_device *dev,
           u8 nd_opt_type)
{
 if (dev->ndisc_ops && dev->ndisc_ops->is_useropt)
  return dev->ndisc_ops->is_useropt(nd_opt_type);
 else
  return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_ops_parse_options(const struct net_device *dev,
       struct nd_opt_hdr *nd_opt,
       struct ndisc_options *ndopts)
{
 if (dev->ndisc_ops && dev->ndisc_ops->parse_options)
  return dev->ndisc_ops->parse_options(dev, nd_opt, ndopts);
 else
  return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ndisc_ops_update(const struct net_device *dev,
       struct neighbour *n, u32 flags,
       u8 icmp6_type,
       const struct ndisc_options *ndopts)
{
 if (dev->ndisc_ops && dev->ndisc_ops->update)
  dev->ndisc_ops->update(dev, n, flags, icmp6_type, ndopts);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_ops_opt_addr_space(const struct net_device *dev,
        u8 icmp6_type)
{
 if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space &&
     icmp6_type != 137)
  return dev->ndisc_ops->opt_addr_space(dev, icmp6_type, ((void *)0),
            ((void *)0), ((void *)0));
 else
  return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_ops_redirect_opt_addr_space(const struct net_device *dev,
          struct neighbour *neigh,
          u8 *ha_buf, u8 **ha)
{
 if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space)
  return dev->ndisc_ops->opt_addr_space(dev, 137,
            neigh, ha_buf, ha);
 else
  return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ndisc_ops_fill_addr_option(const struct net_device *dev,
           struct sk_buff *skb,
           u8 icmp6_type)
{
 if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option &&
     icmp6_type != 137)
  dev->ndisc_ops->fill_addr_option(dev, skb, icmp6_type, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ndisc_ops_fill_redirect_addr_option(const struct net_device *dev,
             struct sk_buff *skb,
             const u8 *ha)
{
 if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option)
  dev->ndisc_ops->fill_addr_option(dev, skb, 137, ha);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ndisc_ops_prefix_rcv_add_addr(struct net *net,
       struct net_device *dev,
       const struct prefix_info *pinfo,
       struct inet6_dev *in6_dev,
       struct in6_addr *addr,
       int addr_type, u32 addr_flags,
       bool sllao, bool tokenized,
       __u32 valid_lft,
       u32 prefered_lft,
       bool dev_addr_generated)
{
 if (dev->ndisc_ops && dev->ndisc_ops->prefix_rcv_add_addr)
  dev->ndisc_ops->prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
          addr, addr_type,
          addr_flags, sllao,
          tokenized, valid_lft,
          prefered_lft,
          dev_addr_generated);
}
# 320 "/home/nathan/src/linux-next/include/net/ndisc.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_addr_option_pad(unsigned short type)
{
 switch (type) {
 case 32: return 2;
 default: return 0;
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ndisc_opt_addr_space(unsigned char addr_len, int pad)
{
 return (((addr_len + pad)+2+7)&~7);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_opt_addr_space(struct net_device *dev, u8 icmp6_type)
{
 return __ndisc_opt_addr_space(dev->addr_len,
          ndisc_addr_option_pad(dev->type)) +
  ndisc_ops_opt_addr_space(dev, icmp6_type);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ndisc_redirect_opt_addr_space(struct net_device *dev,
      struct neighbour *neigh,
      u8 *ops_data_buf,
      u8 **ops_data)
{
 return __ndisc_opt_addr_space(dev->addr_len,
          ndisc_addr_option_pad(dev->type)) +
  ndisc_ops_redirect_opt_addr_space(dev, neigh, ops_data_buf,
        ops_data);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 *__ndisc_opt_addr_data(struct nd_opt_hdr *p,
     unsigned char addr_len, int prepad)
{
 u8 *lladdr = (u8 *)(p + 1);
 int lladdrlen = p->nd_opt_len << 3;
 if (lladdrlen != __ndisc_opt_addr_space(addr_len, prepad))
  return ((void *)0);
 return lladdr + prepad;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 *ndisc_opt_addr_data(struct nd_opt_hdr *p,
          struct net_device *dev)
{
 return __ndisc_opt_addr_data(p, dev->addr_len,
         ndisc_addr_option_pad(dev->type));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ndisc_hashfn(const void *pkey, const struct net_device *dev, __u32 *hash_rnd)
{
 const u32 *p32 = pkey;

 return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
  (p32[1] * hash_rnd[1]) +
  (p32[2] * hash_rnd[2]) +
  (p32[3] * hash_rnd[3]));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *__ipv6_neigh_lookup_noref(struct net_device *dev, const void *pkey)
{
 return ___neigh_lookup_noref(&nd_tbl, neigh_key_eq128, ndisc_hashfn, pkey, dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct neighbour *__ipv6_neigh_lookup_noref_stub(struct net_device *dev,
       const void *pkey)
{
 return ___neigh_lookup_noref(ipv6_stub->nd_tbl, neigh_key_eq128,
         ndisc_hashfn, pkey, dev);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *__ipv6_neigh_lookup(struct net_device *dev, const void *pkey)
{
 struct neighbour *n;

 rcu_read_lock_bh();
 n = __ipv6_neigh_lookup_noref(dev, pkey);
 if (n && !refcount_inc_not_zero(&n->refcnt))
  n = ((void *)0);
 rcu_read_unlock_bh();

 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ipv6_confirm_neigh(struct net_device *dev,
     const void *pkey)
{
 struct neighbour *n;

 rcu_read_lock_bh();
 n = __ipv6_neigh_lookup_noref(dev, pkey);
 if (n) {
  unsigned long now = jiffies;


  if (({ union { typeof(n->confirmed) __val; char __c[1]; } __u; if (1) __read_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); else __read_once_size_nocheck(&(n->confirmed), __u.__c, sizeof(n->confirmed)); do { } while (0); __u.__val; }) != now)
   ({ union { typeof(n->confirmed) __val; char __c[1]; } __u = { .__val = ( typeof(n->confirmed)) (now) }; __write_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); __u.__val; });
 }
 rcu_read_unlock_bh();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ipv6_confirm_neigh_stub(struct net_device *dev,
          const void *pkey)
{
 struct neighbour *n;

 rcu_read_lock_bh();
 n = __ipv6_neigh_lookup_noref_stub(dev, pkey);
 if (n) {
  unsigned long now = jiffies;


  if (({ union { typeof(n->confirmed) __val; char __c[1]; } __u; if (1) __read_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); else __read_once_size_nocheck(&(n->confirmed), __u.__c, sizeof(n->confirmed)); do { } while (0); __u.__val; }) != now)
   ({ union { typeof(n->confirmed) __val; char __c[1]; } __u = { .__val = ( typeof(n->confirmed)) (now) }; __write_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); __u.__val; });
 }
 rcu_read_unlock_bh();
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *ip_neigh_gw6(struct net_device *dev,
          const void *addr)
{
 struct neighbour *neigh;

 neigh = __ipv6_neigh_lookup_noref_stub(dev, addr);
 if (__builtin_expect(!!(!neigh), 0))
  neigh = __neigh_create(ipv6_stub->nd_tbl, addr, dev, false);

 return neigh;
}

int ndisc_init(void);
int ndisc_late_init(void);

void ndisc_late_cleanup(void);
void ndisc_cleanup(void);

int ndisc_rcv(struct sk_buff *skb);

void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
     const struct in6_addr *daddr, const struct in6_addr *saddr,
     u64 nonce);

void ndisc_send_rs(struct net_device *dev,
     const struct in6_addr *saddr, const struct in6_addr *daddr);
void ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,
     const struct in6_addr *solicited_addr,
     bool router, bool solicited, bool override, bool inc_opt);

void ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target);

int ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev,
   int dir);

void ndisc_update(const struct net_device *dev, struct neighbour *neigh,
    const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,
    struct ndisc_options *ndopts);




int igmp6_init(void);
int igmp6_late_init(void);

void igmp6_cleanup(void);
void igmp6_late_cleanup(void);

int igmp6_event_query(struct sk_buff *skb);

int igmp6_event_report(struct sk_buff *skb);



int ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write,
          void *buffer, size_t *lenp, loff_t *ppos);
int ndisc_ifinfo_sysctl_strategy(struct ctl_table *ctl,
     void *oldval, size_t *oldlenp,
     void *newval, size_t newlen);


void inet6_ifinfo_notify(int event, struct inet6_dev *idev);
# 19 "/home/nathan/src/linux-next/include/net/ipv6.h" 2
# 144 "/home/nathan/src/linux-next/include/net/ipv6.h"
struct frag_hdr {
 __u8 nexthdr;
 __u8 reserved;
 __be16 frag_off;
 __be32 identification;
};




struct ip6_fraglist_iter {
 struct ipv6hdr *tmp_hdr;
 struct sk_buff *frag;
 int offset;
 unsigned int hlen;
 __be32 frag_id;
 u8 nexthdr;
};

int ip6_fraglist_init(struct sk_buff *skb, unsigned int hlen, u8 *prevhdr,
        u8 nexthdr, __be32 frag_id,
        struct ip6_fraglist_iter *iter);
void ip6_fraglist_prepare(struct sk_buff *skb, struct ip6_fraglist_iter *iter);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *ip6_fraglist_next(struct ip6_fraglist_iter *iter)
{
 struct sk_buff *skb = iter->frag;

 iter->frag = skb->next;
 skb_mark_not_on_list(skb);

 return skb;
}

struct ip6_frag_state {
 u8 *prevhdr;
 unsigned int hlen;
 unsigned int mtu;
 unsigned int left;
 int offset;
 int ptr;
 int hroom;
 int troom;
 __be32 frag_id;
 u8 nexthdr;
};

void ip6_frag_init(struct sk_buff *skb, unsigned int hlen, unsigned int mtu,
     unsigned short needed_tailroom, int hdr_room, u8 *prevhdr,
     u8 nexthdr, __be32 frag_id, struct ip6_frag_state *state);
struct sk_buff *ip6_frag_next(struct sk_buff *skb,
         struct ip6_frag_state *state);







extern int sysctl_mld_max_msf;
extern int sysctl_mld_qrv;
# 272 "/home/nathan/src/linux-next/include/net/ipv6.h"
struct ip6_ra_chain {
 struct ip6_ra_chain *next;
 struct sock *sk;
 int sel;
 void (*destructor)(struct sock *);
};

extern struct ip6_ra_chain *ip6_ra_chain;
extern rwlock_t ip6_ra_lock;






struct ipv6_txoptions {
 refcount_t refcnt;

 int tot_len;



 __u16 opt_flen;
 __u16 opt_nflen;

 struct ipv6_opt_hdr *hopopt;
 struct ipv6_opt_hdr *dst0opt;
 struct ipv6_rt_hdr *srcrt;
 struct ipv6_opt_hdr *dst1opt;
 struct callback_head rcu;

};


enum flowlabel_reflect {
 FLOWLABEL_REFLECT_ESTABLISHED = 1,
 FLOWLABEL_REFLECT_TCP_RESET = 2,
 FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct ip6_flowlabel {
 struct ip6_flowlabel *next;
 __be32 label;
 atomic_t users;
 struct in6_addr dst;
 struct ipv6_txoptions *opt;
 unsigned long linger;
 struct callback_head rcu;
 u8 share;
 union {
  struct pid *pid;
  kuid_t uid;
 } owner;
 unsigned long lastuse;
 unsigned long expires;
 struct net *fl_net;
};
# 337 "/home/nathan/src/linux-next/include/net/ipv6.h"
struct ipv6_fl_socklist {
 struct ipv6_fl_socklist *next;
 struct ip6_flowlabel *fl;
 struct callback_head rcu;
};

struct ipcm6_cookie {
 struct sockcm_cookie sockc;
 __s16 hlimit;
 __s16 tclass;
 __s8 dontfrag;
 struct ipv6_txoptions *opt;
 __u16 gso_size;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipcm6_init(struct ipcm6_cookie *ipc6)
{
 *ipc6 = (struct ipcm6_cookie) {
  .hlimit = -1,
  .tclass = -1,
  .dontfrag = -1,
 };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipcm6_init_sk(struct ipcm6_cookie *ipc6,
     const struct ipv6_pinfo *np)
{
 *ipc6 = (struct ipcm6_cookie) {
  .hlimit = -1,
  .tclass = np->tclass,
  .dontfrag = np->dontfrag,
 };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)
{
 struct ipv6_txoptions *opt;

 rcu_read_lock();
 opt = ({ typeof(*(np->opt)) *________p1 = (typeof(*(np->opt)) *)({ union { typeof((np->opt)) __val; char __c[1]; } __u; if (1) __read_once_size(&((np->opt)), __u.__c, sizeof((np->opt))); else __read_once_size_nocheck(&((np->opt)), __u.__c, sizeof((np->opt))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(np->opt)) *)(________p1)); });
 if (opt) {
  if (!refcount_inc_not_zero(&opt->refcnt))
   opt = ((void *)0);
  else
   opt = (opt);
 }
 rcu_read_unlock();
 return opt;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void txopt_put(struct ipv6_txoptions *opt)
{
 if (opt && refcount_dec_and_test(&opt->refcnt))
  do { typeof (opt) ___p = (opt); if (___p) do { do { extern void __compiletime_assert_390(void) ; if (!(!(!((__builtin_offsetof(typeof(*(opt)), rcu)) < 4096)))) __compiletime_assert_390(); } while (0); kfree_call_rcu(&((___p)->rcu), (rcu_callback_t)(unsigned long)(__builtin_offsetof(typeof(*(opt)), rcu))); } while (0); } while (0);
}

struct ip6_flowlabel *__fl6_sock_lookup(struct sock *sk, __be32 label);

extern struct static_key_false_deferred ipv6_flowlabel_exclusive;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk,
          __be32 label)
{
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&ipv6_flowlabel_exclusive.key), struct static_key_true)) branch = arch_static_branch_jump(&(&ipv6_flowlabel_exclusive.key)->key, false); else if (__builtin_types_compatible_p(typeof(*&ipv6_flowlabel_exclusive.key), struct static_key_false)) branch = arch_static_branch(&(&ipv6_flowlabel_exclusive.key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }))
  return __fl6_sock_lookup(sk, label) ? : ERR_PTR(-2);

 return ((void *)0);
}

struct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,
      struct ip6_flowlabel *fl,
      struct ipv6_txoptions *fopt);
void fl6_free_socklist(struct sock *sk);
int ipv6_flowlabel_opt(struct sock *sk, char *optval, int optlen);
int ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,
      int flags);
int ip6_flowlabel_init(void);
void ip6_flowlabel_cleanup(void);
bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fl6_sock_release(struct ip6_flowlabel *fl)
{
 if (fl)
  atomic_dec(&fl->users);
}

void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);

void icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
    struct icmp6hdr *thdr, int len);

int ip6_ra_control(struct sock *sk, int sel);

int ipv6_parse_hopopts(struct sk_buff *skb);

struct ipv6_txoptions *ipv6_dup_options(struct sock *sk,
     struct ipv6_txoptions *opt);
struct ipv6_txoptions *ipv6_renew_options(struct sock *sk,
       struct ipv6_txoptions *opt,
       int newtype,
       struct ipv6_opt_hdr *newopt);
struct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,
       struct ipv6_txoptions *opt);

bool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,
         const struct inet6_skb_parm *opt);
struct ipv6_txoptions *ipv6_update_options(struct sock *sk,
        struct ipv6_txoptions *opt);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_accept_ra(struct inet6_dev *idev)
{



 return idev->cnf.forwarding ? idev->cnf.accept_ra == 2 :
     idev->cnf.accept_ra;
}





int __ipv6_addr_type(const struct in6_addr *addr);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_addr_type(const struct in6_addr *addr)
{
 return __ipv6_addr_type(addr) & 0xffff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_addr_scope(const struct in6_addr *addr)
{
 return __ipv6_addr_type(addr) & 0x00f0U;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ipv6_addr_src_scope(int type)
{
 return (type == 0x0000U) ? -1 : (type >> 16);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_addr_src_scope(const struct in6_addr *addr)
{
 return __ipv6_addr_src_scope(__ipv6_addr_type(addr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __ipv6_addr_needs_scope_id(int type)
{
 return type & 0x0020U ||
        (type & 0x0002U &&
  (type & (0x0010U|0x0020U)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 ipv6_iface_scope_id(const struct in6_addr *addr, int iface)
{
 return __ipv6_addr_needs_scope_id(__ipv6_addr_type(addr)) ? iface : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2)
{
 return memcmp(a1, a2, sizeof(struct in6_addr));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool
ipv6_masked_addr_cmp(const struct in6_addr *a1, const struct in6_addr *m,
       const struct in6_addr *a2)
{

 const unsigned long *ul1 = (const unsigned long *)a1;
 const unsigned long *ulm = (const unsigned long *)m;
 const unsigned long *ul2 = (const unsigned long *)a2;

 return !!(((ul1[0] ^ ul2[0]) & ulm[0]) |
    ((ul1[1] ^ ul2[1]) & ulm[1]));






}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_addr_prefix(struct in6_addr *pfx,
        const struct in6_addr *addr,
        int plen)
{

 int o = plen >> 3,
     b = plen & 0x7;

 memset(pfx->in6_u.u6_addr8, 0, sizeof(pfx->in6_u.u6_addr8));
 memcpy(pfx->in6_u.u6_addr8, addr, o);
 if (b != 0)
  pfx->in6_u.u6_addr8[o] = addr->in6_u.u6_addr8[o] & (0xff00 >> b);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_addr_prefix_copy(struct in6_addr *addr,
      const struct in6_addr *pfx,
      int plen)
{

 int o = plen >> 3,
     b = plen & 0x7;

 memcpy(addr->in6_u.u6_addr8, pfx, o);
 if (b != 0) {
  addr->in6_u.u6_addr8[o] &= ~(0xff00 >> b);
  addr->in6_u.u6_addr8[o] |= (pfx->in6_u.u6_addr8[o] & (0xff00 >> b));
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ipv6_addr_set_half(__be32 *addr,
     __be32 wh, __be32 wl)
{


 if (__builtin_constant_p(wh) && __builtin_constant_p(wl)) {
  *( u64 *)addr = (( u64)(wh) << 32 | ( u64)(wl));
  return;
 }







 addr[0] = wh;
 addr[1] = wl;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_addr_set(struct in6_addr *addr,
         __be32 w1, __be32 w2,
         __be32 w3, __be32 w4)
{
 __ipv6_addr_set_half(&addr->in6_u.u6_addr32[0], w1, w2);
 __ipv6_addr_set_half(&addr->in6_u.u6_addr32[2], w3, w4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_equal(const struct in6_addr *a1,
       const struct in6_addr *a2)
{

 const unsigned long *ul1 = (const unsigned long *)a1;
 const unsigned long *ul2 = (const unsigned long *)a2;

 return ((ul1[0] ^ ul2[0]) | (ul1[1] ^ ul2[1])) == 0UL;






}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool __ipv6_prefix_equal64_half(const __be64 *a1,
           const __be64 *a2,
           unsigned int len)
{
 if (len && ((*a1 ^ *a2) & (( __be64)(__u64)((~0UL) << (64 - len)))))
  return false;
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_prefix_equal(const struct in6_addr *addr1,
         const struct in6_addr *addr2,
         unsigned int prefixlen)
{
 const __be64 *a1 = (const __be64 *)addr1;
 const __be64 *a2 = (const __be64 *)addr2;

 if (prefixlen >= 64) {
  if (a1[0] ^ a2[0])
   return false;
  return __ipv6_prefix_equal64_half(a1 + 1, a2 + 1, prefixlen - 64);
 }
 return __ipv6_prefix_equal64_half(a1, a2, prefixlen);
}
# 635 "/home/nathan/src/linux-next/include/net/ipv6.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_any(const struct in6_addr *a)
{

 const unsigned long *ul = (const unsigned long *)a;

 return (ul[0] | ul[1]) == 0UL;




}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ipv6_addr_hash(const struct in6_addr *a)
{

 const unsigned long *ul = (const unsigned long *)a;
 unsigned long x = ul[0] ^ ul[1];

 return (u32)(x ^ (x >> 32));




}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __ipv6_addr_jhash(const struct in6_addr *a, const u32 initval)
{
 u32 v = ( u32)a->in6_u.u6_addr32[0] ^ ( u32)a->in6_u.u6_addr32[1];

 return jhash_3words(v,
       ( u32)a->in6_u.u6_addr32[2],
       ( u32)a->in6_u.u6_addr32[3],
       initval);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_loopback(const struct in6_addr *a)
{

 const __be64 *be = (const __be64 *)a;

 return (be[0] | (be[1] ^ (( __be64)(__u64)(1)))) == 0UL;




}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_v4mapped(const struct in6_addr *a)
{
 return (

  *(unsigned long *)a |



  ( unsigned long)(a->in6_u.u6_addr32[2] ^
     (( __be32)(__u32)(0x0000ffff)))) == 0UL;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_v4mapped_loopback(const struct in6_addr *a)
{
 return ipv6_addr_v4mapped(a) && ipv4_is_loopback(a->in6_u.u6_addr32[3]);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ipv6_portaddr_hash(const struct net *net,
         const struct in6_addr *addr6,
         unsigned int port)
{
 unsigned int hash, mix = net_hash_mix(net);

 if (ipv6_addr_any(addr6))
  hash = jhash_1word(0, mix);
 else if (ipv6_addr_v4mapped(addr6))
  hash = jhash_1word(( u32)addr6->in6_u.u6_addr32[3], mix);
 else
  hash = jhash2(( u32 *)addr6->in6_u.u6_addr32, 4, mix);

 return hash ^ port;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_orchid(const struct in6_addr *a)
{
 return (a->in6_u.u6_addr32[0] & (( __be32)(__u32)(0xfffffff0))) == (( __be32)(__u32)(0x20010010));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_addr_is_multicast(const struct in6_addr *addr)
{
 return (addr->in6_u.u6_addr32[0] & (( __be32)(__u32)(0xFF000000))) == (( __be32)(__u32)(0xFF000000));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_addr_set_v4mapped(const __be32 addr,
       struct in6_addr *v4mapped)
{
 ipv6_addr_set(v4mapped,
   0, 0,
   (( __be32)(__u32)(0x0000FFFF)),
   addr);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)
{
 const __be32 *a1 = token1, *a2 = token2;
 int i;

 addrlen >>= 2;

 for (i = 0; i < addrlen; i++) {
  __be32 xb = a1[i] ^ a2[i];
  if (xb)
   return i * 32 + 31 - __fls((( __u32)(__be32)(xb)));
 }
# 776 "/home/nathan/src/linux-next/include/net/ipv6.h"
 return addrlen << 5;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ipv6_addr_diff64(const void *token1, const void *token2, int addrlen)
{
 const __be64 *a1 = token1, *a2 = token2;
 int i;

 addrlen >>= 3;

 for (i = 0; i < addrlen; i++) {
  __be64 xb = a1[i] ^ a2[i];
  if (xb)
   return i * 64 + 63 - __fls((( __u64)(__be64)(xb)));
 }

 return addrlen << 6;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __ipv6_addr_diff(const void *token1, const void *token2, int addrlen)
{

 if (__builtin_constant_p(addrlen) && !(addrlen & 7))
  return __ipv6_addr_diff64(token1, token2, addrlen);

 return __ipv6_addr_diff32(token1, token2, addrlen);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ipv6_addr_diff(const struct in6_addr *a1, const struct in6_addr *a2)
{
 return __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));
}

__be32 ipv6_select_ident(struct net *net,
    const struct in6_addr *daddr,
    const struct in6_addr *saddr);
__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);

int ip6_dst_hoplimit(struct dst_entry *dst);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip6_sk_dst_hoplimit(struct ipv6_pinfo *np, struct flowi6 *fl6,
          struct dst_entry *dst)
{
 int hlimit;

 if (ipv6_addr_is_multicast(&fl6->daddr))
  hlimit = np->mcast_hops;
 else
  hlimit = np->hop_limit;
 if (hlimit < 0)
  hlimit = ip6_dst_hoplimit(dst);
 return hlimit;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iph_to_flow_copy_v6addrs(struct flow_keys *flow,
         const struct ipv6hdr *iph)
{
 do { extern void __compiletime_assert_841(void) ; if (!(!(__builtin_offsetof(typeof(flow->addrs), v6addrs.dst) != __builtin_offsetof(typeof(flow->addrs), v6addrs.src) + sizeof(flow->addrs.v6addrs.src)))) __compiletime_assert_841(); } while (0);


 memcpy(&flow->addrs.v6addrs, &iph->saddr, sizeof(flow->addrs.v6addrs));
 flow->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv6_can_nonlocal_bind(struct net *net,
       struct inet_sock *inet)
{
 return net->ipv6.sysctl.ip_nonlocal_bind ||
  inet->freebind || inet->transparent;
}
# 865 "/home/nathan/src/linux-next/include/net/ipv6.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,
     __be32 flowlabel, bool autolabel,
     struct flowi6 *fl6)
{
 u32 hash;




 flowlabel &= (( __be32)(__u32)(0x000FFFFF));

 if (flowlabel ||
     net->ipv6.sysctl.auto_flowlabels == 0 ||
     (!autolabel &&
      net->ipv6.sysctl.auto_flowlabels != 3))
  return flowlabel;

 hash = skb_get_hash_flowi6(skb, fl6);





 hash = rol32(hash, 16);

 flowlabel = ( __be32)hash & (( __be32)(__u32)(0x000FFFFF));

 if (net->ipv6.sysctl.flowlabel_state_ranges)
  flowlabel |= (( __be32)(__u32)(0x00080000));

 return flowlabel;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip6_default_np_autolabel(struct net *net)
{
 switch (net->ipv6.sysctl.auto_flowlabels) {
 case 0:
 case 2:
 default:
  return 0;
 case 1:
 case 3:
  return 1;
 }
}
# 925 "/home/nathan/src/linux-next/include/net/ipv6.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip6_multipath_hash_policy(const struct net *net)
{
 return net->ipv6.sysctl.multipath_hash_policy;
}
# 939 "/home/nathan/src/linux-next/include/net/ipv6.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,
    __be32 flowlabel)
{
 *(__be32 *)hdr = (( __be32)(__u32)(0x60000000 | (tclass << 20))) | flowlabel;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 ip6_flowinfo(const struct ipv6hdr *hdr)
{
 return *(__be32 *)hdr & (( __be32)(__u32)(0x0FFFFFFF));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 ip6_flowlabel(const struct ipv6hdr *hdr)
{
 return *(__be32 *)hdr & (( __be32)(__u32)(0x000FFFFF));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 ip6_tclass(__be32 flowinfo)
{
 return (( __u32)(__be32)(flowinfo & ((( __be32)(__u32)(0x0FFFFFFF)) & ~(( __be32)(__u32)(0x000FFFFF))))) >> 20;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 ip6_make_flowinfo(unsigned int tclass, __be32 flowlabel)
{
 return (( __be32)(__u32)(tclass << 20)) | flowlabel;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 flowi6_get_flowlabel(const struct flowi6 *fl6)
{
 return fl6->flowlabel & (( __be32)(__u32)(0x000FFFFF));
}
# 978 "/home/nathan/src/linux-next/include/net/ipv6.h"
int ipv6_rcv(struct sk_buff *skb, struct net_device *dev,
      struct packet_type *pt, struct net_device *orig_dev);
void ipv6_list_rcv(struct list_head *head, struct packet_type *pt,
     struct net_device *orig_dev);

int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb);




int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
      __u32 mark, struct ipv6_txoptions *opt, int tclass, u32 priority);

int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);

int ip6_append_data(struct sock *sk,
      int getfrag(void *from, char *to, int offset, int len,
    int odd, struct sk_buff *skb),
      void *from, int length, int transhdrlen,
      struct ipcm6_cookie *ipc6, struct flowi6 *fl6,
      struct rt6_info *rt, unsigned int flags);

int ip6_push_pending_frames(struct sock *sk);

void ip6_flush_pending_frames(struct sock *sk);

int ip6_send_skb(struct sk_buff *skb);

struct sk_buff *__ip6_make_skb(struct sock *sk, struct sk_buff_head *queue,
          struct inet_cork_full *cork,
          struct inet6_cork *v6_cork);
struct sk_buff *ip6_make_skb(struct sock *sk,
        int getfrag(void *from, char *to, int offset,
      int len, int odd, struct sk_buff *skb),
        void *from, int length, int transhdrlen,
        struct ipcm6_cookie *ipc6, struct flowi6 *fl6,
        struct rt6_info *rt, unsigned int flags,
        struct inet_cork_full *cork);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *ip6_finish_skb(struct sock *sk)
{
 return __ip6_make_skb(sk, &sk->sk_write_queue, &inet_sk(sk)->cork,
         &inet6_sk(sk)->cork);
}

int ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,
     struct flowi6 *fl6);
struct dst_entry *ip6_dst_lookup_flow(struct net *net, const struct sock *sk, struct flowi6 *fl6,
          const struct in6_addr *final_dst);
struct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,
      const struct in6_addr *final_dst,
      bool connected);
struct dst_entry *ip6_blackhole_route(struct net *net,
          struct dst_entry *orig_dst);





int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb);
int ip6_forward(struct sk_buff *skb);
int ip6_input(struct sk_buff *skb);
int ip6_mc_input(struct sk_buff *skb);
void ip6_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int nexthdr,
         bool have_final);

int __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);
int ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);





void ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,
     u8 *proto, struct in6_addr **daddr_p,
     struct in6_addr *saddr);
void ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,
    u8 *proto);

int ipv6_skip_exthdr(const struct sk_buff *, int start, u8 *nexthdrp,
       __be16 *frag_offp);

bool ipv6_ext_hdr(u8 nexthdr);

enum {
 IP6_FH_F_FRAG = (1 << 0),
 IP6_FH_F_AUTH = (1 << 1),
 IP6_FH_F_SKIP_RH = (1 << 2),
};


int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset, int target,
    unsigned short *fragoff, int *fragflg);

int ipv6_find_tlv(const struct sk_buff *skb, int offset, int type);

struct in6_addr *fl6_update_dst(struct flowi6 *fl6,
    const struct ipv6_txoptions *opt,
    struct in6_addr *orig);





int ipv6_setsockopt(struct sock *sk, int level, int optname,
      char *optval, unsigned int optlen);
int ipv6_getsockopt(struct sock *sk, int level, int optname,
      char *optval, int *optlen);
int compat_ipv6_setsockopt(struct sock *sk, int level, int optname,
      char *optval, unsigned int optlen);
int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,
      char *optval, int *optlen);

int __ip6_datagram_connect(struct sock *sk, struct sockaddr *addr,
      int addr_len);
int ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);
int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,
     int addr_len);
int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr);
void ip6_datagram_release_cb(struct sock *sk);

int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,
      int *addr_len);
int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,
       int *addr_len);
void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
       u32 info, u8 *payload);
void ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);
void ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);

int inet6_release(struct socket *sock);
int inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);
int inet6_getname(struct socket *sock, struct sockaddr *uaddr,
    int peer);
int inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);

int inet6_hash_connect(struct inet_timewait_death_row *death_row,
         struct sock *sk);
int inet6_sendmsg(struct socket *sock, struct msghdr *msg, size_t size);
int inet6_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
    int flags);




extern const struct proto_ops inet6_stream_ops;
extern const struct proto_ops inet6_dgram_ops;
extern const struct proto_ops inet6_sockraw_ops;

struct group_source_req;
struct group_filter;

int ip6_mc_source(int add, int omode, struct sock *sk,
    struct group_source_req *pgsr);
int ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf);
int ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,
    struct group_filter *optval, int *optlen);


int ac6_proc_init(struct net *net);
void ac6_proc_exit(struct net *net);
int raw6_proc_init(void);
void raw6_proc_exit(void);
int tcp6_proc_init(struct net *net);
void tcp6_proc_exit(struct net *net);
int udp6_proc_init(struct net *net);
void udp6_proc_exit(struct net *net);
int udplite6_proc_init(void);
void udplite6_proc_exit(void);
int ipv6_misc_proc_init(void);
void ipv6_misc_proc_exit(void);
int snmp6_register_dev(struct inet6_dev *idev);
int snmp6_unregister_dev(struct inet6_dev *idev);
# 1160 "/home/nathan/src/linux-next/include/net/ipv6.h"
struct ctl_table *ipv6_icmp_sysctl_init(struct net *net);
struct ctl_table *ipv6_route_sysctl_init(struct net *net);
int ipv6_sysctl_register(void);
void ipv6_sysctl_unregister(void);


int ipv6_sock_mc_join(struct sock *sk, int ifindex,
        const struct in6_addr *addr);
int ipv6_sock_mc_join_ssm(struct sock *sk, int ifindex,
     const struct in6_addr *addr, unsigned int mode);
int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
        const struct in6_addr *addr);
# 17 "/home/nathan/src/linux-next/include/net/inetpeer.h" 2



struct ipv4_addr_key {
 __be32 addr;
 int vif;
};



struct inetpeer_addr {
 union {
  struct ipv4_addr_key a4;
  struct in6_addr a6;
  u32 key[(sizeof(struct in6_addr) / sizeof(u32))];
 };
 __u16 family;
};

struct inet_peer {
 struct rb_node rb_node;
 struct inetpeer_addr daddr;

 u32 metrics[(__RTAX_MAX - 1)];
 u32 rate_tokens;
 u32 n_redirects;
 unsigned long rate_last;





 union {
  struct {
   atomic_t rid;
  };
  struct callback_head rcu;
 };


 __u32 dtime;
 refcount_t refcnt;
};

struct inet_peer_base {
 struct rb_root rb_root;
 seqlock_t lock;
 int total;
};

void inet_peer_base_init(struct inet_peer_base *);

void inet_initpeers(void) __attribute__((__section__(".init.text"))) __attribute__((__cold__)) ;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inetpeer_set_addr_v4(struct inetpeer_addr *iaddr, __be32 ip)
{
 iaddr->a4.addr = ip;
 iaddr->a4.vif = 0;
 iaddr->family = 2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 inetpeer_get_addr_v4(struct inetpeer_addr *iaddr)
{
 return iaddr->a4.addr;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inetpeer_set_addr_v6(struct inetpeer_addr *iaddr,
     struct in6_addr *in6)
{
 iaddr->a6 = *in6;
 iaddr->family = 10;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct in6_addr *inetpeer_get_addr_v6(struct inetpeer_addr *iaddr)
{
 return &iaddr->a6;
}


struct inet_peer *inet_getpeer(struct inet_peer_base *base,
          const struct inetpeer_addr *daddr,
          int create);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_peer *inet_getpeer_v4(struct inet_peer_base *base,
      __be32 v4daddr,
      int vif, int create)
{
 struct inetpeer_addr daddr;

 daddr.a4.addr = v4daddr;
 daddr.a4.vif = vif;
 daddr.family = 2;
 return inet_getpeer(base, &daddr, create);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_peer *inet_getpeer_v6(struct inet_peer_base *base,
      const struct in6_addr *v6daddr,
      int create)
{
 struct inetpeer_addr daddr;

 daddr.a6 = *v6daddr;
 daddr.family = 10;
 return inet_getpeer(base, &daddr, create);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inetpeer_addr_cmp(const struct inetpeer_addr *a,
        const struct inetpeer_addr *b)
{
 int i, n;

 if (a->family == 2)
  n = sizeof(a->a4) / sizeof(u32);
 else
  n = sizeof(a->a6) / sizeof(u32);

 for (i = 0; i < n; i++) {
  if (a->key[i] == b->key[i])
   continue;
  if (a->key[i] < b->key[i])
   return -1;
  return 1;
 }

 return 0;
}


void inet_putpeer(struct inet_peer *p);
bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);

void inetpeer_invalidate_tree(struct inet_peer_base *);
# 25 "/home/nathan/src/linux-next/include/net/route.h" 2


# 1 "/home/nathan/src/linux-next/include/net/ip_fib.h" 1
# 25 "/home/nathan/src/linux-next/include/net/ip_fib.h"
struct fib_config {
 u8 fc_dst_len;
 u8 fc_tos;
 u8 fc_protocol;
 u8 fc_scope;
 u8 fc_type;
 u8 fc_gw_family;

 u32 fc_table;
 __be32 fc_dst;
 union {
  __be32 fc_gw4;
  struct in6_addr fc_gw6;
 };
 int fc_oif;
 u32 fc_flags;
 u32 fc_priority;
 __be32 fc_prefsrc;
 u32 fc_nh_id;
 struct nlattr *fc_mx;
 struct rtnexthop *fc_mp;
 int fc_mx_len;
 int fc_mp_len;
 u32 fc_flow;
 u32 fc_nlflags;
 struct nl_info fc_nlinfo;
 struct nlattr *fc_encap;
 u16 fc_encap_type;
};

struct fib_info;
struct rtable;

struct fib_nh_exception {
 struct fib_nh_exception *fnhe_next;
 int fnhe_genid;
 __be32 fnhe_daddr;
 u32 fnhe_pmtu;
 bool fnhe_mtu_locked;
 __be32 fnhe_gw;
 unsigned long fnhe_expires;
 struct rtable *fnhe_rth_input;
 struct rtable *fnhe_rth_output;
 unsigned long fnhe_stamp;
 struct callback_head rcu;
};

struct fnhe_hash_bucket {
 struct fib_nh_exception *chain;
};





struct fib_nh_common {
 struct net_device *nhc_dev;
 int nhc_oif;
 unsigned char nhc_scope;
 u8 nhc_family;
 u8 nhc_gw_family;
 unsigned char nhc_flags;
 struct lwtunnel_state *nhc_lwtstate;

 union {
  __be32 ipv4;
  struct in6_addr ipv6;
 } nhc_gw;

 int nhc_weight;
 atomic_t nhc_upper_bound;


 struct rtable * *nhc_pcpu_rth_output;
 struct rtable *nhc_rth_input;
 struct fnhe_hash_bucket *nhc_exceptions;
};

struct fib_nh {
 struct fib_nh_common nh_common;
 struct hlist_node nh_hash;
 struct fib_info *nh_parent;



 __be32 nh_saddr;
 int nh_saddr_genid;
# 123 "/home/nathan/src/linux-next/include/net/ip_fib.h"
};





struct nexthop;

struct fib_info {
 struct hlist_node fib_hash;
 struct hlist_node fib_lhash;
 struct list_head nh_list;
 struct net *fib_net;
 int fib_treeref;
 refcount_t fib_clntref;
 unsigned int fib_flags;
 unsigned char fib_dead;
 unsigned char fib_protocol;
 unsigned char fib_scope;
 unsigned char fib_type;
 __be32 fib_prefsrc;
 u32 fib_tb_id;
 u32 fib_priority;
 struct dst_metrics *fib_metrics;




 int fib_nhs;
 bool fib_nh_is_v6;
 bool nh_updated;
 struct nexthop *nh;
 struct callback_head rcu;
 struct fib_nh fib_nh[0];
};






struct fib_table;
struct fib_result {
 __be32 prefix;
 unsigned char prefixlen;
 unsigned char nh_sel;
 unsigned char type;
 unsigned char scope;
 u32 tclassid;
 struct fib_nh_common *nhc;
 struct fib_info *fi;
 struct fib_table *table;
 struct hlist_head *fa_head;
};

struct fib_result_nl {
 __be32 fl_addr;
 u32 fl_mark;
 unsigned char fl_tos;
 unsigned char fl_scope;
 unsigned char tb_id_in;

 unsigned char tb_id;
 unsigned char prefixlen;
 unsigned char nh_sel;
 unsigned char type;
 unsigned char scope;
 int err;
};







__be32 fib_info_update_nhc_saddr(struct net *net, struct fib_nh_common *nhc,
     unsigned char scope);
__be32 fib_result_prefsrc(struct net *net, struct fib_result *res);





struct fib_rt_info {
 struct fib_info *fi;
 u32 tb_id;
 __be32 dst;
 int dst_len;
 u8 tos;
 u8 type;
 u8 offload:1,
    trap:1,
    unused:6;
};

struct fib_entry_notifier_info {
 struct fib_notifier_info info;
 u32 dst;
 int dst_len;
 struct fib_info *fi;
 u8 tos;
 u8 type;
 u32 tb_id;
};

struct fib_nh_notifier_info {
 struct fib_notifier_info info;
 struct fib_nh *fib_nh;
};

int call_fib4_notifier(struct notifier_block *nb,
         enum fib_event_type event_type,
         struct fib_notifier_info *info);
int call_fib4_notifiers(struct net *net, enum fib_event_type event_type,
   struct fib_notifier_info *info);

int fib4_notifier_init(struct net *net);
void fib4_notifier_exit(struct net *net);

void fib_info_notify_update(struct net *net, struct nl_info *info);
int fib_notify(struct net *net, struct notifier_block *nb,
        struct netlink_ext_ack *extack);

struct fib_table {
 struct hlist_node tb_hlist;
 u32 tb_id;
 int tb_num_default;
 struct callback_head rcu;
 unsigned long *tb_data;
 unsigned long __data[0];
};

struct fib_dump_filter {
 u32 table_id;

 bool filter_set;
 bool dump_all_families;
 bool dump_routes;
 bool dump_exceptions;
 unsigned char protocol;
 unsigned char rt_type;
 unsigned int flags;
 struct net_device *dev;
};

int fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,
       struct fib_result *res, int fib_flags);
int fib_table_insert(struct net *, struct fib_table *, struct fib_config *,
       struct netlink_ext_ack *extack);
int fib_table_delete(struct net *, struct fib_table *, struct fib_config *,
       struct netlink_ext_ack *extack);
int fib_table_dump(struct fib_table *table, struct sk_buff *skb,
     struct netlink_callback *cb, struct fib_dump_filter *filter);
int fib_table_flush(struct net *net, struct fib_table *table, bool flush_all);
struct fib_table *fib_trie_unmerge(struct fib_table *main_tb);
void fib_table_flush_external(struct fib_table *table);
void fib_free_table(struct fib_table *tb);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fib_table *fib_get_table(struct net *net, u32 id)
{
 struct hlist_node *tb_hlist;
 struct hlist_head *ptr;

 ptr = id == RT_TABLE_LOCAL ?
  &net->ipv4.fib_table_hash[(RT_TABLE_LOCAL & (2 - 1))] :
  &net->ipv4.fib_table_hash[(RT_TABLE_MAIN & (2 - 1))];

 tb_hlist = ({ typeof(*((*((struct hlist_node **)(&(ptr)->first))))) *________p1 = (typeof(*((*((struct hlist_node **)(&(ptr)->first))))) *)({ union { typeof(((*((struct hlist_node **)(&(ptr)->first))))) __val; char __c[1]; } __u; if (1) __read_once_size(&(((*((struct hlist_node **)(&(ptr)->first))))), __u.__c, sizeof(((*((struct hlist_node **)(&(ptr)->first)))))); else __read_once_size_nocheck(&(((*((struct hlist_node **)(&(ptr)->first))))), __u.__c, sizeof(((*((struct hlist_node **)(&(ptr)->first)))))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*((*((struct hlist_node **)(&(ptr)->first))))) *)(________p1)); });

 return ({ void *__mptr = (void *)(tb_hlist); do { extern void __compiletime_assert_298(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(tb_hlist)), typeof(((struct fib_table *)0)->tb_hlist)) && !__builtin_types_compatible_p(typeof(*(tb_hlist)), typeof(void))))) __compiletime_assert_298(); } while (0); ((struct fib_table *)(__mptr - __builtin_offsetof(struct fib_table, tb_hlist))); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct fib_table *fib_new_table(struct net *net, u32 id)
{
 return fib_get_table(net, id);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fib_lookup(struct net *net, const struct flowi4 *flp,
        struct fib_result *res, unsigned int flags)
{
 struct fib_table *tb;
 int err = -101;

 rcu_read_lock();

 tb = fib_get_table(net, RT_TABLE_MAIN);
 if (tb)
  err = fib_table_lookup(tb, flp, res, flags | 1);

 if (err == -11)
  err = -101;

 rcu_read_unlock();

 return err;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib4_has_custom_rules(const struct net *net)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib4_rule_default(const struct fib_rule *rule)
{
 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fib4_rules_dump(struct net *net, struct notifier_block *nb,
      struct netlink_ext_ack *extack)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int fib4_rules_seq_read(struct net *net)
{
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool fib4_rules_early_flow_dissect(struct net *net,
       struct sk_buff *skb,
       struct flowi4 *fl4,
       struct flow_keys *flkeys)
{
 return false;
}
# 429 "/home/nathan/src/linux-next/include/net/ip_fib.h"
extern const struct nla_policy rtm_ipv4_policy[];
void ip_fib_init(void);
int fib_gw_from_via(struct fib_config *cfg, struct nlattr *nla,
      struct netlink_ext_ack *extack);
__be32 fib_compute_spec_dst(struct sk_buff *skb);
bool fib_info_nh_uses_dev(struct fib_info *fi, const struct net_device *dev);
int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,
   u8 tos, int oif, struct net_device *dev,
   struct in_device *idev, u32 *itag);






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int fib_num_tclassid_users(struct net *net)
{
 return 0;
}

int fib_unmerge(struct net *net);


int ip_fib_check_default(__be32 gw, struct net_device *dev);
int fib_sync_down_dev(struct net_device *dev, unsigned long event, bool force);
int fib_sync_down_addr(struct net_device *dev, __be32 local);
int fib_sync_up(struct net_device *dev, unsigned char nh_flags);
void fib_sync_mtu(struct net_device *dev, u32 orig_mtu);
void fib_nhc_update_mtu(struct fib_nh_common *nhc, u32 new, u32 orig);





int fib_check_nh(struct net *net, struct fib_nh *nh, u32 table, u8 scope,
   struct netlink_ext_ack *extack);
void fib_select_multipath(struct fib_result *res, int hash);
void fib_select_path(struct net *net, struct fib_result *res,
       struct flowi4 *fl4, const struct sk_buff *skb);

int fib_nh_init(struct net *net, struct fib_nh *fib_nh,
  struct fib_config *cfg, int nh_weight,
  struct netlink_ext_ack *extack);
void fib_nh_release(struct net *net, struct fib_nh *fib_nh);
int fib_nh_common_init(struct fib_nh_common *nhc, struct nlattr *fc_encap,
         u16 fc_encap_type, void *cfg, gfp_t gfp_flags,
         struct netlink_ext_ack *extack);
void fib_nh_common_release(struct fib_nh_common *nhc);


void fib_alias_hw_flags_set(struct net *net, const struct fib_rt_info *fri);
void fib_trie_init(void);
struct fib_table *fib_trie_table(u32 id, struct fib_table *alias);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fib_combine_itag(u32 *itag, const struct fib_result *res)
{
# 506 "/home/nathan/src/linux-next/include/net/ip_fib.h"
}

void fib_flush(struct net *net);
void free_fib_info(struct fib_info *fi);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fib_info_hold(struct fib_info *fi)
{
 refcount_inc(&fi->fib_clntref);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fib_info_put(struct fib_info *fi)
{
 if (refcount_dec_and_test(&fi->fib_clntref))
  free_fib_info(fi);
}


int fib_proc_init(struct net *net);
void fib_proc_exit(struct net *net);
# 535 "/home/nathan/src/linux-next/include/net/ip_fib.h"
u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr);

int ip_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,
     struct fib_dump_filter *filter,
     struct netlink_callback *cb);

int fib_nexthop_info(struct sk_buff *skb, const struct fib_nh_common *nh,
       u8 rt_family, unsigned char *flags, bool skip_oif);
int fib_add_nexthop(struct sk_buff *skb, const struct fib_nh_common *nh,
      int nh_weight, u8 rt_family);
# 28 "/home/nathan/src/linux-next/include/net/route.h" 2
# 1 "/home/nathan/src/linux-next/include/net/arp.h" 1
# 11 "/home/nathan/src/linux-next/include/net/arp.h"
extern struct neigh_table arp_tbl;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 arp_hashfn(const void *pkey, const struct net_device *dev, u32 *hash_rnd)
{
 u32 key = *(const u32 *)pkey;
 u32 val = key ^ hash32_ptr(dev);

 return val * hash_rnd[0];
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *__ipv4_neigh_lookup_noref(struct net_device *dev, u32 key)
{
 if (dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))
  key = ((unsigned long int) 0x00000000);

 return ___neigh_lookup_noref(&arp_tbl, neigh_key_eq32, arp_hashfn, &key, dev);
}
# 37 "/home/nathan/src/linux-next/include/net/arp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *__ipv4_neigh_lookup(struct net_device *dev, u32 key)
{
 struct neighbour *n;

 rcu_read_lock_bh();
 n = __ipv4_neigh_lookup_noref(dev, key);
 if (n && !refcount_inc_not_zero(&n->refcnt))
  n = ((void *)0);
 rcu_read_unlock_bh();

 return n;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __ipv4_confirm_neigh(struct net_device *dev, u32 key)
{
 struct neighbour *n;

 rcu_read_lock_bh();
 n = __ipv4_neigh_lookup_noref(dev, key);
 if (n) {
  unsigned long now = jiffies;


  if (({ union { typeof(n->confirmed) __val; char __c[1]; } __u; if (1) __read_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); else __read_once_size_nocheck(&(n->confirmed), __u.__c, sizeof(n->confirmed)); do { } while (0); __u.__val; }) != now)
   ({ union { typeof(n->confirmed) __val; char __c[1]; } __u = { .__val = ( typeof(n->confirmed)) (now) }; __write_once_size(&(n->confirmed), __u.__c, sizeof(n->confirmed)); __u.__val; });
 }
 rcu_read_unlock_bh();
}

void arp_init(void);
int arp_ioctl(struct net *net, unsigned int cmd, void *arg);
void arp_send(int type, int ptype, __be32 dest_ip,
       struct net_device *dev, __be32 src_ip,
       const unsigned char *dest_hw,
       const unsigned char *src_hw, const unsigned char *th);
int arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir);
void arp_ifdown(struct net_device *dev);

struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
      struct net_device *dev, __be32 src_ip,
      const unsigned char *dest_hw,
      const unsigned char *src_hw,
      const unsigned char *target_hw);
void arp_xmit(struct sk_buff *skb);
# 29 "/home/nathan/src/linux-next/include/net/route.h" 2

# 1 "/home/nathan/src/linux-next/include/uapi/linux/in_route.h" 1
# 31 "/home/nathan/src/linux-next/include/net/route.h" 2


# 1 "/home/nathan/src/linux-next/include/uapi/linux/route.h" 1
# 31 "/home/nathan/src/linux-next/include/uapi/linux/route.h"
struct rtentry {
 unsigned long rt_pad1;
 struct sockaddr rt_dst;
 struct sockaddr rt_gateway;
 struct sockaddr rt_genmask;
 unsigned short rt_flags;
 short rt_pad2;
 unsigned long rt_pad3;
 void *rt_pad4;
 short rt_metric;
 char *rt_dev;
 unsigned long rt_mtu;



 unsigned long rt_window;
 unsigned short rt_irtt;
};
# 34 "/home/nathan/src/linux-next/include/net/route.h" 2
# 46 "/home/nathan/src/linux-next/include/net/route.h"
struct fib_nh;
struct fib_info;
struct uncached_list;
struct rtable {
 struct dst_entry dst;

 int rt_genid;
 unsigned int rt_flags;
 __u16 rt_type;
 __u8 rt_is_input;
 __u8 rt_uses_gateway;

 int rt_iif;

 u8 rt_gw_family;

 union {
  __be32 rt_gw4;
  struct in6_addr rt_gw6;
 };


 u32 rt_mtu_locked:1,
    rt_pmtu:31;

 struct list_head rt_uncached;
 struct uncached_list *rt_uncached_list;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rt_is_input_route(const struct rtable *rt)
{
 return rt->rt_is_input != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rt_is_output_route(const struct rtable *rt)
{
 return rt->rt_is_input == 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __be32 rt_nexthop(const struct rtable *rt, __be32 daddr)
{
 if (rt->rt_gw_family == 2)
  return rt->rt_gw4;
 return daddr;
}

struct ip_rt_acct {
 __u32 o_bytes;
 __u32 o_packets;
 __u32 i_bytes;
 __u32 i_packets;
};

struct rt_cache_stat {
        unsigned int in_slow_tot;
        unsigned int in_slow_mc;
        unsigned int in_no_route;
        unsigned int in_brd;
        unsigned int in_martian_dst;
        unsigned int in_martian_src;
        unsigned int out_slow_tot;
        unsigned int out_slow_mc;
};

extern struct ip_rt_acct *ip_rt_acct;

struct in_device;

int ip_rt_init(void);
void rt_cache_flush(struct net *net);
void rt_flush_dev(struct net_device *dev);
struct rtable *ip_route_output_key_hash(struct net *net, struct flowi4 *flp,
     const struct sk_buff *skb);
struct rtable *ip_route_output_key_hash_rcu(struct net *net, struct flowi4 *flp,
         struct fib_result *res,
         const struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *__ip_route_output_key(struct net *net,
         struct flowi4 *flp)
{
 return ip_route_output_key_hash(net, flp, ((void *)0));
}

struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
        const struct sock *sk);
struct dst_entry *ipv4_blackhole_route(struct net *net,
           struct dst_entry *dst_orig);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_output_key(struct net *net, struct flowi4 *flp)
{
 return ip_route_output_flow(net, flp, ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_output(struct net *net, __be32 daddr,
          __be32 saddr, u8 tos, int oif)
{
 struct flowi4 fl4 = {
  .__fl_common.flowic_oif = oif,
  .__fl_common.flowic_tos = tos,
  .daddr = daddr,
  .saddr = saddr,
 };
 return ip_route_output_key(net, &fl4);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_output_ports(struct net *net, struct flowi4 *fl4,
         struct sock *sk,
         __be32 daddr, __be32 saddr,
         __be16 dport, __be16 sport,
         __u8 proto, __u8 tos, int oif)
{
 flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
      RT_SCOPE_UNIVERSE, proto,
      sk ? inet_sk_flowi_flags(sk) : 0,
      daddr, saddr, dport, sport, sock_net_uid(net, sk));
 if (sk)
  security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
 return ip_route_output_flow(net, fl4, sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_output_gre(struct net *net, struct flowi4 *fl4,
       __be32 daddr, __be32 saddr,
       __be32 gre_key, __u8 tos, int oif)
{
 memset(fl4, 0, sizeof(*fl4));
 fl4->__fl_common.flowic_oif = oif;
 fl4->daddr = daddr;
 fl4->saddr = saddr;
 fl4->__fl_common.flowic_tos = tos;
 fl4->__fl_common.flowic_proto = IPPROTO_GRE;
 fl4->uli.gre_key = gre_key;
 return ip_route_output_key(net, fl4);
}
int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,
     u8 tos, struct net_device *dev,
     struct in_device *in_dev, u32 *itag);
int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
    u8 tos, struct net_device *devin);
int ip_route_input_rcu(struct sk_buff *skb, __be32 dst, __be32 src,
         u8 tos, struct net_device *devin,
         struct fib_result *res);

int ip_route_use_hint(struct sk_buff *skb, __be32 dst, __be32 src,
        u8 tos, struct net_device *devin,
        const struct sk_buff *hint);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
     u8 tos, struct net_device *devin)
{
 int err;

 rcu_read_lock();
 err = ip_route_input_noref(skb, dst, src, tos, devin);
 if (!err) {
  skb_dst_force(skb);
  if (!skb_dst(skb))
   err = -22;
 }
 rcu_read_unlock();

 return err;
}

void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu, int oif,
        u8 protocol);
void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
void ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u8 protocol);
void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
void ip_rt_send_redirect(struct sk_buff *skb);

unsigned int inet_addr_type(struct net *net, __be32 addr);
unsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id);
unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
    __be32 addr);
unsigned int inet_addr_type_dev_table(struct net *net,
          const struct net_device *dev,
          __be32 addr);
void ip_rt_multicast_event(struct in_device *);
int ip_rt_ioctl(struct net *, unsigned int cmd, struct rtentry *rt);
void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
struct rtable *rt_dst_alloc(struct net_device *dev,
        unsigned int flags, u16 type,
        bool nopolicy, bool noxfrm, bool will_cache);
struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);

struct in_ifaddr;
void fib_add_ifaddr(struct in_ifaddr *);
void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
void fib_modify_prefix_metric(struct in_ifaddr *ifa, u32 new_metric);

void rt_add_uncached_list(struct rtable *rt);
void rt_del_uncached_list(struct rtable *rt);

int fib_dump_info_fnhe(struct sk_buff *skb, struct netlink_callback *cb,
         u32 table_id, struct fib_info *fi,
         int *fa_index, int fa_start, unsigned int flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_rt_put(struct rtable *rt)
{



 do { extern void __compiletime_assert_248(void) ; if (!(!(__builtin_offsetof(struct rtable, dst) != 0))) __compiletime_assert_248(); } while (0);
 dst_release(&rt->dst);
}



extern const __u8 ip_tos2prio[16];

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) char rt_tos2priority(u8 tos)
{
 return ip_tos2prio[((tos)&0x1E)>>1];
}
# 285 "/home/nathan/src/linux-next/include/net/route.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32 src,
      u32 tos, int oif, u8 protocol,
      __be16 sport, __be16 dport,
      struct sock *sk)
{
 __u8 flow_flags = 0;

 if (inet_sk(sk)->transparent)
  flow_flags |= 0x01;

 flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
      protocol, flow_flags, dst, src, dport, sport,
      sk->sk_uid);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_connect(struct flowi4 *fl4,
           __be32 dst, __be32 src, u32 tos,
           int oif, u8 protocol,
           __be16 sport, __be16 dport,
           struct sock *sk)
{
 struct net *net = sock_net(sk);
 struct rtable *rt;

 ip_route_connect_init(fl4, dst, src, tos, oif, protocol,
         sport, dport, sk);

 if (!dst || !src) {
  rt = __ip_route_output_key(net, fl4);
  if (IS_ERR(rt))
   return rt;
  ip_rt_put(rt);
  flowi4_update_output(fl4, oif, tos, fl4->daddr, fl4->saddr);
 }
 security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
 return ip_route_output_flow(net, fl4, sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable *rt,
            __be16 orig_sport, __be16 orig_dport,
            __be16 sport, __be16 dport,
            struct sock *sk)
{
 if (sport != orig_sport || dport != orig_dport) {
  fl4->uli.ports.dport = dport;
  fl4->uli.ports.sport = sport;
  ip_rt_put(rt);
  flowi4_update_output(fl4, sk->__sk_common.skc_bound_dev_if,
         (((inet_sk(sk)->tos)&0x1E) | sock_flag(sk, SOCK_LOCALROUTE)), fl4->daddr,
         fl4->saddr);
  security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
  return ip_route_output_flow(sock_net(sk), fl4, sk);
 }
 return rt;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_iif(const struct sk_buff *skb)
{
 struct rtable *rt = skb_rtable(skb);

 if (rt && rt->rt_iif)
  return rt->rt_iif;

 return skb->skb_iif;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip4_dst_hoplimit(const struct dst_entry *dst)
{
 int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
 struct net *net = dev_net(dst->dev);

 if (hoplimit == 0)
  hoplimit = net->ipv4.sysctl_ip_default_ttl;
 return hoplimit;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *ip_neigh_gw4(struct net_device *dev,
          __be32 daddr)
{
 struct neighbour *neigh;

 neigh = __ipv4_neigh_lookup_noref(dev, daddr);
 if (__builtin_expect(!!(!neigh), 0))
  neigh = __neigh_create(&arp_tbl, &daddr, dev, false);

 return neigh;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct neighbour *ip_neigh_for_gw(struct rtable *rt,
      struct sk_buff *skb,
      bool *is_v6gw)
{
 struct net_device *dev = rt->dst.dev;
 struct neighbour *neigh;

 if (__builtin_expect(!!(rt->rt_gw_family == 2), 1)) {
  neigh = ip_neigh_gw4(dev, rt->rt_gw4);
 } else if (rt->rt_gw_family == 10) {
  neigh = ip_neigh_gw6(dev, &rt->rt_gw6);
  *is_v6gw = true;
 } else {
  neigh = ip_neigh_gw4(dev, ip_hdr(skb)->daddr);
 }
 return neigh;
}
# 28 "/home/nathan/src/linux-next/include/net/inet_hashtables.h" 2
# 38 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
struct inet_ehash_bucket {
 struct hlist_nulls_head chain;
};
# 76 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
struct inet_bind_bucket {
 possible_net_t ib_net;
 int l3mdev;
 unsigned short port;
 signed char fastreuse;
 signed char fastreuseport;
 kuid_t fastuid;

 struct in6_addr fast_v6_rcv_saddr;

 __be32 fast_rcv_saddr;
 unsigned short fast_sk_family;
 bool fast_ipv6_only;
 struct hlist_node node;
 struct hlist_head owners;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct net *ib_net(struct inet_bind_bucket *ib)
{
 return read_pnet(&ib->ib_net);
}




struct inet_bind_hashbucket {
 spinlock_t lock;
 struct hlist_head chain;
};







struct inet_listen_hashbucket {
 spinlock_t lock;
 unsigned int count;
 union {
  struct hlist_head head;
  struct hlist_nulls_head nulls_head;
 };
};




struct inet_hashinfo {






 struct inet_ehash_bucket *ehash;
 spinlock_t *ehash_locks;
 unsigned int ehash_mask;
 unsigned int ehash_locks_mask;




 struct kmem_cache *bind_bucket_cachep;
 struct inet_bind_hashbucket *bhash;
 unsigned int bhash_size;


 unsigned int lhash2_mask;
 struct inet_listen_hashbucket *lhash2;
# 159 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
 struct inet_listen_hashbucket listening_hash[32]
     __attribute__((__aligned__((1 << 7))));
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_listen_hashbucket *
inet_lhash2_bucket(struct inet_hashinfo *h, u32 hash)
{
 return &h->lhash2[hash & h->lhash2_mask];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct inet_ehash_bucket *inet_ehash_bucket(
 struct inet_hashinfo *hashinfo,
 unsigned int hash)
{
 return &hashinfo->ehash[hash & hashinfo->ehash_mask];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) spinlock_t *inet_ehash_lockp(
 struct inet_hashinfo *hashinfo,
 unsigned int hash)
{
 return &hashinfo->ehash_locks[hash & hashinfo->ehash_locks_mask];
}

int inet_ehash_locks_alloc(struct inet_hashinfo *hashinfo);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_ehash_locks_free(struct inet_hashinfo *hashinfo)
{
 kvfree(hashinfo->ehash_locks);
 hashinfo->ehash_locks = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_sk_bound_dev_eq(struct net *net, int bound_dev_if,
     int dif, int sdif)
{




 return inet_bound_dev_eq(true, bound_dev_if, dif, sdif);

}

struct inet_bind_bucket *
inet_bind_bucket_create(struct kmem_cache *cachep, struct net *net,
   struct inet_bind_hashbucket *head,
   const unsigned short snum, int l3mdev);
void inet_bind_bucket_destroy(struct kmem_cache *cachep,
         struct inet_bind_bucket *tb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 inet_bhashfn(const struct net *net, const __u16 lport,
          const u32 bhash_size)
{
 return (lport + net_hash_mix(net)) & (bhash_size - 1);
}

void inet_bind_hash(struct sock *sk, struct inet_bind_bucket *tb,
      const unsigned short snum);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 inet_lhashfn(const struct net *net, const unsigned short num)
{
 return (num + net_hash_mix(net)) & (32 - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_sk_listen_hashfn(const struct sock *sk)
{
 return inet_lhashfn(sock_net(sk), inet_sk(sk)->sk.__sk_common.skc_num);
}


int __inet_inherit_port(const struct sock *sk, struct sock *child);

void inet_put_port(struct sock *sk);

void inet_hashinfo_init(struct inet_hashinfo *h);
void inet_hashinfo2_init(struct inet_hashinfo *h, const char *name,
    unsigned long numentries, int scale,
    unsigned long low_limit,
    unsigned long high_limit);
int inet_hashinfo2_init_mod(struct inet_hashinfo *h);

bool inet_ehash_insert(struct sock *sk, struct sock *osk);
bool inet_ehash_nolisten(struct sock *sk, struct sock *osk);
int __inet_hash(struct sock *sk, struct sock *osk);
int inet_hash(struct sock *sk);
void inet_unhash(struct sock *sk);

struct sock *__inet_lookup_listener(struct net *net,
        struct inet_hashinfo *hashinfo,
        struct sk_buff *skb, int doff,
        const __be32 saddr, const __be16 sport,
        const __be32 daddr,
        const unsigned short hnum,
        const int dif, const int sdif);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *inet_lookup_listener(struct net *net,
  struct inet_hashinfo *hashinfo,
  struct sk_buff *skb, int doff,
  __be32 saddr, __be16 sport,
  __be32 daddr, __be16 dport, int dif, int sdif)
{
 return __inet_lookup_listener(net, hashinfo, skb, doff, saddr, sport,
          daddr, (( __u16)(__be16)(dport)), dif, sdif);
}
# 319 "/home/nathan/src/linux-next/include/net/inet_hashtables.h"
struct sock *__inet_lookup_established(struct net *net,
           struct inet_hashinfo *hashinfo,
           const __be32 saddr, const __be16 sport,
           const __be32 daddr, const u16 hnum,
           const int dif, const int sdif);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *
 inet_lookup_established(struct net *net, struct inet_hashinfo *hashinfo,
    const __be32 saddr, const __be16 sport,
    const __be32 daddr, const __be16 dport,
    const int dif)
{
 return __inet_lookup_established(net, hashinfo, saddr, sport, daddr,
      (( __u16)(__be16)(dport)), dif, 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *__inet_lookup(struct net *net,
      struct inet_hashinfo *hashinfo,
      struct sk_buff *skb, int doff,
      const __be32 saddr, const __be16 sport,
      const __be32 daddr, const __be16 dport,
      const int dif, const int sdif,
      bool *refcounted)
{
 u16 hnum = (( __u16)(__be16)(dport));
 struct sock *sk;

 sk = __inet_lookup_established(net, hashinfo, saddr, sport,
           daddr, hnum, dif, sdif);
 *refcounted = true;
 if (sk)
  return sk;
 *refcounted = false;
 return __inet_lookup_listener(net, hashinfo, skb, doff, saddr,
          sport, daddr, hnum, dif, sdif);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *inet_lookup(struct net *net,
           struct inet_hashinfo *hashinfo,
           struct sk_buff *skb, int doff,
           const __be32 saddr, const __be16 sport,
           const __be32 daddr, const __be16 dport,
           const int dif)
{
 struct sock *sk;
 bool refcounted;

 sk = __inet_lookup(net, hashinfo, skb, doff, saddr, sport, daddr,
      dport, dif, 0, &refcounted);

 if (sk && !refcounted && !refcount_inc_not_zero(&sk->__sk_common.skc_refcnt))
  sk = ((void *)0);
 return sk;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *__inet_lookup_skb(struct inet_hashinfo *hashinfo,
          struct sk_buff *skb,
          int doff,
          const __be16 sport,
          const __be16 dport,
          const int sdif,
          bool *refcounted)
{
 struct sock *sk = skb_steal_sock(skb);
 const struct iphdr *iph = ip_hdr(skb);

 *refcounted = true;
 if (sk)
  return sk;

 return __inet_lookup(dev_net(skb_dst(skb)->dev), hashinfo, skb,
        doff, iph->saddr, sport,
        iph->daddr, dport, inet_iif(skb), sdif,
        refcounted);
}

u32 inet6_ehashfn(const struct net *net,
    const struct in6_addr *laddr, const u16 lport,
    const struct in6_addr *faddr, const __be16 fport);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_daddr_set(struct sock *sk, __be32 addr)
{
 sk->__sk_common.skc_daddr = addr;

 ipv6_addr_set_v4mapped(addr, &sk->__sk_common.skc_v6_daddr);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void sk_rcv_saddr_set(struct sock *sk, __be32 addr)
{
 sk->__sk_common.skc_rcv_saddr = addr;

 ipv6_addr_set_v4mapped(addr, &sk->__sk_common.skc_v6_rcv_saddr);

}

int __inet_hash_connect(struct inet_timewait_death_row *death_row,
   struct sock *sk, u32 port_offset,
   int (*check_established)(struct inet_timewait_death_row *,
       struct sock *, __u16,
       struct inet_timewait_sock **));

int inet_hash_connect(struct inet_timewait_death_row *death_row,
        struct sock *sk);
# 33 "/home/nathan/src/linux-next/include/net/tcp.h" 2


# 1 "/home/nathan/src/linux-next/include/net/sock_reuseport.h" 1
# 11 "/home/nathan/src/linux-next/include/net/sock_reuseport.h"
extern spinlock_t reuseport_lock;

struct sock_reuseport {
 struct callback_head rcu;

 u16 max_socks;
 u16 num_socks;



 unsigned int synq_overflow_ts;

 unsigned int reuseport_id;
 unsigned int bind_inany:1;
 unsigned int has_conns:1;
 struct bpf_prog *prog;
 struct sock *socks[0];
};

extern int reuseport_alloc(struct sock *sk, bool bind_inany);
extern int reuseport_add_sock(struct sock *sk, struct sock *sk2,
         bool bind_inany);
extern void reuseport_detach_sock(struct sock *sk);
extern struct sock *reuseport_select_sock(struct sock *sk,
       u32 hash,
       struct sk_buff *skb,
       int hdr_len);
extern int reuseport_attach_prog(struct sock *sk, struct bpf_prog *prog);
extern int reuseport_detach_prog(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool reuseport_has_conns(struct sock *sk, bool set)
{
 struct sock_reuseport *reuse;
 bool ret = false;

 rcu_read_lock();
 reuse = ({ typeof(*(sk->sk_reuseport_cb)) *________p1 = (typeof(*(sk->sk_reuseport_cb)) *)({ union { typeof((sk->sk_reuseport_cb)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); else __read_once_size_nocheck(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_reuseport_cb)) *)(________p1)); });
 if (reuse) {
  if (set)
   reuse->has_conns = 1;
  ret = reuse->has_conns;
 }
 rcu_read_unlock();

 return ret;
}

int reuseport_get_id(struct sock_reuseport *reuse);
# 36 "/home/nathan/src/linux-next/include/net/tcp.h" 2


# 1 "/home/nathan/src/linux-next/include/net/ip.h" 1
# 37 "/home/nathan/src/linux-next/include/net/ip.h"
extern unsigned int sysctl_fib_sync_mem;
extern unsigned int sysctl_fib_sync_mem_min;
extern unsigned int sysctl_fib_sync_mem_max;

struct sock;

struct inet_skb_parm {
 int iif;
 struct ip_options opt;
 u16 flags;
# 57 "/home/nathan/src/linux-next/include/net/ip.h"
 u16 frag_max_size;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ipv4_l3mdev_skb(u16 flags)
{
 return !!(flags & ((((1UL))) << (7)));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ip_hdrlen(const struct sk_buff *skb)
{
 return ip_hdr(skb)->ihl * 4;
}

struct ipcm_cookie {
 struct sockcm_cookie sockc;
 __be32 addr;
 int oif;
 struct ip_options_rcu *opt;
 __u8 ttl;
 __s16 tos;
 char priority;
 __u16 gso_size;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipcm_init(struct ipcm_cookie *ipcm)
{
 *ipcm = (struct ipcm_cookie) { .tos = -1 };
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipcm_init_sk(struct ipcm_cookie *ipcm,
    const struct inet_sock *inet)
{
 ipcm_init(ipcm);

 ipcm->sockc.mark = inet->sk.sk_mark;
 ipcm->sockc.tsflags = inet->sk.sk_tsflags;
 ipcm->oif = inet->sk.__sk_common.skc_bound_dev_if;
 ipcm->addr = inet->inet_saddr;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int inet_sdif(struct sk_buff *skb)
{




 return 0;
}
# 121 "/home/nathan/src/linux-next/include/net/ip.h"
struct ip_ra_chain {
 struct ip_ra_chain *next;
 struct sock *sk;
 union {
  void (*destructor)(struct sock *);
  struct sock *saved_sk;
 };
 struct callback_head rcu;
};
# 139 "/home/nathan/src/linux-next/include/net/ip.h"
struct msghdr;
struct net_device;
struct packet_type;
struct rtable;
struct sockaddr;

int igmp_mc_init(void);





int ip_build_and_send_pkt(struct sk_buff *skb, const struct sock *sk,
     __be32 saddr, __be32 daddr,
     struct ip_options_rcu *opt);
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
    struct net_device *orig_dev);
void ip_list_rcv(struct list_head *head, struct packet_type *pt,
   struct net_device *orig_dev);
int ip_local_deliver(struct sk_buff *skb);
void ip_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int proto);
int ip_mr_input(struct sk_buff *skb);
int ip_output(struct net *net, struct sock *sk, struct sk_buff *skb);
int ip_mc_output(struct net *net, struct sock *sk, struct sk_buff *skb);
int ip_do_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
     int (*output)(struct net *, struct sock *, struct sk_buff *));

struct ip_fraglist_iter {
 struct sk_buff *frag;
 struct iphdr *iph;
 int offset;
 unsigned int hlen;
};

void ip_fraglist_init(struct sk_buff *skb, struct iphdr *iph,
        unsigned int hlen, struct ip_fraglist_iter *iter);
void ip_fraglist_prepare(struct sk_buff *skb, struct ip_fraglist_iter *iter);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *ip_fraglist_next(struct ip_fraglist_iter *iter)
{
 struct sk_buff *skb = iter->frag;

 iter->frag = skb->next;
 skb_mark_not_on_list(skb);

 return skb;
}

struct ip_frag_state {
 bool DF;
 unsigned int hlen;
 unsigned int ll_rs;
 unsigned int mtu;
 unsigned int left;
 int offset;
 int ptr;
 __be16 not_last_frag;
};

void ip_frag_init(struct sk_buff *skb, unsigned int hlen, unsigned int ll_rs,
    unsigned int mtu, bool DF, struct ip_frag_state *state);
struct sk_buff *ip_frag_next(struct sk_buff *skb,
        struct ip_frag_state *state);

void ip_send_check(struct iphdr *ip);
int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);
int ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);

int __ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
      __u8 tos);
void ip_init(void);
int ip_append_data(struct sock *sk, struct flowi4 *fl4,
     int getfrag(void *from, char *to, int offset, int len,
          int odd, struct sk_buff *skb),
     void *from, int len, int protolen,
     struct ipcm_cookie *ipc,
     struct rtable **rt,
     unsigned int flags);
int ip_generic_getfrag(void *from, char *to, int offset, int len, int odd,
         struct sk_buff *skb);
ssize_t ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
         int offset, size_t size, int flags);
struct sk_buff *__ip_make_skb(struct sock *sk, struct flowi4 *fl4,
         struct sk_buff_head *queue,
         struct inet_cork *cork);
int ip_send_skb(struct net *net, struct sk_buff *skb);
int ip_push_pending_frames(struct sock *sk, struct flowi4 *fl4);
void ip_flush_pending_frames(struct sock *sk);
struct sk_buff *ip_make_skb(struct sock *sk, struct flowi4 *fl4,
       int getfrag(void *from, char *to, int offset,
     int len, int odd, struct sk_buff *skb),
       void *from, int length, int transhdrlen,
       struct ipcm_cookie *ipc, struct rtable **rtp,
       struct inet_cork *cork, unsigned int flags);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip_queue_xmit(struct sock *sk, struct sk_buff *skb,
    struct flowi *fl)
{
 return __ip_queue_xmit(sk, skb, fl, inet_sk(sk)->tos);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *ip_finish_skb(struct sock *sk, struct flowi4 *fl4)
{
 return __ip_make_skb(sk, fl4, &sk->sk_write_queue, &inet_sk(sk)->cork.base);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 get_rttos(struct ipcm_cookie* ipc, struct inet_sock *inet)
{
 return (ipc->tos != -1) ? ((ipc->tos)&0x1E) : ((inet->tos)&0x1E);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 get_rtconn_flags(struct ipcm_cookie* ipc, struct sock* sk)
{
 return (ipc->tos != -1) ? (((ipc->tos)&0x1E) | sock_flag(sk, SOCK_LOCALROUTE)) : (((inet_sk(sk)->tos)&0x1E) | sock_flag(sk, SOCK_LOCALROUTE));
}


int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);

void ip4_datagram_release_cb(struct sock *sk);

struct ip_reply_arg {
 struct kvec iov[1];
 int flags;
 __wsum csum;
 int csumoffset;

 int bound_dev_if;
 u8 tos;
 kuid_t uid;
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 ip_reply_arg_flowi_flags(const struct ip_reply_arg *arg)
{
 return (arg->flags & 1) ? 0x01 : 0;
}

void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb,
      const struct ip_options *sopt,
      __be32 daddr, __be32 saddr,
      const struct ip_reply_arg *arg,
      unsigned int len, u64 transmit_time);
# 296 "/home/nathan/src/linux-next/include/net/ip.h"
u64 snmp_get_cpu_field(void *mib, int cpu, int offct);
unsigned long snmp_fold_field(void *mib, int offt);





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 snmp_get_cpu_field64(void *mib, int cpu, int offct,
     size_t syncp_offset)
{
 return snmp_get_cpu_field(mib, cpu, offct);

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 snmp_fold_field64(void *mib, int offt, size_t syncp_off)
{
 return snmp_fold_field(mib, offt);
}
# 339 "/home/nathan/src/linux-next/include/net/ip.h"
void inet_get_local_port_range(struct net *net, int *low, int *high);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_is_local_reserved_port(struct net *net, unsigned short port)
{
 if (!net->ipv4.sysctl_local_reserved_ports)
  return false;
 return test_bit(port, net->ipv4.sysctl_local_reserved_ports);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sysctl_dev_name_is_allowed(const char *name)
{
 return strcmp(name, "default") != 0 && strcmp(name, "all") != 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_port_requires_bind_service(struct net *net, unsigned short port)
{
 return port < net->ipv4.sysctl_ip_prot_sock;
}
# 371 "/home/nathan/src/linux-next/include/net/ip.h"
__be32 inet_current_timestamp(void);


extern int inet_peer_threshold;
extern int inet_peer_minttl;
extern int inet_peer_maxttl;

void ipfrag_init(void);

void ip_static_sysctl_init(void);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ip_is_fragment(const struct iphdr *iph)
{
 return (iph->frag_off & (( __be16)(__u16)(0x2000 | 0x1FFF))) != 0;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int ip_decrease_ttl(struct iphdr *iph)
{
 u32 check = ( u32)iph->check;
 check += ( u32)(( __be16)(__u16)(0x0100));
 iph->check = ( __sum16)(check + (check>=0xFFFF));
 return --iph->ttl;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip_mtu_locked(const struct dst_entry *dst)
{
 const struct rtable *rt = (const struct rtable *)dst;

 return rt->rt_mtu_locked || dst_metric_locked(dst, RTAX_MTU);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int ip_dont_fragment(const struct sock *sk, const struct dst_entry *dst)
{
 u8 pmtudisc = ({ union { typeof(inet_sk(sk)->pmtudisc) __val; char __c[1]; } __u; if (1) __read_once_size(&(inet_sk(sk)->pmtudisc), __u.__c, sizeof(inet_sk(sk)->pmtudisc)); else __read_once_size_nocheck(&(inet_sk(sk)->pmtudisc), __u.__c, sizeof(inet_sk(sk)->pmtudisc)); do { } while (0); __u.__val; });

 return pmtudisc == 2 ||
  (pmtudisc == 1 &&
   !ip_mtu_locked(dst));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ip_sk_accept_pmtu(const struct sock *sk)
{
 return inet_sk(sk)->pmtudisc != 4 &&
        inet_sk(sk)->pmtudisc != 5;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ip_sk_use_pmtu(const struct sock *sk)
{
 return inet_sk(sk)->pmtudisc < 3;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ip_sk_ignore_df(const struct sock *sk)
{
 return inet_sk(sk)->pmtudisc < 2 ||
        inet_sk(sk)->pmtudisc == 5;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst,
          bool forwarding)
{
 struct net *net = dev_net(dst->dev);

 if (net->ipv4.sysctl_ip_fwd_use_pmtu ||
     ip_mtu_locked(dst) ||
     !forwarding)
  return dst_mtu(dst);

 return __builtin_choose_expr(((!!(sizeof((typeof(({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })) *)1 == (typeof(0xFFFFU) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(0xFFFFU) * 0l)) : (int *)8))))), ((({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })) < (0xFFFFU) ? (({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })) : (0xFFFFU)), ({ typeof(({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })) __UNIQUE_ID___x86 = (({ union { typeof(dst->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); else __read_once_size_nocheck(&(dst->dev->mtu), __u.__c, sizeof(dst->dev->mtu)); do { } while (0); __u.__val; })); typeof(0xFFFFU) __UNIQUE_ID___y87 = (0xFFFFU); ((__UNIQUE_ID___x86) < (__UNIQUE_ID___y87) ? (__UNIQUE_ID___x86) : (__UNIQUE_ID___y87)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ip_skb_dst_mtu(struct sock *sk,
       const struct sk_buff *skb)
{
 if (!sk || !sk_fullsock(sk) || ip_sk_use_pmtu(sk)) {
  bool forwarding = ((struct inet_skb_parm*)((skb)->cb))->flags & ((((1UL))) << (0));

  return ip_dst_mtu_maybe_forward(skb_dst(skb), forwarding);
 }

 return __builtin_choose_expr(((!!(sizeof((typeof(({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })) *)1 == (typeof(0xFFFFU) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(0xFFFFU) * 0l)) : (int *)8))))), ((({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })) < (0xFFFFU) ? (({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })) : (0xFFFFU)), ({ typeof(({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })) __UNIQUE_ID___x88 = (({ union { typeof(skb_dst(skb)->dev->mtu) __val; char __c[1]; } __u; if (1) __read_once_size(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); else __read_once_size_nocheck(&(skb_dst(skb)->dev->mtu), __u.__c, sizeof(skb_dst(skb)->dev->mtu)); do { } while (0); __u.__val; })); typeof(0xFFFFU) __UNIQUE_ID___y89 = (0xFFFFU); ((__UNIQUE_ID___x88) < (__UNIQUE_ID___y89) ? (__UNIQUE_ID___x88) : (__UNIQUE_ID___y89)); }));
}

struct dst_metrics *ip_fib_metrics_init(struct net *net, struct nlattr *fc_mx,
     int fc_mx_len,
     struct netlink_ext_ack *extack);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_fib_metrics_put(struct dst_metrics *fib_metrics)
{
 if (fib_metrics != &dst_default_metrics &&
     refcount_dec_and_test(&fib_metrics->refcnt))
  kfree(fib_metrics);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void ip_dst_init_metrics(struct dst_entry *dst, struct dst_metrics *fib_metrics)
{
 dst_init_metrics(dst, fib_metrics->metrics, true);

 if (fib_metrics != &dst_default_metrics) {
  dst->_metrics |= 0x2UL;
  refcount_inc(&fib_metrics->refcnt);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
void ip_dst_metrics_put(struct dst_entry *dst)
{
 struct dst_metrics *p = (struct dst_metrics *)((u32 *)(((dst)->_metrics) & ~0x3UL));

 if (p != &dst_default_metrics && refcount_dec_and_test(&p->refcnt))
  kfree(p);
}

u32 ip_idents_reserve(u32 hash, int segs);
void __ip_select_ident(struct net *net, struct iphdr *iph, int segs);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_select_ident_segs(struct net *net, struct sk_buff *skb,
     struct sock *sk, int segs)
{
 struct iphdr *iph = ip_hdr(skb);

 if ((iph->frag_off & (( __be16)(__u16)(0x4000))) && !skb->ignore_df) {





  if (sk && inet_sk(sk)->sk.__sk_common.skc_daddr) {
   iph->id = (( __be16)(__u16)(inet_sk(sk)->inet_id));
   inet_sk(sk)->inet_id += segs;
  } else {
   iph->id = 0;
  }
 } else {
  __ip_select_ident(net, iph, segs);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_select_ident(struct net *net, struct sk_buff *skb,
       struct sock *sk)
{
 ip_select_ident_segs(net, skb, sk, 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum inet_compute_pseudo(struct sk_buff *skb, int proto)
{
 return csum_tcpudp_nofold(ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
      skb->len, proto, 0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void iph_to_flow_copy_v4addrs(struct flow_keys *flow,
         const struct iphdr *iph)
{
 do { extern void __compiletime_assert_540(void) ; if (!(!(__builtin_offsetof(typeof(flow->addrs), v4addrs.dst) != __builtin_offsetof(typeof(flow->addrs), v4addrs.src) + sizeof(flow->addrs.v4addrs.src)))) __compiletime_assert_540(); } while (0);


 memcpy(&flow->addrs.v4addrs, &iph->saddr, sizeof(flow->addrs.v4addrs));
 flow->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __wsum inet_gro_compute_pseudo(struct sk_buff *skb, int proto)
{
 const struct iphdr *iph = skb_gro_network_header(skb);

 return csum_tcpudp_nofold(iph->saddr, iph->daddr,
      skb_gro_len(skb), proto, 0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_eth_mc_map(__be32 naddr, char *buf)
{
 __u32 addr=(( __u32)(__be32)(naddr));
 buf[0]=0x01;
 buf[1]=0x00;
 buf[2]=0x5e;
 buf[5]=addr&0xFF;
 addr>>=8;
 buf[4]=addr&0xFF;
 addr>>=8;
 buf[3]=addr&0x7F;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_ib_mc_map(__be32 naddr, const unsigned char *broadcast, char *buf)
{
 __u32 addr;
 unsigned char scope = broadcast[5] & 0xF;

 buf[0] = 0;
 buf[1] = 0xff;
 buf[2] = 0xff;
 buf[3] = 0xff;
 addr = (( __u32)(__be32)(naddr));
 buf[4] = 0xff;
 buf[5] = 0x10 | scope;
 buf[6] = 0x40;
 buf[7] = 0x1b;
 buf[8] = broadcast[8];
 buf[9] = broadcast[9];
 buf[10] = 0;
 buf[11] = 0;
 buf[12] = 0;
 buf[13] = 0;
 buf[14] = 0;
 buf[15] = 0;
 buf[19] = addr & 0xff;
 addr >>= 8;
 buf[18] = addr & 0xff;
 addr >>= 8;
 buf[17] = addr & 0xff;
 addr >>= 8;
 buf[16] = addr & 0x0f;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_ipgre_mc_map(__be32 naddr, const unsigned char *broadcast, char *buf)
{
 if ((broadcast[0] | broadcast[1] | broadcast[2] | broadcast[3]) != 0)
  memcpy(buf, broadcast, 4);
 else
  memcpy(buf, &naddr, sizeof(naddr));
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void inet_reset_saddr(struct sock *sk)
{
 inet_sk(sk)->sk.__sk_common.skc_rcv_saddr = inet_sk(sk)->inet_saddr = 0;

 if (sk->__sk_common.skc_family == 10) {
  struct ipv6_pinfo *np = inet6_sk(sk);

  memset(&np->saddr, 0, sizeof(np->saddr));
  memset(&sk->__sk_common.skc_v6_rcv_saddr, 0, sizeof(sk->__sk_common.skc_v6_rcv_saddr));
 }

}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int ipv4_addr_hash(__be32 ip)
{
 return ( unsigned int) ip;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 ipv4_portaddr_hash(const struct net *net,
         __be32 saddr,
         unsigned int port)
{
 return jhash_1word(( u32)saddr, net_hash_mix(net)) ^ port;
}

bool ip_call_ra_chain(struct sk_buff *skb);





enum ip_defrag_users {
 IP_DEFRAG_LOCAL_DELIVER,
 IP_DEFRAG_CALL_RA_CHAIN,
 IP_DEFRAG_CONNTRACK_IN,
 __IP_DEFRAG_CONNTRACK_IN_END = IP_DEFRAG_CONNTRACK_IN + ((unsigned short)~0U),
 IP_DEFRAG_CONNTRACK_OUT,
 __IP_DEFRAG_CONNTRACK_OUT_END = IP_DEFRAG_CONNTRACK_OUT + ((unsigned short)~0U),
 IP_DEFRAG_CONNTRACK_BRIDGE_IN,
 __IP_DEFRAG_CONNTRACK_BRIDGE_IN = IP_DEFRAG_CONNTRACK_BRIDGE_IN + ((unsigned short)~0U),
 IP_DEFRAG_VS_IN,
 IP_DEFRAG_VS_OUT,
 IP_DEFRAG_VS_FWD,
 IP_DEFRAG_AF_PACKET,
 IP_DEFRAG_MACVLAN,
};




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool ip_defrag_user_in_between(u32 user,
          enum ip_defrag_users lower_bond,
          enum ip_defrag_users upper_bond)
{
 return user >= lower_bond && user <= upper_bond;
}

int ip_defrag(struct net *net, struct sk_buff *skb, u32 user);

struct sk_buff *ip_check_defrag(struct net *net, struct sk_buff *skb, u32 user);
# 691 "/home/nathan/src/linux-next/include/net/ip.h"
int ip_forward(struct sk_buff *skb);





void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
        __be32 daddr, struct rtable *rt, int is_frag);

int __ip_options_echo(struct net *net, struct ip_options *dopt,
        struct sk_buff *skb, const struct ip_options *sopt);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int ip_options_echo(struct net *net, struct ip_options *dopt,
      struct sk_buff *skb)
{
 return __ip_options_echo(net, dopt, skb, &((struct inet_skb_parm*)((skb)->cb))->opt);
}

void ip_options_fragment(struct sk_buff *skb);
int __ip_options_compile(struct net *net, struct ip_options *opt,
    struct sk_buff *skb, __be32 *info);
int ip_options_compile(struct net *net, struct ip_options *opt,
         struct sk_buff *skb);
int ip_options_get(struct net *net, struct ip_options_rcu **optp,
     unsigned char *data, int optlen);
int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,
        unsigned char *data, int optlen);
void ip_options_undo(struct ip_options *opt);
void ip_forward_options(struct sk_buff *skb);
int ip_options_rcv_srr(struct sk_buff *skb, struct net_device *dev);





void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb);
void ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,
    struct sk_buff *skb, int tlen, int offset);
int ip_cmsg_send(struct sock *sk, struct msghdr *msg,
   struct ipcm_cookie *ipc, bool allow_ipv6);
int ip_setsockopt(struct sock *sk, int level, int optname, char *optval,
    unsigned int optlen);
int ip_getsockopt(struct sock *sk, int level, int optname, char *optval,
    int *optlen);
int compat_ip_setsockopt(struct sock *sk, int level, int optname,
    char *optval, unsigned int optlen);
int compat_ip_getsockopt(struct sock *sk, int level, int optname,
    char *optval, int *optlen);
int ip_ra_control(struct sock *sk, unsigned char on,
    void (*destructor)(struct sock *));

int ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len);
void ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
     u32 info, u8 *payload);
void ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 dport,
      u32 info);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
{
 ip_cmsg_recv_offset(msg, skb->sk, skb, 0, 0);
}

bool icmp_global_allow(void);
extern int sysctl_icmp_msgs_per_sec;
extern int sysctl_icmp_msgs_burst;


int ip_misc_proc_init(void);


int rtm_getroute_parse_ip_proto(struct nlattr *attr, u8 *ip_proto, u8 family,
    struct netlink_ext_ack *extack);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inetdev_valid_mtu(unsigned int mtu)
{
 return __builtin_expect(!!(mtu >= 68), 1);
}
# 39 "/home/nathan/src/linux-next/include/net/tcp.h" 2

# 1 "/home/nathan/src/linux-next/include/net/inet_ecn.h" 1








# 1 "/home/nathan/src/linux-next/include/net/dsfield.h" 1
# 16 "/home/nathan/src/linux-next/include/net/dsfield.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 ipv4_get_dsfield(const struct iphdr *iph)
{
 return iph->tos;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 ipv6_get_dsfield(const struct ipv6hdr *ipv6h)
{
 return (( __u16)(__be16)(*( const __be16 *)ipv6h)) >> 4;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv4_change_dsfield(struct iphdr *iph,__u8 mask,
    __u8 value)
{
        __u32 check = (( __u16)(__be16)(( __be16)iph->check));
 __u8 dsfield;

 dsfield = (iph->tos & mask) | value;
 check += iph->tos;
 if ((check+1) >> 16) check = (check+1) & 0xffff;
 check -= dsfield;
 check += check >> 16;
 iph->check = ( __sum16)(( __be16)(__u16)(check));
 iph->tos = dsfield;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_change_dsfield(struct ipv6hdr *ipv6h,__u8 mask,
    __u8 value)
{
 __be16 *p = ( __be16 *)ipv6h;

 *p = (*p & (( __be16)(__u16)((((u16)mask << 4) | 0xf00f)))) | (( __be16)(__u16)((u16)value << 4));
}
# 10 "/home/nathan/src/linux-next/include/net/inet_ecn.h" 2

enum {
 INET_ECN_NOT_ECT = 0,
 INET_ECN_ECT_1 = 1,
 INET_ECN_ECT_0 = 2,
 INET_ECN_CE = 3,
 INET_ECN_MASK = 3,
};

extern int sysctl_tunnel_ecn_log;

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int INET_ECN_is_ce(__u8 dsfield)
{
 return (dsfield & INET_ECN_MASK) == INET_ECN_CE;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int INET_ECN_is_not_ect(__u8 dsfield)
{
 return (dsfield & INET_ECN_MASK) == INET_ECN_NOT_ECT;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int INET_ECN_is_capable(__u8 dsfield)
{
 return dsfield & INET_ECN_ECT_0;
}
# 44 "/home/nathan/src/linux-next/include/net/inet_ecn.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u8 INET_ECN_encapsulate(__u8 outer, __u8 inner)
{
 outer &= ~INET_ECN_MASK;
 outer |= !INET_ECN_is_ce(inner) ? (inner & INET_ECN_MASK) :
       INET_ECN_ECT_0;
 return outer;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INET_ECN_xmit(struct sock *sk)
{
 inet_sk(sk)->tos |= INET_ECN_ECT_0;
 if (inet6_sk(sk) != ((void *)0))
  inet6_sk(sk)->tclass |= INET_ECN_ECT_0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void INET_ECN_dontxmit(struct sock *sk)
{
 inet_sk(sk)->tos &= ~INET_ECN_MASK;
 if (inet6_sk(sk) != ((void *)0))
  inet6_sk(sk)->tclass &= ~INET_ECN_MASK;
}
# 75 "/home/nathan/src/linux-next/include/net/inet_ecn.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int IP_ECN_set_ce(struct iphdr *iph)
{
 u32 check = ( u32)iph->check;
 u32 ecn = (iph->tos + 1) & INET_ECN_MASK;
# 87 "/home/nathan/src/linux-next/include/net/inet_ecn.h"
 if (!(ecn & 2))
  return !ecn;






 check += ( u16)(( __be16)(__u16)(0xFFFB)) + ( u16)(( __be16)(__u16)(ecn));

 iph->check = ( __sum16)(check + (check>=0xFFFF));
 iph->tos |= INET_ECN_CE;
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void IP_ECN_clear(struct iphdr *iph)
{
 iph->tos &= ~INET_ECN_MASK;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv4_copy_dscp(unsigned int dscp, struct iphdr *inner)
{
 dscp &= ~INET_ECN_MASK;
 ipv4_change_dsfield(inner, INET_ECN_MASK, dscp);
}

struct ipv6hdr;







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)
{
 __be32 from, to;

 if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
  return 0;

 from = *(__be32 *)iph;
 to = from | (( __be32)(__u32)(INET_ECN_CE << 20));
 *(__be32 *)iph = to;
 if (skb->ip_summed == 2)
  skb->csum = csum_add(csum_sub(skb->csum, ( __wsum)from),
         ( __wsum)to);
 return 1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
{
 dscp &= ~INET_ECN_MASK;
 ipv6_change_dsfield(inner, INET_ECN_MASK, dscp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int INET_ECN_set_ce(struct sk_buff *skb)
{
 switch (skb->protocol) {
 case (( __be16)(__u16)(0x0800)):
  if (skb_network_header(skb) + sizeof(struct iphdr) <=
      skb_tail_pointer(skb))
   return IP_ECN_set_ce(ip_hdr(skb));
  break;

 case (( __be16)(__u16)(0x86DD)):
  if (skb_network_header(skb) + sizeof(struct ipv6hdr) <=
      skb_tail_pointer(skb))
   return IP6_ECN_set_ce(skb, ipv6_hdr(skb));
  break;
 }

 return 0;
}
# 186 "/home/nathan/src/linux-next/include/net/inet_ecn.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int __INET_ECN_decapsulate(__u8 outer, __u8 inner, bool *set_ce)
{
 if (INET_ECN_is_not_ect(inner)) {
  switch (outer & INET_ECN_MASK) {
  case INET_ECN_NOT_ECT:
   return 0;
  case INET_ECN_ECT_0:
  case INET_ECN_ECT_1:
   return 1;
  case INET_ECN_CE:
   return 2;
  }
 }

 *set_ce = INET_ECN_is_ce(outer);
 return 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int INET_ECN_decapsulate(struct sk_buff *skb,
           __u8 outer, __u8 inner)
{
 bool set_ce = false;
 int rc;

 rc = __INET_ECN_decapsulate(outer, inner, &set_ce);
 if (!rc && set_ce)
  INET_ECN_set_ce(skb);

 return rc;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int IP_ECN_decapsulate(const struct iphdr *oiph,
         struct sk_buff *skb)
{
 __u8 inner;

 if (skb->protocol == (( __be16)(__u16)(0x0800)))
  inner = ip_hdr(skb)->tos;
 else if (skb->protocol == (( __be16)(__u16)(0x86DD)))
  inner = ipv6_get_dsfield(ipv6_hdr(skb));
 else
  return 0;

 return INET_ECN_decapsulate(skb, oiph->tos, inner);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int IP6_ECN_decapsulate(const struct ipv6hdr *oipv6h,
          struct sk_buff *skb)
{
 __u8 inner;

 if (skb->protocol == (( __be16)(__u16)(0x0800)))
  inner = ip_hdr(skb)->tos;
 else if (skb->protocol == (( __be16)(__u16)(0x86DD)))
  inner = ipv6_get_dsfield(ipv6_hdr(skb));
 else
  return 0;

 return INET_ECN_decapsulate(skb, ipv6_get_dsfield(oipv6h), inner);
}
# 41 "/home/nathan/src/linux-next/include/net/tcp.h" 2

# 1 "/home/nathan/src/linux-next/include/net/mptcp.h" 1
# 16 "/home/nathan/src/linux-next/include/net/mptcp.h"
struct mptcp_ext {
 u64 data_ack;
 u64 data_seq;
 u32 subflow_seq;
 u16 data_len;
 u8 use_map:1,
   dsn64:1,
   data_fin:1,
   use_ack:1,
   ack64:1,
   mpc_map:1,
   __unused:2;

};

struct mptcp_out_options {






};
# 111 "/home/nathan/src/linux-next/include/net/mptcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcp_init(void)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool sk_is_mptcp(const struct sock *sk)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool rsk_is_mptcp(const struct request_sock *req)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcp_parse_option(const struct sk_buff *skb,
          const unsigned char *ptr, int opsize,
          struct tcp_options_received *opt_rx)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mptcp_syn_options(struct sock *sk, const struct sk_buff *skb,
         unsigned int *size,
         struct mptcp_out_options *opts)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcp_rcv_synsent(struct sock *sk)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mptcp_synack_options(const struct request_sock *req,
     unsigned int *size,
     struct mptcp_out_options *opts)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mptcp_established_options(struct sock *sk,
          struct sk_buff *skb,
          unsigned int *size,
          unsigned int remaining,
          struct mptcp_out_options *opts)
{
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcp_incoming_options(struct sock *sk,
       struct sk_buff *skb,
       struct tcp_options_received *opt_rx)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcp_skb_ext_move(struct sk_buff *to,
          const struct sk_buff *from)
{
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool mptcp_skb_can_collapse(const struct sk_buff *to,
       const struct sk_buff *from)
{
 return true;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int mptcpv6_init(void) { return 0; }
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void mptcpv6_handle_mapped(struct sock *sk, bool mapped) { }
# 43 "/home/nathan/src/linux-next/include/net/tcp.h" 2






extern struct inet_hashinfo tcp_hashinfo;

extern struct percpu_counter tcp_orphan_count;
void tcp_time_wait(struct sock *sk, int state, int timeo);
# 245 "/home/nathan/src/linux-next/include/net/tcp.h"
extern int sysctl_tcp_max_orphans;
extern long sysctl_tcp_mem[3];





extern atomic_long_t tcp_memory_allocated;
extern struct percpu_counter tcp_sockets_allocated;
extern unsigned long tcp_memory_pressure;


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_under_memory_pressure(const struct sock *sk)
{
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&memcg_sockets_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&memcg_sockets_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&memcg_sockets_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&memcg_sockets_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) && sk->sk_memcg &&
     mem_cgroup_under_socket_pressure(sk->sk_memcg))
  return true;

 return ({ union { typeof(tcp_memory_pressure) __val; char __c[1]; } __u; if (1) __read_once_size(&(tcp_memory_pressure), __u.__c, sizeof(tcp_memory_pressure)); else __read_once_size_nocheck(&(tcp_memory_pressure), __u.__c, sizeof(tcp_memory_pressure)); do { } while (0); __u.__val; });
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool before(__u32 seq1, __u32 seq2)
{
        return (__s32)(seq1-seq2) < 0;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool between(__u32 seq1, __u32 seq2, __u32 seq3)
{
 return seq3 - seq2 >= seq1 - seq2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_out_of_memory(struct sock *sk)
{
 if (sk->sk_wmem_queued > ((2048 + ((((sizeof(struct sk_buff))) + ((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1)) & ~((typeof((sizeof(struct sk_buff))))(((1 << 7))) - 1))) * 2) &&
     sk_memory_allocated(sk) > sk_prot_mem_limits(sk, 2))
  return true;
 return false;
}

void sk_forced_mem_schedule(struct sock *sk, int size);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_too_many_orphans(struct sock *sk, int shift)
{
 struct percpu_counter *ocp = sk->__sk_common.skc_prot->orphan_count;
 int orphans = percpu_counter_read_positive(ocp);

 if (orphans << shift > sysctl_tcp_max_orphans) {
  orphans = percpu_counter_sum_positive(ocp);
  if (orphans << shift > sysctl_tcp_max_orphans)
   return true;
 }
 return false;
}

bool tcp_check_oom(struct sock *sk, int shift);


extern struct proto tcp_prot;






void tcp_tasklet_init(void);

int tcp_v4_err(struct sk_buff *skb, u32);

void tcp_shutdown(struct sock *sk, int how);

int tcp_v4_early_demux(struct sk_buff *skb);
int tcp_v4_rcv(struct sk_buff *skb);

int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);
int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size);
int tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,
   int flags);
int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
   size_t size, int flags);
ssize_t do_tcp_sendpages(struct sock *sk, struct page *page, int offset,
   size_t size, int flags);
int tcp_send_mss(struct sock *sk, int *size_goal, int flags);
void tcp_push(struct sock *sk, int flags, int mss_now, int nonagle,
       int size_goal);
void tcp_release_cb(struct sock *sk);
void tcp_wfree(struct sk_buff *skb);
void tcp_write_timer_handler(struct sock *sk);
void tcp_delack_timer_handler(struct sock *sk);
int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);
int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb);
void tcp_rcv_established(struct sock *sk, struct sk_buff *skb);
void tcp_rcv_space_adjust(struct sock *sk);
int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);
void tcp_twsk_destructor(struct sock *sk);
ssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,
   struct pipe_inode_info *pipe, size_t len,
   unsigned int flags);

void tcp_enter_quickack_mode(struct sock *sk, unsigned int max_quickacks);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_dec_quickack_mode(struct sock *sk,
      const unsigned int pkts)
{
 struct inet_connection_sock *icsk = inet_csk(sk);

 if (icsk->icsk_ack.quick) {
  if (pkts >= icsk->icsk_ack.quick) {
   icsk->icsk_ack.quick = 0;

   icsk->icsk_ack.ato = ((unsigned)(100/25));
  } else
   icsk->icsk_ack.quick -= pkts;
 }
}






enum tcp_tw_status {
 TCP_TW_SUCCESS = 0,
 TCP_TW_RST = 1,
 TCP_TW_ACK = 2,
 TCP_TW_SYN = 3
};


enum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,
           struct sk_buff *skb,
           const struct tcphdr *th);
struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
      struct request_sock *req, bool fastopen,
      bool *lost_race);
int tcp_child_process(struct sock *parent, struct sock *child,
        struct sk_buff *skb);
void tcp_enter_loss(struct sock *sk);
void tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int flag);
void tcp_clear_retrans(struct tcp_sock *tp);
void tcp_update_metrics(struct sock *sk);
void tcp_init_metrics(struct sock *sk);
void tcp_metrics_init(void);
bool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst);
void tcp_close(struct sock *sk, long timeout);
void tcp_init_sock(struct sock *sk);
void tcp_init_transfer(struct sock *sk, int bpf_op);
__poll_t tcp_poll(struct file *file, struct socket *sock,
        struct poll_table_struct *wait);
int tcp_getsockopt(struct sock *sk, int level, int optname,
     char *optval, int *optlen);
int tcp_setsockopt(struct sock *sk, int level, int optname,
     char *optval, unsigned int optlen);
int compat_tcp_getsockopt(struct sock *sk, int level, int optname,
     char *optval, int *optlen);
int compat_tcp_setsockopt(struct sock *sk, int level, int optname,
     char *optval, unsigned int optlen);
void tcp_set_keepalive(struct sock *sk, int val);
void tcp_syn_ack_timeout(const struct request_sock *req);
int tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
  int flags, int *addr_len);
int tcp_set_rcvlowat(struct sock *sk, int val);
void tcp_data_ready(struct sock *sk);

int tcp_mmap(struct file *file, struct socket *sock,
      struct vm_area_struct *vma);

void tcp_parse_options(const struct net *net, const struct sk_buff *skb,
         struct tcp_options_received *opt_rx,
         int estab, struct tcp_fastopen_cookie *foc);
const u8 *tcp_parse_md5sig_option(const struct tcphdr *th);




u16 tcp_v4_get_syncookie(struct sock *sk, struct iphdr *iph,
    struct tcphdr *th, u32 *cookie);
u16 tcp_v6_get_syncookie(struct sock *sk, struct ipv6hdr *iph,
    struct tcphdr *th, u32 *cookie);
u16 tcp_get_syncookie_mss(struct request_sock_ops *rsk_ops,
     const struct tcp_request_sock_ops *af_ops,
     struct sock *sk, struct tcphdr *th);




void tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);
void tcp_v4_mtu_reduced(struct sock *sk);
void tcp_req_err(struct sock *sk, u32 seq, bool abort);
int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
struct sock *tcp_create_openreq_child(const struct sock *sk,
          struct request_sock *req,
          struct sk_buff *skb);
void tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst);
struct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,
      struct request_sock *req,
      struct dst_entry *dst,
      struct request_sock *req_unhash,
      bool *own_req);
int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
int tcp_connect(struct sock *sk);
enum tcp_synack_type {
 TCP_SYNACK_NORMAL,
 TCP_SYNACK_FASTOPEN,
 TCP_SYNACK_COOKIE,
};
struct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,
    struct request_sock *req,
    struct tcp_fastopen_cookie *foc,
    enum tcp_synack_type synack_type);
int tcp_disconnect(struct sock *sk, int flags);

void tcp_finish_connect(struct sock *sk, struct sk_buff *skb);
int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);
void inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);


struct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,
     struct request_sock *req,
     struct dst_entry *dst, u32 tsoff);
int __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,
        u32 cookie);
struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb);
# 491 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_synq_overflow(const struct sock *sk)
{
 unsigned int last_overflow;
 unsigned int now = jiffies;

 if (sk->__sk_common.skc_reuseport) {
  struct sock_reuseport *reuse;

  reuse = ({ typeof(*(sk->sk_reuseport_cb)) *________p1 = (typeof(*(sk->sk_reuseport_cb)) *)({ union { typeof((sk->sk_reuseport_cb)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); else __read_once_size_nocheck(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_reuseport_cb)) *)(________p1)); });
  if (__builtin_expect(!!(reuse), 1)) {
   last_overflow = ({ union { typeof(reuse->synq_overflow_ts) __val; char __c[1]; } __u; if (1) __read_once_size(&(reuse->synq_overflow_ts), __u.__c, sizeof(reuse->synq_overflow_ts)); else __read_once_size_nocheck(&(reuse->synq_overflow_ts), __u.__c, sizeof(reuse->synq_overflow_ts)); do { } while (0); __u.__val; });
   if (!((u32)(last_overflow + 100) - (u32)(last_overflow) >= (u32)(now) - (u32)(last_overflow)))

    ({ union { typeof(reuse->synq_overflow_ts) __val; char __c[1]; } __u = { .__val = ( typeof(reuse->synq_overflow_ts)) (now) }; __write_once_size(&(reuse->synq_overflow_ts), __u.__c, sizeof(reuse->synq_overflow_ts)); __u.__val; });
   return;
  }
 }

 last_overflow = ({ union { typeof(tcp_sk(sk)->rx_opt.ts_recent_stamp) __val; char __c[1]; } __u; if (1) __read_once_size(&(tcp_sk(sk)->rx_opt.ts_recent_stamp), __u.__c, sizeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)); else __read_once_size_nocheck(&(tcp_sk(sk)->rx_opt.ts_recent_stamp), __u.__c, sizeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)); do { } while (0); __u.__val; });
 if (!((u32)(last_overflow + 100) - (u32)(last_overflow) >= (u32)(now) - (u32)(last_overflow)))
  ({ union { typeof(tcp_sk(sk)->rx_opt.ts_recent_stamp) __val; char __c[1]; } __u = { .__val = ( typeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)) (now) }; __write_once_size(&(tcp_sk(sk)->rx_opt.ts_recent_stamp), __u.__c, sizeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)); __u.__val; });
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_synq_no_recent_overflow(const struct sock *sk)
{
 unsigned int last_overflow;
 unsigned int now = jiffies;

 if (sk->__sk_common.skc_reuseport) {
  struct sock_reuseport *reuse;

  reuse = ({ typeof(*(sk->sk_reuseport_cb)) *________p1 = (typeof(*(sk->sk_reuseport_cb)) *)({ union { typeof((sk->sk_reuseport_cb)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); else __read_once_size_nocheck(&((sk->sk_reuseport_cb)), __u.__c, sizeof((sk->sk_reuseport_cb))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sk->sk_reuseport_cb)) *)(________p1)); });
  if (__builtin_expect(!!(reuse), 1)) {
   last_overflow = ({ union { typeof(reuse->synq_overflow_ts) __val; char __c[1]; } __u; if (1) __read_once_size(&(reuse->synq_overflow_ts), __u.__c, sizeof(reuse->synq_overflow_ts)); else __read_once_size_nocheck(&(reuse->synq_overflow_ts), __u.__c, sizeof(reuse->synq_overflow_ts)); do { } while (0); __u.__val; });
   return !((u32)(last_overflow + (2 * (60 * 100))) - (u32)(last_overflow - 100) >= (u32)(now) - (u32)(last_overflow - 100));


  }
 }

 last_overflow = ({ union { typeof(tcp_sk(sk)->rx_opt.ts_recent_stamp) __val; char __c[1]; } __u; if (1) __read_once_size(&(tcp_sk(sk)->rx_opt.ts_recent_stamp), __u.__c, sizeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)); else __read_once_size_nocheck(&(tcp_sk(sk)->rx_opt.ts_recent_stamp), __u.__c, sizeof(tcp_sk(sk)->rx_opt.ts_recent_stamp)); do { } while (0); __u.__val; });
# 541 "/home/nathan/src/linux-next/include/net/tcp.h"
 return !((u32)(last_overflow + (2 * (60 * 100))) - (u32)(last_overflow - 100) >= (u32)(now) - (u32)(last_overflow - 100));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_cookie_time(void)
{
 u64 val = get_jiffies_64();

 ({ uint32_t __base = ((60 * 100)); uint32_t __rem; __rem = ((uint64_t)(val)) % __base; (val) = ((uint64_t)(val)) / __base; __rem; });
 return val;
}

u32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,
         u16 *mssp);
__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mss);
u64 cookie_init_timestamp(struct request_sock *req, u64 now);
bool cookie_timestamp_decode(const struct net *net,
        struct tcp_options_received *opt);
bool cookie_ecn_ok(const struct tcp_options_received *opt,
     const struct net *net, const struct dst_entry *dst);


int __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,
        u32 cookie);
struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);

u32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,
         const struct tcphdr *th, u16 *mssp);
__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mss);



void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
          int nonagle);
int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);
int tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);
void tcp_retransmit_timer(struct sock *sk);
void tcp_xmit_retransmit_queue(struct sock *);
void tcp_simple_retransmit(struct sock *);
void tcp_enter_recovery(struct sock *sk, bool ece_ack);
int tcp_trim_head(struct sock *, struct sk_buff *, u32);
enum tcp_queue {
 TCP_FRAG_IN_WRITE_QUEUE,
 TCP_FRAG_IN_RTX_QUEUE,
};
int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,
   struct sk_buff *skb, u32 len,
   unsigned int mss_now, gfp_t gfp);

void tcp_send_probe0(struct sock *);
void tcp_send_partial(struct sock *);
int tcp_write_wakeup(struct sock *, int mib);
void tcp_send_fin(struct sock *sk);
void tcp_send_active_reset(struct sock *sk, gfp_t priority);
int tcp_send_synack(struct sock *);
void tcp_push_one(struct sock *, unsigned int mss_now);
void __tcp_send_ack(struct sock *sk, u32 rcv_nxt);
void tcp_send_ack(struct sock *sk);
void tcp_send_delayed_ack(struct sock *sk);
void tcp_send_loss_probe(struct sock *sk);
bool tcp_schedule_loss_probe(struct sock *sk, bool advancing_rto);
void tcp_skb_collapse_tstamp(struct sk_buff *skb,
        const struct sk_buff *next_skb);


void tcp_rearm_rto(struct sock *sk);
void tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req);
void tcp_reset(struct sock *sk);
void tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb);
void tcp_fin(struct sock *sk);


void tcp_init_xmit_timers(struct sock *);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_clear_xmit_timers(struct sock *sk)
{
 if (hrtimer_try_to_cancel(&tcp_sk(sk)->pacing_timer) == 1)
  __sock_put(sk);

 if (hrtimer_try_to_cancel(&tcp_sk(sk)->compressed_ack_timer) == 1)
  __sock_put(sk);

 inet_csk_clear_xmit_timers(sk);
}

unsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);
unsigned int tcp_current_mss(struct sock *sk);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)
{
 int cutoff;
# 640 "/home/nathan/src/linux-next/include/net/tcp.h"
 if (tp->max_window > 536U)
  cutoff = (tp->max_window >> 1);
 else
  cutoff = tp->max_window;

 if (cutoff && pktsize > cutoff)
  return __builtin_choose_expr(((!!(sizeof((typeof((int)(cutoff)) *)1 == (typeof((int)(68U - tp->tcp_header_len)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(cutoff)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((int)(68U - tp->tcp_header_len)) * 0l)) : (int *)8))))), (((int)(cutoff)) > ((int)(68U - tp->tcp_header_len)) ? ((int)(cutoff)) : ((int)(68U - tp->tcp_header_len))), ({ typeof((int)(cutoff)) __UNIQUE_ID___x90 = ((int)(cutoff)); typeof((int)(68U - tp->tcp_header_len)) __UNIQUE_ID___y91 = ((int)(68U - tp->tcp_header_len)); ((__UNIQUE_ID___x90) > (__UNIQUE_ID___y91) ? (__UNIQUE_ID___x90) : (__UNIQUE_ID___y91)); }));
 else
  return pktsize;
}


void tcp_get_info(struct sock *, struct tcp_info *);


int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
    sk_read_actor_t recv_actor);

void tcp_initialize_rcv_mss(struct sock *sk);

int tcp_mtu_to_mss(struct sock *sk, int pmtu);
int tcp_mss_to_mtu(struct sock *sk, int mss);
void tcp_mtup_init(struct sock *sk);
void tcp_init_buffer_space(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_bound_rto(const struct sock *sk)
{
 if (inet_csk(sk)->icsk_rto > ((unsigned)(120*100)))
  inet_csk(sk)->icsk_rto = ((unsigned)(120*100));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 __tcp_set_rto(const struct tcp_sock *tp)
{
 return usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)
{
 tp->pred_flags = (( __be32)(__u32)((tp->tcp_header_len << 26) | (( __u32)(__be32)(TCP_FLAG_ACK)) | snd_wnd));


}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_fast_path_on(struct tcp_sock *tp)
{
 __tcp_fast_path_on(tp, tp->snd_wnd >> tp->rx_opt.snd_wscale);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_fast_path_check(struct sock *sk)
{
 struct tcp_sock *tp = tcp_sk(sk);

 if ((({ union { typeof((&tp->out_of_order_queue)->rb_node) __val; char __c[1]; } __u; if (1) __read_once_size(&((&tp->out_of_order_queue)->rb_node), __u.__c, sizeof((&tp->out_of_order_queue)->rb_node)); else __read_once_size_nocheck(&((&tp->out_of_order_queue)->rb_node), __u.__c, sizeof((&tp->out_of_order_queue)->rb_node)); do { } while (0); __u.__val; }) == ((void *)0)) &&
     tp->rcv_wnd &&
     atomic_read(&sk->sk_backlog.rmem_alloc) < sk->sk_rcvbuf &&
     !tp->urg_data)
  tcp_fast_path_on(tp);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_rto_min(struct sock *sk)
{
 const struct dst_entry *dst = __sk_dst_get(sk);
 u32 rto_min = ((unsigned)(100/5));

 if (dst && dst_metric_locked(dst, RTAX_RTO_MIN))
  rto_min = dst_metric_rtt(dst, RTAX_RTO_MIN);
 return rto_min;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_rto_min_us(struct sock *sk)
{
 return jiffies_to_usecs(tcp_rto_min(sk));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_ca_dst_locked(const struct dst_entry *dst)
{
 return dst_metric_locked(dst, RTAX_CC_ALGO);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_min_rtt(const struct tcp_sock *tp)
{
 return minmax_get(&tp->rtt_min);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_receive_window(const struct tcp_sock *tp)
{
 s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;

 if (win < 0)
  win = 0;
 return (u32) win;
}





u32 __tcp_select_window(struct sock *sk);

void tcp_send_window_probe(struct sock *sk);
# 760 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 tcp_clock_ns(void)
{
 return ktime_get_ns();
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 tcp_clock_us(void)
{
 return div_u64(tcp_clock_ns(), 1000L);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_time_stamp(const struct tcp_sock *tp)
{
 return div_u64(tp->tcp_mstamp, 1000000L / 1000);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_ns_to_ts(u64 ns)
{
 return div_u64(ns, 1000000000L / 1000);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_time_stamp_raw(void)
{
 return tcp_ns_to_ts(tcp_clock_ns());
}

void tcp_mstamp_refresh(struct tcp_sock *tp);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_stamp_us_delta(u64 t1, u64 t0)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((s64)(t1 - t0)) *)1 == (typeof((s64)(0)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((s64)(t1 - t0)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((s64)(0)) * 0l)) : (int *)8))))), (((s64)(t1 - t0)) > ((s64)(0)) ? ((s64)(t1 - t0)) : ((s64)(0))), ({ typeof((s64)(t1 - t0)) __UNIQUE_ID___x92 = ((s64)(t1 - t0)); typeof((s64)(0)) __UNIQUE_ID___y93 = ((s64)(0)); ((__UNIQUE_ID___x92) > (__UNIQUE_ID___y93) ? (__UNIQUE_ID___x92) : (__UNIQUE_ID___y93)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_skb_timestamp(const struct sk_buff *skb)
{
 return tcp_ns_to_ts(skb->skb_mstamp_ns);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 tcp_skb_timestamp_us(const struct sk_buff *skb)
{
 return div_u64(skb->skb_mstamp_ns, 1000L);
}
# 826 "/home/nathan/src/linux-next/include/net/tcp.h"
struct tcp_skb_cb {
 __u32 seq;
 __u32 end_seq;
 union {






  __u32 tcp_tw_isn;
  struct {
   u16 tcp_gso_segs;
   u16 tcp_gso_size;
  };
 };
 __u8 tcp_flags;

 __u8 sacked;
# 854 "/home/nathan/src/linux-next/include/net/tcp.h"
 __u8 ip_dsfield;
 __u8 txstamp_ack:1,
   eor:1,
   has_rxtstamp:1,
   unused:5;
 __u32 ack_seq;
 union {
  struct {

   __u32 in_flight:30,
         is_app_limited:1,
         unused:1;

   __u32 delivered;

   u64 first_tx_mstamp;

   u64 delivered_mstamp;
  } tx;
  union {
   struct inet_skb_parm h4;

   struct inet6_skb_parm h6;

  } header;
  struct {
   __u32 flags;
   struct sock *sk_redir;
   void *data_end;
  } bpf;
 };
};



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void bpf_compute_data_end_sk_skb(struct sk_buff *skb)
{
 ((struct tcp_skb_cb *)&((skb)->cb[0]))->bpf.data_end = skb->data + skb_headlen(skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_skb_bpf_ingress(const struct sk_buff *skb)
{
 return ((struct tcp_skb_cb *)&((skb)->cb[0]))->bpf.flags & (1ULL << 0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sock *tcp_skb_bpf_redirect_fetch(struct sk_buff *skb)
{
 return ((struct tcp_skb_cb *)&((skb)->cb[0]))->bpf.sk_redir;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_skb_bpf_redirect_clear(struct sk_buff *skb)
{
 ((struct tcp_skb_cb *)&((skb)->cb[0]))->bpf.sk_redir = ((void *)0);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_v6_iif(const struct sk_buff *skb)
{
 return ((struct tcp_skb_cb *)&((skb)->cb[0]))->header.h6.iif;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_v6_iif_l3_slave(const struct sk_buff *skb)
{
 bool l3_slave = ipv6_l3mdev_skb(((struct tcp_skb_cb *)&((skb)->cb[0]))->header.h6.flags);

 return l3_slave ? skb->skb_iif : ((struct tcp_skb_cb *)&((skb)->cb[0]))->header.h6.iif;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_v6_sdif(const struct sk_buff *skb)
{




 return 0;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_exact_dif_match(struct net *net, struct sk_buff *skb)
{





 return false;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_v4_sdif(struct sk_buff *skb)
{




 return 0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_skb_pcount(const struct sk_buff *skb)
{
 return ((struct tcp_skb_cb *)&((skb)->cb[0]))->tcp_gso_segs;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_skb_pcount_set(struct sk_buff *skb, int segs)
{
 ((struct tcp_skb_cb *)&((skb)->cb[0]))->tcp_gso_segs = segs;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_skb_pcount_add(struct sk_buff *skb, int segs)
{
 ((struct tcp_skb_cb *)&((skb)->cb[0]))->tcp_gso_segs += segs;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_skb_mss(const struct sk_buff *skb)
{
 return ((struct tcp_skb_cb *)&((skb)->cb[0]))->tcp_gso_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_skb_can_collapse_to(const struct sk_buff *skb)
{
 return __builtin_expect(!!(!((struct tcp_skb_cb *)&((skb)->cb[0]))->eor), 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_skb_can_collapse(const struct sk_buff *to,
     const struct sk_buff *from)
{
 return __builtin_expect(!!(tcp_skb_can_collapse_to(to) && mptcp_skb_can_collapse(to, from)), 1);

}


enum tcp_ca_event {
 CA_EVENT_TX_START,
 CA_EVENT_CWND_RESTART,
 CA_EVENT_COMPLETE_CWR,
 CA_EVENT_LOSS,
 CA_EVENT_ECN_NO_CE,
 CA_EVENT_ECN_IS_CE,
};


enum tcp_ca_ack_event_flags {
 CA_ACK_SLOWPATH = (1 << 0),
 CA_ACK_WIN_UPDATE = (1 << 1),
 CA_ACK_ECE = (1 << 2),
};
# 1024 "/home/nathan/src/linux-next/include/net/tcp.h"
union tcp_cc_info;

struct ack_sample {
 u32 pkts_acked;
 s32 rtt_us;
 u32 in_flight;
};
# 1040 "/home/nathan/src/linux-next/include/net/tcp.h"
struct rate_sample {
 u64 prior_mstamp;
 u32 prior_delivered;
 s32 delivered;
 long interval_us;
 u32 snd_interval_us;
 u32 rcv_interval_us;
 long rtt_us;
 int losses;
 u32 acked_sacked;
 u32 prior_in_flight;
 bool is_app_limited;
 bool is_retrans;
 bool is_ack_delayed;
};

struct tcp_congestion_ops {
 struct list_head list;
 u32 key;
 u32 flags;


 void (*init)(struct sock *sk);

 void (*release)(struct sock *sk);


 u32 (*ssthresh)(struct sock *sk);

 void (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);

 void (*set_state)(struct sock *sk, u8 new_state);

 void (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);

 void (*in_ack_event)(struct sock *sk, u32 flags);

 u32 (*undo_cwnd)(struct sock *sk);

 void (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);

 u32 (*min_tso_segs)(struct sock *sk);

 u32 (*sndbuf_expand)(struct sock *sk);



 void (*cong_control)(struct sock *sk, const struct rate_sample *rs);

 size_t (*get_info)(struct sock *sk, u32 ext, int *attr,
      union tcp_cc_info *info);

 char name[16];
 struct module *owner;
};

int tcp_register_congestion_control(struct tcp_congestion_ops *type);
void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);

void tcp_assign_congestion_control(struct sock *sk);
void tcp_init_congestion_control(struct sock *sk);
void tcp_cleanup_congestion_control(struct sock *sk);
int tcp_set_default_congestion_control(struct net *net, const char *name);
void tcp_get_default_congestion_control(struct net *net, char *name);
void tcp_get_available_congestion_control(char *buf, size_t len);
void tcp_get_allowed_congestion_control(char *buf, size_t len);
int tcp_set_allowed_congestion_control(char *allowed);
int tcp_set_congestion_control(struct sock *sk, const char *name, bool load,
          bool reinit, bool cap_net_admin);
u32 tcp_slow_start(struct tcp_sock *tp, u32 acked);
void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked);

u32 tcp_reno_ssthresh(struct sock *sk);
u32 tcp_reno_undo_cwnd(struct sock *sk);
void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);
extern struct tcp_congestion_ops tcp_reno;

struct tcp_congestion_ops *tcp_ca_find(const char *name);
struct tcp_congestion_ops *tcp_ca_find_key(u32 key);
u32 tcp_ca_get_key_by_name(struct net *net, const char *name, bool *ecn_ca);

char *tcp_ca_get_name_by_key(u32 key, char *buffer);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_ca_needs_ecn(const struct sock *sk)
{
 const struct inet_connection_sock *icsk = inet_csk(sk);

 return icsk->icsk_ca_ops->flags & 0x2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_set_ca_state(struct sock *sk, const u8 ca_state)
{
 struct inet_connection_sock *icsk = inet_csk(sk);

 if (icsk->icsk_ca_ops->set_state)
  icsk->icsk_ca_ops->set_state(sk, ca_state);
 icsk->icsk_ca_state = ca_state;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_ca_event(struct sock *sk, const enum tcp_ca_event event)
{
 const struct inet_connection_sock *icsk = inet_csk(sk);

 if (icsk->icsk_ca_ops->cwnd_event)
  icsk->icsk_ca_ops->cwnd_event(sk, event);
}


void tcp_rate_skb_sent(struct sock *sk, struct sk_buff *skb);
void tcp_rate_skb_delivered(struct sock *sk, struct sk_buff *skb,
       struct rate_sample *rs);
void tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,
    bool is_sack_reneg, struct rate_sample *rs);
void tcp_rate_check_app_limited(struct sock *sk);
# 1168 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_is_sack(const struct tcp_sock *tp)
{
 return __builtin_expect(!!(tp->rx_opt.sack_ok), 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_is_reno(const struct tcp_sock *tp)
{
 return !tcp_is_sack(tp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int tcp_left_out(const struct tcp_sock *tp)
{
 return tp->sacked_out + tp->lost_out;
}
# 1197 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)
{
 return tp->packets_out - tcp_left_out(tp) + tp->retrans_out;
}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_in_slow_start(const struct tcp_sock *tp)
{
 return tp->snd_cwnd < tp->snd_ssthresh;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_in_initial_slowstart(const struct tcp_sock *tp)
{
 return tp->snd_ssthresh >= 0x7fffffff;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_in_cwnd_reduction(const struct sock *sk)
{
 return ((1<<TCP_CA_CWR) | (1<<TCP_CA_Recovery)) &
        (1 << inet_csk(sk)->icsk_ca_state);
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 tcp_current_ssthresh(const struct sock *sk)
{
 const struct tcp_sock *tp = tcp_sk(sk);

 if (tcp_in_cwnd_reduction(sk))
  return tp->snd_ssthresh;
 else
  return __builtin_choose_expr(((!!(sizeof((typeof(tp->snd_ssthresh) *)1 == (typeof(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(tp->snd_ssthresh) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) * 0l)) : (int *)8))))), ((tp->snd_ssthresh) > (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) ? (tp->snd_ssthresh) : (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2)))), ({ typeof(tp->snd_ssthresh) __UNIQUE_ID___x94 = (tp->snd_ssthresh); typeof(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) __UNIQUE_ID___y95 = (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))); ((__UNIQUE_ID___x94) > (__UNIQUE_ID___y95) ? (__UNIQUE_ID___x94) : (__UNIQUE_ID___y95)); }));


}




void tcp_enter_cwr(struct sock *sk);
__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 tcp_max_tso_deferred_mss(const struct tcp_sock *tp)
{
 return 3;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_wnd_end(const struct tcp_sock *tp)
{
 return tp->snd_una + tp->snd_wnd;
}
# 1269 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_is_cwnd_limited(const struct sock *sk)
{
 const struct tcp_sock *tp = tcp_sk(sk);


 if (tcp_in_slow_start(tp))
  return tp->snd_cwnd < 2 * tp->max_packets_out;

 return tp->is_cwnd_limited;
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_needs_internal_pacing(const struct sock *sk)
{
 return ({ typeof(*&sk->sk_pacing_status) ___p1 = ({ union { typeof(*&sk->sk_pacing_status) __val; char __c[1]; } __u; if (1) __read_once_size(&(*&sk->sk_pacing_status), __u.__c, sizeof(*&sk->sk_pacing_status)); else __read_once_size_nocheck(&(*&sk->sk_pacing_status), __u.__c, sizeof(*&sk->sk_pacing_status)); do { } while (0); __u.__val; }); do { extern void __compiletime_assert_1288(void) ; if (!((sizeof(*&sk->sk_pacing_status) == sizeof(char) || sizeof(*&sk->sk_pacing_status) == sizeof(short) || sizeof(*&sk->sk_pacing_status) == sizeof(int) || sizeof(*&sk->sk_pacing_status) == sizeof(long)))) __compiletime_assert_1288(); } while (0); __asm__ __volatile__ ("lwsync" " " : : :"memory"); ___p1; }) == SK_PACING_NEEDED;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long tcp_pacing_delay(const struct sock *sk,
          const struct sk_buff *skb)
{
 s64 pacing_delay = skb ? skb->tstamp : tcp_sk(sk)->tcp_wstamp_ns;

 pacing_delay -= tcp_sk(sk)->tcp_clock_cache;

 return pacing_delay > 0 ? nsecs_to_jiffies(pacing_delay) : 0;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_reset_xmit_timer(struct sock *sk,
     const int what,
     unsigned long when,
     const unsigned long max_when,
     const struct sk_buff *skb)
{
 inet_csk_reset_xmit_timer(sk, what, when + tcp_pacing_delay(sk, skb),
      max_when);
}







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long tcp_probe0_base(const struct sock *sk)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((unsigned long)(inet_csk(sk)->icsk_rto)) *)1 == (typeof((unsigned long)(((unsigned)(100/5)))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned long)(inet_csk(sk)->icsk_rto)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((unsigned long)(((unsigned)(100/5)))) * 0l)) : (int *)8))))), (((unsigned long)(inet_csk(sk)->icsk_rto)) > ((unsigned long)(((unsigned)(100/5)))) ? ((unsigned long)(inet_csk(sk)->icsk_rto)) : ((unsigned long)(((unsigned)(100/5))))), ({ typeof((unsigned long)(inet_csk(sk)->icsk_rto)) __UNIQUE_ID___x96 = ((unsigned long)(inet_csk(sk)->icsk_rto)); typeof((unsigned long)(((unsigned)(100/5)))) __UNIQUE_ID___y97 = ((unsigned long)(((unsigned)(100/5)))); ((__UNIQUE_ID___x96) > (__UNIQUE_ID___y97) ? (__UNIQUE_ID___x96) : (__UNIQUE_ID___y97)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) unsigned long tcp_probe0_when(const struct sock *sk,
         unsigned long max_when)
{
 u64 when = (u64)tcp_probe0_base(sk) << inet_csk(sk)->icsk_backoff;

 return (unsigned long)__builtin_choose_expr(((!!(sizeof((typeof((u64)(when)) *)1 == (typeof((u64)(max_when)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(when)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u64)(max_when)) * 0l)) : (int *)8))))), (((u64)(when)) < ((u64)(max_when)) ? ((u64)(when)) : ((u64)(max_when))), ({ typeof((u64)(when)) __UNIQUE_ID___x98 = ((u64)(when)); typeof((u64)(max_when)) __UNIQUE_ID___y99 = ((u64)(max_when)); ((__UNIQUE_ID___x98) < (__UNIQUE_ID___y99) ? (__UNIQUE_ID___x98) : (__UNIQUE_ID___y99)); }));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_check_probe_timer(struct sock *sk)
{
 if (!tcp_sk(sk)->packets_out && !inet_csk(sk)->icsk_pending)
  tcp_reset_xmit_timer(sk, 3,
         tcp_probe0_base(sk), ((unsigned)(120*100)),
         ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_init_wl(struct tcp_sock *tp, u32 seq)
{
 tp->snd_wl1 = seq;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_update_wl(struct tcp_sock *tp, u32 seq)
{
 tp->snd_wl1 = seq;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __sum16 tcp_v4_check(int len, __be32 saddr,
       __be32 daddr, __wsum base)
{
 return csum_tcpudp_magic(saddr, daddr, len, IPPROTO_TCP, base);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_checksum_complete(struct sk_buff *skb)
{
 return !skb_csum_unnecessary(skb) &&
  __skb_checksum_complete(skb);
}

bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
int tcp_filter(struct sock *sk, struct sk_buff *skb);
void tcp_set_state(struct sock *sk, int state);
void tcp_done(struct sock *sk);
int tcp_abort(struct sock *sk, int err);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_sack_reset(struct tcp_options_received *rx_opt)
{
 rx_opt->dsack = 0;
 rx_opt->num_sacks = 0;
}

u32 tcp_default_init_rwnd(u32 mss);
void tcp_cwnd_restart(struct sock *sk, s32 delta);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_slow_start_after_idle_check(struct sock *sk)
{
 const struct tcp_congestion_ops *ca_ops = inet_csk(sk)->icsk_ca_ops;
 struct tcp_sock *tp = tcp_sk(sk);
 s32 delta;

 if (!sock_net(sk)->ipv4.sysctl_tcp_slow_start_after_idle || tp->packets_out ||
     ca_ops->cong_control)
  return;
 delta = ((u32)jiffies) - tp->lsndtime;
 if (delta > inet_csk(sk)->icsk_rto)
  tcp_cwnd_restart(sk, delta);
}


void tcp_select_initial_window(const struct sock *sk, int __space,
          __u32 mss, __u32 *rcv_wnd,
          __u32 *window_clamp, int wscale_ok,
          __u8 *rcv_wscale, __u32 init_rcv_wnd);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_win_from_space(const struct sock *sk, int space)
{
 int tcp_adv_win_scale = sock_net(sk)->ipv4.sysctl_tcp_adv_win_scale;

 return tcp_adv_win_scale <= 0 ?
  (space>>(-tcp_adv_win_scale)) :
  space - (space>>tcp_adv_win_scale);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_space(const struct sock *sk)
{
 return tcp_win_from_space(sk, ({ union { typeof(sk->sk_rcvbuf) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvbuf), __u.__c, sizeof(sk->sk_rcvbuf)); else __read_once_size_nocheck(&(sk->sk_rcvbuf), __u.__c, sizeof(sk->sk_rcvbuf)); do { } while (0); __u.__val; }) -
      ({ union { typeof(sk->sk_backlog.len) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_backlog.len), __u.__c, sizeof(sk->sk_backlog.len)); else __read_once_size_nocheck(&(sk->sk_backlog.len), __u.__c, sizeof(sk->sk_backlog.len)); do { } while (0); __u.__val; }) -
      atomic_read(&sk->sk_backlog.rmem_alloc));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_full_space(const struct sock *sk)
{
 return tcp_win_from_space(sk, ({ union { typeof(sk->sk_rcvbuf) __val; char __c[1]; } __u; if (1) __read_once_size(&(sk->sk_rcvbuf), __u.__c, sizeof(sk->sk_rcvbuf)); else __read_once_size_nocheck(&(sk->sk_rcvbuf), __u.__c, sizeof(sk->sk_rcvbuf)); do { } while (0); __u.__val; }));
}

extern void tcp_openreq_init_rwin(struct request_sock *req,
      const struct sock *sk_listener,
      const struct dst_entry *dst);

void tcp_enter_memory_pressure(struct sock *sk);
void tcp_leave_memory_pressure(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int keepalive_intvl_when(const struct tcp_sock *tp)
{
 struct net *net = sock_net((struct sock *)tp);

 return tp->keepalive_intvl ? : net->ipv4.sysctl_tcp_keepalive_intvl;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int keepalive_time_when(const struct tcp_sock *tp)
{
 struct net *net = sock_net((struct sock *)tp);

 return tp->keepalive_time ? : net->ipv4.sysctl_tcp_keepalive_time;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int keepalive_probes(const struct tcp_sock *tp)
{
 struct net *net = sock_net((struct sock *)tp);

 return tp->keepalive_probes ? : net->ipv4.sysctl_tcp_keepalive_probes;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 keepalive_time_elapsed(const struct tcp_sock *tp)
{
 const struct inet_connection_sock *icsk = &tp->inet_conn;

 return __builtin_choose_expr(((!!(sizeof((typeof((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)) *)1 == (typeof((u32)(((u32)jiffies) - tp->rcv_tstamp)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(((u32)jiffies) - tp->rcv_tstamp)) * 0l)) : (int *)8))))), (((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)) < ((u32)(((u32)jiffies) - tp->rcv_tstamp)) ? ((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)) : ((u32)(((u32)jiffies) - tp->rcv_tstamp))), ({ typeof((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)) __UNIQUE_ID___x100 = ((u32)(((u32)jiffies) - icsk->icsk_ack.lrcvtime)); typeof((u32)(((u32)jiffies) - tp->rcv_tstamp)) __UNIQUE_ID___y101 = ((u32)(((u32)jiffies) - tp->rcv_tstamp)); ((__UNIQUE_ID___x100) < (__UNIQUE_ID___y101) ? (__UNIQUE_ID___x100) : (__UNIQUE_ID___y101)); }));

}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_fin_time(const struct sock *sk)
{
 int fin_timeout = tcp_sk(sk)->linger2 ? : sock_net(sk)->ipv4.sysctl_tcp_fin_timeout;
 const int rto = inet_csk(sk)->icsk_rto;

 if (fin_timeout < (rto << 2) - (rto >> 1))
  fin_timeout = (rto << 2) - (rto >> 1);

 return fin_timeout;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_paws_check(const struct tcp_options_received *rx_opt,
      int paws_win)
{
 if ((s32)(rx_opt->ts_recent - rx_opt->rcv_tsval) <= paws_win)
  return true;
 if (__builtin_expect(!!(!((s32)((u32)(ktime_get_seconds()) - (u32)(rx_opt->ts_recent_stamp + (60 * 60 * 24 * 24))) < 0)), 0))

  return true;





 if (!rx_opt->ts_recent)
  return true;
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_paws_reject(const struct tcp_options_received *rx_opt,
       int rst)
{
 if (tcp_paws_check(rx_opt, 0))
  return false;
# 1507 "/home/nathan/src/linux-next/include/net/tcp.h"
 if (rst && !((s32)((u32)(ktime_get_seconds()) - (u32)(rx_opt->ts_recent_stamp + 60)) < 0))

  return false;
 return true;
}

bool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,
     int mib_idx, u32 *last_oow_ack_time);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_mib_init(struct net *net)
{

 do { do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOALGORITHM])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 do { do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(100/5))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(100/5))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(100/5))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMIN])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(100/5))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 do { do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(120*100))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(120*100))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(120*100))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_RTOMAX])))) (__ptr + ((local_paca->data_offset))); }); }) += ((unsigned)(120*100))*1000/100; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
 do { do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) { case 1: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])))) (__ptr + ((local_paca->data_offset))); }); }) += -1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 2: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])))) (__ptr + ((local_paca->data_offset))); }); }) += -1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 4: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])))) (__ptr + ((local_paca->data_offset))); }); }) += -1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; case 8: do { unsigned long __flags; do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); __flags = arch_local_irq_save(); } while (0); do { *({ do { const void *__vpp_verify = (typeof((&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))); (typeof((typeof(*(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN]))) *)(&((net)->mib.tcp_statistics->mibs[TCP_MIB_MAXCONN])))) (__ptr + ((local_paca->data_offset))); }); }) += -1; } while (0); do { ({ unsigned long __dummy; typeof(__flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); arch_local_irq_restore(__flags); } while (0); } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_clear_retrans_hints_partial(struct tcp_sock *tp)
{
 tp->lost_skb_hint = ((void *)0);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_clear_all_retrans_hints(struct tcp_sock *tp)
{
 tcp_clear_retrans_hints_partial(tp);
 tp->retransmit_skb_hint = ((void *)0);
}

union tcp_md5_addr {
 struct in_addr a4;

 struct in6_addr a6;

};


struct tcp_md5sig_key {
 struct hlist_node node;
 u8 keylen;
 u8 family;
 u8 prefixlen;
 union tcp_md5_addr addr;
 int l3index;
 u8 key[80];
 struct callback_head rcu;
};


struct tcp_md5sig_info {
 struct hlist_head head;
 struct callback_head rcu;
};


struct tcp4_pseudohdr {
 __be32 saddr;
 __be32 daddr;
 __u8 pad;
 __u8 protocol;
 __be16 len;
};

struct tcp6_pseudohdr {
 struct in6_addr saddr;
 struct in6_addr daddr;
 __be32 len;
 __be32 protocol;
};

union tcp_md5sum_block {
 struct tcp4_pseudohdr ip4;

 struct tcp6_pseudohdr ip6;

};


struct tcp_md5sig_pool {
 struct ahash_request *md5_req;
 void *scratch;
};


int tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,
   const struct sock *sk, const struct sk_buff *skb);
int tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,
     int family, u8 prefixlen, int l3index,
     const u8 *newkey, u8 newkeylen, gfp_t gfp);
int tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr,
     int family, u8 prefixlen, int l3index);
struct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,
      const struct sock *addr_sk);
# 1619 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct tcp_md5sig_key *
tcp_md5_do_lookup(const struct sock *sk, int l3index,
    const union tcp_md5_addr *addr, int family)
{
 return ((void *)0);
}



bool tcp_alloc_md5sig_pool(void);

struct tcp_md5sig_pool *tcp_get_md5sig_pool(void);
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_put_md5sig_pool(void)
{
 local_bh_enable();
}

int tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,
     unsigned int header_len);
int tcp_md5_hash_key(struct tcp_md5sig_pool *hp,
       const struct tcp_md5sig_key *key);


void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
       struct tcp_fastopen_cookie *cookie);
void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
       struct tcp_fastopen_cookie *cookie, bool syn_lost,
       u16 try_exp);
struct tcp_fastopen_request {

 struct tcp_fastopen_cookie cookie;
 struct msghdr *data;
 size_t size;
 int copied;
 struct ubuf_info *uarg;
};
void tcp_free_fastopen_req(struct tcp_sock *tp);
void tcp_fastopen_destroy_cipher(struct sock *sk);
void tcp_fastopen_ctx_destroy(struct net *net);
int tcp_fastopen_reset_cipher(struct net *net, struct sock *sk,
         void *primary_key, void *backup_key);
void tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);
struct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,
         struct request_sock *req,
         struct tcp_fastopen_cookie *foc,
         const struct dst_entry *dst);
void tcp_fastopen_init_key_once(struct net *net);
bool tcp_fastopen_cookie_check(struct sock *sk, u16 *mss,
        struct tcp_fastopen_cookie *cookie);
bool tcp_fastopen_defer_connect(struct sock *sk, int *err);






struct tcp_fastopen_context {
 siphash_key_t key[2];
 int num;
 struct callback_head rcu;
};

extern unsigned int sysctl_tcp_fastopen_blackhole_timeout;
void tcp_fastopen_active_disable(struct sock *sk);
bool tcp_fastopen_active_should_disable(struct sock *sk);
void tcp_fastopen_active_disable_ofo_check(struct sock *sk);
void tcp_fastopen_active_detect_blackhole(struct sock *sk, bool expired);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
struct tcp_fastopen_context *tcp_fastopen_get_ctx(const struct sock *sk)
{
 struct tcp_fastopen_context *ctx;

 ctx = ({ typeof(*(inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)) *________p1 = (typeof(*(inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)) *)({ union { typeof((inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)) __val; char __c[1]; } __u; if (1) __read_once_size(&((inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)), __u.__c, sizeof((inet_csk(sk)->icsk_accept_queue.fastopenq.ctx))); else __read_once_size_nocheck(&((inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)), __u.__c, sizeof((inet_csk(sk)->icsk_accept_queue.fastopenq.ctx))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(inet_csk(sk)->icsk_accept_queue.fastopenq.ctx)) *)(________p1)); });
 if (!ctx)
  ctx = ({ typeof(*(sock_net(sk)->ipv4.tcp_fastopen_ctx)) *________p1 = (typeof(*(sock_net(sk)->ipv4.tcp_fastopen_ctx)) *)({ union { typeof((sock_net(sk)->ipv4.tcp_fastopen_ctx)) __val; char __c[1]; } __u; if (1) __read_once_size(&((sock_net(sk)->ipv4.tcp_fastopen_ctx)), __u.__c, sizeof((sock_net(sk)->ipv4.tcp_fastopen_ctx))); else __read_once_size_nocheck(&((sock_net(sk)->ipv4.tcp_fastopen_ctx)), __u.__c, sizeof((sock_net(sk)->ipv4.tcp_fastopen_ctx))); do { } while (0); __u.__val; }); do { } while (0); ; ((typeof(*(sock_net(sk)->ipv4.tcp_fastopen_ctx)) *)(________p1)); });
 return ctx;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
bool tcp_fastopen_cookie_match(const struct tcp_fastopen_cookie *foc,
          const struct tcp_fastopen_cookie *orig)
{
 if (orig->len == 8 &&
     orig->len == foc->len &&
     !memcmp(orig->val, foc->val, foc->len))
  return true;
 return false;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__))
int tcp_fastopen_context_len(const struct tcp_fastopen_context *ctx)
{
 return ctx->num;
}




enum tcp_chrono {
 TCP_CHRONO_UNSPEC,
 TCP_CHRONO_BUSY,
 TCP_CHRONO_RWND_LIMITED,
 TCP_CHRONO_SNDBUF_LIMITED,
 __TCP_CHRONO_MAX,
};

void tcp_chrono_start(struct sock *sk, const enum tcp_chrono type);
void tcp_chrono_stop(struct sock *sk, const enum tcp_chrono type);




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_skb_tsorted_anchor_cleanup(struct sk_buff *skb)
{
 skb->destructor = ((void *)0);
 skb->_skb_refdst = 0UL;
}
# 1747 "/home/nathan/src/linux-next/include/net/tcp.h"
void tcp_write_queue_purge(struct sock *sk);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_rtx_queue_head(const struct sock *sk)
{
 return ({ typeof(rb_first(&sk->tcp_rtx_queue)) ____ptr = (rb_first(&sk->tcp_rtx_queue)); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_1751(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((struct sk_buff *)0)->rbnode)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_1751(); } while (0); ((struct sk_buff *)(__mptr - __builtin_offsetof(struct sk_buff, rbnode))); }) : ((void *)0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_rtx_queue_tail(const struct sock *sk)
{
 return ({ typeof(rb_last(&sk->tcp_rtx_queue)) ____ptr = (rb_last(&sk->tcp_rtx_queue)); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_1756(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((struct sk_buff *)0)->rbnode)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_1756(); } while (0); ((struct sk_buff *)(__mptr - __builtin_offsetof(struct sk_buff, rbnode))); }) : ((void *)0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_write_queue_head(const struct sock *sk)
{
 return skb_peek(&sk->sk_write_queue);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_write_queue_tail(const struct sock *sk)
{
 return skb_peek_tail(&sk->sk_write_queue);
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_send_head(const struct sock *sk)
{
 return skb_peek(&sk->sk_write_queue);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_skb_is_last(const struct sock *sk,
       const struct sk_buff *skb)
{
 return skb_queue_is_last(&sk->sk_write_queue, skb);
}
# 1790 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_write_queue_empty(const struct sock *sk)
{
 const struct tcp_sock *tp = tcp_sk(sk);

 return tp->write_seq == tp->snd_nxt;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_rtx_queue_empty(const struct sock *sk)
{
 return (({ union { typeof((&sk->tcp_rtx_queue)->rb_node) __val; char __c[1]; } __u; if (1) __read_once_size(&((&sk->tcp_rtx_queue)->rb_node), __u.__c, sizeof((&sk->tcp_rtx_queue)->rb_node)); else __read_once_size_nocheck(&((&sk->tcp_rtx_queue)->rb_node), __u.__c, sizeof((&sk->tcp_rtx_queue)->rb_node)); do { } while (0); __u.__val; }) == ((void *)0));
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_rtx_and_write_queues_empty(const struct sock *sk)
{
 return tcp_rtx_queue_empty(sk) && tcp_write_queue_empty(sk);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)
{
 __skb_queue_tail(&sk->sk_write_queue, skb);


 if (sk->sk_write_queue.next == skb)
  tcp_chrono_start(sk, TCP_CHRONO_BUSY);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_insert_write_queue_before(struct sk_buff *new,
        struct sk_buff *skb,
        struct sock *sk)
{
 __skb_queue_before(&sk->sk_write_queue, skb, new);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_unlink_write_queue(struct sk_buff *skb, struct sock *sk)
{
 tcp_skb_tsorted_anchor_cleanup(skb);
 __skb_unlink(skb, &sk->sk_write_queue);
}

void tcp_rbtree_insert(struct rb_root *root, struct sk_buff *skb);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_rtx_queue_unlink(struct sk_buff *skb, struct sock *sk)
{
 tcp_skb_tsorted_anchor_cleanup(skb);
 rb_erase(&skb->rbnode, &sk->tcp_rtx_queue);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_rtx_queue_unlink_and_free(struct sk_buff *skb, struct sock *sk)
{
 list_del(&skb->tcp_tsorted_anchor);
 tcp_rtx_queue_unlink(skb, sk);
 sk_wmem_free_skb(sk, skb);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_push_pending_frames(struct sock *sk)
{
 if (tcp_send_head(sk)) {
  struct tcp_sock *tp = tcp_sk(sk);

  __tcp_push_pending_frames(sk, tcp_current_mss(sk), tp->nonagle);
 }
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_highest_sack_seq(struct tcp_sock *tp)
{
 if (!tp->sacked_out)
  return tp->snd_una;

 if (tp->highest_sack == ((void *)0))
  return tp->snd_nxt;

 return ((struct tcp_skb_cb *)&((tp->highest_sack)->cb[0]))->seq;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)
{
 tcp_sk(sk)->highest_sack = ({ typeof(rb_next(&(skb)->rbnode)) ____ptr = (rb_next(&(skb)->rbnode)); ____ptr ? ({ void *__mptr = (void *)(____ptr); do { extern void __compiletime_assert_1871(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(____ptr)), typeof(((struct sk_buff *)0)->rbnode)) && !__builtin_types_compatible_p(typeof(*(____ptr)), typeof(void))))) __compiletime_assert_1871(); } while (0); ((struct sk_buff *)(__mptr - __builtin_offsetof(struct sk_buff, rbnode))); }) : ((void *)0); });
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct sk_buff *tcp_highest_sack(struct sock *sk)
{
 return tcp_sk(sk)->highest_sack;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_highest_sack_reset(struct sock *sk)
{
 tcp_sk(sk)->highest_sack = tcp_rtx_queue_head(sk);
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_highest_sack_replace(struct sock *sk,
         struct sk_buff *old,
         struct sk_buff *new)
{
 if (old == tcp_highest_sack(sk))
  tcp_sk(sk)->highest_sack = new;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool inet_sk_transparent(const struct sock *sk)
{
 switch (sk->__sk_common.skc_state) {
 case TCP_TIME_WAIT:
  return inet_twsk(sk)->tw_transparent;
 case TCP_NEW_SYN_RECV:
  return inet_rsk(inet_reqsk(sk))->no_srccheck;
 }
 return inet_sk(sk)->transparent;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_stream_is_thin(struct tcp_sock *tp)
{
 return tp->packets_out < 4 && !tcp_in_initial_slowstart(tp);
}


enum tcp_seq_states {
 TCP_SEQ_STATE_LISTENING,
 TCP_SEQ_STATE_ESTABLISHED,
};

void *tcp_seq_start(struct seq_file *seq, loff_t *pos);
void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos);
void tcp_seq_stop(struct seq_file *seq, void *v);

struct tcp_seq_afinfo {
 sa_family_t family;
};

struct tcp_iter_state {
 struct seq_net_private p;
 enum tcp_seq_states state;
 struct sock *syn_wait_sk;
 int bucket, offset, sbucket, num;
 loff_t last_pos;
};

extern struct request_sock_ops tcp_request_sock_ops;
extern struct request_sock_ops tcp6_request_sock_ops;

void tcp_v4_destroy_sock(struct sock *sk);

struct sk_buff *tcp_gso_segment(struct sk_buff *skb,
    netdev_features_t features);
struct sk_buff *tcp_gro_receive(struct list_head *head, struct sk_buff *skb);
int tcp_gro_complete(struct sk_buff *skb);

void __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_notsent_lowat(const struct tcp_sock *tp)
{
 struct net *net = sock_net((struct sock *)tp);
 return tp->notsent_lowat ?: net->ipv4.sysctl_tcp_notsent_lowat;
}





static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_stream_memory_free(const struct sock *sk, int wake)
{
 const struct tcp_sock *tp = tcp_sk(sk);
 u32 notsent_bytes = ({ union { typeof(tp->write_seq) __val; char __c[1]; } __u; if (1) __read_once_size(&(tp->write_seq), __u.__c, sizeof(tp->write_seq)); else __read_once_size_nocheck(&(tp->write_seq), __u.__c, sizeof(tp->write_seq)); do { } while (0); __u.__val; }) -
       ({ union { typeof(tp->snd_nxt) __val; char __c[1]; } __u; if (1) __read_once_size(&(tp->snd_nxt), __u.__c, sizeof(tp->snd_nxt)); else __read_once_size_nocheck(&(tp->snd_nxt), __u.__c, sizeof(tp->snd_nxt)); do { } while (0); __u.__val; });

 return (notsent_bytes << wake) < tcp_notsent_lowat(tp);
}


int tcp4_proc_init(void);
void tcp4_proc_exit(void);


int tcp_rtx_synack(const struct sock *sk, struct request_sock *req);
int tcp_conn_request(struct request_sock_ops *rsk_ops,
       const struct tcp_request_sock_ops *af_ops,
       struct sock *sk, struct sk_buff *skb);


struct tcp_sock_af_ops {
# 1990 "/home/nathan/src/linux-next/include/net/tcp.h"
};

struct tcp_request_sock_ops {
 u16 mss_clamp;
# 2002 "/home/nathan/src/linux-next/include/net/tcp.h"
 void (*init_req)(struct request_sock *req,
    const struct sock *sk_listener,
    struct sk_buff *skb);

 __u32 (*cookie_init_seq)(const struct sk_buff *skb,
     __u16 *mss);

 struct dst_entry *(*route_req)(const struct sock *sk, struct flowi *fl,
           const struct request_sock *req);
 u32 (*init_seq)(const struct sk_buff *skb);
 u32 (*init_ts_off)(const struct net *net, const struct sk_buff *skb);
 int (*send_synack)(const struct sock *sk, struct dst_entry *dst,
      struct flowi *fl, struct request_sock *req,
      struct tcp_fastopen_cookie *foc,
      enum tcp_synack_type synack_type);
};

extern const struct tcp_request_sock_ops tcp_request_sock_ipv4_ops;

extern const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops;



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,
      const struct sock *sk, struct sk_buff *skb,
      __u16 *mss)
{
 tcp_synq_overflow(sk);
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_SYNCOOKIESSENT])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
 return ops->cookie_init_seq(skb, mss);
}
# 2042 "/home/nathan/src/linux-next/include/net/tcp.h"
int tcpv4_offload_init(void);

void tcp_v4_init(void);
void tcp_init(void);


void tcp_mark_skb_lost(struct sock *sk, struct sk_buff *skb);
void tcp_newreno_mark_lost(struct sock *sk, bool snd_una_advanced);
extern s32 tcp_rack_skb_timeout(struct tcp_sock *tp, struct sk_buff *skb,
    u32 reo_wnd);
extern void tcp_rack_mark_lost(struct sock *sk);
extern void tcp_rack_advance(struct tcp_sock *tp, u8 sacked, u32 end_seq,
        u64 xmit_time);
extern void tcp_rack_reo_timeout(struct sock *sk);
extern void tcp_rack_update_reo_wnd(struct sock *sk, struct rate_sample *rs);


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) s64 tcp_rto_delta_us(const struct sock *sk)
{
 const struct sk_buff *skb = tcp_rtx_queue_head(sk);
 u32 rto = inet_csk(sk)->icsk_rto;
 u64 rto_time_stamp_us = tcp_skb_timestamp_us(skb) + jiffies_to_usecs(rto);

 return rto_time_stamp_us - tcp_sk(sk)->tcp_mstamp;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct ip_options_rcu *tcp_v4_save_options(struct net *net,
        struct sk_buff *skb)
{
 const struct ip_options *opt = &((struct tcp_skb_cb *)&((skb)->cb[0]))->header.h4.opt;
 struct ip_options_rcu *dopt = ((void *)0);

 if (opt->optlen) {
  int opt_size = sizeof(*dopt) + opt->optlen;

  dopt = kmalloc(opt_size, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
  if (dopt && __ip_options_echo(net, &dopt->opt, skb, opt)) {
   kfree(dopt);
   dopt = ((void *)0);
  }
 }
 return dopt;
}






static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool skb_is_tcp_pure_ack(const struct sk_buff *skb)
{
 return skb->truesize == 2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void skb_set_tcp_pure_ack(struct sk_buff *skb)
{
 skb->truesize = 2;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_inq(struct sock *sk)
{
 struct tcp_sock *tp = tcp_sk(sk);
 int answ;

 if ((1 << sk->__sk_common.skc_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
  answ = 0;
 } else if (sock_flag(sk, SOCK_URGINLINE) ||
     !tp->urg_data ||
     before(tp->urg_seq, tp->copied_seq) ||
     !before(tp->urg_seq, tp->rcv_nxt)) {

  answ = tp->rcv_nxt - tp->copied_seq;


  if (answ && sock_flag(sk, SOCK_DONE))
   answ--;
 } else {
  answ = tp->urg_seq - tp->copied_seq;
 }

 return answ;
}

int tcp_peek_len(struct socket *sock);

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_segs_in(struct tcp_sock *tp, const struct sk_buff *skb)
{
 u16 segs_in;

 segs_in = __builtin_choose_expr(((!!(sizeof((typeof((u16)(1)) *)1 == (typeof((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(1)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) * 0l)) : (int *)8))))), (((u16)(1)) > ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) ? ((u16)(1)) : ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs))), ({ typeof((u16)(1)) __UNIQUE_ID___x102 = ((u16)(1)); typeof((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)) __UNIQUE_ID___y103 = ((u16)(((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_segs)); ((__UNIQUE_ID___x102) > (__UNIQUE_ID___y103) ? (__UNIQUE_ID___x102) : (__UNIQUE_ID___y103)); }));
 tp->segs_in += segs_in;
 if (skb->len > tcp_hdrlen(skb))
  tp->data_segs_in += segs_in;
}
# 2147 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_listendrop(const struct sock *sk)
{
 atomic_inc(&((struct sock *)sk)->sk_drops);
 ({ __this_cpu_preempt_check("add"); do { do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) { case 1: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 2: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 4: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; case 8: do { *({ do { const void *__vpp_verify = (typeof((&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))); (typeof((typeof(*(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS]))) *)(&((sock_net(sk))->mib.net_statistics->mibs[LINUX_MIB_LISTENDROPS])))) (__ptr + ((local_paca->data_offset))); }); }) += 1; } while (0);break; default: __bad_size_call_parameter();break; } } while (0); });
}

enum hrtimer_restart tcp_pace_kick(struct hrtimer *timer);
# 2163 "/home/nathan/src/linux-next/include/net/tcp.h"
struct tcp_ulp_ops {
 struct list_head list;


 int (*init)(struct sock *sk);

 void (*update)(struct sock *sk, struct proto *p,
         void (*write_space)(struct sock *sk));

 void (*release)(struct sock *sk);

 int (*get_info)(const struct sock *sk, struct sk_buff *skb);
 size_t (*get_info_size)(const struct sock *sk);

 void (*clone)(const struct request_sock *req, struct sock *newsk,
        const gfp_t priority);

 char name[16];
 struct module *owner;
};
int tcp_register_ulp(struct tcp_ulp_ops *type);
void tcp_unregister_ulp(struct tcp_ulp_ops *type);
int tcp_set_ulp(struct sock *sk, const char *name);
void tcp_get_available_ulp(char *buf, size_t len);
void tcp_cleanup_ulp(struct sock *sk);
void tcp_update_ulp(struct sock *sk, struct proto *p,
      void (*write_space)(struct sock *sk));





struct sk_msg;
struct sk_psock;

int tcp_bpf_init(struct sock *sk);
void tcp_bpf_reinit(struct sock *sk);
int tcp_bpf_sendmsg_redir(struct sock *sk, struct sk_msg *msg, u32 bytes,
     int flags);
int tcp_bpf_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
      int nonblock, int flags, int *addr_len);
int __tcp_bpf_recvmsg(struct sock *sk, struct sk_psock *psock,
        struct msghdr *msg, int len, int flags);







static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_call_bpf(struct sock *sk, int op, u32 nargs, u32 *args)
{
 struct bpf_sock_ops_kern sock_ops;
 int ret;

 memset(&sock_ops, 0, __builtin_offsetof(struct bpf_sock_ops_kern, temp));
 if (sk_fullsock(sk)) {
  sock_ops.is_fullsock = 1;
  sock_owned_by_me(sk);
 }

 sock_ops.sk = sk;
 sock_ops.op = op;
 if (nargs > 0)
  memcpy(sock_ops.args, args, nargs * sizeof(*args));

 ret = ({ int __ret = 0; if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&cgroup_bpf_enabled_key), struct static_key_true)) branch = arch_static_branch_jump(&(&cgroup_bpf_enabled_key)->key, false); else if (__builtin_types_compatible_p(typeof(*&cgroup_bpf_enabled_key), struct static_key_false)) branch = arch_static_branch(&(&cgroup_bpf_enabled_key)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }) && (&sock_ops)->sk) { typeof(sk) __sk = sk_to_full_sk((&sock_ops)->sk); if (__sk && sk_fullsock(__sk)) __ret = __cgroup_bpf_run_filter_sock_ops(__sk, &sock_ops, BPF_CGROUP_SOCK_OPS); } __ret; });
 if (ret == 0)
  ret = sock_ops.reply;
 else
  ret = -1;
 return ret;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_call_bpf_2arg(struct sock *sk, int op, u32 arg1, u32 arg2)
{
 u32 args[2] = {arg1, arg2};

 return tcp_call_bpf(sk, op, 2, args);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) int tcp_call_bpf_3arg(struct sock *sk, int op, u32 arg1, u32 arg2,
        u32 arg3)
{
 u32 args[3] = {arg1, arg2, arg3};

 return tcp_call_bpf(sk, op, 3, args);
}
# 2271 "/home/nathan/src/linux-next/include/net/tcp.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_timeout_init(struct sock *sk)
{
 int timeout;

 timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, 0, ((void *)0));

 if (timeout <= 0)
  timeout = ((unsigned)(1*100));
 return timeout;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 tcp_rwnd_init_bpf(struct sock *sk)
{
 int rwnd;

 rwnd = tcp_call_bpf(sk, BPF_SOCK_OPS_RWND_INIT, 0, ((void *)0));

 if (rwnd < 0)
  rwnd = 0;
 return rwnd;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool tcp_bpf_ca_needs_ecn(struct sock *sk)
{
 return (tcp_call_bpf(sk, BPF_SOCK_OPS_NEEDS_ECN, 0, ((void *)0)) == 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_bpf_rtt(struct sock *sk)
{
 if ((tcp_sk(sk)->bpf_sock_ops_cb_flags & (1<<3)))
  tcp_call_bpf(sk, BPF_SOCK_OPS_RTT_CB, 0, ((void *)0));
}
# 2315 "/home/nathan/src/linux-next/include/net/tcp.h"
extern struct static_key_false tcp_tx_delay_enabled;
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void tcp_add_tx_delay(struct sk_buff *skb,
        const struct tcp_sock *tp)
{
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&tcp_tx_delay_enabled), struct static_key_true)) branch = arch_static_branch_jump(&(&tcp_tx_delay_enabled)->key, false); else if (__builtin_types_compatible_p(typeof(*&tcp_tx_delay_enabled), struct static_key_false)) branch = arch_static_branch(&(&tcp_tx_delay_enabled)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); }))
  skb->skb_mstamp_ns += (u64)tp->tcp_tx_delay * 1000L;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u64 tcp_transmit_time(const struct sock *sk)
{
 if (({ bool branch; if (__builtin_types_compatible_p(typeof(*&tcp_tx_delay_enabled), struct static_key_true)) branch = arch_static_branch_jump(&(&tcp_tx_delay_enabled)->key, false); else if (__builtin_types_compatible_p(typeof(*&tcp_tx_delay_enabled), struct static_key_false)) branch = arch_static_branch(&(&tcp_tx_delay_enabled)->key, false); else branch = ____wrong_branch_error(); __builtin_expect(!!(branch), 0); })) {
  u32 delay = (sk->__sk_common.skc_state == TCP_TIME_WAIT) ?
   tcp_twsk(sk)->tw_tx_delay : tcp_sk(sk)->tcp_tx_delay;

  return tcp_clock_ns() + (u64)delay * 1000L;
 }
 return 0;
}
# 21 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2





# 1 "/home/nathan/src/linux-next/include/linux/firmware.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/firmware.h"
struct firmware {
 size_t size;
 const u8 *data;
 struct page **pages;


 void *priv;
};

struct module;
struct device;

struct builtin_fw {
 char *name;
 void *data;
 unsigned long size;
};
# 43 "/home/nathan/src/linux-next/include/linux/firmware.h"
int request_firmware(const struct firmware **fw, const char *name,
       struct device *device);
int firmware_request_nowarn(const struct firmware **fw, const char *name,
       struct device *device);
int request_firmware_nowait(
 struct module *module, bool uevent,
 const char *name, struct device *device, gfp_t gfp, void *context,
 void (*cont)(const struct firmware *fw, void *context));
int request_firmware_direct(const struct firmware **fw, const char *name,
       struct device *device);
int request_firmware_into_buf(const struct firmware **firmware_p,
 const char *name, struct device *device, void *buf, size_t size);

void release_firmware(const struct firmware *fw);
# 99 "/home/nathan/src/linux-next/include/linux/firmware.h"
int firmware_request_cache(struct device *device, const char *name);
# 27 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2



# 1 "/home/nathan/src/linux-next/include/linux/hwmon.h" 1
# 17 "/home/nathan/src/linux-next/include/linux/hwmon.h"
struct device;
struct attribute_group;

enum hwmon_sensor_types {
 hwmon_chip,
 hwmon_temp,
 hwmon_in,
 hwmon_curr,
 hwmon_power,
 hwmon_energy,
 hwmon_humidity,
 hwmon_fan,
 hwmon_pwm,
 hwmon_intrusion,
 hwmon_max,
};

enum hwmon_chip_attributes {
 hwmon_chip_temp_reset_history,
 hwmon_chip_in_reset_history,
 hwmon_chip_curr_reset_history,
 hwmon_chip_power_reset_history,
 hwmon_chip_register_tz,
 hwmon_chip_update_interval,
 hwmon_chip_alarms,
 hwmon_chip_samples,
 hwmon_chip_curr_samples,
 hwmon_chip_in_samples,
 hwmon_chip_power_samples,
 hwmon_chip_temp_samples,
};
# 62 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_temp_attributes {
 hwmon_temp_enable,
 hwmon_temp_input,
 hwmon_temp_type,
 hwmon_temp_lcrit,
 hwmon_temp_lcrit_hyst,
 hwmon_temp_min,
 hwmon_temp_min_hyst,
 hwmon_temp_max,
 hwmon_temp_max_hyst,
 hwmon_temp_crit,
 hwmon_temp_crit_hyst,
 hwmon_temp_emergency,
 hwmon_temp_emergency_hyst,
 hwmon_temp_alarm,
 hwmon_temp_lcrit_alarm,
 hwmon_temp_min_alarm,
 hwmon_temp_max_alarm,
 hwmon_temp_crit_alarm,
 hwmon_temp_emergency_alarm,
 hwmon_temp_fault,
 hwmon_temp_offset,
 hwmon_temp_label,
 hwmon_temp_lowest,
 hwmon_temp_highest,
 hwmon_temp_reset_history,
};
# 116 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_in_attributes {
 hwmon_in_enable,
 hwmon_in_input,
 hwmon_in_min,
 hwmon_in_max,
 hwmon_in_lcrit,
 hwmon_in_crit,
 hwmon_in_average,
 hwmon_in_lowest,
 hwmon_in_highest,
 hwmon_in_reset_history,
 hwmon_in_label,
 hwmon_in_alarm,
 hwmon_in_min_alarm,
 hwmon_in_max_alarm,
 hwmon_in_lcrit_alarm,
 hwmon_in_crit_alarm,
};
# 152 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_curr_attributes {
 hwmon_curr_enable,
 hwmon_curr_input,
 hwmon_curr_min,
 hwmon_curr_max,
 hwmon_curr_lcrit,
 hwmon_curr_crit,
 hwmon_curr_average,
 hwmon_curr_lowest,
 hwmon_curr_highest,
 hwmon_curr_reset_history,
 hwmon_curr_label,
 hwmon_curr_alarm,
 hwmon_curr_min_alarm,
 hwmon_curr_max_alarm,
 hwmon_curr_lcrit_alarm,
 hwmon_curr_crit_alarm,
};
# 188 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_power_attributes {
 hwmon_power_enable,
 hwmon_power_average,
 hwmon_power_average_interval,
 hwmon_power_average_interval_max,
 hwmon_power_average_interval_min,
 hwmon_power_average_highest,
 hwmon_power_average_lowest,
 hwmon_power_average_max,
 hwmon_power_average_min,
 hwmon_power_input,
 hwmon_power_input_highest,
 hwmon_power_input_lowest,
 hwmon_power_reset_history,
 hwmon_power_accuracy,
 hwmon_power_cap,
 hwmon_power_cap_hyst,
 hwmon_power_cap_max,
 hwmon_power_cap_min,
 hwmon_power_min,
 hwmon_power_max,
 hwmon_power_crit,
 hwmon_power_lcrit,
 hwmon_power_label,
 hwmon_power_alarm,
 hwmon_power_cap_alarm,
 hwmon_power_min_alarm,
 hwmon_power_max_alarm,
 hwmon_power_lcrit_alarm,
 hwmon_power_crit_alarm,
};
# 250 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_energy_attributes {
 hwmon_energy_enable,
 hwmon_energy_input,
 hwmon_energy_label,
};





enum hwmon_humidity_attributes {
 hwmon_humidity_enable,
 hwmon_humidity_input,
 hwmon_humidity_label,
 hwmon_humidity_min,
 hwmon_humidity_min_hyst,
 hwmon_humidity_max,
 hwmon_humidity_max_hyst,
 hwmon_humidity_alarm,
 hwmon_humidity_fault,
};
# 282 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_fan_attributes {
 hwmon_fan_enable,
 hwmon_fan_input,
 hwmon_fan_label,
 hwmon_fan_min,
 hwmon_fan_max,
 hwmon_fan_div,
 hwmon_fan_pulses,
 hwmon_fan_target,
 hwmon_fan_alarm,
 hwmon_fan_min_alarm,
 hwmon_fan_max_alarm,
 hwmon_fan_fault,
};
# 310 "/home/nathan/src/linux-next/include/linux/hwmon.h"
enum hwmon_pwm_attributes {
 hwmon_pwm_input,
 hwmon_pwm_enable,
 hwmon_pwm_mode,
 hwmon_pwm_freq,
};






enum hwmon_intrusion_attributes {
 hwmon_intrusion_alarm,
 hwmon_intrusion_beep,
};
# 374 "/home/nathan/src/linux-next/include/linux/hwmon.h"
struct hwmon_ops {
 umode_t (*is_visible)(const void *drvdata, enum hwmon_sensor_types type,
         u32 attr, int channel);
 int (*read)(struct device *dev, enum hwmon_sensor_types type,
      u32 attr, int channel, long *val);
 int (*read_string)(struct device *dev, enum hwmon_sensor_types type,
      u32 attr, int channel, const char **str);
 int (*write)(struct device *dev, enum hwmon_sensor_types type,
       u32 attr, int channel, long val);
};







struct hwmon_channel_info {
 enum hwmon_sensor_types type;
 const u32 *config;
};
# 409 "/home/nathan/src/linux-next/include/linux/hwmon.h"
struct hwmon_chip_info {
 const struct hwmon_ops *ops;
 const struct hwmon_channel_info **info;
};


struct device *hwmon_device_register(struct device *dev);

struct device *
hwmon_device_register_with_groups(struct device *dev, const char *name,
      void *drvdata,
      const struct attribute_group **groups);
struct device *
devm_hwmon_device_register_with_groups(struct device *dev, const char *name,
           void *drvdata,
           const struct attribute_group **groups);
struct device *
hwmon_device_register_with_info(struct device *dev,
    const char *name, void *drvdata,
    const struct hwmon_chip_info *info,
    const struct attribute_group **extra_groups);
struct device *
devm_hwmon_device_register_with_info(struct device *dev,
    const char *name, void *drvdata,
    const struct hwmon_chip_info *info,
    const struct attribute_group **extra_groups);

void hwmon_device_unregister(struct device *dev);
void devm_hwmon_device_unregister(struct device *dev);
# 448 "/home/nathan/src/linux-next/include/linux/hwmon.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool hwmon_is_bad_char(const char ch)
{
 switch (ch) {
 case '-':
 case '*':
 case ' ':
 case '\t':
 case '\n':
  return true;
 default:
  return false;
 }
}
# 31 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2
# 1 "/home/nathan/src/linux-next/include/linux/hwmon-sysfs.h" 1
# 12 "/home/nathan/src/linux-next/include/linux/hwmon-sysfs.h"
struct sensor_device_attribute{
 struct device_attribute dev_attr;
 int index;
};
# 45 "/home/nathan/src/linux-next/include/linux/hwmon-sysfs.h"
struct sensor_device_attribute_2 {
 struct device_attribute dev_attr;
 u8 index;
 u8 nr;
};
# 32 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2

# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_hw.h" 1
# 205 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eq_entry {
 u32 evt;
};



struct be_eth_wrb {
 __le32 frag_pa_hi;
 __le32 frag_pa_lo;
 u32 rsvd0;
 __le32 frag_len;
} __attribute__((__packed__));




struct amap_eth_hdr_wrb {
 u8 rsvd0[32];
 u8 rsvd1[32];
 u8 complete;
 u8 event;
 u8 crc;
 u8 forward;
 u8 lso6;
 u8 mgmt;
 u8 ipcs;
 u8 udpcs;
 u8 tcpcs;
 u8 lso;
 u8 vlan;
 u8 gso[2];
 u8 num_wrb[5];
 u8 lso_mss[14];
 u8 len[16];
 u8 vlan_tag[16];
} __attribute__((__packed__));






struct be_eth_hdr_wrb {
 __le32 dw[4];
};
# 269 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_hw.h"
struct amap_eth_tx_compl {
 u8 wrb_index[16];
 u8 ct[2];
 u8 port[2];
 u8 rsvd0[8];
 u8 status[4];
 u8 user_bytes[16];
 u8 nwh_bytes[8];
 u8 lso;
 u8 cast_enc[2];
 u8 rsvd1[5];
 u8 rsvd2[32];
 u8 pkts[16];
 u8 ringid[11];
 u8 hash_val[4];
 u8 valid;
} __attribute__((__packed__));

struct be_eth_tx_compl {
 u32 dw[4];
};


struct be_eth_rx_d {
 u32 fragpa_hi;
 u32 fragpa_lo;
};






struct amap_eth_rx_compl_v0 {
 u8 vlan_tag[16];
 u8 pktsize[14];
 u8 port;
 u8 ip_opt;
 u8 err;
 u8 rsshp;
 u8 ipf;
 u8 tcpf;
 u8 udpf;
 u8 ipcksm;
 u8 l4_cksm;
 u8 ip_version;
 u8 macdst[6];
 u8 vtp;
 u8 ip_frag;
 u8 fragndx[10];
 u8 ct[2];
 u8 sw;
 u8 numfrags[3];
 u8 rss_flush;
 u8 cast_enc[2];
 u8 qnq;
 u8 rss_bank;
 u8 rsvd1[23];
 u8 lro_pkt;
 u8 rsvd2[2];
 u8 valid;
 u8 rsshash[32];
} __attribute__((__packed__));




struct amap_eth_rx_compl_v1 {
 u8 vlan_tag[16];
 u8 pktsize[14];
 u8 vtp;
 u8 ip_opt;
 u8 err;
 u8 rsshp;
 u8 ipf;
 u8 tcpf;
 u8 udpf;
 u8 ipcksm;
 u8 l4_cksm;
 u8 ip_version;
 u8 macdst[7];
 u8 rsvd0;
 u8 fragndx[10];
 u8 ct[2];
 u8 sw;
 u8 numfrags[3];
 u8 rss_flush;
 u8 cast_enc[2];
 u8 qnq;
 u8 rss_bank;
 u8 port[2];
 u8 vntagp;
 u8 header_len[8];
 u8 header_split[2];
 u8 rsvd1[12];
 u8 tunneled;
 u8 valid;
 u8 rsshash[32];
} __attribute__((__packed__));

struct be_eth_rx_compl {
 u32 dw[4];
};
# 34 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2
# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_roce.h" 1
# 22 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_roce.h"
struct ocrdma_dev;

enum be_interrupt_mode {
 BE_INTERRUPT_MODE_MSIX = 0,
 BE_INTERRUPT_MODE_INTX = 1,
 BE_INTERRUPT_MODE_MSI = 2,
};


struct be_dev_info {
 u8 *db;
 u64 unmapped_db;
 u32 db_page_size;
 u32 db_total_size;
 u64 dpp_unmapped_addr;
 u32 dpp_unmapped_len;
 struct pci_dev *pdev;
 struct net_device *netdev;
 u8 mac_addr[6];
 u32 dev_family;
 enum be_interrupt_mode intr_mode;
 struct {
  int num_vectors;
  int start_vector;
  u32 vector_list[32];
 } msix;
};


struct ocrdma_driver {
 unsigned char name[32];
 u32 be_abi_version;
 struct ocrdma_dev *(*add) (struct be_dev_info *dev_info);
 void (*remove) (struct ocrdma_dev *);
 void (*state_change_handler) (struct ocrdma_dev *, u32 new_state);
};

enum be_roce_event {
 BE_DEV_SHUTDOWN = 2
};




int be_roce_register_driver(struct ocrdma_driver *drv);
void be_roce_unregister_driver(struct ocrdma_driver *drv);


int be_roce_mcc_cmd(void *netdev_handle, void *wrb_payload,
      int wrb_payload_size, u16 *cmd_status, u16 *ext_status);
# 35 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h" 2
# 120 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
struct be_dma_mem {
 void *va;
 dma_addr_t dma;
 u32 size;
};

struct be_queue_info {
 u32 len;
 u32 entry_size;
 u32 tail, head;
 atomic_t used;
 u32 id;
 struct be_dma_mem dma_mem;
 bool created;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 MODULO(u32 val, u32 limit)
{
 do { if (__builtin_constant_p(limit & (limit - 1))) { if (limit & (limit - 1)) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/net/ethernet/emulex/benet/be.h"), "i" (138), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/net/ethernet/emulex/benet/be.h"), "i" (138), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(limit & (limit - 1)))); } } while (0);
 return val & (limit - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void index_adv(u32 *index, u32 val, u32 limit)
{
 *index = MODULO((*index + val), limit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void index_inc(u32 *index, u32 limit)
{
 *index = MODULO((*index + 1), limit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *queue_head_node(struct be_queue_info *q)
{
 return q->dma_mem.va + q->head * q->entry_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *queue_tail_node(struct be_queue_info *q)
{
 return q->dma_mem.va + q->tail * q->entry_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *queue_index_node(struct be_queue_info *q, u16 index)
{
 return q->dma_mem.va + index * q->entry_size;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void queue_head_inc(struct be_queue_info *q)
{
 index_inc(&q->head, q->len);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void index_dec(u32 *index, u32 limit)
{
 *index = MODULO((*index - 1), limit);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void queue_tail_inc(struct be_queue_info *q)
{
 index_inc(&q->tail, q->len);
}

struct be_eq_obj {
 struct be_queue_info q;
 char desc[32];

 struct be_adapter *adapter;
 struct napi_struct napi;
 u8 idx;
 u8 msix_idx;
 u16 spurious_intr;
 cpumask_var_t affinity_mask;
} __attribute__((__aligned__((1 << 7))));

struct be_aic_obj {
 u32 min_eqd;
 u32 max_eqd;
 u32 prev_eqd;
 u32 et_eqd;
 ulong jiffies;
 u64 rx_pkts_prev;
 u64 tx_reqs_prev;
};

struct be_mcc_obj {
 struct be_queue_info q;
 struct be_queue_info cq;
 bool rearm_cq;
};

struct be_tx_stats {
 u64 tx_bytes;
 u64 tx_pkts;
 u64 tx_vxlan_offload_pkts;
 u64 tx_reqs;
 u64 tx_compl;
 u32 tx_stops;
 u32 tx_drv_drops;

 u32 tx_hdr_parse_err;
 u32 tx_dma_err;
 u32 tx_tso_err;
 u32 tx_spoof_check_err;
 u32 tx_qinq_err;
 u32 tx_internal_parity_err;
 u32 tx_sge_err;
 struct u64_stats_sync sync;
 struct u64_stats_sync sync_compl;
};


struct be_tx_compl_info {
 u8 status;
 u16 end_index;
};

struct be_tx_obj {
 u32 db_offset;
 struct be_tx_compl_info txcp;
 struct be_queue_info q;
 struct be_queue_info cq;

 struct sk_buff *sent_skb_list[2048];
 struct be_tx_stats stats;
 u16 pend_wrb_cnt;
 u16 last_req_wrb_cnt;
 u16 last_req_hdr;
} __attribute__((__aligned__((1 << 7))));


struct be_rx_page_info {
 struct page *page;

 dma_addr_t bus;
 u16 page_offset;
 bool last_frag;
};

struct be_rx_stats {
 u64 rx_bytes;
 u64 rx_pkts;
 u64 rx_vxlan_offload_pkts;
 u32 rx_drops_no_skbs;
 u32 rx_drops_no_frags;
 u32 rx_post_fail;
 u32 rx_compl;
 u32 rx_mcast_pkts;
 u32 rx_compl_err;
 struct u64_stats_sync sync;
};

struct be_rx_compl_info {
 u32 rss_hash;
 u16 vlan_tag;
 u16 pkt_size;
 u16 port;
 u8 vlanf;
 u8 num_rcvd;
 u8 err;
 u8 ipf;
 u8 tcpf;
 u8 udpf;
 u8 ip_csum;
 u8 l4_csum;
 u8 ipv6;
 u8 qnq;
 u8 pkt_type;
 u8 ip_frag;
 u8 tunneled;
};

struct be_rx_obj {
 struct be_adapter *adapter;
 struct be_queue_info q;
 struct be_queue_info cq;
 struct be_rx_compl_info rxcp;
 struct be_rx_page_info page_info_tbl[1024];
 struct be_rx_stats stats;
 u8 rss_id;
 bool rx_post_starved;
} __attribute__((__aligned__((1 << 7))));

struct be_drv_stats {
 u32 eth_red_drops;
 u32 dma_map_errors;
 u32 rx_drops_no_pbuf;
 u32 rx_drops_no_txpb;
 u32 rx_drops_no_erx_descr;
 u32 rx_drops_no_tpre_descr;
 u32 rx_drops_too_many_frags;
 u32 forwarded_packets;
 u32 rx_drops_mtu;
 u32 rx_crc_errors;
 u32 rx_alignment_symbol_errors;
 u32 rx_pause_frames;
 u32 rx_priority_pause_frames;
 u32 rx_control_frames;
 u32 rx_in_range_errors;
 u32 rx_out_range_errors;
 u32 rx_frame_too_long;
 u32 rx_address_filtered;
 u32 rx_dropped_too_small;
 u32 rx_dropped_too_short;
 u32 rx_dropped_header_too_small;
 u32 rx_dropped_tcp_length;
 u32 rx_dropped_runt;
 u32 rx_ip_checksum_errs;
 u32 rx_tcp_checksum_errs;
 u32 rx_udp_checksum_errs;
 u32 tx_pauseframes;
 u32 tx_priority_pauseframes;
 u32 tx_controlframes;
 u32 rxpp_fifo_overflow_drop;
 u32 rx_input_fifo_overflow_drop;
 u32 pmem_fifo_overflow_drop;
 u32 jabber_events;
 u32 rx_roce_bytes_lsd;
 u32 rx_roce_bytes_msd;
 u32 rx_roce_frames;
 u32 roce_drops_payload_len;
 u32 roce_drops_crc;
};




struct be_vf_cfg {
 unsigned char mac_addr[6];
 int if_handle;
 int pmac_id;
 u16 vlan_tag;
 u32 tx_rate;
 u32 plink_tracking;
 u32 privileges;
 bool spoofchk;
};

enum vf_state {
 ENABLED = 0,
 ASSIGNED = 1
};
# 384 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
struct phy_info {


 u8 transceiver;
 u8 autoneg;
 u8 fc_autoneg;
 u8 port_type;
 u16 phy_type;
 u16 interface_type;
 u32 misc_params;
 u16 auto_speeds_supported;
 u16 fixed_speeds_supported;
 int link_speed;
 u32 advertising;
 u32 supported;
 u8 cable_type;
 u8 vendor_name[17];
 u8 vendor_pn[17];
};

struct be_resources {
 u16 max_vfs;
 u16 max_mcast_mac;
 u16 max_tx_qs;
 u16 max_rss_qs;
 u16 max_rx_qs;
 u16 max_cq_count;
 u16 max_uc_mac;
 u16 max_vlans;
 u16 max_iface_count;
 u16 max_mcc_count;
 u16 max_evt_qs;
 u16 max_nic_evt_qs;
 u32 if_cap_flags;
 u32 vf_if_cap_flags;
 u32 flags;



 u16 max_rss_tables;
};


struct be_port_resources {
 u16 max_vfs;
 u16 nic_pfs;
};



struct rss_info {
 u8 rsstable[128];
 u8 rss_queue[128];
 u8 rss_hkey[40];
 u64 rss_flags;
};


struct be_hwmon {
 struct device *hwmon_dev;
 u8 be_on_die_temp;
};
# 459 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
enum {
 BE_WRB_F_CRC_BIT,
 BE_WRB_F_IPCS_BIT,
 BE_WRB_F_TCPCS_BIT,
 BE_WRB_F_UDPCS_BIT,
 BE_WRB_F_LSO_BIT,
 BE_WRB_F_LSO6_BIT,
 BE_WRB_F_VLAN_BIT,
 BE_WRB_F_VLAN_SKIP_HW_BIT,
 BE_WRB_F_OS2BMC_BIT
};





struct be_wrb_params {
 u32 features;
 u16 vlan_tag;
 u16 lso_mss;
};

struct be_eth_addr {
 unsigned char mac[6];
};
# 512 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
enum {
 ERR_RECOVERY_ST_NONE = 0,
 ERR_RECOVERY_ST_DETECT = 1,
 ERR_RECOVERY_ST_RESET = 2,
 ERR_RECOVERY_ST_PRE_POLL = 3,
 ERR_RECOVERY_ST_REINIT = 4
};

struct be_error_recovery {
 union {
  u8 recovery_retries;
  u8 recovery_state;
 };


 bool recovery_supported;
 u16 ue_to_reset_time;


 u16 ue_to_poll_time;


 u16 last_err_code;
 unsigned long probe_time;
 unsigned long last_recovery_time;


 u32 resched_delay;
 struct delayed_work err_detection_work;
};




struct be_vxlan_port {
 struct list_head list;
 __be16 port;
 int port_aliases;
};

struct be_adapter {
 struct pci_dev *pdev;
 struct net_device *netdev;

 u8 *csr;
 u8 *db;
 u8 *pcicfg;

 struct mutex mbox_lock;
 struct be_dma_mem mbox_mem;


 struct be_dma_mem mbox_mem_alloced;

 struct be_mcc_obj mcc_obj;
 struct mutex mcc_lock;
 spinlock_t mcc_cq_lock;

 u16 cfg_num_rx_irqs;
 u16 cfg_num_tx_irqs;
 u16 num_evt_qs;
 u16 num_msix_vec;
 struct be_eq_obj eq_obj[32];
 struct msix_entry msix_entries[32];
 bool isr_registered;


 u16 num_tx_qs;
 struct be_tx_obj tx_obj[32];


 u16 num_rx_qs;
 u16 num_rss_qs;
 u16 need_def_rxq;
 struct be_rx_obj rx_obj[32];
 u32 big_page_size;

 struct be_drv_stats drv_stats;
 struct be_aic_obj aic_obj[32];
 bool aic_enabled;
 u8 vlan_prio_bmap;
 u16 recommended_prio_bits;
 struct be_dma_mem rx_filter;

 struct be_dma_mem stats_cmd;

 struct delayed_work work;
 u16 work_counter;

 u8 recovery_retries;
 u8 err_flags;
 bool pcicfg_mapped;
 u32 flags;
 u32 cmd_privileges;

 char fw_ver[32];
 char fw_on_flash[32];


 int if_handle;
 u32 if_flags;
 u32 *pmac_id;
 struct be_eth_addr *uc_list;
 u32 uc_macs;
 struct be_eth_addr *mc_list;
 u32 mc_count;
 unsigned long vids[(((4096) + ((sizeof(long) * 8)) - 1) / ((sizeof(long) * 8)))];
 u16 vlans_added;
 bool update_uc_list;
 bool update_mc_list;
 struct mutex rx_filter_lock;

 u32 beacon_state;

 u32 port_num;
 char port_name;
 u8 mc_type;
 u32 function_mode;
 u32 function_caps;
 u32 rx_fc;
 u32 tx_fc;
 bool stats_cmd_sent;
 struct {
  u32 size;
  u32 total_size;
  u64 io_addr;
 } roce_db;
 u32 num_msix_roce_vec;
 struct ocrdma_dev *ocrdma_dev;
 struct list_head entry;

 u32 flash_status;
 struct completion et_cmd_compl;

 struct be_resources pool_res;
 struct be_resources res;
 u16 num_vfs;
 u8 pf_num;
 u8 vf_num;
 u8 virtfn;
 struct be_vf_cfg *vf_cfg;
 bool be3_native;
 u32 sli_family;
 u8 hba_port_num;
 u16 pvid;
 __be16 vxlan_port;
 int vxlan_port_count;
 struct list_head vxlan_port_list;
 struct phy_info phy;
 u8 wol_cap;
 bool wol_en;
 u16 asic_rev;
 u16 qnq_vid;
 u32 msg_enable;
 int be_get_temp_freq;
 struct be_hwmon hwmon_info;
 struct rss_info rss_info;

 u32 bmc_filt_mask;
 u32 fat_dump_len;
 u16 serial_num[8];
 u8 phy_state;
 u8 dev_mac[6];
 u32 priv_flags;
 struct be_error_recovery error_recovery;
};


struct be_cmd_work {
 struct work_struct work;
 struct be_adapter *adapter;
 union {
  __be16 vxlan_port;
 } info;
};
# 720 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 be_max_rx_irqs(struct be_adapter *adapter)
{

 u16 num = __builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_rss_qs))) *)1 == (typeof((u16)(1)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_rss_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(1)) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_rss_qs))) > ((u16)(1)) ? ((u16)((adapter->res.max_rss_qs))) : ((u16)(1))), ({ typeof((u16)((adapter->res.max_rss_qs))) __UNIQUE_ID___x104 = ((u16)((adapter->res.max_rss_qs))); typeof((u16)(1)) __UNIQUE_ID___y105 = ((u16)(1)); ((__UNIQUE_ID___x104) > (__UNIQUE_ID___y105) ? (__UNIQUE_ID___x104) : (__UNIQUE_ID___y105)); }));

 return __builtin_choose_expr(((!!(sizeof((typeof((u16)(num)) *)1 == (typeof((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); }))))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); }))))) * 0l)) : (int *)8))))), (((u16)(num)) < ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); }))))) ? ((u16)(num)) : ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); })))))), ({ typeof((u16)(num)) __UNIQUE_ID___x108 = ((u16)(num)); typeof((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); }))))) __UNIQUE_ID___y109 = ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x106 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y107 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x106) < (__UNIQUE_ID___y107) ? (__UNIQUE_ID___x106) : (__UNIQUE_ID___y107)); }))))); ((__UNIQUE_ID___x108) < (__UNIQUE_ID___y109) ? (__UNIQUE_ID___x108) : (__UNIQUE_ID___y109)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 be_max_tx_irqs(struct be_adapter *adapter)
{
 return __builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_tx_qs))) *)1 == (typeof((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); }))))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_tx_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); }))))) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_tx_qs))) < ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); }))))) ? ((u16)((adapter->res.max_tx_qs))) : ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); })))))), ({ typeof((u16)((adapter->res.max_tx_qs))) __UNIQUE_ID___x112 = ((u16)((adapter->res.max_tx_qs))); typeof((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); }))))) __UNIQUE_ID___y113 = ((u16)((__builtin_choose_expr(((!!(sizeof((typeof((u16)((adapter->res.max_nic_evt_qs))) *)1 == (typeof((u16)(num_online_cpus())) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)((adapter->res.max_nic_evt_qs))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u16)(num_online_cpus())) * 0l)) : (int *)8))))), (((u16)((adapter->res.max_nic_evt_qs))) < ((u16)(num_online_cpus())) ? ((u16)((adapter->res.max_nic_evt_qs))) : ((u16)(num_online_cpus()))), ({ typeof((u16)((adapter->res.max_nic_evt_qs))) __UNIQUE_ID___x110 = ((u16)((adapter->res.max_nic_evt_qs))); typeof((u16)(num_online_cpus())) __UNIQUE_ID___y111 = ((u16)(num_online_cpus())); ((__UNIQUE_ID___x110) < (__UNIQUE_ID___y111) ? (__UNIQUE_ID___x110) : (__UNIQUE_ID___y111)); }))))); ((__UNIQUE_ID___x112) < (__UNIQUE_ID___y113) ? (__UNIQUE_ID___x112) : (__UNIQUE_ID___y113)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 be_max_qp_irqs(struct be_adapter *adapter)
{
 return __builtin_choose_expr(((!!(sizeof((typeof(be_max_tx_irqs(adapter)) *)1 == (typeof(be_max_rx_irqs(adapter)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(be_max_tx_irqs(adapter)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(be_max_rx_irqs(adapter)) * 0l)) : (int *)8))))), ((be_max_tx_irqs(adapter)) < (be_max_rx_irqs(adapter)) ? (be_max_tx_irqs(adapter)) : (be_max_rx_irqs(adapter))), ({ typeof(be_max_tx_irqs(adapter)) __UNIQUE_ID___x114 = (be_max_tx_irqs(adapter)); typeof(be_max_rx_irqs(adapter)) __UNIQUE_ID___y115 = (be_max_rx_irqs(adapter)); ((__UNIQUE_ID___x114) < (__UNIQUE_ID___y115) ? (__UNIQUE_ID___x114) : (__UNIQUE_ID___y115)); }));
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u16 be_max_any_irqs(struct be_adapter *adapter)
{
 return __builtin_choose_expr(((!!(sizeof((typeof(be_max_tx_irqs(adapter)) *)1 == (typeof(be_max_rx_irqs(adapter)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(be_max_tx_irqs(adapter)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(be_max_rx_irqs(adapter)) * 0l)) : (int *)8))))), ((be_max_tx_irqs(adapter)) > (be_max_rx_irqs(adapter)) ? (be_max_tx_irqs(adapter)) : (be_max_rx_irqs(adapter))), ({ typeof(be_max_tx_irqs(adapter)) __UNIQUE_ID___x116 = (be_max_tx_irqs(adapter)); typeof(be_max_rx_irqs(adapter)) __UNIQUE_ID___y117 = (be_max_rx_irqs(adapter)); ((__UNIQUE_ID___x116) > (__UNIQUE_ID___y117) ? (__UNIQUE_ID___x116) : (__UNIQUE_ID___y117)); }));
}
# 785 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
extern const struct ethtool_ops be_ethtool_ops;
# 836 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 amap_mask(u32 bitsize)
{
 return (bitsize == 32 ? 0xFFFFFFFF : (1 << bitsize) - 1);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void
amap_set(void *ptr, u32 dw_offset, u32 mask, u32 offset, u32 value)
{
 u32 *dw = (u32 *) ptr + dw_offset;
 *dw &= ~(mask << offset);
 *dw |= (mask & value) << offset;
}
# 856 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u32 amap_get(void *ptr, u32 dw_offset, u32 mask, u32 offset)
{
 u32 *dw = (u32 *) ptr;
 return mask & (*(dw + dw_offset) >> offset);
}
# 882 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void swap_dws(void *wrb, int len)
{

 u32 *dw = wrb;
 do { if (__builtin_constant_p(len % 4)) { if (len % 4) do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/net/ethernet/emulex/benet/be.h"), "i" (886), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0); } else { __asm__ __volatile__( "1:	" "tdnei" " " " %4, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/net/ethernet/emulex/benet/be.h"), "i" (886), "i" (0), "i" (sizeof(struct bug_entry)), "r" (( long)(len % 4))); } } while (0);
 do {
  *dw = (( __le32)(__builtin_constant_p((__u32)((*dw))) ? ((__u32)( (((__u32)((*dw)) & (__u32)0x000000ffUL) << 24) | (((__u32)((*dw)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((*dw)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((*dw)) & (__u32)0xff000000UL) >> 24))) : __fswab32((*dw))));
  dw++;
  len -= 4;
 } while (len);

}



static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 is_tcp_pkt(struct sk_buff *skb)
{
 u8 val = 0;

 if (ip_hdr(skb)->version == 4)
  val = (ip_hdr(skb)->protocol == IPPROTO_TCP);
 else if (ip_hdr(skb)->version == 6)
  val = (ipv6_hdr(skb)->nexthdr == 6);

 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 is_udp_pkt(struct sk_buff *skb)
{
 u8 val = 0;

 if (ip_hdr(skb)->version == 4)
  val = (ip_hdr(skb)->protocol == IPPROTO_UDP);
 else if (ip_hdr(skb)->version == 6)
  val = (ipv6_hdr(skb)->nexthdr == 17);

 return val;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_ipv4_pkt(struct sk_buff *skb)
{
 return skb->protocol == (( __be16)(__u16)(0x0800)) && ip_hdr(skb)->version == 4;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_ipv6_ext_hdr(struct sk_buff *skb)
{
 if (ip_hdr(skb)->version == 6)
  return ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr);
 else
  return false;
}
# 946 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be.h"
static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) u8 be_check_error(struct be_adapter *adapter, u32 err_type)
{
 return (adapter->err_flags & err_type);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be_set_error(struct be_adapter *adapter, int err_type)
{
 struct net_device *netdev = adapter->netdev;

 adapter->err_flags |= err_type;
 netif_carrier_off(netdev);

 _dev_info(&adapter->pdev->dev, "%s: Link down\n", netdev->name);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be_clear_error(struct be_adapter *adapter, int err_type)
{
 adapter->err_flags &= ~err_type;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool be_multi_rxq(const struct be_adapter *adapter)
{
 return adapter->num_rx_qs > 1;
}

void be_cq_notify(struct be_adapter *adapter, u16 qid, bool arm,
    u16 num_popped);
void be_link_status_update(struct be_adapter *adapter, u8 link_status);
void be_parse_stats(struct be_adapter *adapter);
int be_load_fw(struct be_adapter *adapter, u8 *func);
bool be_is_wol_supported(struct be_adapter *adapter);
bool be_pause_supported(struct be_adapter *adapter);
u32 be_get_fw_log_level(struct be_adapter *adapter);
int be_update_queues(struct be_adapter *adapter);
int be_poll(struct napi_struct *napi, int budget);
void be_eqd_update(struct be_adapter *adapter, bool force_update);




void be_roce_dev_add(struct be_adapter *);
void be_roce_dev_remove(struct be_adapter *);




void be_roce_dev_shutdown(struct be_adapter *);
# 16 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c" 2
# 1 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h" 1
# 22 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_sge {
 u32 pa_lo;
 u32 pa_hi;
 u32 len;
};




struct be_mcc_wrb {
 u32 embedded;
 u32 payload_length;
 u32 tag0;
 u32 tag1;
 u32 rsvd;
 union {
  u8 embedded_payload[236];
  struct be_sge sgl[19];
 } payload;
};







enum mcc_base_status {
 MCC_STATUS_SUCCESS = 0,
 MCC_STATUS_FAILED = 1,
 MCC_STATUS_ILLEGAL_REQUEST = 2,
 MCC_STATUS_ILLEGAL_FIELD = 3,
 MCC_STATUS_INSUFFICIENT_BUFFER = 4,
 MCC_STATUS_UNAUTHORIZED_REQUEST = 5,
 MCC_STATUS_NOT_SUPPORTED = 66,
 MCC_STATUS_FEATURE_NOT_SUPPORTED = 68,
 MCC_STATUS_INVALID_LENGTH = 116
};


enum mcc_addl_status {
 MCC_ADDL_STATUS_INSUFFICIENT_RESOURCES = 0x16,
 MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH = 0x4d,
 MCC_ADDL_STATUS_TOO_MANY_INTERFACES = 0x4a,
 MCC_ADDL_STATUS_INSUFFICIENT_VLANS = 0xab,
 MCC_ADDL_STATUS_INVALID_SIGNATURE = 0x56,
 MCC_ADDL_STATUS_MISSING_SIGNATURE = 0x57,
 MCC_ADDL_STATUS_INSUFFICIENT_PRIVILEGES = 0x60
};
# 85 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_compl {
 u32 status;
 u32 tag0;
 u32 tag1;
 u32 flags;
};
# 110 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
enum {
 LINK_DOWN = 0x0,
 LINK_UP = 0x1
};






struct be_async_event_link_state {
 u8 physical_port;
 u8 port_link_status;
 u8 port_duplex;
 u8 port_speed;
 u8 port_fault;
 u8 rsvd0[7];
 u32 flags;
} __attribute__((__packed__));




struct be_async_event_grp5_qos_link_speed {
 u8 physical_port;
 u8 rsvd[5];
 u16 qos_link_speed;
 u32 event_tag;
 u32 flags;
} __attribute__((__packed__));




struct be_async_event_grp5_cos_priority {
 u8 physical_port;
 u8 available_priority_bmap;
 u8 reco_default_priority;
 u8 valid;
 u8 rsvd0;
 u8 event_tag;
 u32 flags;
} __attribute__((__packed__));




struct be_async_event_grp5_pvid_state {
 u8 enabled;
 u8 rsvd0;
 u16 tag;
 u32 event_tag;
 u32 rsvd1;
 u32 flags;
} __attribute__((__packed__));


struct be_async_event_qnq {
 u8 valid;
 u8 rsvd0;
 u16 vlan_tag;
 u32 event_tag;
 u8 rsvd1[4];
 u32 flags;
} __attribute__((__packed__));

enum {
 BE_PHY_FUNCTIONAL = 0,
 BE_PHY_NOT_PRESENT = 1,
 BE_PHY_DIFF_MEDIA = 2,
 BE_PHY_INCOMPATIBLE = 3,
 BE_PHY_UNQUALIFIED = 4,
 BE_PHY_UNCERTIFIED = 5
};
# 200 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
extern const char * const be_misconfig_evt_port_state[];


struct be_async_event_misconfig_port {






 u32 event_data_word1;
# 223 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
 u32 event_data_word2;
 u32 rsvd0;
 u32 flags;
} __attribute__((__packed__));
# 237 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_fw_control {
 u32 event_data_word1;
 u32 event_data_word2;
 u32 evt_tag;
 u32 event_data_word4;
} __attribute__((__packed__));

struct be_mcc_mailbox {
 struct be_mcc_wrb wrb;
 struct be_mcc_compl compl;
};
# 328 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_hdr {
 u8 opcode;
 u8 subsystem;
 u8 port_number;
 u8 domain;
 u32 timeout;
 u32 request_length;
 u8 version;
 u8 rsvd[3];
};



struct be_cmd_resp_hdr {
 u8 opcode;
 u8 subsystem;
 u8 rsvd[2];
 u8 base_status;
 u8 addl_status;
 u8 rsvd1[2];
 u32 response_length;
 u32 actual_resp_len;
};

struct phys_addr {
 u32 lo;
 u32 hi;
};







struct amap_eq_context {
 u8 cidx[13];
 u8 rsvd0[3];
 u8 epidx[13];
 u8 valid;
 u8 rsvd1;
 u8 size;
 u8 pidx[13];
 u8 rsvd2[3];
 u8 pd[10];
 u8 count[3];
 u8 solevent;
 u8 stalled;
 u8 armed;
 u8 rsvd3[4];
 u8 func[8];
 u8 rsvd4;
 u8 delaymult[10];
 u8 rsvd5[2];
 u8 phase[2];
 u8 nodelay;
 u8 rsvd6[4];
 u8 rsvd7[32];
} __attribute__((__packed__));

struct be_cmd_req_eq_create {
 struct be_cmd_req_hdr hdr;
 u16 num_pages;
 u16 rsvd0;
 u8 context[sizeof(struct amap_eq_context) / 8];
 struct phys_addr pages[8];
} __attribute__((__packed__));

struct be_cmd_resp_eq_create {
 struct be_cmd_resp_hdr resp_hdr;
 u16 eq_id;
 u16 msix_idx;
} __attribute__((__packed__));


enum {
 MAC_ADDRESS_TYPE_STORAGE = 0x0,
 MAC_ADDRESS_TYPE_NETWORK = 0x1,
 MAC_ADDRESS_TYPE_PD = 0x2,
 MAC_ADDRESS_TYPE_MANAGEMENT = 0x3
};

struct mac_addr {
 u16 size_of_struct;
 u8 addr[6];
} __attribute__((__packed__));

struct be_cmd_req_mac_query {
 struct be_cmd_req_hdr hdr;
 u8 type;
 u8 permanent;
 u16 if_id;
 u32 pmac_id;
} __attribute__((__packed__));

struct be_cmd_resp_mac_query {
 struct be_cmd_resp_hdr hdr;
 struct mac_addr mac;
};


struct be_cmd_req_pmac_add {
 struct be_cmd_req_hdr hdr;
 u32 if_id;
 u8 mac_address[6];
 u8 rsvd0[2];
} __attribute__((__packed__));

struct be_cmd_resp_pmac_add {
 struct be_cmd_resp_hdr hdr;
 u32 pmac_id;
};


struct be_cmd_req_pmac_del {
 struct be_cmd_req_hdr hdr;
 u32 if_id;
 u32 pmac_id;
};




struct amap_cq_context_be {
 u8 cidx[11];
 u8 rsvd0;
 u8 coalescwm[2];
 u8 nodelay;
 u8 epidx[11];
 u8 rsvd1;
 u8 count[2];
 u8 valid;
 u8 solevent;
 u8 eventable;
 u8 pidx[11];
 u8 rsvd2;
 u8 pd[10];
 u8 eqid[8];
 u8 stalled;
 u8 armed;
 u8 rsvd3[4];
 u8 func[8];
 u8 rsvd4[20];
 u8 rsvd5[32];
} __attribute__((__packed__));

struct amap_cq_context_v2 {
 u8 rsvd0[12];
 u8 coalescwm[2];
 u8 nodelay;
 u8 rsvd1[12];
 u8 count[2];
 u8 valid;
 u8 rsvd2;
 u8 eventable;
 u8 eqid[16];
 u8 rsvd3[15];
 u8 armed;
 u8 rsvd4[32];
 u8 rsvd5[32];
} __attribute__((__packed__));

struct be_cmd_req_cq_create {
 struct be_cmd_req_hdr hdr;
 u16 num_pages;
 u8 page_size;
 u8 rsvd0;
 u8 context[sizeof(struct amap_cq_context_be) / 8];
 struct phys_addr pages[8];
} __attribute__((__packed__));


struct be_cmd_resp_cq_create {
 struct be_cmd_resp_hdr hdr;
 u16 cq_id;
 u16 rsvd0;
} __attribute__((__packed__));

struct be_cmd_req_get_fat {
 struct be_cmd_req_hdr hdr;
 u32 fat_operation;
 u32 read_log_offset;
 u32 read_log_length;
 u32 data_buffer_size;
 u32 data_buffer[1];
} __attribute__((__packed__));

struct be_cmd_resp_get_fat {
 struct be_cmd_resp_hdr hdr;
 u32 log_size;
 u32 read_log_length;
 u32 rsvd[2];
 u32 data_buffer[1];
} __attribute__((__packed__));





struct amap_mcc_context_be {
 u8 con_index[14];
 u8 rsvd0[2];
 u8 ring_size[4];
 u8 fetch_wrb;
 u8 fetch_r2t;
 u8 cq_id[10];
 u8 prod_index[14];
 u8 fid[8];
 u8 pdid[9];
 u8 valid;
 u8 rsvd1[32];
 u8 rsvd2[32];
} __attribute__((__packed__));

struct amap_mcc_context_v1 {
 u8 async_cq_id[16];
 u8 ring_size[4];
 u8 rsvd0[12];
 u8 rsvd1[31];
 u8 valid;
 u8 async_cq_valid[1];
 u8 rsvd2[31];
 u8 rsvd3[32];
} __attribute__((__packed__));

struct be_cmd_req_mcc_create {
 struct be_cmd_req_hdr hdr;
 u16 num_pages;
 u16 cq_id;
 u8 context[sizeof(struct amap_mcc_context_be) / 8];
 struct phys_addr pages[8];
} __attribute__((__packed__));

struct be_cmd_req_mcc_ext_create {
 struct be_cmd_req_hdr hdr;
 u16 num_pages;
 u16 cq_id;
 u32 async_event_bitmap[1];
 u8 context[sizeof(struct amap_mcc_context_v1) / 8];
 struct phys_addr pages[8];
} __attribute__((__packed__));

struct be_cmd_resp_mcc_create {
 struct be_cmd_resp_hdr hdr;
 u16 id;
 u16 rsvd0;
} __attribute__((__packed__));





struct be_cmd_req_eth_tx_create {
 struct be_cmd_req_hdr hdr;
 u8 num_pages;
 u8 ulp_num;
 u16 type;
 u16 if_id;
 u8 queue_size;
 u8 rsvd0;
 u32 rsvd1;
 u16 cq_id;
 u16 rsvd2;
 u32 rsvd3[13];
 struct phys_addr pages[8];
} __attribute__((__packed__));

struct be_cmd_resp_eth_tx_create {
 struct be_cmd_resp_hdr hdr;
 u16 cid;
 u16 rid;
 u32 db_offset;
 u32 rsvd0[4];
} __attribute__((__packed__));


struct be_cmd_req_eth_rx_create {
 struct be_cmd_req_hdr hdr;
 u16 cq_id;
 u8 frag_size;
 u8 num_pages;
 struct phys_addr pages[2];
 u32 interface_id;
 u16 max_frame_size;
 u16 rsvd0;
 u32 rss_queue;
} __attribute__((__packed__));

struct be_cmd_resp_eth_rx_create {
 struct be_cmd_resp_hdr hdr;
 u16 id;
 u8 rss_id;
 u8 rsvd0;
} __attribute__((__packed__));



enum {
 QTYPE_EQ = 1,
 QTYPE_CQ,
 QTYPE_TXQ,
 QTYPE_RXQ,
 QTYPE_MCCQ
};

struct be_cmd_req_q_destroy {
 struct be_cmd_req_hdr hdr;
 u16 id;
 u16 bypass_flush;
} __attribute__((__packed__));




enum be_if_flags {
 BE_IF_FLAGS_RSS = 0x4,
 BE_IF_FLAGS_PROMISCUOUS = 0x8,
 BE_IF_FLAGS_BROADCAST = 0x10,
 BE_IF_FLAGS_UNTAGGED = 0x20,
 BE_IF_FLAGS_ULP = 0x40,
 BE_IF_FLAGS_VLAN_PROMISCUOUS = 0x80,
 BE_IF_FLAGS_VLAN = 0x100,
 BE_IF_FLAGS_MCAST_PROMISCUOUS = 0x200,
 BE_IF_FLAGS_PASS_L2_ERRORS = 0x400,
 BE_IF_FLAGS_PASS_L3L4_ERRORS = 0x800,
 BE_IF_FLAGS_MULTICAST = 0x1000,
 BE_IF_FLAGS_DEFQ_RSS = 0x1000000
};
# 677 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_create {
 struct be_cmd_req_hdr hdr;
 u32 version;
 u32 capability_flags;
 u32 enable_flags;
 u8 mac_addr[6];
 u8 rsvd0;
 u8 pmac_invalid;
 u32 vlan_tag;
} __attribute__((__packed__));

struct be_cmd_resp_if_create {
 struct be_cmd_resp_hdr hdr;
 u32 interface_id;
 u32 pmac_id;
};


struct be_cmd_req_if_destroy {
 struct be_cmd_req_hdr hdr;
 u32 interface_id;
};


struct be_port_rxf_stats_v0 {
 u32 rx_bytes_lsd;
 u32 rx_bytes_msd;
 u32 rx_total_frames;
 u32 rx_unicast_frames;
 u32 rx_multicast_frames;
 u32 rx_broadcast_frames;
 u32 rx_crc_errors;
 u32 rx_alignment_symbol_errors;
 u32 rx_pause_frames;
 u32 rx_control_frames;
 u32 rx_in_range_errors;
 u32 rx_out_range_errors;
 u32 rx_frame_too_long;
 u32 rx_address_filtered;
 u32 rx_vlan_filtered;
 u32 rx_dropped_too_small;
 u32 rx_dropped_too_short;
 u32 rx_dropped_header_too_small;
 u32 rx_dropped_tcp_length;
 u32 rx_dropped_runt;
 u32 rx_64_byte_packets;
 u32 rx_65_127_byte_packets;
 u32 rx_128_256_byte_packets;
 u32 rx_256_511_byte_packets;
 u32 rx_512_1023_byte_packets;
 u32 rx_1024_1518_byte_packets;
 u32 rx_1519_2047_byte_packets;
 u32 rx_2048_4095_byte_packets;
 u32 rx_4096_8191_byte_packets;
 u32 rx_8192_9216_byte_packets;
 u32 rx_ip_checksum_errs;
 u32 rx_tcp_checksum_errs;
 u32 rx_udp_checksum_errs;
 u32 rx_non_rss_packets;
 u32 rx_ipv4_packets;
 u32 rx_ipv6_packets;
 u32 rx_ipv4_bytes_lsd;
 u32 rx_ipv4_bytes_msd;
 u32 rx_ipv6_bytes_lsd;
 u32 rx_ipv6_bytes_msd;
 u32 rx_chute1_packets;
 u32 rx_chute2_packets;
 u32 rx_chute3_packets;
 u32 rx_management_packets;
 u32 rx_switched_unicast_packets;
 u32 rx_switched_multicast_packets;
 u32 rx_switched_broadcast_packets;
 u32 tx_bytes_lsd;
 u32 tx_bytes_msd;
 u32 tx_unicastframes;
 u32 tx_multicastframes;
 u32 tx_broadcastframes;
 u32 tx_pauseframes;
 u32 tx_controlframes;
 u32 tx_64_byte_packets;
 u32 tx_65_127_byte_packets;
 u32 tx_128_256_byte_packets;
 u32 tx_256_511_byte_packets;
 u32 tx_512_1023_byte_packets;
 u32 tx_1024_1518_byte_packets;
 u32 tx_1519_2047_byte_packets;
 u32 tx_2048_4095_byte_packets;
 u32 tx_4096_8191_byte_packets;
 u32 tx_8192_9216_byte_packets;
 u32 rx_fifo_overflow;
 u32 rx_input_fifo_overflow;
};

struct be_rxf_stats_v0 {
 struct be_port_rxf_stats_v0 port[2];
 u32 rx_drops_no_pbuf;
 u32 rx_drops_no_txpb;
 u32 rx_drops_no_erx_descr;
 u32 rx_drops_no_tpre_descr;
 u32 management_rx_port_packets;
 u32 management_rx_port_bytes;
 u32 management_rx_port_pause_frames;
 u32 management_rx_port_errors;
 u32 management_tx_port_packets;
 u32 management_tx_port_bytes;
 u32 management_tx_port_pause;
 u32 management_rx_port_rxfifo_overflow;
 u32 rx_drops_too_many_frags;
 u32 rx_drops_invalid_ring;
 u32 forwarded_packets;
 u32 rx_drops_mtu;
 u32 rsvd0[7];
 u32 port0_jabber_events;
 u32 port1_jabber_events;
 u32 rsvd1[6];
};

struct be_erx_stats_v0 {
 u32 rx_drops_no_fragments[44];
 u32 rsvd[4];
};

struct be_pmem_stats {
 u32 eth_red_drops;
 u32 rsvd[5];
};

struct be_hw_stats_v0 {
 struct be_rxf_stats_v0 rxf;
 u32 rsvd[48];
 struct be_erx_stats_v0 erx;
 struct be_pmem_stats pmem;
};

struct be_cmd_req_get_stats_v0 {
 struct be_cmd_req_hdr hdr;
 u8 rsvd[sizeof(struct be_hw_stats_v0)];
};

struct be_cmd_resp_get_stats_v0 {
 struct be_cmd_resp_hdr hdr;
 struct be_hw_stats_v0 hw_stats;
};

struct lancer_pport_stats {
 u32 tx_packets_lo;
 u32 tx_packets_hi;
 u32 tx_unicast_packets_lo;
 u32 tx_unicast_packets_hi;
 u32 tx_multicast_packets_lo;
 u32 tx_multicast_packets_hi;
 u32 tx_broadcast_packets_lo;
 u32 tx_broadcast_packets_hi;
 u32 tx_bytes_lo;
 u32 tx_bytes_hi;
 u32 tx_unicast_bytes_lo;
 u32 tx_unicast_bytes_hi;
 u32 tx_multicast_bytes_lo;
 u32 tx_multicast_bytes_hi;
 u32 tx_broadcast_bytes_lo;
 u32 tx_broadcast_bytes_hi;
 u32 tx_discards_lo;
 u32 tx_discards_hi;
 u32 tx_errors_lo;
 u32 tx_errors_hi;
 u32 tx_pause_frames_lo;
 u32 tx_pause_frames_hi;
 u32 tx_pause_on_frames_lo;
 u32 tx_pause_on_frames_hi;
 u32 tx_pause_off_frames_lo;
 u32 tx_pause_off_frames_hi;
 u32 tx_internal_mac_errors_lo;
 u32 tx_internal_mac_errors_hi;
 u32 tx_control_frames_lo;
 u32 tx_control_frames_hi;
 u32 tx_packets_64_bytes_lo;
 u32 tx_packets_64_bytes_hi;
 u32 tx_packets_65_to_127_bytes_lo;
 u32 tx_packets_65_to_127_bytes_hi;
 u32 tx_packets_128_to_255_bytes_lo;
 u32 tx_packets_128_to_255_bytes_hi;
 u32 tx_packets_256_to_511_bytes_lo;
 u32 tx_packets_256_to_511_bytes_hi;
 u32 tx_packets_512_to_1023_bytes_lo;
 u32 tx_packets_512_to_1023_bytes_hi;
 u32 tx_packets_1024_to_1518_bytes_lo;
 u32 tx_packets_1024_to_1518_bytes_hi;
 u32 tx_packets_1519_to_2047_bytes_lo;
 u32 tx_packets_1519_to_2047_bytes_hi;
 u32 tx_packets_2048_to_4095_bytes_lo;
 u32 tx_packets_2048_to_4095_bytes_hi;
 u32 tx_packets_4096_to_8191_bytes_lo;
 u32 tx_packets_4096_to_8191_bytes_hi;
 u32 tx_packets_8192_to_9216_bytes_lo;
 u32 tx_packets_8192_to_9216_bytes_hi;
 u32 tx_lso_packets_lo;
 u32 tx_lso_packets_hi;
 u32 rx_packets_lo;
 u32 rx_packets_hi;
 u32 rx_unicast_packets_lo;
 u32 rx_unicast_packets_hi;
 u32 rx_multicast_packets_lo;
 u32 rx_multicast_packets_hi;
 u32 rx_broadcast_packets_lo;
 u32 rx_broadcast_packets_hi;
 u32 rx_bytes_lo;
 u32 rx_bytes_hi;
 u32 rx_unicast_bytes_lo;
 u32 rx_unicast_bytes_hi;
 u32 rx_multicast_bytes_lo;
 u32 rx_multicast_bytes_hi;
 u32 rx_broadcast_bytes_lo;
 u32 rx_broadcast_bytes_hi;
 u32 rx_unknown_protos;
 u32 rsvd_69;
 u32 rx_discards_lo;
 u32 rx_discards_hi;
 u32 rx_errors_lo;
 u32 rx_errors_hi;
 u32 rx_crc_errors_lo;
 u32 rx_crc_errors_hi;
 u32 rx_alignment_errors_lo;
 u32 rx_alignment_errors_hi;
 u32 rx_symbol_errors_lo;
 u32 rx_symbol_errors_hi;
 u32 rx_pause_frames_lo;
 u32 rx_pause_frames_hi;
 u32 rx_pause_on_frames_lo;
 u32 rx_pause_on_frames_hi;
 u32 rx_pause_off_frames_lo;
 u32 rx_pause_off_frames_hi;
 u32 rx_frames_too_long_lo;
 u32 rx_frames_too_long_hi;
 u32 rx_internal_mac_errors_lo;
 u32 rx_internal_mac_errors_hi;
 u32 rx_undersize_packets;
 u32 rx_oversize_packets;
 u32 rx_fragment_packets;
 u32 rx_jabbers;
 u32 rx_control_frames_lo;
 u32 rx_control_frames_hi;
 u32 rx_control_frames_unknown_opcode_lo;
 u32 rx_control_frames_unknown_opcode_hi;
 u32 rx_in_range_errors;
 u32 rx_out_of_range_errors;
 u32 rx_address_filtered;
 u32 rx_vlan_filtered;
 u32 rx_dropped_too_small;
 u32 rx_dropped_too_short;
 u32 rx_dropped_header_too_small;
 u32 rx_dropped_invalid_tcp_length;
 u32 rx_dropped_runt;
 u32 rx_ip_checksum_errors;
 u32 rx_tcp_checksum_errors;
 u32 rx_udp_checksum_errors;
 u32 rx_non_rss_packets;
 u32 rsvd_111;
 u32 rx_ipv4_packets_lo;
 u32 rx_ipv4_packets_hi;
 u32 rx_ipv6_packets_lo;
 u32 rx_ipv6_packets_hi;
 u32 rx_ipv4_bytes_lo;
 u32 rx_ipv4_bytes_hi;
 u32 rx_ipv6_bytes_lo;
 u32 rx_ipv6_bytes_hi;
 u32 rx_nic_packets_lo;
 u32 rx_nic_packets_hi;
 u32 rx_tcp_packets_lo;
 u32 rx_tcp_packets_hi;
 u32 rx_iscsi_packets_lo;
 u32 rx_iscsi_packets_hi;
 u32 rx_management_packets_lo;
 u32 rx_management_packets_hi;
 u32 rx_switched_unicast_packets_lo;
 u32 rx_switched_unicast_packets_hi;
 u32 rx_switched_multicast_packets_lo;
 u32 rx_switched_multicast_packets_hi;
 u32 rx_switched_broadcast_packets_lo;
 u32 rx_switched_broadcast_packets_hi;
 u32 num_forwards_lo;
 u32 num_forwards_hi;
 u32 rx_fifo_overflow;
 u32 rx_input_fifo_overflow;
 u32 rx_drops_too_many_frags_lo;
 u32 rx_drops_too_many_frags_hi;
 u32 rx_drops_invalid_queue;
 u32 rsvd_141;
 u32 rx_drops_mtu_lo;
 u32 rx_drops_mtu_hi;
 u32 rx_packets_64_bytes_lo;
 u32 rx_packets_64_bytes_hi;
 u32 rx_packets_65_to_127_bytes_lo;
 u32 rx_packets_65_to_127_bytes_hi;
 u32 rx_packets_128_to_255_bytes_lo;
 u32 rx_packets_128_to_255_bytes_hi;
 u32 rx_packets_256_to_511_bytes_lo;
 u32 rx_packets_256_to_511_bytes_hi;
 u32 rx_packets_512_to_1023_bytes_lo;
 u32 rx_packets_512_to_1023_bytes_hi;
 u32 rx_packets_1024_to_1518_bytes_lo;
 u32 rx_packets_1024_to_1518_bytes_hi;
 u32 rx_packets_1519_to_2047_bytes_lo;
 u32 rx_packets_1519_to_2047_bytes_hi;
 u32 rx_packets_2048_to_4095_bytes_lo;
 u32 rx_packets_2048_to_4095_bytes_hi;
 u32 rx_packets_4096_to_8191_bytes_lo;
 u32 rx_packets_4096_to_8191_bytes_hi;
 u32 rx_packets_8192_to_9216_bytes_lo;
 u32 rx_packets_8192_to_9216_bytes_hi;
};

struct pport_stats_params {
 u16 pport_num;
 u8 rsvd;
 u8 reset_stats;
};

struct lancer_cmd_req_pport_stats {
 struct be_cmd_req_hdr hdr;
 union {
  struct pport_stats_params params;
  u8 rsvd[sizeof(struct lancer_pport_stats)];
 } cmd_params;
};

struct lancer_cmd_resp_pport_stats {
 struct be_cmd_resp_hdr hdr;
 struct lancer_pport_stats pport_stats;
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct lancer_pport_stats*
 pport_stats_from_cmd(struct be_adapter *adapter)
{
 struct lancer_cmd_resp_pport_stats *cmd = adapter->stats_cmd.va;
 return &cmd->pport_stats;
}

struct be_cmd_req_get_cntl_addnl_attribs {
 struct be_cmd_req_hdr hdr;
 u8 rsvd[8];
};

struct be_cmd_resp_get_cntl_addnl_attribs {
 struct be_cmd_resp_hdr hdr;
 u16 ipl_file_number;
 u8 ipl_file_version;
 u8 rsvd0;
 u8 on_die_temperature;
 u8 rsvd1[3];
};

struct be_cmd_req_vlan_config {
 struct be_cmd_req_hdr hdr;
 u8 interface_id;
 u8 promiscuous;
 u8 untagged;
 u8 num_vlan;
 u16 normal_vlan[64];
} __attribute__((__packed__));



struct macaddr {
 u8 byte[6];
};

struct be_cmd_req_rx_filter {
 struct be_cmd_req_hdr hdr;
 u32 global_flags_mask;
 u32 global_flags;
 u32 if_flags_mask;
 u32 if_flags;
 u32 if_id;
 u32 mcast_num;
 struct macaddr mcast_mac[64];
};


struct be_cmd_req_link_status {
 struct be_cmd_req_hdr hdr;
 u32 rsvd;
};

enum {
 PHY_LINK_DUPLEX_NONE = 0x0,
 PHY_LINK_DUPLEX_HALF = 0x1,
 PHY_LINK_DUPLEX_FULL = 0x2
};

enum {
 PHY_LINK_SPEED_ZERO = 0x0,
 PHY_LINK_SPEED_10MBPS = 0x1,
 PHY_LINK_SPEED_100MBPS = 0x2,
 PHY_LINK_SPEED_1GBPS = 0x3,
 PHY_LINK_SPEED_10GBPS = 0x4,
 PHY_LINK_SPEED_20GBPS = 0x5,
 PHY_LINK_SPEED_25GBPS = 0x6,
 PHY_LINK_SPEED_40GBPS = 0x7
};

struct be_cmd_resp_link_status {
 struct be_cmd_resp_hdr hdr;
 u8 physical_port;
 u8 mac_duplex;
 u8 mac_speed;
 u8 mac_fault;
 u8 mgmt_mac_duplex;
 u8 mgmt_mac_speed;
 u16 link_speed;
 u8 logical_link_status;
 u8 rsvd1[3];
} __attribute__((__packed__));



struct be_cmd_req_port_type {
 struct be_cmd_req_hdr hdr;
 __le32 page_num;
 __le32 port;
};

enum {
 TR_PAGE_A0 = 0xa0,
 TR_PAGE_A2 = 0xa2
};
# 1117 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_port_type {
 struct be_cmd_resp_hdr hdr;
 u32 page_num;
 u32 port;
 u8 page_data[256];
};


struct be_cmd_req_get_fw_version {
 struct be_cmd_req_hdr hdr;
 u8 rsvd0[32];
 u8 rsvd1[32];
} __attribute__((__packed__));

struct be_cmd_resp_get_fw_version {
 struct be_cmd_resp_hdr hdr;
 u8 firmware_version_string[32];
 u8 fw_on_flash_version_string[32];
} __attribute__((__packed__));


struct be_cmd_req_set_flow_control {
 struct be_cmd_req_hdr hdr;
 u16 tx_flow_control;
 u16 rx_flow_control;
} __attribute__((__packed__));


struct be_cmd_req_get_flow_control {
 struct be_cmd_req_hdr hdr;
 u32 rsvd;
};

struct be_cmd_resp_get_flow_control {
 struct be_cmd_resp_hdr hdr;
 u16 tx_flow_control;
 u16 rx_flow_control;
} __attribute__((__packed__));


struct be_set_eqd {
 u32 eq_id;
 u32 phase;
 u32 delay_multiplier;
};

struct be_cmd_req_modify_eq_delay {
 struct be_cmd_req_hdr hdr;
 u32 num_eq;
 struct be_set_eqd set_eqd[32];
} __attribute__((__packed__));
# 1177 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_query_fw_cfg {
 struct be_cmd_req_hdr hdr;
 u32 rsvd[31];
};

struct be_cmd_resp_query_fw_cfg {
 struct be_cmd_resp_hdr hdr;
 u32 be_config_number;
 u32 asic_revision;
 u32 phys_port;
 u32 function_mode;
 u32 rsvd[26];
 u32 function_caps;
};
# 1215 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rss_config {
 struct be_cmd_req_hdr hdr;
 u32 if_id;
 u16 enable_rss;
 u16 cpu_table_size_log2;
 u32 hash[10];
 u8 cpu_table[128];
 u8 flush;
 u8 rsvd0[3];
};






struct be_cmd_req_enable_disable_beacon {
 struct be_cmd_req_hdr hdr;
 u8 port_num;
 u8 beacon_state;
 u8 beacon_duration;
 u8 status_duration;
} __attribute__((__packed__));

struct be_cmd_req_get_beacon_state {
 struct be_cmd_req_hdr hdr;
 u8 port_num;
 u8 rsvd0;
 u16 rsvd1;
} __attribute__((__packed__));

struct be_cmd_resp_get_beacon_state {
 struct be_cmd_resp_hdr resp_hdr;
 u8 beacon_state;
 u8 rsvd0[3];
} __attribute__((__packed__));





enum {
 OPTYPE_ISCSI_ACTIVE = 0,
 OPTYPE_REDBOOT = 1,
 OPTYPE_BIOS = 2,
 OPTYPE_PXE_BIOS = 3,
 OPTYPE_OFFSET_SPECIFIED = 7,
 OPTYPE_FCOE_BIOS = 8,
 OPTYPE_ISCSI_BACKUP = 9,
 OPTYPE_FCOE_FW_ACTIVE = 10,
 OPTYPE_FCOE_FW_BACKUP = 11,
 OPTYPE_NCSI_FW = 13,
 OPTYPE_REDBOOT_DIR = 18,
 OPTYPE_REDBOOT_CONFIG = 19,
 OPTYPE_SH_PHY_FW = 21,
 OPTYPE_FLASHISM_JUMPVECTOR = 22,
 OPTYPE_UFI_DIR = 23,
 OPTYPE_PHY_FW = 99
};


enum {
 BE2_BIOS_COMP_MAX_SIZE = 0x40000,
 BE2_REDBOOT_COMP_MAX_SIZE = 0x40000,
 BE2_COMP_MAX_SIZE = 0x140000
};


enum {
 BE3_NCSI_COMP_MAX_SIZE = 0x40000,
 BE3_PHY_FW_COMP_MAX_SIZE = 0x40000,
 BE3_BIOS_COMP_MAX_SIZE = 0x80000,
 BE3_REDBOOT_COMP_MAX_SIZE = 0x100000,
 BE3_COMP_MAX_SIZE = 0x200000
};


enum {
 BE2_REDBOOT_START = 0x8000,
 BE2_FCOE_BIOS_START = 0x80000,
 BE2_ISCSI_PRIMARY_IMAGE_START = 0x100000,
 BE2_ISCSI_BACKUP_IMAGE_START = 0x240000,
 BE2_FCOE_PRIMARY_IMAGE_START = 0x380000,
 BE2_FCOE_BACKUP_IMAGE_START = 0x4c0000,
 BE2_ISCSI_BIOS_START = 0x700000,
 BE2_PXE_BIOS_START = 0x780000
};


enum {
 BE3_REDBOOT_START = 0x40000,
 BE3_PHY_FW_START = 0x140000,
 BE3_ISCSI_PRIMARY_IMAGE_START = 0x200000,
 BE3_ISCSI_BACKUP_IMAGE_START = 0x400000,
 BE3_FCOE_PRIMARY_IMAGE_START = 0x600000,
 BE3_FCOE_BACKUP_IMAGE_START = 0x800000,
 BE3_ISCSI_BIOS_START = 0xc00000,
 BE3_PXE_BIOS_START = 0xc80000,
 BE3_FCOE_BIOS_START = 0xd00000,
 BE3_NCSI_START = 0xf40000
};


enum {
 IMAGE_NCSI = 0x10,
 IMAGE_OPTION_ROM_PXE = 0x20,
 IMAGE_OPTION_ROM_FCOE = 0x21,
 IMAGE_OPTION_ROM_ISCSI = 0x22,
 IMAGE_FLASHISM_JUMPVECTOR = 0x30,
 IMAGE_FIRMWARE_ISCSI = 0xa0,
 IMAGE_FIRMWARE_FCOE = 0xa2,
 IMAGE_FIRMWARE_BACKUP_ISCSI = 0xb0,
 IMAGE_FIRMWARE_BACKUP_FCOE = 0xb2,
 IMAGE_FIRMWARE_PHY = 0xc0,
 IMAGE_REDBOOT_DIR = 0xd0,
 IMAGE_REDBOOT_CONFIG = 0xd1,
 IMAGE_UFI_DIR = 0xd2,
 IMAGE_BOOT_CODE = 0xe2
};

struct controller_id {
 u32 vendor;
 u32 device;
 u32 subvendor;
 u32 subdevice;
};

struct flash_comp {
 unsigned long offset;
 int optype;
 int size;
 int img_type;
};

struct image_hdr {
 u32 imageid;
 u32 imageoffset;
 u32 imagelength;
 u32 image_checksum;
 u8 image_version[32];
};

struct flash_file_hdr_g2 {
 u8 sign[32];
 u32 cksum;
 u32 antidote;
 struct controller_id cont_id;
 u32 file_len;
 u32 chunk_num;
 u32 total_chunks;
 u32 num_imgs;
 u8 build[24];
};






struct flash_file_hdr_g3 {
 u8 sign[52];
 u8 ufi_version[4];
 u32 file_len;
 u32 cksum;
 u32 antidote;
 u32 num_imgs;
 u8 build[24];
 u8 asic_type_rev;
 u8 rsvd[31];
};

struct flash_section_hdr {
 u32 format_rev;
 u32 cksum;
 u32 antidote;
 u32 num_images;
 u8 id_string[128];
 u32 rsvd[4];
} __attribute__((__packed__));

struct flash_section_hdr_g2 {
 u32 format_rev;
 u32 cksum;
 u32 antidote;
 u32 build_num;
 u8 id_string[128];
 u32 rsvd[8];
} __attribute__((__packed__));

struct flash_section_entry {
 u32 type;
 u32 offset;
 u32 pad_size;
 u32 image_size;
 u32 cksum;
 u32 entry_point;
 u16 optype;
 u16 rsvd0;
 u32 rsvd1;
 u8 ver_data[32];
} __attribute__((__packed__));

struct flash_section_info {
 u8 cookie[32];
 struct flash_section_hdr fsec_hdr;
 struct flash_section_entry fsec_entry[32];
} __attribute__((__packed__));

struct flash_section_info_g2 {
 u8 cookie[32];
 struct flash_section_hdr_g2 fsec_hdr;
 struct flash_section_entry fsec_entry[32];
} __attribute__((__packed__));
# 1436 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flashrom_params {
 u32 op_code;
 u32 op_type;
 u32 data_buf_size;
 u32 offset;
};

struct be_cmd_write_flashrom {
 struct be_cmd_req_hdr hdr;
 struct flashrom_params params;
 u8 data_buf[32768];
 u8 rsvd[4];
} __attribute__((__packed__));


struct be_cmd_read_flash_crc {
 struct be_cmd_req_hdr hdr;
 struct flashrom_params params;
 u8 crc[4];
 u8 rsvd[4];
} __attribute__((__packed__));





struct amap_lancer_write_obj_context {
 u8 write_length[24];
 u8 reserved1[7];
 u8 eof;
} __attribute__((__packed__));

struct lancer_cmd_req_write_object {
 struct be_cmd_req_hdr hdr;
 u8 context[sizeof(struct amap_lancer_write_obj_context) / 8];
 u32 write_offset;
 u8 object_name[104];
 u32 descriptor_count;
 u32 buf_len;
 u32 addr_low;
 u32 addr_high;
};



struct lancer_cmd_resp_write_object {
 u8 opcode;
 u8 subsystem;
 u8 rsvd1[2];
 u8 status;
 u8 additional_status;
 u8 rsvd2[2];
 u32 resp_len;
 u32 actual_resp_len;
 u32 actual_write_len;
 u8 change_status;
 u8 rsvd3[3];
};
# 1503 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_read_object {
 struct be_cmd_req_hdr hdr;
 u32 desired_read_len;
 u32 read_offset;
 u8 object_name[104];
 u32 descriptor_count;
 u32 buf_len;
 u32 addr_low;
 u32 addr_high;
};

struct lancer_cmd_resp_read_object {
 u8 opcode;
 u8 subsystem;
 u8 rsvd1[2];
 u8 status;
 u8 additional_status;
 u8 rsvd2[2];
 u32 resp_len;
 u32 actual_resp_len;
 u32 actual_read_len;
 u32 eof;
};

struct lancer_cmd_req_delete_object {
 struct be_cmd_req_hdr hdr;
 u32 rsvd1;
 u32 rsvd2;
 u8 object_name[104];
};


struct be_cmd_req_acpi_wol_magic_config{
 struct be_cmd_req_hdr hdr;
 u32 rsvd0[145];
 u8 magic_mac[6];
 u8 rsvd2[2];
} __attribute__((__packed__));

struct be_cmd_req_acpi_wol_magic_config_v1 {
 struct be_cmd_req_hdr hdr;
 u8 rsvd0[2];
 u8 query_options;
 u8 rsvd1[5];
 u32 rsvd2[288];
 u8 magic_mac[6];
 u8 rsvd3[22];
} __attribute__((__packed__));

struct be_cmd_resp_acpi_wol_magic_config_v1 {
 struct be_cmd_resp_hdr hdr;
 u8 rsvd0[2];
 u8 wol_settings;
 u8 rsvd1[5];
 u32 rsvd2[288];
 u8 magic_mac[6];
 u8 rsvd3[22];
} __attribute__((__packed__));
# 1574 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_loopback_test {
 struct be_cmd_req_hdr hdr;
 u32 loopback_type;
 u32 num_pkts;
 u64 pattern;
 u32 src_port;
 u32 dest_port;
 u32 pkt_size;
};

struct be_cmd_resp_loopback_test {
 struct be_cmd_resp_hdr resp_hdr;
 u32 status;
 u32 num_txfer;
 u32 num_rx;
 u32 miscomp_off;
 u32 ticks_compl;
};

struct be_cmd_req_set_lmode {
 struct be_cmd_req_hdr hdr;
 u8 src_port;
 u8 dest_port;
 u8 loopback_type;
 u8 loopback_state;
};


struct be_cmd_req_ddrdma_test {
 struct be_cmd_req_hdr hdr;
 u64 pattern;
 u32 byte_count;
 u32 rsvd0;
 u8 snd_buff[4096];
 u8 rsvd1[4096];
};

struct be_cmd_resp_ddrdma_test {
 struct be_cmd_resp_hdr hdr;
 u64 pattern;
 u32 byte_cnt;
 u32 snd_err;
 u8 rsvd0[4096];
 u8 rcv_buff[4096];
};




struct be_cmd_req_seeprom_read {
 struct be_cmd_req_hdr hdr;
 u8 rsvd0[1024];
};

struct be_cmd_resp_seeprom_read {
 struct be_cmd_req_hdr hdr;
 u8 seeprom_data[1024];
};

enum {
 PHY_TYPE_CX4_10GB = 0,
 PHY_TYPE_XFP_10GB,
 PHY_TYPE_SFP_1GB,
 PHY_TYPE_SFP_PLUS_10GB,
 PHY_TYPE_KR_10GB,
 PHY_TYPE_KX4_10GB,
 PHY_TYPE_BASET_10GB,
 PHY_TYPE_BASET_1GB,
 PHY_TYPE_BASEX_1GB,
 PHY_TYPE_SGMII,
 PHY_TYPE_QSFP,
 PHY_TYPE_KR4_40GB,
 PHY_TYPE_KR2_20GB,
 PHY_TYPE_TN_8022,
 PHY_TYPE_DISABLED = 255
};
# 1678 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_phy_info {
 struct be_cmd_req_hdr hdr;
 u8 rsvd0[24];
};

struct be_phy_info {
 u16 phy_type;
 u16 interface_type;
 u32 misc_params;
 u16 ext_phy_details;
 u16 rsvd;
 u16 auto_speeds_supported;
 u16 fixed_speeds_supported;
 u32 future_use[2];
};

struct be_cmd_resp_get_phy_info {
 struct be_cmd_req_hdr hdr;
 struct be_phy_info phy_info;
};





struct be_cmd_req_set_qos {
 struct be_cmd_req_hdr hdr;
 u32 valid_bits;
 u32 max_bps_nic;
 u32 rsvd[7];
};


struct mgmt_hba_attribs {
 u32 rsvd0[24];
 u8 controller_model_number[32];
 u32 rsvd1[16];
 u32 controller_serial_number[8];
 u32 rsvd2[55];
 u8 rsvd3[3];
 u8 phy_port;
 u32 rsvd4[15];
 u8 rsvd5[2];
 u8 pci_funcnum;
 u8 rsvd6;
 u32 rsvd7[6];
} __attribute__((__packed__));

struct mgmt_controller_attrib {
 struct mgmt_hba_attribs hba_attribs;
 u32 rsvd0[10];
} __attribute__((__packed__));

struct be_cmd_req_cntl_attribs {
 struct be_cmd_req_hdr hdr;
};

struct be_cmd_resp_cntl_attribs {
 struct be_cmd_resp_hdr hdr;
 struct mgmt_controller_attrib attribs;
};





struct be_cmd_req_set_func_cap {
 struct be_cmd_req_hdr hdr;
 u32 valid_cap_flags;
 u32 cap_flags;
 u8 rsvd[212];
};

struct be_cmd_resp_set_func_cap {
 struct be_cmd_resp_hdr hdr;
 u32 valid_cap_flags;
 u32 cap_flags;
 u8 rsvd[212];
};


enum {
 BE_PRIV_DEFAULT = 0x1,
 BE_PRIV_LNKQUERY = 0x2,
 BE_PRIV_LNKSTATS = 0x4,
 BE_PRIV_LNKMGMT = 0x8,
 BE_PRIV_LNKDIAG = 0x10,
 BE_PRIV_UTILQUERY = 0x20,
 BE_PRIV_FILTMGMT = 0x40,
 BE_PRIV_IFACEMGMT = 0x80,
 BE_PRIV_VHADM = 0x100,
 BE_PRIV_DEVCFG = 0x200,
 BE_PRIV_DEVSEC = 0x400
};




struct be_cmd_priv_map {
 u8 opcode;
 u8 subsystem;
 u32 priv_mask;
};

struct be_cmd_req_get_fn_privileges {
 struct be_cmd_req_hdr hdr;
 u32 rsvd;
};

struct be_cmd_resp_get_fn_privileges {
 struct be_cmd_resp_hdr hdr;
 u32 privilege_mask;
};

struct be_cmd_req_set_fn_privileges {
 struct be_cmd_req_hdr hdr;
 u32 privileges;
 u32 privileges_lancer;
};



struct be_cmd_req_get_mac_list {
 struct be_cmd_req_hdr hdr;
 u8 mac_type;
 u8 perm_override;
 u16 iface_id;
 u32 mac_id;
 u32 rsvd[3];
} __attribute__((__packed__));

struct get_list_macaddr {
 u16 mac_addr_size;
 union {
  u8 macaddr[6];
  struct {
   u8 rsvd[2];
   u32 mac_id;
  } __attribute__((__packed__)) s_mac_id;
 } __attribute__((__packed__)) mac_addr_id;
} __attribute__((__packed__));

struct be_cmd_resp_get_mac_list {
 struct be_cmd_resp_hdr hdr;
 struct get_list_macaddr fd_macaddr;
 struct get_list_macaddr macid_macaddr;
 u8 true_mac_count;
 u8 pseudo_mac_count;
 u8 mac_list_size;
 u8 rsvd;

 struct get_list_macaddr macaddr_list[64];
} __attribute__((__packed__));

struct be_cmd_req_set_mac_list {
 struct be_cmd_req_hdr hdr;
 u8 mac_count;
 u8 rsvd1;
 u16 rsvd2;
 struct macaddr mac[64];
} __attribute__((__packed__));
# 1848 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct amap_set_hsw_context {
 u8 interface_id[16];
 u8 rsvd0[8];
 u8 mac_spoofchk[2];
 u8 rsvd1[4];
 u8 pvid_valid;
 u8 pport;
 u8 rsvd2[6];
 u8 port_fwd_type[3];
 u8 rsvd3[5];
 u8 vlan_spoofchk[2];
 u8 pvid[16];
 u8 rsvd4[32];
 u8 rsvd5[32];
 u8 rsvd6[32];
} __attribute__((__packed__));

struct be_cmd_req_set_hsw_config {
 struct be_cmd_req_hdr hdr;
 u8 context[sizeof(struct amap_set_hsw_context) / 8];
} __attribute__((__packed__));

struct amap_get_hsw_req_context {
 u8 interface_id[16];
 u8 rsvd0[14];
 u8 pvid_valid;
 u8 pport;
} __attribute__((__packed__));

struct amap_get_hsw_resp_context {
 u8 rsvd0[6];
 u8 port_fwd_type[3];
 u8 rsvd1[5];
 u8 spoofchk;
 u8 rsvd2;
 u8 pvid[16];
 u8 rsvd3[32];
 u8 rsvd4[32];
 u8 rsvd5[32];
} __attribute__((__packed__));

struct be_cmd_req_get_hsw_config {
 struct be_cmd_req_hdr hdr;
 u8 context[sizeof(struct amap_get_hsw_req_context) / 8];
} __attribute__((__packed__));

struct be_cmd_resp_get_hsw_config {
 struct be_cmd_resp_hdr hdr;
 u8 context[sizeof(struct amap_get_hsw_resp_context) / 8];
 u32 rsvd;
};


struct be_cmd_req_get_port_name {
 struct be_cmd_req_hdr hdr;
 u32 rsvd0;
};

struct be_cmd_resp_get_port_name {
 struct be_cmd_req_hdr hdr;
 u8 port_name[4];
};



struct be_port_rxf_stats_v1 {
 u32 rsvd0[12];
 u32 rx_crc_errors;
 u32 rx_alignment_symbol_errors;
 u32 rx_pause_frames;
 u32 rx_priority_pause_frames;
 u32 rx_control_frames;
 u32 rx_in_range_errors;
 u32 rx_out_range_errors;
 u32 rx_frame_too_long;
 u32 rx_address_filtered;
 u32 rx_dropped_too_small;
 u32 rx_dropped_too_short;
 u32 rx_dropped_header_too_small;
 u32 rx_dropped_tcp_length;
 u32 rx_dropped_runt;
 u32 rsvd1[10];
 u32 rx_ip_checksum_errs;
 u32 rx_tcp_checksum_errs;
 u32 rx_udp_checksum_errs;
 u32 rsvd2[7];
 u32 rx_switched_unicast_packets;
 u32 rx_switched_multicast_packets;
 u32 rx_switched_broadcast_packets;
 u32 rsvd3[3];
 u32 tx_pauseframes;
 u32 tx_priority_pauseframes;
 u32 tx_controlframes;
 u32 rsvd4[10];
 u32 rxpp_fifo_overflow_drop;
 u32 rx_input_fifo_overflow_drop;
 u32 pmem_fifo_overflow_drop;
 u32 jabber_events;
 u32 rsvd5[3];
};


struct be_rxf_stats_v1 {
 struct be_port_rxf_stats_v1 port[4];
 u32 rsvd0[2];
 u32 rx_drops_no_pbuf;
 u32 rx_drops_no_txpb;
 u32 rx_drops_no_erx_descr;
 u32 rx_drops_no_tpre_descr;
 u32 rsvd1[6];
 u32 rx_drops_too_many_frags;
 u32 rx_drops_invalid_ring;
 u32 forwarded_packets;
 u32 rx_drops_mtu;
 u32 rsvd2[14];
};

struct be_erx_stats_v1 {
 u32 rx_drops_no_fragments[68];
 u32 rsvd[4];
};

struct be_port_rxf_stats_v2 {
 u32 rsvd0[10];
 u32 roce_bytes_received_lsd;
 u32 roce_bytes_received_msd;
 u32 rsvd1[5];
 u32 roce_frames_received;
 u32 rx_crc_errors;
 u32 rx_alignment_symbol_errors;
 u32 rx_pause_frames;
 u32 rx_priority_pause_frames;
 u32 rx_control_frames;
 u32 rx_in_range_errors;
 u32 rx_out_range_errors;
 u32 rx_frame_too_long;
 u32 rx_address_filtered;
 u32 rx_dropped_too_small;
 u32 rx_dropped_too_short;
 u32 rx_dropped_header_too_small;
 u32 rx_dropped_tcp_length;
 u32 rx_dropped_runt;
 u32 rsvd2[10];
 u32 rx_ip_checksum_errs;
 u32 rx_tcp_checksum_errs;
 u32 rx_udp_checksum_errs;
 u32 rsvd3[7];
 u32 rx_switched_unicast_packets;
 u32 rx_switched_multicast_packets;
 u32 rx_switched_broadcast_packets;
 u32 rsvd4[3];
 u32 tx_pauseframes;
 u32 tx_priority_pauseframes;
 u32 tx_controlframes;
 u32 rsvd5[10];
 u32 rxpp_fifo_overflow_drop;
 u32 rx_input_fifo_overflow_drop;
 u32 pmem_fifo_overflow_drop;
 u32 jabber_events;
 u32 rsvd6[3];
 u32 rx_drops_payload_size;
 u32 rx_drops_clipped_header;
 u32 rx_drops_crc;
 u32 roce_drops_payload_len;
 u32 roce_drops_crc;
 u32 rsvd7[19];
};

struct be_rxf_stats_v2 {
 struct be_port_rxf_stats_v2 port[4];
 u32 rsvd0[2];
 u32 rx_drops_no_pbuf;
 u32 rx_drops_no_txpb;
 u32 rx_drops_no_erx_descr;
 u32 rx_drops_no_tpre_descr;
 u32 rsvd1[6];
 u32 rx_drops_too_many_frags;
 u32 rx_drops_invalid_ring;
 u32 forwarded_packets;
 u32 rx_drops_mtu;
 u32 rsvd2[35];
};

struct be_hw_stats_v1 {
 struct be_rxf_stats_v1 rxf;
 u32 rsvd0[48];
 struct be_erx_stats_v1 erx;
 struct be_pmem_stats pmem;
 u32 rsvd1[18];
};

struct be_cmd_req_get_stats_v1 {
 struct be_cmd_req_hdr hdr;
 u8 rsvd[sizeof(struct be_hw_stats_v1)];
};

struct be_cmd_resp_get_stats_v1 {
 struct be_cmd_resp_hdr hdr;
 struct be_hw_stats_v1 hw_stats;
};

struct be_erx_stats_v2 {
 u32 rx_drops_no_fragments[136];
 u32 rsvd[3];
};

struct be_hw_stats_v2 {
 struct be_rxf_stats_v2 rxf;
 u32 rsvd0[48];
 struct be_erx_stats_v2 erx;
 struct be_pmem_stats pmem;
 u32 rsvd1[18];
};

struct be_cmd_req_get_stats_v2 {
 struct be_cmd_req_hdr hdr;
 u8 rsvd[sizeof(struct be_hw_stats_v2)];
};

struct be_cmd_resp_get_stats_v2 {
 struct be_cmd_resp_hdr hdr;
 struct be_hw_stats_v2 hw_stats;
};
# 2079 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_mode {
 u8 mode;
 u8 rsvd0;
 u16 port_mask;
 u32 dbg_lvl;
 u64 fun_mask;
} __attribute__((__packed__));

struct ext_fat_modules {
 u8 modules_str[32];
 u32 modules_id;
 u32 num_modes;
 struct ext_fat_mode trace_lvl[4];
} __attribute__((__packed__));

struct be_fat_conf_params {
 u32 max_log_entries;
 u32 log_entry_size;
 u8 log_type;
 u8 max_log_funs;
 u8 max_log_ports;
 u8 rsvd0;
 u32 supp_modes;
 u32 num_modules;
 struct ext_fat_modules module[27];
} __attribute__((__packed__));

struct be_cmd_req_get_ext_fat_caps {
 struct be_cmd_req_hdr hdr;
 u32 parameter_type;
};

struct be_cmd_resp_get_ext_fat_caps {
 struct be_cmd_resp_hdr hdr;
 struct be_fat_conf_params get_params;
};

struct be_cmd_req_set_ext_fat_caps {
 struct be_cmd_req_hdr hdr;
 struct be_fat_conf_params set_params;
};
# 2138 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_res_desc_hdr {
 u8 desc_type;
 u8 desc_len;
} __attribute__((__packed__));

struct be_port_res_desc {
 struct be_res_desc_hdr hdr;
 u8 rsvd0;
 u8 flags;
 u8 link_num;
 u8 mc_type;
 u16 rsvd1;







 u8 nv_flags;
 u8 rsvd2;
 __le16 nv_port;
 u32 rsvd3[19];
} __attribute__((__packed__));

struct be_pcie_res_desc {
 struct be_res_desc_hdr hdr;
 u8 rsvd0;
 u8 flags;
 u16 rsvd1;
 u8 pf_num;
 u8 rsvd2;
 u32 rsvd3;
 u8 sriov_state;
 u8 pf_state;
 u8 pf_type;
 u8 rsvd4;
 u16 num_vfs;
 u16 rsvd5;
 u32 rsvd6[17];
} __attribute__((__packed__));

struct be_nic_res_desc {
 struct be_res_desc_hdr hdr;
 u8 rsvd1;


 u8 flags;
 u8 vf_num;
 u8 rsvd2;
 u8 pf_num;
 u8 rsvd3;
 u16 unicast_mac_count;
 u8 rsvd4[6];
 u16 mcc_count;
 u16 vlan_count;
 u16 mcast_mac_count;
 u16 txq_count;
 u16 rq_count;
 u16 rssq_count;
 u16 lro_count;
 u16 cq_count;
 u16 toe_conn_count;
 u16 eq_count;
 u16 vlan_id;
 u16 iface_count;
 u32 cap_flags;
 u8 link_param;
 u8 rsvd6;
 u16 channel_id_param;
 u32 bw_min;
 u32 bw_max;
 u8 acpi_params;
 u8 wol_param;
 u16 rsvd7;
 u16 tunnel_iface_count;
 u16 direct_tenant_iface_count;
 u32 rsvd8[6];
} __attribute__((__packed__));


enum mc_type {
 MC_NONE = 0x01,
 UMC = 0x02,
 FLEX10 = 0x03,
 vNIC1 = 0x04,
 nPAR = 0x05,
 UFP = 0x06,
 vNIC2 = 0x07
};


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool be_is_mc(struct be_adapter *adapter)
{
 return adapter->mc_type > MC_NONE;
}

struct be_cmd_req_get_func_config {
 struct be_cmd_req_hdr hdr;
};

struct be_cmd_resp_get_func_config {
 struct be_cmd_resp_hdr hdr;
 u32 desc_count;
 u8 func_param[264 * 88];
};

enum {
 RESOURCE_LIMITS,
 RESOURCE_MODIFIABLE
};

struct be_cmd_req_get_profile_config {
 struct be_cmd_req_hdr hdr;
 u8 rsvd;



 u8 type;
 u16 rsvd1;
};

struct be_cmd_resp_get_profile_config {
 struct be_cmd_resp_hdr hdr;
 __le16 desc_count;
 u16 rsvd;
 u8 func_param[264 * 88];
};


struct be_cmd_req_set_profile_config {
 struct be_cmd_req_hdr hdr;
 u32 rsvd;
 u32 desc_count;
 u8 desc[2 * 88];
} __attribute__((__packed__));

struct be_cmd_req_get_active_profile {
 struct be_cmd_req_hdr hdr;
 u32 rsvd;
} __attribute__((__packed__));

struct be_cmd_resp_get_active_profile {
 struct be_cmd_resp_hdr hdr;
 u16 active_profile_id;
 u16 next_profile_id;
} __attribute__((__packed__));

struct be_cmd_enable_disable_vf {
 struct be_cmd_req_hdr hdr;
 u8 enable;
 u8 rsvd[3];
};

struct be_cmd_req_intr_set {
 struct be_cmd_req_hdr hdr;
 u8 intr_enabled;
 u8 rsvd[3];
};

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool check_privilege(struct be_adapter *adapter, u32 flags)
{
 return flags & adapter->cmd_privileges ? true : false;
}


struct be_if_desc {
 u32 if_id;
 u32 cap_flags;
 u32 en_flags;
};

struct be_cmd_req_get_iface_list {
 struct be_cmd_req_hdr hdr;
};

struct be_cmd_resp_get_iface_list {
 struct be_cmd_req_hdr hdr;
 u32 if_cnt;
 struct be_if_desc if_desc;
};





struct be_req_ue_recovery {
 u32 uer;
 u32 rsvd;
};

struct be_cmd_req_set_features {
 struct be_cmd_req_hdr hdr;
 u32 features;
 u32 parameter_len;
 union {
  struct be_req_ue_recovery req;
  u32 rsvd[2];
 } parameter;
};

struct be_resp_ue_recovery {
 u32 uer;
 u16 ue2rp;
 u16 ue2sr;
};

struct be_cmd_resp_set_features {
 struct be_cmd_resp_hdr hdr;
 u32 features;
 u32 parameter_len;
 union {
  struct be_resp_ue_recovery resp;
  u32 rsvd[2];
 } parameter;
};




struct be_cmd_req_set_ll_link {
 struct be_cmd_req_hdr hdr;
 u32 link_config;
};





struct be_cmd_req_manage_iface_filters {
 struct be_cmd_req_hdr hdr;
 u8 op;
 u8 rsvd0;
 u8 flags;
 u8 rsvd1;
 u32 tunnel_iface_id;
 u32 target_iface_id;
 u8 mac[6];
 u16 vlan_tag;
 u32 tenant_id;
 u32 filter_id;
 u32 cap_flags;
 u32 cap_control_flags;
} __attribute__((__packed__));

u16 be_POST_stage_get(struct be_adapter *adapter);
int be_pci_fnum_get(struct be_adapter *adapter);
int be_fw_wait_ready(struct be_adapter *adapter);
int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
     bool permanent, u32 if_handle, u32 pmac_id);
int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr, u32 if_id,
      u32 *pmac_id, u32 domain);
int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id,
      u32 domain);
int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,
       u32 *if_handle, u32 domain);
int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle, u32 domain);
int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
int be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,
       struct be_queue_info *eq, bool no_delay,
       int num_cqe_dma_coalesce);
int be_cmd_mccq_create(struct be_adapter *adapter, struct be_queue_info *mccq,
         struct be_queue_info *cq);
int be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo);
int be_cmd_rxq_create(struct be_adapter *adapter, struct be_queue_info *rxq,
        u16 cq_id, u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
       int type);
int be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q);
int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
        u8 *link_status, u32 dom);
int be_cmd_reset(struct be_adapter *adapter);
int be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd);
int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
          struct be_dma_mem *nonemb_cmd);
int be_cmd_get_fw_ver(struct be_adapter *adapter);
int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *, int num);
int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,
         u32 num, u32 domain);
int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
int be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc);
int be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc);
int be_cmd_query_fw_cfg(struct be_adapter *adapter);
int be_cmd_reset_function(struct be_adapter *adapter);
int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
        u32 rss_hash_opts, u16 table_size, const u8 *rss_hkey);
int be_process_mcc(struct be_adapter *adapter);
int be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num, u8 beacon,
       u8 status, u8 state);
int be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num,
       u32 *state);
int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,
          u8 page_num, u8 *data);
int be_cmd_query_cable_type(struct be_adapter *adapter);
int be_cmd_query_sfp_info(struct be_adapter *adapter);
int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
      u32 data_size, u32 data_offset, const char *obj_name,
      u32 *data_read, u32 *eof, u8 *addn_status);
int lancer_fw_download(struct be_adapter *adapter, const struct firmware *fw);
int be_fw_download(struct be_adapter *adapter, const struct firmware *fw);
int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
       struct be_dma_mem *nonemb_cmd);
int be_cmd_fw_init(struct be_adapter *adapter);
int be_cmd_fw_clean(struct be_adapter *adapter);
void be_async_mcc_enable(struct be_adapter *adapter);
void be_async_mcc_disable(struct be_adapter *adapter);
int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
    u32 loopback_type, u32 pkt_size, u32 num_pkts,
    u64 pattern);
int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern, u32 byte_cnt,
   struct be_dma_mem *cmd);
int be_cmd_get_seeprom_data(struct be_adapter *adapter,
       struct be_dma_mem *nonemb_cmd);
int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
   u8 loopback_type, u8 enable);
int be_cmd_get_phy_info(struct be_adapter *adapter);
int be_cmd_config_qos(struct be_adapter *adapter, u32 max_rate,
        u16 link_speed, u8 domain);
void be_detect_error(struct be_adapter *adapter);
int be_cmd_get_die_temperature(struct be_adapter *adapter);
int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
int be_cmd_get_fat_dump_len(struct be_adapter *adapter, u32 *dump_size);
int be_cmd_get_fat_dump(struct be_adapter *adapter, u32 buf_len, void *buf);
int be_cmd_req_native_mode(struct be_adapter *adapter);
int be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,
        u32 domain);
int be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,
        u32 vf_num);
int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
        bool *pmac_id_active, u32 *pmac_id,
        u32 if_handle, u8 domain);
int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id, u8 *mac,
     u32 if_handle, bool active, u32 domain);
int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array, u8 mac_count,
   u32 domain);
int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom);
int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid, u32 domain,
     u16 intf_id, u16 hsw_mode, u8 spoofchk);
int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid, u32 domain,
     u16 intf_id, u8 *mode, bool *spoofchk);
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level);
int be_cmd_get_fw_log_level(struct be_adapter *adapter);
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
       struct be_dma_mem *cmd);
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
       struct be_dma_mem *cmd,
       struct be_fat_conf_params *cfgs);
int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
int lancer_initiate_dump(struct be_adapter *adapter);
int lancer_delete_dump(struct be_adapter *adapter);
bool dump_present(struct be_adapter *adapter);
int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
int be_cmd_query_port_name(struct be_adapter *adapter);
int be_cmd_get_func_config(struct be_adapter *adapter,
      struct be_resources *res);
int be_cmd_get_profile_config(struct be_adapter *adapter,
         struct be_resources *res,
         struct be_port_resources *port_res,
         u8 profile_type, u8 query, u8 domain);
int be_cmd_get_active_profile(struct be_adapter *adapter, u16 *profile);
int be_cmd_get_if_id(struct be_adapter *adapter, struct be_vf_cfg *vf_cfg,
       int vf_num);
int be_cmd_enable_vf(struct be_adapter *adapter, u8 domain);
int be_cmd_intr_set(struct be_adapter *adapter, bool intr_enable);
int be_cmd_set_logical_link_config(struct be_adapter *adapter,
       int link_state, u8 domain);
int be_cmd_set_vxlan_port(struct be_adapter *adapter, __be16 port);
int be_cmd_manage_iface(struct be_adapter *adapter, u32 iface, u8 op);
int be_cmd_set_sriov_config(struct be_adapter *adapter,
       struct be_resources res, u16 num_vfs,
       struct be_resources *vft_res);
int be_cmd_set_features(struct be_adapter *adapter);
# 17 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c" 2

const char * const be_misconfig_evt_port_state[] = {
 "Physical Link is functional",
 "Optics faulted/incorrectly installed/not installed - Reseat optics. If issue not resolved, replace.",
 "Optics of two types installed  Remove one optic or install matching pair of optics.",
 "Incompatible optics  Replace with compatible optics for card to function.",
 "Unqualified optics  Replace with Avago optics for Warranty and Technical Support.",
 "Uncertified optics  Replace with Avago-certified optics to enable link operation."
};

static char *be_port_misconfig_evt_severity[] = {
 "KERN_WARN",
 "KERN_INFO",
 "KERN_ERR",
 "KERN_WARN"
};

static char *phy_state_oper_desc[] = {
 "Link is non-operational",
 "Link is operational",
 ""
};

static struct be_cmd_priv_map cmd_priv_map[] = {
 {
  12,
  0x3,
  BE_PRIV_LNKMGMT | BE_PRIV_VHADM |
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  37,
  0x1,
  BE_PRIV_LNKQUERY | BE_PRIV_VHADM |
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  36,
  0x1,
  BE_PRIV_LNKMGMT | BE_PRIV_VHADM |
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  18,
  0x3,
  BE_PRIV_LNKMGMT | BE_PRIV_VHADM |
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  102,
  0x1,
  BE_PRIV_LNKMGMT | BE_PRIV_VHADM |
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  17,
  0xb,
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  18,
  0xb,
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  19,
  0xb,
  BE_PRIV_DEVCFG | BE_PRIV_DEVSEC
 },
 {
  153,
  0x1,
  BE_PRIV_DEVCFG | BE_PRIV_VHADM |
  BE_PRIV_DEVSEC
 },
 {
  125,
  0x1,
  BE_PRIV_DEVCFG
 }
};

static bool be_cmd_allowed(struct be_adapter *adapter, u8 opcode, u8 subsystem)
{
 int i;
 int num_entries = (sizeof(cmd_priv_map) / sizeof((cmd_priv_map)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((cmd_priv_map)), typeof(&(cmd_priv_map)[0])))); }))));
 u32 cmd_privileges = adapter->cmd_privileges;

 for (i = 0; i < num_entries; i++)
  if (opcode == cmd_priv_map[i].opcode &&
      subsystem == cmd_priv_map[i].subsystem)
   if (!(cmd_privileges & cmd_priv_map[i].priv_mask))
    return false;

 return true;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void *embedded_payload(struct be_mcc_wrb *wrb)
{
 return wrb->payload.embedded_payload;
}

static int be_mcc_notify(struct be_adapter *adapter)
{
 struct be_queue_info *mccq = &adapter->mcc_obj.q;
 u32 val = 0;

 if (be_check_error(adapter, (1 | ((((1UL))) << (1)) | ((((1UL))) << (2)) | ((((1UL))) << (3)))))
  return -5;

 val |= mccq->id & 0x7FF;
 val |= 1 << (16);

 __asm__ __volatile__ ("sync" : : : "memory");
 iowrite32(val, adapter->db + 0x140);

 return 0;
}




static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool be_mcc_compl_is_new(struct be_mcc_compl *compl)
{
 u32 flags;

 if (compl->flags != 0) {
  flags = (__builtin_constant_p((__u32)(( __u32)(__le32)(compl->flags))) ? ((__u32)( (((__u32)(( __u32)(__le32)(compl->flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(compl->flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(compl->flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(compl->flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(compl->flags)));
  if (flags & ((((1UL))) << (31))) {
   compl->flags = flags;
   return true;
  }
 }
 return false;
}


static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void be_mcc_compl_use(struct be_mcc_compl *compl)
{
 compl->flags = 0;
}

static struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0, u32 tag1)
{
 unsigned long addr;

 addr = tag1;
 addr = ((addr << 16) << 16) | tag0;
 return (void *)addr;
}

static bool be_skip_err_log(u8 opcode, u16 base_status, u16 addl_status)
{
 if (base_status == MCC_STATUS_NOT_SUPPORTED ||
     base_status == MCC_STATUS_ILLEGAL_REQUEST ||
     addl_status == MCC_ADDL_STATUS_TOO_MANY_INTERFACES ||
     addl_status == MCC_ADDL_STATUS_INSUFFICIENT_VLANS ||
     (opcode == 7 &&
     (base_status == MCC_STATUS_ILLEGAL_FIELD ||
      addl_status == MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH)))
  return true;
 else
  return false;
}




static void be_async_cmd_process(struct be_adapter *adapter,
     struct be_mcc_compl *compl,
     struct be_cmd_resp_hdr *resp_hdr)
{
 enum mcc_base_status base_status = ((enum mcc_base_status) (compl->status > 0 ? (compl->status & 0xFFFF) : 0));
 u8 opcode = 0, subsystem = 0;

 if (resp_hdr) {
  opcode = resp_hdr->opcode;
  subsystem = resp_hdr->subsystem;
 }

 if (opcode == 18 &&
     subsystem == 0xb) {
  complete(&adapter->et_cmd_compl);
  return;
 }

 if (opcode == 19 &&
     subsystem == 0xb) {
  complete(&adapter->et_cmd_compl);
  return;
 }

 if ((opcode == 7 ||
      opcode == 172) &&
     subsystem == 0x1) {
  adapter->flash_status = compl->status;
  complete(&adapter->et_cmd_compl);
  return;
 }

 if ((opcode == 4 ||
      opcode == 18) &&
     subsystem == 0x3 &&
     base_status == MCC_STATUS_SUCCESS) {
  be_parse_stats(adapter);
  adapter->stats_cmd_sent = false;
  return;
 }

 if (opcode == 121 &&
     subsystem == 0x1) {
  if (base_status == MCC_STATUS_SUCCESS) {
   struct be_cmd_resp_get_cntl_addnl_attribs *resp =
       (void *)resp_hdr;
   adapter->hwmon_info.be_on_die_temp =
      resp->on_die_temperature;
  } else {
   adapter->be_get_temp_freq = 0;
   adapter->hwmon_info.be_on_die_temp =
      0xFF;
  }
  return;
 }
}

static int be_mcc_compl_process(struct be_adapter *adapter,
    struct be_mcc_compl *compl)
{
 enum mcc_base_status base_status;
 enum mcc_addl_status addl_status;
 struct be_cmd_resp_hdr *resp_hdr;
 u8 opcode = 0, subsystem = 0;



 swap_dws(compl, 4);

 base_status = ((enum mcc_base_status) (compl->status > 0 ? (compl->status & 0xFFFF) : 0));
 addl_status = ((enum mcc_addl_status) (compl->status > 0 ? (compl->status >> 16) & 0xFF : 0));

 resp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);
 if (resp_hdr) {
  opcode = resp_hdr->opcode;
  subsystem = resp_hdr->subsystem;
 }

 be_async_cmd_process(adapter, compl, resp_hdr);

 if (base_status != MCC_STATUS_SUCCESS &&
     !be_skip_err_log(opcode, base_status, addl_status)) {
  if (base_status == MCC_STATUS_UNAUTHORIZED_REQUEST ||
      addl_status == MCC_ADDL_STATUS_INSUFFICIENT_PRIVILEGES) {
   _dev_warn(&adapter->pdev->dev, "VF is not privileged to issue opcode %d-%d\n", opcode, subsystem);


  } else {
   _dev_err(&adapter->pdev->dev, "opcode %d-%d failed:status %d-%d\n", opcode, subsystem, base_status, addl_status);


  }
 }
 return compl->status;
}


static void be_async_link_state_process(struct be_adapter *adapter,
     struct be_mcc_compl *compl)
{
 struct be_async_event_link_state *evt =
   (struct be_async_event_link_state *)compl;


 adapter->phy.link_speed = -1;






 if (!((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) &&
     !(evt->port_link_status & 0x2))
  return;




 if (adapter->flags & ((((1UL))) << (1)))
  be_link_status_update(adapter,
          evt->port_link_status & 0x1);
}

static void be_async_port_misconfig_event_process(struct be_adapter *adapter,
        struct be_mcc_compl *compl)
{
 struct be_async_event_misconfig_port *evt =
   (struct be_async_event_misconfig_port *)compl;
 u32 sfp_misconfig_evt_word1 = (__builtin_constant_p((__u32)(( __u32)(__le32)(evt->event_data_word1))) ? ((__u32)( (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(evt->event_data_word1)));
 u32 sfp_misconfig_evt_word2 = (__builtin_constant_p((__u32)(( __u32)(__le32)(evt->event_data_word2))) ? ((__u32)( (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(evt->event_data_word2)));
 u8 phy_oper_state = 0x2;
 struct device *dev = &adapter->pdev->dev;
 u8 msg_severity = 0x1;
 u8 phy_state_info;
 u8 new_phy_state;

 new_phy_state =
  (sfp_misconfig_evt_word1 >> (adapter->hba_port_num * 8)) & 0xff;

 if (new_phy_state == adapter->phy_state)
  return;

 adapter->phy_state = new_phy_state;


 if (!sfp_misconfig_evt_word2)
  goto log_message;

 phy_state_info =
  (sfp_misconfig_evt_word2 >> (adapter->hba_port_num * 8)) & 0xff;

 if (phy_state_info & 0x80) {
  msg_severity = (phy_state_info & 0x6) >> 1;

  if ((new_phy_state == BE_PHY_UNQUALIFIED || new_phy_state == BE_PHY_UNCERTIFIED))
   phy_oper_state = (phy_state_info & 0x1);
 }

log_message:



 if ((new_phy_state > BE_PHY_UNCERTIFIED))
  dev_printk(be_port_misconfig_evt_severity[msg_severity], dev,
      "Port %c: Unrecognized Optics state: 0x%x. %s",
      adapter->port_name,
      new_phy_state,
      phy_state_oper_desc[phy_oper_state]);
 else
  dev_printk(be_port_misconfig_evt_severity[msg_severity], dev,
      "Port %c: %s %s",
      adapter->port_name,
      be_misconfig_evt_port_state[new_phy_state],
      phy_state_oper_desc[phy_oper_state]);


 if ((new_phy_state == BE_PHY_INCOMPATIBLE || new_phy_state == BE_PHY_UNQUALIFIED || new_phy_state == BE_PHY_UNCERTIFIED))
  adapter->flags |= ((((1UL))) << (10));
}


static void be_async_grp5_cos_priority_process(struct be_adapter *adapter,
            struct be_mcc_compl *compl)
{
 struct be_async_event_grp5_cos_priority *evt =
   (struct be_async_event_grp5_cos_priority *)compl;

 if (evt->valid) {
  adapter->vlan_prio_bmap = evt->available_priority_bmap;
  adapter->recommended_prio_bits =
   evt->reco_default_priority << 13;
 }
}


static void be_async_grp5_qos_speed_process(struct be_adapter *adapter,
         struct be_mcc_compl *compl)
{
 struct be_async_event_grp5_qos_link_speed *evt =
   (struct be_async_event_grp5_qos_link_speed *)compl;

 if (adapter->phy.link_speed >= 0 &&
     evt->physical_port == adapter->port_num)
  adapter->phy.link_speed = (__builtin_constant_p((__u16)(( __u16)(__le16)(evt->qos_link_speed))) ? ((__u16)( (((__u16)(( __u16)(__le16)(evt->qos_link_speed)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(evt->qos_link_speed)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(evt->qos_link_speed))) * 10;
}


static void be_async_grp5_pvid_state_process(struct be_adapter *adapter,
          struct be_mcc_compl *compl)
{
 struct be_async_event_grp5_pvid_state *evt =
   (struct be_async_event_grp5_pvid_state *)compl;

 if (evt->enabled) {
  adapter->pvid = (__builtin_constant_p((__u16)(( __u16)(__le16)(evt->tag))) ? ((__u16)( (((__u16)(( __u16)(__le16)(evt->tag)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(evt->tag)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(evt->tag))) & 0x0fff;
  _dev_info(&adapter->pdev->dev, "LPVID: %d\n", adapter->pvid);
 } else {
  adapter->pvid = 0;
 }
}


static void be_async_grp5_fw_control_process(struct be_adapter *adapter,
          struct be_mcc_compl *compl)
{
 struct be_async_fw_control *evt = (struct be_async_fw_control *)compl;
 u32 evt_dw1 = (__builtin_constant_p((__u32)(( __u32)(__le32)(evt->event_data_word1))) ? ((__u32)( (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word1)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(evt->event_data_word1)));

 if (evt_dw1 & 0x4) {
  adapter->flags |= ((((1UL))) << (12));
  adapter->bmc_filt_mask = (__builtin_constant_p((__u32)(( __u32)(__le32)(evt->event_data_word2))) ? ((__u32)( (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(evt->event_data_word2)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(evt->event_data_word2)));
 } else {
  adapter->flags &= ~((((1UL))) << (12));
 }
}

static void be_async_grp5_evt_process(struct be_adapter *adapter,
          struct be_mcc_compl *compl)
{
 u8 event_type = (compl->flags >> 16) &
    0xFF;

 switch (event_type) {
 case 0x2:
  be_async_grp5_cos_priority_process(adapter, compl);
  break;
 case 0x1:
  be_async_grp5_qos_speed_process(adapter, compl);
  break;
 case 0x3:
  be_async_grp5_pvid_state_process(adapter, compl);
  break;

 case 0x5:
  be_async_grp5_fw_control_process(adapter, compl);
  break;
 default:
  break;
 }
}

static void be_async_dbg_evt_process(struct be_adapter *adapter,
         struct be_mcc_compl *cmp)
{
 u8 event_type = 0;
 struct be_async_event_qnq *evt = (struct be_async_event_qnq *)cmp;

 event_type = (cmp->flags >> 16) &
   0xFF;

 switch (event_type) {
 case 1:
  if (evt->valid)
   adapter->qnq_vid = (__builtin_constant_p((__u16)(( __u16)(__le16)(evt->vlan_tag))) ? ((__u16)( (((__u16)(( __u16)(__le16)(evt->vlan_tag)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(evt->vlan_tag)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(evt->vlan_tag)));
  adapter->flags |= ((((1UL))) << (7));
 break;
 default:
  _dev_warn(&adapter->pdev->dev, "Unknown debug event 0x%x!\n", event_type);

 break;
 }
}

static void be_async_sliport_evt_process(struct be_adapter *adapter,
      struct be_mcc_compl *cmp)
{
 u8 event_type = (cmp->flags >> 16) &
   0xFF;

 if (event_type == 0x9)
  be_async_port_misconfig_event_process(adapter, cmp);
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_link_state_evt(u32 flags)
{
 return ((flags >> 8) & 0xFF) ==
   0x1;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_grp5_evt(u32 flags)
{
 return ((flags >> 8) & 0xFF) ==
   0x5;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_dbg_evt(u32 flags)
{
 return ((flags >> 8) & 0xFF) ==
   0x6;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) bool is_sliport_evt(u32 flags)
{
 return ((flags >> 8) & 0xFF) ==
  0x11;
}

static void be_mcc_event_process(struct be_adapter *adapter,
     struct be_mcc_compl *compl)
{
 if (is_link_state_evt(compl->flags))
  be_async_link_state_process(adapter, compl);
 else if (is_grp5_evt(compl->flags))
  be_async_grp5_evt_process(adapter, compl);
 else if (is_dbg_evt(compl->flags))
  be_async_dbg_evt_process(adapter, compl);
 else if (is_sliport_evt(compl->flags))
  be_async_sliport_evt_process(adapter, compl);
}

static struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter)
{
 struct be_queue_info *mcc_cq = &adapter->mcc_obj.cq;
 struct be_mcc_compl *compl = queue_tail_node(mcc_cq);

 if (be_mcc_compl_is_new(compl)) {
  queue_tail_inc(mcc_cq);
  return compl;
 }
 return ((void *)0);
}

void be_async_mcc_enable(struct be_adapter *adapter)
{
 spin_lock_bh(&adapter->mcc_cq_lock);

 be_cq_notify(adapter, adapter->mcc_obj.cq.id, true, 0);
 adapter->mcc_obj.rearm_cq = true;

 spin_unlock_bh(&adapter->mcc_cq_lock);
}

void be_async_mcc_disable(struct be_adapter *adapter)
{
 spin_lock_bh(&adapter->mcc_cq_lock);

 adapter->mcc_obj.rearm_cq = false;
 be_cq_notify(adapter, adapter->mcc_obj.cq.id, false, 0);

 spin_unlock_bh(&adapter->mcc_cq_lock);
}

int be_process_mcc(struct be_adapter *adapter)
{
 struct be_mcc_compl *compl;
 int num = 0, status = 0;
 struct be_mcc_obj *mcc_obj = &adapter->mcc_obj;

 spin_lock_bh(&adapter->mcc_cq_lock);

 while ((compl = be_mcc_compl_get(adapter))) {
  if (compl->flags & ((((1UL))) << (30))) {
   be_mcc_event_process(adapter, compl);
  } else if (compl->flags & ((((1UL))) << (28))) {
   status = be_mcc_compl_process(adapter, compl);
   atomic_dec(&mcc_obj->q.used);
  }
  be_mcc_compl_use(compl);
  num++;
 }

 if (num)
  be_cq_notify(adapter, mcc_obj->cq.id, mcc_obj->rearm_cq, num);

 spin_unlock_bh(&adapter->mcc_cq_lock);
 return status;
}


static int be_mcc_wait_compl(struct be_adapter *adapter)
{

 int i, status = 0;
 struct be_mcc_obj *mcc_obj = &adapter->mcc_obj;

 for (i = 0; i < 12000; i++) {
  if (be_check_error(adapter, (1 | ((((1UL))) << (1)) | ((((1UL))) << (2)) | ((((1UL))) << (3)))))
   return -5;

  status = be_process_mcc(adapter);

  if (atomic_read(&mcc_obj->q.used) == 0)
   break;
  usleep_range(500, 1000);
 }
 if (i == 12000) {
  _dev_err(&adapter->pdev->dev, "FW not responding\n");
  be_set_error(adapter, ((((1UL))) << (2)));
  return -5;
 }
 return status;
}


static int be_mcc_notify_wait(struct be_adapter *adapter)
{
 int status;
 struct be_mcc_wrb *wrb;
 struct be_mcc_obj *mcc_obj = &adapter->mcc_obj;
 u32 index = mcc_obj->q.head;
 struct be_cmd_resp_hdr *resp;

 index_dec(&index, mcc_obj->q.len);
 wrb = queue_index_node(&mcc_obj->q, index);

 resp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);

 status = be_mcc_notify(adapter);
 if (status)
  goto out;

 status = be_mcc_wait_compl(adapter);
 if (status == -5)
  goto out;

 status = (resp->base_status |
    ((resp->addl_status & 0xFF) <<
     16));
out:
 return status;
}

static int be_mbox_db_ready_wait(struct be_adapter *adapter, void *db)
{
 int msecs = 0;
 u32 ready;

 do {
  if (be_check_error(adapter, (1 | ((((1UL))) << (1)) | ((((1UL))) << (2)) | ((((1UL))) << (3)))))
   return -5;

  ready = ioread32(db);
  if (ready == 0xffffffff)
   return -1;

  ready &= 0x1;
  if (ready)
   break;

  if (msecs > 4000) {
   _dev_err(&adapter->pdev->dev, "FW not responding\n");
   be_set_error(adapter, ((((1UL))) << (2)));
   be_detect_error(adapter);
   return -1;
  }

  msleep(1);
  msecs++;
 } while (true);

 return 0;
}





static int be_mbox_notify_wait(struct be_adapter *adapter)
{
 int status;
 u32 val = 0;
 void *db = adapter->db + 0x160;
 struct be_dma_mem *mbox_mem = &adapter->mbox_mem;
 struct be_mcc_mailbox *mbox = mbox_mem->va;
 struct be_mcc_compl *compl = &mbox->compl;


 status = be_mbox_db_ready_wait(adapter, db);
 if (status != 0)
  return status;

 val |= 0x2;

 val |= (((u32)(((mbox_mem->dma) >> 16) >> 16)) >> 2) << 2;
 iowrite32(val, db);


 status = be_mbox_db_ready_wait(adapter, db);
 if (status != 0)
  return status;

 val = 0;

 val |= (u32)(mbox_mem->dma >> 4) << 2;
 iowrite32(val, db);

 status = be_mbox_db_ready_wait(adapter, db);
 if (status != 0)
  return status;


 if (be_mcc_compl_is_new(compl)) {
  status = be_mcc_compl_process(adapter, &mbox->compl);
  be_mcc_compl_use(compl);
  if (status)
   return status;
 } else {
  _dev_err(&adapter->pdev->dev, "invalid mailbox completion\n");
  return -1;
 }
 return 0;
}

u16 be_POST_stage_get(struct be_adapter *adapter)
{
 u32 sem;

 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
  sem = ioread32(adapter->csr + 0xac);
 else
  pci_read_config_dword(adapter->pdev,
          0x94, &sem);

 return sem & 0x0000FFFF;
}

static int lancer_wait_ready(struct be_adapter *adapter)
{

 u32 sliport_status;
 int i;

 for (i = 0; i < 30; i++) {
  sliport_status = ioread32(adapter->db + 0x404);
  if (sliport_status & 0x00800000)
   return 0;

  if (sliport_status & 0x80000000 &&
      !(sliport_status & 0x01000000))
   return -5;

  msleep(1000);
 }

 return sliport_status ? : -1;
}

int be_fw_wait_ready(struct be_adapter *adapter)
{
 u16 stage;
 int status, timeout = 0;
 struct device *dev = &adapter->pdev->dev;

 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228)) {
  status = lancer_wait_ready(adapter);
  if (status) {
   stage = status;
   goto err;
  }
  return 0;
 }

 do {

  if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) && (adapter->virtfn))
   return 0;

  stage = be_POST_stage_get(adapter);
  if (stage == 0xc000)
   return 0;

  _dev_info(dev, "Waiting for POST, %ds elapsed\n", timeout);
  if (msleep_interruptible(2000)) {
   _dev_err(dev, "Waiting for POST aborted\n");
   return -4;
  }
  timeout += 2;
 } while (timeout < 60);

err:
 _dev_err(dev, "POST timeout; stage=%#x\n", stage);
 return -110;
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb)
{
 return &wrb->payload.sgl[0];
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) void fill_wrb_tags(struct be_mcc_wrb *wrb, unsigned long addr)
{
 wrb->tag0 = addr & 0xFFFFFFFF;
 wrb->tag1 = ((u32)(((addr) >> 16) >> 16));
}



static void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr,
       u8 subsystem, u8 opcode, int cmd_len,
       struct be_mcc_wrb *wrb,
       struct be_dma_mem *mem)
{
 struct be_sge *sge;

 req_hdr->opcode = opcode;
 req_hdr->subsystem = subsystem;
 req_hdr->request_length = (( __le32)(__builtin_constant_p((__u32)((cmd_len - sizeof(*req_hdr)))) ? ((__u32)( (((__u32)((cmd_len - sizeof(*req_hdr))) & (__u32)0x000000ffUL) << 24) | (((__u32)((cmd_len - sizeof(*req_hdr))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((cmd_len - sizeof(*req_hdr))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((cmd_len - sizeof(*req_hdr))) & (__u32)0xff000000UL) >> 24))) : __fswab32((cmd_len - sizeof(*req_hdr)))));
 req_hdr->version = 0;
 fill_wrb_tags(wrb, (ulong) req_hdr);
 wrb->payload_length = cmd_len;
 if (mem) {
  wrb->embedded |= (1 & 0x1F) <<
   3;
  sge = nonembedded_sgl(wrb);
  sge->pa_hi = (( __le32)(__builtin_constant_p((__u32)((((u32)(((mem->dma) >> 16) >> 16))))) ? ((__u32)( (((__u32)((((u32)(((mem->dma) >> 16) >> 16)))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((u32)(((mem->dma) >> 16) >> 16)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((u32)(((mem->dma) >> 16) >> 16)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((u32)(((mem->dma) >> 16) >> 16)))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((u32)(((mem->dma) >> 16) >> 16))))));
  sge->pa_lo = (( __le32)(__builtin_constant_p((__u32)((mem->dma & 0xFFFFFFFF))) ? ((__u32)( (((__u32)((mem->dma & 0xFFFFFFFF)) & (__u32)0x000000ffUL) << 24) | (((__u32)((mem->dma & 0xFFFFFFFF)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((mem->dma & 0xFFFFFFFF)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((mem->dma & 0xFFFFFFFF)) & (__u32)0xff000000UL) >> 24))) : __fswab32((mem->dma & 0xFFFFFFFF))));
  sge->len = (( __le32)(__builtin_constant_p((__u32)((mem->size))) ? ((__u32)( (((__u32)((mem->size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((mem->size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((mem->size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((mem->size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((mem->size))));
 } else
  wrb->embedded |= 1;
 swap_dws(wrb, 8);
}

static void be_cmd_page_addrs_prepare(struct phys_addr *pages, u32 max_pages,
          struct be_dma_mem *mem)
{
 int i, buf_pages = __builtin_choose_expr(((!!(sizeof((typeof(((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))) *)1 == (typeof(max_pages) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(max_pages) * 0l)) : (int *)8))))), ((((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))) < (max_pages) ? (((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))) : (max_pages)), ({ typeof(((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))) __UNIQUE_ID___x118 = (((u32)((((size_t)(mem->va) & ((1 << 12) - 1)) + (mem->size) + ((1 << 12) - 1)) >> 12))); typeof(max_pages) __UNIQUE_ID___y119 = (max_pages); ((__UNIQUE_ID___x118) < (__UNIQUE_ID___y119) ? (__UNIQUE_ID___x118) : (__UNIQUE_ID___y119)); }));
 u64 dma = (u64)mem->dma;

 for (i = 0; i < buf_pages; i++) {
  pages[i].lo = (( __le32)(__builtin_constant_p((__u32)((dma & 0xFFFFFFFF))) ? ((__u32)( (((__u32)((dma & 0xFFFFFFFF)) & (__u32)0x000000ffUL) << 24) | (((__u32)((dma & 0xFFFFFFFF)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((dma & 0xFFFFFFFF)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((dma & 0xFFFFFFFF)) & (__u32)0xff000000UL) >> 24))) : __fswab32((dma & 0xFFFFFFFF))));
  pages[i].hi = (( __le32)(__builtin_constant_p((__u32)((((u32)(((dma) >> 16) >> 16))))) ? ((__u32)( (((__u32)((((u32)(((dma) >> 16) >> 16)))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((u32)(((dma) >> 16) >> 16)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((u32)(((dma) >> 16) >> 16)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((u32)(((dma) >> 16) >> 16)))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((u32)(((dma) >> 16) >> 16))))));
  dma += (1 << 12);
 }
}

static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((__no_instrument_function__)) struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter)
{
 struct be_dma_mem *mbox_mem = &adapter->mbox_mem;
 struct be_mcc_wrb *wrb
  = &((struct be_mcc_mailbox *)(mbox_mem->va))->wrb;
 memset(wrb, 0, sizeof(*wrb));
 return wrb;
}

static struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter)
{
 struct be_queue_info *mccq = &adapter->mcc_obj.q;
 struct be_mcc_wrb *wrb;

 if (!mccq->created)
  return ((void *)0);

 if (atomic_read(&mccq->used) >= mccq->len)
  return ((void *)0);

 wrb = queue_head_node(mccq);
 queue_head_inc(mccq);
 atomic_inc(&mccq->used);
 memset(wrb, 0, sizeof(*wrb));
 return wrb;
}

static bool use_mcc(struct be_adapter *adapter)
{
 return adapter->mcc_obj.q.created;
}


static int be_cmd_lock(struct be_adapter *adapter)
{
 if (use_mcc(adapter)) {
  mutex_lock(&adapter->mcc_lock);
  return 0;
 } else {
  return mutex_lock_interruptible(&adapter->mbox_lock);
 }
}


static void be_cmd_unlock(struct be_adapter *adapter)
{
 if (use_mcc(adapter))
  return mutex_unlock(&adapter->mcc_lock);
 else
  return mutex_unlock(&adapter->mbox_lock);
}

static struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter,
          struct be_mcc_wrb *wrb)
{
 struct be_mcc_wrb *dest_wrb;

 if (use_mcc(adapter)) {
  dest_wrb = wrb_from_mccq(adapter);
  if (!dest_wrb)
   return ((void *)0);
 } else {
  dest_wrb = wrb_from_mbox(adapter);
 }

 memcpy(dest_wrb, wrb, sizeof(*wrb));
 if (wrb->embedded & (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1)))))
  fill_wrb_tags(dest_wrb, (ulong) embedded_payload(wrb));

 return dest_wrb;
}


static int be_cmd_notify_wait(struct be_adapter *adapter,
         struct be_mcc_wrb *wrb)
{
 struct be_mcc_wrb *dest_wrb;
 int status;

 status = be_cmd_lock(adapter);
 if (status)
  return status;

 dest_wrb = be_cmd_copy(adapter, wrb);
 if (!dest_wrb) {
  status = -16;
  goto unlock;
 }

 if (use_mcc(adapter))
  status = be_mcc_notify_wait(adapter);
 else
  status = be_mbox_notify_wait(adapter);

 if (!status)
  memcpy(wrb, dest_wrb, sizeof(*wrb));

unlock:
 be_cmd_unlock(adapter);
 return status;
}




int be_cmd_fw_init(struct be_adapter *adapter)
{
 u8 *wrb;
 int status;

 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
  return 0;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = (u8 *)wrb_from_mbox(adapter);
 *wrb++ = 0xFF;
 *wrb++ = 0x12;
 *wrb++ = 0x34;
 *wrb++ = 0xFF;
 *wrb++ = 0xFF;
 *wrb++ = 0x56;
 *wrb++ = 0x78;
 *wrb = 0xFF;

 status = be_mbox_notify_wait(adapter);

 mutex_unlock(&adapter->mbox_lock);
 return status;
}




int be_cmd_fw_clean(struct be_adapter *adapter)
{
 u8 *wrb;
 int status;

 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
  return 0;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = (u8 *)wrb_from_mbox(adapter);
 *wrb++ = 0xFF;
 *wrb++ = 0xAA;
 *wrb++ = 0xBB;
 *wrb++ = 0xFF;
 *wrb++ = 0xFF;
 *wrb++ = 0xCC;
 *wrb++ = 0xDD;
 *wrb = 0xFF;

 status = be_mbox_notify_wait(adapter);

 mutex_unlock(&adapter->mbox_lock);
 return status;
}

int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_eq_create *req;
 struct be_dma_mem *q_mem = &eqo->q.dma_mem;
 int status, ver = 0;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          13, sizeof(*req), wrb,
          ((void *)0));


 if (!(((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) || (adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228)))
  ver = 2;

 req->hdr.version = ver;
 req->num_pages = (( __le16)(__builtin_constant_p((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))) ? ((__u16)( (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0x00ffU) << 8) | (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0xff00U) >> 8))) : __fswab16((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))));

 amap_set(req->context, __builtin_offsetof(struct amap_eq_context, valid)/32, amap_mask(sizeof(((struct amap_eq_context *)0)->valid)), (((size_t)&(((struct amap_eq_context *)0)->valid))%32), 1);

 amap_set(req->context, __builtin_offsetof(struct amap_eq_context, size)/32, amap_mask(sizeof(((struct amap_eq_context *)0)->size)), (((size_t)&(((struct amap_eq_context *)0)->size))%32), 0);
 amap_set(req->context, __builtin_offsetof(struct amap_eq_context, count)/32, amap_mask(sizeof(((struct amap_eq_context *)0)->count)), (((size_t)&(((struct amap_eq_context *)0)->count))%32), __ilog2_u32(eqo->q.len / 256));

 swap_dws(req->context, sizeof(req->context));

 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_eq_create *resp = embedded_payload(wrb);

  eqo->q.id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->eq_id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->eq_id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->eq_id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->eq_id)));
  eqo->msix_idx =
   (ver == 2) ? (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->msix_idx))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->msix_idx)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->msix_idx)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->msix_idx))) : eqo->idx;
  eqo->q.created = true;
 }

 mutex_unlock(&adapter->mbox_lock);
 return status;
}


int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
     bool permanent, u32 if_handle, u32 pmac_id)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_mac_query *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          1, sizeof(*req), wrb,
          ((void *)0));
 req->type = MAC_ADDRESS_TYPE_NETWORK;
 if (permanent) {
  req->permanent = 1;
 } else {
  req->if_id = (( __le16)(__builtin_constant_p((__u16)(((u16)if_handle))) ? ((__u16)( (((__u16)(((u16)if_handle)) & (__u16)0x00ffU) << 8) | (((__u16)(((u16)if_handle)) & (__u16)0xff00U) >> 8))) : __fswab16(((u16)if_handle))));
  req->pmac_id = (( __le32)(__builtin_constant_p((__u32)((pmac_id))) ? ((__u32)( (((__u32)((pmac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((pmac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((pmac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((pmac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((pmac_id))));
  req->permanent = 0;
 }

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_mac_query *resp = embedded_payload(wrb);

  memcpy(mac_addr, resp->mac.addr, 6);
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,
      u32 if_id, u32 *pmac_id, u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_pmac_add *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          59, sizeof(*req), wrb,
          ((void *)0));

 req->hdr.domain = domain;
 req->if_id = (( __le32)(__builtin_constant_p((__u32)((if_id))) ? ((__u32)( (((__u32)((if_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((if_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((if_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((if_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((if_id))));
 memcpy(req->mac_address, mac_addr, 6);

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_pmac_add *resp = embedded_payload(wrb);

  *pmac_id = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->pmac_id))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->pmac_id)));
 }

err:
 mutex_unlock(&adapter->mcc_lock);

  if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_UNAUTHORIZED_REQUEST)
  status = -1;

 return status;
}


int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id, u32 dom)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_pmac_del *req;
 int status;

 if (pmac_id == -1)
  return 0;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          60, sizeof(*req),
          wrb, ((void *)0));

 req->hdr.domain = dom;
 req->if_id = (( __le32)(__builtin_constant_p((__u32)((if_id))) ? ((__u32)( (((__u32)((if_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((if_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((if_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((if_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((if_id))));
 req->pmac_id = (( __le32)(__builtin_constant_p((__u32)((pmac_id))) ? ((__u32)( (((__u32)((pmac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((pmac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((pmac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((pmac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((pmac_id))));

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,
       struct be_queue_info *eq, bool no_delay, int coalesce_wm)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_cq_create *req;
 struct be_dma_mem *q_mem = &cq->dma_mem;
 void *ctxt;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);
 ctxt = &req->context;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          12, sizeof(*req), wrb,
          ((void *)0));

 req->num_pages = (( __le16)(__builtin_constant_p((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))) ? ((__u16)( (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0x00ffU) << 8) | (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0xff00U) >> 8))) : __fswab16((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))));

 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))) {
  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, coalescwm)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->coalescwm)), (((size_t)&(((struct amap_cq_context_be *)0)->coalescwm))%32), coalesce_wm);

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, nodelay)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->nodelay)), (((size_t)&(((struct amap_cq_context_be *)0)->nodelay))%32), no_delay);

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, count)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->count)), (((size_t)&(((struct amap_cq_context_be *)0)->count))%32), __ilog2_u32(cq->len / 256));

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, valid)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->valid)), (((size_t)&(((struct amap_cq_context_be *)0)->valid))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, eventable)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->eventable)), (((size_t)&(((struct amap_cq_context_be *)0)->eventable))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_be, eqid)/32, amap_mask(sizeof(((struct amap_cq_context_be *)0)->eqid)), (((size_t)&(((struct amap_cq_context_be *)0)->eqid))%32), eq->id);
 } else {
  req->hdr.version = 2;
  req->page_size = 1;




  if (!(adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
   amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, coalescwm)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->coalescwm)), (((size_t)&(((struct amap_cq_context_v2 *)0)->coalescwm))%32), coalesce_wm);

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, nodelay)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->nodelay)), (((size_t)&(((struct amap_cq_context_v2 *)0)->nodelay))%32), no_delay);

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, count)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->count)), (((size_t)&(((struct amap_cq_context_v2 *)0)->count))%32), __ilog2_u32(cq->len / 256));

  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, valid)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->valid)), (((size_t)&(((struct amap_cq_context_v2 *)0)->valid))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, eventable)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->eventable)), (((size_t)&(((struct amap_cq_context_v2 *)0)->eventable))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_cq_context_v2, eqid)/32, amap_mask(sizeof(((struct amap_cq_context_v2 *)0)->eqid)), (((size_t)&(((struct amap_cq_context_v2 *)0)->eqid))%32), eq->id);
 }

 swap_dws(ctxt, sizeof(req->context));

 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_cq_create *resp = embedded_payload(wrb);

  cq->id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->cq_id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->cq_id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->cq_id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->cq_id)));
  cq->created = true;
 }

 mutex_unlock(&adapter->mbox_lock);

 return status;
}

static u32 be_encoded_q_len(int q_len)
{
 u32 len_encoded = fls(q_len);

 if (len_encoded == 16)
  len_encoded = 0;
 return len_encoded;
}

static int be_cmd_mccq_ext_create(struct be_adapter *adapter,
      struct be_queue_info *mccq,
      struct be_queue_info *cq)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_mcc_ext_create *req;
 struct be_dma_mem *q_mem = &mccq->dma_mem;
 void *ctxt;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);
 ctxt = &req->context;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          90, sizeof(*req), wrb,
          ((void *)0));

 req->num_pages = (( __le16)(__builtin_constant_p((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))) ? ((__u16)( (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0x00ffU) << 8) | (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0xff00U) >> 8))) : __fswab16((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))));
 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))) {
  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, valid)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->valid)), (((size_t)&(((struct amap_mcc_context_be *)0)->valid))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, ring_size)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->ring_size)), (((size_t)&(((struct amap_mcc_context_be *)0)->ring_size))%32), be_encoded_q_len(mccq->len));

  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, cq_id)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->cq_id)), (((size_t)&(((struct amap_mcc_context_be *)0)->cq_id))%32), cq->id);
 } else {
  req->hdr.version = 1;
  req->cq_id = (( __le16)(__builtin_constant_p((__u16)((cq->id))) ? ((__u16)( (((__u16)((cq->id)) & (__u16)0x00ffU) << 8) | (((__u16)((cq->id)) & (__u16)0xff00U) >> 8))) : __fswab16((cq->id))));

  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_v1, ring_size)/32, amap_mask(sizeof(((struct amap_mcc_context_v1 *)0)->ring_size)), (((size_t)&(((struct amap_mcc_context_v1 *)0)->ring_size))%32), be_encoded_q_len(mccq->len));

  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_v1, valid)/32, amap_mask(sizeof(((struct amap_mcc_context_v1 *)0)->valid)), (((size_t)&(((struct amap_mcc_context_v1 *)0)->valid))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_v1, async_cq_id)/32, amap_mask(sizeof(((struct amap_mcc_context_v1 *)0)->async_cq_id)), (((size_t)&(((struct amap_mcc_context_v1 *)0)->async_cq_id))%32), cq->id);

  amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_v1, async_cq_valid)/32, amap_mask(sizeof(((struct amap_mcc_context_v1 *)0)->async_cq_valid)), (((size_t)&(((struct amap_mcc_context_v1 *)0)->async_cq_valid))%32), 1);

 }




 req->async_event_bitmap[0] =
   (( __le32)(__builtin_constant_p((__u32)((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11))))) ? ((__u32)( (((__u32)((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11)))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11)))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((((1UL))) << (0x1)) | ((((1UL))) << (0x5)) | ((((1UL))) << (0x6)) | ((((1UL))) << (0x11))))));




 swap_dws(ctxt, sizeof(req->context));

 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);

  mccq->id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->id)));
  mccq->created = true;
 }
 mutex_unlock(&adapter->mbox_lock);

 return status;
}

static int be_cmd_mccq_org_create(struct be_adapter *adapter,
      struct be_queue_info *mccq,
      struct be_queue_info *cq)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_mcc_create *req;
 struct be_dma_mem *q_mem = &mccq->dma_mem;
 void *ctxt;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);
 ctxt = &req->context;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          21, sizeof(*req), wrb,
          ((void *)0));

 req->num_pages = (( __le16)(__builtin_constant_p((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))) ? ((__u16)( (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0x00ffU) << 8) | (((__u16)((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12)))) & (__u16)0xff00U) >> 8))) : __fswab16((((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12))))));

 amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, valid)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->valid)), (((size_t)&(((struct amap_mcc_context_be *)0)->valid))%32), 1);
 amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, ring_size)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->ring_size)), (((size_t)&(((struct amap_mcc_context_be *)0)->ring_size))%32), be_encoded_q_len(mccq->len));

 amap_set(ctxt, __builtin_offsetof(struct amap_mcc_context_be, cq_id)/32, amap_mask(sizeof(((struct amap_mcc_context_be *)0)->cq_id)), (((size_t)&(((struct amap_mcc_context_be *)0)->cq_id))%32), cq->id);

 swap_dws(ctxt, sizeof(req->context));

 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);

  mccq->id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->id)));
  mccq->created = true;
 }

 mutex_unlock(&adapter->mbox_lock);
 return status;
}

int be_cmd_mccq_create(struct be_adapter *adapter,
         struct be_queue_info *mccq, struct be_queue_info *cq)
{
 int status;

 status = be_cmd_mccq_ext_create(adapter, mccq, cq);
 if (status && ((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))) {
  _dev_warn(&adapter->pdev->dev, "Upgrade to F/W ver 2.102.235.0 " "or newer to avoid conflicting priorities between NIC " "and FCoE traffic");


  status = be_cmd_mccq_org_create(adapter, mccq, cq);
 }
 return status;
}

int be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo)
{
 struct be_mcc_wrb wrb = {0};
 struct be_cmd_req_eth_tx_create *req;
 struct be_queue_info *txq = &txo->q;
 struct be_queue_info *cq = &txo->cq;
 struct be_dma_mem *q_mem = &txq->dma_mem;
 int status, ver = 0;

 req = embedded_payload(&wrb);
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          7, sizeof(*req), &wrb, ((void *)0));

 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228)) {
  req->hdr.version = 1;
 } else if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))) {
  if (adapter->function_caps & 0x40)
   req->hdr.version = 2;
 } else {
  req->hdr.version = 2;
 }

 if (req->hdr.version > 0)
  req->if_id = (( __le16)(__builtin_constant_p((__u16)((adapter->if_handle))) ? ((__u16)( (((__u16)((adapter->if_handle)) & (__u16)0x00ffU) << 8) | (((__u16)((adapter->if_handle)) & (__u16)0xff00U) >> 8))) : __fswab16((adapter->if_handle))));
 req->num_pages = ((u32)((((size_t)(q_mem->va) & ((1 << 12) - 1)) + (q_mem->size) + ((1 << 12) - 1)) >> 12));
 req->ulp_num = 1;
 req->type = 2;
 req->cq_id = (( __le16)(__builtin_constant_p((__u16)((cq->id))) ? ((__u16)( (((__u16)((cq->id)) & (__u16)0x00ffU) << 8) | (((__u16)((cq->id)) & (__u16)0xff00U) >> 8))) : __fswab16((cq->id))));
 req->queue_size = be_encoded_q_len(txq->len);
 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);
 ver = req->hdr.version;

 status = be_cmd_notify_wait(adapter, &wrb);
 if (!status) {
  struct be_cmd_resp_eth_tx_create *resp = embedded_payload(&wrb);

  txq->id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->cid))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->cid)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->cid)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->cid)));
  if (ver == 2)
   txo->db_offset = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->db_offset))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->db_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->db_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->db_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->db_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->db_offset)));
  else
   txo->db_offset = 0x60;
  txq->created = true;
 }

 return status;
}


int be_cmd_rxq_create(struct be_adapter *adapter,
        struct be_queue_info *rxq, u16 cq_id, u16 frag_size,
        u32 if_id, u32 rss, u8 *rss_id)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_eth_rx_create *req;
 struct be_dma_mem *q_mem = &rxq->dma_mem;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          8, sizeof(*req), wrb, ((void *)0));

 req->cq_id = (( __le16)(__builtin_constant_p((__u16)((cq_id))) ? ((__u16)( (((__u16)((cq_id)) & (__u16)0x00ffU) << 8) | (((__u16)((cq_id)) & (__u16)0xff00U) >> 8))) : __fswab16((cq_id))));
 req->frag_size = fls(frag_size) - 1;
 req->num_pages = 2;
 be_cmd_page_addrs_prepare(req->pages, (sizeof(req->pages) / sizeof((req->pages)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((req->pages)), typeof(&(req->pages)[0])))); })))), q_mem);
 req->interface_id = (( __le32)(__builtin_constant_p((__u32)((if_id))) ? ((__u32)( (((__u32)((if_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((if_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((if_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((if_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((if_id))));
 req->max_frame_size = (( __le16)(__builtin_constant_p((__u16)((9018))) ? ((__u16)( (((__u16)((9018)) & (__u16)0x00ffU) << 8) | (((__u16)((9018)) & (__u16)0xff00U) >> 8))) : __fswab16((9018))));
 req->rss_queue = (( __le32)(__builtin_constant_p((__u32)((rss))) ? ((__u32)( (((__u32)((rss)) & (__u32)0x000000ffUL) << 24) | (((__u32)((rss)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((rss)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((rss)) & (__u32)0xff000000UL) >> 24))) : __fswab32((rss))));

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_eth_rx_create *resp = embedded_payload(wrb);

  rxq->id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->id)));
  rxq->created = true;
  *rss_id = resp->rss_id;
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}




int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
       int queue_type)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_q_destroy *req;
 u8 subsys = 0, opcode = 0;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);

 switch (queue_type) {
 case QTYPE_EQ:
  subsys = 0x1;
  opcode = 55;
  break;
 case QTYPE_CQ:
  subsys = 0x1;
  opcode = 54;
  break;
 case QTYPE_TXQ:
  subsys = 0x3;
  opcode = 9;
  break;
 case QTYPE_RXQ:
  subsys = 0x3;
  opcode = 10;
  break;
 case QTYPE_MCCQ:
  subsys = 0x1;
  opcode = 53;
  break;
 default:
  do { __asm__ __volatile__( "1:	" "twi 31, 0, 0" "\n" ".section __bug_table,\"aw\"\n" "2:\t" ".8byte" " " "1b, %0\n" "\t.short %1, %2\n" ".org 2b+%3\n" ".previous\n" : : "i" ("drivers/net/ethernet/emulex/benet/be_cmds.c"), "i" (1487), "i" (0), "i" (sizeof(struct bug_entry))); do { ; __builtin_unreachable(); } while (0); } while (0);
 }

 be_wrb_cmd_hdr_prepare(&req->hdr, subsys, opcode, sizeof(*req), wrb,
          ((void *)0));
 req->id = (( __le16)(__builtin_constant_p((__u16)((q->id))) ? ((__u16)( (((__u16)((q->id)) & (__u16)0x00ffU) << 8) | (((__u16)((q->id)) & (__u16)0xff00U) >> 8))) : __fswab16((q->id))));

 status = be_mbox_notify_wait(adapter);
 q->created = false;

 mutex_unlock(&adapter->mbox_lock);
 return status;
}


int be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_q_destroy *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          10, sizeof(*req), wrb, ((void *)0));
 req->id = (( __le16)(__builtin_constant_p((__u16)((q->id))) ? ((__u16)( (((__u16)((q->id)) & (__u16)0x00ffU) << 8) | (((__u16)((q->id)) & (__u16)0xff00U) >> 8))) : __fswab16((q->id))));

 status = be_mcc_notify_wait(adapter);
 q->created = false;

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}




int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,
       u32 *if_handle, u32 domain)
{
 struct be_mcc_wrb wrb = {0};
 struct be_cmd_req_if_create *req;
 int status;

 req = embedded_payload(&wrb);
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          50,
          sizeof(*req), &wrb, ((void *)0));
 req->hdr.domain = domain;
 req->capability_flags = (( __le32)(__builtin_constant_p((__u32)((cap_flags))) ? ((__u32)( (((__u32)((cap_flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)((cap_flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((cap_flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((cap_flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32((cap_flags))));
 req->enable_flags = (( __le32)(__builtin_constant_p((__u32)((en_flags))) ? ((__u32)( (((__u32)((en_flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)((en_flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((en_flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((en_flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32((en_flags))));
 req->pmac_invalid = true;

 status = be_cmd_notify_wait(adapter, &wrb);
 if (!status) {
  struct be_cmd_resp_if_create *resp = embedded_payload(&wrb);

  *if_handle = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->interface_id))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->interface_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->interface_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->interface_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->interface_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->interface_id)));


  if ((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) && (adapter->virtfn))
   adapter->pmac_id[0] = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->pmac_id))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->pmac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->pmac_id)));
 }
 return status;
}


int be_cmd_if_destroy(struct be_adapter *adapter, int interface_id, u32 domain)
{
 struct be_mcc_wrb wrb = {0};
 struct be_cmd_req_if_destroy *req;
 int status;

 if (interface_id == -1)
  return 0;

 req = embedded_payload(&wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          51,
          sizeof(*req), &wrb, ((void *)0));
 req->hdr.domain = domain;
 req->interface_id = (( __le32)(__builtin_constant_p((__u32)((interface_id))) ? ((__u32)( (((__u32)((interface_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((interface_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((interface_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((interface_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((interface_id))));

 status = be_cmd_notify_wait(adapter, &wrb);
 return status;
}





int be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_hdr *hdr;
 int status = 0;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 hdr = nonemb_cmd->va;

 be_wrb_cmd_hdr_prepare(hdr, 0x3,
          4, nonemb_cmd->size, wrb,
          nonemb_cmd);


 if ((adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))
  hdr->version = 0;
 if ((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
  hdr->version = 1;
 else
  hdr->version = 2;

 status = be_mcc_notify(adapter);
 if (status)
  goto err;

 adapter->stats_cmd_sent = true;

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
          struct be_dma_mem *nonemb_cmd)
{
 struct be_mcc_wrb *wrb;
 struct lancer_cmd_req_pport_stats *req;
 int status = 0;

 if (!be_cmd_allowed(adapter, 18,
       0x3))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = nonemb_cmd->va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          18, nonemb_cmd->size,
          wrb, nonemb_cmd);

 req->cmd_params.params.pport_num = (( __le16)(__builtin_constant_p((__u16)((adapter->hba_port_num))) ? ((__u16)( (((__u16)((adapter->hba_port_num)) & (__u16)0x00ffU) << 8) | (((__u16)((adapter->hba_port_num)) & (__u16)0xff00U) >> 8))) : __fswab16((adapter->hba_port_num))));
 req->cmd_params.params.reset_stats = 0;

 status = be_mcc_notify(adapter);
 if (status)
  goto err;

 adapter->stats_cmd_sent = true;

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int be_mac_to_link_speed(int mac_speed)
{
 switch (mac_speed) {
 case PHY_LINK_SPEED_ZERO:
  return 0;
 case PHY_LINK_SPEED_10MBPS:
  return 10;
 case PHY_LINK_SPEED_100MBPS:
  return 100;
 case PHY_LINK_SPEED_1GBPS:
  return 1000;
 case PHY_LINK_SPEED_10GBPS:
  return 10000;
 case PHY_LINK_SPEED_20GBPS:
  return 20000;
 case PHY_LINK_SPEED_25GBPS:
  return 25000;
 case PHY_LINK_SPEED_40GBPS:
  return 40000;
 }
 return 0;
}




int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
        u8 *link_status, u32 dom)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_link_status *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 if (link_status)
  *link_status = LINK_DOWN;

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          5,
          sizeof(*req), wrb, ((void *)0));


 if (!(adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))
  req->hdr.version = 1;

 req->hdr.domain = dom;

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_link_status *resp = embedded_payload(wrb);

  if (link_speed) {
   *link_speed = resp->link_speed ?
          (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->link_speed))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->link_speed)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->link_speed)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->link_speed))) * 10 :
          be_mac_to_link_speed(resp->mac_speed);

   if (!resp->logical_link_status)
    *link_speed = 0;
  }
  if (link_status)
   *link_status = resp->logical_link_status;
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_get_die_temperature(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_cntl_addnl_attribs *req;
 int status = 0;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          121,
          sizeof(*req), wrb, ((void *)0));

 status = be_mcc_notify(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_get_fat_dump_len(struct be_adapter *adapter, u32 *dump_size)
{
 struct be_mcc_wrb wrb = {0};
 struct be_cmd_req_get_fat *req;
 int status;

 req = embedded_payload(&wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          68, sizeof(*req),
          &wrb, ((void *)0));
 req->fat_operation = (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1))));
 status = be_cmd_notify_wait(adapter, &wrb);
 if (!status) {
  struct be_cmd_resp_get_fat *resp = embedded_payload(&wrb);

  if (dump_size && resp->log_size)
   *dump_size = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->log_size))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->log_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->log_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->log_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->log_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->log_size))) -
     sizeof(u32);
 }
 return status;
}

int be_cmd_get_fat_dump(struct be_adapter *adapter, u32 buf_len, void *buf)
{
 struct be_dma_mem get_fat_cmd;
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_fat *req;
 u32 offset = 0, total_size, buf_size,
    log_offset = sizeof(u32), payload_len;
 int status;

 if (buf_len == 0)
  return 0;

 total_size = buf_len;

 get_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;
 get_fat_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,
         get_fat_cmd.size,
         &get_fat_cmd.dma, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!get_fat_cmd.va)
  return -12;

 mutex_lock(&adapter->mcc_lock);

 while (total_size) {
  buf_size = __builtin_choose_expr(((!!(sizeof((typeof(total_size) *)1 == (typeof((u32)60*1024) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(total_size) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)60*1024) * 0l)) : (int *)8))))), ((total_size) < ((u32)60*1024) ? (total_size) : ((u32)60*1024)), ({ typeof(total_size) __UNIQUE_ID___x120 = (total_size); typeof((u32)60*1024) __UNIQUE_ID___y121 = ((u32)60*1024); ((__UNIQUE_ID___x120) < (__UNIQUE_ID___y121) ? (__UNIQUE_ID___x120) : (__UNIQUE_ID___y121)); }));
  total_size -= buf_size;

  wrb = wrb_from_mccq(adapter);
  if (!wrb) {
   status = -16;
   goto err;
  }
  req = get_fat_cmd.va;

  payload_len = sizeof(struct be_cmd_req_get_fat) + buf_size;
  be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
           68, payload_len,
           wrb, &get_fat_cmd);

  req->fat_operation = (( __le32)(__builtin_constant_p((__u32)((0))) ? ((__u32)( (((__u32)((0)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0))));
  req->read_log_offset = (( __le32)(__builtin_constant_p((__u32)((log_offset))) ? ((__u32)( (((__u32)((log_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((log_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((log_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((log_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((log_offset))));
  req->read_log_length = (( __le32)(__builtin_constant_p((__u32)((buf_size))) ? ((__u32)( (((__u32)((buf_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((buf_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((buf_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((buf_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((buf_size))));
  req->data_buffer_size = (( __le32)(__builtin_constant_p((__u32)((buf_size))) ? ((__u32)( (((__u32)((buf_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((buf_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((buf_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((buf_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((buf_size))));

  status = be_mcc_notify_wait(adapter);
  if (!status) {
   struct be_cmd_resp_get_fat *resp = get_fat_cmd.va;

   memcpy(buf + offset,
          resp->data_buffer,
          (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->read_log_length))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->read_log_length)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->read_log_length)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->read_log_length)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->read_log_length)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->read_log_length))));
  } else {
   _dev_err(&adapter->pdev->dev, "FAT Table Retrieve error\n");
   goto err;
  }
  offset += buf_size;
  log_offset += buf_size;
 }
err:
 dma_free_coherent(&adapter->pdev->dev, get_fat_cmd.size,
     get_fat_cmd.va, get_fat_cmd.dma);
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_get_fw_ver(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_fw_version *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          35, sizeof(*req), wrb,
          ((void *)0));
 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_fw_version *resp = embedded_payload(wrb);

  strlcpy(adapter->fw_ver, resp->firmware_version_string,
   sizeof(adapter->fw_ver));
  strlcpy(adapter->fw_on_flash, resp->fw_on_flash_version_string,
   sizeof(adapter->fw_on_flash));
 }
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}




static int __be_cmd_modify_eqd(struct be_adapter *adapter,
          struct be_set_eqd *set_eqd, int num)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_modify_eq_delay *req;
 int status = 0, i;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          41, sizeof(*req), wrb,
          ((void *)0));

 req->num_eq = (( __le32)(__builtin_constant_p((__u32)((num))) ? ((__u32)( (((__u32)((num)) & (__u32)0x000000ffUL) << 24) | (((__u32)((num)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((num)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((num)) & (__u32)0xff000000UL) >> 24))) : __fswab32((num))));
 for (i = 0; i < num; i++) {
  req->set_eqd[i].eq_id = (( __le32)(__builtin_constant_p((__u32)((set_eqd[i].eq_id))) ? ((__u32)( (((__u32)((set_eqd[i].eq_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((set_eqd[i].eq_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((set_eqd[i].eq_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((set_eqd[i].eq_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((set_eqd[i].eq_id))));
  req->set_eqd[i].phase = 0;
  req->set_eqd[i].delay_multiplier =
    (( __le32)(__builtin_constant_p((__u32)((set_eqd[i].delay_multiplier))) ? ((__u32)( (((__u32)((set_eqd[i].delay_multiplier)) & (__u32)0x000000ffUL) << 24) | (((__u32)((set_eqd[i].delay_multiplier)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((set_eqd[i].delay_multiplier)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((set_eqd[i].delay_multiplier)) & (__u32)0xff000000UL) >> 24))) : __fswab32((set_eqd[i].delay_multiplier))));
 }

 status = be_mcc_notify(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *set_eqd,
        int num)
{
 int num_eqs, i = 0;

 while (num) {
  num_eqs = __builtin_choose_expr(((!!(sizeof((typeof(num) *)1 == (typeof(8) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(num) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(8) * 0l)) : (int *)8))))), ((num) < (8) ? (num) : (8)), ({ typeof(num) __UNIQUE_ID___x122 = (num); typeof(8) __UNIQUE_ID___y123 = (8); ((__UNIQUE_ID___x122) < (__UNIQUE_ID___y123) ? (__UNIQUE_ID___x122) : (__UNIQUE_ID___y123)); }));
  __be_cmd_modify_eqd(adapter, &set_eqd[i], num_eqs);
  i += num_eqs;
  num -= num_eqs;
 }

 return 0;
}


int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,
         u32 num, u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_vlan_config *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          4, sizeof(*req),
          wrb, ((void *)0));
 req->hdr.domain = domain;

 req->interface_id = if_id;
 req->untagged = BE_IF_FLAGS_UNTAGGED & (adapter->res.if_cap_flags) ? 1 : 0;
 req->num_vlan = num;
 memcpy(req->normal_vlan, vtag_array,
        req->num_vlan * sizeof(vtag_array[0]));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int __be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 value)
{
 struct be_mcc_wrb *wrb;
 struct be_dma_mem *mem = &adapter->rx_filter;
 struct be_cmd_req_rx_filter *req = mem->va;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 memset(req, 0, sizeof(*req));
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          34, sizeof(*req),
          wrb, mem);

 req->if_id = (( __le32)(__builtin_constant_p((__u32)((adapter->if_handle))) ? ((__u32)( (((__u32)((adapter->if_handle)) & (__u32)0x000000ffUL) << 24) | (((__u32)((adapter->if_handle)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((adapter->if_handle)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((adapter->if_handle)) & (__u32)0xff000000UL) >> 24))) : __fswab32((adapter->if_handle))));
 req->if_flags_mask = (( __le32)(__builtin_constant_p((__u32)((flags))) ? ((__u32)( (((__u32)((flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)((flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32((flags))));
 req->if_flags = (value == 1) ? req->if_flags_mask : 0;

 if (flags & BE_IF_FLAGS_MULTICAST) {
  int i;




  req->if_flags_mask |=
   (( __le32)(__builtin_constant_p((__u32)((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags)))) ? ((__u32)( (((__u32)((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags))) & (__u32)0x000000ffUL) << 24) | (((__u32)((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags))) & (__u32)0xff000000UL) >> 24))) : __fswab32((BE_IF_FLAGS_MCAST_PROMISCUOUS & (adapter->res.if_cap_flags)))));

  req->mcast_num = (( __le32)(__builtin_constant_p((__u32)((adapter->mc_count))) ? ((__u32)( (((__u32)((adapter->mc_count)) & (__u32)0x000000ffUL) << 24) | (((__u32)((adapter->mc_count)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((adapter->mc_count)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((adapter->mc_count)) & (__u32)0xff000000UL) >> 24))) : __fswab32((adapter->mc_count))));
  for (i = 0; i < adapter->mc_count; i++)
   ether_addr_copy(req->mcast_mac[i].byte,
     adapter->mc_list[i].mac);
 }

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 value)
{
 struct device *dev = &adapter->pdev->dev;

 if ((flags & (adapter->res.if_cap_flags)) != flags) {
  _dev_warn(dev, "Cannot set rx filter flags 0x%x\n", flags);
  _dev_warn(dev, "Interface is capable of 0x%x flags only\n", (adapter->res.if_cap_flags));

 }
 flags &= (adapter->res.if_cap_flags);
 if (!flags)
  return -524;

 return __be_cmd_rx_filter(adapter, flags, value);
}


int be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_flow_control *req;
 int status;

 if (!be_cmd_allowed(adapter, 36,
       0x1))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          36, sizeof(*req),
          wrb, ((void *)0));

 req->hdr.version = 1;
 req->tx_flow_control = (( __le16)(__builtin_constant_p((__u16)(((u16)tx_fc))) ? ((__u16)( (((__u16)(((u16)tx_fc)) & (__u16)0x00ffU) << 8) | (((__u16)(((u16)tx_fc)) & (__u16)0xff00U) >> 8))) : __fswab16(((u16)tx_fc))));
 req->rx_flow_control = (( __le16)(__builtin_constant_p((__u16)(((u16)rx_fc))) ? ((__u16)( (((__u16)(((u16)rx_fc)) & (__u16)0x00ffU) << 8) | (((__u16)(((u16)rx_fc)) & (__u16)0xff00U) >> 8))) : __fswab16(((u16)rx_fc))));

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);

 if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_FEATURE_NOT_SUPPORTED)
  return -95;

 return status;
}


int be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_flow_control *req;
 int status;

 if (!be_cmd_allowed(adapter, 37,
       0x1))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          37, sizeof(*req),
          wrb, ((void *)0));

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_flow_control *resp =
      embedded_payload(wrb);

  *tx_fc = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->tx_flow_control))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->tx_flow_control)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->tx_flow_control)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->tx_flow_control)));
  *rx_fc = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->rx_flow_control))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->rx_flow_control)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->rx_flow_control)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->rx_flow_control)));
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_query_fw_cfg(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_query_fw_cfg *req;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          58,
          sizeof(*req), wrb, ((void *)0));

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_query_fw_cfg *resp = embedded_payload(wrb);

  adapter->port_num = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->phys_port))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->phys_port)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->phys_port)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->phys_port)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->phys_port)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->phys_port)));
  adapter->function_mode = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->function_mode))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->function_mode)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->function_mode)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->function_mode)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->function_mode)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->function_mode)));
  adapter->function_caps = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->function_caps))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->function_caps)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->function_caps)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->function_caps)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->function_caps)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->function_caps)));
  adapter->asic_rev = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->asic_revision))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->asic_revision)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->asic_revision)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->asic_revision)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->asic_revision)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->asic_revision))) & 0xFF;
  _dev_info(&adapter->pdev->dev, "FW config: function_mode=0x%x, function_caps=0x%x\n", adapter->function_mode, adapter->function_caps);


 }

 mutex_unlock(&adapter->mbox_lock);
 return status;
}


int be_cmd_reset_function(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_hdr *req;
 int status;

 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228)) {
  iowrite32(0x08000000,
     adapter->db + 0x408);
  status = lancer_wait_ready(adapter);
  if (status)
   _dev_err(&adapter->pdev->dev, "Adapter in non recoverable error\n");

  return status;
 }

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(req, 0x1,
          61, sizeof(*req), wrb,
          ((void *)0));

 status = be_mbox_notify_wait(adapter);

 mutex_unlock(&adapter->mbox_lock);
 return status;
}

int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
        u32 rss_hash_opts, u16 table_size, const u8 *rss_hkey)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_rss_config *req;
 int status;

 if (!((adapter->res.if_cap_flags) & BE_IF_FLAGS_RSS))
  return 0;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          1, sizeof(*req), wrb, ((void *)0));

 req->if_id = (( __le32)(__builtin_constant_p((__u32)((adapter->if_handle))) ? ((__u32)( (((__u32)((adapter->if_handle)) & (__u32)0x000000ffUL) << 24) | (((__u32)((adapter->if_handle)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((adapter->if_handle)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((adapter->if_handle)) & (__u32)0xff000000UL) >> 24))) : __fswab32((adapter->if_handle))));
 req->enable_rss = (( __le16)(__builtin_constant_p((__u16)((rss_hash_opts))) ? ((__u16)( (((__u16)((rss_hash_opts)) & (__u16)0x00ffU) << 8) | (((__u16)((rss_hash_opts)) & (__u16)0xff00U) >> 8))) : __fswab16((rss_hash_opts))));
 req->cpu_table_size_log2 = (( __le16)(__builtin_constant_p((__u16)((fls(table_size) - 1))) ? ((__u16)( (((__u16)((fls(table_size) - 1)) & (__u16)0x00ffU) << 8) | (((__u16)((fls(table_size) - 1)) & (__u16)0xff00U) >> 8))) : __fswab16((fls(table_size) - 1))));

 if (!((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
  req->hdr.version = 1;

 memcpy(req->cpu_table, rsstable, table_size);
 memcpy(req->hash, rss_hkey, 40);
 swap_dws(req->hash, sizeof(req->hash));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num,
       u8 bcn, u8 sts, u8 state)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_enable_disable_beacon *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          69,
          sizeof(*req), wrb, ((void *)0));

 req->port_num = port_num;
 req->beacon_state = state;
 req->beacon_duration = bcn;
 req->status_duration = sts;

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num, u32 *state)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_beacon_state *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          70, sizeof(*req),
          wrb, ((void *)0));

 req->port_num = port_num;

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_beacon_state *resp =
      embedded_payload(wrb);

  *state = resp->beacon_state;
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,
          u8 page_num, u8 *data)
{
 struct be_dma_mem cmd;
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_port_type *req;
 int status;

 if (page_num > TR_PAGE_A2)
  return -22;

 cmd.size = sizeof(struct be_cmd_resp_port_type);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory allocation failed\n");
  return -12;
 }

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          73,
          cmd.size, wrb, &cmd);

 req->port = (( __le32)(__builtin_constant_p((__u32)((adapter->hba_port_num))) ? ((__u32)( (((__u32)((adapter->hba_port_num)) & (__u32)0x000000ffUL) << 24) | (((__u32)((adapter->hba_port_num)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((adapter->hba_port_num)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((adapter->hba_port_num)) & (__u32)0xff000000UL) >> 24))) : __fswab32((adapter->hba_port_num))));
 req->page_num = (( __le32)(__builtin_constant_p((__u32)((page_num))) ? ((__u32)( (((__u32)((page_num)) & (__u32)0x000000ffUL) << 24) | (((__u32)((page_num)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((page_num)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((page_num)) & (__u32)0xff000000UL) >> 24))) : __fswab32((page_num))));
 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_port_type *resp = cmd.va;

  memcpy(data, resp->page_data, 256);
 }
err:
 mutex_unlock(&adapter->mcc_lock);
 dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
 return status;
}

static int lancer_cmd_write_object(struct be_adapter *adapter,
       struct be_dma_mem *cmd, u32 data_size,
       u32 data_offset, const char *obj_name,
       u32 *data_written, u8 *change_status,
       u8 *addn_status)
{
 struct be_mcc_wrb *wrb;
 struct lancer_cmd_req_write_object *req;
 struct lancer_cmd_resp_write_object *resp;
 void *ctxt = ((void *)0);
 int status;

 mutex_lock(&adapter->mcc_lock);
 adapter->flash_status = 0;

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err_unlock;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          172,
          sizeof(struct lancer_cmd_req_write_object), wrb,
          ((void *)0));

 ctxt = &req->context;
 amap_set(ctxt, __builtin_offsetof(struct amap_lancer_write_obj_context, write_length)/32, amap_mask(sizeof(((struct amap_lancer_write_obj_context *)0)->write_length)), (((size_t)&(((struct amap_lancer_write_obj_context *)0)->write_length))%32), data_size);


 if (data_size == 0)
  amap_set(ctxt, __builtin_offsetof(struct amap_lancer_write_obj_context, eof)/32, amap_mask(sizeof(((struct amap_lancer_write_obj_context *)0)->eof)), (((size_t)&(((struct amap_lancer_write_obj_context *)0)->eof))%32), 1);

 else
  amap_set(ctxt, __builtin_offsetof(struct amap_lancer_write_obj_context, eof)/32, amap_mask(sizeof(((struct amap_lancer_write_obj_context *)0)->eof)), (((size_t)&(((struct amap_lancer_write_obj_context *)0)->eof))%32), 0);


 swap_dws(ctxt, sizeof(req->context));
 req->write_offset = (( __le32)(__builtin_constant_p((__u32)((data_offset))) ? ((__u32)( (((__u32)((data_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((data_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((data_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((data_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((data_offset))));
 strlcpy(req->object_name, obj_name, sizeof(req->object_name));
 req->descriptor_count = (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1))));
 req->buf_len = (( __le32)(__builtin_constant_p((__u32)((data_size))) ? ((__u32)( (((__u32)((data_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((data_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((data_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((data_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((data_size))));
 req->addr_low = (( __le32)(__builtin_constant_p((__u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF))) ? ((__u32)( (((__u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF)) & (__u32)0x000000ffUL) << 24) | (((__u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF)) & (__u32)0xff000000UL) >> 24))) : __fswab32(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) & 0xFFFFFFFF))));


 req->addr_high = (( __le32)(__builtin_constant_p((__u32)((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16))))) ? ((__u32)( (((__u32)((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16)))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16)))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((u32)(((cmd->dma + sizeof(struct lancer_cmd_req_write_object)) >> 16) >> 16))))));


 status = be_mcc_notify(adapter);
 if (status)
  goto err_unlock;

 mutex_unlock(&adapter->mcc_lock);

 if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
      msecs_to_jiffies(60000)))
  status = -110;
 else
  status = adapter->flash_status;

 resp = embedded_payload(wrb);
 if (!status) {
  *data_written = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->actual_write_len))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->actual_write_len)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->actual_write_len)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->actual_write_len)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->actual_write_len)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->actual_write_len)));
  *change_status = resp->change_status;
 } else {
  *addn_status = resp->additional_status;
 }

 return status;

err_unlock:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_query_cable_type(struct be_adapter *adapter)
{
 u8 page_data[256];
 int status;

 status = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,
         page_data);
 if (!status) {
  switch (adapter->phy.interface_type) {
  case PHY_TYPE_QSFP:
   adapter->phy.cable_type =
    page_data[0x83];
   break;
  case PHY_TYPE_SFP_PLUS_10GB:
   adapter->phy.cable_type =
    page_data[0x8];
   break;
  default:
   adapter->phy.cable_type = 0;
   break;
  }
 }
 return status;
}

int be_cmd_query_sfp_info(struct be_adapter *adapter)
{
 u8 page_data[256];
 int status;

 status = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,
         page_data);
 if (!status) {
  strlcpy(adapter->phy.vendor_name, page_data +
   0x14, 17 - 1);
  strlcpy(adapter->phy.vendor_pn,
   page_data + 0x28,
   17 - 1);
 }

 return status;
}

static int lancer_cmd_delete_object(struct be_adapter *adapter,
        const char *obj_name)
{
 struct lancer_cmd_req_delete_object *req;
 struct be_mcc_wrb *wrb;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          174,
          sizeof(*req), wrb, ((void *)0));

 strlcpy(req->object_name, obj_name, sizeof(req->object_name));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
      u32 data_size, u32 data_offset, const char *obj_name,
      u32 *data_read, u32 *eof, u8 *addn_status)
{
 struct be_mcc_wrb *wrb;
 struct lancer_cmd_req_read_object *req;
 struct lancer_cmd_resp_read_object *resp;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err_unlock;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          171,
          sizeof(struct lancer_cmd_req_read_object), wrb,
          ((void *)0));

 req->desired_read_len = (( __le32)(__builtin_constant_p((__u32)((data_size))) ? ((__u32)( (((__u32)((data_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((data_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((data_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((data_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((data_size))));
 req->read_offset = (( __le32)(__builtin_constant_p((__u32)((data_offset))) ? ((__u32)( (((__u32)((data_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((data_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((data_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((data_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((data_offset))));
 strcpy(req->object_name, obj_name);
 req->descriptor_count = (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1))));
 req->buf_len = (( __le32)(__builtin_constant_p((__u32)((data_size))) ? ((__u32)( (((__u32)((data_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((data_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((data_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((data_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((data_size))));
 req->addr_low = (( __le32)(__builtin_constant_p((__u32)(((cmd->dma & 0xFFFFFFFF)))) ? ((__u32)( (((__u32)(((cmd->dma & 0xFFFFFFFF))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((cmd->dma & 0xFFFFFFFF))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((cmd->dma & 0xFFFFFFFF))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((cmd->dma & 0xFFFFFFFF))) & (__u32)0xff000000UL) >> 24))) : __fswab32(((cmd->dma & 0xFFFFFFFF)))));
 req->addr_high = (( __le32)(__builtin_constant_p((__u32)((((u32)(((cmd->dma) >> 16) >> 16))))) ? ((__u32)( (((__u32)((((u32)(((cmd->dma) >> 16) >> 16)))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((u32)(((cmd->dma) >> 16) >> 16)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((u32)(((cmd->dma) >> 16) >> 16)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((u32)(((cmd->dma) >> 16) >> 16)))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((u32)(((cmd->dma) >> 16) >> 16))))));

 status = be_mcc_notify_wait(adapter);

 resp = embedded_payload(wrb);
 if (!status) {
  *data_read = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->actual_read_len))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->actual_read_len)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->actual_read_len)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->actual_read_len)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->actual_read_len)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->actual_read_len)));
  *eof = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->eof))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->eof)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->eof)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->eof)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->eof)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->eof)));
 } else {
  *addn_status = resp->additional_status;
 }

err_unlock:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int be_cmd_write_flashrom(struct be_adapter *adapter,
     struct be_dma_mem *cmd, u32 flash_type,
     u32 flash_opcode, u32 img_offset, u32 buf_size)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_write_flashrom *req;
 int status;

 mutex_lock(&adapter->mcc_lock);
 adapter->flash_status = 0;

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err_unlock;
 }
 req = cmd->va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          7, cmd->size, wrb,
          cmd);

 req->params.op_type = (( __le32)(__builtin_constant_p((__u32)((flash_type))) ? ((__u32)( (((__u32)((flash_type)) & (__u32)0x000000ffUL) << 24) | (((__u32)((flash_type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((flash_type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((flash_type)) & (__u32)0xff000000UL) >> 24))) : __fswab32((flash_type))));
 if (flash_type == OPTYPE_OFFSET_SPECIFIED)
  req->params.offset = (( __le32)(__builtin_constant_p((__u32)((img_offset))) ? ((__u32)( (((__u32)((img_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((img_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((img_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((img_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((img_offset))));

 req->params.op_code = (( __le32)(__builtin_constant_p((__u32)((flash_opcode))) ? ((__u32)( (((__u32)((flash_opcode)) & (__u32)0x000000ffUL) << 24) | (((__u32)((flash_opcode)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((flash_opcode)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((flash_opcode)) & (__u32)0xff000000UL) >> 24))) : __fswab32((flash_opcode))));
 req->params.data_buf_size = (( __le32)(__builtin_constant_p((__u32)((buf_size))) ? ((__u32)( (((__u32)((buf_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((buf_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((buf_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((buf_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((buf_size))));

 status = be_mcc_notify(adapter);
 if (status)
  goto err_unlock;

 mutex_unlock(&adapter->mcc_lock);

 if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
      msecs_to_jiffies(40000)))
  status = -110;
 else
  status = adapter->flash_status;

 return status;

err_unlock:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
    u16 img_optype, u32 img_offset, u32 crc_offset)
{
 struct be_cmd_read_flash_crc *req;
 struct be_mcc_wrb *wrb;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          6, sizeof(*req),
          wrb, ((void *)0));

 req->params.op_type = (( __le32)(__builtin_constant_p((__u32)((img_optype))) ? ((__u32)( (((__u32)((img_optype)) & (__u32)0x000000ffUL) << 24) | (((__u32)((img_optype)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((img_optype)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((img_optype)) & (__u32)0xff000000UL) >> 24))) : __fswab32((img_optype))));
 if (img_optype == OPTYPE_OFFSET_SPECIFIED)
  req->params.offset = (( __le32)(__builtin_constant_p((__u32)((img_offset + crc_offset))) ? ((__u32)( (((__u32)((img_offset + crc_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((img_offset + crc_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((img_offset + crc_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((img_offset + crc_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((img_offset + crc_offset))));
 else
  req->params.offset = (( __le32)(__builtin_constant_p((__u32)((crc_offset))) ? ((__u32)( (((__u32)((crc_offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)((crc_offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((crc_offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((crc_offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32((crc_offset))));

 req->params.op_code = (( __le32)(__builtin_constant_p((__u32)((4))) ? ((__u32)( (((__u32)((4)) & (__u32)0x000000ffUL) << 24) | (((__u32)((4)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((4)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((4)) & (__u32)0xff000000UL) >> 24))) : __fswab32((4))));
 req->params.data_buf_size = (( __le32)(__builtin_constant_p((__u32)((0x4))) ? ((__u32)( (((__u32)((0x4)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x4)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x4)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x4)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x4))));

 status = be_mcc_notify_wait(adapter);
 if (!status)
  memcpy(flashed_crc, req->crc, 4);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static char flash_cookie[2][16] = {"*** SE FLAS", "H DIRECTORY *** "};

static bool phy_flashing_required(struct be_adapter *adapter)
{
 return (adapter->phy.phy_type == PHY_TYPE_TN_8022 &&
  adapter->phy.interface_type == PHY_TYPE_BASET_10GB);
}

static bool is_comp_in_ufi(struct be_adapter *adapter,
      struct flash_section_info *fsec, int type)
{
 int i = 0, img_type = 0;
 struct flash_section_info_g2 *fsec_g2 = ((void *)0);

 if ((adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))
  fsec_g2 = (struct flash_section_info_g2 *)fsec;

 for (i = 0; i < 32; i++) {
  if (fsec_g2)
   img_type = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec_g2->fsec_entry[i].type))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec_g2->fsec_entry[i].type)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec_g2->fsec_entry[i].type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec_g2->fsec_entry[i].type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec_g2->fsec_entry[i].type)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec_g2->fsec_entry[i].type)));
  else
   img_type = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec->fsec_entry[i].type)));

  if (img_type == type)
   return true;
 }
 return false;
}

static struct flash_section_info *get_fsec_info(struct be_adapter *adapter,
      int header_size,
      const struct firmware *fw)
{
 struct flash_section_info *fsec = ((void *)0);
 const u8 *p = fw->data;

 p += header_size;
 while (p < (fw->data + fw->size)) {
  fsec = (struct flash_section_info *)p;
  if (!memcmp(flash_cookie, fsec->cookie, sizeof(flash_cookie)))
   return fsec;
  p += 32;
 }
 return ((void *)0);
}

static int be_check_flash_crc(struct be_adapter *adapter, const u8 *p,
         u32 img_offset, u32 img_size, int hdr_size,
         u16 img_optype, bool *crc_match)
{
 u32 crc_offset;
 int status;
 u8 crc[4];

 status = be_cmd_get_flash_crc(adapter, crc, img_optype, img_offset,
          img_size - 4);
 if (status)
  return status;

 crc_offset = hdr_size + img_offset + img_size - 4;


 if (!memcmp(crc, p + crc_offset, 4))
  *crc_match = true;
 else
  *crc_match = false;

 return status;
}

static int be_flash(struct be_adapter *adapter, const u8 *img,
      struct be_dma_mem *flash_cmd, int optype, int img_size,
      u32 img_offset)
{
 u32 flash_op, num_bytes, total_bytes = img_size, bytes_sent = 0;
 struct be_cmd_write_flashrom *req = flash_cmd->va;
 int status;

 while (total_bytes) {
  num_bytes = __builtin_choose_expr(((!!(sizeof((typeof((u32)(32 * 1024)) *)1 == (typeof((u32)(total_bytes)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(32 * 1024)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(total_bytes)) * 0l)) : (int *)8))))), (((u32)(32 * 1024)) < ((u32)(total_bytes)) ? ((u32)(32 * 1024)) : ((u32)(total_bytes))), ({ typeof((u32)(32 * 1024)) __UNIQUE_ID___x124 = ((u32)(32 * 1024)); typeof((u32)(total_bytes)) __UNIQUE_ID___y125 = ((u32)(total_bytes)); ((__UNIQUE_ID___x124) < (__UNIQUE_ID___y125) ? (__UNIQUE_ID___x124) : (__UNIQUE_ID___y125)); }));

  total_bytes -= num_bytes;

  if (!total_bytes) {
   if (optype == OPTYPE_PHY_FW)
    flash_op = 9;
   else
    flash_op = 1;
  } else {
   if (optype == OPTYPE_PHY_FW)
    flash_op = 10;
   else
    flash_op = 2;
  }

  memcpy(req->data_buf, img, num_bytes);
  img += num_bytes;
  status = be_cmd_write_flashrom(adapter, flash_cmd, optype,
            flash_op, img_offset +
            bytes_sent, num_bytes);
  if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_REQUEST &&
      optype == OPTYPE_PHY_FW)
   break;
  else if (status)
   return status;

  bytes_sent += num_bytes;
 }
 return 0;
}


static bool be_fw_ncsi_supported(char *ver)
{
 int v1[4] = {3, 102, 148, 0};
 int v2[4];
 int i;

 if (sscanf(ver, "%d.%d.%d.%d", &v2[0], &v2[1], &v2[2], &v2[3]) != 4)
  return false;

 for (i = 0; i < 4; i++) {
  if (v1[i] < v2[i])
   return true;
  else if (v1[i] > v2[i])
   return false;
 }

 return true;
}


static int be_flash_BEx(struct be_adapter *adapter,
   const struct firmware *fw,
   struct be_dma_mem *flash_cmd, int num_of_images)
{
 int img_hdrs_size = (num_of_images * sizeof(struct image_hdr));
 struct device *dev = &adapter->pdev->dev;
 struct flash_section_info *fsec = ((void *)0);
 int status, i, filehdr_size, num_comp;
 const struct flash_comp *pflashcomp;
 bool crc_match;
 const u8 *p;

 static const struct flash_comp gen3_flash_types[] = {
  { BE3_ISCSI_PRIMARY_IMAGE_START, OPTYPE_ISCSI_ACTIVE,
   BE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_ISCSI},
  { BE3_REDBOOT_START, OPTYPE_REDBOOT,
   BE3_REDBOOT_COMP_MAX_SIZE, IMAGE_BOOT_CODE},
  { BE3_ISCSI_BIOS_START, OPTYPE_BIOS,
   BE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_ISCSI},
  { BE3_PXE_BIOS_START, OPTYPE_PXE_BIOS,
   BE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_PXE},
  { BE3_FCOE_BIOS_START, OPTYPE_FCOE_BIOS,
   BE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_FCOE},
  { BE3_ISCSI_BACKUP_IMAGE_START, OPTYPE_ISCSI_BACKUP,
   BE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_ISCSI},
  { BE3_FCOE_PRIMARY_IMAGE_START, OPTYPE_FCOE_FW_ACTIVE,
   BE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_FCOE},
  { BE3_FCOE_BACKUP_IMAGE_START, OPTYPE_FCOE_FW_BACKUP,
   BE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_FCOE},
  { BE3_NCSI_START, OPTYPE_NCSI_FW,
   BE3_NCSI_COMP_MAX_SIZE, IMAGE_NCSI},
  { BE3_PHY_FW_START, OPTYPE_PHY_FW,
   BE3_PHY_FW_COMP_MAX_SIZE, IMAGE_FIRMWARE_PHY}
 };

 static const struct flash_comp gen2_flash_types[] = {
  { BE2_ISCSI_PRIMARY_IMAGE_START, OPTYPE_ISCSI_ACTIVE,
   BE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_ISCSI},
  { BE2_REDBOOT_START, OPTYPE_REDBOOT,
   BE2_REDBOOT_COMP_MAX_SIZE, IMAGE_BOOT_CODE},
  { BE2_ISCSI_BIOS_START, OPTYPE_BIOS,
   BE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_ISCSI},
  { BE2_PXE_BIOS_START, OPTYPE_PXE_BIOS,
   BE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_PXE},
  { BE2_FCOE_BIOS_START, OPTYPE_FCOE_BIOS,
   BE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_FCOE},
  { BE2_ISCSI_BACKUP_IMAGE_START, OPTYPE_ISCSI_BACKUP,
   BE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_ISCSI},
  { BE2_FCOE_PRIMARY_IMAGE_START, OPTYPE_FCOE_FW_ACTIVE,
   BE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_FCOE},
  { BE2_FCOE_BACKUP_IMAGE_START, OPTYPE_FCOE_FW_BACKUP,
    BE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_FCOE}
 };

 if ((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710)) {
  pflashcomp = gen3_flash_types;
  filehdr_size = sizeof(struct flash_file_hdr_g3);
  num_comp = (sizeof(gen3_flash_types) / sizeof((gen3_flash_types)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((gen3_flash_types)), typeof(&(gen3_flash_types)[0])))); }))));
 } else {
  pflashcomp = gen2_flash_types;
  filehdr_size = sizeof(struct flash_file_hdr_g2);
  num_comp = (sizeof(gen2_flash_types) / sizeof((gen2_flash_types)[0]) + ((int)(sizeof(struct { int:(-!!(__builtin_types_compatible_p(typeof((gen2_flash_types)), typeof(&(gen2_flash_types)[0])))); }))));
  img_hdrs_size = 0;
 }


 fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
 if (!fsec) {
  _dev_err(dev, "Invalid Cookie. FW image may be corrupted\n");
  return -1;
 }
 for (i = 0; i < num_comp; i++) {
  if (!is_comp_in_ufi(adapter, fsec, pflashcomp[i].img_type))
   continue;

  if ((pflashcomp[i].optype == OPTYPE_NCSI_FW) &&
      !be_fw_ncsi_supported(adapter->fw_ver)) {
   _dev_info(dev, "NCSI section update is not supported in FW ver %s\n", adapter->fw_ver);
   continue;
  }

  if (pflashcomp[i].optype == OPTYPE_PHY_FW &&
      !phy_flashing_required(adapter))
   continue;

  if (pflashcomp[i].optype == OPTYPE_REDBOOT) {
   status = be_check_flash_crc(adapter, fw->data,
          pflashcomp[i].offset,
          pflashcomp[i].size,
          filehdr_size +
          img_hdrs_size,
          OPTYPE_REDBOOT, &crc_match);
   if (status) {
    _dev_err(dev, "Could not get CRC for 0x%x region\n", pflashcomp[i].optype);


    continue;
   }

   if (crc_match)
    continue;
  }

  p = fw->data + filehdr_size + pflashcomp[i].offset +
   img_hdrs_size;
  if (p + pflashcomp[i].size > fw->data + fw->size)
   return -1;

  status = be_flash(adapter, p, flash_cmd, pflashcomp[i].optype,
      pflashcomp[i].size, 0);
  if (status) {
   _dev_err(dev, "Flashing section type 0x%x failed\n", pflashcomp[i].img_type);

   return status;
  }
 }
 return 0;
}

static u16 be_get_img_optype(struct flash_section_entry fsec_entry)
{
 u32 img_type = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec_entry.type))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec_entry.type)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec_entry.type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec_entry.type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec_entry.type)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec_entry.type)));
 u16 img_optype = (__builtin_constant_p((__u16)(( __u16)(__le16)(fsec_entry.optype))) ? ((__u16)( (((__u16)(( __u16)(__le16)(fsec_entry.optype)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(fsec_entry.optype)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(fsec_entry.optype)));

 if (img_optype != 0xFFFF)
  return img_optype;

 switch (img_type) {
 case IMAGE_FIRMWARE_ISCSI:
  img_optype = OPTYPE_ISCSI_ACTIVE;
  break;
 case IMAGE_BOOT_CODE:
  img_optype = OPTYPE_REDBOOT;
  break;
 case IMAGE_OPTION_ROM_ISCSI:
  img_optype = OPTYPE_BIOS;
  break;
 case IMAGE_OPTION_ROM_PXE:
  img_optype = OPTYPE_PXE_BIOS;
  break;
 case IMAGE_OPTION_ROM_FCOE:
  img_optype = OPTYPE_FCOE_BIOS;
  break;
 case IMAGE_FIRMWARE_BACKUP_ISCSI:
  img_optype = OPTYPE_ISCSI_BACKUP;
  break;
 case IMAGE_NCSI:
  img_optype = OPTYPE_NCSI_FW;
  break;
 case IMAGE_FLASHISM_JUMPVECTOR:
  img_optype = OPTYPE_FLASHISM_JUMPVECTOR;
  break;
 case IMAGE_FIRMWARE_PHY:
  img_optype = OPTYPE_SH_PHY_FW;
  break;
 case IMAGE_REDBOOT_DIR:
  img_optype = OPTYPE_REDBOOT_DIR;
  break;
 case IMAGE_REDBOOT_CONFIG:
  img_optype = OPTYPE_REDBOOT_CONFIG;
  break;
 case IMAGE_UFI_DIR:
  img_optype = OPTYPE_UFI_DIR;
  break;
 default:
  break;
 }

 return img_optype;
}

static int be_flash_skyhawk(struct be_adapter *adapter,
       const struct firmware *fw,
       struct be_dma_mem *flash_cmd, int num_of_images)
{
 int img_hdrs_size = num_of_images * sizeof(struct image_hdr);
 bool crc_match, old_fw_img, flash_offset_support = true;
 struct device *dev = &adapter->pdev->dev;
 struct flash_section_info *fsec = ((void *)0);
 u32 img_offset, img_size, img_type;
 u16 img_optype, flash_optype;
 int status, i, filehdr_size;
 const u8 *p;

 filehdr_size = sizeof(struct flash_file_hdr_g3);
 fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
 if (!fsec) {
  _dev_err(dev, "Invalid Cookie. FW image may be corrupted\n");
  return -22;
 }

retry_flash:
 for (i = 0; i < (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec->fsec_hdr.num_images))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec->fsec_hdr.num_images)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec->fsec_hdr.num_images)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_hdr.num_images)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_hdr.num_images)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec->fsec_hdr.num_images))); i++) {
  img_offset = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].offset))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].offset)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].offset)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].offset)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].offset)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec->fsec_entry[i].offset)));
  img_size = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].pad_size))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].pad_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].pad_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].pad_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].pad_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec->fsec_entry[i].pad_size)));
  img_type = (__builtin_constant_p((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fsec->fsec_entry[i].type)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fsec->fsec_entry[i].type)));
  img_optype = be_get_img_optype(fsec->fsec_entry[i]);
  old_fw_img = fsec->fsec_entry[i].optype == 0xFFFF;

  if (img_optype == 0xFFFF)
   continue;

  if (flash_offset_support)
   flash_optype = OPTYPE_OFFSET_SPECIFIED;
  else
   flash_optype = img_optype;




  if (old_fw_img)
   goto flash;

  status = be_check_flash_crc(adapter, fw->data, img_offset,
         img_size, filehdr_size +
         img_hdrs_size, flash_optype,
         &crc_match);
  if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_REQUEST ||
      ((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_FIELD) {




   if (flash_optype == OPTYPE_OFFSET_SPECIFIED) {
    flash_offset_support = false;
    goto retry_flash;
   }
# 2982 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c"
   _dev_err(dev, "Flash incomplete. Reset the server\n");
   _dev_err(dev, "Download FW image again after reset\n");
   return -11;
  } else if (status) {
   _dev_err(dev, "Could not get CRC for 0x%x region\n", img_optype);

   return -14;
  }

  if (crc_match)
   continue;

flash:
  p = fw->data + filehdr_size + img_offset + img_hdrs_size;
  if (p + img_size > fw->data + fw->size)
   return -1;

  status = be_flash(adapter, p, flash_cmd, flash_optype, img_size,
      img_offset);





  if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_FIELD &&
      flash_optype == OPTYPE_OFFSET_SPECIFIED) {
   flash_offset_support = false;
   goto retry_flash;
  }




  if (old_fw_img &&
      (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_FIELD ||
       (img_optype == OPTYPE_UFI_DIR &&
        ((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_FAILED))) {
   continue;
  } else if (status) {
   _dev_err(dev, "Flashing section type 0x%x failed\n", img_type);


   switch (((enum mcc_addl_status) (status > 0 ? (status >> 16) & 0xFF : 0))) {
   case MCC_ADDL_STATUS_MISSING_SIGNATURE:
    _dev_err(dev, "Digital signature missing in FW\n");

    return -22;
   case MCC_ADDL_STATUS_INVALID_SIGNATURE:
    _dev_err(dev, "Invalid digital signature in FW\n");

    return -22;
   default:
    return -14;
   }
  }
 }
 return 0;
}

int lancer_fw_download(struct be_adapter *adapter,
         const struct firmware *fw)
{
 struct device *dev = &adapter->pdev->dev;
 struct be_dma_mem flash_cmd;
 const u8 *data_ptr = ((void *)0);
 u8 *dest_image_ptr = ((void *)0);
 size_t image_size = 0;
 u32 chunk_size = 0;
 u32 data_written = 0;
 u32 offset = 0;
 int status = 0;
 u8 add_status = 0;
 u8 change_status;

 if (!(((fw->size) & ((typeof(fw->size))(sizeof(u32)) - 1)) == 0)) {
  _dev_err(dev, "FW image size should be multiple of 4\n");
  return -22;
 }

 flash_cmd.size = sizeof(struct lancer_cmd_req_write_object)
    + (32 * 1024);
 flash_cmd.va = dma_alloc_coherent(dev, flash_cmd.size, &flash_cmd.dma,
       ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)));
 if (!flash_cmd.va)
  return -12;

 dest_image_ptr = flash_cmd.va +
    sizeof(struct lancer_cmd_req_write_object);
 image_size = fw->size;
 data_ptr = fw->data;

 while (image_size) {
  chunk_size = __builtin_choose_expr(((!!(sizeof((typeof((u32)(image_size)) *)1 == (typeof((u32)((32 * 1024))) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)(image_size)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)((u32)((32 * 1024))) * 0l)) : (int *)8))))), (((u32)(image_size)) < ((u32)((32 * 1024))) ? ((u32)(image_size)) : ((u32)((32 * 1024)))), ({ typeof((u32)(image_size)) __UNIQUE_ID___x126 = ((u32)(image_size)); typeof((u32)((32 * 1024))) __UNIQUE_ID___y127 = ((u32)((32 * 1024))); ((__UNIQUE_ID___x126) < (__UNIQUE_ID___y127) ? (__UNIQUE_ID___x126) : (__UNIQUE_ID___y127)); }));


  memcpy(dest_image_ptr, data_ptr, chunk_size);

  status = lancer_cmd_write_object(adapter, &flash_cmd,
       chunk_size, offset,
       "/prg",
       &data_written, &change_status,
       &add_status);
  if (status)
   break;

  offset += data_written;
  data_ptr += data_written;
  image_size -= data_written;
 }

 if (!status) {

  status = lancer_cmd_write_object(adapter, &flash_cmd,
       0, offset,
       "/prg",
       &data_written, &change_status,
       &add_status);
 }

 dma_free_coherent(dev, flash_cmd.size, flash_cmd.va, flash_cmd.dma);
 if (status) {
  _dev_err(dev, "Firmware load error\n");
  return (status > 0 ? -5 : status);
 }

 _dev_info(dev, "Firmware flashed successfully\n");

 if (change_status == 0x02) {
  _dev_info(dev, "Resetting adapter to activate new FW\n");
  status = lancer_physdev_ctrl(adapter,
          0x00000002);
  if (status) {
   _dev_err(dev, "Adapter busy, could not reset FW\n");
   _dev_err(dev, "Reboot server to activate new FW\n");
  }
 } else if (change_status != 0x00) {
  _dev_info(dev, "Reboot server to activate new FW\n");
 }

 return 0;
}




static bool be_check_ufi_compatibility(struct be_adapter *adapter,
           struct flash_file_hdr_g3 *fhdr)
{
 if (!fhdr) {
  _dev_err(&adapter->pdev->dev, "Invalid FW UFI file");
  return false;
 }




 switch (fhdr->build[0]) {
 case '4':
  if (!(adapter->pdev->device == 0x720 || adapter->pdev->device == 0x728))
   return false;
  break;
 case '3':
  if (!(adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710))
   return false;
  break;
 case '2':
  if (!(adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))
   return false;
  break;
 default:
  return false;
 }






 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) && fhdr->asic_type_rev == 0)
  return adapter->asic_rev < 0x10;
 else
  return (fhdr->asic_type_rev >= adapter->asic_rev);
}

int be_fw_download(struct be_adapter *adapter, const struct firmware *fw)
{
 struct device *dev = &adapter->pdev->dev;
 struct flash_file_hdr_g3 *fhdr3;
 struct image_hdr *img_hdr_ptr;
 int status = 0, i, num_imgs;
 struct be_dma_mem flash_cmd;

 fhdr3 = (struct flash_file_hdr_g3 *)fw->data;
 if (!be_check_ufi_compatibility(adapter, fhdr3)) {
  _dev_err(dev, "Flash image is not compatible with adapter\n");
  return -22;
 }

 flash_cmd.size = sizeof(struct be_cmd_write_flashrom);
 flash_cmd.va = dma_alloc_coherent(dev, flash_cmd.size, &flash_cmd.dma,
       ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)));
 if (!flash_cmd.va)
  return -12;

 num_imgs = (__builtin_constant_p((__u32)(( __u32)(__le32)(fhdr3->num_imgs))) ? ((__u32)( (((__u32)(( __u32)(__le32)(fhdr3->num_imgs)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(fhdr3->num_imgs)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(fhdr3->num_imgs)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(fhdr3->num_imgs)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(fhdr3->num_imgs)));
 for (i = 0; i < num_imgs; i++) {
  img_hdr_ptr = (struct image_hdr *)(fw->data +
    (sizeof(struct flash_file_hdr_g3) +
     i * sizeof(struct image_hdr)));
  if (!(adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700) &&
      (__builtin_constant_p((__u32)(( __u32)(__le32)(img_hdr_ptr->imageid))) ? ((__u32)( (((__u32)(( __u32)(__le32)(img_hdr_ptr->imageid)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(img_hdr_ptr->imageid)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(img_hdr_ptr->imageid)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(img_hdr_ptr->imageid)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(img_hdr_ptr->imageid))) != 1)
   continue;

  if ((adapter->pdev->device == 0x720 || adapter->pdev->device == 0x728))
   status = be_flash_skyhawk(adapter, fw, &flash_cmd,
        num_imgs);
  else
   status = be_flash_BEx(adapter, fw, &flash_cmd,
           num_imgs);
 }

 dma_free_coherent(dev, flash_cmd.size, flash_cmd.va, flash_cmd.dma);
 if (!status)
  _dev_info(dev, "Firmware flashed successfully\n");

 return status;
}

int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
       struct be_dma_mem *nonemb_cmd)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_acpi_wol_magic_config *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = nonemb_cmd->va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          12, sizeof(*req),
          wrb, nonemb_cmd);
 memcpy(req->magic_mac, mac, 6);

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
   u8 loopback_type, u8 enable)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_lmode *req;
 int status;

 if (!be_cmd_allowed(adapter, 19,
       0xb))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err_unlock;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0xb,
          19, sizeof(*req),
          wrb, ((void *)0));

 req->src_port = port_num;
 req->dest_port = port_num;
 req->loopback_type = loopback_type;
 req->loopback_state = enable;

 status = be_mcc_notify(adapter);
 if (status)
  goto err_unlock;

 mutex_unlock(&adapter->mcc_lock);

 if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
      msecs_to_jiffies(12000)))
  status = -110;

 return status;

err_unlock:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
    u32 loopback_type, u32 pkt_size, u32 num_pkts,
    u64 pattern)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_loopback_test *req;
 struct be_cmd_resp_loopback_test *resp;
 int status;

 if (!be_cmd_allowed(adapter, 18,
       0xb))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0xb,
          18, sizeof(*req), wrb,
          ((void *)0));

 req->hdr.timeout = (( __le32)(__builtin_constant_p((__u32)((15))) ? ((__u32)( (((__u32)((15)) & (__u32)0x000000ffUL) << 24) | (((__u32)((15)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((15)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((15)) & (__u32)0xff000000UL) >> 24))) : __fswab32((15))));
 req->pattern = (( __le64)(__builtin_constant_p((__u64)((pattern))) ? ((__u64)( (((__u64)((pattern)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pattern)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pattern)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pattern)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pattern)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pattern)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pattern)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pattern)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pattern))));
 req->src_port = (( __le32)(__builtin_constant_p((__u32)((port_num))) ? ((__u32)( (((__u32)((port_num)) & (__u32)0x000000ffUL) << 24) | (((__u32)((port_num)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((port_num)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((port_num)) & (__u32)0xff000000UL) >> 24))) : __fswab32((port_num))));
 req->dest_port = (( __le32)(__builtin_constant_p((__u32)((port_num))) ? ((__u32)( (((__u32)((port_num)) & (__u32)0x000000ffUL) << 24) | (((__u32)((port_num)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((port_num)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((port_num)) & (__u32)0xff000000UL) >> 24))) : __fswab32((port_num))));
 req->pkt_size = (( __le32)(__builtin_constant_p((__u32)((pkt_size))) ? ((__u32)( (((__u32)((pkt_size)) & (__u32)0x000000ffUL) << 24) | (((__u32)((pkt_size)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((pkt_size)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((pkt_size)) & (__u32)0xff000000UL) >> 24))) : __fswab32((pkt_size))));
 req->num_pkts = (( __le32)(__builtin_constant_p((__u32)((num_pkts))) ? ((__u32)( (((__u32)((num_pkts)) & (__u32)0x000000ffUL) << 24) | (((__u32)((num_pkts)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((num_pkts)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((num_pkts)) & (__u32)0xff000000UL) >> 24))) : __fswab32((num_pkts))));
 req->loopback_type = (( __le32)(__builtin_constant_p((__u32)((loopback_type))) ? ((__u32)( (((__u32)((loopback_type)) & (__u32)0x000000ffUL) << 24) | (((__u32)((loopback_type)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((loopback_type)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((loopback_type)) & (__u32)0xff000000UL) >> 24))) : __fswab32((loopback_type))));

 status = be_mcc_notify(adapter);
 if (status)
  goto err;

 mutex_unlock(&adapter->mcc_lock);

 wait_for_completion(&adapter->et_cmd_compl);
 resp = embedded_payload(wrb);
 status = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->status))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->status)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->status)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->status)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->status)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->status)));

 return status;
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,
   u32 byte_cnt, struct be_dma_mem *cmd)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_ddrdma_test *req;
 int status;
 int i, j = 0;

 if (!be_cmd_allowed(adapter, 17,
       0xb))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = cmd->va;
 be_wrb_cmd_hdr_prepare(&req->hdr, 0xb,
          17, cmd->size, wrb,
          cmd);

 req->pattern = (( __le64)(__builtin_constant_p((__u64)((pattern))) ? ((__u64)( (((__u64)((pattern)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)((pattern)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)((pattern)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)((pattern)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)((pattern)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)((pattern)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)((pattern)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)((pattern)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64((pattern))));
 req->byte_count = (( __le32)(__builtin_constant_p((__u32)((byte_cnt))) ? ((__u32)( (((__u32)((byte_cnt)) & (__u32)0x000000ffUL) << 24) | (((__u32)((byte_cnt)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((byte_cnt)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((byte_cnt)) & (__u32)0xff000000UL) >> 24))) : __fswab32((byte_cnt))));
 for (i = 0; i < byte_cnt; i++) {
  req->snd_buff[i] = (u8)(pattern >> (j*8));
  j++;
  if (j > 7)
   j = 0;
 }

 status = be_mcc_notify_wait(adapter);

 if (!status) {
  struct be_cmd_resp_ddrdma_test *resp;

  resp = cmd->va;
  if ((memcmp(resp->rcv_buff, req->snd_buff, byte_cnt) != 0) ||
      resp->snd_err) {
   status = -1;
  }
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_get_seeprom_data(struct be_adapter *adapter,
       struct be_dma_mem *nonemb_cmd)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_seeprom_read *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = nonemb_cmd->va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          30, sizeof(*req), wrb,
          nonemb_cmd);

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_get_phy_info(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_phy_info *req;
 struct be_dma_mem cmd;
 int status;

 if (!be_cmd_allowed(adapter, 102,
       0x1))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 cmd.size = sizeof(struct be_cmd_req_get_phy_info);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
  status = -12;
  goto err;
 }

 req = cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          102, sizeof(*req),
          wrb, &cmd);

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_phy_info *resp_phy_info =
    cmd.va + sizeof(struct be_cmd_req_hdr);

  adapter->phy.phy_type = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp_phy_info->phy_type))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp_phy_info->phy_type)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp_phy_info->phy_type)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp_phy_info->phy_type)));
  adapter->phy.interface_type =
   (__builtin_constant_p((__u16)(( __u16)(__le16)(resp_phy_info->interface_type))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp_phy_info->interface_type)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp_phy_info->interface_type)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp_phy_info->interface_type)));
  adapter->phy.auto_speeds_supported =
   (__builtin_constant_p((__u16)(( __u16)(__le16)(resp_phy_info->auto_speeds_supported))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp_phy_info->auto_speeds_supported)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp_phy_info->auto_speeds_supported)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp_phy_info->auto_speeds_supported)));
  adapter->phy.fixed_speeds_supported =
   (__builtin_constant_p((__u16)(( __u16)(__le16)(resp_phy_info->fixed_speeds_supported))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp_phy_info->fixed_speeds_supported)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp_phy_info->fixed_speeds_supported)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp_phy_info->fixed_speeds_supported)));
  adapter->phy.misc_params =
   (__builtin_constant_p((__u32)(( __u32)(__le32)(resp_phy_info->misc_params))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp_phy_info->misc_params)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp_phy_info->misc_params)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp_phy_info->misc_params)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp_phy_info->misc_params)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp_phy_info->misc_params)));

  if ((adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) {
   adapter->phy.fixed_speeds_supported =
    8 |
    4;
  }
 }
 dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_qos *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          28, sizeof(*req), wrb, ((void *)0));

 req->hdr.domain = domain;
 req->valid_bits = (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1))));
 req->max_bps_nic = (( __le32)(__builtin_constant_p((__u32)((bps))) ? ((__u32)( (((__u32)((bps)) & (__u32)0x000000ffUL) << 24) | (((__u32)((bps)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((bps)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((bps)) & (__u32)0xff000000UL) >> 24))) : __fswab32((bps))));

 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_get_cntl_attributes(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_cntl_attribs *req;
 struct be_cmd_resp_cntl_attribs *resp;
 int status, i;
 int payload_len = __builtin_choose_expr(((!!(sizeof((typeof(sizeof(*req)) *)1 == (typeof(sizeof(*resp)) *)1))) && ((sizeof(int) == sizeof(*(8 ? ((void *)((long)(sizeof(*req)) * 0l)) : (int *)8))) && (sizeof(int) == sizeof(*(8 ? ((void *)((long)(sizeof(*resp)) * 0l)) : (int *)8))))), ((sizeof(*req)) > (sizeof(*resp)) ? (sizeof(*req)) : (sizeof(*resp))), ({ typeof(sizeof(*req)) __UNIQUE_ID___x128 = (sizeof(*req)); typeof(sizeof(*resp)) __UNIQUE_ID___y129 = (sizeof(*resp)); ((__UNIQUE_ID___x128) > (__UNIQUE_ID___y129) ? (__UNIQUE_ID___x128) : (__UNIQUE_ID___y129)); }));
 struct mgmt_controller_attrib *attribs;
 struct be_dma_mem attribs_cmd;
 u32 *serial_num;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 memset(&attribs_cmd, 0, sizeof(struct be_dma_mem));
 attribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);
 attribs_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,
         attribs_cmd.size,
         &attribs_cmd.dma, ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!attribs_cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory allocation failure\n");
  status = -12;
  goto err;
 }

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = attribs_cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          32, payload_len,
          wrb, &attribs_cmd);

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  attribs = attribs_cmd.va + sizeof(struct be_cmd_resp_hdr);
  adapter->hba_port_num = attribs->hba_attribs.phy_port;
  serial_num = attribs->hba_attribs.controller_serial_number;
  for (i = 0; i < 8; i++)
   adapter->serial_num[i] = (__builtin_constant_p((__u32)(( __u32)(__le32)(serial_num[i]))) ? ((__u32)( (((__u32)(( __u32)(__le32)(serial_num[i])) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(serial_num[i])) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(serial_num[i])) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(serial_num[i])) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(serial_num[i]))) &
    (((((1UL))) << ((16) % 64)) - 1);



  if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
   adapter->pf_num = attribs->hba_attribs.pci_funcnum;
 }

err:
 mutex_unlock(&adapter->mbox_lock);
 if (attribs_cmd.va)
  dma_free_coherent(&adapter->pdev->dev, attribs_cmd.size,
      attribs_cmd.va, attribs_cmd.dma);
 return status;
}


int be_cmd_req_native_mode(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_func_cap *req;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          103,
          sizeof(*req), wrb, ((void *)0));

 req->valid_cap_flags = (( __le32)(__builtin_constant_p((__u32)((2 | 4))) ? ((__u32)( (((__u32)((2 | 4)) & (__u32)0x000000ffUL) << 24) | (((__u32)((2 | 4)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((2 | 4)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((2 | 4)) & (__u32)0xff000000UL) >> 24))) : __fswab32((2 | 4))));

 req->cap_flags = (( __le32)(__builtin_constant_p((__u32)((4))) ? ((__u32)( (((__u32)((4)) & (__u32)0x000000ffUL) << 24) | (((__u32)((4)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((4)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((4)) & (__u32)0xff000000UL) >> 24))) : __fswab32((4))));

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_set_func_cap *resp = embedded_payload(wrb);

  adapter->be3_native = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->cap_flags))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->cap_flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->cap_flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->cap_flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->cap_flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->cap_flags))) &
     4;
  if (!adapter->be3_native)
   _dev_warn(&adapter->pdev->dev, "adapter not in advanced mode\n");

 }
err:
 mutex_unlock(&adapter->mbox_lock);
 return status;
}


int be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,
        u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_fn_privileges *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          170, sizeof(*req),
          wrb, ((void *)0));

 req->hdr.domain = domain;

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_fn_privileges *resp =
      embedded_payload(wrb);

  *privilege = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->privilege_mask))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->privilege_mask)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->privilege_mask)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->privilege_mask)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->privilege_mask)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->privilege_mask)));




  if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) && be_is_mc(adapter) &&
      (!adapter->virtfn))
   *privilege = (BE_PRIV_VHADM | BE_PRIV_DEVCFG | BE_PRIV_DEVSEC);
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,
        u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_fn_privileges *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          100, sizeof(*req),
          wrb, ((void *)0));
 req->hdr.domain = domain;
 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
  req->privileges_lancer = (( __le32)(__builtin_constant_p((__u32)((privileges))) ? ((__u32)( (((__u32)((privileges)) & (__u32)0x000000ffUL) << 24) | (((__u32)((privileges)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((privileges)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((privileges)) & (__u32)0xff000000UL) >> 24))) : __fswab32((privileges))));
 else
  req->privileges = (( __le32)(__builtin_constant_p((__u32)((privileges))) ? ((__u32)( (((__u32)((privileges)) & (__u32)0x000000ffUL) << 24) | (((__u32)((privileges)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((privileges)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((privileges)) & (__u32)0xff000000UL) >> 24))) : __fswab32((privileges))));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}





int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
        bool *pmac_id_valid, u32 *pmac_id, u32 if_handle,
        u8 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_mac_list *req;
 int status;
 int mac_count;
 struct be_dma_mem get_mac_list_cmd;
 int i;

 memset(&get_mac_list_cmd, 0, sizeof(struct be_dma_mem));
 get_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);
 get_mac_list_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,
       get_mac_list_cmd.size,
       &get_mac_list_cmd.dma,
       ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));

 if (!get_mac_list_cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory allocation failure during GET_MAC_LIST\n");

  return -12;
 }

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto out;
 }

 req = get_mac_list_cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          147,
          get_mac_list_cmd.size, wrb, &get_mac_list_cmd);
 req->hdr.domain = domain;
 req->mac_type = MAC_ADDRESS_TYPE_NETWORK;
 if (*pmac_id_valid) {
  req->mac_id = (( __le32)(__builtin_constant_p((__u32)((*pmac_id))) ? ((__u32)( (((__u32)((*pmac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)((*pmac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((*pmac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((*pmac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32((*pmac_id))));
  req->iface_id = (( __le16)(__builtin_constant_p((__u16)((if_handle))) ? ((__u16)( (((__u16)((if_handle)) & (__u16)0x00ffU) << 8) | (((__u16)((if_handle)) & (__u16)0xff00U) >> 8))) : __fswab16((if_handle))));
  req->perm_override = 0;
 } else {
  req->perm_override = 1;
 }

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_mac_list *resp =
      get_mac_list_cmd.va;

  if (*pmac_id_valid) {
   memcpy(mac, resp->macid_macaddr.mac_addr_id.macaddr,
          6);
   goto out;
  }

  mac_count = resp->true_mac_count + resp->pseudo_mac_count;





  for (i = 0; i < mac_count; i++) {
   struct get_list_macaddr *mac_entry;
   u16 mac_addr_size;
   u32 mac_id;

   mac_entry = &resp->macaddr_list[i];
   mac_addr_size = (__builtin_constant_p((__u16)(( __u16)(__le16)(mac_entry->mac_addr_size))) ? ((__u16)( (((__u16)(( __u16)(__le16)(mac_entry->mac_addr_size)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(mac_entry->mac_addr_size)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(mac_entry->mac_addr_size)));



   if (mac_addr_size == sizeof(u32)) {
    *pmac_id_valid = true;
    mac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;
    *pmac_id = (__builtin_constant_p((__u32)(( __u32)(__le32)(mac_id))) ? ((__u32)( (((__u32)(( __u32)(__le32)(mac_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(mac_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(mac_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(mac_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(mac_id)));
    goto out;
   }
  }

  *pmac_id_valid = false;
  memcpy(mac, resp->macaddr_list[0].mac_addr_id.macaddr,
         6);
 }

out:
 mutex_unlock(&adapter->mcc_lock);
 dma_free_coherent(&adapter->pdev->dev, get_mac_list_cmd.size,
     get_mac_list_cmd.va, get_mac_list_cmd.dma);
 return status;
}

int be_cmd_get_active_mac(struct be_adapter *adapter, u32 curr_pmac_id,
     u8 *mac, u32 if_handle, bool active, u32 domain)
{
 if (!active)
  be_cmd_get_mac_from_list(adapter, mac, &active, &curr_pmac_id,
      if_handle, domain);
 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
  return be_cmd_mac_addr_query(adapter, mac, false,
          if_handle, curr_pmac_id);
 else

  return be_cmd_get_mac_from_list(adapter, mac, &active,
      &curr_pmac_id,
      if_handle, domain);
}

int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac)
{
 int status;
 bool pmac_valid = false;

 eth_zero_addr(mac);

 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))) {
  if ((!adapter->virtfn))
   status = be_cmd_mac_addr_query(adapter, mac, true, 0,
             0);
  else
   status = be_cmd_mac_addr_query(adapter, mac, false,
             adapter->if_handle, 0);
 } else {
  status = be_cmd_get_mac_from_list(adapter, mac, &pmac_valid,
        ((void *)0), adapter->if_handle, 0);
 }

 return status;
}


int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,
   u8 mac_count, u32 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_mac_list *req;
 int status;
 struct be_dma_mem cmd;

 memset(&cmd, 0, sizeof(struct be_dma_mem));
 cmd.size = sizeof(struct be_cmd_req_set_mac_list);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)(0x400u|0x800u)) | (( gfp_t)0x40u) | (( gfp_t)0x80u)));
 if (!cmd.va)
  return -12;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = cmd.va;
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          148, sizeof(*req),
          wrb, &cmd);

 req->hdr.domain = domain;
 req->mac_count = mac_count;
 if (mac_count)
  memcpy(req->mac, mac_array, 6*mac_count);

 status = be_mcc_notify_wait(adapter);

err:
 dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
 mutex_unlock(&adapter->mcc_lock);
 return status;
}





int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom)
{
 bool active_mac = false;
 u8 old_mac[6];
 u32 pmac_id;
 int status;

 status = be_cmd_get_mac_from_list(adapter, old_mac, &active_mac,
       &pmac_id, if_id, dom);

 if (!status && active_mac)
  be_cmd_pmac_del(adapter, if_id, pmac_id, dom);

 return be_cmd_set_mac_list(adapter, mac, mac ? 1 : 0, dom);
}

int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,
     u32 domain, u16 intf_id, u16 hsw_mode, u8 spoofchk)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_hsw_config *req;
 void *ctxt;
 int status;

 if (!be_cmd_allowed(adapter, 153,
       0x1))
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);
 ctxt = &req->context;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          153, sizeof(*req), wrb,
          ((void *)0));

 req->hdr.domain = domain;
 amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, interface_id)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->interface_id)), (((size_t)&(((struct amap_set_hsw_context *)0)->interface_id))%32), intf_id);
 if (pvid) {
  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, pvid_valid)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->pvid_valid)), (((size_t)&(((struct amap_set_hsw_context *)0)->pvid_valid))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, pvid)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->pvid)), (((size_t)&(((struct amap_set_hsw_context *)0)->pvid))%32), pvid);
 }
 if (hsw_mode) {
  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, interface_id)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->interface_id)), (((size_t)&(((struct amap_set_hsw_context *)0)->interface_id))%32), adapter->hba_port_num);

  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, pport)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->pport)), (((size_t)&(((struct amap_set_hsw_context *)0)->pport))%32), 1);
  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, port_fwd_type)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->port_fwd_type)), (((size_t)&(((struct amap_set_hsw_context *)0)->port_fwd_type))%32), hsw_mode);

 }


 if (!((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) && spoofchk) {
  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, mac_spoofchk)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->mac_spoofchk)), (((size_t)&(((struct amap_set_hsw_context *)0)->mac_spoofchk))%32), spoofchk);

  amap_set(ctxt, __builtin_offsetof(struct amap_set_hsw_context, vlan_spoofchk)/32, amap_mask(sizeof(((struct amap_set_hsw_context *)0)->vlan_spoofchk)), (((size_t)&(((struct amap_set_hsw_context *)0)->vlan_spoofchk))%32), spoofchk);

 }

 swap_dws(req->context, sizeof(req->context));
 status = be_mcc_notify_wait(adapter);

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}


int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,
     u32 domain, u16 intf_id, u8 *mode, bool *spoofchk)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_hsw_config *req;
 void *ctxt;
 int status;
 u16 vid;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);
 ctxt = &req->context;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          152, sizeof(*req), wrb,
          ((void *)0));

 req->hdr.domain = domain;
 amap_set(ctxt, __builtin_offsetof(struct amap_get_hsw_req_context, interface_id)/32, amap_mask(sizeof(((struct amap_get_hsw_req_context *)0)->interface_id)), (((size_t)&(((struct amap_get_hsw_req_context *)0)->interface_id))%32), intf_id);

 amap_set(ctxt, __builtin_offsetof(struct amap_get_hsw_req_context, pvid_valid)/32, amap_mask(sizeof(((struct amap_get_hsw_req_context *)0)->pvid_valid)), (((size_t)&(((struct amap_get_hsw_req_context *)0)->pvid_valid))%32), 1);

 if (!((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)) && mode) {
  amap_set(ctxt, __builtin_offsetof(struct amap_get_hsw_req_context, interface_id)/32, amap_mask(sizeof(((struct amap_get_hsw_req_context *)0)->interface_id)), (((size_t)&(((struct amap_get_hsw_req_context *)0)->interface_id))%32), adapter->hba_port_num);

  amap_set(ctxt, __builtin_offsetof(struct amap_get_hsw_req_context, pport)/32, amap_mask(sizeof(((struct amap_get_hsw_req_context *)0)->pport)), (((size_t)&(((struct amap_get_hsw_req_context *)0)->pport))%32), 1);
 }
 swap_dws(req->context, sizeof(req->context));

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_hsw_config *resp =
      embedded_payload(wrb);

  swap_dws(&resp->context, sizeof(resp->context));
  vid = amap_get(&resp->context, __builtin_offsetof(struct amap_get_hsw_resp_context, pvid)/32, amap_mask(sizeof(((struct amap_get_hsw_resp_context *)0)->pvid)), (((size_t)&(((struct amap_get_hsw_resp_context *)0)->pvid))%32));

  if (pvid)
   *pvid = (__builtin_constant_p((__u16)(( __u16)(__le16)(vid))) ? ((__u16)( (((__u16)(( __u16)(__le16)(vid)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(vid)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(vid)));
  if (mode)
   *mode = amap_get(&resp->context, __builtin_offsetof(struct amap_get_hsw_resp_context, port_fwd_type)/32, amap_mask(sizeof(((struct amap_get_hsw_resp_context *)0)->port_fwd_type)), (((size_t)&(((struct amap_get_hsw_resp_context *)0)->port_fwd_type))%32));

  if (spoofchk)
   *spoofchk =
    amap_get(&resp->context, __builtin_offsetof(struct amap_get_hsw_resp_context, spoofchk)/32, amap_mask(sizeof(((struct amap_get_hsw_resp_context *)0)->spoofchk)), (((size_t)&(((struct amap_get_hsw_resp_context *)0)->spoofchk))%32));

 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static bool be_is_wol_excluded(struct be_adapter *adapter)
{
 struct pci_dev *pdev = adapter->pdev;

 if ((adapter->virtfn))
  return true;

 switch (pdev->subsystem_device) {
 case 0xE602:
 case 0xE642:
 case 0xE612:
 case 0xE652:
  return true;
 default:
  return false;
 }
}

int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_acpi_wol_magic_config_v1 *req;
 int status = 0;
 struct be_dma_mem cmd;

 if (!be_cmd_allowed(adapter, 12,
       0x3))
  return -1;

 if (be_is_wol_excluded(adapter))
  return status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 memset(&cmd, 0, sizeof(struct be_dma_mem));
 cmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory allocation failure\n");
  status = -12;
  goto err;
 }

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x3,
          12,
          sizeof(*req), wrb, &cmd);

 req->hdr.version = 1;
 req->query_options = 2;

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_acpi_wol_magic_config_v1 *resp;

  resp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;

  adapter->wol_cap = resp->wol_settings;


  if (adapter->wol_cap & 0x1 &&
      !is_zero_ether_addr(resp->magic_mac))
   adapter->wol_en = true;
 }
err:
 mutex_unlock(&adapter->mbox_lock);
 if (cmd.va)
  dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
      cmd.dma);
 return status;

}

int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)
{
 struct be_dma_mem extfat_cmd;
 struct be_fat_conf_params *cfgs;
 int status;
 int i, j;

 memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
 extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
 extfat_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,
        extfat_cmd.size, &extfat_cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!extfat_cmd.va)
  return -12;

 status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
 if (status)
  goto err;

 cfgs = (struct be_fat_conf_params *)
   (extfat_cmd.va + sizeof(struct be_cmd_resp_hdr));
 for (i = 0; i < (__builtin_constant_p((__u32)(( __u32)(__le32)(cfgs->num_modules))) ? ((__u32)( (((__u32)(( __u32)(__le32)(cfgs->num_modules)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(cfgs->num_modules)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(cfgs->num_modules)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(cfgs->num_modules)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(cfgs->num_modules))); i++) {
  u32 num_modes = (__builtin_constant_p((__u32)(( __u32)(__le32)(cfgs->module[i].num_modes))) ? ((__u32)( (((__u32)(( __u32)(__le32)(cfgs->module[i].num_modes)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(cfgs->module[i].num_modes)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(cfgs->module[i].num_modes)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(cfgs->module[i].num_modes)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(cfgs->module[i].num_modes)));

  for (j = 0; j < num_modes; j++) {
   if (cfgs->module[i].trace_lvl[j].mode == 0)
    cfgs->module[i].trace_lvl[j].dbg_lvl =
       (( __le32)(__builtin_constant_p((__u32)((level))) ? ((__u32)( (((__u32)((level)) & (__u32)0x000000ffUL) << 24) | (((__u32)((level)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((level)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((level)) & (__u32)0xff000000UL) >> 24))) : __fswab32((level))));
  }
 }

 status = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd, cfgs);
err:
 dma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,
     extfat_cmd.dma);
 return status;
}

int be_cmd_get_fw_log_level(struct be_adapter *adapter)
{
 struct be_dma_mem extfat_cmd;
 struct be_fat_conf_params *cfgs;
 int status, j;
 int level = 0;

 memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
 extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
 extfat_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,
        extfat_cmd.size, &extfat_cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));

 if (!extfat_cmd.va) {
  _dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n", __func__);

  goto err;
 }

 status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
 if (!status) {
  cfgs = (struct be_fat_conf_params *)(extfat_cmd.va +
      sizeof(struct be_cmd_resp_hdr));

  for (j = 0; j < (__builtin_constant_p((__u32)(( __u32)(__le32)(cfgs->module[0].num_modes))) ? ((__u32)( (((__u32)(( __u32)(__le32)(cfgs->module[0].num_modes)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(cfgs->module[0].num_modes)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(cfgs->module[0].num_modes)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(cfgs->module[0].num_modes)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(cfgs->module[0].num_modes))); j++) {
   if (cfgs->module[0].trace_lvl[j].mode == 0)
    level = cfgs->module[0].trace_lvl[j].dbg_lvl;
  }
 }
 dma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,
     extfat_cmd.dma);
err:
 return level;
}

int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
       struct be_dma_mem *cmd)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_ext_fat_caps *req;
 int status;

 if (!be_cmd_allowed(adapter, 125,
       0x1))
  return -1;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = cmd->va;
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          125,
          cmd->size, wrb, cmd);
 req->parameter_type = (( __le32)(__builtin_constant_p((__u32)((1))) ? ((__u32)( (((__u32)((1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((1))));

 status = be_mbox_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mbox_lock);
 return status;
}

int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
       struct be_dma_mem *cmd,
       struct be_fat_conf_params *configs)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_set_ext_fat_caps *req;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = cmd->va;
 memcpy(&req->set_params, configs, sizeof(struct be_fat_conf_params));
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          126,
          cmd->size, wrb, cmd);

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_query_port_name(struct be_adapter *adapter)
{
 struct be_cmd_req_get_port_name *req;
 struct be_mcc_wrb *wrb;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          77, sizeof(*req), wrb,
          ((void *)0));
 if (!((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
  req->hdr.version = 1;

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_port_name *resp = embedded_payload(wrb);

  adapter->port_name = resp->port_name[adapter->hba_port_num];
 } else {
  adapter->port_name = adapter->hba_port_num + '0';
 }

 mutex_unlock(&adapter->mbox_lock);
 return status;
}
# 4249 "/home/nathan/src/linux-next/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_nic_res_desc *be_get_nic_desc(u8 *buf, u32 desc_count,
            bool get_vft, u8 pf_num)
{
 struct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;
 struct be_nic_res_desc *nic;
 int i;

 for (i = 0; i < desc_count; i++) {
  if (hdr->desc_type == 0x41 ||
      hdr->desc_type == 0x51) {
   nic = (struct be_nic_res_desc *)hdr;

   if ((pf_num == 255 ||
        nic->pf_num == pf_num) &&
       (!get_vft || nic->flags & ((((1UL))) << (3))))
    return nic;
  }
  hdr->desc_len = hdr->desc_len ? : 72;
  hdr = (void *)hdr + hdr->desc_len;
 }
 return ((void *)0);
}

static struct be_nic_res_desc *be_get_vft_desc(u8 *buf, u32 desc_count,
            u8 pf_num)
{
 return be_get_nic_desc(buf, desc_count, true, pf_num);
}

static struct be_nic_res_desc *be_get_func_nic_desc(u8 *buf, u32 desc_count,
          u8 pf_num)
{
 return be_get_nic_desc(buf, desc_count, false, pf_num);
}

static struct be_pcie_res_desc *be_get_pcie_desc(u8 *buf, u32 desc_count,
       u8 pf_num)
{
 struct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;
 struct be_pcie_res_desc *pcie;
 int i;

 for (i = 0; i < desc_count; i++) {
  if (hdr->desc_type == 0x40 ||
      hdr->desc_type == 0x50) {
   pcie = (struct be_pcie_res_desc *)hdr;
   if (pcie->pf_num == pf_num)
    return pcie;
  }

  hdr->desc_len = hdr->desc_len ? : 72;
  hdr = (void *)hdr + hdr->desc_len;
 }
 return ((void *)0);
}

static struct be_port_res_desc *be_get_port_desc(u8 *buf, u32 desc_count)
{
 struct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;
 int i;

 for (i = 0; i < desc_count; i++) {
  if (hdr->desc_type == 0x55)
   return (struct be_port_res_desc *)hdr;

  hdr->desc_len = hdr->desc_len ? : 72;
  hdr = (void *)hdr + hdr->desc_len;
 }
 return ((void *)0);
}

static void be_copy_nic_desc(struct be_resources *res,
        struct be_nic_res_desc *desc)
{
 res->max_uc_mac = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->unicast_mac_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->unicast_mac_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->unicast_mac_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->unicast_mac_count)));
 res->max_vlans = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->vlan_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->vlan_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->vlan_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->vlan_count)));
 res->max_mcast_mac = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->mcast_mac_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->mcast_mac_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->mcast_mac_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->mcast_mac_count)));
 res->max_tx_qs = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->txq_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->txq_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->txq_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->txq_count)));
 res->max_rss_qs = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->rssq_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->rssq_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->rssq_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->rssq_count)));
 res->max_rx_qs = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->rq_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->rq_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->rq_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->rq_count)));
 res->max_evt_qs = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->eq_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->eq_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->eq_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->eq_count)));
 res->max_cq_count = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->cq_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->cq_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->cq_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->cq_count)));
 res->max_iface_count = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->iface_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->iface_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->iface_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->iface_count)));
 res->max_mcc_count = (__builtin_constant_p((__u16)(( __u16)(__le16)(desc->mcc_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(desc->mcc_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(desc->mcc_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(desc->mcc_count)));

 res->if_cap_flags = (__builtin_constant_p((__u32)(( __u32)(__le32)(desc->cap_flags))) ? ((__u32)( (((__u32)(( __u32)(__le32)(desc->cap_flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(desc->cap_flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(desc->cap_flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(desc->cap_flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(desc->cap_flags))) &
    (BE_IF_FLAGS_RSS | BE_IF_FLAGS_PROMISCUOUS | BE_IF_FLAGS_BROADCAST | BE_IF_FLAGS_VLAN_PROMISCUOUS | BE_IF_FLAGS_VLAN | BE_IF_FLAGS_MCAST_PROMISCUOUS | BE_IF_FLAGS_PASS_L3L4_ERRORS | BE_IF_FLAGS_MULTICAST | BE_IF_FLAGS_UNTAGGED | BE_IF_FLAGS_DEFQ_RSS);
}


int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_func_config *req;
 int status;
 struct be_dma_mem cmd;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 memset(&cmd, 0, sizeof(struct be_dma_mem));
 cmd.size = sizeof(struct be_cmd_resp_get_func_config);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va) {
  _dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
  status = -12;
  goto err;
 }

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = cmd.va;

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          160,
          cmd.size, wrb, &cmd);

 if ((adapter->pdev->device == 0x720 || adapter->pdev->device == 0x728))
  req->hdr.version = 1;

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_func_config *resp = cmd.va;
  u32 desc_count = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->desc_count))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->desc_count)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->desc_count)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->desc_count)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->desc_count)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->desc_count)));
  struct be_nic_res_desc *desc;





  desc = be_get_func_nic_desc(resp->func_param, desc_count,
         255);
  if (!desc) {
   status = -22;
   goto err;
  }


  adapter->pf_num = desc->pf_num;
  adapter->vf_num = desc->vf_num;

  if (res)
   be_copy_nic_desc(res, desc);
 }
err:
 mutex_unlock(&adapter->mbox_lock);
 if (cmd.va)
  dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
      cmd.dma);
 return status;
}


static u16 be_get_nic_pf_num_list(u8 *buf, u32 desc_count, u16 *nic_pf_nums)
{
 struct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;
 struct be_pcie_res_desc *pcie = ((void *)0);
 int i;
 u16 nic_pf_count = 0;

 for (i = 0; i < desc_count; i++) {
  if (hdr->desc_type == 0x40 ||
      hdr->desc_type == 0x50) {
   pcie = (struct be_pcie_res_desc *)hdr;
   if (pcie->pf_state && (pcie->pf_type == 1 ||
            pcie->pf_type == 8)) {
    nic_pf_nums[nic_pf_count++] = pcie->pf_num;
   }
  }

  hdr->desc_len = hdr->desc_len ? : 72;
  hdr = (void *)hdr + hdr->desc_len;
 }
 return nic_pf_count;
}


int be_cmd_get_profile_config(struct be_adapter *adapter,
         struct be_resources *res,
         struct be_port_resources *port_res,
         u8 profile_type, u8 query, u8 domain)
{
 struct be_cmd_resp_get_profile_config *resp;
 struct be_cmd_req_get_profile_config *req;
 struct be_nic_res_desc *vf_res;
 struct be_pcie_res_desc *pcie;
 struct be_port_res_desc *port;
 struct be_nic_res_desc *nic;
 struct be_mcc_wrb wrb = {0};
 struct be_dma_mem cmd;
 u16 desc_count;
 int status;

 memset(&cmd, 0, sizeof(struct be_dma_mem));
 cmd.size = sizeof(struct be_cmd_resp_get_profile_config);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va)
  return -12;

 req = cmd.va;
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          164,
          cmd.size, &wrb, &cmd);

 if (!(adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228))
  req->hdr.version = 1;
 req->type = profile_type;
 req->hdr.domain = domain;





 if (query == RESOURCE_MODIFIABLE)
  req->type |= ((((1UL))) << (3));

 status = be_cmd_notify_wait(adapter, &wrb);
 if (status)
  goto err;

 resp = cmd.va;
 desc_count = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->desc_count))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->desc_count)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->desc_count)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->desc_count)));

 if (port_res) {
  u16 nic_pf_cnt = 0, i;
  u16 nic_pf_num_list[16];

  nic_pf_cnt = be_get_nic_pf_num_list(resp->func_param,
          desc_count,
          nic_pf_num_list);

  for (i = 0; i < nic_pf_cnt; i++) {
   nic = be_get_func_nic_desc(resp->func_param, desc_count,
         nic_pf_num_list[i]);
   if (nic->link_param == adapter->port_num) {
    port_res->nic_pfs++;
    pcie = be_get_pcie_desc(resp->func_param,
       desc_count,
       nic_pf_num_list[i]);
    port_res->max_vfs += (__builtin_constant_p((__u16)(( __u16)(__le16)(pcie->num_vfs))) ? ((__u16)( (((__u16)(( __u16)(__le16)(pcie->num_vfs)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(pcie->num_vfs)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(pcie->num_vfs)));
   }
  }
  goto err;
 }

 pcie = be_get_pcie_desc(resp->func_param, desc_count,
    adapter->pf_num);
 if (pcie)
  res->max_vfs = (__builtin_constant_p((__u16)(( __u16)(__le16)(pcie->num_vfs))) ? ((__u16)( (((__u16)(( __u16)(__le16)(pcie->num_vfs)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(pcie->num_vfs)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(pcie->num_vfs)));

 port = be_get_port_desc(resp->func_param, desc_count);
 if (port)
  adapter->mc_type = port->mc_type;

 nic = be_get_func_nic_desc(resp->func_param, desc_count,
       adapter->pf_num);
 if (nic)
  be_copy_nic_desc(res, nic);

 vf_res = be_get_vft_desc(resp->func_param, desc_count,
     adapter->pf_num);
 if (vf_res)
  res->vf_if_cap_flags = vf_res->cap_flags;
err:
 if (cmd.va)
  dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
      cmd.dma);
 return status;
}


static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,
         int size, int count, u8 version, u8 domain)
{
 struct be_cmd_req_set_profile_config *req;
 struct be_mcc_wrb wrb = {0};
 struct be_dma_mem cmd;
 int status;

 memset(&cmd, 0, sizeof(struct be_dma_mem));
 cmd.size = sizeof(struct be_cmd_req_set_profile_config);
 cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
        ((( gfp_t)0x20u)|(( gfp_t)0x200u)|(( gfp_t)0x800u)));
 if (!cmd.va)
  return -12;

 req = cmd.va;
 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          165, cmd.size,
          &wrb, &cmd);
 req->hdr.version = version;
 req->hdr.domain = domain;
 req->desc_count = (( __le32)(__builtin_constant_p((__u32)((count))) ? ((__u32)( (((__u32)((count)) & (__u32)0x000000ffUL) << 24) | (((__u32)((count)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((count)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((count)) & (__u32)0xff000000UL) >> 24))) : __fswab32((count))));
 memcpy(req->desc, desc, size);

 status = be_cmd_notify_wait(adapter, &wrb);

 if (cmd.va)
  dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
      cmd.dma);
 return status;
}


static void be_reset_nic_desc(struct be_nic_res_desc *nic)
{
 memset(nic, 0, sizeof(*nic));
 nic->unicast_mac_count = 0xFFFF;
 nic->mcc_count = 0xFFFF;
 nic->vlan_count = 0xFFFF;
 nic->mcast_mac_count = 0xFFFF;
 nic->txq_count = 0xFFFF;
 nic->rq_count = 0xFFFF;
 nic->rssq_count = 0xFFFF;
 nic->lro_count = 0xFFFF;
 nic->cq_count = 0xFFFF;
 nic->toe_conn_count = 0xFFFF;
 nic->eq_count = 0xFFFF;
 nic->iface_count = 0xFFFF;
 nic->link_param = 0xFF;
 nic->channel_id_param = (( __le16)(__builtin_constant_p((__u16)((0xF000))) ? ((__u16)( (((__u16)((0xF000)) & (__u16)0x00ffU) << 8) | (((__u16)((0xF000)) & (__u16)0xff00U) >> 8))) : __fswab16((0xF000))));
 nic->acpi_params = 0xFF;
 nic->wol_param = 0x0F;
 nic->tunnel_iface_count = 0xFFFF;
 nic->direct_tenant_iface_count = 0xFFFF;
 nic->bw_min = 0xFFFFFFFF;
 nic->bw_max = 0xFFFFFFFF;
}


static void be_reset_pcie_desc(struct be_pcie_res_desc *pcie)
{
 memset(pcie, 0, sizeof(*pcie));
 pcie->sriov_state = 0xFF;
 pcie->pf_state = 0xFF;
 pcie->pf_type = 0xFF;
 pcie->num_vfs = 0xFFFF;
}

int be_cmd_config_qos(struct be_adapter *adapter, u32 max_rate, u16 link_speed,
        u8 domain)
{
 struct be_nic_res_desc nic_desc;
 u32 bw_percent;
 u16 version = 0;

 if ((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710))
  return be_cmd_set_qos(adapter, max_rate / 10, domain);

 be_reset_nic_desc(&nic_desc);
 nic_desc.pf_num = adapter->pf_num;
 nic_desc.vf_num = domain;
 nic_desc.bw_min = 0;
 if ((adapter->pdev->device == 0xe220 || adapter->pdev->device == 0xe228)) {
  nic_desc.hdr.desc_type = 0x41;
  nic_desc.hdr.desc_len = 72;
  nic_desc.flags = (1 << 4) | (1 << 6) |
     (1 << 7);
  nic_desc.bw_max = (( __le32)(__builtin_constant_p((__u32)((max_rate / 10))) ? ((__u32)( (((__u32)((max_rate / 10)) & (__u32)0x000000ffUL) << 24) | (((__u32)((max_rate / 10)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((max_rate / 10)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((max_rate / 10)) & (__u32)0xff000000UL) >> 24))) : __fswab32((max_rate / 10))));
 } else {
  version = 1;
  nic_desc.hdr.desc_type = 0x51;
  nic_desc.hdr.desc_len = 88;
  nic_desc.flags = (1 << 6) | (1 << 7);
  bw_percent = max_rate ? (max_rate * 100) / link_speed : 100;
  nic_desc.bw_max = (( __le32)(__builtin_constant_p((__u32)((bw_percent))) ? ((__u32)( (((__u32)((bw_percent)) & (__u32)0x000000ffUL) << 24) | (((__u32)((bw_percent)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((bw_percent)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((bw_percent)) & (__u32)0xff000000UL) >> 24))) : __fswab32((bw_percent))));
 }

 return be_cmd_set_profile_config(adapter, &nic_desc,
      nic_desc.hdr.desc_len,
      1, version, domain);
}

int be_cmd_set_sriov_config(struct be_adapter *adapter,
       struct be_resources pool_res, u16 num_vfs,
       struct be_resources *vft_res)
{
 struct {
  struct be_pcie_res_desc pcie;
  struct be_nic_res_desc nic_vft;
 } __attribute__((__packed__)) desc;


 be_reset_pcie_desc(&desc.pcie);
 desc.pcie.hdr.desc_type = 0x50;
 desc.pcie.hdr.desc_len = 88;
 desc.pcie.flags = ((((1UL))) << (6)) | ((((1UL))) << (7));
 desc.pcie.pf_num = adapter->pdev->devfn;
 desc.pcie.sriov_state = num_vfs ? 1 : 0;
 desc.pcie.num_vfs = (( __le16)(__builtin_constant_p((__u16)((num_vfs))) ? ((__u16)( (((__u16)((num_vfs)) & (__u16)0x00ffU) << 8) | (((__u16)((num_vfs)) & (__u16)0xff00U) >> 8))) : __fswab16((num_vfs))));


 be_reset_nic_desc(&desc.nic_vft);
 desc.nic_vft.hdr.desc_type = 0x51;
 desc.nic_vft.hdr.desc_len = 88;
 desc.nic_vft.flags = vft_res->flags | ((((1UL))) << (3)) |
        ((((1UL))) << (6)) | ((((1UL))) << (7));
 desc.nic_vft.pf_num = adapter->pdev->devfn;
 desc.nic_vft.vf_num = 0;
 desc.nic_vft.cap_flags = (( __le32)(__builtin_constant_p((__u32)((vft_res->vf_if_cap_flags))) ? ((__u32)( (((__u32)((vft_res->vf_if_cap_flags)) & (__u32)0x000000ffUL) << 24) | (((__u32)((vft_res->vf_if_cap_flags)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((vft_res->vf_if_cap_flags)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((vft_res->vf_if_cap_flags)) & (__u32)0xff000000UL) >> 24))) : __fswab32((vft_res->vf_if_cap_flags))));
 desc.nic_vft.rq_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_rx_qs))) ? ((__u16)( (((__u16)((vft_res->max_rx_qs)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_rx_qs)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_rx_qs))));
 desc.nic_vft.txq_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_tx_qs))) ? ((__u16)( (((__u16)((vft_res->max_tx_qs)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_tx_qs)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_tx_qs))));
 desc.nic_vft.rssq_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_rss_qs))) ? ((__u16)( (((__u16)((vft_res->max_rss_qs)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_rss_qs)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_rss_qs))));
 desc.nic_vft.cq_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_cq_count))) ? ((__u16)( (((__u16)((vft_res->max_cq_count)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_cq_count)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_cq_count))));

 if (vft_res->max_uc_mac)
  desc.nic_vft.unicast_mac_count =
     (( __le16)(__builtin_constant_p((__u16)((vft_res->max_uc_mac))) ? ((__u16)( (((__u16)((vft_res->max_uc_mac)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_uc_mac)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_uc_mac))));
 if (vft_res->max_vlans)
  desc.nic_vft.vlan_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_vlans))) ? ((__u16)( (((__u16)((vft_res->max_vlans)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_vlans)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_vlans))));
 if (vft_res->max_iface_count)
  desc.nic_vft.iface_count =
    (( __le16)(__builtin_constant_p((__u16)((vft_res->max_iface_count))) ? ((__u16)( (((__u16)((vft_res->max_iface_count)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_iface_count)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_iface_count))));
 if (vft_res->max_mcc_count)
  desc.nic_vft.mcc_count = (( __le16)(__builtin_constant_p((__u16)((vft_res->max_mcc_count))) ? ((__u16)( (((__u16)((vft_res->max_mcc_count)) & (__u16)0x00ffU) << 8) | (((__u16)((vft_res->max_mcc_count)) & (__u16)0xff00U) >> 8))) : __fswab16((vft_res->max_mcc_count))));

 return be_cmd_set_profile_config(adapter, &desc,
      2 * 88, 2, 1, 0);
}

int be_cmd_manage_iface(struct be_adapter *adapter, u32 iface, u8 op)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_manage_iface_filters *req;
 int status;

 if (iface == 0xFFFFFFFF)
  return -1;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          193, sizeof(*req),
          wrb, ((void *)0));
 req->op = op;
 req->target_iface_id = (( __le32)(__builtin_constant_p((__u32)((iface))) ? ((__u32)( (((__u32)((iface)) & (__u32)0x000000ffUL) << 24) | (((__u32)((iface)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((iface)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((iface)) & (__u32)0xff000000UL) >> 24))) : __fswab32((iface))));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_set_vxlan_port(struct be_adapter *adapter, __be16 port)
{
 struct be_port_res_desc port_desc;

 memset(&port_desc, 0, sizeof(port_desc));
 port_desc.hdr.desc_type = 0x55;
 port_desc.hdr.desc_len = 88;
 port_desc.flags = (1 << 6) | (1 << 7);
 port_desc.link_num = adapter->hba_port_num;
 if (port) {
  port_desc.nv_flags = 3 | (1 << 2) |
     (1 << 4);
  port_desc.nv_port = (__builtin_constant_p((__u16)(port)) ? ((__u16)( (((__u16)(port) & (__u16)0x00ffU) << 8) | (((__u16)(port) & (__u16)0xff00U) >> 8))) : __fswab16(port));
 } else {
  port_desc.nv_flags = 1;
  port_desc.nv_port = 0;
 }

 return be_cmd_set_profile_config(adapter, &port_desc,
      88, 1, 1, 0);
}

int be_cmd_get_if_id(struct be_adapter *adapter, struct be_vf_cfg *vf_cfg,
       int vf_num)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_get_iface_list *req;
 struct be_cmd_resp_get_iface_list *resp;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          194, sizeof(*resp),
          wrb, ((void *)0));
 req->hdr.domain = vf_num + 1;

 status = be_mcc_notify_wait(adapter);
 if (!status) {
  resp = (struct be_cmd_resp_get_iface_list *)req;
  vf_cfg->if_handle = (__builtin_constant_p((__u32)(( __u32)(__le32)(resp->if_desc.if_id))) ? ((__u32)( (((__u32)(( __u32)(__le32)(resp->if_desc.if_id)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__le32)(resp->if_desc.if_id)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__le32)(resp->if_desc.if_id)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__le32)(resp->if_desc.if_id)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__le32)(resp->if_desc.if_id)));
 }

err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

static int lancer_wait_idle(struct be_adapter *adapter)
{

 u32 reg_val;
 int status = 0, i;

 for (i = 0; i < 30; i++) {
  reg_val = ioread32(adapter->db + 0x414);
  if ((reg_val & 0x40000000) == 0)
   break;

  ssleep(1);
 }

 if (i == 30)
  status = -1;

 return status;
}

int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask)
{
 int status = 0;

 status = lancer_wait_idle(adapter);
 if (status)
  return status;

 iowrite32(mask, adapter->db + 0x414);

 return status;
}


bool dump_present(struct be_adapter *adapter)
{
 u32 sliport_status = 0;

 sliport_status = ioread32(adapter->db + 0x404);
 return !!(sliport_status & 0x02000000);
}

int lancer_initiate_dump(struct be_adapter *adapter)
{
 struct device *dev = &adapter->pdev->dev;
 int status;

 if (dump_present(adapter)) {
  _dev_info(dev, "Previous dump not cleared, not forcing dump\n");
  return -17;
 }


 status = lancer_physdev_ctrl(adapter, 0x00000002 |
         0x00000004);
 if (status < 0) {
  _dev_err(dev, "FW reset failed\n");
  return status;
 }

 status = lancer_wait_idle(adapter);
 if (status)
  return status;

 if (!dump_present(adapter)) {
  _dev_err(dev, "FW dump not generated\n");
  return -5;
 }

 return 0;
}

int lancer_delete_dump(struct be_adapter *adapter)
{
 int status;

 status = lancer_cmd_delete_object(adapter, "/dbg/dump.bin");
 return (status > 0 ? -5 : status);
}


int be_cmd_enable_vf(struct be_adapter *adapter, u8 domain)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_enable_disable_vf *req;
 int status;

 if (((adapter->pdev->device == 0x221 || adapter->pdev->device == 0x710) || (adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700)))
  return 0;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          196, sizeof(*req),
          wrb, ((void *)0));

 req->hdr.domain = domain;
 req->enable = 1;
 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_intr_set(struct be_adapter *adapter, bool intr_enable)
{
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_intr_set *req;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          89, sizeof(*req),
          wrb, ((void *)0));

 req->intr_enabled = intr_enable;

 status = be_mbox_notify_wait(adapter);

 mutex_unlock(&adapter->mbox_lock);
 return status;
}


int be_cmd_get_active_profile(struct be_adapter *adapter, u16 *profile_id)
{
 struct be_cmd_req_get_active_profile *req;
 struct be_mcc_wrb *wrb;
 int status;

 if (mutex_lock_interruptible(&adapter->mbox_lock))
  return -1;

 wrb = wrb_from_mbox(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          167, sizeof(*req),
          wrb, ((void *)0));

 status = be_mbox_notify_wait(adapter);
 if (!status) {
  struct be_cmd_resp_get_active_profile *resp =
       embedded_payload(wrb);

  *profile_id = (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->active_profile_id))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->active_profile_id)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->active_profile_id)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->active_profile_id)));
 }

err:
 mutex_unlock(&adapter->mbox_lock);
 return status;
}

static int
__be_cmd_set_logical_link_config(struct be_adapter *adapter,
     int link_state, int version, u8 domain)
{
 struct be_cmd_req_set_ll_link *req;
 struct be_mcc_wrb *wrb;
 u32 link_config = 0;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          80,
          sizeof(*req), wrb, ((void *)0));

 req->hdr.version = version;
 req->hdr.domain = domain;

 if (link_state == IFLA_VF_LINK_STATE_ENABLE ||
     link_state == IFLA_VF_LINK_STATE_AUTO)
  link_config |= ((((1UL))) << (0));

 if (link_state == IFLA_VF_LINK_STATE_AUTO)
  link_config |= ((((1UL))) << (8));

 req->link_config = (( __le32)(__builtin_constant_p((__u32)((link_config))) ? ((__u32)( (((__u32)((link_config)) & (__u32)0x000000ffUL) << 24) | (((__u32)((link_config)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((link_config)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((link_config)) & (__u32)0xff000000UL) >> 24))) : __fswab32((link_config))));

 status = be_mcc_notify_wait(adapter);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_cmd_set_logical_link_config(struct be_adapter *adapter,
       int link_state, u8 domain)
{
 int status;

 if ((adapter->pdev->device == 0x211 || adapter->pdev->device == 0x700))
  return -95;

 status = __be_cmd_set_logical_link_config(adapter, link_state,
        2, domain);




 if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_REQUEST)
  status = __be_cmd_set_logical_link_config(adapter, link_state,
         1, domain);
 return status;
}

int be_cmd_set_features(struct be_adapter *adapter)
{
 struct be_cmd_resp_set_features *resp;
 struct be_cmd_req_set_features *req;
 struct be_mcc_wrb *wrb;
 int status;

 if (mutex_lock_interruptible(&adapter->mcc_lock))
  return -1;

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }

 req = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(&req->hdr, 0x1,
          191,
          sizeof(*req), wrb, ((void *)0));

 req->features = (( __le32)(__builtin_constant_p((__u32)((0x10))) ? ((__u32)( (((__u32)((0x10)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x10)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x10)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x10)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x10))));
 req->parameter_len = (( __le32)(__builtin_constant_p((__u32)((sizeof(struct be_req_ue_recovery)))) ? ((__u32)( (((__u32)((sizeof(struct be_req_ue_recovery))) & (__u32)0x000000ffUL) << 24) | (((__u32)((sizeof(struct be_req_ue_recovery))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((sizeof(struct be_req_ue_recovery))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((sizeof(struct be_req_ue_recovery))) & (__u32)0xff000000UL) >> 24))) : __fswab32((sizeof(struct be_req_ue_recovery)))));
 req->parameter.req.uer = (( __le32)(__builtin_constant_p((__u32)((0x1))) ? ((__u32)( (((__u32)((0x1)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x1)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x1)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x1)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x1))));

 status = be_mcc_notify_wait(adapter);
 if (status)
  goto err;

 resp = embedded_payload(wrb);

 adapter->error_recovery.ue_to_poll_time =
  (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2rp))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2rp)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2rp)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->parameter.resp.ue2rp)));
 adapter->error_recovery.ue_to_reset_time =
  (__builtin_constant_p((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2sr))) ? ((__u16)( (((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2sr)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__le16)(resp->parameter.resp.ue2sr)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__le16)(resp->parameter.resp.ue2sr)));
 adapter->error_recovery.recovery_supported = true;
err:



 if (((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_ILLEGAL_REQUEST ||
     ((enum mcc_base_status) (status > 0 ? (status & 0xFFFF) : 0)) == MCC_STATUS_INVALID_LENGTH)
  _dev_info(&adapter->pdev->dev, "Adapter does not support HW error recovery\n");


 mutex_unlock(&adapter->mcc_lock);
 return status;
}

int be_roce_mcc_cmd(void *netdev_handle, void *wrb_payload,
      int wrb_payload_size, u16 *cmd_status, u16 *ext_status)
{
 struct be_adapter *adapter = netdev_priv(netdev_handle);
 struct be_mcc_wrb *wrb;
 struct be_cmd_req_hdr *hdr = (struct be_cmd_req_hdr *)wrb_payload;
 struct be_cmd_req_hdr *req;
 struct be_cmd_resp_hdr *resp;
 int status;

 mutex_lock(&adapter->mcc_lock);

 wrb = wrb_from_mccq(adapter);
 if (!wrb) {
  status = -16;
  goto err;
 }
 req = embedded_payload(wrb);
 resp = embedded_payload(wrb);

 be_wrb_cmd_hdr_prepare(req, hdr->subsystem,
          hdr->opcode, wrb_payload_size, wrb, ((void *)0));
 memcpy(req, wrb_payload, wrb_payload_size);
 swap_dws(req, wrb_payload_size);

 status = be_mcc_notify_wait(adapter);
 if (cmd_status)
  *cmd_status = (status & 0xffff);
 if (ext_status)
  *ext_status = 0;
 memcpy(wrb_payload, resp, sizeof(*resp) + resp->response_length);
 swap_dws(wrb_payload, sizeof(*resp) + resp->response_length);
err:
 mutex_unlock(&adapter->mcc_lock);
 return status;
}
extern typeof(be_roce_mcc_cmd) be_roce_mcc_cmd; extern const char __kstrtab_be_roce_mcc_cmd[]; extern const char __kstrtabns_be_roce_mcc_cmd[]; asm("	.section \"___kcrctab" "" "+" "be_roce_mcc_cmd" "\", \"a\"	\n" "	.weak	__crc_" "be_roce_mcc_cmd" "				\n" "	.long	__crc_" "be_roce_mcc_cmd" " - .			\n" "	.previous					\n"); asm("	.section \"__ksymtab_strings\",\"aMS\",%progbits,1	\n" "__kstrtab_" "be_roce_mcc_cmd" ":					\n" "	.asciz 	\"" "be_roce_mcc_cmd" "\"					\n" "__kstrtabns_" "be_roce_mcc_cmd" ":					\n" "	.asciz 	\"" "" "\"					\n" "	.previous						\n"); static const struct kernel_symbol __ksymtab_be_roce_mcc_cmd __attribute__((section("___ksymtab" "" "+" "be_roce_mcc_cmd"), used)) __attribute__((__aligned__(sizeof(void *)))) = { (unsigned long)&be_roce_mcc_cmd, __kstrtab_be_roce_mcc_cmd, __kstrtabns_be_roce_mcc_cmd };
